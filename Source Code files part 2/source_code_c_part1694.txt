mage with that 
// attachment.  This is not a serious limitation since
// all cameras store their attachments in the same
// folder as their image.
//
HRESULT FakeCamera::SearchDirEx(ITEM_HANDLE_ARRAY *pItemArray,
                                ITEM_HANDLE ParentHandle,
                                LPOLESTR Path)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::SearchDirEx");
    
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR TempStr[MAX_PATH];
    FSUSD_FILE_DATA *pFFD_array=NULL;
    DWORD     dwNumFilesInArray=0;
    DWORD     dwCurArraySize=0;


    //
    // Search for everything, except ".", "..", and hidden files, put them in pFFD_array
    //
    swprintf(TempStr, L"%s\\%s", Path, L"*");
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SearchDirEx, searching directory %S", TempStr));

    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFile(TempStr, &FindData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, empty directory %S", TempStr));
            hr = S_OK;
        }
        else
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, FindFirstFile failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
        goto Cleanup;
    }

    pFFD_array = (FSUSD_FILE_DATA *)CoTaskMemAlloc(sizeof(FSUSD_FILE_DATA)*FFD_ALLOCATION_INCREMENT);
    if( !pFFD_array )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    dwCurArraySize = FFD_ALLOCATION_INCREMENT;

    while (hr == S_OK)
    {
        if( wcscmp(FindData.cFileName, L".") &&
            wcscmp(FindData.cFileName, L"..") &&
            !(FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) )
        {
             pFFD_array[dwNumFilesInArray].dwFileAttributes = FindData.dwFileAttributes;
             pFFD_array[dwNumFilesInArray].ftFileTime = FindData.ftLastWriteTime;
             pFFD_array[dwNumFilesInArray].dwFileSize = FindData.nFileSizeLow;
             pFFD_array[dwNumFilesInArray].dwProcessed = 0;
             wcscpy(pFFD_array[dwNumFilesInArray].cFileName, FindData.cFileName);
             dwNumFilesInArray++;

             if( (dwNumFilesInArray & (FFD_ALLOCATION_INCREMENT-1)) == (FFD_ALLOCATION_INCREMENT-1) )
             {   // Time to allocate more memory 
                pFFD_array = (FSUSD_FILE_DATA *)CoTaskMemRealloc(pFFD_array, (sizeof(FSUSD_FILE_DATA)*(dwCurArraySize+FFD_ALLOCATION_INCREMENT)));
                if( !pFFD_array )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                dwCurArraySize += FFD_ALLOCATION_INCREMENT;
             }
        }
        
        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, FindNextFile failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    hFind = INVALID_HANDLE_VALUE;
    
    
    // Now that all names under current directory are in the array, do analysis on them
    
    // 1. Find JPG images and their attachments
    ULONG uImageType;
    UINT nFormatCode;
    ITEM_HANDLE ImageHandle;
    for(DWORD i=0; i<dwNumFilesInArray; i++)
    {
        if( pFFD_array[i].dwProcessed )
            continue;
        if( !((pFFD_array[i].dwFileAttributes) & FILE_ATTRIBUTE_DIRECTORY))
        {
            uImageType = GetImageTypeFromFilename(pFFD_array[i].cFileName, &nFormatCode);
            if( nFormatCode > m_NumFormatInfo )
            {   // Something really weird happened
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Aborting SearchDirEx, Format index overflow"));
                hr = E_FAIL;
                goto Cleanup;
            }
            if( m_FormatInfo[nFormatCode].FormatGuid == WiaImgFmt_JPEG )
            {
                // Add this item
                hr = CreateItemEx(ParentHandle, &(pFFD_array[i]), &ImageHandle, nFormatCode);
                if (FAILED(hr))
                {
                   WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, CreateImage failed"));
                   goto Cleanup;
                }

                if (!pItemArray->Add(ImageHandle))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, Add failed"));
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                pFFD_array[i].dwProcessed = 1;
                ImageHandle->bHasAttachments = FALSE;
                m_NumImages ++;

                swprintf(TempStr, L"%s\\%s", Path, pFFD_array[i].cFileName);
                hr = SearchForAttachments(pItemArray, ImageHandle, TempStr, pFFD_array, dwNumFilesInArray);
                if (FAILED(hr))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDir, SearchForAttachments failed"));
                    goto Cleanup;
                }

                if (hr == S_OK)
                {
                    ImageHandle->bHasAttachments = TRUE;
                }
                ImageHandle->bIsFolder = FALSE;
                hr = S_OK;

            }
        }
    }   // end of JPEG images and attachments

    // 2. For other items that are not processed.
    for(i=0; i<dwNumFilesInArray; i++)
    {
        if( pFFD_array[i].dwProcessed )
            continue;

        if ((pFFD_array[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))  // for folder
        {
             hr = CreateFolderEx(ParentHandle, &(pFFD_array[i]), &ImageHandle);
             if (FAILED(hr))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, CreateFolder failed"));
                 goto Cleanup;
             }

             if (!pItemArray->Add(ImageHandle))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, Add failed"));
                 hr = E_OUTOFMEMORY;
                 goto Cleanup;
             }

             swprintf(TempStr, L"%s\\%s", Path, pFFD_array[i].cFileName);
             hr = SearchDirEx(pItemArray, ImageHandle, TempStr);
             if (FAILED(hr))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, recursive SearchDir failed"));
                 goto Cleanup;
             }
             pFFD_array[i].dwProcessed = 1;
             ImageHandle->bHasAttachments = FALSE;
             ImageHandle->bIsFolder = TRUE;
         } 
         else 
         {   // for files

             uImageType = GetImageTypeFromFilename(pFFD_array[i].cFileName, &nFormatCode);

 #ifdef GDIPLUS_CHECK
             if( (ITEMTYPE_IMAGE == uImageType) && 
                 !IsFormatSupportedByGDIPlus(m_FormatInfo[nFormatCode].FormatGuid))
             {
                 uImageType = ITEMTYPE_FILE;    // Force to create non-image item
                 m_FormatInfo[nFormatCode].ItemType = uImageType;
                 m_FormatInfo[nFormatCode].FormatGuid = WiaImgFmt_UNDEFINED;
             }
 #endif            
             hr = CreateItemEx(ParentHandle, &(pFFD_array[i]), &ImageHandle, nFormatCode);
             if (FAILED(hr))
             {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, CreateImage failed"));
                goto Cleanup;
             }

             if (!pItemArray->Add(ImageHandle))
             {
                 WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchDirEx, Add failed"));
                 hr = E_OUTOFMEMORY;
                 goto Cleanup;
             }

             pFFD_array[i].dwProcessed = 1;
             ImageHandle->bHasAttachments = FALSE;
             ImageHandle->bIsFolder = FALSE;

             if(ITEMTYPE_IMAGE == uImageType) 
             {
                 m_NumImages ++;
             }
             hr = S_OK;
         }
    }
    hr = S_OK;

Cleanup:
    if( hFind != INVALID_HANDLE_VALUE ) 
        FindClose(hFind);
    if( pFFD_array )
        CoTaskMemFree(pFFD_array);
    return hr;
}

//
// Searches for attachments to an image item
//

inline BOOL CompareAttachmentStrings(WCHAR *pParentStr, WCHAR *pStr2)
{
    WCHAR *pSlash = wcsrchr(pStr2, L'\\');
    WCHAR *pStrTmp;

    if( pSlash )
        pStrTmp = pSlash+1;
    else
        pStrTmp = pStr2;
    
    if( wcslen(pParentStr) == 8 && wcscmp(pParentStr+4, L"0000") > 0 && wcscmp(pParentStr+4, L"9999") < 0 )
    {
        if( wcslen(pStrTmp) < 8 ) 
            return FALSE;
        return (CSTR_EQUAL == CompareString( LOCALE_SYSTEM_DEFAULT, 0, pParentStr+4, 4, pStrTmp+4, 4) );
    }
    else
    {
        WCHAR pStr22[MAX_PATH];
        wcscpy(pStr22, pStrTmp);
        WCHAR *pDot = wcsrchr(pStr22, L'.');

        if(pDot )
            *pDot = L'\0';
        return (CSTR_EQUAL == CompareString( LOCALE_SYSTEM_DEFAULT, 0, pParentStr, -1, pStr22, -1) );
    }
}

HRESULT FakeCamera::SearchForAttachments(ITEM_HANDLE_ARRAY *pItemArray,
                                         ITEM_HANDLE ParentHandle,
                                         LPOLESTR Path,
                                         FSUSD_FILE_DATA *pFFD_Current,
                                         DWORD dwNumOfFiles)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::SearchForAttachments");
    HRESULT hr = S_FALSE;

    int NumAttachments = 0;

    //
    //  Attachment is defined as any non-image item whose extension is different than the parent but 
    //  the filename is the same except the first 4 letters.
    //
    
    WCHAR TempStrParent[MAX_PATH];
    WCHAR *pTemp;

    pTemp = wcsrchr(Path, L'\\');
    if (pTemp)
    {
        wcscpy(TempStrParent, pTemp+1);
    }
    else
    {
        wcscpy(TempStrParent, Path);
    }

    //
    // Chop the extension
    //
    
    WCHAR *pDot = wcsrchr(TempStrParent, L'.');
    
    if (pDot)
    {
        *(pDot) = L'\0';
    }
    else
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchForAttachments, filename did not contain a dot"));
        return E_INVALIDARG;
    }

    ITEM_HANDLE NonImageHandle;
    UINT nFormatCode;
    ULONG uImageType; 
    for(DWORD i=0; i<dwNumOfFiles; i++)
    {
        if (!(pFFD_Current[i].dwProcessed) && !(pFFD_Current[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            nFormatCode=0;
            uImageType = GetImageTypeFromFilename(pFFD_Current[i].cFileName, &nFormatCode);

            if( (uImageType != ITEMTYPE_IMAGE) &&
                CompareAttachmentStrings(TempStrParent, pFFD_Current[i].cFileName) )
            {
                hr = CreateItemEx(ParentHandle, &(pFFD_Current[i]), &NonImageHandle, nFormatCode);
                if (FAILED(hr))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchForAttachments, CreateItemEx failed"));
                    return hr;
                }
                if (!pItemArray->Add(NonImageHandle))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SearchForAttachments, Add failed"));
                    return E_OUTOFMEMORY;
                }

                pFFD_Current[i].dwProcessed = 1;
                NonImageHandle->bIsFolder = FALSE;
                NumAttachments++;
            }
        }
    } // end of FOR loop
 
    if( NumAttachments > 0 )
        hr = S_OK;
    else
        hr = S_FALSE;
    return hr;    
}


HRESULT FakeCamera::CreateFolderEx(ITEM_HANDLE ParentHandle,
                                 FSUSD_FILE_DATA *pFindData,
                                 ITEM_HANDLE *pFolderHandle)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::CreateFolder");
    HRESULT hr = S_OK;

    if (!pFolderHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateFolder, invalid arg"));
        return E_INVALIDARG;
    }

    *pFolderHandle = new ITEM_INFO;
    if (!*pFolderHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateFolder, memory allocation failed"));
        return E_OUTOFMEMORY;
    }


    //
    // Initialize the ItemInfo structure
    //
    ITEM_INFO *pItemInfo = *pFolderHandle;
    memset(pItemInfo, 0, sizeof(ITEM_INFO));
    
    //
    // Fill in the other item information
    //
    pItemInfo->Parent = ParentHandle;
    pItemInfo->pName = SysAllocString(pFindData->cFileName);
    memset(&pItemInfo->Time, 0, sizeof(SYSTEMTIME));
    FILETIME ftLocalFileTime;
    FileTimeToLocalFileTime(&pFindData->ftFileTime, &ftLocalFileTime);
    if (!FileTimeToSystemTime(&ftLocalFileTime, &pItemInfo->Time))
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateFolder, couldn't convert file time to system time"));
    pItemInfo->Format = 0;
    pItemInfo->bReadOnly = pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY;
    pItemInfo->bCanSetReadOnly = TRUE;
    pItemInfo->bIsFolder = TRUE;

    m_NumItems++;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,
                ("CreateFolder, created folder %S at 0x%08x under 0x%08x",
                 pFindData->cFileName, pItemInfo, ParentHandle));

    return hr;
}


HRESULT FakeCamera::CreateItemEx(ITEM_HANDLE ParentHandle,
                                   FSUSD_FILE_DATA *pFileData,
                                   ITEM_HANDLE *pItemHandle,
                                   UINT nFormatCode)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::CreateNonImage");
    HRESULT hr = S_OK;

    if (!pItemHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateNonImage, invalid arg"));
        return E_INVALIDARG;
    }

    *pItemHandle = new ITEM_INFO;
    if (!*pItemHandle )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateNonImage, memory allocation failed"));
        return E_OUTOFMEMORY;
    }


    //
    // The name cannot contain a dot and the name needs to be unique
    // wrt the parent image, so replace the dot with an underline character.
    //
    WCHAR TempStr[MAX_PATH];
    wcscpy(TempStr, pFileData->cFileName);

    //
    // Initialize the ItemInfo structure
    //
    ITEM_INFO *pItemInfo = *pItemHandle;
    memset(pItemInfo, 0, sizeof(ITEM_INFO));
    
    pItemInfo->Format = nFormatCode;
    if (nFormatCode) {  // if known extension, it will be handled by the format code
        WCHAR *pDot = wcsrchr(TempStr, L'.');
        if (pDot)
            *pDot = L'\0';
    }

    //
    // Fill in the other item information
    //
    pItemInfo->Parent = ParentHandle;
    pItemInfo->pName = SysAllocString(TempStr);
    memset(&pItemInfo->Time, 0, sizeof(SYSTEMTIME));
    FILETIME ftLocalFileTime;
    FileTimeToLocalFileTime(&pFileData->ftFileTime, &ftLocalFileTime);
    if (!FileTimeToSystemTime(&ftLocalFileTime, &pItemInfo->Time))
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateNonImage, couldn't convert file time to system time"));
    pItemInfo->Size = pFileData->dwFileSize;
    pItemInfo->bReadOnly = pFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY;
    pItemInfo->bCanSetReadOnly = TRUE;
    pItemInfo->bIsFolder = FALSE;
                                
    m_NumItems++;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,
                ("CreateNonImage, created non-image %S at 0x%08x under 0x%08x",
                 pFileData->cFileName, pItemInfo, ParentHandle));

    return hr;
}

//
// Construct the full path name of the item by traversing its parents
//
VOID FakeCamera::ConstructFullName(WCHAR *pFullName, ITEM_INFO *pItemInfo, BOOL bAddExt)
{
    if (pItemInfo->Parent)
        ConstructFullName(pFullName, pItemInfo->Parent, FALSE);
    else
        wcscpy(pFullName, m_RootPath);

    //
    // If this item has attachments and we're creating the name for its children,
    // don't add its name (it's a repeat of the child's name)
    //
    WCHAR *pTmp;
    if( pItemInfo->Parent && pItemInfo->Parent->bHasAttachments )
    {
        pTmp = wcsrchr(pFullName, L'\\');
        if( pTmp )
        {
            *pTmp = L'\0';
        }
    }
    
    wcscat(pFullName, L"\\");
    wcscat(pFullName, pItemInfo->pName);
    
    if (bAddExt)
    {
        if( pItemInfo->Format > 0 && pItemInfo->Format < (INT)m_NumFormatInfo )
        {
            wcscat(pFullName, L".");
            wcscat(pFullName, m_FormatInfo[pItemInfo->Format].ExtensionString);
        }
    }
}

//
// Frees the item info structure
//
VOID FakeCamera::FreeItemInfo(ITEM_INFO *pItemInfo)
{
    if (pItemInfo)
    {
        if (pItemInfo->pName)
        {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("FreeItemInfo, removing %S", pItemInfo->pName));

            SysFreeString(pItemInfo->pName);
            pItemInfo->pName = NULL;
        }

        if (!m_ItemHandles.Remove(pItemInfo))
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FreeItemInfo, couldn't remove handle from array"));

        if (m_FormatInfo[pItemInfo->Format].ItemType == ITEMTYPE_IMAGE)
        {
            m_NumImages--;
        }

        m_NumItems--;

        delete pItemInfo;
    }
}

//
// Retrieves the thumbnail for an item
//
/*
HRESULT FakeCamera::GetNativeThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetThumbnail");
    HRESULT hr = S_OK;
     
    if (!ppThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, invalid arg"));
        return E_INVALIDARG;
    }
    *ppThumb = NULL;
    *pThumbSize = 0;

    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    BYTE *pBuffer;
    hr = ReadJpegHdr(FullName, &pBuffer);
    if (FAILED(hr) || !pBuffer)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, ReadJpegHdr failed"));
        return hr;
    }

    IFD ImageIfd, ThumbIfd;
    BOOL bSwap;
    hr = ReadExifJpeg(pBuffer, &ImageIfd, &ThumbIfd, &bSwap);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, GetExifJpegDimen failed"));
        delete []pBuffer;
        return hr;
    }

    LONG ThumbOffset = 0;

    for (int count = 0; count < ThumbIfd.Count; count++)
    {
        if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_DATA) {
            ThumbOffset = ThumbIfd.pEntries[count].Offset;
        }
        else if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_LEN) {
            *pThumbSize = ThumbIfd.pEntries[count].Offset;
        }
    }

    if (!ThumbOffset || !*pThumbSize)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, thumbnail not found"));
        return E_FAIL;
    }

    *ppThumb = new BYTE[*pThumbSize];
    if (!*ppThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, memory allocation failed"));
        return E_OUTOFMEMORY;
    }

    memcpy(*ppThumb, pBuffer + APP1_OFFSET + ThumbOffset, *pThumbSize);

    delete []pBuffer;

    FreeIfd(&ImageIfd);
    FreeIfd(&ThumbIfd);

    return hr;
}
*/


HRESULT FakeCamera::CreateThumbnail(ITEM_HANDLE ItemHandle, 
                                 int *pThumbSize, 
                                 BYTE **ppThumb,
                                 BMP_IMAGE_INFO *pBmpImageInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FSCamera::GetThumbnail");
    HRESULT hr = S_OK;
    GpStatus Status = Gdiplus::Ok;
    SizeF  gdipSize;
    BYTE *pTempBuf=NULL;
    CImageStream *pOutStream = NULL;
    Image *pImage=NULL, *pThumbnail=NULL;
    CLSID ClsidBmpEncoder;
    INT iBmpHeadSize = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
    ITEM_INFO *pItemInfo=NULL;

    if (!ppThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, invalid arg"));
        return E_INVALIDARG;
    }
    *ppThumb = NULL;
    *pThumbSize = 0;

    if( S_OK != (hr=GetClsidOfEncoder(ImageFormatBMP, &ClsidBmpEncoder)))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, Cannot get Encode"));
        hr = E_FAIL;
        goto Cleanup;
    }
     
    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    pItemInfo = (ITEM_INFO *)ItemHandle;

    pImage = new Image(FullName);

    if( !pImage ||  Gdiplus::ImageTypeBitmap != pImage->GetType() )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, Cannot get Full GDI+ Image for %S", FullName));
        hr = E_FAIL;
        goto Cleanup;
    }

    // Calculate Thumbnail size
    Status = pImage->GetPhysicalDimension(&gdipSize);
    if (Status != Gdiplus::Ok)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, Failed in GetPhysicalDimension"));
        hr = E_FAIL;
        goto Cleanup;
    }

    if(  gdipSize.Width < 1.0 || gdipSize.Height < 1.0 )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateThumbnail, PhysicalDimension abnormal"));
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pItemInfo->Width = (LONG)gdipSize.Width;
    pItemInfo->Height = (LONG)gdipSize.Height;
    PixelFormat PixFmt = pImage->GetPixelFormat();
	pItemInfo->Depth = (PixFmt & 0xFFFF) >> 8;   // Cannot assume image is always 24bits/pixel
    if( (pItemInfo->Depth) < 24 )
        pItemInfo->Depth = 24; 
    pItemInfo->BitsPerChannel = 8;
    pItemInfo->Channels = (pItemInfo->Depth)/(pItemInfo->BitsPerChannel);

	
    if(  gdipSize.Width > gdipSize.Height )
    {
        pBmpImageInfo->Width = 120;
        pBmpImageInfo->Height = (INT)(gdipSize.Height*120.0/gdipSize.Width);
        pBmpImageInfo->Height = (pBmpImageInfo->Height + 0x3) & (~0x3);
    }
    else
    {
        pBmpImageInfo->Height = 120;
        pBmpImageInfo->Width = (INT)(gdipSize.Width*120.0/gdipSize.Height);
        pBmpImageInfo->Width = (pBmpImageInfo->Width + 0x3 ) & (~0x3);
    }
 
    pThumbnail = pImage->GetThumbnailImage(pBmpImageInfo->Width,pBmpImageInfo->Height);

    if( !pThumbnail ||  Gdiplus::ImageTypeBitmap != pThumbnail->GetType() )
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Cannot get Thumbnail GDI+ Image"));
        hr = E_FAIL;
        goto Cleanup;
    }

    if( pImage )
    {
        delete pImage;
        pImage=NULL;
    }

#if 0
    pThumbnail->Save(L"C:\\thumbdmp.bmp", &ClsidBmpEncoder, NULL);
#endif

    //
    // Ask GDI+ for the image dimensions, and fill in the
    // passed structure
    //
    Status = pThumbnail->GetPhysicalDimension(&gdipSize);
    if (Status != Gdiplus::Ok)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Failed in GetPhysicalDimension"));
        hr = E_FAIL;
        goto Cleanup;
    }

    pBmpImageInfo->Width = (INT) gdipSize.Width;
    pBmpImageInfo->Height = (INT) gdipSize.Height;
    pBmpImageInfo->ByteWidth = (pBmpImageInfo->Width) << 2;
    pBmpImageInfo->Size = pBmpImageInfo->ByteWidth * pBmpImageInfo->Height;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetThumbnail, W=%d H=%d", pBmpImageInfo->Width, pBmpImageInfo->Height));

    if (pBmpImageInfo->Size == 0)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Thumbnail size is zero"));
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // See if the caller passed in a destination buffer, and make sure
    // it is big enough.
    //
    if (*ppThumb) {
        if (*pThumbSize < pBmpImageInfo->Size) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetThumbnail, Input Buffer too small"));
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // Otherwise allocate memory for a buffer
    //
    else
    {
        pTempBuf = new BYTE[pBmpImageInfo->Size];
        if (!pTempBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        *ppThumb = pTempBuf;
   }

    //
    // Create output IStream
    //
    pOutStream = new CImageStream;
    if (!pOutStream) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pOutStream->SetBuffer(*ppThumb, pBmpImageInfo->Size, SKIP_BOTHHDR);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    //
    // Write the Image to the output IStream in BMP format
    //
    pThumbnail->Save(pOutStream, &ClsidBmpEncoder, NULL);



    // pack
    DWORD i, k;

    for(k=0, i=0; k<(DWORD)(pBmpImageInfo->Size); k+=4, i+=3)
    {
        (*ppThumb)[i] = (*ppThumb)[k];
        (*ppThumb)[i+1] = (*ppThumb)[k+1];
        (*ppThumb)[i+2] = (*ppThumb)[k+2];
    }
 
    *pThumbSize = ((pBmpImageInfo->Size)>>2)*3;
    pBmpImageInfo->Size = *pThumbSize;

Cleanup:
    if (FAILED(hr)) {
        if (pTempBuf) {
            delete []pTempBuf;
            pTempBuf = NULL;
            *ppThumb = NULL;
            *pThumbSize = 0;
        }
    }
    
    if (pOutStream) 
    {
        pOutStream->Release();
    }

    if( pImage )
    {
        delete pImage;
    }
    
    if( pThumbnail )
    {
        delete pThumbnail;
    }

    return hr; 
}

PBITMAPINFO CreateBitmapInfoStruct(HBITMAP hBmp)
{ 
    BITMAP bmp; 
    PBITMAPINFO pbmi; 
    WORD    cClrBits; 

    // Retrieve the bitmap's color format, width, and height. 
    if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bmp)) 
	{
        return NULL;
	}

    // Convert the color format to a count of bits. 
    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits <= 4) 
        cClrBits = 4; 
    else if (cClrBits <= 8) 
        cClrBits = 8; 
    else if (cClrBits <= 16) 
        cClrBits = 16; 
    else if (cClrBits <= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 

     if (cClrBits != 24) 
         pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                    sizeof(BITMAPINFOHEADER) + 
                    sizeof(RGBQUAD) * (1<< cClrBits)); 

     // There is no RGBQUAD array for the 24-bit-per-pixel format. 

     else 
         pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                    sizeof(BITMAPINFOHEADER)); 

    
     if( !pbmi ) 
         return NULL;

    // Initialize the fields in the BITMAPINFO structure. 
    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
    pbmi->bmiHeader.biWidth = bmp.bmWidth; 
    pbmi->bmiHeader.biHeight = bmp.bmHeight; 
    pbmi->bmiHeader.biPlanes = bmp.bmPlanes; 
    pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel; 
    if (cClrBits < 24) 
        pbmi->bmiHeader.biClrUsed = (1<<cClrBits); 

    // If the bitmap is not compressed, set the BI_RGB flag. 
    pbmi->bmiHeader.biCompression = BI_RGB; 

    // Compute the number of bytes in the array of color 
    // indices and store the result in biSizeImage. 
    // For Windows NT/2000, the width must be DWORD aligned unless 
    // the bitmap is RLE compressed. This example shows this. 
    // For Windows 95/98, the width must be WORD aligned unless the 
    // bitmap is RLE compressed.
    pbmi->bmiHeader.biSizeImage = ((pbmi->bmiHeader.biWidth * cClrBits +31) & ~31) /8
                                  * pbmi->bmiHeader.biHeight; 
    // Set biClrImportant to 0, indicating that all of the 
    // device colors are important. 
    pbmi->bmiHeader.biClrImportant = 0; 
    return pbmi; 
} 

HRESULT FakeCamera::CreateVideoThumbnail(ITEM_HANDLE ItemHandle, 
                                 int *pThumbSize, 
                                 BYTE **ppThumb,
                                 BMP_IMAGE_INFO *pBmpImageInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FSCamera::CreateVideoThumbnail");
   HRESULT hr = S_OK;
   HBITMAP hBmp=NULL;
   PBITMAPINFO pBMI=NULL;
   BYTE *pTempBuf=NULL;

#ifdef USE_SHELLAPI

 	IShellFolder *pDesktop=NULL;
	IShellFolder *pFolder=NULL;
    ITEMIDLIST *pidlFolder=NULL;
    ITEMIDLIST *pidlFile=NULL;
    IExtractImage *pExtract=NULL;
    SIZE rgSize;
    WCHAR *wcsTmp, wcTemp;
    DWORD dwPriority, dwFlags;

    if (!ppThumb || !pThumbSize || !pBmpImageInfo)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, invalid arg"));
        return E_INVALIDARG;
    }
    
	*ppThumb = NULL;
    *pThumbSize = 0;

   
    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    // Calculate Thumbnail size, BUGBUG
	rgSize.cx = 120;
	rgSize.cy = 90;

    // Get thumbnail using Shell APIs
	hr = SHGetDesktopFolder(&pDesktop);
    if( S_OK != hr || !pDesktop )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot open Desktop"));
		goto Cleanup;
	}

	wcsTmp = wcsrchr(FullName, L'\\');

	if( wcsTmp )
	{
//		wcTemp = *(wcsTmp+1);
		*(wcsTmp) = NULL;
	}
	else 
	{
		hr = E_INVALIDARG;
		goto Cleanup;
	}

	hr = pDesktop->ParseDisplayName(NULL, NULL, FullName, NULL, &pidlFolder, NULL);
    if( S_OK != hr || !pidlFolder )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot open IDL Folder=%S", FullName));
		goto Cleanup;
	}

    hr = pDesktop->BindToObject(pidlFolder, NULL, IID_IShellFolder, (LPVOID *)&pFolder);
    if( S_OK != hr || !pFolder )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot bind to Folder=%S", FullName));
		goto Cleanup;
	}

//    *(wcsTmp+1) = wcTemp;  // restore the char
	hr = pFolder->ParseDisplayName(NULL, NULL, wcsTmp+1, NULL, &pidlFile, NULL);
    if( S_OK != hr || !pidlFile )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot open IDL File=%S", wcsTmp+1));
		goto Cleanup;
	}

    hr = pFolder->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidlFile, IID_IExtractImage, NULL, (LPVOID *)&pExtract);
    if( S_OK != hr || !pExtract )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot get extract pointer=%S, hr=0x%x", wcsTmp+1, hr));
		goto Cleanup;
	}

 
	dwFlags = 0;
	dwPriority=0;
	hr = pExtract->GetLocation(FullName, MAX_PATH, &dwPriority, &rgSize, 0, &dwFlags);
    if( S_OK != hr )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Failed in GetLocation"));
		goto Cleanup;
	}

	hr = pExtract->Extract(&hBmp);

#else
	
    hBmp = (HBITMAP)LoadImage(g_hInst, MAKEINTRESOURCE(IDB_BITMAP_VIDEO), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if( !hBmp )
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
	}
#endif  // end of if use ShellAPI
    if( S_OK != hr || !hBmp )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot extract Image hr=0x%x", hr));
		goto Cleanup;
	}


    pBMI = CreateBitmapInfoStruct(hBmp);
    if( !pBMI )
	{
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Cannot create BitmapInfoStruct"));
		goto Cleanup;
	}


    pBmpImageInfo->Width = pBMI->bmiHeader.biWidth;
    pBmpImageInfo->Height = pBMI->bmiHeader.biHeight;
    pBmpImageInfo->ByteWidth = ((pBMI->bmiHeader.biWidth * 24 + 31 ) & ~31 ) >> 3;
    pBmpImageInfo->Size = pBMI->bmiHeader.biWidth * pBmpImageInfo->Height * 3;
   
    //
    // See if the caller passed in a destination buffer, and make sure
    // it is big enough.
    //
    if (*ppThumb) {
        if (*pThumbSize < pBmpImageInfo->Size) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Input Buffer too small"));
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

     //
    // Otherwise allocate memory for a buffer
    //
    else
    {
        pTempBuf = new BYTE[(pBmpImageInfo->ByteWidth)*(pBmpImageInfo->Height)];
        if (!pTempBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        *ppThumb = pTempBuf;
        *pThumbSize = pBmpImageInfo->Size;
    }


    //
    // Create output buffer
	//

	if (!GetDIBits(GetDC(NULL), hBmp, 0, (WORD)pBMI->bmiHeader.biHeight, *ppThumb, pBMI, DIB_RGB_COLORS)) 
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CreateVideoThumbnail, Failed in GetDIBits"));
		hr = E_FAIL;
		goto Cleanup;
   }

#if 0
    // pack
    DWORD i, k;

    for(k=0, i=0; k<(DWORD)(pBmpImageInfo->Size); k+=4, i+=3)
    {
        pTempBuf[i] = pTempBuf[k];
        pTempBuf[i+1] = pTempBuf[k+1];
        pTempBuf[i+2] = pTempBuf[k+2];
    }
#endif 
 
Cleanup:
    if (FAILED(hr)) {
        if (pTempBuf) {
            delete []pTempBuf;
            pTempBuf = NULL;
            *ppThumb = NULL;
            *pThumbSize = 0;
        }
    }
    
    if (pBMI) 
		LocalFree(pBMI);
    
#ifdef USE_SHELLAPI
	if( pDesktop )
		pDesktop->Release();
	
	if( pFolder )
		pFolder->Release();
	
	if( pidlFolder )
		CoTaskMemFree(pidlFolder);

    if( pidlFile )
		CoTaskMemFree(pidlFile);

	if( pExtract )
		pExtract->Release();
#endif

	if( hBmp )
	{
		DeleteObject(hBmp);
	}
	return hr; 
}


VOID FakeCamera::FreeThumbnail(BYTE *pThumb)
{
    if (pThumb)
    {
        delete []pThumb;
        pThumb = NULL;
    }
}

//
// Retrieves the data for an item
//
HRESULT FakeCamera::GetItemData(ITEM_HANDLE ItemHandle, LONG lState,
                                BYTE *pBuf, DWORD lLength)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetItemData");
    
    HRESULT hr = S_OK;

    if (lState & STATE_FIRST)
    {
        if (m_hFile != NULL)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, file handle is already open"));
            return E_FAIL;
        }

        WCHAR FullName[MAX_PATH];
        ConstructFullName(FullName, ItemHandle);

        m_hFile = CreateFile(FullName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, CreateFile failed %S", FullName));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }

    if (!(lState & STATE_CANCEL))
    {
        DWORD Received = 0;
        if (!ReadFile(m_hFile, pBuf, lLength, &Received, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, ReadFile failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        if (lLength != Received)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetItemData, incorrect amount read %d", Received));
            return E_FAIL;
        }

        Sleep(100);
    }

    if (lState & (STATE_LAST | STATE_CANCEL))
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }

    return hr;
}

//
// Deletes an item
//
HRESULT FakeCamera::DeleteItem(ITEM_HANDLE ItemHandle)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::DeleteItem");
    
    HRESULT hr = S_OK;
    DWORD   dwErr = 0; 
    WCHAR FullName[MAX_PATH];
    ConstructFullName(FullName, ItemHandle);

    if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributes(FullName) )
    {
        dwErr = RemoveDirectory(FullName);
    } else {
        dwErr = DeleteFile(FullName);
    }
 
    if (!dwErr )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItem, DeleteFile failed %S", FullName));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

//
// Captures a new image
//
HRESULT FakeCamera::TakePicture(ITEM_HANDLE *pItemHandle)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::TakePicture");
    
    HRESULT hr = S_OK;

    if (!pItemHandle)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TakePicture, invalid arg"));
        return E_INVALIDARG;
    }

    return hr;
}

//
// See if the camera is active
//
HRESULT
FakeCamera::Status()
{
    HRESULT hr = S_OK;

    //
    // This sample device is always active, but your driver should contact the
    // device and return S_FALSE if it's not ready.
    //
    // if (NotReady)
    //   return S_FALSE;

    return hr;
}

//
// Reset the camera
//
HRESULT FakeCamera::Reset()
{
    HRESULT hr = S_OK;

    return hr;
}

/*
//
// This function reads a JPEG file looking for the frame header, which contains
// the width and height of the image.
//
HRESULT ReadDimFromJpeg(LPOLESTR FullName, WORD *pWidth, WORD *pHeight)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "ReadDimFromJpeg");
    
    HRESULT hr = S_OK;

    if (!pWidth || !pHeight)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, invalid arg"));
        return E_INVALIDARG;
    }

    *pWidth = 0;
    *pHeight = 0;

    HANDLE hFile = CreateFile(FullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, CreateFile failed %S", FullName));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    const DWORD BytesToRead = 32 * 1024;
    BYTE *pBuffer = new BYTE[BytesToRead];
    if (!pBuffer)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, buffer allocation failed"));
        return E_OUTOFMEMORY;
    }

    DWORD BytesRead = 0;
    if (!ReadFile(hFile, pBuffer, BytesToRead, &BytesRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, ReadFile failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ReadDimFromJpeg, read %d bytes", BytesRead));

    BYTE *pCur = pBuffer;
    int SegmentLength = 0;
    const int Overlap = 8;  // if pCur gets within Overlap bytes of the end, read another chunk

    //
    // Pretend that we read Overlap fewer bytes than were actually read
    //
    BytesRead -= Overlap;

    while (SUCCEEDED(hr) &&
           BytesRead != 0 &&
           pCur[1] != 0xc0)
    {
        if (pCur[0] != 0xff)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, not a JFIF format image"));
            hr = E_FAIL;
            break;
        }

        //
        // if the marker is >= 0xd0 and <= 0xd9 or is equal to 0x01
        // there is no length field
        //
        if (((pCur[1] & 0xf0) == 0xd0 &&
             (pCur[1] & 0x0f) < 0xa) ||
            pCur[1] == 0x01)
        {
            SegmentLength = 0;
        }
        else
        {
            SegmentLength = ByteSwapWord(*((WORD *) (pCur + 2)));
        }

        pCur += SegmentLength + 2;

        if (pCur >= pBuffer + BytesRead)
        {
            memcpy(pBuffer, pBuffer + BytesRead, Overlap);

            pCur -= BytesRead;

            if (!ReadFile(hFile, pBuffer + Overlap, BytesToRead - Overlap, &BytesRead, NULL))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, ReadFile failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                break;
            }

            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ReadDimFromJpeg, read %d more bytes", BytesRead));
        }
    }

    if (SUCCEEDED(hr))
    {
        if (BytesRead == 0)
        {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, width and height tags not found"));
            hr = S_FALSE;
        }
        else
        {
            if (pCur[0] != 0xff)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadDimFromJpeg, not a JFIF format image"));
                return E_FAIL;
            }

            *pHeight = ByteSwapWord(*((WORD *) (pCur + 5)));
            *pWidth =  ByteSwapWord(*((WORD *) (pCur + 7)));
        }
    }

    delete []pBuffer;
    CloseHandle(hFile);

    return hr;
}

//
// The next section contains functions useful for reading information from
// Exif files.
//
HRESULT ReadJpegHdr(LPOLESTR FullName, BYTE **ppBuf)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "ReadJpegHdr");
    
    HRESULT hr = S_OK;
    WORD TagSize;

    HANDLE hFile = CreateFile(FullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadJpegHdr, CreateFile failed %S", FullName));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    BYTE JpegHdr[] = {0xff, 0xd8, 0xff, 0xe1};
    const int JpegHdrSize = sizeof(JpegHdr) + 2;
    BYTE tempBuf[JpegHdrSize];
    DWORD BytesRead = 0;

    if (!ReadFile(hFile, tempBuf, JpegHdrSize, &BytesRead, NULL) || BytesRead != JpegHdrSize)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadJpegHdr, ReadFile failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        goto Cleanup;
    }
    
    if (memcmp(tempBuf, JpegHdr, sizeof(JpegHdr)) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    TagSize = GetWord(tempBuf + sizeof(JpegHdr), TRUE);
    *ppBuf = new BYTE[TagSize];

    if (!ppBuf)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadJpegHdr, memory allocation failed"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!ReadFile(hFile, *ppBuf, TagSize, &BytesRead, NULL) || BytesRead != TagSize)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadJpegHdr, ReadFile failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        goto Cleanup;                                                              
    }

Cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    return hr;
}

HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "ReadExifJpeg");
    
    HRESULT hr = S_OK;

    BYTE ExifTag[] = {0x45, 0x78, 0x69, 0x66, 0x00, 0x00};

    if (memcmp(pBuf, ExifTag, sizeof(ExifTag)) != 0)
        return E_FAIL;

    hr = ReadTiff(pBuf + APP1_OFFSET, pImageIfd, pThumbIfd, pbSwap);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadExifJpeg, ReadTiff failed"));
        return hr;
    }

    return hr;
}

HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "ReadTiff");
    
    HRESULT hr = S_OK;

    *pbSwap = FALSE;

    if (pBuf[0] == 0x4d) {
        *pbSwap = TRUE;
        if (pBuf[1] != 0x4d)
            return E_FAIL;
    }
    else if (pBuf[0] != 0x49 ||
             pBuf[1] != 0x49)
        return E_FAIL;

    WORD MagicNumber = GetWord(pBuf+2, *pbSwap);
    if (MagicNumber != 42)
        return E_FAIL;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ReadTiff, reading image IFD"));

    pImageIfd->Offset = GetDword(pBuf + 4, *pbSwap);
    hr = ReadIfd(pBuf, pImageIfd, *pbSwap);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadTiff, ReadIfd failed"));
        return hr;
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ReadTiff, reading thumb IFD"));

    pThumbIfd->Offset = pImageIfd->NextIfdOffset;
    hr = ReadIfd(pBuf, pThumbIfd, *pbSwap);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadTiff, ReadIfd failed"));
        return hr;
    }

    return hr;
}

HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "ReadIfd");
    
    HRESULT hr = S_OK;

    const int DIR_ENTRY_SIZE = 12;
    
    pBuf += pIfd->Offset;

    pIfd->Count = GetWord(pBuf, bSwap);

    pIfd->pEntries = new DIR_ENTRY[pIfd->Count];
    if (!pIfd->pEntries)
        return E_OUTOFMEMORY;

    pBuf += 2;
    for (int count = 0; count < pIfd->Count; count++)
    {
        pIfd->pEntries[count].Tag = GetWord(pBuf, bSwap);
        pIfd->pEntries[count].Type = GetWord(pBuf + 2, bSwap);
        pIfd->pEntries[count].Count = GetDword(pBuf + 4, bSwap);
        pIfd->pEntries[count].Offset = GetDword(pBuf + 8, bSwap);
        pBuf += DIR_ENTRY_SIZE;

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ReadIfd, tag 0x%04x, type %2d offset/value 0x%08x",
                                                                    pIfd->pEntries[count].Tag, pIfd->pEntries[count].Type, pIfd->pEntries[count].Offset));
    }

    pIfd->NextIfdOffset = GetDword(pBuf, bSwap);

    return hr;
}

VOID FreeIfd(IFD *pIfd)
{
    if (pIfd->pEntries)
        delete []pIfd->pEntries;
    pIfd->pEntries = NULL;
}

WORD ByteSwapWord(WORD w)
{
    return (w >> 8) | (w << 8);
}

DWORD ByteSwapDword(DWORD dw)
{
    return ByteSwapWord((WORD) (dw >> 16)) | (ByteSwapWord((WORD) (dw & 0xffff)) << 16);
}

WORD GetWord(BYTE *pBuf, BOOL bSwap)
{
    WORD w = *((WORD *) pBuf);

    if (bSwap)
        w = ByteSwapWord(w);
    
    return w;
}

DWORD GetDword(BYTE *pBuf, BOOL bSwap)
{
    DWORD dw = *((DWORD *) pBuf);

    if (bSwap)
        dw = ByteSwapDword(dw);

    return dw;
}

DWORD GetRational(BYTE *pBuf, BOOL bSwap)
{
    DWORD num = *((DWORD *) pBuf);
    DWORD den = *((DWORD *) pBuf + 1);

    if (bSwap)
    {
        num = ByteSwapDword(num);
        den = ByteSwapDword(den);
    }

    if (den == 0)
        return 0xffffffff;
    else
        return num / den;
}
*/
/*
//
// Set the default and valid values for a property
//
VOID
FakeCamera::SetValidValues(
    INT index,
    CWiaPropertyList *pPropertyList
    )
{
    HRESULT hr = S_OK;

    ULONG ExposureModeList[] = {
        EXPOSUREMODE_MANUAL,
        EXPOSUREMODE_AUTO,
        EXPOSUREMODE_APERTURE_PRIORITY,
        EXPOSUREMODE_SHUTTER_PRIORITY,
        EXPOSUREMODE_PROGRAM_CREATIVE,
        EXPOSUREMODE_PROGRAM_ACTION,
        EXPOSUREMODE_PORTRAIT
    };

    PROPID PropId = pPropertyList->GetPropId(index);
    WIA_PROPERTY_INFO *pPropInfo = pPropertyList->GetWiaPropInfo(index);

    //
    // Based on the property ID, populate the valid values range or list information
    //
    switch (PropId)
    {
    case WIA_DPC_EXPOSURE_MODE:
        pPropInfo->ValidVal.List.Nom      = EXPOSUREMODE_MANUAL;
        pPropInfo->ValidVal.List.cNumList = sizeof(ExposureModeList) / sizeof(ExposureModeList[0]);
        pPropInfo->ValidVal.List.pList    = (BYTE*) ExposureModeList;
        break;

    case WIA_DPC_EXPOSURE_COMP:
        pPropInfo->ValidVal.Range.Nom = 0;
        pPropInfo->ValidVal.Range.Min = -200;
        pPropInfo->ValidVal.Range.Max = 200;
        pPropInfo->ValidVal.Range.Inc = 50;
        break;

    default:
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FakeCamera::SetValidValues, property 0x%08x not defined", PropId));
        return;
    }

    return;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA File System Device driver IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"


/**************************************************************************\
* CWiaCameraDevice::CWiaCameraDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::CWiaCameraDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    
    m_pIStiDevControl(NULL),
    m_pStiDevice(NULL),
    m_dwLastOperationError(0),
    
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pRootItem(NULL),

    m_NumSupportedCommands(0),
    m_NumSupportedEvents(0),
    m_NumCapabilities(0),
    m_pCapabilities(NULL),

    m_pDevice(NULL),

    m_ConnectedApps(0),
    m_pIWiaLog(NULL),
    m_FormatInfo(NULL),
    m_NumFormatInfo(0)
{
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }
}

/**************************************************************************\
* CWiaCameraDevice::~CWiaCameraDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::~CWiaCameraDevice(void)
{
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("~CWiaCameraDevice, executing ~CWiaCameraDevice destructor"));
    // Close the connection with the camera and delete it
    if( m_pDevice )
	{
		m_pDevice->Close();
		delete m_pDevice;
		m_pDevice = NULL;
	}

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }
    
    if(m_pIWiaLog)
        m_pIWiaLog->Release();
}

/**************************************************************************\
* CWiaCameraDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT hr = S_OK;
    
    //
    // Create logging object
    //
    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWiaLog, (void**)&m_pIWiaLog);
    
    if (SUCCEEDED(hr) &&
        (m_pIWiaLog != NULL))
    {
        //
        // This will not really work on 64 bit!!!
        //
        hr = m_pIWiaLog->InitializeLog((LONG)(LONG_PTR) g_hInst);
        if (SUCCEEDED(hr))
        {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("CWiaCameraDevice::Initialize, logging initialized"));
        }
        else
            OutputDebugString(TEXT("Failed to initialize log for fsusd.dll\n"));
    }
    else
    {
        OutputDebugString(TEXT("Failed to CoCreateInstance on WiaLog for fsusd.dll\n"));
    }
    
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::Initialize");

    //
    // Check and cache the pointer to the IStiDeviceControl interface
    //
    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWiaCameraDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    pIStiDevControl->AddRef();
    m_pIStiDevControl = pIStiDevControl;

    //
    // Retrieve the port name from the IStiDeviceControl interface
    //
    hr = m_pIStiDevControl->GetMyDevicePortName(m_pPortName, sizeof(m_pPortName) / sizeof(m_pPortName[0]));
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, GetMyDevicePortName failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Create the device
    //
    m_pDevice = new FakeCamera;
    if (!m_pDevice)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, memory allocation failed"));
        return E_OUTOFMEMORY;
    }
    
#if 1
//    DBG_TRC(("IStiPortName=%S [%d]", m_pPortName, wcslen(m_pPortName)));
    WIAS_LTRACE(m_pIWiaLog, WIALOG_NO_RESOURCE_ID, WIALOG_LEVEL1, ("IStiPortName=%S [%d]", m_pPortName, wcslen(m_pPortName)));
#endif

    m_pIWiaLog->AddRef();
    m_pDevice->SetWiaLog(&m_pIWiaLog);

    //
    // Initialize access to the camera
    //
    // ISSUE-10/17/2000-davepar Also need to pass in event callback
    //
    hr = m_pDevice->Open(m_pPortName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Init failed"));
        goto Cleanup;
    }

    if( !m_pCapabilities )
    {
        hr = BuildCapabilities();
        if( hr != S_OK )
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, BuildCapabilities failed"));
            goto Cleanup;
        }
    }

    //
    // Intialize image format converter
    //
    hr = m_Converter.Init();
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Init converter failed"));
        goto Cleanup;
    }

Cleanup:
    if( hr != S_OK )
    {
        if( m_pDevice )
		{
			delete m_pDevice;
			m_pDevice = NULL;
		}
    }
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetCapabilities");
    HRESULT hr = S_OK;

    memset(pUsdCaps, 0, sizeof(*pUsdCaps));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetStatus");
    HRESULT hr = S_OK;

    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWiaCameraDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If asked, verify the device is online
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        pDevStatus->dwOnlineState = 0L;

        hr = m_pDevice->Status();

        if (hr == S_OK) {
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }

        else if (hr == S_FALSE) {
            hr = S_OK;
        }
        else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Status failed"));
            return hr;
        }
    }

    // If asked, verify state of event
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {
        pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

        // ISSUE-10/17/2000-davepar See if camera wants polling, and then poll for events

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::DeviceReset");
    HRESULT hr = S_OK;

    hr = m_pDevice->Reset();
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeviceReset, Reset failed"));
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::Diagnostic");
    HRESULT hr = S_OK;

    // ISSUE-10/17/2000-davepar Should call m_pDevice->Diagnostic

    // Initialize response buffer
    memset(&pBuffer->sErrorInfo, 0, sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::SetNotificationHandle");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetNotificationData
*
*   Provides data from an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetNotificationData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::Escape");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetLastError");
    HRESULT hr = S_OK;

    if (!pdwLastDeviceError) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetLastError, invalid arg"));
        return E_INVALIDARG;
    }

    *pdwLastDeviceError = m_dwLastOperationError;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::GetLastErrorInfo");
    HRESULT hr = S_OK;

    if (!pLastErrorInfo) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetLastErrorInfo, invalid arg"));
        return E_INVALIDARG;
    }

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::LockDevice");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::UnLockDevice");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawReadData");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawWriteData");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadCommand
*
*   Read a command from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawReadCommand");
    HRESULT hr = S_OK;

    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteCommand
*
*   Write a command to the device.
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::RawWriteCommand");
    HRESULT hr = S_OK;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\fscam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       FScam.h
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   File System Device object library
*
***************************************************************************/

#ifndef _CAMAPI_H
#define _CAMAPI_H

//
// GetItemData state bit masks
//
const LONG STATE_NEXT   = 0x00;
const LONG STATE_FIRST  = 0x01;
const LONG STATE_LAST   = 0x02;
const LONG STATE_CANCEL = 0x04;

//
// Constants and structures for supporting a generic camera
//
typedef LONG FORMAT_CODE;
/*
const FORMAT_CODE TYPE_UNKNOWN    = 0x00;
const FORMAT_CODE TYPE_FOLDER     = 0x01;
const FORMAT_CODE TYPE_TXT        = 0x02;
const FORMAT_CODE TYPE_HTML       = 0x03;
const FORMAT_CODE TYPE_RTF        = 0x04;
const FORMAT_CODE TYPE_DPOF       = 0x05;
const FORMAT_CODE TYPE_AIFF       = 0x06;
const FORMAT_CODE TYPE_WAV        = 0x07;
const FORMAT_CODE TYPE_MP3        = 0x08;
const FORMAT_CODE TYPE_AVI        = 0x09;
const FORMAT_CODE TYPE_MPEG       = 0x0a;

const FORMAT_CODE TYPE_UNKNOWNIMG = 0x10;
const FORMAT_CODE TYPE_JPEG       = 0x11;
const FORMAT_CODE TYPE_TIFF       = 0x12;
const FORMAT_CODE TYPE_FLASHPIX   = 0x13;
const FORMAT_CODE TYPE_BMP        = 0x14;
const FORMAT_CODE TYPE_DIB        = 0x15;
const FORMAT_CODE TYPE_GIF        = 0x16;
const FORMAT_CODE TYPE_JPEG2000   = 0x17;

const FORMAT_CODE TYPE_IMAGEMASK  = 0x10;
*/

typedef struct _DEVICE_INFO {
    BOOL        bSyncNeeded;        // Should be set if the driver can get out-of-sync with the camera (i.e. for serial cameras)
    BSTR        FirmwareVersion;    // String allocated and freed by camera library
    LONG        PicturesTaken;      // Number of pictures stored on the camera
    LONG        PicturesRemaining;  // Space available on the camera, in pictures at the current resolution
    LONG        TotalItems;         // Total number of items on the camera, including folders, images, audio, etc.
    SYSTEMTIME  Time;               // Current time on the device
    LONG        ExposureMode;       // See WIA_DPC_EXPOSURE_MODE
    LONG        ExposureComp;       // See WIA_DPC_EXPOSURE_COMP
} DEVICE_INFO, *PDEVICE_INFO;

typedef struct _ITEM_INFO {
    struct _ITEM_INFO
               *Parent;             // Pointer to this item's parent, equal to ROOT_ITEM if this is a top level item
    BSTR        pName;              // String allocated and freed by camera library
    SYSTEMTIME  Time;               // Last modified time of the item
    FORMAT_CODE Format;             // Index to g_FormatInfo[] array.
    BOOL        bHasAttachments;    // Indicates whether an image has attachments
    LONG        Width;              // Width of the image in pixels, zero for non-images
    LONG        Height;             // Height of the image in pixels, zero for non-images
    LONG        Depth;              // Pixel depth in pixels (e.g. 8, 16, 24)
    LONG        Channels;           // Number of color channels per pixel (e.g. 1, 3)
    LONG        BitsPerChannel;     // Number of bits per color channel, normally 8
    LONG        Size;               // Size of the image in bytes
    LONG        SequenceNum;        // If image is part of a sequence, the sequence number
//    FORMAT_CODE ThumbFormat;        // Indicates the format of the thumbnail
    LONG        ThumbWidth;         // Width of thumbnail (can be set to zero until thumbnail is read by app)
    LONG        ThumbHeight;        // Height of thumbnail (can be set to zero until thumbnail is read by app)
    BOOL        bReadOnly;          // Indicates if item can or cannot be deleted by app
    BOOL        bCanSetReadOnly;    // Indicates if the app can change the read-only status on and off
    BOOL        bIsFolder;          // Indicates if the item is a folder
} ITEM_INFO, *PITEM_INFO;

typedef ITEM_INFO *ITEM_HANDLE;
const ITEM_HANDLE ROOT_ITEM_HANDLE = NULL;

typedef CWiaArray<ITEM_HANDLE> ITEM_HANDLE_ARRAY;

#define FFD_ALLOCATION_INCREMENT 64  // this must be a power of 2 !!!
typedef struct _FSUSD_FILE_DATA {
    DWORD     dwFileAttributes;
    FILETIME  ftFileTime;
    DWORD     dwFileSize;
    TCHAR     cFileName[MAX_PATH];
    DWORD     dwProcessed;
} FSUSD_FILE_DATA, *PFSUSD_FILE_DATA;

#ifndef FORMAT_INFO_STRUCTURE
#define FORMAT_INFO_STRUCTURE

#define MAXEXTENSIONSTRINGLENGTH 8
typedef struct _FORMAT_INFO
{
    GUID    FormatGuid;         // WIA format GUID
    WCHAR   ExtensionString[MAXEXTENSIONSTRINGLENGTH];   // File extension
    LONG    ItemType;           // WIA item type
} FORMAT_INFO, *PFORMAT_INFO;
#endif 

//
// Generic camera class definition
//

class FakeCamera
{
public:
    //
    // Methods for accessing the camera
    //
    FakeCamera();
    ~FakeCamera();

    HRESULT Open(LPWSTR pPortName);
    HRESULT Close();
    HRESULT GetDeviceInfo(DEVICE_INFO *pDeviceInfo);
    VOID    FreeDeviceInfo(DEVICE_INFO *pDeviceInfo);
    HRESULT GetItemList(ITEM_HANDLE *pItemArray);
    HRESULT SearchDirEx(ITEM_HANDLE_ARRAY *pItemArray,
                      ITEM_HANDLE ParentHandle, LPOLESTR Path);
    HRESULT SearchForAttachments(ITEM_HANDLE_ARRAY *pItemArray,
                                 ITEM_HANDLE ParentHandle, LPOLESTR Path, FSUSD_FILE_DATA *pFFD, DWORD dwNumFiles);
    HRESULT CreateFolderEx(ITEM_HANDLE ParentHandle,
                          FSUSD_FILE_DATA *pFindData, ITEM_HANDLE *pFolderHandle);
    HRESULT CreateItemEx(ITEM_HANDLE ParentHandle,
                        FSUSD_FILE_DATA *pFileData, ITEM_HANDLE *pImageHandle, UINT nFormatCode);
    VOID    ConstructFullName(WCHAR *pFullName, ITEM_INFO *pItemInfo, BOOL bAddExt = TRUE);

    VOID    FreeItemInfo(ITEM_INFO *pItemInfo);
    HRESULT GetNativeThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb);
    HRESULT CreateThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb, BMP_IMAGE_INFO *pBmpInfo);
    HRESULT CreateVideoThumbnail(ITEM_HANDLE ItemHandle, int *pThumbSize, BYTE **ppThumb, BMP_IMAGE_INFO *pBmpInfo);
    VOID    FreeThumbnail(BYTE *pThumb);
    HRESULT GetItemData(ITEM_HANDLE ItemHandle, LONG lState, BYTE *pBuf, DWORD lLength);
    HRESULT DeleteItem(ITEM_HANDLE ItemHandle);
    HRESULT TakePicture(ITEM_HANDLE *pItemHandle);
    HRESULT Status();
    HRESULT Reset();
    ULONG   GetImageTypeFromFilename(WCHAR *pFilename, UINT *pFormatCode);
    void    SetWiaLog(IWiaLog **ppILog) { m_pIWiaLog = *ppILog; };

private:
    WCHAR               m_RootPath[MAX_PATH];
    ITEM_HANDLE_ARRAY   m_ItemHandles;
    int                 m_NumImages;
    int                 m_NumItems;
    HANDLE              m_hFile;
    IWiaLog            *m_pIWiaLog;

public:
    FORMAT_INFO        *m_FormatInfo;
    UINT                m_NumFormatInfo;
};

//
// Constants for reading Exif files
//
const WORD TIFF_XRESOLUTION =   0x11a;
const WORD TIFF_YRESOLUTION =   0x11b;
const WORD TIFF_JPEG_DATA =     0x201;
const WORD TIFF_JPEG_LEN =      0x202;

const int APP1_OFFSET = 6;      // Offset between the start of the APP1 segment and the start of the TIFF tags

//
// Structures for reading Exif files
//
typedef struct _DIR_ENTRY
{
    WORD    Tag;
    WORD    Type;
    DWORD   Count;
    DWORD   Offset;
} DIR_ENTRY, *PDIR_ENTRY;

typedef struct _IFD
{
    DWORD       Offset;
    WORD        Count;
    DIR_ENTRY  *pEntries;
    DWORD       NextIfdOffset;
} IFD, *PIFD;

//
// Functions for reading Exif files
//
HRESULT ReadDimFromJpeg(LPOLESTR FullName, WORD *pWidth, WORD *pHeight);
HRESULT ReadJpegHdr(LPOLESTR FileName, BYTE **ppBuf);
HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap);
VOID    FreeIfd(IFD *pIfd);
WORD    ByteSwapWord(WORD w);
DWORD   ByteSwapDword(DWORD dw);
WORD    GetWord(BYTE *pBuf, BOOL bSwap);
DWORD   GetDword(BYTE *pBuf, BOOL bSwap);
DWORD   GetRational(BYTE *pBuf, BOOL bSwap);

#endif // #ifndef _CAMAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\pch.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 2001
*
*  TITLE:       pch.h
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Procomplied header for WIA File System Device driver object
*
*******************************************************************************/

#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef UNICODE
#define UNICODE
#endif

#include <stdio.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include <wiamindr.h>
#include <wiautil.h>

#include "wiatempl.h"

#include "resource.h"
#include "FScam.h"
#include "wiacam.h"
//#include "coreDbg.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2001, MICROSOFT CORP.
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA File System Device driver IWiaMiniDrv methods. This file
*   contains 3 sections. The first is the WIA minidriver entry points, all
*   starting with "drv". The next section is public help methods. The last
*   section is private helper methods.
*
*******************************************************************************/

#include "pch.h"

//
// This structure is a convenient way to map between the FORMAT_CODEs and info
// useful for WIA, such as the format GUIDs and item types. These need to
// correspond to the constants defined in FakeCam.h.
//

// FORMAT_INFO *g_FormatInfo;
// extern UINT g_NumFormatInfo=0;


// The following are utility functions for populate the g_FormatInfo array
LONG GetTypeInfoFromRegistry(HKEY *phKeyExt, WCHAR *wcsKeyName, GUID *pFormatGuid)
{
    HKEY hKeyCur;

    DWORD dwRet = RegOpenKeyExW(*phKeyExt, wcsKeyName, 0, KEY_READ | KEY_QUERY_VALUE, &hKeyCur);

    if( dwRet != ERROR_SUCCESS )
    {
        return ITEMTYPE_FILE;
    }

    WCHAR wcsValueName[64] = L"Generic";
    WCHAR wcsData[MAX_PATH];
    DWORD dwType = REG_SZ;
    DWORD dwSize = MAX_PATH;

    dwRet = RegQueryValueExW(hKeyCur,
        wcsValueName, NULL, &dwType, (LPBYTE)wcsData, &dwSize );

    DWORD dwItemType = ITEMTYPE_FILE;

    if( ERROR_SUCCESS == dwRet )
    {
         if( CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
             NORM_IGNORECASE, L"image", 5, wcsData, 5) )
         {
            dwItemType = ITEMTYPE_IMAGE;
         }
         else if ( CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
             NORM_IGNORECASE, L"audio", 5, wcsData, 5) )
         {
            dwItemType = ITEMTYPE_AUDIO;
         }
         else if ( CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
             NORM_IGNORECASE, L"video", 5, wcsData, 5) )
         {
            dwItemType = ITEMTYPE_VIDEO;
         }
         else
         {
            dwItemType = ITEMTYPE_FILE;
         }
    }

    lstrcpyW(wcsValueName, L"FormatGUID");
    dwType = REG_SZ;
    dwSize = MAX_PATH;
    dwRet = RegQueryValueExW(hKeyCur,
        wcsValueName,
        NULL,
        &dwType,
        (LPBYTE)wcsData,
        &dwSize );

    if( ERROR_SUCCESS == dwRet )
    {
        wcsData[dwSize]=0;
        if( NOERROR != CLSIDFromString(wcsData, pFormatGuid))
        {
            CopyMemory(pFormatGuid, (CONST VOID *)&WiaImgFmt_UNDEFINED, sizeof(GUID));
        }
    }
    else
    {
        CopyMemory(pFormatGuid, (CONST VOID *)&WiaImgFmt_UNDEFINED, sizeof(GUID));
    }

    RegCloseKey(hKeyCur);
    return dwItemType;
}

DWORD CWiaCameraDevice::PopulateFormatInfo(void)
{
    HKEY hKeyExt = NULL;
    DWORD dwRet, dwCurAllocation = 32;
    DWORD dwIndex=0, dwIndexBase=0, dwKeyNameSize=32;

    m_FormatInfo = (FORMAT_INFO *)CoTaskMemAlloc(sizeof(FORMAT_INFO)*dwCurAllocation);

    if( !m_FormatInfo )
    {
        dwRet = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    m_FormatInfo[0].FormatGuid = WiaImgFmt_UNDEFINED;
    m_FormatInfo[0].ItemType = ITEMTYPE_FILE;
    lstrcpyW(m_FormatInfo[0].ExtensionString, L"");
    dwIndexBase=1;
    dwIndex=0;

    dwRet = RegOpenKeyExW(HKEY_CLASSES_ROOT,
        L"CLSID\\{D2923B86-15F1-46FF-A19A-DE825F919576}\\SupportedExtension",
        0, KEY_READ | KEY_QUERY_VALUE, &hKeyExt);

    if( ERROR_SUCCESS != dwRet )   // No Key exist
    {
        goto Compilation;
    }

    WCHAR wcsKeyName[32], *pExt;
    FILETIME ftLWT;
    dwRet = RegEnumKeyExW(hKeyExt, dwIndex, wcsKeyName, &dwKeyNameSize, NULL, NULL, NULL, &ftLWT);

    if( ERROR_SUCCESS != dwRet )  // No key exist
    {
        goto Compilation;
    }

    while ( dwRet == ERROR_SUCCESS )
    {
        pExt = (wcsKeyName[0]==L'.'?(&wcsKeyName[1]):(&wcsKeyName[0])); // remove the dot
        pExt[MAXEXTENSIONSTRINGLENGTH-1] = NULL;  // Truncate to avoid overrun

        // Set values in FORMAT_INFO structure
        lstrcpyW(m_FormatInfo[dwIndex+dwIndexBase].ExtensionString, pExt);
        m_FormatInfo[dwIndex+dwIndexBase].ItemType = GetTypeInfoFromRegistry(&hKeyExt, wcsKeyName, &(m_FormatInfo[dwIndex+dwIndexBase].FormatGuid));

        dwIndex++;
        if( dwIndex+dwIndexBase > dwCurAllocation-1 )  // need allocate more memory
        {
            dwCurAllocation += 32;
            m_FormatInfo = (FORMAT_INFO *)CoTaskMemRealloc(m_FormatInfo, sizeof(FORMAT_INFO)*dwCurAllocation);
            if( !m_FormatInfo )
            {
                dwRet = ERROR_OUTOFMEMORY;
                dwIndex --;
                goto Exit;
            }
        }
        dwKeyNameSize=32;
        dwRet = RegEnumKeyExW(hKeyExt, dwIndex, wcsKeyName, &dwKeyNameSize, NULL, NULL, NULL, &ftLWT);
    }

    if(dwRet == ERROR_NO_MORE_ITEMS )
    {
        dwRet = ERROR_SUCCESS;
        goto Exit;
    }

Compilation:   // Compile a fixed list of formats when error occurs

    dwIndex=dwIndexBase=0;
    dwRet = ERROR_SUCCESS;

    DEFAULT_FORMAT_INFO g_DefaultFormats[] =
    {
        { (GUID *)&WiaImgFmt_UNDEFINED,       ITEMTYPE_FILE,     L""   },  // Unknown
        { (GUID *)&WiaImgFmt_JPEG,  ITEMTYPE_IMAGE, L"JPG"  },  // JPEG or EXIF
        { (GUID *)&WiaImgFmt_TIFF,  ITEMTYPE_IMAGE, L"TIF"  },  // TIFF
        { (GUID *)&WiaImgFmt_BMP,   ITEMTYPE_IMAGE, L"BMP"  },  // BMP
        { (GUID *)&WiaImgFmt_GIF,   ITEMTYPE_IMAGE, L"GIF"  },  // GIF
        { NULL, 0, NULL }
    };

    while( g_DefaultFormats[dwIndex].pFormatGuid )
    {
          m_FormatInfo[dwIndex].FormatGuid = *g_DefaultFormats[dwIndex].pFormatGuid;
          m_FormatInfo[dwIndex].ItemType = g_DefaultFormats[dwIndex].ItemType;
          lstrcpyW(m_FormatInfo[dwIndex].ExtensionString, g_DefaultFormats[dwIndex].ExtensionString);
          dwIndex++;
    }

Exit:
    m_NumFormatInfo = dwIndex+dwIndexBase;
    if (hKeyExt != NULL ) {
        RegCloseKey(hKeyExt);
        hKeyExt = NULL;
    }
    return dwRet;
}

void CWiaCameraDevice::UnPopulateFormatInfo(void)
{
    CoTaskMemFree(m_FormatInfo);
}

/**************************************************************************\
* CWiaCameraDevice::drvInitializeWia
*
*   Initialize the WIA mini driver. This function will be called each time an
*   application creates a device. The first time through, the driver item tree
*   will be created and other initialization will be done.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvInitializeWia");
    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("drvInitializeWia, device ID: %ws", bstrDeviceID));

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    m_ConnectedApps++;;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, number of connected apps is now %d", m_ConnectedApps));

    if (m_ConnectedApps == 1)
    {
        if (ERROR_SUCCESS != PopulateFormatInfo() ) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to populate FormatInfo array"));
            return E_OUTOFMEMORY;
        }

        //
        // Save STI device interface for calling locking functions
        //
        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID
        //
        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root item name
        //
        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate root item name"));
            return E_OUTOFMEMORY;
        }

        if( m_pDevice )
        {
            m_pDevice->m_FormatInfo = m_FormatInfo;
            m_pDevice->m_NumFormatInfo = m_NumFormatInfo;
        }
        else
        {
            return (HRESULT_FROM_WIN32(ERROR_INVALID_ACCESS));
        }

        //
        // Get information from the device
        //
        hr = m_pDevice->GetDeviceInfo(&m_DeviceInfo);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, GetDeviceInfo failed"));
            return hr;
        }

        //
        // Build the capabilities array
        //
        hr = BuildCapabilities();
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
            return hr;
        }

        //
        //  Build the device item tree
        //
        hr = BuildItemTree();
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildItemTree failed"));
            return hr;
        }

    }

    *ppIDrvItemRoot = m_pRootItem;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnInitializeWia(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvUnInitializeWia");
    HRESULT hr = S_OK;

    m_ConnectedApps--;

    if (m_ConnectedApps == 0)
    {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvUnInitializeWia, connected apps is zero, freeing resources..."));

        // Destroy the driver item tree
        hr = DeleteItemTree(WiaItemTypeDisconnected);
        if (FAILED(hr))
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvUnInitializeWia, UnlinkItemTree failed"));

        // Delete allocated arrays
        DeleteCapabilitiesArrayContents();

        // Free the device info structure
        m_pDevice->FreeDeviceInfo(&m_DeviceInfo);

        // Free the item handle map
        m_HandleItemMap.RemoveAll();

        // Free the storage for the device ID
        if (m_bstrDeviceID) {
            SysFreeString(m_bstrDeviceID);
        }

        // Free the storage for the root item name
        if (m_bstrRootFullItemName) {
            SysFreeString(m_bstrRootFullItemName);
        }

        UnPopulateFormatInfo();

        //
        // Do not delete the device here, because GetStatus may still be called later
        //

    /*
        // Kill notification thread if it exists.
        SetNotificationHandle(NULL);

        // Close event for syncronization of notifications shutdown.
        if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
            CloseHandle(m_hShutdownEvent);
            m_hShutdownEvent = NULL;
        }


        //
        // WIA member destruction
        //

        // Cleanup the WIA event sink.
        if (m_pIWiaEventCallback) {
            m_pIWiaEventCallback->Release();
            m_pIWiaEventCallback = NULL;
        }

    */

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree. For the root item, just set the properties already
*   set up in drvInitializeWia. For child items, access the camera for
*   information about the item and for images also get the thumbnail.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildRootItemProperties(pWiasContext);

    } else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildChildItemProperties(pWiasContext);

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(100);
}

/**************************************************************************\
* CWiaCameraDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvUnLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWiaCameraDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvFreeDrvItemContext");
    *plDevErrVal = 0;

    ITEM_CONTEXT *pItemCtx = (ITEM_CONTEXT *) pSpecContext;

    if (pItemCtx)
    {
        if (!m_HandleItemMap.Remove(pItemCtx->ItemHandle))
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvFreeDrvItemContext, remove on handle item map failed"));

        if (pItemCtx->ItemHandle)
            m_pDevice->FreeItemInfo(pItemCtx->ItemHandle);
        pItemCtx->ItemHandle = NULL;

        if (pItemCtx->pFormatInfo)
        {
            delete []pItemCtx->pFormatInfo;
            pItemCtx->pFormatInfo = NULL;
        }
        pItemCtx->NumFormatInfo = 0;

        if (pItemCtx->pThumb)
        {
            delete []pItemCtx->pThumb;
            pItemCtx->pThumb = NULL;
        }
        pItemCtx->ThumbSize = 0;
    }

    return S_OK;
}

/**************************************************************************\
* CWiaCameraDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvReadItemProperties");
    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvReadItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadRootItemProperties(pWiasContext, nPropSpec, pPropSpec);

    } else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadChildItemProperties(pWiasContext, nPropSpec, pPropSpec);

    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;

    //
    // This function doesn't need to do anything, because all of the camera
    // properties are written in drvValidateItemProperties
    //

    *plDevErrVal = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAcquireItemData
*
*   Transfer data from a mini driver item to device manger.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvAcquireItemData");
    HRESULT hr = S_OK;

    plDevErrVal = 0;

    //
    // Locals
    //
    BYTE *pTempBuf = NULL;
    LONG lBufSize = 0;

    //
    // Get item context
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, GetDrvItemContext"));
        return hr;
    }

    //
    // If the format requested is BMP or DIB, and the image is not already in BMP
    // format, convert it
    //
    BOOL bConvert = (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) && !(IsEqualGUID(m_FormatInfo[pItemCtx->ItemHandle->Format].FormatGuid, WiaImgFmt_BMP)) ) ||
                    (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP) && !(IsEqualGUID(m_FormatInfo[pItemCtx->ItemHandle->Format].FormatGuid, WiaImgFmt_MEMORYBMP)) );

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("drvAcquireItemData, FormatCode=%d, bConvert=%d", pItemCtx->ItemHandle->Format, bConvert));

    //
    // If the class driver did not allocate the transfer buffer or the image is being
    // converted to DIB or BMP, allocate a temporary buffer.
    //
    if (bConvert || !pmdtc->bClassDrvAllocBuf) {
        lBufSize = pItemCtx->ItemHandle->Size;
        pTempBuf = new BYTE[lBufSize];
        if (!pTempBuf)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, buffer allocation failed"));
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    // Acquire the data from the device
    //
    hr = AcquireData(pItemCtx, pmdtc, pTempBuf, lBufSize, bConvert);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, AcquireData failed"));
        goto Cleanup;
    }
    if (hr == S_FALSE)
    {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, transfer cancelled"));
        goto Cleanup;
    }

    //
    // Now convert the data to BMP, if necessary
    //
    if (bConvert)
    {
        hr = Convert(pWiasContext, pItemCtx, pmdtc, pTempBuf, lBufSize);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, Convert failed"));
            goto Cleanup;
        }
    }

Cleanup:
    if (pTempBuf)
    {
        delete []pTempBuf;
        pTempBuf = NULL;
        lBufSize = 0;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    *pcelt = 0;
    *ppwfi = NULL;

    IWiaDrvItem *pWiaDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, wiasGetDrvItem failed"));
        return hr;
    }

    ITEM_CONTEXT *pItemCtx = NULL;
    hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **) &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, GetDeviceSpecContext failed"));
        return hr;
    }

    if (!pItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, item context is null"));
        return E_FAIL;
    }

    FORMAT_CODE FormatCode;
    WIA_FORMAT_INFO *pwfi;

    if (!pItemCtx->pFormatInfo)
    {
        //
        // The format info list is not intialized. Do it now.
        //
        LONG ItemType;
        DWORD ui32;

        hr = wiasGetItemType(pWiasContext, &ItemType);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, wiasGetItemType failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }


        if ((ItemType&WiaItemTypeFile)&&(ItemType&WiaItemTypeImage) )
        {
            //
            // Create the supported format for the item, based on the format stored in the
            // ObjectInfo structure.
            //
            if (!pItemCtx->ItemHandle)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, ItemHandle is not initialized"));
                return E_FAIL;
            }

            //
            // If the format is not BMP, add the BMP types to the format array,
            // since this driver must support converting those to BMP
            //
            FormatCode = pItemCtx->ItemHandle->Format;

            BOOL bIsBmp = (IsEqualGUID(m_FormatInfo[FormatCode].FormatGuid, WiaImgFmt_BMP)) ||
                          (IsEqualGUID(m_FormatInfo[FormatCode].FormatGuid, WiaImgFmt_MEMORYBMP));

            ULONG NumWfi = bIsBmp ? 1 : 2;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            pwfi = new WIA_FORMAT_INFO[2 * NumWfi];
            if (!pwfi)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, memory allocation failed"));
                return E_OUTOFMEMORY;
            }

            pwfi[0].guidFormatID = WiaImgFmt_BMP;
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].guidFormatID = WiaImgFmt_MEMORYBMP;
            pwfi[1].lTymed = TYMED_CALLBACK;

            FORMAT_INFO *pFormatInfo = FormatCode2FormatInfo(FormatCode);

            //
            // Add entries when appropriate
            //
            if (!bIsBmp)
            {
                pwfi[2].guidFormatID = pFormatInfo->FormatGuid;
                pwfi[2].lTymed = TYMED_FILE;
                pwfi[3].guidFormatID = pFormatInfo->FormatGuid;
                pwfi[3].lTymed = TYMED_CALLBACK;
           }

            pItemCtx->NumFormatInfo = 2 * NumWfi;
            pItemCtx->pFormatInfo = pwfi;
        }
        else if (ItemType & WiaItemTypeFile) {

            if (!pItemCtx->ItemHandle)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, ItemHandle is not initialized"));
                return E_FAIL;
            }

            FormatCode = pItemCtx->ItemHandle->Format;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            pwfi = new WIA_FORMAT_INFO[2];
            if (!pwfi)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, memory allocation failed"));
                return E_OUTOFMEMORY;
            }

            FORMAT_INFO *pFormatInfo = FormatCode2FormatInfo(FormatCode);

            if( !pFormatInfo )
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, FormatCode2FormatInfo failed"));
                return E_FAIL;
            }

            pwfi[0].guidFormatID = pFormatInfo->FormatGuid;
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].guidFormatID = pFormatInfo->FormatGuid;
            pwfi[1].lTymed = TYMED_CALLBACK;

            //
            // Add entries when appropriate
            //
            pItemCtx->NumFormatInfo = 2;
            pItemCtx->pFormatInfo = pwfi;
        }
        else
        //  ((ItemType & WiaItemTypeFolder) || (ItemType & WiaItemTypeRoot))
        {
            //
            // Folders and the root don't really need format info, but some apps may fail
            // without it. Create a fake list just in case.
            //
            pItemCtx->pFormatInfo = new WIA_FORMAT_INFO[2];

            if (!pItemCtx->pFormatInfo)
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, memory allocation failed"));
                return E_OUTOFMEMORY;
            }

            pItemCtx->NumFormatInfo = 2;
            pItemCtx->pFormatInfo[0].lTymed = TYMED_FILE;
            pItemCtx->pFormatInfo[0].guidFormatID = FMT_NOTHING;
            pItemCtx->pFormatInfo[1].lTymed = TYMED_CALLBACK;
            pItemCtx->pFormatInfo[1].guidFormatID = FMT_NOTHING;
        }

    }   // end of IF

    *pcelt = pItemCtx->NumFormatInfo;
    *ppwfi = pItemCtx->pFormatInfo;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
***************************************************************************/

HRESULT CWiaCameraDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvValidateItemProperties");

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Have the service validate against the valid values for each property
    //
    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed"));
        return hr;
    }

    //
    // Get the item type
    //
    LONG lItemType  = 0;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        return hr;
    }

    //
    // Validate root item properties
    //
    if (lItemType & WiaItemTypeRoot) {

        //
        // None yet
        //

    }

    //
    // Validate child item properties
    //
    else {

        //
        // If tymed property was changed, update format and item size
        //
        if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_TYMED))
        {
            //
            // Create a property context needed by some WIA Service
            // functions used below.
            //
            WIA_PROPERTY_CONTEXT Context;
            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed"));
                return hr;
            }

            //
            // Use the WIA Service to update the valid values
            // for format. It will pull the values from the
            // structure returnd by drvGetWiaFormatInfo, using the
            // new value for tymed.
            //
            hr = wiasUpdateValidFormat(pWiasContext, &Context, (IWiaMiniDrv*) this);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                return hr;
            }

            //
            // Free the property context
            //
            hr = wiasFreePropContext(&Context);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasFreePropContext failed"));
                return hr;
            }

            //
            //  Update the item size
            //
            hr = SetItemSize(pWiasContext);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                return hr;
            }
        }

        //
        // If the format was changed, just update the item size
        //
        else if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_FORMAT))
        {
            //
            //  Update the item size
            //
            hr = SetItemSize(pWiasContext);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                return hr;
            }
        }

        //
        // Unconditionally update WIA_IPA_FILE_EXTENSION to match the current format
        //

        ITEM_CONTEXT *pItemCtx;
        hr = GetDrvItemContext(pWiasContext, &pItemCtx);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, GetDrvItemContext failed"));
            return hr;
        }

        BSTR      bstrFileExt       = NULL;
        ITEM_INFO *pItemInfo        = pItemCtx->ItemHandle;
        FORMAT_INFO *pFormatInfo    = NULL;
        if (pItemInfo)
        {
            pFormatInfo = FormatCode2FormatInfo(pItemInfo->Format);
            if( pFormatInfo->ExtensionString[0] )
            {
                bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
            }
            else // unknown file extension, get it from filename
            {
                WCHAR *pwcsTemp = wcsrchr(pItemInfo->pName, L'.');
                if( pwcsTemp )
                {
                    bstrFileExt = SysAllocString(pwcsTemp+1);
                }
                else
                {
                    bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
                }
            }
        }

        hr = wiasWritePropStr(pWiasContext, WIA_IPA_FILENAME_EXTENSION, bstrFileExt);
        if (bstrFileExt)
        {
            SysFreeString(bstrFileExt);
            bstrFileExt = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeleteItem
*
*   Delete an item from the device.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    plDevErrVal = 0;
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvDeleteItem");
    HRESULT hr = S_OK;

    ITEM_CONTEXT *pItemCtx = NULL;
    IWiaDrvItem *pDrvItem;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx, &pDrvItem);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, GetDrvItemContext failed"));
        return hr;
    }

    hr = m_pDevice->DeleteItem(pItemCtx->ItemHandle);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, delete item failed"));
        return hr;
    }

    //
    // Get the item's full name
    //
    BSTR bstrFullName;
    hr = pDrvItem->GetFullItemName(&bstrFullName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, GetFullItemName failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Queue an "item deleted" event
    //

    hr = wiasQueueEvent(m_bstrDeviceID,
                        &WIA_EVENT_ITEM_DELETED,
                        bstrFullName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeleteItem, wiasQueueEvent failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);

        // Continue to free the string and return hr
    }


    SysFreeString(bstrFullName);

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::DrvNotifyPnpEvent");
    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvGetCapabilites");
    *plDevErrVal = 0;

    if( !m_pCapabilities )
    {
        HRESULT hr = BuildCapabilities();
        if( hr != S_OK )
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
            return (hr);
        }
    }
    //
    //  Return values depend on the passed flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    switch (ulFlags) {
        case WIA_DEVICE_COMMANDS:

                //
                //  report commands only
                //

                *pcelt          = m_NumSupportedCommands;
                *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
                break;
        case WIA_DEVICE_EVENTS:

                //
                //  report events only
                //

                *pcelt          = m_NumSupportedEvents;
                *ppCapabilities = m_pCapabilities;
                break;
        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

                //
                //  report both events and commands
                //

                *pcelt          = m_NumCapabilities;
                *ppCapabilities = m_pCapabilities;
                break;
        default:

                //
                //  invalid request
                //

                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
                return E_INVALIDARG;
    }
    return S_OK;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvDeviceCommand");
    *plDevErrVal = 0;
    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Re-build the item tree, if the device needs it.
        //

        if (m_DeviceInfo.bSyncNeeded)
        {
            hr = DeleteItemTree(WiaItemTypeDisconnected);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, DeleteItemTree failed"));
                return hr;
            }

            m_pDevice->FreeDeviceInfo(&m_DeviceInfo);
            memset(&m_DeviceInfo, 0, sizeof(m_DeviceInfo));

            hr = m_pDevice->GetDeviceInfo(&m_DeviceInfo);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, GetDeviceInfo failed"));
                return hr;
            }

            hr = BuildItemTree();
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, BuildItemTree failed"));
                return hr;
            }
        }
    }

#if DEADCODE

    //
    // Not implemented yet
    //
    else if (*plCommand == WIA_CMD_TAKE_PICTURE) {

        //
        // TAKE_PICTURE - Command the camera to capture a new image.
        //

        ITEM_HANDLE NewImage = 0;
        hr = m_pDevice->TakePicture(&NewImage);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, take picture failed"));
            return hr;
        }

        // ISSUE-10/17/2000-davepar Create a new driver item for the new image
    }
#endif

    else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command"));
        hr = E_NOTIMPL;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvAnalyzeItem");
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::drvGetDeviceErrorStr");
    HRESULT hr = S_OK;
    *plDevErr  = 0;

    //
    //  Map device errors to a string appropriate for showing to the user
    //

    // ISSUE-10/17/2000-davepar These should be read from the resource file

    switch (lDevErrVal) {
        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            hr = E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
\**************************************************************************/

HRESULT CWiaCameraDevice::SetItemSize(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::SetItemSize");
    HRESULT  hr = S_OK;

    LONG lItemSize     = 0;
    LONG lWidthInBytes = 0;
    GUID guidFormatID  = GUID_NULL;

    LONG lNumProperties = 2;
    PROPVARIANT pv[2];
    PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE}};

    //
    // Get the driver item context
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, GetDrvItemContext failed"));
        return hr;
    }

    //
    // Read the format GUID
    //
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }

    if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP) ||
        IsEqualCLSID(guidFormatID, WiaImgFmt_MEMORYBMP))
    {

        if( !(pItemCtx->ItemHandle->Width) ||
            !(pItemCtx->ItemHandle->Depth) ||
            !(pItemCtx->ItemHandle->Height) )
        { // Since we are going to use these, make sure they are filled in
            LONG lNumPropToRead = 3;
            PROPSPEC pPropsToRead[3] = {    {PRSPEC_PROPID, WIA_IPA_DEPTH},
                                            {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
                                            {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE} };

            hr = ReadChildItemProperties(pWiasContext, lNumPropToRead, pPropsToRead);

            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadItemProperties failed"));
                return hr;
            }
        }

        lItemSize = sizeof(BITMAPINFOHEADER);

        //
        // if this is a file, add file header to size
        //
        if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP))
        {
            lItemSize += sizeof(BITMAPFILEHEADER);
        }

        //
        // Calculate number of bytes per line, width must be
        // aligned to 4 byte boundary.
        //
        lWidthInBytes = ((pItemCtx->ItemHandle->Width * pItemCtx->ItemHandle->Depth + 31) & ~31) / 8;

        //
        // Calculate image size
        //
        lItemSize += lWidthInBytes * pItemCtx->ItemHandle->Height;
    }
    else
    {
        lItemSize = pItemCtx->ItemHandle->Size;
        lWidthInBytes = 0;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = lItemSize;
    pv[1].lVal = lWidthInBytes;

    //
    // Write WIA_IPA_ITEM_SIZE and WIA_IPA_BYTES_PER_LINE property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, wiasWriteMultiple failed"));
        return hr;
    }

    return hr;
}

/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* DeleteItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::DeleteItemTree(LONG lReason)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pRootItem) {
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pRootItem->UnlinkItemTree(lReason);

    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, UnlinkItemTree failed"));
        return hr;
    }

    m_pRootItem->Release();
    m_pRootItem = NULL;

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildItemTree()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::BuildItemTree");
    HRESULT hr = S_OK;

    //
    // Make sure the item tree doesn't already exist
    //
    if (m_pRootItem)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, item tree already exists"));
        return E_FAIL;
    }

    //
    //  Create the root item name
    //
    BSTR bstrRoot = SysAllocString(L"Root");
    if (!bstrRoot)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, SysAllocString failed"));
        hr = E_OUTOFMEMORY;
    }

    //
    //  Create the root item
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = wiasCreateDrvItem(WiaItemTypeFolder | WiaItemTypeDevice | WiaItemTypeRoot,
                           bstrRoot,
                           m_bstrRootFullItemName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &m_pRootItem);

    SysFreeString(bstrRoot);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
        return hr;
    }

    //
    // Initialize item context fields for the root
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));
    pItemCtx->ItemHandle = ROOT_ITEM_HANDLE;

    //
    // Put the root item in the handle map
    //
    m_HandleItemMap.Add(ROOT_ITEM_HANDLE, m_pRootItem);

    //
    // Get the list of items from the camera
    //
    ITEM_HANDLE *pItemArray = new ITEM_HANDLE[m_DeviceInfo.TotalItems];
    if (!pItemArray)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, memory allocation failed"));
        return E_OUTOFMEMORY;
    }
    m_pDevice->GetItemList(pItemArray);

    //
    // Create a driver item for each item on the camera
    //
    for (int count = 0; count < m_DeviceInfo.TotalItems; count++)
    {
        hr = AddObject(pItemArray[count]);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddObject failed"));
            return hr;
        }
    }

    return hr;
}

/**************************************************************************\
* AddObject
*
*   Helper function to add an object to the tree
*
* Arguments:
*
*    pItemHandle    - Pointer to the item handle
*
\**************************************************************************/
HRESULT CWiaCameraDevice::AddObject(ITEM_HANDLE ItemHandle, BOOL bQueueEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::AddObject");

    HRESULT hr = S_OK;

    LONG ExtraFlags = 0;

    //
    // Get information about the item from the camera
    //
    ITEM_INFO *pItemInfo = ItemHandle;
    if (!pItemInfo)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, invalid arg"));
        return E_INVALIDARG;
    }

    //
    // Look up the item's parent in the map
    //
    IWiaDrvItem *pParent = NULL;
    pParent = m_HandleItemMap.Lookup(pItemInfo->Parent);

    //
    // If a parent wasn't found, just use the root as the parent
    //
    if (!pParent)
    {
        pParent = m_pRootItem;
    }


#ifdef CHECK_DOT_IN_FILENAME
    //
    // Make sure there is no filename extension in the name
    //
    if (wcschr(pItemInfo->pName, L'.'))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, item name=%S", pItemInfo->pName));
        return E_FAIL;
    }
#endif

    //
    // Create the item's full name
    //
    BSTR bstrItemFullName = NULL;
    BSTR bstrParentName = NULL;

    hr = pParent->GetFullItemName(&bstrParentName);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, GetFullItemName failed"));
        return hr;
    }

    WCHAR wcsName[MAX_PATH];
    wsprintf(wcsName, L"%s\\%s", bstrParentName, pItemInfo->pName);

    bstrItemFullName = SysAllocString(wcsName);
    if (!bstrItemFullName)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, SysAllocString failed"));
        return E_OUTOFMEMORY;
    }

    //
    // Look up information about the item's format
    //
    LONG lItemType=0;

    //
    // See if the item has attachments
    //
    if (pItemInfo->bHasAttachments)
        ExtraFlags |= WiaItemTypeHasAttachments;

    if( pItemInfo->bIsFolder)
    {
        lItemType = ITEMTYPE_FOLDER;
    }
    else
    {
        lItemType = m_FormatInfo[pItemInfo->Format].ItemType;
    }

    //
    // Create the driver item
    //
    IWiaDrvItem *pItem = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;
    hr = wiasCreateDrvItem(lItemType | ExtraFlags,
                           pItemInfo->pName,
                           bstrItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &pItem);

    SysFreeString(bstrParentName);

    if (FAILED(hr) || !pItem || !pItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, wiasCreateDrvItem failed"));
        return hr;
    }

    //
    // Fill in the driver item context. Wait until the thumbnail is requested before
    // reading it in.
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));
    pItemCtx->ItemHandle = ItemHandle;

    //
    // Place the new item under it's parent
    //
    hr = pItem->AddItemToFolder(pParent);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, AddItemToFolder failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Add the item to the item handle/driver item map
    //
    if (!m_HandleItemMap.Add(ItemHandle, pItem))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, handle item map Add failed"));
        return E_OUTOFMEMORY;
    }

    //
    // Eventhough, there is still a reference to the item in the handle/item map, release
    // it here, because there isn't a convenient place to do it later
    //
    pItem->Release();

    //
    // Post an item added event, if requested
    //
    if (bQueueEvent)
    {
        hr = wiasQueueEvent(m_bstrDeviceID, &WIA_EVENT_ITEM_CREATED, bstrItemFullName);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AddObject, wiasQueueEvent failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }

    SysFreeString(bstrItemFullName);

    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = 3;
    m_NumCapabilities       = (m_NumSupportedCommands + m_NumSupportedEvents);


    m_pCapabilities = new WIA_DEV_CAP_DRV[m_NumCapabilities];
    if (m_pCapabilities) {

        //
        // Initialize EVENTS
        //

        // WIA_EVENT_DEVICE_CONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[0].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[0].wszDescription),TRUE);
        m_pCapabilities[0].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
        m_pCapabilities[0].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[0].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

        // WIA_EVENT_DEVICE_DISCONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[1].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[1].wszDescription),TRUE);
        m_pCapabilities[1].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
        m_pCapabilities[1].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[1].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

        // WIA_EVENT_ITEM_DELETED
        GetOLESTRResourceString(IDS_EVENT_ITEM_DELETED_NAME,&(m_pCapabilities[2].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_ITEM_DELETED_DESC,&(m_pCapabilities[2].wszDescription),TRUE);
        m_pCapabilities[2].guid           = (GUID*)&WIA_EVENT_ITEM_DELETED;
        m_pCapabilities[2].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[2].wszIcon        = WIA_ICON_ITEM_DELETED;


        //
        // Initialize COMMANDS
        //

        // WIA_CMD_SYNCHRONIZE
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[3].wszName),TRUE);
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[3].wszDescription),TRUE);
        m_pCapabilities[3].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
        m_pCapabilities[3].ulFlags        = 0;
        m_pCapabilities[3].wszIcon        = WIA_ICON_SYNCHRONIZE;

        // ISSUE-10/17/2000-davepar Add TakePicture if the camera supports it
    }
    else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildCapabilities, memory allocation failed"));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::DeleteCapabilitiesArrayContents()
{
    HRESULT hr = S_OK;

    if (m_pCapabilities) {
        for (LONG i = 0; i < m_NumCapabilities; i++) {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }

        delete []m_pCapabilities;
        m_pCapabilities = NULL;
    }

    m_NumSupportedCommands = 0;
    m_NumSupportedEvents = 0;
    m_NumCapabilities = 0;

    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
\**************************************************************************/
HRESULT CWiaCameraDevice::GetBSTRResourceString(LONG lResourceID, BSTR *pBSTR, BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[MAX_PATH];
    if (bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst, lResourceID, szStringValue, MAX_PATH);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[MAX_PATH];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           sizeof(wszStringValue));

       *pBSTR = SysAllocString(wszStringValue);
#endif

       if (!*pBSTR) {
           WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetBSTRResourceString, SysAllocString failed"));
           return E_OUTOFMEMORY;
       }

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }

    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
\**************************************************************************/
HRESULT CWiaCameraDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           sizeof(wszStringValue));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* VerticalFlip
*
*
*
* Arguments:
*
*
*
\**************************************************************************/

VOID CWiaCameraDevice::VerticalFlip(
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext
    )

{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWiaCameraDevice::VerticalFlip");
    HRESULT hr = S_OK;

    LONG        iHeight;
    LONG        iWidth        = pItemCtx->ItemHandle->Width;
    ULONG       uiDepth       = pItemCtx->ItemHandle->Depth;
    LONG        ScanLineWidth = iWidth * uiDepth / 8;
    PBITMAPINFO pbmi          = NULL;
    PBYTE       pImageTop     = NULL;

    //
    // find out if data is TYMED_FILE or TYMED_HGLOBAL
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer + sizeof(BITMAPFILEHEADER));

    } else if (pDataTransferContext->tymed == TYMED_HGLOBAL) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer);

    } else {
        return;
    }

    //
    // init memory pointer and height
    //

    pImageTop = &pDataTransferContext->pTransferBuffer[0] + pDataTransferContext->lHeaderSize;
    iHeight = pbmi->bmiHeader.biHeight;

    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,ScanLineWidth);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * ScanLineWidth;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,ScanLineWidth);
            memcpy(pImageTop,pImageBottom,ScanLineWidth);
            memcpy(pImageBottom,pBuffer,ScanLineWidth);

            pImageTop    += ScanLineWidth;
            pImageBottom -= ScanLineWidth;
        }

        LocalFree(pBuffer);
    }
}

/**************************************************************************\
* FormatCode2FormatInfo
*
*   This helper function looks up information about an item's format based
*   on the format code.
*
* Arguments:
*
*   ItemType - the item's type
*
\**************************************************************************/

FORMAT_INFO *CWiaCameraDevice::FormatCode2FormatInfo(FORMAT_CODE FormatCode)
{
    if (FormatCode > (LONG)m_NumFormatInfo)
        FormatCode = 0;
    if (FormatCode < 0)
        FormatCode = 0;

    return &m_FormatInfo[FormatCode];
}

/**************************************************************************\
* GetDrvItemContext
*
*   This helper function gets the driver item context.
*
* Arguments:
*
*   pWiasContext - service context
*   ppItemCtx    - pointer to pointer to item context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::GetDrvItemContext(BYTE *pWiasContext, ITEM_CONTEXT **ppItemCtx,
                                            IWiaDrvItem **ppDrvItem)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::GetDrvItemContext");
    HRESULT hr = S_OK;

    if (!pWiasContext || !ppItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, invalid arg"));
        return E_INVALIDARG;
    }

    IWiaDrvItem *pWiaDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    *ppItemCtx = NULL;
    hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **) ppItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, GetDeviceSpecContext failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    if (!*ppItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDrvItemContext, item context is null"));
        return E_FAIL;
    }

    if (ppDrvItem)
    {
        *ppDrvItem = pWiaDrvItem;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiacam.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_ITEM_DELETED_NAME        121
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_EVENT_ITEM_DELETED_DESC        122
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDC_STATIC                      -1

#define IDB_BITMAP_VIDEO                   120

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\private.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        private.h
*
*  VERSION:     1.0
*
*  DATE:        11/8/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Definitions for the wiautil.lib library, which should not be public.
*
*****************************************************************************/

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

class CImageStream : public IStream
{
public:
	CImageStream();
	~CImageStream();

    STDMETHOD(SetBuffer)(BYTE *pBuffer, INT iSize, SKIP_AMOUNT iSkipAmt = SKIP_OFF);
    
    // IUnknown 

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISequentialStream

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
    LONG                m_cRef;         // Reference count
    
    BYTE               *m_pBuffer;      // Buffer to use for reads and writes
    INT                 m_iSize;        // Size of the buffer
    INT                 m_iPosition;    // Current position in the buffer
    INT                 m_iOffset;      // Offset to apply to reads and writes
    BYTE                m_Header[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)];
                                        // Location to store bmp file and info headers
};

#endif // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\wiacam.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       wiacam.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA File System Device driver Class Factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
// IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    return TRUE;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

//    WIAS_LTRACE(g_pIWiaLog,
//                WIALOG_NO_RESOURCE_ID,
//                WIALOG_LEVEL3,
//                ("CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory, (creating)"));
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
{
    // Destructor logic
//    WIAS_LTRACE(g_pIWiaLog,
//                WIALOG_NO_RESOURCE_ID,
//                WIALOG_LEVEL3,
//                ("CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    CWiaCameraDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new CWiaCameraDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWiaCameraDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWiaCameraDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWiaCameraDevice::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
\**************************************************************************/

extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
//            DBG_INIT(hinst);
            DisableThreadLibraryCalls(hinst);
//          if( ERROR_SUCCESS != PopulateFormatInfo() )
//              return FALSE;
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {

            }
//          UnPopulateFormatInfo();
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_FSUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_FSUsd)) {
        CWiaCameraDeviceClassFactory *pcf = new CWiaCameraDeviceClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\wiacam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       wiacam.h
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*       Definition of WIA File System Device driver object
*
***************************************************************************/

#ifndef WIACAM__H_
#define WIACAM__H_

extern HINSTANCE  g_hInst;     // DLL module instance
// extern IWiaLog   *g_pIWiaLog;  // pointer to WIA logging interface

#if defined( _WIN32 ) && !defined( _NO_COM)

// {D2923B86-15F1-46FF-A19A-DE825F919576}
DEFINE_GUID(CLSID_FSUsd, 0xD2923B86, 0x15F1, 0x46FF, 0xA1, 0x9A, 0xDE, 0x82, 0x5F, 0x91, 0x95, 0x76);

#endif

//////////////////////////////////////////////////////////////////////////
// DLL #define Section                                                  //
//////////////////////////////////////////////////////////////////////////

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"
#define DATASEG_DEFAULT         DATASEG_SHARED

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);

#pragma data_seg(DATASEG_PERINSTANCE)
#pragma data_seg(DATASEG_DEFAULT)

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);
extern void DllAddRef(void);
extern void DllRelease(void);


/***************************************************************************\
*
*  CWiaCameraDeviceClassFactory
*
\****************************************************************************/

class CWiaCameraDeviceClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    CWiaCameraDeviceClassFactory();
    ~CWiaCameraDeviceClassFactory();
};


//
// Base structure for supporting non-delegating IUnknown for contained objects
//
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD (NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef) (THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease) (THIS) PURE;
};

//
// General purpose GUIDs
//
DEFINE_GUID(GUID_NULL, 0,0,0,0,0,0,0,0,0,0,0);

DEFINE_GUID(FMT_NOTHING,
            0x81a566e7,0x8620,0x4fba,0xbc,0x8e,0xb2,0x7c,0x17,0xad,0x9e,0xfd);

//
// Driver item context
//
typedef struct _ITEM_CONTEXT{
    ITEM_HANDLE         ItemHandle;     // Handle to the camera item
    LONG                NumFormatInfo;  // Number of entries in format info array
    WIA_FORMAT_INFO    *pFormatInfo;    // Pointer to format info array 
    LONG                ThumbSize;      // Size of the thumbnail data in bytes
    BYTE               *pThumb;         // Thumbnail data
} ITEM_CONTEXT, *PITEM_CONTEXT;

//
// Handy constants for common item types
//
const ULONG ITEMTYPE_FILE   = WiaItemTypeFile;
const ULONG ITEMTYPE_IMAGE  = WiaItemTypeFile | WiaItemTypeImage;
const ULONG ITEMTYPE_AUDIO  = WiaItemTypeFile | WiaItemTypeAudio;
const ULONG ITEMTYPE_VIDEO  = WiaItemTypeFile | WiaItemTypeVideo;
const ULONG ITEMTYPE_FOLDER = WiaItemTypeFolder;
const ULONG ITEMTYPE_BURST  = WiaItemTypeFolder | WiaItemTypeBurst;
const ULONG ITEMTYPE_HPAN   = WiaItemTypeFolder | WiaItemTypeHPanorama;
const ULONG ITEMTYPE_VPAN   = WiaItemTypeFolder | WiaItemTypeVPanorama;

//
// Structure which holds everything needed for each format type.
//
#ifndef FORMAT_INFO_STRUCTURE
#define FORMAT_INFO_STRUCTURE

#define MAXEXTENSIONSTRINGLENGTH 8
typedef struct _FORMAT_INFO
{
    GUID    FormatGuid;         // WIA format GUID
    WCHAR   ExtensionString[MAXEXTENSIONSTRINGLENGTH];   // File extension
    LONG    ItemType;           // WIA item type
} FORMAT_INFO, *PFORMAT_INFO;
#endif 

typedef struct _DEFAULT_FORMAT_INFO
{
    GUID    *pFormatGuid;         // WIA format GUID
    LONG    ItemType;           // WIA item type
    WCHAR   *ExtensionString;   // File extension
} DEFAULT_FORMAT_INFO, *PDEFAULT_FORMAT_INFO;

//
// Minimum data call back transfer buffer size
//
const LONG MIN_BUFFER_SIZE   = 0x8000;

//
// When doing a transfer and convert to BMP, this value
// represents how much of the time is spent doing the
// transfer of data from the device.
//
const LONG TRANSFER_PERCENT = 90;

//
// Class definition for sample WIA scanner object
//

class CWiaCameraDevice : public IStiUSD,               // STI USD interface
                         public IWiaMiniDrv,           // WIA Minidriver interface
                         public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWiaCameraDevice(LPUNKNOWN punkOuter);
    ~CWiaCameraDevice();

private:

    // COM object data
    ULONG                m_cRef;                 // Device object reference count
    LPUNKNOWN            m_punkOuter;            // Pointer to outer unknown

    // STI data
    PSTIDEVICECONTROL    m_pIStiDevControl;      // Device control interface
    IStiDevice          *m_pStiDevice;           // Sti object
    DWORD                m_dwLastOperationError; // Last error
    WCHAR                m_pPortName[MAX_PATH];  // Port name for accessing the device

    // WIA data
    BSTR                 m_bstrDeviceID;         // WIA unique device ID
    BSTR                 m_bstrRootFullItemName; // Root item name
    IWiaDrvItem         *m_pRootItem;            // Root item

    LONG                 m_NumSupportedCommands; // Number of supported commands
    LONG                 m_NumSupportedEvents;   // Number of supported events
    LONG                 m_NumCapabilities;      // Number of capabilities
    WIA_DEV_CAP_DRV     *m_pCapabilities;        // Capabilities array

    // Device data
    FakeCamera          *m_pDevice;              // Pointer to device class
    DEVICE_INFO          m_DeviceInfo;           // Device information
    CWiaMap<ITEM_HANDLE, IWiaDrvItem *>
                         m_HandleItemMap;        // Maps item handles to drv items
    
    // Misc data
    int                  m_ConnectedApps;        // Number of app connected to this driver
    CWiauFormatConverter m_Converter;
    IWiaLog             *m_pIWiaLog;

public:

    FORMAT_INFO         *m_FormatInfo;
    UINT                 m_NumFormatInfo;

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHODIMP Initialize(PSTIDEVICECONTROL pHelDcb, DWORD dwStiVersion, HKEY hParametersKey);
    STDMETHODIMP GetCapabilities(PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus(PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPDIAG pBuffer);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE EscapeFunction, LPVOID lpInData, DWORD cbInDataSize,
                        LPVOID pOutData, DWORD dwOutDataSize, LPDWORD pdwActualData);
    STDMETHODIMP GetLastError(LPDWORD pdwLastDeviceError);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHODIMP drvInitializeWia(BYTE *pWiasContext, LONG lFlags, BSTR bstrDeviceID, BSTR bstrRootFullItemName,
                                  IUnknown *pStiDevice, IUnknown *pIUnknownOuter, IWiaDrvItem  **ppIDrvItemRoot,
                                  IUnknown **ppIUnknownInner, LONG *plDevErrVal);
    STDMETHODIMP drvUnInitializeWia(BYTE* pWiasContext);
    STDMETHODIMP drvDeviceCommand(BYTE *pWiasContext, LONG lFlags, const GUID *pGUIDCommand,
                                  IWiaDrvItem **ppMiniDrvItem, LONG *plDevErrVal);
    STDMETHODIMP drvDeleteItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetCapabilities(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                    WIA_DEV_CAP_DRV **ppCapabilities, LONG *plDevErrVal);
    STDMETHODIMP drvInitItemProperties(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvLockWiaDevice(BYTE  *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvUnLockWiaDevice(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvAnalyzeItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetWiaFormatInfo(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                     WIA_FORMAT_INFO **ppwfi, LONG *plDevErrVal);
    STDMETHODIMP drvNotifyPnpEvent(const GUID *pEventGUID, BSTR bstrDeviceID, ULONG ulReserved);
    STDMETHODIMP drvReadItemProperties(BYTE *pWiaItem, LONG lFlags, ULONG nPropSpec,
                                       const PROPSPEC *pPropSpec, LONG  *plDevErrVal);
    STDMETHODIMP drvWriteItemProperties(BYTE *pWiasContext, LONG lFLags,
                                        PMINIDRV_TRANSFER_CONTEXT pmdtc, LONG *plDevErrVal);
    STDMETHODIMP drvValidateItemProperties(BYTE *pWiasContext, LONG lFlags, ULONG nPropSpec,
                                           const PROPSPEC *pPropSpec, LONG *plDevErrVal);
    STDMETHODIMP drvAcquireItemData(BYTE *pWiasContext, LONG lFlags,
                                    PMINIDRV_TRANSFER_CONTEXT pDataContext, LONG *plDevErrVal);
    STDMETHODIMP drvGetDeviceErrorStr(LONG lFlags, LONG lDevErrVal, LPOLESTR *ppszDevErrStr, LONG *plDevErrVal);
    STDMETHODIMP drvFreeDrvItemContext(LONG lFlags, BYTE *pDevContext, LONG *plDevErrVal);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////

    //
    // WIA Item Management Helpers
    //
    HRESULT BuildItemTree(void);
    HRESULT AddObject(ITEM_HANDLE ItemHandle, BOOL bQueueEvent = FALSE);
    HRESULT DeleteItemTree(LONG lReason);

    //
    // WIA Property Management Helpers
    //
    HRESULT BuildRootItemProperties(BYTE *pWiasContext);
    HRESULT ReadRootItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    
    HRESULT BuildChildItemProperties(BYTE *pWiasContext);
    HRESULT GetValidFormats(BYTE *pWiasContext, LONG TymedValue, int *pNumFormats, GUID **ppFormatArray);
    HRESULT ReadChildItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT CacheThumbnail(ITEM_CONTEXT *pItemCtx, ULONG uItemType);
    HRESULT AcquireData(ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                        BYTE *pBuf, LONG lBufSize, BOOL bConverting);
    HRESULT Convert(BYTE *pWiasContext, ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                    BYTE *pNativeImage, LONG lNativeSize);

    //
    // WIA Capability Management Helpers
    //
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();
    HRESULT SetItemSize(BYTE *pWiasContext);

    //
    // WIA Resource file Helpers
    //
    HRESULT GetBSTRResourceString(LONG lLocalResourceID, BSTR *pBSTR, BOOL bLocal);
    HRESULT GetOLESTRResourceString(LONG lLocalResourceID, LPOLESTR *ppsz, BOOL bLocal);

    //
    // Miscellaneous Helpers
    //
    HRESULT GetDrvItemContext(BYTE *pWiasContext, ITEM_CONTEXT **ppItemCtx, IWiaDrvItem **ppDrvItem = NULL);
    
    VOID VerticalFlip(
        PITEM_CONTEXT              pDrvItemContext,
        PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);

    FORMAT_INFO *FormatCode2FormatInfo(FORMAT_CODE ItemType);
    DWORD PopulateFormatInfo(void);
    void  UnPopulateFormatInfo(void);
                                     
public:
    VOID RunNotifications(VOID);
};

typedef CWiaCameraDevice *PWIACAMERADEVICE;

#endif // #ifndef WIACAM__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\root.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2001, MICROSOFT CORP.
*
*  TITLE:       Root.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for the root item.
*
*******************************************************************************/

#include "pch.h"

/**************************************************************************\
* BuildRootItemProperties
*
*   Create the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildRootItemProperties(
    BYTE *pWiasContext
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::BuildRootItemProperties");
    
    HRESULT hr = S_OK;

    //
    // Create a WIA property list and allocate enough space for all
    // the properties created below
    //
    CWiauPropertyList RootProps;

    hr = RootProps.Init(50);

    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, initializing property list failed"));
        return hr;
    }

    //
    // These are the WHQL required properties for cameras:
    //
    INT index;

    hr = RootProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, (LONG) WIA_ITEM_READ | WIA_ITEM_WRITE);

    hr = RootProps.DefineProperty(&index, WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.FirmwareVersion);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.PicturesTaken);

#ifdef COUNT_PIC_REMAINING
    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.PicturesRemaining);
#endif

    //
    // These are WHQL optional properties
    //

#if DEADCODE
    
    hr = RootProps.DefineProperty(&index, WIA_DPA_DEVICE_TIME, WIA_DPA_DEVICE_TIME_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, &m_DeviceInfo.Time);


    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_MODE, WIA_DPC_EXPOSURE_MODE_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureMode);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_COMP, WIA_DPC_EXPOSURE_COMP_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureComp);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_TIME, WIA_DPC_EXPOSURE_TIME_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureTime);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FNUMBER, WIA_DPC_FNUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FLASH_MODE, WIA_DPC_FLASH_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FlashMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_MODE, WIA_DPC_FOCUS_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocusMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PAN_POSITION, WIA_DPC_PAN_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PanPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TILT_POSITION, WIA_DPC_TILT_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TiltPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_MODE, WIA_DPC_TIMER_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TimerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_VALUE, WIA_DPC_TIMER_VALUE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TimerValue);

    hr = RootProps.DefineProperty(&index, WIA_DPC_POWER_MODE, WIA_DPC_POWER_MODE_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PowerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BATTERY_STATUS, WIA_DPC_BATTERY_STATUS_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.BatteryStatus);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_WIDTH, WIA_DPC_THUMB_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ThumbWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_HEIGHT, WIA_DPC_THUMB_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ThumbHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PictWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.PictHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_COMPRESSION_SETTING, WIA_DPC_COMPRESSION_SETTING_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.CompressionSetting);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMELAPSE_INTERVAL, WIA_DPC_TIMELAPSE_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.TimelapseInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_INTERVAL, WIA_DPC_BURST_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.BurstInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_NUMBER, WIA_DPC_BURST_NUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.BurstNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EFFECT_MODE, WIA_DPC_EFFECT_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.EffectMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_DIGITAL_ZOOM, WIA_DPC_DIGITAL_ZOOM_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.DigitalZoom);

    hr = RootProps.DefineProperty(&index, WIA_DPC_SHARPNESS, WIA_DPC_SHARPNESS_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.Sharpness);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CONTRAST, WIA_DPC_CONTRAST_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.Constrast);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_MODE, WIA_DPC_CAPTURE_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.CaptureMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_DELAY, WIA_DPC_CAPTURE_DELAY_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.CaptureDelay);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_INDEX, WIA_DPC_EXPOSURE_INDEX_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureIndex);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_METERING_MODE, WIA_DPC_EXPOSURE_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.ExposureMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_METERING_MODE, WIA_DPC_FOCUS_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocusMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_DISTANCE, WIA_DPC_FOCUS_DISTANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocusDistance);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCAL_LENGTH, WIA_DPC_FOCAL_LENGTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.FocalLength);

    hr = RootProps.DefineProperty(&index, WIA_DPC_RGBGAIN, WIA_DPC_RGBGAIN_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.RGBGain);

    hr = RootProps.DefineProperty(&index, WIA_DPC_WHITE_BALANCE, WIA_DPC_WHITE_BALANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, CameraStats.WhiteBalance);

#endif // DEADCODE

    //
    // TODO: Add other optional properties that your device supports here
    //


    // Last step: send all the properties to WIA

    hr = RootProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, SendToWia failed"));
    }

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //
failure:
    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, DefineProperty failed"));
    return hr;
}

/**************************************************************************\
* ReadRootItemProperties
*
*   Update the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::ReadRootItemProperties(
    BYTE           *pWiasContext,
    LONG            NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::ReadRootItemProperties");
    HRESULT hr = S_OK;

    if (!NumPropSpecs || !pPropSpecs)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadRootItemProperties, invalid arg"));
        return E_INVALIDARG;
    }

    //
    // Loop through all of the PropSpecs
    //
    for (int count = 0; count < NumPropSpecs; count++)
    {
        PROPID propId = pPropSpecs[count].propid;
        
        switch (propId)
        {
        case WIA_DPC_PICTURES_TAKEN:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, m_DeviceInfo.PicturesTaken);
            break;

#ifdef COUNT_PIC_REMAINING
        case WIA_DPC_PICTURES_REMAINING:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_REMAINING, m_DeviceInfo.PicturesRemaining);
            break;
#endif
        default:
            break;
        }
        
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadRootItemProperties, wiasWritePropLong failed 0x%08x", propId));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\wiatempl.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    wiatempl.h

Abstract:

    This module declares useful types such as CWiaArray and CWiaMap.
    These were lifted from the ATL library (atlbase.h).

Author:

    DavePar
    
Revision History:


--*/

#ifndef TYPEUTIL__H_
#define TYPEUTIL__H_

#ifndef ASSERT
#define ASSERT(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CWiaArray & CWiaMap

template <class T>
class CWiaArray
{
public:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

// Construction/destruction
    CWiaArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CWiaArray()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL GrowTo(int size)
    {
        if (size > m_nAllocSize)
        {
            T* aT;
            aT = (T*) realloc(m_aT, size * sizeof(T));
            if (aT == NULL)
                return FALSE;
            m_nAllocSize = size;
            m_aT = aT;
        }
        return TRUE;
    }
    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
            if (!GrowTo(nNewAllocSize))
                return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    int AddN(T& t) // Adds the new item and returns its index
    {
        if (Add(t))
            return m_nSize - 1;
        else
            return -1;
    }
    BOOL Push(T& t)
    {
        return Add(t);
    }
    BOOL Pop(T& t)
    {
        if (m_nSize == 0)
            return FALSE;
        t = m_aT[m_nSize - 1];
        return RemoveAt(m_nSize - 1);
    }
    BOOL Remove(const T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {

        //---- always call the dtr ----
#if _MSC_VER >= 1200
        m_aT[nIndex].~T();
#else
        T* MyT;
                MyT = &m_aT[nIndex];
                MyT->~T();
#endif

        //---- if target entry is not at end, compact the array ----
        if(nIndex != (m_nSize - 1))
        {
            
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
        }

        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aT != NULL)
        {
            for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
                m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
            free(m_aT);
            m_aT = NULL;
        }
        m_nSize = 0;
        m_nAllocSize = 0;
    }
    T& operator[] (int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

// Implementation
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <class _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, T& t)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aT + nIndex) Wrapper(t);
    }
    int Find(const T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
    BOOL Parse(BYTE **ppRaw, int NumSize = 4)
    {
        if (!ppRaw || !*ppRaw)
            return FALSE;
    
        RemoveAll();
    
        // Get the number of elements from the raw data
        int NumElems;
        DWORD *pDword = (DWORD *) *ppRaw;
        WORD *pWord = (WORD *) *ppRaw;
        switch (NumSize)
        {
        case 4:
            NumElems = *pDword;
            break;
        case 2:
            NumElems = *pWord;
            break;
        case 1:
            NumElems = **ppRaw;
            break;
        default:
            return FALSE;
        }

        *ppRaw += NumSize;
    
        // Allocate space for the array
        if (!GrowTo(NumElems))
            return FALSE;
    
        // Copy in the elements
        memcpy(m_aT, *ppRaw, NumElems * sizeof(T));
        m_nSize = NumElems;
    
        // Advance the raw pointer past the array and number of elements field
        *ppRaw += NumElems * sizeof(T);
    
        return TRUE;
    }
};

// for arrays of simple types
template <class T>
class CWiaValArray : public CWiaArray< T >
{
public:
    BOOL Add(T t)
    {
        return CWiaArray< T >::Add(t);
    }
    BOOL Remove(T t)
    {
        return CWiaArray< T >::Remove(t);
    }
    T operator[] (int nIndex) const
    {
        return CWiaArray< T >::operator[](nIndex);
    }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CWiaMap
{
public:
    TKey* m_aKey;
    TVal* m_aVal;
    int m_nSize;

// Construction/destruction
    CWiaMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
    { }

    ~CWiaMap()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Add(TKey key, TVal val)
    {
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
        if(pKey == NULL)
            return FALSE;
        m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
        if(pVal == NULL)
            return FALSE;
        m_aVal = pVal;
        m_nSize++;
        SetAtIndex(m_nSize - 1, key, val);
        return TRUE;
    }
    BOOL Remove(TKey key)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        if(nIndex != (m_nSize - 1))
        {
            m_aKey[nIndex].~TKey();
#if _MSC_VER >= 1200
            m_aVal[nIndex].~TVal();
#else
            TVal * t1;
            t1 = &m_aVal[nIndex];
            t1->~TVal();
#endif
            memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
            memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
        }
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
        if(pKey != NULL || m_nSize == 1)
            m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
        if(pVal != NULL || m_nSize == 1)
            m_aVal = pVal;
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aKey != NULL)
        {
            for(int i = 0; i < m_nSize; i++)
            {
                m_aKey[i].~TKey();
#if _MSC_VER >= 1200
                m_aVal[i].~TVal();
#else
                TVal * t1;
                t1 = &m_aVal[i];
                t1->~TVal();
#endif
            }
            free(m_aKey);
            m_aKey = NULL;
        }
        if(m_aVal != NULL)
        {
            free(m_aVal);
            m_aVal = NULL;
        }

        m_nSize = 0;
    }
    BOOL SetAt(TKey key, TVal val)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        SetAtIndex(nIndex, key, val);
        return TRUE;
    }
    TVal Lookup(TKey key) const
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetValueAt(nIndex);
    }
    TKey ReverseLookup(TVal val) const
    {
        int nIndex = FindVal(val);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetKeyAt(nIndex);
    }
    TKey& GetKeyAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aKey[nIndex];
    }
    TVal& GetValueAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aVal[nIndex];
    }

// Implementation

    template <typename T>
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <typename _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, TKey& key, TVal& val)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aKey + nIndex) Wrapper<TKey>(key);
        new(m_aVal + nIndex) Wrapper<TVal>(val);
    }
    int FindKey(TKey& key) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aKey[i] == key)
                return i;
        }
        return -1;  // not found
    }
    int FindVal(TVal& val) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aVal[i] == val)
                return i;
        }
        return -1;  // not found
    }
};

#endif // TYPEUTIL__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\mscplus\mscplus.cpp ===
/***************************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
*
*  TITLE:       MSCplus.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      PoYuan
*
*  DATE:        3 Nov, 2000
*
*  DESCRIPTION:
*   Class implementation for MSC+ functionalities.
*   11/03/2000 - First revision finished and unitested on a limited number of functions.
*
****************************************************************************************/


#include "MSCplus.h"

BOOL utilGetScsiAddress(char *pDriveStr, SCSI_ADDRESS *pSA)
{
    HANDLE hDevice;
	INT nStatus;
	ULONG ulReturned;

    hDevice = CreateFileA(pDriveStr, 
						 0, 
						 FILE_SHARE_READ | FILE_SHARE_WRITE, 
						 NULL, 
						 OPEN_EXISTING, 
						 0, 
						 NULL);

	if(hDevice != INVALID_HANDLE_VALUE)
	{
        nStatus = DeviceIoControl(hDevice,
								 IOCTL_SCSI_GET_ADDRESS,
								 0,
								 0,
								 pSA,
								 sizeof(SCSI_ADDRESS),
								 &ulReturned,
								 FALSE);
	}

	if(hDevice != INVALID_HANDLE_VALUE)
	{
		CloseHandle( hDevice );
		return nStatus;
	}
	else
	{
		return FALSE;
	}
}

BOOL CMSCplus::Initialize(WCHAR wcDriveLetter)
{
    if( wcDriveLetter < 0x41 ||
        wcDriveLetter > 0x7A ||
        (wcDriveLetter > 0x5A && wcDriveLetter < 0x61) )
    {
        return FALSE;
    }
       
    m_dwInquiryDataLength=0; 

    m_szCreateFileName = new CHAR [32];
    m_pDataBuffer = NULL;

    if( !m_szCreateFileName )
    {
        return FALSE;
    }

    lstrcpyA(m_szCreateFileName, "\\\\.\\A:");
    
    m_szCreateFileName[4]+=(CHAR)(wcDriveLetter>0x60?(wcDriveLetter-0x61):(wcDriveLetter-0x41));

    // BUGBUG need to call GetSCSIAddress to get real ones
    SCSI_ADDRESS stSA;
    
    if(utilGetScsiAddress(m_szCreateFileName, &stSA))
    {
        m_SCSIPathId = stSA.PathId;
        m_SCSITargetId = stSA.TargetId;
        m_SCSILun = stSA.Lun;
    }
    else
    {
        m_SCSIPathId = 0;
        m_SCSITargetId = 0;
        m_SCSILun = 0;
    }
 
    m_bInitialized = TRUE;
    return TRUE;
}

BOOL CMSCplus::IsDeviceReady(void)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);
    CDB[0]=SCSIOP_TEST_UNIT_READY;
    
    if( ERROR_SUCCESS == m_utilIssueSimpleSCSICDB(CDB, 6, SCSI_IOCTL_DATA_OUT) )
    {
        if( 0x00 == m_ucScsiStatus )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else 
    {
        return FALSE;
    }
}

BOOL CMSCplus::IsMSCplusDevice(DWORD *pdwError, BOOL bNoReuseIB)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    // BUGBUG Need to use Shell API to detect MSC+ device

    return FALSE;
}

WORD CMSCplus::m_LookupDTCodeFromPropCode(WORD wPropCode) // BUGBUG, may be using LUT
{
   switch(wPropCode) {
   
   case PROPCODE_BATTERYLEVEL:
   case PROPCODE_COMPRESSIONSETTING:
   case PROPCODE_CONTRAST:
   case PROPCODE_SHARPNESS:
   case PROPCODE_DIGITALZOOM:
       return DTCODE_UINT8;

   case PROPCODE_FUNCTIONALMODE:
   case PROPCODE_WHITEBALANCE:
   case PROPCODE_FNUMBER:
   case PROPCODE_FOCUSDISTANCE:
   case PROPCODE_FOCUSMODE:
   case PROPCODE_EXPOSUREMETERINGMODE:
   case PROPCODE_FLASHMODE:
   case PROPCODE_EXPOSUREPROGRAMMODE:
   case PROPCODE_EXPOSUREINDEX:
   case PROPCODE_STILLCAPTUREMODE:
   case PROPCODE_EFFECTMODE:
   case PROPCODE_BURSTNUMBER:
   case PROPCODE_BURSTINTERVAL:
   case PROPCODE_TIMELAPSENUMBER:
   case PROPCODE_FOCUSMETERINGMODE:
       return DTCODE_UINT16;

   case PROPCODE_EXPOSUREBIASCOMPENSATION:
       return DTCODE_INT16;

   case PROPCODE_FOCALLENGTH:
   case PROPCODE_EXPOSURETIME:
   case PROPCODE_CAPTUREDELAY:
   case PROPCODE_TIMELAPSEINTERVAL:
       return DTCODE_UINT32;

   case PROPCODE_IMAGESIZE:
   case PROPCODE_RGBGAIN:
   case PROPCODE_DATETIME:
   case PROPCODE_UPLOADURL:
   case PROPCODE_ARTIST:
   case PROPCODE_COPYRIGHTINFO:
       return DTCODE_STR;
   
   case PROPCODE_UNDEFINED:                  
   default:
       return DTCODE_UNDEFINED;
   }
}

DWORD CMSCplus::GetStandardInquiryBuffer(LPBYTE pBuffer, 
                       DWORD *pdwBufSize, 
                       BOOL bNoReuseIB)
{
    DWORD dwErr;
    
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pBuffer || !pdwBufSize || !(*pdwBufSize) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if( !m_dwInquiryDataLength || bNoReuseIB )
    {
        // Need to re-issue Inquiry

        if( (dwErr=m_utilSCSIGetInquiryBuffer())!=ERROR_SUCCESS)
        {
            return dwErr;
        }
        else 
        {
            if( m_dwInquiryDataLength > *pdwBufSize )
            {
                *pdwBufSize = m_dwInquiryDataLength;
                return ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                CopyMemory(pBuffer, m_ucInquiryBuffer, m_dwInquiryDataLength);
                return ERROR_SUCCESS;
            }
        }
    }
    else // no need to re-issue
    {
        CopyMemory(pBuffer, m_ucInquiryBuffer, m_dwInquiryDataLength);
        return ERROR_SUCCESS;
    }
}

DWORD CMSCplus::GetManufacturer(BYTE *pBuffer, 
                      DWORD *pdwBufSize, 
                      BOOL bNoReuseIB)
{
    DWORD dwErr;
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pBuffer || !pdwBufSize || (*pdwBufSize<DEFAULT_VENDOR_STRING_LENGTH) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if( !m_dwInquiryDataLength || bNoReuseIB )
    {
        // Need to re-issue Inquiry
        if( (dwErr=m_utilSCSIGetInquiryBuffer())!=ERROR_SUCCESS)
        {
            return dwErr;
        }
    }
    // Now we have the Inquiry Buffer to work with
    ZeroMemory(pBuffer, *pdwBufSize);
    CopyMemory(pBuffer, m_ucInquiryBuffer+8, DEFAULT_VENDOR_STRING_LENGTH);
    *pdwBufSize = DEFAULT_VENDOR_STRING_LENGTH;
    return ERROR_SUCCESS;
}

DWORD CMSCplus::GetProductName(BYTE *pBuffer, 
                     DWORD *pdwBufSize, 
                     BOOL bNoReuseIB)
{
    DWORD dwErr;
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    if( !pBuffer || !pdwBufSize || (*pdwBufSize<DEFAULT_PRODUCT_STRING_LENGTH) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if( !m_dwInquiryDataLength || bNoReuseIB )
    {
        // Need to re-issue Inquiry
        if( (dwErr=m_utilSCSIGetInquiryBuffer())!=ERROR_SUCCESS)
        {
            return dwErr;
        }
    }
    // Now we have the Inquiry Buffer to work with
    ZeroMemory(pBuffer, *pdwBufSize);
    CopyMemory(pBuffer, m_ucInquiryBuffer+16, DEFAULT_PRODUCT_STRING_LENGTH);
    *pdwBufSize = DEFAULT_PRODUCT_STRING_LENGTH;
    return ERROR_SUCCESS;
}

DWORD CMSCplus::GetProductVersion(BYTE *pBuffer, 
                        DWORD *pdwBufSize, 
                        BOOL bNoReuseIB)
{
    DWORD dwErr;
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pBuffer || !pdwBufSize || (*pdwBufSize<DEFAULT_VERSION_STRING_LENGTH) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if( !m_dwInquiryDataLength || bNoReuseIB )
    {
        // Need to re-issue Inquiry
        if( (dwErr=m_utilSCSIGetInquiryBuffer())!=ERROR_SUCCESS)
        {
            return dwErr;
        }
    }
    // Now we have the Inquiry Buffer to work with
    ZeroMemory(pBuffer, *pdwBufSize);
    CopyMemory(pBuffer, m_ucInquiryBuffer+32, DEFAULT_VERSION_STRING_LENGTH);
    *pdwBufSize = DEFAULT_VERSION_STRING_LENGTH;
    return ERROR_SUCCESS;
}

DWORD CMSCplus::GetVendorSpecificInfo(BYTE *pBuffer, 
                        DWORD *pdwBufSize, 
                        BOOL bNoReuseIB)
{
    DWORD dwErr;
    DWORD dwInfoLength;
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pBuffer || !pdwBufSize )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if( !m_dwInquiryDataLength || bNoReuseIB )
    {
        // Need to re-issue Inquiry
        if( (dwErr=m_utilSCSIGetInquiryBuffer())!=ERROR_SUCCESS)
        {
            return dwErr;
        }
    }

    dwInfoLength = m_dwInquiryDataLength - 36;

    if( *pdwBufSize < dwInfoLength )
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwBufSize = dwInfoLength;
    // Now we have the Inquiry Buffer to work with
    ZeroMemory(pBuffer, *pdwBufSize);
    CopyMemory(pBuffer, m_ucInquiryBuffer+36, dwInfoLength);
    return ERROR_SUCCESS;
}


DWORD CMSCplus::GetDeviceSerialNumber(BYTE *pBuffer, 
                            DWORD *pdwBufSize, 
                            BOOL bNoReuseIB)
{
    DWORD dwErr;
    DWORD dwSNLength;
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pBuffer || !pdwBufSize || !(*pdwBufSize) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_dwInquiryDataLength=0;    
    if( (dwErr=m_utilSCSIGetInquiryBuffer(0x01, 0x80))!=ERROR_SUCCESS)
    {
        return dwErr;
    }
    else // parse the data buffer
    {
        dwSNLength = m_ucInquiryBuffer[3];
        if( *pdwBufSize < dwSNLength )
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            CopyMemory(pBuffer, m_ucInquiryBuffer+4, dwSNLength);
            *pdwBufSize = dwSNLength;
        }
    }

    return ERROR_SUCCESS;
}

// -------------------------------------------------------------------
// Function: m_utilIssueSimpleSCSICDB
// 
// Purpose: Private function to issue simple commands, such as 
//    TEST UNIT READY, SEND DIAGNOSTIC, REQUEST SENSE, and RESET DEVICE.
//
// -------------------------------------------------------------------
DWORD CMSCplus::m_utilIssueSimpleSCSICDB(UCHAR *pCDB, UCHAR ucCDBLength, UCHAR ucDirection)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pCDB || (ucCDBLength < SCSI_MIN_CDB_LENGTH) || (ucCDBLength > SCSI_MAX_CDB_LENGTH) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    BOOL bStatus;
    ULONG uLength, uReturned;
    HANDLE devHandle;
    SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER SPTwb, *pSPTwb;

    pSPTwb = &SPTwb;

    if( !pSPTwb ) 
    {
        return ERROR_OUTOFMEMORY;
    }


    devHandle = CreateFileA(m_szCreateFileName,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (devHandle == INVALID_HANDLE_VALUE) 
    {
        return (GetLastError());
    }

    //
    // Set parameters for sending SCSI command
    //

    ZeroMemory(pSPTwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER));

    pSPTwb->sptd.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    pSPTwb->sptd.PathId = m_SCSIPathId;
    pSPTwb->sptd.TargetId = m_SCSITargetId;
    pSPTwb->sptd.Lun = m_SCSILun;
    pSPTwb->sptd.CdbLength = ucCDBLength;
    pSPTwb->sptd.SenseInfoLength = 24;
    pSPTwb->sptd.DataIn = ucDirection;
    pSPTwb->sptd.DataTransferLength = 0; 
    pSPTwb->sptd.TimeOutValue = 2;
    pSPTwb->sptd.DataBuffer = m_pDataBuffer;
    pSPTwb->sptd.SenseInfoOffset = 
        offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf);
    
    CopyMemory(pSPTwb->sptd.Cdb, pCDB, ucCDBLength);

    uLength = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) + pSPTwb->sptd.DataTransferLength;

    bStatus = DeviceIoControl(devHandle,
                         IOCTL_SCSI_PASS_THROUGH,
                         pSPTwb,
                         sizeof(SCSI_PASS_THROUGH_DIRECT),
                         pSPTwb,
                         uLength,
                         &uReturned,
                         FALSE);
    
    CloseHandle(devHandle);

    m_ucScsiStatus = pSPTwb->sptd.ScsiStatus;

    if( !bStatus )
    { 
        return (GetLastError());
    }
    else 
    {
        return ERROR_SUCCESS;
    }
} // end of m_utilIssueSimpleSCSICDB


DWORD CMSCplus::m_utilSCSIGetInquiryBuffer(UCHAR ucCDB1, UCHAR ucCDB2)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    BOOL bStatus;
    ULONG uLength, uReturned;
    HANDLE devHandle;
    SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER SPTwb, *pSPTwb;

    pSPTwb = &SPTwb;

    if( !pSPTwb ) 
    {
        return ERROR_OUTOFMEMORY;
    }


    devHandle = CreateFileA(m_szCreateFileName,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (devHandle == INVALID_HANDLE_VALUE) 
    {
        return (GetLastError());
    }

    //
    // clear internal buffer
    // 

    m_dwInquiryDataLength=0;      
    ZeroMemory(m_ucInquiryBuffer, DEFAULT_DATA_BUFFER_SIZE);
    
    //
    // Get the inquiry data.
    //

    ZeroMemory(pSPTwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER));

    pSPTwb->sptd.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    pSPTwb->sptd.PathId = m_SCSIPathId;
    pSPTwb->sptd.TargetId = m_SCSITargetId;
    pSPTwb->sptd.Lun = m_SCSILun;
    pSPTwb->sptd.CdbLength = CDB6GENERIC_LENGTH;
    pSPTwb->sptd.SenseInfoLength = 24;
    pSPTwb->sptd.DataIn = SCSI_IOCTL_DATA_IN;
    pSPTwb->sptd.DataTransferLength = DEFAULT_DATA_BUFFER_SIZE; 
    pSPTwb->sptd.TimeOutValue = 2;
    pSPTwb->sptd.DataBuffer = m_ucInquiryBuffer;
    pSPTwb->sptd.SenseInfoOffset = 
        offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf);
    pSPTwb->sptd.Cdb[0] = SCSIOP_INQUIRY;
    pSPTwb->sptd.Cdb[1] = (m_SCSILun<<5) + ucCDB1; // EVPD = 0 for Standard
    pSPTwb->sptd.Cdb[2] = ucCDB2; // Page Code = 00H for Standard
    pSPTwb->sptd.Cdb[3] = 0;
    pSPTwb->sptd.Cdb[4] = DEFAULT_DATA_BUFFER_SIZE; 
    pSPTwb->sptd.Cdb[5] = 0;

    uLength = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) + pSPTwb->sptd.DataTransferLength;

    bStatus = DeviceIoControl(devHandle,
                         IOCTL_SCSI_PASS_THROUGH,
                         pSPTwb,
                         sizeof(SCSI_PASS_THROUGH_DIRECT),
                         pSPTwb,
                         uLength,
                         &uReturned,
                         FALSE);
    
   
    CloseHandle(devHandle);

    m_ucScsiStatus = pSPTwb->sptd.ScsiStatus;
    if( !bStatus )
    { 
        return (GetLastError());
    }
    else 
    {
        m_dwInquiryDataLength = uReturned+8; // BUGBUG, needs to double check this
        return ERROR_SUCCESS;
    }

} // end of m_utilGetStandardSCSIInquiryBuffer



/*   This uses static buffer in SPTwb instead of buffer pointer.
DWORD CMSCplus::m_utilGetStandardSCSIInquiryBuffer()
{
    BOOL bStatus;
    ULONG uLength, uReturned;
    HANDLE devHandle;
    SCSI_PASS_THROUGH_WITH_BUFFERS SPTwb, *pSPTwb;

    pSPTwb = &SPTwb;

    if( !pSPTwb ) 
    {
        return ERROR_OUTOFMEMORY;
    }

    m_dwInquiryDataLength=0;  // clear internal buffer

    devHandle = CreateFileA(m_szCreateFileName,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (devHandle == INVALID_HANDLE_VALUE) 
    {
        return (GetLastError());
    }

    //
    // Get the inquiry data.
    //

    ZeroMemory(pSPTwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));

    pSPTwb->spt.Length = sizeof(SCSI_PASS_THROUGH);
    pSPTwb->spt.PathId = 0;
    pSPTwb->spt.TargetId = 0;
    pSPTwb->spt.Lun = 0;
    pSPTwb->spt.CdbLength = CDB6GENERIC_LENGTH;
    pSPTwb->spt.SenseInfoLength = 24;
    pSPTwb->spt.DataIn = SCSI_IOCTL_DATA_IN;
    pSPTwb->spt.DataTransferLength = DEFAULT_DATA_BUFFER_SIZE; 
    pSPTwb->spt.TimeOutValue = 2;
    pSPTwb->spt.DataBufferOffset =
        offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
    pSPTwb->spt.SenseInfoOffset = 
        offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    pSPTwb->spt.Cdb[0] = SCSIOP_INQUIRY;
    pSPTwb->spt.Cdb[1] = 0; // EVPD = 0 
    pSPTwb->spt.Cdb[2] = 0; // Page Code = 00H ;
    pSPTwb->spt.Cdb[3] = 0;
    pSPTwb->spt.Cdb[4] = DEFAULT_DATA_BUFFER_SIZE; 
    pSPTwb->spt.Cdb[5] = 0;

    uLength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + pSPTwb->spt.DataTransferLength;

    bStatus = DeviceIoControl(devHandle,
                         IOCTL_SCSI_PASS_THROUGH,
                         pSPTwb,
                         sizeof(SCSI_PASS_THROUGH),
                         pSPTwb,
                         uLength,
                         &uReturned,
                         FALSE);
    
    CloseHandle(devHandle);

    if( !bStatus )
    { 
        return (GetLastError());
    }
    else 
    {
        m_dwInquiryDataLength = uReturned-offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
        CopyMemory(m_ucInquiryBuffer, 
                   pSPTwb->ucDataBuf, 
                   m_dwInquiryDataLength);
        return ERROR_SUCCESS;
    }

} // end of m_utilGetStandardSCSIInquiryBuffer
*/


DWORD CMSCplus::ResetDevice(void)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);
    CDB[0] = SCSIOP_RESET_DEVICE;
    CDB[1] = m_SCSILun << 5;
    
    return (m_utilIssueSimpleSCSICDB(CDB, CDB6GENERIC_LENGTH, SCSI_IOCTL_DATA_OUT));
} // end of ResetDevice

DWORD CMSCplus::SelfTest(BYTE *pParamBuffer, DWORD dwBufSize)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    UCHAR CDB[16];

    ZeroMemory(CDB, 16);
    CDB[0] = SCSIOP_SEND_DIAGNOSTIC;

    CDB[1] = m_SCSILun << 5;
    if( pParamBuffer && dwBufSize )
    {
        CDB[1] |= 0x14;
        CDB[2] = (UCHAR)(dwBufSize & 0xFF00)>>8;
        CDB[3] = (UCHAR)(dwBufSize & 0xFF);
        m_pDataBuffer = pParamBuffer;
    }

    return (m_utilIssueSimpleSCSICDB(CDB, CDB6GENERIC_LENGTH, SCSI_IOCTL_DATA_OUT));
} // end of SelfTest

DWORD CMSCplus::SetDevicePropValue(WORD wPropCode, LPBYTE pValue, DWORD dwValueLength)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    if( !pValue || !dwValueLength)
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_pDataBuffer = pValue;

    // Contruct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0] = SCSIOP_WRITE_INFO;
    CDB[1] = (m_SCSILun<<5);
    CDB[2] = SCSI_DTC_DEV_PROP_VALUE;

    WORD wDTC = m_LookupDTCodeFromPropCode(wPropCode);

    CDB[4] = (UCHAR)((wDTC & 0xFF00)>>8);
    CDB[5] = (UCHAR)(wDTC & 0xFF);
    CDB[6] = (UCHAR)((dwValueLength & 0xFF0000)>>16);
    CDB[7] = (UCHAR)((dwValueLength & 0xFF00)>>8);
    CDB[8] = (UCHAR)(dwValueLength & 0xFF);

    return (m_utilIssueSimpleSCSICDB(CDB, CDB10GENERIC_LENGTH, SCSI_IOCTL_DATA_OUT));
}  // end of SetDevicePropValue

DWORD CMSCplus::ResetDevicePropValue(WORD wPropCode)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    m_pDataBuffer = NULL;

    // Contruct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0] = SCSIOP_WRITE_INFO;
    CDB[1] = (m_SCSILun<<5);
    CDB[2] = SCSI_DTC_DEV_PROP_VALUE;

    WORD wDTC = m_LookupDTCodeFromPropCode(wPropCode);

    CDB[4] = (UCHAR)((wDTC & 0xFF00)>>8);
    CDB[5] = (UCHAR)(wDTC & 0xFF);

    return (m_utilIssueSimpleSCSICDB(CDB, CDB10GENERIC_LENGTH, SCSI_IOCTL_DATA_OUT));
}   // end of ResetDevicePropValue


DWORD CMSCplus::InitiateCapture(WORD wFormatCode, BYTE *pDataBuffer, DWORD dwBufSize)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    // Contruct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0]=SCSIOP_START_STOP_CAPTURE;
    CDB[1]=(m_SCSILun<<5);
    CDB[2]=CAPTURE_TYPE_SINGLE;
    CDB[4] = (UCHAR)((wFormatCode & 0xFF00)>>8);
    CDB[5] = (UCHAR)(wFormatCode & 0xFF);

    if( pDataBuffer && dwBufSize )
    {
        CDB[6] = (UCHAR)((dwBufSize & 0xFF0000)>>16);
        CDB[7] = (UCHAR)((dwBufSize & 0xFF00)>>8);
        CDB[8] = (UCHAR)(dwBufSize & 0xFF);
        m_pDataBuffer = pDataBuffer;
    }

    return (m_utilIssueSimpleSCSICDB(CDB, CDB6GENERIC_LENGTH, SCSI_IOCTL_DATA_IN));

} // end of InitiateCapture 

DWORD CMSCplus::InitiateOpenCapture(WORD wFormatCode, BYTE *pDataBuffer, DWORD dwBufSize)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);
    
    // Contruct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0]=SCSIOP_START_STOP_CAPTURE;
    CDB[1]=(m_SCSILun<<5);
    CDB[2]=CAPTURE_TYPE_OPEN_CAP;
    CDB[4]=(UCHAR)((wFormatCode & 0xFF00)>>8);
    CDB[5]=(UCHAR)(wFormatCode & 0xFF);

    if( pDataBuffer && dwBufSize )
    {
        CDB[6] = (UCHAR)((dwBufSize & 0xFF0000)>>16);
        CDB[7] = (UCHAR)((dwBufSize & 0xFF00)>>8);
        CDB[8] = (UCHAR)(dwBufSize & 0xFF);
        m_pDataBuffer = pDataBuffer;
    }

    return (m_utilIssueSimpleSCSICDB(CDB, CDB6GENERIC_LENGTH, SCSI_IOCTL_DATA_IN));

  }  // end of InitiateOpenCapture
DWORD CMSCplus::TerminateOpenCapture(void)
{
   CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

   // Contruct CDB
   UCHAR CDB[16];
   ZeroMemory(CDB, 16);

   CDB[0]=SCSIOP_START_STOP_CAPTURE;
   CDB[1]=(m_SCSILun<<5);
   CDB[2]=CAPTURE_TYPE_STOP_CAP;
   
   return (m_utilIssueSimpleSCSICDB(CDB, CDB6GENERIC_LENGTH, SCSI_IOCTL_DATA_OUT));

}   // end of TerminateOpenCapture


DWORD CMSCplus::GetDeviceInfo(LPBYTE pDeviceInfo, DWORD dwDeviceInfoBufferLength)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pDeviceInfo || !dwDeviceInfoBufferLength )
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_pDataBuffer = pDeviceInfo;

    // construct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0] = SCSIOP_READ_INFO;
    CDB[1] = (m_SCSILun<<5);
    CDB[2] = SCSI_DTC_DEVICE_INFO;

    WORD wDTC = DTCODE_DSDEVINFO;

    CDB[4] = (UCHAR)((wDTC & 0xFF00)>>8);
    CDB[5] = (UCHAR)(wDTC & 0xFF);
    CDB[6] = (UCHAR)((dwDeviceInfoBufferLength & 0xFF0000)>>16);
    CDB[7] = (UCHAR)((dwDeviceInfoBufferLength & 0xFF00)>>8);
    CDB[8] = (UCHAR)(dwDeviceInfoBufferLength & 0xFF);

    return (m_utilIssueSimpleSCSICDB(CDB, CDB10GENERIC_LENGTH, SCSI_IOCTL_DATA_IN));
}  // end of GetDeviceInfo

DWORD CMSCplus::GetDevicePropDesc(WORD wPropCode, LPBYTE pPropDesc, DWORD dwPropDescLength)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pPropDesc || !dwPropDescLength )
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_pDataBuffer = pPropDesc;

    // construct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0] = SCSIOP_READ_INFO;
    CDB[1] = (m_SCSILun<<5);
    CDB[2] = SCSI_DTC_DEV_PROP_DESC;

    WORD wDTC = m_LookupDTCodeFromPropCode(wPropCode);

    CDB[4] = (UCHAR)((wDTC & 0xFF00)>>8);
    CDB[5] = (UCHAR)(wDTC & 0xFF);
    CDB[6] = (UCHAR)((dwPropDescLength & 0xFF0000)>>16);
    CDB[7] = (UCHAR)((dwPropDescLength & 0xFF00)>>8);
    CDB[8] = (UCHAR)(dwPropDescLength & 0xFF);

    return (m_utilIssueSimpleSCSICDB(CDB, CDB10GENERIC_LENGTH, SCSI_IOCTL_DATA_IN));

}  // end of GetDevicePropDesc

DWORD CMSCplus::GetDevicePropValue(WORD wPropCode, LPBYTE pPropValue, DWORD dwPropValueLength)
{
    CHECK_MSCPLUS_INITIALIZATION(m_bInitialized);

    if( !pPropValue || !dwPropValueLength )
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_pDataBuffer = pPropValue;

    // construct CDB
    UCHAR CDB[16];
    ZeroMemory(CDB, 16);

    CDB[0] = SCSIOP_READ_INFO;
    CDB[1] = (m_SCSILun<<5);
    CDB[2] = SCSI_DTC_DEV_PROP_VALUE;

    WORD wDTC = m_LookupDTCodeFromPropCode(wPropCode);

    CDB[4] = (UCHAR)((wDTC & 0xFF00)>>8);
    CDB[5] = (UCHAR)(wDTC & 0xFF);
    CDB[6] = (UCHAR)((dwPropValueLength & 0xFF0000)>>16);
    CDB[7] = (UCHAR)((dwPropValueLength & 0xFF00)>>8);
    CDB[8] = (UCHAR)(dwPropValueLength & 0xFF);

    return (m_utilIssueSimpleSCSICDB(CDB, CDB10GENERIC_LENGTH, SCSI_IOCTL_DATA_IN));
}   // end of GetDevicePropValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\camevent.cpp ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    camevent.cpp

Abstract:

    Enumerate disk images to emulate camera

Author:

    Mark Enstrom (marke) 1/13/1999


Environment:

    user mode

Revision History:

--*/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "ircamera.h"
#include "tcamprop.h"
#include "resource.h"

extern HINSTANCE g_hInst; // Global hInstance

CAM_EVENT gCamEvent[] = {

    {
        TEXT("Pathname Change"),
        &WIA_EVENT_NAME_CHANGE
    },
    {
        TEXT("Disconnect"),
        &WIA_EVENT_DEVICE_DISCONNECTED
    },
    {
        TEXT("Connect"),
        &WIA_EVENT_DEVICE_CONNECTED
    }
};

TCHAR   gpszPath[MAX_PATH];


/**************************************************************************\
* CameraEventDlgProp
*
*
* Arguments:
*
*   hDlg
*   message
*   wParam
*   lParam
*
* Return Value:
*
*    Status
*
* History:
*
*    1/11/1999 Original Version
*
\**************************************************************************/
BOOL  _stdcall
CameraEventDlgProc(
   HWND       hDlg,
   unsigned   message,
   DWORD      wParam,
   LONG       lParam )

/*++

Routine Description:

   Process message for about box, show a dialog box that says what the
   name of the program is.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    static IrUsdDevice *pDevice;

    switch (message) 
        {
        case WM_INITDIALOG:
            {
            //
            // get event list from device
            //
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 0, (long)gCamEvent[0].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 1, (long)gCamEvent[1].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 2, (long)gCamEvent[2].pszEvent);

            SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, 0, 0);

            pDevice = (IrUsdDevice*)lParam;
            pDevice->m_hDlg = hDlg;

            SetDlgItemText(hDlg, IDC_EDIT1, gpszPath);

            }
            break;

        case WM_COMMAND:
            switch(wParam) 
                {

                case IDCANCEL:
                case IDOK:
                    {
                    //if (IDYES == MessageBox( hDlg, TEXT("Are you sure you want to close the event dialog?"), TEXT("IR Camera"), MB_ICONQUESTION|MB_YESNOCANCEL ))
                        EndDialog( hDlg, wParam );
                    }
                    break;

            case IDD_GEN_EVENT:
                    {
                    //
                    // if event is not already set
                    //

                    //
                    // get selected
                    //

                    int i = SendDlgItemMessage(
                                hDlg,
                                IDC_COMBO1,
                                CB_GETCURSEL, 0, 0);

                    pDevice->m_guidLastEvent = *gCamEvent[i].pguid;

                    //
                    // private event
                    //

                    if (IsEqualIID(pDevice->m_guidLastEvent,WIA_EVENT_NAME_CHANGE)) 
                        {
                        UINT ui = GetDlgItemText( hDlg, IDC_EDIT1, gpszPath, MAX_PATH );
                        }

                    SetEvent(pDevice->m_hSignalEvent);
                    WIAS_TRACE((g_hInst,"CameraEventDlgProc(): SetEvent()"));
                    return TRUE;
                    }
                }
            break;
        }

    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\camopen.cpp ===
//-------------------------------------------------------------------------
//
//  Copyright (c) 1999  Microsoft Corporation.
//
//  camopen.cpp
//
//  Abstract:
//
//     Enumerate disk images to emulate camera
//
//  Author:
//
//     Edward Reus    27/Jul/99
//     modeled after code by Mark Enstrom
//
//-------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <tchar.h>

#include "sti.h"
#include "ircamera.h"
#include <irthread.h>

extern HINSTANCE g_hInst; // Global hInstance

#define  __GLOBALPROPVARS__

#include "resource.h"
#include "defprop.h"

//-------------------------------------------------------------------------
//  IrUsdDevice::CamOpenCamera()
//
//   Initialize the IrTran-P camera driver.
//
//   This is a helper called by IrUsdDevice::Initialize().
//
// Arguments:
//
//   pGenericStatus    -    camera status
//
// Return Value:
//
//   HRESULT - S_OK
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::CamOpenCamera( IN OUT CAMERA_STATUS *pCameraStatus )
    {
    HRESULT    hr = S_OK;
    SYSTEMTIME SystemTime;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamOpenCamerai()"));

    //
    // Initialize camera state:
    //
    memset( pCameraStatus, 0, sizeof(CAMERA_STATUS) );

    pCameraStatus->FirmwareVersion = 0x00000001;
    pCameraStatus->NumPictTaken = 20;
    pCameraStatus->NumPictRemaining = 0;
    pCameraStatus->ThumbWidth = 80;
    pCameraStatus->ThumbHeight= 60;
    pCameraStatus->PictWidth  = 300;
    pCameraStatus->PictHeight = 300;

    GetSystemTime( &(pCameraStatus->CameraTime) );

    return hr;
    }


//-------------------------------------------------------------------------
// IrUsdDevice::CamBuildImageTree()
//
//    Build the tree of camera images by enumerating a disk directory for
//    all .JPG files.
//
// Arguments:
//
//    pCamStatus  -    device status
//    ppRootFile  -    return new root of item tree
//
// Return Value:
//
//    status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::CamBuildImageTree( OUT CAMERA_STATUS  *pCamStatus,
                                        OUT IWiaDrvItem   **ppRootFile )
    {
    HRESULT  hr = S_OK;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamBuildImageTree()"));

    //
    // Create the new image root:
    //
    BSTR bstrRoot = SysAllocString(L"Root");

    if (!bstrRoot)
        {
        return E_OUTOFMEMORY;
        }

    //
    // Call Wia service library to create new root item:
    //
    hr = wiasCreateDrvItem( WiaItemTypeFolder | WiaItemTypeRoot | WiaItemTypeDevice,
                            bstrRoot,
                            m_bstrRootFullItemName,
                            (IWiaMiniDrv*)this,
                            sizeof(IRCAM_IMAGE_CONTEXT),
                            NULL,
                            ppRootFile );

    SysFreeString(bstrRoot);

    if (FAILED(hr))
        {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, CreateDeviceItem failed"));
        return hr;
        }

    //
    // Enumerate the root directory:
    //
    CHAR  *pszImageDirectory = GetImageDirectory();

    if (!pszImageDirectory)
        {
        return E_OUTOFMEMORY;
        }

    #ifdef UNICODE

    WCHAR  wszPath[MAX_PATH];

    mbstowcs( wszPath, pszImageDirectory, strlen(pszImageDirectory) );

    hr = EnumDiskImages( *ppRootFile, wszPath );

    #else

    hr = EnumDiskImages( *ppRootFile, pszImageDirectory );

    #endif


    // Don't free pszImageDirectory!!

    return (hr);
    }

//-------------------------------------------------------------------------
// IrUsdDevice::EnumDiskImages()
//
//   Walk through camera temp directory looking for JPEG files to pick up.
//
// Arguments:
//
//   pRootFile
//   pwszDirName
//
// Return Value:
//
//   status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::EnumDiskImages( IWiaDrvItem *pRootFile,
                                     TCHAR       *pszDirName )
    {
    HRESULT          hr = E_FAIL;
    WIN32_FIND_DATA  FindData;
    TCHAR           *pTempName;

    WIAS_TRACE((g_hInst,"IrUsdDevice::EnumDiskImages()"));

    pTempName = (TCHAR*)ALLOC(MAX_PATH);
    if (!pTempName)
        {
        return E_OUTOFMEMORY;
        }

    _tcscpy( pTempName, pszDirName);
    _tcscat( pTempName, TEXT("\\*.jpg") );

    //
    // Look for files at the specified directory:
    //
    HANDLE hFile = FindFirstFile( pTempName, &FindData );

    if (hFile != INVALID_HANDLE_VALUE)
        {
        BOOL bStatus;

        do {
            //
            // Add an image to this folder.
            //
            // Create file name:
            //

            _tcscpy(pTempName, pszDirName);
            _tcscat(pTempName, TEXT("\\"));
            _tcscat(pTempName, FindData.cFileName);

            //
            // Create a new DrvItem for this image and add it to the
            // DrvItem tree.
            //

            IWiaDrvItem *pNewImage;

            hr = CreateItemFromFileName(
                         WiaItemTypeFile | WiaItemTypeImage,
                         pTempName,
                         FindData.cFileName,
                         &pNewImage);

            if (FAILED(hr))
                {
                break;
                }

            hr = pNewImage->AddItemToFolder(pRootFile);

            pNewImage->Release();

            //
            // Look for the next image:
            //
            bStatus = FindNextFile(hFile,&FindData);

        } while (bStatus);

        FindClose(hFile);
    }

    //
    // Now look for directories,
    // add a new PCAMERA_FILE for each sub directory found
    //

    _tcscpy(pTempName, pszDirName);
    _tcscat(pTempName, TEXT("\\*.*"));

    hFile = FindFirstFile( pTempName,&FindData );

    if (hFile != INVALID_HANDLE_VALUE)
        {
        BOOL bStatus;

        do {
            if (  (FindData.cFileName[0] != L'.')
               && (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                //
                // Found a subdirectory:
                //

                _tcscpy(pTempName, pszDirName);
                _tcscat(pTempName, TEXT("\\"));
                _tcscat(pTempName, FindData.cFileName);

                //
                // Create a new folder for the sub-directory:
                //

                IWiaDrvItem *pNewFolder;

                hr = CreateItemFromFileName(
                                 WiaItemTypeFolder,
                                 pTempName,
                                 FindData.cFileName,
                                 &pNewFolder);

                if (FAILED(hr))
                    {
                    continue;
                    }

                hr = pNewFolder->AddItemToFolder(pRootFile);

                pNewFolder->Release();

                if (hr == S_OK)
                    {
                    //
                    // Enumerate the sub-folder
                    //
                    EnumDiskImages(pNewFolder, pTempName);
                    }
                }

            bStatus = FindNextFile(hFile,&FindData);

        } while (bStatus);

        FindClose(hFile);
        }

    FREE(pTempName);

    return S_OK;
    }

//-------------------------------------------------------------------------
// IrUsdDevice::CreateItemFromFileName()
//
//    Helper funtion used by EnumDiskImages to create dev items and names.
//
// Arguments:
//
//    FolderType  - type of item to create
//    pszPath     - complete path name
//    pszName     - file name
//    ppNewFolder - return new item
//
// Return Value:
//
//   status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::CreateItemFromFileName( LONG          FolderType,
                                             TCHAR        *pszPath,
                                             TCHAR        *pszName,
                                             IWiaDrvItem **ppNewFolder )
    {
    HRESULT  hr = S_OK;
    WCHAR    wszFullItemName[MAX_PATH];
    WCHAR    wszTemp[MAX_PATH];
    BSTR     bstrItemName;
    BSTR     bstrFullItemName;
    IWiaDrvItem  *pNewFolder = 0;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CreateItemFromFileName()"));

    *ppNewFolder = NULL;

    //
    // Convert path to wide char
    //
    CHAR *pszImageDirectory = ::GetImageDirectory();

    if (!pszImageDirectory)
        {
        return E_OUTOFMEMORY;
        }

    DWORD dwImageDirectoryLen = strlen(pszImageDirectory);

    #ifndef UNICODE
    MultiByteToWideChar( CP_ACP,
                         0,
                         pszPath + dwImageDirectoryLen,
                         strlen(pszPath) - dwImageDirectoryLen - 4,
                         wszTemp,
                         MAX_PATH);
    #else
    wcscpy(wszTemp, pszPath+dwImageDirectoryLen);
    #endif

    if (FolderType & ~WiaItemTypeFolder)
        {
        wszTemp[_tcslen(pszPath) - strlen(pszImageDirectory) - 4] = 0;
        }

    wcscpy(wszFullItemName, m_bstrRootFullItemName);
    wcscat(wszFullItemName, wszTemp);

    //
    // Convert item name to wide char:
    //

    #ifndef UNICODE
    MultiByteToWideChar( CP_ACP,
                         0,
                         pszName,
                         strlen(pszName)-4,
                         wszTemp,
                         MAX_PATH);
    #else
    wcscpy(wszTemp, pszName);
    #endif

    if (FolderType & ~WiaItemTypeFolder)
        {
        wszTemp[_tcslen(pszName)-4] = 0;
        }

    bstrItemName = SysAllocString(wszTemp);

    if (bstrItemName)
        {
        bstrFullItemName = SysAllocString(wszFullItemName);

        if (bstrFullItemName)
            {
            //
            // Call WIA to create new DrvItem
            //

            IRCAM_IMAGE_CONTEXT *pContext = 0;

            hr = wiasCreateDrvItem( FolderType,
                                    bstrItemName,
                                    bstrFullItemName,
                                    (IWiaMiniDrv *)this,
                                    sizeof(IRCAM_IMAGE_CONTEXT),
                                    (BYTE **)&pContext,
                                    &pNewFolder);

            if (hr == S_OK)
                {
                //
                // init device specific context (image path)
                //
                pContext->pszCameraImagePath = _tcsdup(pszPath);
                }
            else
                {
                WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, wiasCreateDrvItem failed"));
                }

            SysFreeString(bstrFullItemName);
            }
        else
            {
            WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate full item name"));
            hr = E_OUTOFMEMORY;
            }

        SysFreeString(bstrItemName);
        }
    else
        {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate item name"));
        hr = E_OUTOFMEMORY;
        }

    //
    // Assign output value and cleanup
    //

    if (hr == S_OK)
        {
        *ppNewFolder = pNewFolder;
        }
    else
        {
        //
        // delete item
        //
        }

    return hr;
}

//-------------------------------------------------------------------------
// SetItemSize()
//
//   Helper function to call wias to calc new item size
//
// Arguments:
//
//   pWiasContext       - item
//
// Return Value:
//
//    Status
//
//-------------------------------------------------------------------------
HRESULT SetItemSize( BYTE* pWiasContext )
    {
    HRESULT                    hr;
    MINIDRV_TRANSFER_CONTEXT   drvTranCtx;

    memset( &drvTranCtx, 0, sizeof(MINIDRV_TRANSFER_CONTEXT) );

    hr = wiasReadPropGuid( pWiasContext,
                           WIA_IPA_FORMAT,
                           (GUID*)&drvTranCtx.guidFormatID,
                           NULL,
                           false );
    if (FAILED(hr))
        {
        return hr;
        }

    hr = wiasReadPropLong( pWiasContext,
                           WIA_IPA_TYMED,
                           (LONG*)&drvTranCtx.tymed,
                           NULL,
                           false );
    if (FAILED(hr))
        {
        return hr;
        }

    WIAS_TRACE((g_hInst,"SetItemSize(): tymed: %d",drvTranCtx.tymed));

    //
    // wias works for DIB and TIFF formats.
    //
    // Driver doesn't support JPEG
    //

    hr = wiasGetImageInformation(pWiasContext,
                                 WIAS_INIT_CONTEXT,
                                 &drvTranCtx);

    if (hr == S_OK)
        {
        WIAS_TRACE((g_hInst,"SetItemSize(): lItemSize: %d",drvTranCtx.lItemSize));
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, drvTranCtx.lItemSize);
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_BYTES_PER_LINE, drvTranCtx.cbWidthInBytes);
        }

    return hr;
    }

//-------------------------------------------------------------------------
// IrUsdDevice::InitImageInformation()
//
//    Init image properties
//
// Arguments:
//
//
// Return Value:
//
//    Status
//
//-------------------------------------------------------------------------
HRESULT IrUsdDevice::InitImageInformation( BYTE                *pWiasContext,
                                           IRCAM_IMAGE_CONTEXT *pContext,
                                           LONG                *plDevErrVal)
    {
    int                      i;
    HRESULT                  hr = S_OK;
    CAMERA_PICTURE_INFO      camInfo;
    PROPVARIANT              propVar;

    WIAS_TRACE((g_hInst,"IrUsdDevice::InitImageInformation()"));

    //
    // GET image info
    //

    hr = CamGetPictureInfo( pContext,
                            &camInfo );

    if (hr != S_OK)
        {
        return hr;
        }

    //
    // Use WIA services to write image properties:
    //
    wiasWritePropLong( pWiasContext,
                       WIA_IPC_THUMB_WIDTH,
                       camInfo.ThumbWidth);

    wiasWritePropLong( pWiasContext,
                       WIA_IPC_THUMB_HEIGHT,
                       camInfo.ThumbHeight );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_PIXELS_PER_LINE,
                       camInfo.PictWidth );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_NUMBER_OF_LINES,
                       camInfo.PictHeight );

    wiasWritePropGuid( pWiasContext,
                       WIA_IPA_PREFERRED_FORMAT,
                       WiaImgFmt_JPEG );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_DEPTH,
                       camInfo.PictBitsPerPixel );

    wiasWritePropBin( pWiasContext,
                      WIA_IPA_ITEM_TIME,
                      sizeof(SYSTEMTIME),
                      (PBYTE)&camInfo.TimeStamp );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_DATATYPE,
                       WIA_DATA_COLOR );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_ITEM_SIZE,
                       camInfo.PictCompSize );

    wiasWritePropLong( pWiasContext,
                       WIA_IPA_BYTES_PER_LINE,
                       camInfo.PictBytesPerRow );

    //
    // Calculate item size
    //
    // hr = SetItemSize(pWiasContext); BUGBUG

    //
    // Load a thumbnail of the image:
    //
    PBYTE pThumb;
    LONG  lSize;

    hr = CamLoadThumbnail(pContext, &pThumb, &lSize);

    if (hr == S_OK)
        {
        //
        // write thumb property
        //
        PROPSPEC    propSpec;
        PROPVARIANT propVar;

        propVar.vt          = VT_VECTOR | VT_UI1;
        propVar.caub.cElems = lSize;
        propVar.caub.pElems = pThumb;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPC_THUMBNAIL;

        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);

        FREE(pThumb);
        }

    //
    // Use WIA services to set the extended property access and
    // valid value information from gWiaPropInfoDefaults.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_ITEM_PROPS,
                                 gPropSpecDefaults,
                                 gWiaPropInfoDefaults);
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\camxfer.cpp ===
//------------------------------------------------------------------------------
//  Copyright (c) 1999  Microsoft Corporation
//
//  camxfer.cpp
//
//  Abstract:
//
//     Core ircamera (IrUseDevice object) imaging methods.
//
//  Author:
//     Edward Reus   03-Aug-99
//     modeled after code by Mark Enstrom
//
//------------------------------------------------------------------------------

#include <stdio.h>
#include <objbase.h>
#include <tchar.h>
#include <sti.h>
#include <malloc.h>
#include "jpegutil.h"

extern HINSTANCE g_hInst; // Global hInstance

#include "ircamera.h"


#if FALSE
//------------------------------------------------------------------------------
// IrUsdDevice::OpenAndMapJPEG()
//
// Open and memory map the JPEG file. The JPEG file is opened read only and
// a pointer to the memory map is returned.
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::OpenAndMapJPEG( IN  IRCAM_IMAGE_CONTEXT *pIrCamContext,
                                     OUT BYTE               **ppJpeg )
    {
    HRESULT  hr = S_OK;

    *ppJpeg = 0;


    return hr;
    }
#endif

//------------------------------------------------------------------------------
// IrUsdDevice::CamLoadPicture()
//
//    Read a .JPG image from the disk and copy it to the application.
//
// Arguments:
//
//   pIrCamContext --
//   pDataTransCtx --
//   plCamErrVal   --
//
// Return Value:
//
//   status
//
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::CamLoadPicture( IRCAM_IMAGE_CONTEXT      *pIrCamContext,
                                     PMINIDRV_TRANSFER_CONTEXT pDataTransCtx,
                                     PLONG                     plCamErrVal )
    {
    HRESULT               hr = S_OK;
    LONG                  cbNeeded;
    IWiaMiniDrvCallBack  *pIProgressCB;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamLoadPicture()"));

    //
    // Verify call arguments:
    //
    if ( (!pIrCamContext) || (!plCamErrVal))
        {
        return E_INVALIDARG;
        }

    if (pDataTransCtx->guidFormatID != WiaImgFmt_JPEG)
        {
        return E_NOTIMPL;
        }

    pIProgressCB = pDataTransCtx->pIWiaMiniDrvCallBack;

    //
    // Simulate the download of data from the camera
    //
    if (pIProgressCB)
        {
        hr = pIProgressCB->MiniDrvCallback(
                               IT_MSG_STATUS,
                               IT_STATUS_TRANSFER_FROM_DEVICE,
                               (LONG)0,     // Percentage Complete,
                               0,
                               0,
                               pDataTransCtx,
                               0);
        if (hr != S_OK)
            {
            return hr;   // Client wants to cancel the transfer or error.
            }
        }

    HANDLE hFile = CreateFile(
                       pIrCamContext->pszCameraImagePath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    else
        {
        if (pIProgressCB)
            {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)25,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
            }
        }

    if (hr != S_OK)
        {
        if (hFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hFile);
            }
        return hr;
        }

    //
    // Get the size of the JPEG:
    //
    BY_HANDLE_FILE_INFORMATION  FileInfo;

    if (!GetFileInformationByHandle(hFile,&FileInfo))
       {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       CloseHandle(hFile);
       return hr;
       }

    //
    // Map the JPEG into memory:
    //
    HANDLE hMap = CreateFileMapping( hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL );
    if (hMap == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    else
        {
        if (pIProgressCB)
            {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)50,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0 );
            }
        }

    if (hr != S_OK)
        {
        CloseHandle(hFile);
        return hr;
        }

    PBYTE pFile = (PBYTE)MapViewOfFile(
                             hMap,
                             FILE_MAP_READ,
                             0,
                             0,
                             0 );
    if (pFile == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    else
        {
        if (pIProgressCB)
            {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)100,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
            }
        }

    if (hr != S_OK)
        {
        CloseHandle(hFile);
        CloseHandle(hMap);
        return hr;
        }

    #if FALSE
    //
    // File contains BITMAPFILEHEADER + BITMAPINFO structure.
    //
    // DIB Data is located bfOffBits after start of file
    //

    PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
    PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile +
                                               sizeof(BITMAPFILEHEADER));

    //
    // validate bitmap
    //

    if (pbmFile->bfType != 'MB')
        {
        //
        // file is not a bitmap
        //
        UnmapViewOfFile(pFile);
        CloseHandle(hMap);
        CloseHandle(hFile);
        return(E_FAIL);
        }

    //
    // write image size
    //
    // make sure to align scanline to ULONG boundary
    //
    // calculate byte width
    //

    lScanLineWidth = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;

    //
    // round up to nearenst DWORD
    //

    lScanLineWidth = (lScanLineWidth + 31) >> 3;

    lScanLineWidth &= 0xfffffffc;
    #endif

    cbNeeded = FileInfo.nFileSizeLow;

    if (cbNeeded > ((LONG)pDataTransCtx->lItemSize - (LONG)pDataTransCtx->cbOffset))
        {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        }
    else
        {
        //
        // Copy the JPEG image...
        //
        memcpy(
            pDataTransCtx->pTransferBuffer + pDataTransCtx->cbOffset,
            pFile,
            cbNeeded);
        }

    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return hr;
    }

//------------------------------------------------------------------------------
//  IrUsdDevice::CamLoadPictureCB()
//
//    Return data by filling the data buffer and calling back to the client.
//
// Arguments:
//
//    pIrCamContext --
//    pTransCtx     -- mini driver transfer contect
//    plCamErrVal   --
//
// Return Value:
//
//   HRESULT  -- E_INVALIDARG
//               E_NOTIMPL
//               E_FAIL
//
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::CamLoadPictureCB( IRCAM_IMAGE_CONTEXT      *pIrCamContext,
                                       MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                                       PLONG                     plCamErrVal )
    {
    LONG     lScanLineWidth;
    HRESULT  hr = E_FAIL;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamLoadPictureCB()"));

    //
    // Verify parameters:
    //
    if ((!pIrCamContext) || (!plCamErrVal))
        {
        return E_INVALIDARG;
        }

    if (pTransCtx == NULL)
        {
        return E_INVALIDARG;
        }

    if (pTransCtx->guidFormatID != WiaImgFmt_JPEG)
        {
        return E_NOTIMPL;
        }

    //
    // try to open disk file
    //

    HANDLE hFile = CreateFile(
                       pIrCamContext->pszCameraImagePath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    //
    // Get the size of the JPEG file:
    //
    BY_HANDLE_FILE_INFORMATION  FileInfo;

    if (!GetFileInformationByHandle(hFile,&FileInfo))
       {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       CloseHandle(hFile);
       return hr;
       }

    HANDLE hMap = CreateFileMapping( hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL );
    if (hMap == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        CloseHandle(hFile);
        return hr;
        }

    PBYTE pFile = (PBYTE)MapViewOfFile(
                             hMap,
                             FILE_MAP_READ,
                             0,
                             0,
                             0 );
    if (pFile == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        CloseHandle(hFile);
        CloseHandle(hMap);
        return hr;
        }

    //
    // Callback loop
    //
    PBYTE pSrc = pFile;

    LONG  lBytesRemaining = FileInfo.nFileSizeLow;
    LONG  lTransferSize;
    LONG  lPercentComplete;

    do {

        PBYTE pDst = pTransCtx->pTransferBuffer;

        //
        // Transfer as much data as the transfer buffer will hold:
        //
        lTransferSize = lBytesRemaining;

        if (lBytesRemaining > pTransCtx->lBufferSize)
            {
            lTransferSize = pTransCtx->lBufferSize;
            }

        //
        // Copy data:
        //
        memcpy( pDst, pSrc, lTransferSize);

        lPercentComplete = 100 * (pTransCtx->cbOffset + lTransferSize);
        lPercentComplete /= pTransCtx->lItemSize;

        //
        // Make callback:
        //
        hr = pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                     IT_MSG_DATA,
                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                     lPercentComplete,
                                     pTransCtx->cbOffset,
                                     lTransferSize,
                                     pTransCtx,
                                     0);
        //
        // increment pointers (redundant pointers here):
        //
        pSrc                += lTransferSize;
        pTransCtx->cbOffset += lTransferSize;
        lBytesRemaining     -= lTransferSize;

        if (hr != S_OK)
            {
            break;
            }
    } while (lBytesRemaining > 0);

    //
    // Cleanup:
    //
    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return hr;
}



//------------------------------------------------------------------------------
// IrUsdDevice::CamGetPictureInfo()
//
//    Load file and get information from image
//
// Arguments:
//
//    pIrCamContext   --
//    pPictInfo       -- Infomation about the image
//    ppBITMAPINFO    -- Alloc and fill out BITMAPINFO
//    pBITMAPINFOSize -- Size
//
// Return Value:
//
//    HRESULT -- S_OK    - No problem.
//               E_FAIL  - If we can't parse the JPEG.
//               HRESULT mapped Win32 Errors from CreateFile()
//
//------------------------------------------------------------------------------
HRESULT IrUsdDevice::CamGetPictureInfo(
                        IRCAM_IMAGE_CONTEXT  *pIrCamContext ,
                        CAMERA_PICTURE_INFO  *pPictInfo )
    {
    HRESULT     hr = S_OK;
    FILETIME    ftCreate;
    SYSTEMTIME  stCreate;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamGetPictureInfo()"));

    memset(pPictInfo,0,sizeof(CAMERA_PICTURE_INFO));

    //
    // Try to open disk file
    //
    HANDLE hFile = CreateFile(
                       pIrCamContext->pszCameraImagePath,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    //
    // Get the size of the JPEG:
    //
    BY_HANDLE_FILE_INFORMATION  FileInfo;

    if (!GetFileInformationByHandle(hFile,&FileInfo))
       {
       hr = HRESULT_FROM_WIN32(::GetLastError());
       CloseHandle(hFile);
       return hr;
       }

    //
    // Get the creation time for this image:
    //
    if (  !GetFileTime( hFile, &ftCreate, NULL, NULL)
       || !FileTimeToSystemTime( &ftCreate, &stCreate) )
        {
        //
        // If either of those fail, then return the system time:
        //
        GetLocalTime( &stCreate );
        }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READONLY,
                       0,
                       0,
                       NULL
                       );
    if (hMap == NULL)
        {
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    PBYTE pJpeg = (PBYTE)MapViewOfFile(
                             hMap,
                             FILE_MAP_READ,
                             0,
                             0,
                             0 );
    if (pJpeg == NULL)
        {
        CloseHandle(hFile);
        CloseHandle(hMap);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return hr;
        }

    //
    // Get JPEG image dimensions:
    //
    int    iStatus;
    long   lWidth = 0;
    long   lHeight = 0;
    WORD   wNumChannels = 0;
    DWORD  dwJpegSize = FileInfo.nFileSizeLow;

    iStatus = GetJPEGDimensions( pJpeg,
                                 dwJpegSize,
                                 &lWidth,
                                 &lHeight,
                                 &wNumChannels );
    if (iStatus != JPEGERR_NO_ERROR)
        {
        UnmapViewOfFile(pJpeg);
        CloseHandle(hFile);
        CloseHandle(hMap);
        return E_FAIL;
        }

    //
    // Fill out image information:
    //
    pPictInfo->PictNumber       = 0;    // Unknown
    pPictInfo->ThumbWidth       = 80;
    pPictInfo->ThumbHeight      = 60;
    pPictInfo->PictWidth        = lWidth;
    pPictInfo->PictHeight       = lHeight;
    pPictInfo->PictCompSize     = FileInfo.nFileSizeLow;
    pPictInfo->PictFormat       = CF_JPEG;
    pPictInfo->PictBitsPerPixel = wNumChannels * 8;
    pPictInfo->PictBytesPerRow  = lWidth*wNumChannels;

    memcpy( &pPictInfo->TimeStamp, &stCreate, sizeof(pPictInfo->TimeStamp) );

    //
    // Cleanup:
    //
    UnmapViewOfFile(pJpeg);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return hr;
}

//--------------------------------------------------------------------------
// IrUsdDevice::CamLoadThumbnail()
//
//   Load the thumbnail of the specified picture. The picture is saved as
//   a .JPG file, so it needs to be uncompressed into a DIB, then the DIB
//   needs to be resized down to thumbnail size. The thumbnail DIBs are saved
//   into *.tmb files the first time that they are read so that we only need
//   to process them into DIBs once.
//
// Arguments:
//
//   pCameraImage    - image item
//   pThumbnail      - buffer for thumbnail
//   pThumbSize      - size of thumbnail
//
// Return Value:
//
//   HRESULT: S_OK
//            E_OUTOFMEMORY
//            E_FAIL
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::CamLoadThumbnail(
                        IN  IRCAM_IMAGE_CONTEXT *pIrCamContext,
                        OUT BYTE               **ppThumbnail,
                        OUT LONG                *pThumbSize )
    {
    HRESULT  hr = S_OK;
    DWORD    dwStatus = 0;
    TCHAR    pszThumbName[MAX_PATH];
    BOOL     bThumbExists = TRUE;  // True if there is a thumbnail file already.
    BOOL     bCacheThumb  = TRUE;  // Should we try to cache the thumbnail if it
                                   //   isn't already cached? (TRUE == Yes).
    BYTE    *pTmbPixels = NULL;
    HBITMAP  hbmThumb = NULL;
    BYTE    *pThumb = NULL;

    HANDLE   hTmbFile = INVALID_HANDLE_VALUE;
    HANDLE   hTmbMap = NULL;
    BYTE    *pTmbFile = NULL;

    HANDLE   hFile = INVALID_HANDLE_VALUE;
    HANDLE   hMap = NULL;
    BYTE    *pFile = NULL;

    BYTE    *pDIB = NULL;

    BITMAPINFO bmiDIB;
    BITMAPINFO bmiJPEG;
    HDC        hdc = NULL;
    HDC        hdcm1 = NULL;

    BY_HANDLE_FILE_INFORMATION  FileInfo;

    long    lThumbWidth;
    long    lThumbHeight;
    double  fImageWidth;
    double  fImageHeight;
    double  fAspect;
    double  fDefAspect = 80.0 / 60.0;

    HBITMAP hbmDef;

    int   iStatus;
    long  lWidth;
    long  lHeight;
    WORD  wNumChannels;
    DWORD dwBytesPerScanLine;
    DWORD dwDIBSize;

    WIAS_TRACE((g_hInst,"IrUsdDevice::CamLoadThumbnail()"));

    //
    // Initialize the return values
    //
    *ppThumbnail = NULL;
    *pThumbSize = 0;

    //
    // Fill in the size of the tumbnail pixel buffer
    //

    bmiDIB.bmiHeader.biSizeImage = 80*60*3;

    //
    // Build thumbnail filename: <file>.bmp.tmb
    //
    _tcscpy(pszThumbName, pIrCamContext->pszCameraImagePath);
    _tcscat(pszThumbName, SZ_TMB );

    //
    // See if a saved copy of the thumbnail already exists:
    //
    hTmbFile = CreateFile( pszThumbName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

    if (hTmbFile == INVALID_HANDLE_VALUE)
        {
        //
        // It didn't, try to create a new one:
        //
        hTmbFile = CreateFile( pszThumbName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_NEW,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

        //
        // So, we need to write into the thumbnail file:
        //
        bThumbExists = FALSE;
        }

    //
    // If we could open (or create a new) .tmb file to hold the
    // cached thumbnail then we are Ok to go on...
    //
    if (hTmbFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }


    hTmbMap = CreateFileMapping( hTmbFile,
                                 NULL,   // No special security
                                 PAGE_READWRITE,
                                 0,      // Size high 32bits.
                                 80*60*3,// Size low 32bits. (80*60*3).
                                 NULL);  // No handle name.

    if (hTmbMap != NULL)
        {
        pTmbFile = (PBYTE)MapViewOfFile(
                                 hTmbMap,
                                 FILE_MAP_READ | FILE_MAP_WRITE,
                                 0, 0,   // Offset (64bit).
                                 0 );    // Map entire file.

        if (pTmbFile)
            {
            if (bThumbExists)
                {
                //
                // Allocate memory for thumbnail pixels:
                //
                pTmbPixels = (PBYTE)ALLOC(80*60*3);

                if (!pTmbPixels)
                    {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                    }

                //
                // Pull the thumbnail from the cached file:
                //
                memcpy( pTmbPixels,
                        pTmbFile,
                        80*60*3);

                //
                // All done for the cached thumbnail case, set
                // return values and goto cleanup...
                //
                *ppThumbnail = pTmbPixels;
                *pThumbSize = 80*60*3;

                goto cleanup;
                }
            else
                {
                //
                // No existing thumbnail file, but opened a new
                // file, so we will need to write out to cache:
                //
                bCacheThumb = TRUE;
                }
            }
        else
            {
            //
            // Couldn't memory map the thumbnail file, so don't
            // try to cache it:
            //
            bCacheThumb  = FALSE;
            }
        }
    else
        {
        //
        // Can't open/create thumbnail file, so we can't cache
        // thumbnail:
        //
        bCacheThumb  = FALSE;
        }

    //
    // Try to create a thumbnail from the full-size image
    // and cache it if the thumbnail cache file was created.
    //

    //
    // Open the .JPEG image file:
    //
    hFile = CreateFile(
                    pIrCamContext->pszCameraImagePath,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    if (!GetFileInformationByHandle(hFile,&FileInfo))
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    //
    // Map the file into memory:
    //
    hMap = CreateFileMapping( hFile,
                              NULL,          // No special security.
                              PAGE_READONLY, // Only read needed.
                              FileInfo.nFileSizeHigh,  // File Size.
                              FileInfo.nFileSizeLow,
                              NULL );        // No handle name.

    if (hMap == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    pFile = (PBYTE)MapViewOfFile(
                           hMap,
                           FILE_MAP_READ,
                           0, 0, // 64-bit file offset = 0.
                           0 );  // Bytes to map. 0 == Entire file.

    if (pFile == NULL)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    //
    // Here is where we will parse out the full JPEG into a DIB. We
    // need to read the full JPEG, then squeeze it down to thumbnail
    // size.
    //
    // First, we need to dimensions of the JPEG image:
    //
    iStatus = GetJPEGDimensions( pFile,
                                 FileInfo.nFileSizeLow,
                                 &lWidth,
                                 &lHeight,
                                 &wNumChannels );

    if (iStatus != JPEGERR_NO_ERROR)
        {
        hr = E_FAIL;
        goto cleanup;
        }

    //
    // Allocate memory to hold a DIB of the entire JPEG:
    //
    dwBytesPerScanLine = lWidth * wNumChannels;
    dwBytesPerScanLine = (dwBytesPerScanLine + wNumChannels) & 0xFFFFFFFC;
    dwDIBSize = dwBytesPerScanLine * lHeight;

    pDIB = (BYTE*)ALLOC(dwDIBSize);

    if (!pDIB)
        {
        hr = E_OUTOFMEMORY;
        goto cleanup;
        }

    //
    // Convert the full JPEG image into a DIB:
    //
    iStatus = DecompJPEG( pFile,
                          FileInfo.nFileSizeLow,
                          pDIB,
                          dwBytesPerScanLine );

    if (iStatus != JPEGERR_NO_ERROR)
        {
        hr = E_FAIL;
        goto cleanup;
        }

    //
    // Generate the thumbnail from the full-size image:
    //
    hdc   = GetDC(NULL);
    hdcm1 = CreateCompatibleDC(hdc);
    SetStretchBltMode( hdcm1, COLORONCOLOR );

    //
    // Create a BITMAP for rendering the thumbnail:
    //
    bmiDIB.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmiDIB.bmiHeader.biBitCount      = 24;
    bmiDIB.bmiHeader.biWidth         = 80;
    bmiDIB.bmiHeader.biHeight        = 60;
    bmiDIB.bmiHeader.biPlanes        = 1;
    bmiDIB.bmiHeader.biCompression   = BI_RGB;
    bmiDIB.bmiHeader.biXPelsPerMeter = 100;
    bmiDIB.bmiHeader.biYPelsPerMeter = 100;
    bmiDIB.bmiHeader.biClrUsed       = 0;
    bmiDIB.bmiHeader.biClrImportant  = 0;

    hbmThumb = CreateDIBSection( hdc,
                                 &bmiDIB,
                                 DIB_RGB_COLORS,
                                 (VOID**)&pThumb,
                                 NULL,
                                 0 );
    if (!hbmThumb)
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto cleanup;
        }

    hbmDef = (HBITMAP)SelectObject(hdcm1, hbmThumb);

    //
    // Initialize the DIB:
    //
    memset( pThumb, 0, bmiDIB.bmiHeader.biSizeImage );

    //
    // We want to create 80x60 thumbnail while preserving the original
    // image aspect ratio.
    //
    fImageWidth  = (double)lWidth;
    fImageHeight = (double)lHeight;
    fAspect      = fImageWidth / fImageHeight;

    if (fAspect > fDefAspect)
        {
        lThumbWidth  = 80;
        lThumbHeight = (LONG)(80.0 / fAspect);
        }
    else
        {
        lThumbHeight = 60;
        lThumbWidth  = (LONG)(60.0 * fAspect);
        }

    memset(&bmiJPEG,0,sizeof(bmiJPEG));

    bmiJPEG.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmiJPEG.bmiHeader.biBitCount      = 24;     // Use 0 for JPEG content.
    bmiJPEG.bmiHeader.biWidth         = lWidth;
    bmiJPEG.bmiHeader.biHeight        = lHeight;
    bmiJPEG.bmiHeader.biPlanes        = 1;
    bmiJPEG.bmiHeader.biCompression   = BI_RGB; // BI_JPEG;
    bmiJPEG.bmiHeader.biXPelsPerMeter = 1000;
    bmiJPEG.bmiHeader.biYPelsPerMeter = 1000;
    bmiJPEG.bmiHeader.biClrUsed       = 0;
    bmiJPEG.bmiHeader.biClrImportant  = 0;
    bmiJPEG.bmiHeader.biSizeImage     = FileInfo.nFileSizeLow;

    iStatus = StretchDIBits( hdcm1,
                             0,
                             0,
                             lThumbWidth,
                             lThumbHeight,
                             0,
                             0,
                             lWidth,
                             lHeight,
                             pDIB,  // pFile is our JPEG.
                             &bmiJPEG,
                             DIB_RGB_COLORS,
                             SRCCOPY );
    if (iStatus == GDI_ERROR)
        {
        dwStatus = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);
        }

    SelectObject(hdcm1, hbmDef);

    //
    // If necessary, cache the thumbnail:
    //
    if (bCacheThumb)
        {
        memcpy( pTmbFile, pThumb, bmiDIB.bmiHeader.biSizeImage );
        }

    //
    // Allocate memory for thumbnail pixels:
    //
    pTmbPixels = (PBYTE)ALLOC(bmiDIB.bmiHeader.biSizeImage);
    if (! pTmbPixels)
        {
        hr = E_OUTOFMEMORY;
        goto cleanup;
        }

    //
    // Write out the thumbnail data to the cache file:
    //
    memcpy( pTmbPixels, pThumb, bmiDIB.bmiHeader.biSizeImage);
    *ppThumbnail = pTmbPixels;
    *pThumbSize = bmiDIB.bmiHeader.biSizeImage;


    cleanup:
        if (pTmbFile)
            {
            UnmapViewOfFile(pTmbFile);
            }
        if (hTmbMap)
            {
            CloseHandle(hTmbMap);
            }
        if (hTmbFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hTmbFile);
            }

        if (pFile)
            {
            UnmapViewOfFile(pFile);
            }
        if (hMap)
            {
            CloseHandle(hMap);
            }
        if (hFile != INVALID_HANDLE_VALUE)
            {
            CloseHandle(hFile);
            }

        if (hbmThumb)
            {
            DeleteObject(hbmThumb);
            }

        if (hdcm1)
            {
            DeleteDC(hdcm1);
            }
        if (hdc)
            {
            ReleaseDC(NULL, hdc);
            }

    return hr;
}


//--------------------------------------------------------------------------
// CamDeletePicture()
//
// Delete the specified picture from the temp directory. In this case, all
// that we have to do is delete image (.jpg) and the temporary thumbnail
// file that we created (.tmb).
//
// Arguments:
//
//    pIrCamContext --
//
// Return Value:
//
//    HRESULT    S_OK
//               S_FAIL
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::CamDeletePicture( IRCAM_IMAGE_CONTEXT *pIrCamContext )
    {
    DWORD  dwStatus;

    WIAS_TRACE((g_hInst,"CamDeletePicture(): %s",pIrCamContext->pszCameraImagePath));

    //
    // First, delete the thumbnail (.tmb) file:
    //
    DWORD  dwLen = _tcslen(pIrCamContext->pszCameraImagePath);
    TCHAR *pszThumb = (TCHAR*)_alloca(sizeof(TCHAR)*(dwLen+1) + sizeof(SZ_TMB));

    _tcscpy(pszThumb,pIrCamContext->pszCameraImagePath);
    _tcscat(pszThumb,SZ_TMB);

    if (!DeleteFile(pszThumb))
        {
        dwStatus = ::GetLastError();
        }

    //
    // Now, delete the image (.jpg):
    //
    if (!DeleteFile(pIrCamContext->pszCameraImagePath))
        {
        dwStatus = ::GetLastError();
        }

    return S_OK;
    }


//--------------------------------------------------------------------------
// CamTakePicture()
//
// Tell the camera to snap a picture. IrTran-P doesn't support this.
//
// Arguments:
//
//    pIrCamContext --
//
//    pHandle       --
//
//
// Return Value:
//
//    HRESULT     E_NOTIMPL
//
//--------------------------------------------------------------------------
HRESULT CamTakePicture( IRCAM_IMAGE_CONTEXT  *pIrCamContext ,
                        ULONG                 *pHandle)
    {
    return E_NOTIMPL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\mscplus\mscplus.h ===
/***************************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
*
*  TITLE:       MSCplus.h
*
*  VERSION:     1.0
*
*  AUTHOR:      PoYuan
*
*  DATE:        3 Nov, 2000
*
*  DESCRIPTION:
*   Class definition for MSC+ functionalities.
*   11/03/2000 - First revision finished and unitested on a limited number of functions.
*
****************************************************************************************/

#ifndef __MSCPLUS_H__
#define __MSCPLUS_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <devioctl.h>
#include <ntddscsi.h>
#include <stddef.h>

#pragma intrinsic(memcmp)

typedef struct _SCSI_PASS_THROUGH_WITH_BUFFERS {
    SCSI_PASS_THROUGH spt;
    ULONG             Filler;      // realign buffers to double word boundary
    UCHAR             ucSenseBuf[32];
    UCHAR             ucDataBuf[512];
} SCSI_PASS_THROUGH_WITH_BUFFERS, *PSCSI_PASS_THROUGH_WITH_BUFFERS;

typedef struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER {
    SCSI_PASS_THROUGH_DIRECT sptd;
    ULONG             Filler;      // realign buffer to double word boundary
    UCHAR             ucSenseBuf[32];
} SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, *PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER;



//
// Command Descriptor Block constants.
//

const UCHAR CDB6GENERIC_LENGTH  = 6;
const UCHAR CDB10GENERIC_LENGTH = 10;

const UCHAR SCSI_MIN_CDB_LENGTH = 6;
const UCHAR SCSI_MAX_CDB_LENGTH = 12;
//
// SCSI CDB operation codes
//

const UCHAR SCSIOP_TEST_UNIT_READY =    0x00;
const UCHAR SCSIOP_INQUIRY         =    0x12;
const UCHAR SCSIOP_SEND_DIAGNOSTIC =    0x1D;
const UCHAR SCSIOP_REQUEST_SENSE   =    0x03;

// The following are MSCPlus specific definitions

const UCHAR SCSIOP_READ_INFO          = 0xE0;
const UCHAR SCSIOP_WRITE_INFO         = 0xE1;
const UCHAR SCSIOP_START_STOP_CAPTURE = 0xE2;
const UCHAR SCSIOP_RESET_DEVICE       = 0xDF;

const UCHAR SCSI_DTC_IMAGE           = 0x00;
const UCHAR SCSI_DTC_DEVICE_INFO     = 0x80;
const UCHAR SCSI_DTC_DEV_PROP_DESC   = 0x81;
const UCHAR SCSI_DTC_DEV_PROP_VALUE  = 0x82;

const UCHAR CAPTURE_TYPE_SINGLE      = 0x00;
const UCHAR CAPTURE_TYPE_OPEN_CAP    = 0x01;
const UCHAR CAPTURE_TYPE_STOP_CAP    = 0x02;



#define DEFAULT_DATA_BUFFER_SIZE   224
#define DEFAULT_VENDOR_STRING_LENGTH  8
#define DEFAULT_PRODUCT_STRING_LENGTH 16
#define DEFAULT_VERSION_STRING_LENGTH 4


#define CHECK_MSCPLUS_INITIALIZATION(b)  if(!b){return ERROR_INVALID_ACCESS;}

// ResponseCodes
#define RESPCODE_OK                         0x2001
#define RESPCODE_GENERALERROR               0x2002
#define RESPCODE_OPERATIONNOTSUPPORTED      0x2005
#define RESPCODE_PARAMETERNOTSUPPORTED      0x2006
#define RESPCODE_DEVICEPROPNOTSUPPORTED     0x200A
#define RESPCODE_STORAGEFULL                0x200C
#define RESPCODE_ACCESSDENIED               0x200F
#define RESPCODE_SELFTESTFAILED             0x2011
#define RESPCODE_INVALIDCODEFORMAT          0x2016
#define RESPCODE_CAPTUREALREADYTERMINATED   0x2018
#define RESPCODE_DEVICEBUSY                 0x2019
#define RESPCODE_INVALIDDEVICEPROPFORMAT    0x201B
#define RESPCODE_INVALIDDEVICEPROPVALUE     0x201C
#define RESPCODE_INVALIDPARAMETER           0x201D

// DataTypeCodes
#define DTCODE_UNDEFINED    0x0000
#define DTCODE_INT8		    0x0001
#define DTCODE_UINT8		0x0002
#define DTCODE_INT16		0x0003
#define DTCODE_UINT16		0x0004
#define DTCODE_INT32		0x0005
#define DTCODE_UINT32		0x0006
#define DTCODE_INT64		0x0007
#define DTCODE_UINT64		0x0008
#define DTCODE_INT128		0x0009
#define DTCODE_UINT128		0x000A
#define DTCODE_AINT8		0x4001
#define DTCODE_AUINT8		0x4002
#define DTCODE_AINT16		0x4003
#define DTCODE_AUINT16		0x4004
#define DTCODE_AINT32		0x4005
#define DTCODE_AUINT32		0x4006
#define DTCODE_AINT64		0x4007
#define DTCODE_AUINT64		0x4008
#define DTCODE_AINT128		0x4009
#define DTCODE_AUINT128		0x400A
#define DTCODE_STR		    0xFFFF
#define DTCODE_REAL		    0x8001
#define DTCODE_DSDEVINFO	0x8002
#define DTCODE_DSPROPDESC	0x8003	

// DevicePropCodes
#define PROPCODE_UNDEFINED                  0x5000
#define PROPCODE_BATTERYLEVEL               0x5001
#define PROPCODE_FUNCTIONALMODE             0x5002
#define PROPCODE_IMAGESIZE                  0x5003
#define PROPCODE_COMPRESSIONSETTING         0x5004
#define PROPCODE_WHITEBALANCE               0x5005
#define PROPCODE_RGBGAIN                    0x5006
#define PROPCODE_FNUMBER                    0x5007
#define PROPCODE_FOCALLENGTH                0x5008
#define PROPCODE_FOCUSDISTANCE              0x5009
#define PROPCODE_FOCUSMODE                  0x500A
#define PROPCODE_EXPOSUREMETERINGMODE       0x500B
#define PROPCODE_FLASHMODE                  0x500C
#define PROPCODE_EXPOSURETIME               0x500D
#define PROPCODE_EXPOSUREPROGRAMMODE        0x500E
#define PROPCODE_EXPOSUREINDEX              0x500F
#define PROPCODE_EXPOSUREBIASCOMPENSATION   0x5010
#define PROPCODE_DATETIME                   0x5011
#define PROPCODE_CAPTUREDELAY               0x5012
#define PROPCODE_STILLCAPTUREMODE           0x5013
#define PROPCODE_CONTRAST                   0x5014
#define PROPCODE_SHARPNESS                  0x5015
#define PROPCODE_DIGITALZOOM                0x5016
#define PROPCODE_EFFECTMODE                 0x5017
#define PROPCODE_BURSTNUMBER                0x5018
#define PROPCODE_BURSTINTERVAL              0x5019
#define PROPCODE_TIMELAPSENUMBER            0x501A
#define PROPCODE_TIMELAPSEINTERVAL          0x501B
#define PROPCODE_FOCUSMETERINGMODE          0x501C
#define PROPCODE_UPLOADURL                  0x501D
#define PROPCODE_ARTIST                     0x501E
#define PROPCODE_COPYRIGHTINFO              0x501F

class CMSCplus {
private:
    BYTE  *m_pDataBuffer;
    BYTE  m_ucInquiryBuffer[DEFAULT_DATA_BUFFER_SIZE];
    DWORD m_dwInquiryDataLength; 
    CHAR *m_szCreateFileName;
    BOOL  m_bInitialized;
    UCHAR m_ucScsiStatus; // stores ResponseCode of last operation
    UCHAR m_SCSIPathId;
    UCHAR m_SCSITargetId;
    UCHAR m_SCSILun;

private:
    DWORD m_utilIssueSimpleSCSICDB(UCHAR *pCDB, UCHAR ucSize, UCHAR ucDirection);
    DWORD m_utilSCSIGetInquiryBuffer(UCHAR ucCDB1=0, UCHAR ucCDB2=0);
    WORD  m_LookupDTCodeFromPropCode(WORD wPropCode);

public:
    // Functions related to SCSI Command Test Unit Ready (00H)
    BOOL IsDeviceReady(void);

    // Functions related to SCSI Command Send Diagnostic (1DH)
    DWORD SelfTest(BYTE *pParamBuffer=NULL, DWORD dwBufSize=NULL);

    // Functions related to SCSI Command Inquiry (12H)
                    // reuse Inquiry Buffer to reduce traffic
    DWORD GetStandardInquiryBuffer(LPBYTE pBuffer, DWORD *pdwBufSize, BOOL bNoReuseIB=FALSE);
    DWORD GetManufacturer(BYTE *pBuffer, DWORD *pdwBufSize, BOOL bNoReuseIB=FALSE);
    DWORD GetProductName(BYTE *pBuffer, DWORD *pdwBufSize, BOOL bNoReuseIB=FALSE);
    DWORD GetProductVersion(BYTE *pBuffer, DWORD *pdwBufSize, BOOL bNoReuseIB=FALSE);
    DWORD GetVendorSpecificInfo(BYTE *pBuffer, DWORD *pdwBufSize, BOOL bNoReuseIB=FALSE);
    DWORD GetDeviceSerialNumber(BYTE *pBuffer, DWORD *pdwBufSize, BOOL bNoReuseIB=FALSE);
    
  
     // Functions related to SCSI Command READ INFO 
    DWORD GetDeviceInfo(LPBYTE pDeviceInfo, DWORD dwDeviceInfoBufferLength);
    DWORD GetDevicePropDesc(WORD wPropCode, LPBYTE pPropDesc, DWORD dwPropDescLength);
    DWORD GetDevicePropValue(WORD wPropCode, LPBYTE pPropValue, DWORD dwPropValueLength);

    // Functions related to SCSI Command WRITE INFO 
    DWORD SetDevicePropValue(WORD wPropCode, LPBYTE pValue, DWORD dwValueLength);
    DWORD ResetDevicePropValue(WORD wPropCode);

    // Functions related to SCSI Command START STOP CAPTURE 
    DWORD InitiateCapture(WORD wFormateCode=0, BYTE *pParamBuffer=NULL, DWORD dwBufSize=0);
    DWORD TerminateOpenCapture(void);
    DWORD InitiateOpenCapture(WORD wFormatCode=0, BYTE *pParamBuffer=NULL, DWORD dwBufSize=0);

    // Functions related to SCSI RESET DEVICE 
    DWORD ResetDevice(void);

    // Basic functions
    BOOL Initialize(WCHAR wcDriveLetter);
    WORD GetScsiStatus() { return m_ucScsiStatus; };
    BOOL IsMSCplusDevice(DWORD *pdwError, BOOL bNoReuseIB=FALSE); 
    
    CMSCplus() 
    {
        m_bInitialized=FALSE;
        m_ucScsiStatus=0;
    };

    ~CMSCplus()
    { 
        if( m_bInitialized )
        {
            delete [] m_szCreateFileName;
        }
    };
};

#endif // __MSCPLUS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\device.cpp ===
//------------------------------------------------------------------------------
// Copyright (c) 1999-2000  Microsoft Corporation.
//
//  device.cpp
//
//  Implement IrTran-P device methods.
//
//  Author:
//
//     EdwardR   12-Aug-1999   Modeled from code by ReedB.
//
//------------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <irthread.h>

#include "ircamera.h"
#include "resource.h"
#include "tcamprop.h"

// #include "/nt/private/windows/imagein/ui/uicommon/simstr.h"
// #include "/nt/private/windows/imagein/ui/inc/shellext.h"

extern HINSTANCE g_hInst;
extern DWORD EnableDisableIrCOMM( IN BOOL fDisable );  // irtranp\irtranp.cpp

DWORD  WINAPI EventMonitorThread( IN void *pvIrUsdDevice );  // Forward Ref.

#define SZ_REG_KEY_INFRARED    TEXT("Control Panel\\Infrared")
#define SZ_REG_KEY_IRTRANP     TEXT("Control Panel\\Infrared\\IrTranP")
#define SZ_REG_DISABLE_IRCOMM  TEXT("DisableIrCOMM")

HKEY  g_hRegistryKey = 0;

//--------------------------------------------------------------------------
// SignalWIA()
//
// Helper function used by the IrTran-P code to signal WIA that a new
// picture has arrived.
//
// Arguments:
//
//    pvIrUsdDevice  -- Device object. IrTran-P only knows this as a void*.
//
//--------------------------------------------------------------------------
DWORD SignalWIA( IN char *pszPathPlusFileName,
                 IN void *pvIrUsdDevice )
    {
    HRESULT hr;
    DWORD   dwStatus = 0;
    IrUsdDevice *pIrUsdDevice = (IrUsdDevice*)pvIrUsdDevice;


    //
    // First, add the new picture to the tree representing the images:
    //
    if (pIrUsdDevice && pIrUsdDevice->IsInitialized())
        {
        TCHAR *ptszPath;
        TCHAR *ptszFileName;

        #ifdef UNICODE

        int      iStatus;
        WCHAR    wszTemp[MAX_PATH];

        iStatus = MultiByteToWideChar( CP_ACP,
                                       0,
                                       pszPathPlusFileName,
                                       -1, // Auto-calculate length...
                                       wszTemp,
                                       MAX_PATH);

        ptszPath = wszTemp;
        ptszFileName = wcsrchr(wszTemp,L'\\');
        ptszFileName++;

        #else

        ptszPath = pszPathPlusFileName;
        ptszFileName = strrchr(pszPathPlusFileName,'\\');
        ptszFileName++;

        #endif

        IrUsdDevice *pIrUsdDevice = (IrUsdDevice*)pvIrUsdDevice;
        IWiaDrvItem *pNewImage;

        hr = pIrUsdDevice->CreateItemFromFileName(
                             WiaItemTypeFile | WiaItemTypeImage,
                             ptszPath,
                             ptszFileName,
                             &pNewImage);

        if (!FAILED(hr))
            {
            IWiaDrvItem *pDrvItemRoot = pIrUsdDevice->GetDrvItemRoot();

            hr = pNewImage->AddItemToFolder(pDrvItemRoot);

            pNewImage->Release();
            }
        else
            {
            WIAS_ERROR((g_hInst,"SignalWIA(): CreateItemFromFileName() Failed: %x",hr));
            }
        }

    //
    // Now, signal WIA:
    //
    if (pIrUsdDevice)
        {
        DWORD dwNewTime = GetTickCount();
        DWORD dwDelta = dwNewTime - pIrUsdDevice->m_dwLastConnectTime;

        if (dwDelta > RECONNECT_TIMEOUT)
            {
            pIrUsdDevice->m_guidLastEvent = WIA_EVENT_DEVICE_CONNECTED;
            if (!SetEvent(pIrUsdDevice->m_hSignalEvent))
                {
                dwStatus = GetLastError();
                WIAS_ERROR((g_hInst,"SignalWIA(): SetEvent() Failed: %d",dwStatus));
                }
            }
        else
            {
            pIrUsdDevice->m_guidLastEvent = WIA_EVENT_ITEM_CREATED;
            if (!SetEvent(pIrUsdDevice->m_hSignalEvent))
                {
                dwStatus = GetLastError();
                WIAS_ERROR((g_hInst,"SignalWIA(): SetEvent() Failed: %d",dwStatus));
                }
            }

        pIrUsdDevice->m_dwLastConnectTime = dwNewTime;
        }
    else
        {
        WIAS_ERROR((g_hInst,"SignalWIA(): null pvIrUsdDevice object"));
        return dwStatus;
        }

    //
    // Display IrCamera browser if it's not already up:
    //
#if FALSE
    HINSTANCE hInst = LoadLibrary(TEXT("WIASHEXT.DLL"));
    if (hInst)
        {
        WIAMAKEFULLPIDLFORDEVICE pfn =
              (WIAMAKEFULLPIDLFORDEVICE)GetProcAddress(hInst, "MakeFullPidlForDevice");

        if (pfn)
            {
            LPITEMIDLIST pidl = NULL;

            pfn( pIrUsdDevice->m_bstrDeviceID, &pidl );

            if (pidl)
                {
                SHELLEXECUTEINFO sei;

                memset( &sei, 0, sizeof(sei) );

                sei.cbSize      = sizeof(sei);
                // sei.hwnd        = hDlg;
                sei.fMask       = SEE_MASK_IDLIST;
                sei.nShow       = SW_SHOW;
                sei.lpIDList    = pidl;

                ShellExecuteEx( &sei );

                LPMALLOC pMalloc = NULL;
                if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
                    {
                    pMalloc->Free(pidl);
                    pMalloc->Release();
                    }
                }
            }


        FreeLibrary( hInst );
        }
#endif

    return dwStatus;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::IrUsdDevice()
//
//   Device class constructor
//
// Arguments:
//
//    punkOuter
//
// Return Value:
//
//    None
//
//--------------------------------------------------------------------------
IrUsdDevice::IrUsdDevice( LPUNKNOWN punkOuter ):
                  m_cRef(1),
                  m_punkOuter(NULL),
                  m_dwLastConnectTime(0),
                  m_fValid(FALSE),
                  m_pIStiDevControl(NULL),
                  m_hShutdownEvent(INVALID_HANDLE_VALUE),
                  m_hRegistryEvent(INVALID_HANDLE_VALUE),
                  m_hSignalEvent(INVALID_HANDLE_VALUE),
                  m_hIrTranPThread(NULL),
                  m_hEventMonitorThread(NULL),
                  m_guidLastEvent(GUID_NULL),
                  m_pIWiaEventCallback(NULL),
                  m_pStiDevice(NULL),
                  m_bstrDeviceID(NULL),
                  m_bstrRootFullItemName(NULL),
                  m_pIDrvItemRoot(NULL)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::IrUsdDevice"));

    //
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    //

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        }
    else
        {
        //
        // Cast below is needed in order to point to right virtual table
        //
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
        }
    }

HRESULT IrUsdDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;
    
    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"IrUsdDevice::PrivateInitialize, create shutdown CritSect failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {

        //
        // Create event for syncronization of notifications shutdown.
        //
        m_hShutdownEvent =  CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent))
        {
            m_fValid = TRUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"IrUsdDevice::PrivateInitialize, create shutdown event failed"));
        }
    }
    
    return hr;
}

                  

//------------------------------------------------------------------------
// IrUsdDevice::~IrUsdDevice
//
//   Device class destructor
//
// Arguments:
//
//    None
//
// Return Value:
//
//    None
//
//------------------------------------------------------------------------
IrUsdDevice::~IrUsdDevice(void)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::~IrUsdDevice"));


    //
    // Kill notification thread if it exists.
    //

    SetNotificationHandle(NULL);

    //
    // Close event for syncronization of notifications shutdown.
    //

    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE))
        {
        CloseHandle(m_hShutdownEvent);
        }

    if (m_hRegistryEvent && (m_hRegistryEvent != INVALID_HANDLE_VALUE))
        {
        CloseHandle(m_hRegistryEvent);
        }

    //
    // Release the device control interface.
    //

    if (m_pIStiDevControl)
        {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
        }

    //
    // WIA member destruction
    //
    // Cleanup the WIA event sink.
    //

    if (m_pIWiaEventCallback)
        {
        m_pIWiaEventCallback->Release();
        }

    //
    // Free the storage for the device ID.
    //

    if (m_bstrDeviceID)
        {
        SysFreeString(m_bstrDeviceID);
        }

    //
    // Release the objects supporting device property storage.
    //

    if (m_bstrRootFullItemName)
        {
        SysFreeString(m_bstrRootFullItemName);
        }

    //
    // Free the critical section.
    //
    DeleteCriticalSection(&m_csShutdown);
    
    }

/**************************************************************************\
* IrUsdDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    //
    // We do support device notifications, but do not requiring polling.
    //

    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return STI_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::GetStatus()
//
//   Query device online and/or event status.
//
// Arguments:
//
//   pDevStatus  - Pointer to device status data.
//
// Return Value:
//
//    HRESULT - STI_OK
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::GetStatus( IN OUT PSTI_DEVICE_STATUS pDevStatus )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::GetStatus()"));

    //
    // Validate parameters.
    //
    if (!pDevStatus)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::GetStatus, NULL device status"));
        return E_INVALIDARG;
        }

    //
    // If we are asked, verify whether device is online.
    //
    pDevStatus->dwOnlineState = 0L;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)
        {
        //
        // The IrTran-P device is always on-line:
        //
        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }

    //
    // If we are asked, verify state of event.
    //
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE)
        {
        //
        // Generate an event the first time we load.
        //
        if (m_bUsdLoadEvent)
            {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_bUsdLoadEvent = FALSE;
            }

        //
        // event pending ???
        //
        }

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::DeviceReset()
//
//   Reset data file pointer to start of file. For IrTran-P, we don't need
//   to do anything.
//
// Arguments:
//
//    None
//
// Return Value:
//
//    HRESULT - STI_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::DeviceReset(void)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::DeviceReset()"));

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::Diagnostic()
//
//   Run the camera through a test diagnostic. The IrTran-P device will
//   always pass the diagnostic.
//
// Arguments:
//
//    pBuffer    - Pointer o diagnostic results data.
//
// Return Value:
//
//    HRESULT - STI_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::Diagnostic( IN OUT LPSTI_DIAG pBuffer )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::Diagnostic()"));

    //
    // Initialize response buffer
    //
    pBuffer->dwStatusMask = 0;

    memset( &pBuffer->sErrorInfo, 0, sizeof(pBuffer->sErrorInfo) );

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::StartIrTranPThread()
//
//--------------------------------------------------------------------------
DWORD IrUsdDevice::StartIrTranPThread()
    {
    DWORD   dwStatus = S_OK;
    DWORD   dwThread;

    if (!m_hIrTranPThread)
        {
        m_hIrTranPThread = CreateThread( NULL,       // Default security
                                         0,          // Default stack size
                                         IrTranP,    // IrTran-P protocol eng.
                                         (LPVOID)this,
                                         0,          // Creation flags
                                         &dwThread); // New thread ID.

        if (!m_hIrTranPThread)
            {
            dwStatus = ::GetLastError();
            WIAS_ERROR((g_hInst,"IrUsdDevice::SetNotificationHandle(): unable to create IrTran-P thread: %d",dwStatus));
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::StopIrTranPThread()
//
//--------------------------------------------------------------------------
DWORD IrUsdDevice::StopIrTranPThread()
    {
    DWORD   dwStatus;

    //
    // Shutdown the listen on IrCOMM, this will cause the IrTran-P thread
    // to exit.
    //
    dwStatus = EnableDisableIrCOMM(TRUE);  // TRUE == Disable.

    m_hIrTranPThread = NULL;

    return dwStatus;
    }
//--------------------------------------------------------------------------
// IrUsdDevice::StartEventMonitorThread()
//
//--------------------------------------------------------------------------
DWORD IrUsdDevice::StartEventMonitorThread()
    {
    DWORD   dwStatus = S_OK;
    DWORD   dwThread;

    //
    //  Event to signal for registry changes:
    //
    if ((!m_hRegistryEvent)||(m_hRegistryEvent == INVALID_HANDLE_VALUE))
        {
        m_hRegistryEvent = CreateEvent( NULL,    // Security
                                        FALSE,   // Auto-reset
                                        FALSE,   // Initially not set
                                        NULL );  // No name
        }

    if (!m_hRegistryEvent)
        {
        dwStatus = ::GetLastError();

        WIAS_ERROR((g_hInst,"IrUsdDevice::StartEventMonitorThread(): unable to create Registry Monitor Event: %d",dwStatus));

        return dwStatus;
        }

    //
    //  Start monitoring the registry to look for enable/disable changes
    //  for access to the IrCOMM port.
    //
    if (!m_hEventMonitorThread)
        {
        m_hEventMonitorThread = CreateThread(
                                        NULL,        // Default security
                                        0,           // Default stack size
                                        EventMonitorThread,
                                        (LPVOID)this,// Function data
                                        0,           // Creation flags
                                        &dwThread ); // New thread ID
        if (!m_hEventMonitorThread)
            {
            dwStatus = ::GetLastError();
            WIAS_ERROR((g_hInst,"IrUsdDevice::StartEventMonitorThread(): unable to create Registry Monitor Thread: %d",dwStatus));
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::SetNotificationHandle()
//
//   Starts and stops the event notification thread.
//
// Arguments:
//
//    hEvent -   Event to use in signaling WIA of events (like CONNECT etc.)
//               If valid start the notification thread otherwise kill the
//               notification thread.
//
// Return Value:
//
//    HRESULT  - STI_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::SetNotificationHandle( IN HANDLE hEvent )
    {
    DWORD   dwStatus;
    HRESULT hr = STI_OK;

    WIAS_TRACE((g_hInst,"IrUsdDevice::SetNotificationHandle"));


    EnterCriticalSection(&m_csShutdown);

    //
    // Are we starting or stopping the notification thread?
    //
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE))
        {
        m_hSignalEvent = hEvent;

        //
        // Initialize to no event.
        //
        m_guidLastEvent = GUID_NULL;

#if FALSE
        //
        // Create the notification thread.
        //
        if (!m_hIrTranPThread)
            {
            DWORD   dwThread;

            m_hIrTranPThread = CreateThread(
                                         NULL,       // Default security
                                         0,          // Default stack size
                                         IrTranP,    // IrTran-P protocol eng.
                                         (LPVOID)this,
                                         0,          // Creation flags
                                         &dwThread); // New thread ID.

            if (m_hIrTranPThread)
                {
                WIAS_TRACE((g_hInst,"IrUsdDevice::SetNotificationHandle(): Enabling IrTran-P"));
                }
            else
                {
                dwStatus = ::GetLastError();
                WIAS_ERROR((g_hInst,"IrUsdDevice::SetNotificationHandle(): unable to create IrTran-P thread: %d",dwStatus));
                hr = HRESULT_FROM_WIN32(dwStatus);
                }
            }
        else
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::SetNotificationHandle(): spurious IrTran-P thread"));
            hr = STI_OK;   // STIERR_UNSUPPORTED;
            }
#endif

        dwStatus = StartEventMonitorThread();

        if (dwStatus)
            {
            hr = HRESULT_FROM_WIN32(dwStatus);
            }
        }
    else
        {
        //
        // Disable event notifications.
        //
        SetEvent(m_hShutdownEvent);

        if (m_hIrTranPThread)
            {
            WIAS_TRACE((g_hInst,"IrUsdDevice::SetNotificationHandle(): stopping IrTran-P thread"));
            UninitializeIrTranP(m_hIrTranPThread);
            }
        }

    LeaveCriticalSection(&m_csShutdown);

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::GetNotificationData()
//
//   WIA calls this function to get data on the event. Currently for IrTran-P,
//   we get one of two events either WIA_EVENT_DEVICE_CONNECTED or
//   WIA_EVENT_ITEM_CREATED.
//
// Arguments:
//
//    pStiNotify - Pointer to event data.
//
// Return Value:
//
//    HRESULT  - STI_OK
//               STIERR_NOEVENT (not currently returned).
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::GetNotificationData( IN OUT LPSTINOTIFY pStiNotify )
    {
    DWORD  dwStatus;

    WIAS_TRACE((g_hInst,"IrUsdDevice::GetNotificationData()"));

    memset(pStiNotify,0,sizeof(STINOTIFY));

    pStiNotify->dwSize = sizeof(STINOTIFY);

    pStiNotify->guidNotificationCode =  m_guidLastEvent;

    //
    // If we are to return a device connected then follow it by an item
    // created event.
    //
    if (IsEqualGUID(m_guidLastEvent,WIA_EVENT_DEVICE_CONNECTED))
        {
        m_guidLastEvent = WIA_EVENT_ITEM_CREATED;
        if (!SetEvent(m_hSignalEvent))
            {
            dwStatus = ::GetLastError();
            WIAS_ERROR((g_hInst,"SignalWIA(): SetEvent() Failed: %d",dwStatus));
            }
        }

    return STI_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::Escape()
//
//   Used to issue a command to the device. IrTran-P doesn't support this.
//
// Arguments:
//
//    EscapeFunction - Command to be issued.
//    pInData        - Input data to be passed with command.
//    cbInDataSize   - Size of input data.
//    pOutData       - Output data to be passed back from command.
//    cbOutDataSize  - Size of output data buffer.
//    pcbActualData  - Size of output data actually written.
//
// Return Value:
//
//    HRESULT - STI_OK
//              STIERR_UNSUPPORTED
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::Escape(
                            STI_RAW_CONTROL_CODE EscapeFunction,
                            LPVOID               pInData,
                            DWORD                cbInDataSize,
                            LPVOID               pOutData,
                            DWORD                cbOutDataSize,
                            LPDWORD              pcbActualData )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::Escape(): unsupported"));

    //
    // Write command to device if needed.
    //

    return STIERR_UNSUPPORTED;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::GetLastError()
//
//   Get the last error from the device.
//
// Arguments:
//
//    pdwLastDeviceError - Pointer to last error data.
//
// Return Value:
//
//    HRESULT - STI_OK
//              STIERR_INVALID_PARAM
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::GetLastError( OUT LPDWORD pdwLastDeviceError )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::GetLastError()"));

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD)))
        {
        return STIERR_INVALID_PARAM;
        }

    *pdwLastDeviceError = m_dwLastOperationError;

    return STI_OK;
    }

/**************************************************************************\
* IrUsdDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    WIAS_TRACE((g_hInst,"IrUsdDevice::GetLastErrorInfo"));

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return STI_OK;
}

/**************************************************************************\
* IrUsdDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::LockDevice(void)
    {
    return STI_OK;
    }

/**************************************************************************\
* IrUsdDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::UnLockDevice(void)
{
    return STI_OK;
}

/**************************************************************************\
* IrUsdDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawReadData"));

    return STI_OK;
}

/**************************************************************************\
* IrUsdDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawWriteData"));

    return STI_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::RawReadCommand()
//
//    Raw read of bytes directly from the camera. Not supported by IrTran-P
//    device.
//
// Arguments:
//
//    lpBuffer           -
//    lpdwNumberOfBytes  -
//    lpOverlapped       -
//
// Return Value:
//
//    HRESULT  - STIERR_UNSUPPORTED
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::RawReadCommand(
                             IN LPVOID          lpBuffer,
                             IN LPDWORD         lpdwNumberOfBytes,
                             IN LPOVERLAPPED    lpOverlapped)
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawReadCommand() not supported"));

    return STIERR_UNSUPPORTED;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::RawWriteCommand()
//
//    Raw write of byte directly to a camera. Not supported by IrTran-P device.
//
// Arguments:
//
//    lpBuffer       -
//    nNumberOfBytes -
//    lpOverlapped   -
//
// Return Value:
//
//    HRESULT  - STIERR_UNSUPPORTED
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::RawWriteCommand(
                             IN LPVOID          lpBuffer,
                             IN DWORD           nNumberOfBytes,
                             IN LPOVERLAPPED    lpOverlapped )
    {
    WIAS_TRACE((g_hInst,"IrUsdDevice::RawWriteCommand(): not supported"));

    return STIERR_UNSUPPORTED;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::Initialize()
//
//   Initialize the device object.
//
// Arguments:
//
//    pIStiDevControlNone    -
//    dwStiVersion           -
//    hParametersKey         -
//
// Return Value:
//
//    HRESULT  STI_OK
//             STIERR_INVALID_PARAM
//
//--------------------------------------------------------------------------
STDMETHODIMP IrUsdDevice::Initialize(
                               PSTIDEVICECONTROL pIStiDevControl,
                               DWORD             dwStiVersion,
                               HKEY              hParametersKey )
    {
    HRESULT  hr = STI_OK;
    UINT     uiNameLen = 0;
    CAMERA_STATUS   camStatus;

    WIAS_TRACE((g_hInst,"IrUsdDevice::Initialize"));

    if (!pIStiDevControl)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::Initialize(): invalid device control interface"));
        return STIERR_INVALID_PARAM;
        }

    //
    // Cache the device control interface:
    //
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Try to open the camera only once here during Initialize:
    //
    hr = CamOpenCamera(&camStatus);

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::RunNotifications()
//
//   Monitor changes to the source data file parent directory.
//
// Arguments:
//
//    None
//
// Return Value:
//
//    None
//
//--------------------------------------------------------------------------
VOID IrUsdDevice::RunNotifications(void)
    {
    //
    // Start up camera event dlg
    //
    WIAS_TRACE((g_hInst,"IrUsdDevice::RunNotifications: start up event dlg"));

    HWND hWnd = GetDesktopWindow();

    int iret = DialogBoxParam( g_hInst,
                               MAKEINTRESOURCE(IDD_EVENT_DLG),
                               hWnd,
                               CameraEventDlgProc,
                               (LPARAM)this );

    WIAS_TRACE((g_hInst,"IrUsdDevice::RunNotifications, iret = 0x%lx",iret));

    if (iret == -1)
        {
        DWORD dwStatus = ::GetLastError();
        WIAS_TRACE((g_hInst,"IrUsdDevice::RunNotifications, dlg error = 0x%lx",dwStatus));
        }
    }

//--------------------------------------------------------------------------
// NotificationsThread()
//
//   Calls RunNotifications() to put up a dialog to start events.
//
// Arguments:
//
//    lpParameter    - Pointer to device object.
//
// Return Value:
//
//    None
//
//--------------------------------------------------------------------------
VOID NotificationsThread( LPVOID lpParameter )
    {
    WIAS_TRACE((g_hInst,"NotificationsThread(): Start"));

    IrUsdDevice *pThisDevice = (IrUsdDevice*)lpParameter;

    pThisDevice->RunNotifications();
    }


//--------------------------------------------------------------------------
//  OpenIrTranPKey()
//
//  Open and return a registry handle to the IrTranP key in the registry.
//  This key will be monitored for changes in value.
//--------------------------------------------------------------------------
DWORD OpenIrTranPKey( HKEY *phRegistryKey )
    {
    DWORD dwStatus = 0;
    DWORD dwDisposition = 0;
    HKEY  hKey;

    *phRegistryKey = 0;

    //
    // If we've been called before, then we don't need to reopen the key.
    //
    if (g_hRegistryKey)
        {
        *phRegistryKey = g_hRegistryKey;
        return 0;
        }

    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                       SZ_REG_KEY_INFRARED,
                       0,              // reserved MBZ
                       0,              // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       0,              // security attributes
                       &hKey,
                       &dwDisposition))
        {
        // Create failed.
        dwStatus = GetLastError();
        WIAS_TRACE((g_hInst,"OpenIrTranPKey(): RegCreateKeyEx(): '%' failed %d", SZ_REG_KEY_INFRARED, dwStatus));
        }

    if (RegCloseKey(hKey))
        {
        // Close failed.
        }

    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                       SZ_REG_KEY_IRTRANP,
                       0,              // reserved, MBZ
                       0,              // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       0,
                       &hKey,          // security attributes
                       &dwDisposition))
        {
        // Create failed
        dwStatus = GetLastError();
        WIAS_TRACE((g_hInst,"OpenIrTranPKey(): RegCreateKeyEx(): '%' failed %d", SZ_REG_KEY_IRTRANP, dwStatus));
        }

    *phRegistryKey = g_hRegistryKey = hKey;

    return dwStatus;
    }

//--------------------------------------------------------------------------
//  CheckForIrCOMMEnabled()
//
//  Check the registry to see if IrCOMM for IrTran-P is enabled, if it is
//  then return TRUE, else return FALSE.
//
//  Note: Don't close the key, it is maintained globally and will be closed
//  at shutdown.
//--------------------------------------------------------------------------
BOOL  CheckForIrCOMMEnabled( IN IrUsdDevice *pIrUsdDevice )
    {
    DWORD dwStatus;
    DWORD dwType;
    DWORD dwDisabled;
    DWORD dwValueSize = sizeof(dwDisabled);
    HKEY  hKey;

    dwStatus = OpenIrTranPKey(&hKey);
    if (dwStatus)
        {
        // If the key doesn't exist, or can't be opened, then assume that
        // we are enabled...
        return TRUE;
        }

    //
    // Check the value of the "DisableIrCOMM" value. Zero or missing value
    // means fEnabled == TRUE, non-zero value means fEnabled == FALSE.
    //
    if (RegQueryValueEx( hKey,         // IrTranP registry key
                         SZ_REG_DISABLE_IRCOMM,
                         NULL,         // reserved, MB NULL
                         &dwType,      // out, value type (expect: REG_DWORD)
                         (BYTE*)&dwDisabled, // out, value
                         &dwValueSize))      // in/out, size of value
        {
        // Query disabled flag registry value failed, assume enabled.
        return TRUE;
        }

    if ((dwType == REG_DWORD) && (dwDisabled))
        {
        // Disabled flag is set.
        return FALSE;
        }

    return TRUE;
    }

//--------------------------------------------------------------------------
//  EventMonitorThread()
//
//--------------------------------------------------------------------------
DWORD WINAPI EventMonitorThread( IN void *pvIrUsdDevice )
    {
    DWORD  dwStatus = 0;
    BOOL   fEnabled;
    HANDLE hHandles[2];
    HKEY   hRegistryKey;
    IrUsdDevice *pIrUsdDevice = (IrUsdDevice*)pvIrUsdDevice;

    //
    // Get the IrTranP registry key. We will monitor this key for
    // changes...
    //
    dwStatus = OpenIrTranPKey(&hRegistryKey);
    if (dwStatus)
        {
        return dwStatus;
        }

    //
    // We will Monitor two events. One for shutdown of the USD, the
    // other for registry state changes (to enable/disable listen on
    // IrCOMM).
    //
    hHandles[0] = pIrUsdDevice->m_hShutdownEvent;
    hHandles[1] = pIrUsdDevice->m_hRegistryEvent;

    while (TRUE)
        {
        fEnabled = CheckForIrCOMMEnabled(pIrUsdDevice);

        if ((fEnabled) && (!pIrUsdDevice->m_hIrTranPThread))
            {
            // Start IrTran-P listen/protocol thread.
            dwStatus = pIrUsdDevice->StartIrTranPThread();
            }
        else if (pIrUsdDevice->m_hIrTranPThread)
            {
            // Stop IrTran-P listen/protocol thread.
            dwStatus = pIrUsdDevice->StopIrTranPThread();
            }

        dwStatus = RegNotifyChangeKeyValue( hRegistryKey,  // IrTranP key
                                            FALSE,    // don't watch subtree
                                            REG_NOTIFY_CHANGE_LAST_SET,
                                            pIrUsdDevice->m_hRegistryEvent,
                                            TRUE );   // Asynchronous

        dwStatus = WaitForMultipleObjects( 2,
                                           hHandles,
                                           FALSE,
                                           INFINITE);
        if (dwStatus == WAIT_FAILED)
            {
            dwStatus = GetLastError();
            break;
            }

        if (dwStatus == WAIT_OBJECT_0)
            {
            // Received a shutdown event. If the IrTranP thread is running
            // then shut it down. Break out of this while loop to stop this
            // monitor thread.
            break;
            }

        if (dwStatus == WAIT_OBJECT_0+1)
            {
            // Received a registry change event. We'll continue around the
            // while loop and check to see if IrTranP over IrCOMM has been
            // disabled...
            continue;
            }

        else if (dwStatus == WAIT_ABANDONED_0)
            {
            // Wait abandonded on the shutdown event
            }
        else if (dwStatus == WAIT_ABANDONED_0+1)
            {
            // Wait abandonded on the registry change event
            }
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\ircamera.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// TITLE:       ircamera.cpp
//
// VERSION:     1.0
//
// AUTHOR:
//
//    EdwardR    22/Jul/99   Original coding.
//
// DESCRIPTION:
//
//    Implementation of the WIA IrTran-P USD.
//
//------------------------------------------------------------------------------

#define INITGUID

#include "ircamera.h"
#include "resource.h"

#include "wiamindr_i.c"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.

// Can we use UNICODE APIs
//BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

// Debugging interface, has IrUsdClassFactory lifetime.
WIA_DECLARE_DEBUGGER();

/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  IrUsdClassFactory
*
\****************************************************************************/

class IrUsdClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    IrUsdClassFactory();
    ~IrUsdClassFactory();
};

/**************************************************************************\
* IrUsdClassFactory::IrUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

IrUsdClassFactory::IrUsdClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_TRACE((g_hInst,"Creating IrUsdClassFactory"));
}

/**************************************************************************\
* IrUsdClassFactory::~IrUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

IrUsdClassFactory::~IrUsdClassFactory(void)
{
    // Destructor logic
    WIAS_TRACE((g_hInst,"Destroying IrUsdClassFactory"));
}

/**************************************************************************\
* IrUsdClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR  *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* IrUsdClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* IrUsdClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* IrUsdClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                       riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{

    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IWiaItem) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    IrUsdDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new IrUsdDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* IrUsdClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* IrUsdDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::NonDelegatingQueryInterface(
    REFIID   riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* IrUsdDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* IrUsdDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* IrUsdDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP IrUsdDevice::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* IrUsdDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* IrUsdDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) IrUsdDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C"
BOOL APIENTRY
DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {
                OutputDebugStringA("IrUsd: Unloaded before all objects releaseed!\n");
            }

            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_IrUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_IrUsd)) {
        IrUsdClassFactory *pcf = new IrUsdClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\ircamera.inc ===
#
#  Common settings for the IrTran-P USD
#

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\jpegutil.cpp ===
/***********************************************************************
 *
 * JPEG decompression utility functions
 *
 *   Implement (1) JPEG memory data source
 *             (2) JPEG error manager using setjmp/longjmp
 *
 *   Author : Indy Zhu    [indyz]
 *   Date   : 5/20/98
 *  
 ***********************************************************************/

#include  <stdio.h>
// #include  <stdlib.h>
#include  <setjmp.h>

// Workaround for redefinition of INT32
#define   XMD_H  1

extern "C"
{
// Header file for JPEG library
#include  "jpeglib.h"
}

#include  <windows.h>
#include  "jpegutil.h"

//
// Buf source manager definition
//

typedef struct _buf_source_mgr
{
    struct jpeg_source_mgr  pub;
    
    // Fields specific to buf_source_mgr
    LPBYTE                  pJPEGBlob;
    DWORD                   dwSize;   
} buf_source_mgr;

//
// Jump error manager definition
//

typedef struct _jmp_error_mgr
{
    struct jpeg_error_mgr  pub;

    // Private fields for jump error manager
    jmp_buf                stackContext;
} jmp_error_mgr;

/******************************************************************************\
*
* init_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void    init_source(j_decompress_ptr pDecompInfo)
{
    // No working necessary here
}

/******************************************************************************\
*
* fill_input_buffer()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static boolean fill_input_buffer(j_decompress_ptr pDecompInfo)
{
    buf_source_mgr  *pBufSrcMgr;

    // Recover buf source manager itself
    pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;

    // buf_source_mgr can only fire one shot    
    pBufSrcMgr->pub.next_input_byte = pBufSrcMgr->pJPEGBlob;
    pBufSrcMgr->pub.bytes_in_buffer = pBufSrcMgr->dwSize;
  
    return(TRUE);
}

/******************************************************************************\
*
* skip_input_data()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void    skip_input_data(j_decompress_ptr pDecompInfo, long lBytes)
{
    buf_source_mgr  *pBufSrcMgr;

    // For buf source manager, it is very easy to implement
    if (lBytes > 0) {

        pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;
    
        pBufSrcMgr->pub.next_input_byte += lBytes;
        pBufSrcMgr->pub.bytes_in_buffer -= lBytes;
    }
}

/******************************************************************************\
*
* term_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void    term_source(j_decompress_ptr pDecompInfo)
{
}

/******************************************************************************\
*
* jpeg_buf_src()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void jpeg_buf_src(j_decompress_ptr pDecompInfo, 
                         LPBYTE pJPEGBlob, DWORD dwSize)
{
    buf_source_mgr  *pBufSrcMgr;

    // Allocate memory for the buf source manager
    pBufSrcMgr = (buf_source_mgr *)
        (pDecompInfo->mem->alloc_small)((j_common_ptr)pDecompInfo, 
                                       JPOOL_PERMANENT, 
                                       sizeof(buf_source_mgr));
    // Record the pJPEGBlob
    pBufSrcMgr->pJPEGBlob = pJPEGBlob;
    pBufSrcMgr->dwSize    = dwSize;

    // Fill in the function pointers
    pBufSrcMgr->pub.init_source = init_source;
    pBufSrcMgr->pub.fill_input_buffer = fill_input_buffer;
    pBufSrcMgr->pub.skip_input_data = skip_input_data;
    pBufSrcMgr->pub.resync_to_restart = jpeg_resync_to_restart;
    pBufSrcMgr->pub.term_source = term_source;

    // Initialize the pointer into the buffer
    pBufSrcMgr->pub.bytes_in_buffer = 0;
    pBufSrcMgr->pub.next_input_byte = NULL;

    // Ask the decompression context to remember it
    pDecompInfo->src = (struct jpeg_source_mgr *)pBufSrcMgr;
}

/******************************************************************************\
*
* jmp_error_exit()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void  jmp_error_exit(j_common_ptr pDecompInfo)
{
    jmp_error_mgr  *pJmpErrorMgr;

    // Get the jump error manager back
    pJmpErrorMgr = (jmp_error_mgr *)pDecompInfo->err;

    // Display the error message
#ifdef _DEBUG
    (pDecompInfo->err->output_message)(pDecompInfo);
#endif

    // Recover the original stack
    longjmp(pJmpErrorMgr->stackContext, 1);
}

/******************************************************************************\
*
* jpeg_jmp_error()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

struct jpeg_error_mgr *jpeg_jmp_error(jmp_error_mgr *pJmpErrorMgr)
{
    // Initialize the public part
    jpeg_std_error(&pJmpErrorMgr->pub);

    // Set up jump error manager exit method
    pJmpErrorMgr->pub.error_exit = jmp_error_exit;

    return((jpeg_error_mgr *)pJmpErrorMgr);
}

/******************************************************************************\
*
* GetJPEGDimensions()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

int GetJPEGDimensions(LPBYTE pJPEGBlob, DWORD dwSize,
                      LONG   *pWidth, LONG *pHeight, WORD *pChannel)
{
    int                            ret;
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    ret = jpeg_read_header(&decompInfo, TRUE);

    // Release the decompression context
    jpeg_destroy_decompress(&decompInfo);

    // Fill in the dimension info for the caller
    *pWidth   = decompInfo.image_width;
    *pHeight  = decompInfo.image_height;
    *pChannel = decompInfo.num_components;

    if (ret != JPEG_HEADER_OK) {
        return(JPEGERR_INTERNAL_ERROR);
    }

    return(JPEGERR_NO_ERROR);
}

/******************************************************************************\
*
* DecompProgressJPEG()
*
* Arguments:
*
* Assumption : The JPEG  is 24bits.
*              pDIBPixel is the pixel buffer of a DIB
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

short __stdcall 
DecompProgressJPEG(
    LPBYTE                         pJPEGBlob, 
    DWORD                          dwSize, 
    LPBYTE                         pDIBPixel, 
    DWORD                          dwBytesPerScanLine,
    JPEGCallbackProc               pProgressCB, 
    PVOID                          pCBContext)
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    LPBYTE                         pCurScanBuf;
    JSAMPLE                        sampleTemp;
    LPBYTE                         pCurPixel;
    DWORD                          i;
    //
    // Callback related variables
    //
    ULONG                          ulImageSize;
    ULONG                          ulOffset;
    ULONG                          ulNewScanlines;
    ULONG                          ulCBInterval;
    BOOL                           bRet = FALSE;

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK) {

        jpeg_destroy_decompress(&decompInfo);
        return(JPEGERR_INTERNAL_ERROR);
    }
    
    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion

    // Step 5 : Start the real action
    jpeg_start_decompress(&decompInfo);

    //
    // Prepare for the final decompression
    //

    pCurScanBuf = pDIBPixel + 
                  (decompInfo.image_height - 1) * dwBytesPerScanLine;
    if (pProgressCB) {

        ulImageSize    = decompInfo.image_height * dwBytesPerScanLine;
        ulCBInterval   = decompInfo.image_height / 10;
        ulOffset       = 0;
        ulNewScanlines = 0;
    }

    // Step 6 : Acquire the scan line
    while (decompInfo.output_scanline < decompInfo.output_height) {

        jpeg_read_scanlines(&decompInfo, &pCurScanBuf, 1);

        // Famous swapping for the unique format of Windows
        pCurPixel = pCurScanBuf;
        for (i = 0; i < decompInfo.image_width; 
             i++, pCurPixel += decompInfo.num_components) {

            sampleTemp = *pCurPixel;
            *pCurPixel = *(pCurPixel + 2);
            *(pCurPixel + 2) = sampleTemp;
        }
        
        pCurScanBuf -= dwBytesPerScanLine;

        //
        // Fire the callback when possible and necessary
        //

        if (pProgressCB) {

            ulNewScanlines++;
            ulOffset += dwBytesPerScanLine;

            if ((ulNewScanlines == ulCBInterval) || 
                (decompInfo.output_scanline == decompInfo.output_height)) {

                bRet = pProgressCB(
                           ulImageSize, ulNewScanlines,
                           ulNewScanlines * dwBytesPerScanLine,
                           pDIBPixel, pCBContext);

                if (! bRet) {
                    break;
                }
            }
        }
    }

    // Step 7 : Finish the job
    jpeg_finish_decompress(&decompInfo);

    // Step 8 : Garbage collection
    jpeg_destroy_decompress(&decompInfo);

    if (bRet) {
        return(JPEGERR_NO_ERROR);
    } else {
        return(JPEGERR_CALLBACK_ERROR);
    }
}

/******************************************************************************\
*
* DecompTransferJPEG()
*
* Arguments:
*
*     ppDIBPixel - *ppDIBPixel will change between callback if multiple buffer is
*                  used, but dwBufSize is assumed to be constant.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/1999 Original Version
*
\******************************************************************************/

short __stdcall
DecompTransferJPEG(
    LPBYTE                         pJPEGBlob,
    DWORD                          dwSize,
    LPBYTE                        *ppDIBPixel,
    DWORD                          dwBufSize,
    DWORD                          dwBytesPerScanLine,
    JPEGCallbackProc               pProgressCB,
    PVOID                          pCBContext)
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    LPBYTE                         pCurScanLine;
    JSAMPLE                        sampleTemp;
    LPBYTE                         pCurPixel;
    DWORD                          i;
    //
    // Callback related variables
    //
    ULONG                          ulImageSize;
    ULONG                          ulOffset = 0;
    ULONG                          ulBufferLeft;
    BOOL                           bRet = FALSE;

    //
    // Parameter checking
    //

    if ((! ppDIBPixel) || (! *ppDIBPixel) || (! pProgressCB)) {
        return (JPEGERR_INTERNAL_ERROR);
    }

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK) {

        jpeg_destroy_decompress(&decompInfo);
        return(JPEGERR_INTERNAL_ERROR);
    }

    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion

    // Step 5 : Start the real action
    jpeg_start_decompress(&decompInfo);

    //
    // Prepare for the final decompression
    //

    ulImageSize  = decompInfo.image_height * dwBytesPerScanLine;
    ulBufferLeft = dwBufSize;
    pCurScanLine = *ppDIBPixel;

    // Step 6 : Acquire the scan line
    while (decompInfo.output_scanline < decompInfo.output_height) {

        jpeg_read_scanlines(&decompInfo, &pCurScanLine, 1);

        // Famous swapping for the unique format of Windows
        pCurPixel = pCurScanLine;
        for (i = 0; i < decompInfo.image_width;
             i++, pCurPixel += decompInfo.num_components) {

            sampleTemp = *pCurPixel;
            *pCurPixel = *(pCurPixel + 2);
            *(pCurPixel + 2) = sampleTemp;
        }

        pCurScanLine += dwBytesPerScanLine;
        ulBufferLeft -= dwBytesPerScanLine;

        //
        // Fire the callback when possible and necessary
        //

        if ((ulBufferLeft < dwBytesPerScanLine) ||
            (decompInfo.output_scanline == decompInfo.output_height)) {

            bRet = pProgressCB(
                       ulImageSize, 
                       ulOffset,
                       dwBufSize - ulBufferLeft,
                       *ppDIBPixel, pCBContext);

            if (! bRet) {
                break;
            }

            //
            // Reset the buffer, which may have been switched by the callback 
            //

            ulBufferLeft = dwBufSize;
            pCurScanLine = *ppDIBPixel;

            ulOffset = decompInfo.output_scanline * dwBytesPerScanLine;
        }
    }

    // Step 7 : Finish the job
    jpeg_finish_decompress(&decompInfo);

    // Step 8 : Garbage collection
    jpeg_destroy_decompress(&decompInfo);

    if (bRet) {
        return(JPEGERR_NO_ERROR);
    } else {
        return(JPEGERR_CALLBACK_ERROR);
    }
}

/******************************************************************************\
*
* DecompJPEG()
*
* Arguments:
*
* Assumption : The JPEG  is 24bits.
*              pDIBPixel is the pixel buffer of a DIB
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

SHORT __stdcall
DecompJPEG(
    LPBYTE                         pJPEGBlob, 
    DWORD                          dwSize,
    LPBYTE                         pDIBPixel, 
    DWORD                          dwBytesPerScanLine)
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    LPBYTE                         pCurScanBuf;
    JSAMPLE                        sampleTemp;
    LPBYTE                         pCurPixel;
    DWORD                          i;

    // Step 1 : Initialize JPEG session data-structure
    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);
    // Reserve the state of the current stack
    if (setjmp(jpegErrMgr.stackContext)) {

        // JPEG lib will longjump here when there is an error
        jpeg_destroy_decompress(&decompInfo);

        return(-1);
    }

    // Step 2 : Specify the source of the compressed data
    jpeg_buf_src(&decompInfo, pJPEGBlob, dwSize);

    // Step 3 : Read JPEG file header information
    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK) {

        jpeg_destroy_decompress(&decompInfo);
        return(-1);
    }

    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion

    // Step 5 : Start the real action
    jpeg_start_decompress(&decompInfo);

    pCurScanBuf = pDIBPixel +
                  (decompInfo.image_height - 1) * dwBytesPerScanLine;
    // Step 6 : Acquire the scan line
    while (decompInfo.output_scanline < decompInfo.output_height) {

        jpeg_read_scanlines(&decompInfo, &pCurScanBuf, 1);

        // Famous swapping for the unique format of Windows
        pCurPixel = pCurScanBuf;
        for (i = 0; i < decompInfo.image_width;
             i++, pCurPixel += decompInfo.num_components) {

            sampleTemp = *pCurPixel;
            *pCurPixel = *(pCurPixel + 2);
            *(pCurPixel + 2) = sampleTemp;
        }

        pCurScanBuf -= dwBytesPerScanLine;
    }

    // Step 7 : Finish the job
    jpeg_finish_decompress(&decompInfo);

    // Step 8 : Garbage collection
    jpeg_destroy_decompress(&decompInfo);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\defprop.h ===
//------------------------------------------------------------------------------
//  Copyright (c) 1999  Microsoft Corporation.
//
//  defprop.h
//
//     Property Declarations and definitions for the IrTran-P WIA USD.
//
//  Author:
//
//     EdwardR    12-Aug-1999
//
//------------------------------------------------------------------------------

#include  "tcamprop.h"

#define  NUM_CAP_ENTRIES         4
#define  NUM_EVENTS              3


#define PREFFERED_FORMAT_NOM        &WiaImgFmt_JPEG
#define FORMAT_NOM                  &WiaImgFmt_JPEG

#define NUM_CAM_ITEM_PROPS  (19)
#define NUM_CAM_DEV_PROPS   (17)

#ifdef __GLOBALPROPVARS__

PROPID gItemPropIDs[NUM_CAM_ITEM_PROPS] =
    {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPC_THUMBNAIL,
    WIA_IPA_ITEM_TIME,
    WIA_IPC_THUMB_WIDTH,
    WIA_IPC_THUMB_HEIGHT,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_COMPRESSION,
    WIA_IPA_CHANNELS_PER_PIXEL,
    WIA_IPA_BITS_PER_CHANNEL,
    WIA_IPA_PLANAR,
    WIA_IPA_BYTES_PER_LINE,
    WIA_IPA_ACCESS_RIGHTS,
    WIA_IPA_MIN_BUFFER_SIZE
    };

LPOLESTR gItemPropNames[NUM_CAM_ITEM_PROPS] =
    {
    WIA_IPA_DATATYPE_STR,
    WIA_IPA_DEPTH_STR,
    WIA_IPA_PIXELS_PER_LINE_STR,
    WIA_IPA_NUMBER_OF_LINES_STR,
    WIA_IPC_THUMBNAIL_STR,
    WIA_IPA_ITEM_TIME_STR,
    WIA_IPC_THUMB_WIDTH_STR,
    WIA_IPC_THUMB_HEIGHT_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_COMPRESSION_STR,
    WIA_IPA_CHANNELS_PER_PIXEL_STR,
    WIA_IPA_BITS_PER_CHANNEL_STR,
    WIA_IPA_PLANAR_STR,
    WIA_IPA_BYTES_PER_LINE_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
    WIA_IPA_MIN_BUFFER_SIZE_STR
    };

PROPID gItemCameraPropIDs[WIA_NUM_IPC] =
    {
    WIA_IPC_AUDIO_AVAILABLE,
    WIA_IPC_AUDIO_DATA
    };

LPOLESTR gItemCameraPropNames[WIA_NUM_IPC] =
    {
    WIA_IPC_AUDIO_AVAILABLE_STR,
    WIA_IPC_AUDIO_DATA_STR,
    };

PROPID gDevicePropIDs[NUM_CAM_DEV_PROPS] =
    {
    WIA_DPA_FIRMWARE_VERSION,
    WIA_DPA_CONNECT_STATUS,
    WIA_DPA_DEVICE_TIME,
    WIA_DPC_PICTURES_TAKEN,
    WIA_DPC_PICTURES_REMAINING,
    WIA_DPC_THUMB_WIDTH,
    WIA_DPC_THUMB_HEIGHT,
    WIA_DPC_PICT_WIDTH,
    WIA_DPC_PICT_HEIGHT,
    WIA_DPC_EXPOSURE_MODE,
    WIA_DPC_FLASH_MODE,
    WIA_DPC_FOCUS_MODE,
    WIA_DPC_ZOOM_POSITION,
    WIA_DPC_BATTERY_STATUS,
    WIA_DPC_TIMER_MODE,
    WIA_DPC_TIMER_VALUE,
    WIA_DPP_TCAM_ROOT_PATH
    };

LPOLESTR gDevicePropNames[NUM_CAM_DEV_PROPS] =
    {
    WIA_DPA_FIRMWARE_VERSION_STR,
    WIA_DPA_CONNECT_STATUS_STR,
    WIA_DPA_DEVICE_TIME_STR,
    WIA_DPC_PICTURES_TAKEN_STR,
    WIA_DPC_PICTURES_REMAINING_STR,
    WIA_DPC_THUMB_WIDTH_STR,
    WIA_DPC_THUMB_HEIGHT_STR,
    WIA_DPC_PICT_WIDTH_STR,
    WIA_DPC_PICT_HEIGHT_STR,
    WIA_DPC_EXPOSURE_MODE_STR,
    WIA_DPC_FLASH_MODE_STR,
    WIA_DPC_FOCUS_MODE_STR,
    WIA_DPC_ZOOM_POSITION_STR,
    WIA_DPC_BATTERY_STATUS_STR,
    WIA_DPC_TIMER_MODE_STR,
    WIA_DPC_TIMER_VALUE_STR,
    WIA_DPP_TCAM_ROOT_PATH_STR
    };

PROPSPEC gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS] =
    {
    {PRSPEC_PROPID, WIA_DPA_FIRMWARE_VERSION},
    {PRSPEC_PROPID, WIA_DPA_CONNECT_STATUS},
    {PRSPEC_PROPID, WIA_DPA_DEVICE_TIME},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_REMAINING},
    {PRSPEC_PROPID, WIA_DPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_EXPOSURE_MODE},
    {PRSPEC_PROPID, WIA_DPC_FLASH_MODE},
    {PRSPEC_PROPID, WIA_DPC_FOCUS_MODE},
    {PRSPEC_PROPID, WIA_DPC_ZOOM_POSITION},
    {PRSPEC_PROPID, WIA_DPC_BATTERY_STATUS},
    {PRSPEC_PROPID, WIA_DPC_TIMER_MODE},
    {PRSPEC_PROPID, WIA_DPC_TIMER_VALUE},
    {PRSPEC_PROPID, WIA_DPP_TCAM_ROOT_PATH}
    };

WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS] =
    {
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_FIRMWARE_VERSION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_CONNECT_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_DEVICE_TIME
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_TAKEN
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_REMAINING
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_EXPOSURE_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FLASH_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FOCUS_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_ZOOM_POSITION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_BATTERY_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_VALUE
    {WIA_PROP_RW   | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}  // WIA_DPP_ROOT_PATH
    };

PROPSPEC gPropSpecDefaults[NUM_CAM_ITEM_PROPS] =
    {
    {PRSPEC_PROPID, WIA_IPA_DATATYPE},
    {PRSPEC_PROPID, WIA_IPA_DEPTH},
    {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
    {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
    {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
    {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
    {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
    {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
    {PRSPEC_PROPID, WIA_IPA_FORMAT},
    {PRSPEC_PROPID, WIA_IPA_TYMED},
    {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
    {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
    {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL},
    {PRSPEC_PROPID, WIA_IPA_PLANAR},
    {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
    {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
    {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
    };

LONG  gPropVarDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_CAM_ITEM_PROPS)] =
    {
    // VARTYPE                 reserved    val               pad/array ptr
    (LONG)VT_I4,               0x00000000, WIA_DATA_GRAYSCALE,0x00000000,            // WIA_IPA_DATATYPE
    (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_DEPTH

    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_PIXELS_PER_LINE
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_NUMBER_OF_LINES

    (LONG)VT_VECTOR | VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMBNAIL
    (LONG)VT_VECTOR | VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_TIME
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_WIDTH
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_HEIGHT
    (LONG)VT_CLSID,            0x00000000, (LONG)PREFFERED_FORMAT_NOM,0x00000000,    // WIA_IPA_PREFERRED_FORMAT
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_SIZE
    (LONG)VT_CLSID,            0x00000000, (LONG)FORMAT_NOM,  0x00000000,            // WIA_IPA_FORMAT
    (LONG)VT_I4,               0x00000000, TYMED_CALLBACK,    0x00000000,            // WIA_IPA_TYMED
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_COMPRESSION
    (LONG)VT_I4,               0x00000000, 3,                 0x00000000,            // WIA_IPA_CHANNELS PER PIXEL
    (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_BITS PER CHANNEL
    (LONG)VT_I4,               0x00000000, WIA_PACKED_PIXEL,  0x00000000,            // WIA_IPA_PLANAR
    (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_WIDTH IN BYTES
    (LONG)VT_I4,               0x00000000, WIA_ITEM_RD,       0x00000000,             // WIA_IPA_ACCESS_RIGHTS

    (LONG)VT_I4,               0x00000000, 65535,             0x00000000,            // WIA_IPA_MIN_BUFFER_SIZE
    };


//
// Default device extended properties.
//

#define NUM_DATATYPE 3

LONG lDataTypes[NUM_DATATYPE] =
    {
    WIA_DATA_THRESHOLD,
    WIA_DATA_GRAYSCALE,
    WIA_DATA_COLOR
    };

#define NUM_DEPTH 3
LONG lDepths[NUM_DEPTH] =
    {
    1,
    8,
    24
    };

//
//  Different formats supported
//

#define NUM_FORMAT 2

GUID *pguidFormats[NUM_FORMAT] =
    {
    (GUID*) &WiaImgFmt_JPEG,
    (GUID*) &WiaImgFmt_JPEG
    };

GUID g_guidFormats[NUM_FORMAT];   // FormatID's specified in pguidFormats are copied to g_guidFormats
                                  // during SetFormatAttribs

//
//  This is an array of WIA_FORMAT_INFOs, describing the different formats
//  and their corresponding media types.  Initialized in wiadev.cpp
//

WIA_FORMAT_INFO* g_wfiTable = NULL;

//
//  Different media types supported
//
#define NUM_TYMED  2
LONG lTymeds [NUM_TYMED]=
    {
    TYMED_CALLBACK,
    TYMED_FILE
    };

//
// Extended information for each property
//

WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS] =
    {

    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DATATYPE, WIA_DATA_GRAYSCALE, (LONG) lDataTypes, 0}, // WIA_IPA_DATATYPE
    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DEPTH,    8,                  (LONG) lDepths,    0}, // WIA_IPA_DEPTH

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PIXELS_PER_LINE
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_NUMBER_OF_LINES
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMBNAIL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_TIME
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_PREFERRED_FORMAT, set later
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_SIZE

    {WIA_PROP_RW   | WIA_PROP_LIST, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_FORMAT, set later
    {WIA_PROP_RW   | WIA_PROP_LIST, VT_I4,    NUM_TYMED,    TYMED_CALLBACK, (LONG)lTymeds,     0}, // WIA_IPA_TYMED
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_COMPRESSION
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_CHANNELS
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BITS_PER_CHANNEL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PLANAR
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BYTES_PER_LINE
    {WIA_PROP_RW   | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ACCESS_RIGHTS

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_MIN_BUFFER_SIZE

    };

//
// Device capabilities.  Events are listed before commands to simplify the
// implementation of drvGetCapabilities(...)
//

#define  N   WIA_NOTIFICATION_EVENT
#define  A   WIA_ACTION_EVENT
#define  NA  (WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT)

WIA_DEV_CAP_DRV gCapabilities[NUM_CAP_ENTRIES] =
    {
    //
    // GUID                             ulFlags  wszName  wszDescription wszIcon
    //
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,    NA, NULL,    NULL, WIA_ICON_DEVICE_CONNECTED},
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED, N,  NULL,    NULL, WIA_ICON_DEVICE_DISCONNECTED},
    {(GUID *)&WIA_EVENT_ITEM_CREATED,        NA, NULL,    NULL, WIA_ICON_ITEM_CREATED},
    {(GUID *)&WIA_CMD_SYNCHRONIZE,           0,  NULL,    NULL, WIA_ICON_SYNCHRONIZE}
    };

//
// The device name and description strings are kept in the resource file. This
// table maps the IDS_ values (in the resource file for each of the
// gCapabilities[] array entries. gDefaultStrings[] are backup names in case
// we can't load the strings from the resource file (should never actually
// happen).
//

UINT gCapabilityIDS[NUM_CAP_ENTRIES] =
    {
    IDS_DEVICE_CONNECTED,
    IDS_DEVICE_DISCONNECTED,
    IDS_NEW_PICTURE_SENT,
    IDS_SYNCHRONIZE
    };

WCHAR *gDefaultStrings[NUM_CAP_ENTRIES] =
    {
    L"Device connected",
    L"Device disconnected",
    L"New picture sent",
    L"Synchronize"
    };


#else

extern PROPID             gItemPropIDs[NUM_CAM_ITEM_PROPS];
extern LPOLESTR           gItemPropNames[NUM_CAM_ITEM_PROPS];
extern PROPID             gItemCameraPropIDs[WIA_NUM_IPC];
extern LPOLESTR           gItemCameraPropNames[WIA_NUM_IPC];
extern PROPID             gDevicePropIDs[NUM_CAM_DEV_PROPS];
extern LPOLESTR           gDevicePropNames[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS];
extern WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gPropSpecDefaults[NUM_CAM_ITEM_PROPS];
extern LONG               gPropVarDefaults[];
extern WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS];
extern WIA_DEV_CAP_DRV    gCapabilities[NUM_CAP_ENTRIES];
extern UINT               gCapabilityIDS[NUM_CAP_ENTRIES];
extern WCHAR             *gDefaultStrings[NUM_CAP_ENTRIES];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\jpegutil.h ===
#include  <wtypes.h>

 
//
// JPEG erro code
//
 
#define JPEGERR_NO_ERROR         0
#define JPEGERR_INTERNAL_ERROR  -1
#define JPEGERR_CALLBACK_ERROR  -2

//
// Prototype for JPEG callback
//

typedef BOOL (__stdcall *JPEGCallbackProc)(
    ULONG,                  // Total byte to download
    ULONG,                  // Bytes downloaded so far
    ULONG,                  // Bytes newly downloaded
    PBYTE,                  // Buffer containing the image data
    PVOID);                 // User supplied context

//
// Prototype for JPEG utility functions
//

int GetJPEGDimensions(LPBYTE pJPEGBlob, DWORD dwSize,
                      LONG   *pWidth, LONG *pHeight, WORD *pChannel);

SHORT __stdcall
DecompProgressJPEG(
    PBYTE,                  // Buffer containing the JPEG data
    ULONG,                  // Size of the JPEG buffer
    PBYTE,                  // Buffer to receive DIB data
    ULONG,                  // Scanline picth
    JPEGCallbackProc,       // Progress callback
    PVOID);                 // User supplied callback context

SHORT __stdcall
DecompTransferJPEG(
    PBYTE,                  // Buffer containing the JPEG data
    ULONG,                  // Size of the JPEG buffer
    PBYTE *,                // POINTER to the buffer to receive DIB data
    DWORD,                  // Size of the DIB buffer
    ULONG,                  // Scanline picth
    JPEGCallbackProc,       // Progress callback
    PVOID);                 // User supplied callback context

SHORT __stdcall
DecompJPEG(
    LPBYTE,                 // Buffer containing the JPEG data
    DWORD,                  // Size of the JPEG buffer
    LPBYTE,                 // Buffer to receive DIB data
    DWORD);                 // Scanline picth
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\ircamera.h ===
//---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999, All rights reserved
//
//  ircamera.h
//
//  Microsoft Confidential
//  
//  Author:  EdwardR        22/July/99      Initial Coding.
//
//
//---------------------------------------------------------------------------

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"
#include "wiamindr.h"

//---------------------------------------------------------------------------
// Temp (cached) thumbnail file name extension:
//---------------------------------------------------------------------------

#define SZ_TMB    TEXT(".tmb")

//---------------------------------------------------------------------------
// Timeout for sending a reconnect signal to WIA. Currently set to three
// minutes (in milliseconds):
//---------------------------------------------------------------------------

#define RECONNECT_TIMEOUT    (3*60*1000)

//---------------------------------------------------------------------------
// GUID's
//---------------------------------------------------------------------------

#if defined( _WIN32 ) && !defined( _NO_COM)

//  {26d2e349-10ca-4cc2-881d-3e8025d9b6de}
DEFINE_GUID(CLSID_IrUsd, 0x26d2e349L, 0x10ca, 0x4cc2, 0x88, 0x1d, 0x3e, 0x80, 0x25, 0xd9, 0xb6, 0xde);

// {b62d000a-73b3-4c0c-9a4d-9eb4886d147c}
DEFINE_GUID(guidEventTimeChanged, 0xb62d000aL, 0x73b3, 0x4c0c, 0x9a, 0x4d, 0x9e, 0xb4, 0x88, 0x6d, 0x14, 0x7c);

// {d69b7fbd-9f21-4acf-96b7-86c2aca97ae1}
DEFINE_GUID(guidEventSizeChanged, 0xd69b7fbdL, 0x9f21, 0x4acf, 0x96, 0xb7, 0x86, 0xc2, 0xac, 0xa9, 0x7a, 0xe1);

// {ad89b522-0986-45eb-9ec3-803989197af8}
DEFINE_GUID(guidEventFirstLoaded, 0xad89b522L, 0x0986, 0x45eb, 0x9e, 0xc3, 0x80, 0x39, 0x89, 0x19, 0x7a, 0xf8);

#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//---------------------------------------------------------------------------
//
// Module ref counting
//
//---------------------------------------------------------------------------

extern UINT g_cRefThisDll;
extern UINT g_cLocks;

extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);

extern void DllAddRef(void);
extern void DllRelease(void);

typedef struct _IRCAM_IMAGE_CONTEXT
    {
	PTCHAR	pszCameraImagePath;
    } IRCAM_IMAGE_CONTEXT, *PIRCAM_IMAGE_CONTEXT;

typedef struct _CAMERA_PICTURE_INFO
    {
    LONG    PictNumber;
    LONG    ThumbWidth;
    LONG    ThumbHeight;
    LONG    PictWidth;
    LONG    PictHeight;
    LONG    PictCompSize;
    LONG    PictFormat;
    LONG    PictBitsPerPixel;
    LONG    PictBytesPerRow;
    SYSTEMTIME TimeStamp;
    } CAMERA_PICTURE_INFO, *PCAMERA_PICTURE_INFO;


typedef struct _CAMERA_STATUS
    {
    LONG    FirmwareVersion;
    LONG    NumPictTaken;
    LONG    NumPictRemaining;
    LONG    ThumbWidth;
    LONG    ThumbHeight;
    LONG    PictWidth;
    LONG    PictHeight;
    SYSTEMTIME CameraTime;
    } CAMERA_STATUS, *PCAMERA_STATUS;

#define ALLOC(s) LocalAlloc(0,s)
#define FREE(s)  LocalFree(s)


//---------------------------------------------------------------------------
//
// Base class for supporting non-delegating IUnknown for contained objects
//
//---------------------------------------------------------------------------

struct INonDelegatingUnknown
    {
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
    };


//---------------------------------------------------------------------------
//
// Class definition for object
//
//---------------------------------------------------------------------------

class IrUsdDevice : public IStiUSD,
                    public IWiaMiniDrv,
                    public INonDelegatingUnknown
{
private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.

public:
    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hIrTranPThread;       // IrTran-P camera protocol.

    HANDLE              m_hRegistryEvent;
    HANDLE              m_hEventMonitorThread;

    // WIA information, one time initialization.
    IStiDevice         *m_pStiDevice;           // Sti object.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback  *m_pIWiaEventCallback;   // WIA event sink.
    IWiaDrvItem        *m_pIDrvItemRoot;        // root item

    HANDLE              m_hSignalEvent;         // Signal event handle.
    HWND                m_hDlg;
    GUID                m_guidLastEvent;        // Last event ID.

    DWORD               m_dwLastConnectTime;    // msec since last connect.

    // *** IUnknown-like methods ***
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey)  ;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps)  ;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus)  ;
    STDMETHOD(DeviceReset)(THIS )  ;
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer)  ;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError)  ;
    STDMETHOD(LockDevice) (THIS )  ;
    STDMETHOD(UnLockDevice) (THIS )  ;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent)  ;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify)  ;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo);

    //
    // MiniDrv methods
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE         *pWiasContext, 
        LONG          lFlags,
        BSTR          bstrDeviceID,          
        BSTR          bstrRootFullItemName, 
        IUnknown     *pStiDevice,           
        IUnknown     *pIUnknownOuter,       
        IWiaDrvItem **ppIDrvItemRoot,       
        IUnknown    **ppIUnknownInner,
        LONG         *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_ 
        LONG          lFlags, 
        LONG          lDevErrVal, 
        LPOLESTR     *ppszDevErrStr, 
        LONG         *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_ 
        BYTE         *pWiasContext,
        LONG          lFlags,
        const GUID   *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG         *plErr);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE         *pWiasContext, 
        LONG          lFlags,
        PMINIDRV_TRANSFER_CONTEXT pDataContext, 
        LONG         *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_ 
        BYTE         *pWiasContext, 
        LONG          lFlags,
        LONG         *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_ 
        BYTE         *pWiasContext, 
        LONG          lFlags,
        ULONG         nPropSpec, 
        const PROPSPEC *pPropSpec, 
        LONG         *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_ 
        BYTE         *pWiasContext, 
        LONG          lFLags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG         *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_ 
        BYTE         *pWiaItem, 
        LONG          lFlags,
        ULONG         nPropSpec, 
        const PROPSPEC *pPropSpec, 
        LONG         *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal );

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE         *pWiasContext,
        LONG          lFlags,
        LONG         *plDevErrVal);

	 STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG          lFlags,
        BYTE         *pSpecContext,
        LONG         *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE         *pWiasContext,
        LONG          ulFlags,
        LONG         *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG         *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE         *pWiasContext,
        LONG          ulFlags,
        LONG         *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG         *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID   *pEventGUID,
        BSTR          bstrDeviceID,
        ULONG         ulReserved );

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);

    //
    // Public helper methods:
    //
    HRESULT CreateItemFromFileName(
        LONG            FolderType,
        PTCHAR          pszPath,
        PTCHAR          pszName,
        IWiaDrvItem   **ppNewFolder);

    IWiaDrvItem *GetDrvItemRoot(VOID);
    BOOL         IsInitialized(VOID);
    BOOL         IsValid(VOID);

private:
    //
    // Private helper methods:
    //
    HRESULT InitImageInformation(
        BYTE                  *,
        IRCAM_IMAGE_CONTEXT   *,
        LONG                  *);


    HRESULT EnumDiskImages(
        IWiaDrvItem  *pRootFile,
        TCHAR        *pwszPath );

    HRESULT CamLoadPicture(
        IRCAM_IMAGE_CONTEXT      *pCameraImage,
        MINIDRV_TRANSFER_CONTEXT *pDataTransCtx,
        LONG                     *plDevErrVal );

    HRESULT CamLoadPictureCB(
        IRCAM_IMAGE_CONTEXT      *pCameraImage,
        MINIDRV_TRANSFER_CONTEXT *pDataTransCtx,
        LONG                     *plDevErrVal );

    HRESULT CamGetPictureInfo(
        IRCAM_IMAGE_CONTEXT        *pCameraImage,
        CAMERA_PICTURE_INFO        *pPictureInfo );

    HRESULT CamLoadThumbnail( IN  IRCAM_IMAGE_CONTEXT *pIrCamContext, 
                              OUT BYTE               **ppThumbnail,
                              OUT LONG                *pThumbSize );

    HRESULT CamDeletePicture( IRCAM_IMAGE_CONTEXT *pIrCamContext );

    HRESULT CamBuildImageTree(CAMERA_STATUS *,IWiaDrvItem **);

    HRESULT CamOpenCamera(CAMERA_STATUS *);
    
    HRESULT BuildDeviceItemTree(LONG *plDevErrVal);
    HRESULT DeleteDeviceItemTree(LONG *plDevErrVal);
    HRESULT InitDeviceProperties(BYTE *, LONG *plDevErrVal);

    void    InitializeCapabilities();

public:
    DWORD   StartEventMonitorThread();
    DWORD   StartIrTranPThread();
    DWORD   StopIrTranPThread();

public:
    IrUsdDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~IrUsdDevice();
    
    VOID RunNotifications(VOID);
};

inline IWiaDrvItem *IrUsdDevice::GetDrvItemRoot(VOID)
    {
    return m_pIDrvItemRoot;
    }

inline BOOL IrUsdDevice::IsValid(VOID)
    {
    return m_fValid;
    }

inline BOOL IrUsdDevice::IsInitialized(VOID)
    {
    return (m_bstrRootFullItemName != NULL);
    }

typedef IrUsdDevice *PIrUsdDevice;


HRESULT SetItemSize(BYTE*);

//
// Syncronization mechanisms
//
#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);


// Device constants:
const LEN_INQUIRE_BUTTON = 8;
const BYTE INQUIRE_BUTTON[LEN_INQUIRE_BUTTON + 1] = "INQUIREB";

const LEN_INQUIRE_BUTTON_READ = 10;

const LEN_CLEAR_BUTTON = 5;
const BYTE CLEAR_BUTTON[LEN_CLEAR_BUTTON + 1] = "CLRBT";

const LEN_CURRENT_ERROR = 7;
const BYTE CURRENT_ERROR[LEN_CURRENT_ERROR + 1] = "CURERR";

const LEN_DIAGS = 5;
const BYTE TURN_ON_LAMP[LEN_DIAGS + 1] = "LAMPO";
const BYTE TURN_OFF_LAMP[LEN_DIAGS + 1] = "LAMPF";
const BYTE SELF_TEST[LEN_DIAGS + 1] = "SELFT";
const BYTE STATUS_STRING[LEN_DIAGS + 1] = "STATS";


BOOL
_stdcall CameraEventDlgProc(
   HWND     hDlg,
   unsigned message,
   DWORD    wParam,
   LONG     lParam );

typedef struct _CAM_EVENT
    {
    PTCHAR       pszEvent;
    const GUID  *pguid;
    } CAM_EVENT,*PCAM_EVENT;


//
// Useful helper functions:
//

extern int LoadStringResource( IN  HINSTANCE hInst,
                        IN  UINT      uID,
                        OUT WCHAR    *pwszBuff,
                        IN  int       iBuffMax );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\miniitem.cpp ===
//----------------------------------------------------------------------------
// Copyright (c) 1998, 1999  Microsoft Corporation.
//
//
//  miniitem.cpp
//
//  Implementation of the WIA IrTran-P camera item methods.
//
//  Author:  MarkE    30-Aug-98   Original TestCam version.
//
//           EdwardR  11-Aug-99   Rewritten for IrTran-P devices.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "ircamera.h"

#include "defprop.h"

extern HINSTANCE g_hInst;    // Global DLL hInstance

//----------------------------------------------------------------------------
//  ValidateDataTransferContext()
//
//    Validate the data transfer context. This is a helper function, called
//    by IrUsdDevice::drvAcquireItemData().
//
//  Parameters:
//
//    pDataTransferContext --
//
//  Return:
//
//    HRESULT    S_OK
//               E_INVALIDARG
//----------------------------------------------------------------------------
HRESULT ValidateDataTransferContext(
                IN MINIDRV_TRANSFER_CONTEXT *pDataTransferContext )
   {
   //
   // Check the context size:
   //
   if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT))
       {
       WIAS_ERROR((g_hInst,"ValidateDataTransferContext(): invalid data transfer context size"));
       return E_INVALIDARG;;
       }

   //
   // For tymed file or hglobal, only WiaImgFmt_JPEG is allowed:
   //
   if (  (pDataTransferContext->tymed == TYMED_FILE)
      || (pDataTransferContext->tymed == TYMED_HGLOBAL))
       {
       if (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG)
           {
           WIAS_ERROR((g_hInst,"ValidateDataTransferContext(): invalid format for TYMED_FILE"));
           return E_INVALIDARG;;
           }

       }

   //
   // For tymed CALLBACK, only WiaImgFmt_JPEG is allowed:
   //
   if (pDataTransferContext->tymed == TYMED_CALLBACK)
       {
       if (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG)
           {
           WIAS_ERROR((g_hInst,"ValidateDataTransferContext(): Invalid format for TYMED_CALLBACK"));
           return E_INVALIDARG;;
           }

       //
       // The callback is always double buffered, non-callback case
       // (TYMED_FILE) never is:
       //
       if (pDataTransferContext->pTransferBuffer == NULL)
           {
           WIAS_ERROR((g_hInst, "ValidateDataTransferContext(): Null transfer buffer"));
           return E_INVALIDARG;
           }
       }

   return S_OK;
}


//----------------------------------------------------------------------------
// SendBitmapHeader()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT   S_OK
//
//----------------------------------------------------------------------------
HRESULT SendBitmapHeader(
                  IN IWiaDrvItem              *pDrvItem,
                  IN MINIDRV_TRANSFER_CONTEXT *pTranCtx )
    {
    HRESULT hr;

    WIAS_ASSERT(g_hInst, pDrvItem != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx->tymed == TYMED_CALLBACK);

    //
    // driver is sending TOPDOWN data, must swap biHeight
    //
    // this routine assumes pTranCtx->pHeader points to a
    // BITMAPINFO header (TYMED_FILE doesn't use this path
    // and DIB is the only format supported now)
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pTranCtx->pTransferBuffer;

    if (pTranCtx->guidFormatID == WiaImgFmt_BMP)
        {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
        }

    hr = pTranCtx->
            pIWiaMiniDrvCallBack->
                MiniDrvCallback(
                    IT_MSG_DATA,
                    IT_STATUS_TRANSFER_TO_CLIENT,
                    0,
                    0,
                    pTranCtx->lHeaderSize,
                    pTranCtx,
                    0 );

    if (hr == S_OK)
        {
        //
        // advance offset for destination copy
        //
        pTranCtx->cbOffset += pTranCtx->lHeaderSize;
        }

    return hr;
}

//----------------------------------------------------------------------------
// IrUsdDevice::drvDeleteItem()
//
//   Try to delete a device item.
//
//   BUGBUG: Not yet implemented.
//
// Arguments:
//
//   pWiasContext - The context of the item to delete
//   lFlags       - unused
//   plDevErrVal  - unused
//
// Return Value:
//
//    HRESULT  - STG_E_ACCESSDENIED
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvDeleteItem(
                                 IN  BYTE *pWiasContext,
                                 IN  LONG  lFlags,
                                 OUT LONG *plDevErrVal )
    {
    HRESULT      hr = S_OK;
    IWiaDrvItem *pDrvItem = 0;
    IRCAM_IMAGE_CONTEXT *pContext = 0;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvDeleteItem()"));

    *plDevErrVal = 0;

    hr = wiasGetDrvItem( pWiasContext, &pDrvItem );
    if (FAILED(hr))
        {
        return hr;
        }

    hr = pDrvItem->GetDeviceSpecContext( (BYTE**)&pContext );
    if (FAILED(hr))
        {
        return hr;
        }

    hr = CamDeletePicture( pContext );

    return hr;
    }

//----------------------------------------------------------------------------
// IrUsdDevice::drvAcquireItemData()
//
//   Scan data into buffer. This routine scans the entire contents into
//   the destination buffer in one call. Status will be sent back if
//   the callback routine is provided
//
// Arguments:
//
//   pWiasContext    - Identifies what item we are working with.
//   lFlags          - unused
//   pTranCtx        - Buffer and callback information
//   plDevErrVal     - Return error value
//
// Return Value:
//
//   HRESULT   - S_OK
//               E_POINTER
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvAcquireItemData(
                                 IN  BYTE                     *pWiasContext,
                                 IN  LONG                      lFlags,
                                 IN  MINIDRV_TRANSFER_CONTEXT *pTranCtx,
                                 OUT LONG                     *plDevErrVal)
    {
    HRESULT  hr;

    *plDevErrVal = 0;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvAcquireItemData()"));

    //
    // Get a pointer to the associated driver item.
    //
    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

    if (FAILED(hr))
        {
        return hr;
        }

    //
    // Validate the data transfer context.
    //
    hr = ValidateDataTransferContext(pTranCtx);

    if (FAILED(hr))
        {
        return hr;
        }

    //
    // Get item specific driver data:
    //
    IRCAM_IMAGE_CONTEXT  *pMCamContext;

    pDrvItem->GetDeviceSpecContext((BYTE **)&pMCamContext);

    if (!pMCamContext)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::drvAcquireItemData(): NULL item context"));
        return E_POINTER;
        }

    //
    // Use WIA services to fetch format specific info.
    //
    hr = wiasGetImageInformation(pWiasContext,
                                 0,
                                 pTranCtx);

    if (hr != S_OK)
        {
        return hr;
        }

    //
    // Determine if this is a callback or buffered transfer
    //
    if (pTranCtx->tymed == TYMED_CALLBACK) {

        //
        // For formats that have a data header, send it to the client
        //

        if (pTranCtx->lHeaderSize > 0)
            {
            hr = SendBitmapHeader(
                     pDrvItem,
                     pTranCtx);
            }

        if (hr == S_OK)
            {
            hr = CamLoadPictureCB(
                     pMCamContext,
                     pTranCtx,
                     plDevErrVal);
            }
        }
    else
        {

        //
        // Offset past the header in the buffer and get the picture data:
        //
        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

        hr = CamLoadPicture(
                 pMCamContext,
                 pTranCtx,
                 plDevErrVal);

        }

    return hr;
    }

//----------------------------------------------------------------------------
// IrUsdDevice::drvInitItemProperties()
//
//   Initialize the device item properties.
//
// Arguments:
//
//   pWiasContext - Pointer to WIA item context.
//   lFLags       - unused
//   plDevErrVal  - pointer to hardware error value.
//
//
// Return Value:
//
//    HRESULT - S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvInitItemProperties(
                                 IN  BYTE *pWiasContext,
                                 IN  LONG  lFlags,
                                 OUT LONG *plDevErrVal )
    {
    HRESULT     hr;
    LONG        lItemType;
    IRCAM_IMAGE_CONTEXT *pContext;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvInitItemProperties()"));

    //
    // NOTE: This device doesn't touch hardware to initialize the
    // device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //
    if (!pWiasContext)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): invalid input pointers"));
        return E_INVALIDARG;
        }

    //
    // Get a pointer to the associated driver item:
    //
    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem( pWiasContext, &pDrvItem );

    if (FAILED(hr))
        {
        return hr;
        }

    //
    // The root item has the all the device properties
    //
    hr = pDrvItem->GetItemFlags(&lItemType);

    if (FAILED(hr))
        {
        return hr;
        }

    if (lItemType & WiaItemTypeRoot)
        {
        //
        // Root item property initialization finishes here:
        //
        return InitDeviceProperties( pWiasContext, plDevErrVal);
        }

    //
    // If this is a file, init the properties
    //
    if (lItemType & WiaItemTypeFile)
        {
        //
        // Add the item property names:
        //
        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_CAM_ITEM_PROPS,
                                  gItemPropIDs,
                                  gItemPropNames);

        if (FAILED(hr))
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): wiasSetItemPropNames() failed"));
            return hr;
            }

        //
        // Use WIA services to set default item properties:
        //
        hr = wiasWriteMultiple( pWiasContext,
                                NUM_CAM_ITEM_PROPS,
                                gPropSpecDefaults,
                                (PROPVARIANT*)gPropVarDefaults);

        if (FAILED(hr))
            {
            return hr;
            }

        hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        if (FAILED(hr))
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): GetDeviceSpecContext failed"));
            return hr;
            }

        hr = InitImageInformation(pWiasContext,
                                  pContext,
                                  plDevErrVal);

        if (FAILED(hr))
            {
            WIAS_ERROR((g_hInst,"IrUsdDevice::drvInitItemProperties(): InitImageInformation() failed"));
            return hr;
            }
        }

    return S_OK;
}

//----------------------------------------------------------------------------
// IrUsdDevice::drvValidateItemProperties()
//
//   Validate the device item properties.
//
// Arguments:
//
//   pWiasContext    - wia item context
//   lFlags          - unused
//   nPropSpec       -
//   pPropSpec       -
//   plDevErrVal     - device error value
//
// Return Value:
//
//   HRESULT
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvValidateItemProperties(
                                 BYTE           *pWiasContext,
                                 LONG            lFlags,
                                 ULONG           nPropSpec,
                                 const PROPSPEC *pPropSpec,
                                 LONG           *plDevErrVal )
    {
    //
    // This device doesn't touch hardware to validate the device item properties
    //
    *plDevErrVal = 0;

    //
    // Parameter validation.
    //
    if (!pWiasContext || !pPropSpec)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::drvValidateItemProperties(): Invalid input pointers"));
        return E_POINTER;
        }

    //
    // validate size
    //
    HRESULT hr = S_OK;

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr))
        {
        return hr;
        }

    LONG lItemType;

    hr = pDrvItem->GetItemFlags(&lItemType);

    if (hr == S_OK)
        {
        if (lItemType & WiaItemTypeFile)
            {
            //
            // calc item size
            //

            hr = SetItemSize(pWiasContext);

            //
            //  Change MinBufferSize property.  Need to get Tymed and
            //  ItemSize first, since MinBufferSize in dependant on these
            //  properties.
            //

            LONG        lTymed;
            LONG        lItemSize;
            LONG        lMinBufSize = 0;
            HRESULT     hr = S_OK;

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_TYMED, &lTymed, NULL, TRUE);
            if (FAILED(hr))
                {
                WIAS_ERROR((g_hInst,"drvValidateItemProperties, could not read TYMED property"));
                return hr;
                }

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_ITEM_SIZE, &lItemSize, NULL, TRUE);
            if (SUCCEEDED(hr))
                {
                //
                //  Update the MinBufferSize property.
                //

                switch (lTymed)
                    {
                    case TYMED_CALLBACK:
                        lMinBufSize = 65535;
                        break;

                    default:
                        lMinBufSize = lItemSize;
                    }

                if (lMinBufSize)
                    {
                    hr = wiasWritePropLong(pWiasContext, WIA_IPA_MIN_BUFFER_SIZE, lMinBufSize);
                    if (FAILED(hr))
                        {
                        WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not write value for WIA_IPA_MIN_BUFFER_SIZE"));
                        }
                    }
                }
            else
                {
                WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not read value for ItemSize"));
                }

            }
        else if (lItemType & WiaItemTypeRoot)
            {
            //
            // Find out whether the Root Path property is changed
            //
#if FALSE
            for (ULONG i = 0; i < nPropSpec; i++)
                {

                if (((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                          (pPropSpec[i].propid == WIA_DPP_TCAM_ROOT_PATH)) ||
                    ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) &&
                          (wcscmp(pPropSpec[i].lpwstr, WIA_DPP_TCAM_ROOT_PATH_STR) == 0)))
                    {
                    BSTR   bstrRootPath;

                    //
                    // Retrieve the new value for Root Path property
                    //

                    hr = wiasReadPropStr(
                             pWiasContext,
                             WIA_DPP_TCAM_ROOT_PATH,
                             &bstrRootPath,
                             NULL,
                             TRUE);
                    if (FAILED(hr))
                        {
                        return hr;
                        }

#ifdef UNICODE
                    wcscpy(gpszPath, bstrRootPath);
#else
                    wcstombs(gpszPath, bstrRootPath, MAX_PATH);
#endif
                    //
                    // Release the Root Path bstr
                    //

                    SysFreeString(bstrRootPath);

                    //
                    // Rebuild the item tree and send event notification
                    //

                    hr = DeleteDeviceItemTree(plDevErrVal);
                    if (FAILED(hr))
                        {
                        break;
                        }

                    hr = BuildDeviceItemTree(plDevErrVal);
                    if (FAILED(hr))
                        {
                        break;
                        }

                    m_guidLastEvent = WIA_EVENT_DEVICE_CONNECTED;
                    SetEvent(m_hSignalEvent);

                    break;
                    }
                }
#endif
            }
        }

    return hr;
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.
*
* Arguments:
*
*   pWiasContext    - the corresponding wia item context
*   pmdtc           - pointer to mini driver context
*   pFlags          - unused
*   plDevErrVal     - the device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvWriteItemProperties(
    BYTE                       *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                       *plDevErrVal)
{
    //
    // Assume no device hardware errors.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if ((! pWiasContext) || (! pmdtc)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    HRESULT hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    IRCAM_IMAGE_CONTEXT *pItemContext;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, NULL item context"));
        return E_POINTER;
    }

    //
    // Write the device item properties to the hardware here.
    //

    return hr;
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvReadItemProperties
*
*   Read the device item properties from the hardware.
*
* Arguments:
*
*   pWiasContext    - wia item context
*   lFlags          - unused
*   nPropSpec       -
*   pPropSpec       -
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvReadItemProperties(
    BYTE            *pWiasContext,
    LONG                lFlags,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec,
    LONG                *plDevErrVal)
{
    // For most scanner devices, item properties are stored in the driver
    // and written out at acquire image time. Some devices support properties
    // which should be updated on every property read. This can be done here.


    *plDevErrVal = 0;

    return S_OK;
}


//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused,
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT IrUsdDevice::drvLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(100);
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT IrUsdDevice::drvUnLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvAnalyzeItem
*
*   The test camera does not support imag analysis.
*
* Arguments:
*
*   pWiasContext    - Pointer to the device item context to be analyzed.
*   lFlags          - Operation flags.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvAnalyzeItem(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *plDevErrVal)
{
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
/**************************************************************************\
* IrUsdDevice::drvFreeDrvItemContext
*
*   The test scanner does not support imag analysis.
*
* Arguments:
*
*   lFlags          - unused
*   pSpecContext    - Pointer to item specific context.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/
//----------------------------------------------------------------------------

HRESULT _stdcall IrUsdDevice::drvFreeDrvItemContext(
                                 LONG   lFlags,
                                 BYTE  *pSpecContext,
                                 LONG  *plDevErrVal )
    {
    IRCAM_IMAGE_CONTEXT *pContext = (IRCAM_IMAGE_CONTEXT*)pSpecContext;

    if (pContext != NULL)
        {
        if (pContext->pszCameraImagePath != NULL)
            {
            free(pContext->pszCameraImagePath);
            pContext->pszCameraImagePath = NULL;
            }
        }

    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\progress.cpp ===
//--------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  progress.cpp
//
//  IR ProgressBar object.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <shlobj.h>
#include <malloc.h>
#include "ircamera.h"
#include "progress.h"


//--------------------------------------------------------------------------
// CIrProgress::CIrProgress()
//
//--------------------------------------------------------------------------
CIrProgress::CIrProgress() :
                 m_hInstance(NULL),
                 m_pPD(NULL)
    {
    }

//--------------------------------------------------------------------------
// CIrProgress::~CIrProgress()
//
//--------------------------------------------------------------------------
CIrProgress::~CIrProgress()
    {
    if (m_pPD)
        {
        m_pPD->Release();
        m_pPD = NULL;
        }
    }

//--------------------------------------------------------------------------
// CIrProgress::Initialize()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::Initialize( IN HINSTANCE hInstance,
                                 IN DWORD     dwIdrAnimationAvi )
    {
    HRESULT hr;
    CHAR    szStr[MAX_PATH];
    WCHAR   wszStr[MAX_PATH];


    if (!hInstance)
         {
         return E_INVALIDARG;
         }

    m_hInstance = hInstance;

    //
    // Create a shell progress object to do the work for us.
    //
    hr = CoCreateInstance( CLSID_ProgressDialog,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IProgressDialog,
                           (void**)&m_pPD );
    if (FAILED(hr))
        {
        return hr;
        }

    //
    // Get the title string and place it on the progress dialog:
    //
    if (::LoadStringResource(m_hInstance,
                           IDS_PROGRESS_TITLE,
                           wszStr,
                           MAX_PATH ))
        {
        hr = m_pPD->SetTitle(wszStr);
        }
    else
        {
        // Couldn't load string, default title...
        hr = m_pPD->SetTitle(L"Image Transfer Progress");
        }

    //
    // Setup the file transfer animation
    //
    hr = m_pPD->SetAnimation( m_hInstance, dwIdrAnimationAvi );
    if (FAILED(hr))
        {
        goto error;
        }

    //
    // Setup the cancel string (displayed when the cancel button
    // is pressed.
    //
    if (::LoadStringResource(m_hInstance,
                           IDS_CANCEL_MSG,
                           wszStr,
                           MAX_PATH ))
        {
        hr = m_pPD->SetCancelMsg( wszStr, NULL );
        }
    else
        {
        // Couldn't load string, use default cancel message...
        hr = m_pPD->SetCancelMsg( L"Cleaning up...", NULL );
        }

    return hr;

error:
    m_pPD->Release();
    m_pPD = NULL;
    m_hInstance = NULL;
    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::SetText()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::SetText( IN TCHAR *pText )
    {
    HRESULT hr = S_OK;

    if (m_pPD)
        {
        #ifdef UNICODE

        hr = m_pPD->SetLine( 1, pText, FALSE, NULL );

        #else

        WCHAR wszText[MAX_PATH];

        if (!MultiByteToWideChar( CP_ACP,
                                  0,
                                  pText,
                                  1+strlen(pText),
                                  wszText,
                                  MAX_PATH) )
            {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            return hr;
            }

        hr = m_pPD->SetLine( 1, wszText, FALSE, NULL );

        #endif
        }

    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::StartProgressDialog()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::StartProgressDialog()
    {
    HRESULT  hr = S_OK;

    if (m_pPD)
        {
        DWORD dwFlags = PROGDLG_NORMAL|PROGDLG_AUTOTIME|PROGDLG_NOMINIMIZE;

        HRESULT hr = m_pPD->StartProgressDialog( NULL, // hwndParent
                                                 NULL, 
                                                 dwFlags,
                                                 NULL  );
        }

    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::UpdateProgressDialog()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::UpdateProgressDialog( IN DWORD dwCompleted,
                                           IN DWORD dwTotal )
    {
    HRESULT hr = S_OK;

    if (m_pPD)
        {
        hr = m_pPD->SetProgress( dwCompleted, dwTotal );
        }

    return hr;
    }

//--------------------------------------------------------------------------
// CIrProgress::HasUserCancelled()
//
//--------------------------------------------------------------------------
BOOL CIrProgress::HasUserCancelled()
    {
    if (m_pPD)
        {
        return m_pPD->HasUserCancelled();
        }
    else
        {
        return S_OK;
        }
    }

//--------------------------------------------------------------------------
// CIrProgress::EndProgressDialog()
//
//--------------------------------------------------------------------------
HRESULT CIrProgress::EndProgressDialog()
    {
    HRESULT hr = S_OK;

    if (m_pPD)
        {
        hr = m_pPD->StopProgressDialog();
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\progress.h ===
//--------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  progress.h
//
//  IR ProgressBar object. Use the shell progress indicator for progress
//  during image transfer from the camera.
//
//--------------------------------------------------------------------------


#include "resource.h"


class CIrProgress
{
public:
    CIrProgress(VOID);
    ~CIrProgress(VOID);

    HRESULT Initialize( IN HINSTANCE hInstance,
                        IN DWORD     dwIdrAnimationAvi );

    HRESULT SetText( IN TCHAR *pText );

    HRESULT StartProgressDialog(VOID);

    HRESULT UpdateProgressDialog( IN DWORD dwCompleted,
                                  IN DWORD dwTotal );

    BOOL    HasUserCancelled(VOID);

    HRESULT EndProgressDialog(VOID);
                      

private:

    HINSTANCE        m_hInstance;
    IProgressDialog *m_pPD;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\tcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TCamProp.H
*
*  VERSION:     1.0
*
*  AUTHOR:      IndyZ
*
*  DATE:        16 May, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for test camera's private properties.
*
*******************************************************************************/

#ifndef __TCAMPROP_H__
#define __TCAMPROP_H__

#include  <guiddef.h>

//
// Path where test camera builds its item tree, BSTR & RW
//

#define  WIA_DPP_TCAM_ROOT_PATH         WIA_PRIVATE_DEVPROP
#define  WIA_DPP_TCAM_ROOT_PATH_STR     L"Test Camera Root Path"

//
// Private event after the Root Path is changed
//

const GUID WIA_EVENT_NAME_CHANGE =
{ /* 88f80f75-af08-11d2-a094-00c04f72dc3c */
    0x88f80f75,
    0xaf08,
    0x11d2,
    {0xa0, 0x94, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\version.h ===
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "IrTran-P Windows Image Acquisition USD"
#define VER_INTERNALNAME_STR            "ircamera"
#define VER_LEGALCOPYRIGHT_YEARS        "1999"
#define VER_ORIGINALFILENAME_STR        "ircamera.dll"

#include <ntverp.h>
#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\wiadev.cpp ===
//------------------------------------------------------------------------------
//  (C) COPYRIGHT MICROSOFT CORP., 1998
//
//  wiadev.cpp
//
//  Implementation of device methods for the IrTran-P USD mini driver.
//
//  Author
//     EdwardR     05-Aug-99    Initial code.
//     Modeled after code written by ReedB.
//
//------------------------------------------------------------------------------

#define __FORMATS_AND_MEDIA_TYPES__

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "ircamera.h"
#include "defprop.h"
#include "resource.h"
#include <irthread.h>
#include <malloc.h>

extern HINSTANCE        g_hInst;     // Global hInstance
extern WIA_FORMAT_INFO *g_wfiTable;

//----------------------------------------------------------------------------
// IrUsdDevice::InitializWia()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT  S_OK
//
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvInitializeWia(
                                 BYTE         *pWiasContext,
                                 LONG          lFlags,
                                 BSTR          bstrDeviceID,
                                 BSTR          bstrRootFullItemName,
                                 IUnknown     *pStiDevice,
                                 IUnknown     *pIUnknownOuter,
                                 IWiaDrvItem **ppIDrvItemRoot,
                                 IUnknown    **ppIUnknownInner,
                                 LONG         *plDevErrVal )
    {
    HRESULT              hr;
    LONG                 lDevErrVal;

    WIAS_TRACE((g_hInst,"IrUsdDevice::drvInitializeWia(): Device ID: %ws", bstrDeviceID));

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;
    *plDevErrVal = 0;

    //
    // Initialize names and STI pointer?
    //
    if (m_pStiDevice == NULL)
        {
        //
        // save STI device inteface for locking:
        //
        m_pStiDevice = (IStiDevice*)pStiDevice;

        //
        // Cache the device ID:
        //
        m_bstrDeviceID = SysAllocString(bstrDeviceID);
        if (! m_bstrDeviceID)
            {
            return E_OUTOFMEMORY;
            }

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (! m_bstrRootFullItemName)
            {
            return E_OUTOFMEMORY;
            }
        }

    //
    // Build the device item tree
    //
    hr = drvDeviceCommand( NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal );

    if (SUCCEEDED(hr))
        {
        *ppIDrvItemRoot = m_pIDrvItemRoot;
        }

    return hr;
    }


//----------------------------------------------------------------------------
// IrUsdDevice::drvUnInitializeWia
//
//   Gets called when a client connection is going away.
//
// Arguments:
//
//   pWiasContext    - Pointer to the WIA Root item context of the client's
//                     item tree.
//
// Return Value:
//    Status
//
// History:
//
//   30/12/1999 Original Version
//----------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


//----------------------------------------------------------------------------
//
//   Mini Driver Device Services
//
//----------------------------------------------------------------------------



/**************************************************************************\
* drvGetDeviceErrorStr
*
*     Map a device error value to a string.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall IrUsdDevice::drvGetDeviceErrorStr(
    LONG        lFlags,
    LONG        lDevErrVal,
    LPOLESTR    *ppszDevErrStr,
    LONG        *plDevErr)
{
    *plDevErr = 0;
    if (!ppszDevErrStr) {
        WIAS_ERROR((g_hInst,"drvGetDeviceErrorStr, NULL ppszDevErrStr"));
        return E_POINTER;
    }

    // Map device errors to a string to be placed in the event log.
    switch (lDevErrVal) {

        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            return E_FAIL;
    }
    return S_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::DeleteDeviceItemTree()
//
//   Recursive device item tree delete routine. Deletes the whole tree.
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::DeleteDeviceItemTree( OUT LONG *plDevErrVal )
    {
    HRESULT hr;

    //
    // does tree exist
    //
    if (m_pIDrvItemRoot == NULL)
        {
        return S_OK;
        }

    //
    // Unlink and release the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    m_pIDrvItemRoot = NULL;

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::BuildDeviceItemTree()
//
//   The device uses the IWiaDrvServices methods to build up a tree of
//   device items. The test scanner supports only a single scanning item so
//   build a device item tree with one entry.
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::BuildDeviceItemTree( OUT LONG  *plDevErrVal )
    {
    HRESULT hr = S_OK;

    //
    // Note: This device doesn't touch hardware to build the tree.
    //

    if (plDevErrVal)
        {
        *plDevErrVal = 0;
        }

    //
    // Rebuild the new device item tree (of JPEG images):
    //
    CAMERA_STATUS camStatus;

    if (!m_pIDrvItemRoot)
        {
        hr = CamBuildImageTree( &camStatus, &m_pIDrvItemRoot );
        }

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::InitDeviceProperties()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT  -- S_OK
//                E_POINTER
//                E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT IrUsdDevice::InitDeviceProperties(
                         BYTE  *pWiasContext,
                         LONG  *plDevErrVal )
    {
    int         i;
    HRESULT     hr;
    BSTR        bstrFirmwreVer;
    SYSTEMTIME  camTime;
    PROPVARIANT propVar;

    //
    // This device doesn't actually touch any hardware to initialize
    // the device properties.
    //
    if (plDevErrVal)
        {
        *plDevErrVal = 0;
        }

    //
    // Parameter validation.
    //
    if (!pWiasContext)
        {
        WIAS_ERROR((g_hInst,"IrUsdDevice::InitDeviceProperties(): NULL WIAS context"));
        return E_POINTER;
        }

    //
    // Write standard property names
    //
    hr = wiasSetItemPropNames(pWiasContext,
                              sizeof(gDevicePropIDs)/sizeof(PROPID),
                              gDevicePropIDs,
                              gDevicePropNames);
    if (FAILED(hr))
        {
        WIAS_TRACE((g_hInst,"IrUsdDevice::InitDeviceProperties(): WritePropertyNames() failed: 0x%x",hr));
        return hr;
        }

    //
    // Write the properties supported by all WIA devices
    //
    bstrFirmwreVer = SysAllocString(L"02161999");
    if (bstrFirmwreVer)
        {
        wiasWritePropStr( pWiasContext,
                          WIA_DPA_FIRMWARE_VERSION,
                          bstrFirmwreVer );
        SysFreeString(bstrFirmwreVer);
        }

    wiasWritePropLong( pWiasContext, WIA_DPA_CONNECT_STATUS, 1);

    wiasWritePropLong( pWiasContext, WIA_DPC_PICTURES_TAKEN, 0);

    GetSystemTime(&camTime);
    wiasWritePropBin( pWiasContext,
                      WIA_DPA_DEVICE_TIME,
                      sizeof(SYSTEMTIME),
                      (PBYTE)&camTime );

    //
    // Write the camera properties, just default values, it may vary with items
    //

    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICTURES_REMAINING, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_WIDTH, 80);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_HEIGHT, 60);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_WIDTH, 1024);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_HEIGHT, 768);

    // Give WIA_DPC_EXPOSURE_MODE to WIA_DPC_TIMER_VALUE some default.

    wiasWritePropLong(
        pWiasContext, WIA_DPC_EXPOSURE_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FLASH_MODE, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FOCUS_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_ZOOM_POSITION, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_BATTERY_STATUS, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_VALUE, 0);

    //
    // Write the WIA_DPP_TCAM_ROOT_PATH property
    //

    BSTR    bstrRootPath;
    CHAR   *pszPath = ::GetImageDirectory();   // Don't try to free...
    WCHAR   wszPath[MAX_PATH];

    if (!pszPath)
        {
        return E_OUTOFMEMORY;
        }

    mbstowcs( wszPath, pszPath, strlen(pszPath) );

    bstrRootPath = SysAllocString(wszPath);

    if (! bstrRootPath)
        {
        return E_OUTOFMEMORY;
        }

    wiasWritePropStr(pWiasContext, WIA_DPP_TCAM_ROOT_PATH, bstrRootPath);

    //
    // Use WIA services to set the property access and
    // valid value information from gDevPropInfoDefaults.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_DEV_PROPS,
                                 gDevicePropSpecDefaults,
                                 gDevPropInfoDefaults);
    return S_OK;
}

//--------------------------------------------------------------------------
// IrUsdDevice::drvDeviceCommand()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT   S_OK
//              E_NOTIMPL
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvDeviceCommand(
                                 BYTE         *pWiasContext,
                                 LONG          lFlags,
                                 const GUID   *plCommand,
                                 IWiaDrvItem **ppWiaDrvItem,
                                 LONG         *plErr)
    {
    HRESULT hr;

    //
    // init return value
    //
    if (ppWiaDrvItem != NULL)
        {
        *ppWiaDrvItem = NULL;
        }

    //
    // dispatch command
    //
    if (*plCommand == WIA_CMD_SYNCHRONIZE)
        {
        WIAS_TRACE((g_hInst,"IrUsdDevice::drvDeviceCommand(): WIA_CMD_SYNCHRONIZE"));

        hr = drvLockWiaDevice(pWiasContext, lFlags, plErr);
        if (FAILED(hr))
            {
            return (hr);
            }

        //
        // SYNCHRONIZE - make sure tree is up to date with device
        //
        // The dirver's responsibility is to make sure the tree is accurate.
        //

        hr = BuildDeviceItemTree(plErr);

        drvUnLockWiaDevice( pWiasContext, lFlags, plErr );
        }
    else
        {
        WIAS_TRACE((g_hInst,"drvDeviceCommand: Unsupported command"));

        hr = E_NOTIMPL;
        }

    return hr;
}

//--------------------------------------------------------------------------
// LoadStringResource()
//
//
//--------------------------------------------------------------------------
int LoadStringResource( IN  HINSTANCE hInst,
                        IN  UINT      uID,
                        OUT WCHAR    *pwszBuff,
                        IN  int       iBuffMax )
    {
    #ifdef UNICODE
    return LoadString(hInst,uID,pwszBuff,iBuffMax);
    #else
    CHAR *pszBuff = (CHAR*)_alloca(sizeof(CHAR)*iBuffMax);

    int  iCount = LoadString(hInst,uID,pszBuff,iBuffMax);

    if (iCount > 0)
        {
        MultiByteToWideChar( CP_ACP, 0, pszBuff, -1, pwszBuff, iBuffMax );
        }

    return iCount;

    #endif
    }

//--------------------------------------------------------------------------
// IrUsdDevice::InitializeCapabilities()
//
// This helper function is called by IrUsdDevice::drvGetCapabilities() to
// make sure that the string resources are setup in the gCapabilities[]
// array before it is passed back to WIA.
//
//--------------------------------------------------------------------------
void IrUsdDevice::InitializeCapabilities()
    {
    int    i;
    UINT   uIDS;
    WCHAR *pwszName;
    WCHAR *pwszDescription;
#   define MAX_IDS_WSTR      64

    //
    // If we have entries already, then this function was already called
    // and  we can just return:
    //
    if (gCapabilities[0].wszName)
        {
        return;
        }

    for (i=0; i<NUM_CAP_ENTRIES; i++)
        {
        //
        // Get the string table string ID for this entry:
        //
        uIDS = gCapabilityIDS[i];

        //
        // Get the name string for this entry fron the resource file:
        //
        pwszName = new WCHAR [MAX_IDS_WSTR];
        if (  (pwszName)
           && (LoadStringResource(g_hInst,uIDS,pwszName,MAX_IDS_WSTR)))
            {
            gCapabilities[i].wszName = pwszName;
            }
        else
            {
            gCapabilities[i].wszName = gDefaultStrings[i];
            }

        //
        // Get the Discription string for this entry from the resource file:
        //
        pwszDescription = new WCHAR [MAX_IDS_WSTR];
        if (  (pwszDescription)
           && (LoadStringResource(g_hInst,uIDS,pwszDescription,MAX_IDS_WSTR)))
            {
            gCapabilities[i].wszDescription = pwszDescription;
            }
        else
            {
            gCapabilities[i].wszDescription = gDefaultStrings[i];
            }
        }
    }

//--------------------------------------------------------------------------
// IrUsdDevice::drvGetCapabilities()
//
//
//
// Arguments:
//
//
//
// Return Value:
//
//    HRESULT   -- S_OK
//              -- E_INVALIDARG
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvGetCapabilities(
                                 BYTE             *pWiasContext,
                                 LONG              ulFlags,
                                 LONG             *pCelt,
                                 WIA_DEV_CAP_DRV **ppCapabilities,
                                 LONG             *plDevErrVal )
    {
    HRESULT  hr = S_OK;

    *plDevErrVal = 0;

    //
    // Make sure the device capabilities array is setup
    //
    InitializeCapabilities();

    //
    // Return Commmand and/or Events depending on flags:
    //
    switch (ulFlags)
        {
        case WIA_DEVICE_COMMANDS:
            //
            //  Only asked for commands:
            //
            *pCelt = NUM_CAP_ENTRIES - NUM_EVENTS;
            *ppCapabilities = &gCapabilities[NUM_EVENTS];
            break;

        case WIA_DEVICE_EVENTS:
            //
            //  Return only events:
            //
            *pCelt = NUM_EVENTS;
            *ppCapabilities = gCapabilities;
            break;

        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):
            //
            //  Return both events and commands:
            //
            *pCelt = NUM_CAP_ENTRIES;
            *ppCapabilities = gCapabilities;
            break;

        default:
            //
            // Flags is invalid
            //
            WIAS_ERROR((g_hInst, "drvGetCapabilities, flags was invalid"));
            hr = E_INVALIDARG;
        }

    return hr;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::drvGetFormatEtc()
//
//     Return an array of the supported formats and mediatypes.
//
// Arguments:
//
//     pWiasConext -
//     ulFlags     -
//     plNumFE     - Number of returned formats.
//     ppFE        - Pointer to array of FORMATETC for supported formats
//                   and mediatypes.
//     plDevErrVal - Return error number.
//
// Return Value:
//
//     HRESULT  - S_OK
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvGetWiaFormatInfo(
                                 IN  BYTE       *pWiasContext,
                                 IN  LONG        ulFlags,
                                 OUT LONG       *plNumWFI,
                                 OUT WIA_FORMAT_INFO **ppWFI,
                                 OUT LONG       *plDevErrVal)
    {
    #define NUM_WIA_FORMAT_INFO  2

    WIAS_TRACE((g_hInst, "IrUsdDevice::drvGetWiaFormatInfo()"));

    //
    // If necessary, setup the g_wfiTable.
    //
    if (!g_wfiTable)
        {
        g_wfiTable = (WIA_FORMAT_INFO*) CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * NUM_WIA_FORMAT_INFO);
        if (!g_wfiTable)
            {
            WIAS_ERROR((g_hInst, "drvGetWiaFormatInfo(): out of memory"));
            return E_OUTOFMEMORY;
            }

        //
        // Set the format/tymed pairs:
        //
        g_wfiTable[0].guidFormatID = WiaImgFmt_JPEG;
        g_wfiTable[0].lTymed = TYMED_CALLBACK;
        g_wfiTable[1].guidFormatID = WiaImgFmt_JPEG;
        g_wfiTable[1].lTymed = TYMED_FILE;
        }

    *plNumWFI = NUM_WIA_FORMAT_INFO;
    *ppWFI = g_wfiTable;
    *plDevErrVal = 0;

    return S_OK;
    }

//--------------------------------------------------------------------------
// IrUsdDevice::drvNotifyPnpEvent()
//
// Notify PnP event received by device manager.
//
//--------------------------------------------------------------------------
HRESULT _stdcall IrUsdDevice::drvNotifyPnpEvent(
                                 IN const GUID *pEventGUID,
                                 IN BSTR        bstrDeviceID,
                                 IN ULONG       ulReserved )
    {
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\resource.h ===
//--------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  resource.h
//
//  Resource constants for testing shell progress bar, this is the IR
//  animation.
//
//--------------------------------------------------------------------------

#define IDD_EVENT_DLG                   101
#define IDD_GEN_EVENT                   1000

#define IDC_COMBO1                      1001
#define IDC_EDIT1                       1002
#define IDC_STATIC                      -1

#define IDS_PROGRESS_TITLE              2001
#define IDS_CANCEL_MSG                  2002
#define IDS_DEVICE_CONNECTED            2003
#define IDS_DEVICE_DISCONNECTED         2004
#define IDS_NEW_PICTURE_SENT            2005
#define IDS_SYNCHRONIZE                 2006

#define IDR_TRANSFER_AVI                7001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\bftp.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// bftp.cpp
//
// Author
//
//   Edward Reus (EdwardR)  02-26-98   Initial Coding.
//
//--------------------------------------------------------------------

#include "precomp.h"
#include <stdlib.h>

extern HINSTANCE  g_hInst;   // Instance of ircamera.dll

static BFTP_ATTRIBUTE_MAP_ENTRY Attributes[] = {
    //Attr   Name    Type
    { FIL0, "FIL0",  ATTR_TYPE_CHAR },   // ASCII 8.3 File Name.
    { LFL0, "LFL0",  ATTR_TYPE_CHAR },   // SJIS or ISO8859-1 Long File Name.
    { TIM0, "TIM0",  ATTR_TYPE_TIME },   // File create/modify time.
    { TYP0, "TYP0",  ATTR_TYPE_BINARY }, // File or Thumbnail Information.
    { TMB0, "TMB0",  ATTR_TYPE_BINARY }, // The scaled down image.
    { BDY0, "BDY0",  ATTR_TYPE_BINARY }, // (?).
    { CMD0, "CMD0",  ATTR_TYPE_BINARY }, // Command Name (?).
    { WHT0, "WHT0",  ATTR_TYPE_CHAR },   // Category Data.
    { ERR0, "ERR0",  ATTR_TYPE_BINARY }, // Error code.
    { RPL0, "RPL0",  ATTR_TYPE_CHAR },   // Result: Stored File Name.
    { INVALID_ATTR,  0,      0 }
    };

//
// This is the bFTP for an RIMG query by the camera:
//
#define BFTP_RIMG_ATTR_VALUE_SIZE         14
#define BFTP_RIMG_RESP_SIZE               12 + BFTP_RIMG_ATTR_VALUE_SIZE

static UCHAR BftpRimgRespAttrValue[BFTP_RIMG_ATTR_VALUE_SIZE] =
    {
    0x00, 0xff, 0xff,                   // Pixel aspect ratio (any).
    0x02, 0x01, 0xff, 0xff, 0xff, 0xff, // Accept image size (any).
    0x05, 0xff, 0xff, 0xff, 0xff        // Accept file size (any).
    };

//
// This is the bFTP for an RINF query by the camera:
//
#define BFTP_RINF_ATTR_VALUE_SIZE          3
#define BFTP_RINF_RESP_SIZE               12 + BFTP_RINF_ATTR_VALUE_SIZE

static UCHAR BftpRinfRespAttrValue[BFTP_RINF_ATTR_VALUE_SIZE] =
    {
    0x10, 0xff, 0xff                    // Memory available (lots).
    };

//
// This is the bFTP for an RCMD query by the camera:
//
#define BFTP_RCMD_ATTR_VALUE_SIZE          5
#define BFTP_RCMD_RESP_SIZE               12 + BFTP_RCMD_ATTR_VALUE_SIZE

static UCHAR BftpRcmdRespAttrValue[BFTP_RCMD_ATTR_VALUE_SIZE] =
    {
    0x20, 0x00, 0xff, 0x00, 0x01        // Accept up to 255 puts/connect.
    };

//
// Map bFTP error codes:
static DWORD dwBftpErrorCodeMap[][2] =
    {
    { ERROR_PUT_UNDEFINED_ERROR,    ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_ILLEGAL_DATA,       ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_UNSUPPORTED_PID,    ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_ILLEGAL_ATTRIBUTE,  ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_UNSUPPORTED_CMD,    ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_FILE_SYSTEM_FULL,   ERROR_IRTRANP_DISK_FULL },
    { ERROR_PUT_NO_FILE_OR_DIR,     ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_LOW_BATTERY,        ERROR_BFTP_INVALID_PROTOCOL },
    { ERROR_PUT_ABORT_EXECUTION,    ERROR_SCEP_ABORT },
    { ERROR_PUT_NO_ERROR,           NO_ERROR }
    };

//--------------------------------------------------------------------
//  CharToValue()
//
//  Used in parsing the bFTP date string. In this case the maximum
//  value to parse is the year (YYYY).
//--------------------------------------------------------------------
static WORD CharToValue( IN UCHAR *pValue,
                         IN DWORD  dwLength )
    {
    #define MAX_VALUE_STR_LEN    4
    WORD    wValue = 0;
    CHAR    szTemp[MAX_VALUE_STR_LEN];

    if (dwLength < MAX_VALUE_STR_LEN)
        {
        memcpy(szTemp,pValue,dwLength);
        szTemp[dwLength] = 0;
        wValue =  (WORD)atoi(szTemp);
        }

    return wValue;
    }

//--------------------------------------------------------------------
// MapBftpErrorCode()
//
//--------------------------------------------------------------------
DWORD  MapBftpErrorCode( IN DWORD dwBftpErrorCode )
    {
    DWORD  dwErrorCode = NO_ERROR;
    DWORD  dwNumCodes = sizeof(dwBftpErrorCodeMap)/(2*sizeof(DWORD));

    for (DWORD i=0; i<dwNumCodes; i++)
        {
        if (dwBftpErrorCode == dwBftpErrorCodeMap[i][0])
            {
            dwErrorCode = dwBftpErrorCodeMap[i][1];
            break;
            }
        }

    return dwErrorCode;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseBftpAttributeName()
//
//--------------------------------------------------------------------
BFTP_ATTRIBUTE *CSCEP_CONNECTION::ParseBftpAttributeName(
                                     IN BFTP_ATTRIBUTE *pAttr,
                                     IN OUT DWORD      *pdwSize,
                                     OUT    DWORD      *pdwWhichAttr )
    {
    BFTP_ATTRIBUTE_MAP_ENTRY *pAttrMapEntry = Attributes;

    *pdwWhichAttr = INVALID_ATTR;

    while (pAttrMapEntry->pName)
       {
       if (Match4(pAttr->Name,pAttrMapEntry->pName))
           {
           *pdwWhichAttr = pAttrMapEntry->dwWhichAttr;

           break;
           }

       pAttrMapEntry++;
       }

    // Note: that the Length paramter is 8 bytes in from the start
    // of pAttr, hence the extra 8 (bytes) below:
    *pdwSize = *pdwSize - 8UL - pAttr->Length;
    pAttr = (BFTP_ATTRIBUTE*)( 8UL + pAttr->Length + (UCHAR*)pAttr );

    return pAttr;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::SaveBftpCreateDate()
//
// The bFTP create date/time is a character array of the form:
// YYYYMMDDHHMMSS (not zero terminated).
//
// If it was specifed then we want to use it as the create date
// of the picture file that we save the JPEG to.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::SaveBftpCreateDate( IN UCHAR  *pDate,
                                            IN DWORD   dwDateLength )
    {
    DWORD  dwStatus = NO_ERROR;
    SYSTEMTIME     SystemTime;
    FILETIME       LocalTime;
    FILETIME       FileTime;

    memset(&SystemTime,0,sizeof(SystemTime));

    if (dwDateLength == BFTP_DATE_TIME_SIZE)
        {
        //
        // Note that system time is in UTC, we will need to convert
        // this to local time...
        //
        SystemTime.wYear = CharToValue( pDate, 4 );
        SystemTime.wMonth = CharToValue( &(pDate[4]), 2 );
        SystemTime.wDay = CharToValue( &(pDate[6]), 2 );
        SystemTime.wHour = CharToValue( &(pDate[8]), 2 );
        SystemTime.wMinute = CharToValue( &(pDate[10]), 2 );
        SystemTime.wSecond = CharToValue( &(pDate[12]), 2 );

        if (SystemTimeToFileTime(&SystemTime,&LocalTime))
            {
            //
            // Before we use the time zone, we need to convert it to
            // UTC (its currently in "local time". Note that:
            //
            if (LocalFileTimeToFileTime(&LocalTime,&FileTime))
                {
                m_CreateTime = FileTime;
                }
            else
                {
                WIAS_ERROR((g_hInst,"IrTranP: SaveBftpCreateDate(): LocalFileTimeToFileTime() Failed: %d",GetLastError()));
                }
            }
        else
            {
            dwStatus = GetLastError();
            WIAS_ERROR((g_hInst,"IrTranP: SaveBftpCreateDate(): SystemTimeToFileTime(): Failed: %d", dwStatus));
            dwStatus = NO_ERROR;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseBftp()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseBftp( IN  UCHAR  *pBftpData,
                                   IN  DWORD   dwBftpDataSize,
                                   IN  BOOL    fSaveAsUPF,
                                   OUT DWORD  *pdwBftpOp,
                                   OUT UCHAR **ppPutData,
                                   OUT DWORD  *pdwPutDataSize )
    {
    DWORD   i;
    DWORD   dwStatus = NO_ERROR;
    DWORD   dwAttrSize;
    DWORD   dwWhichAttr;
    DWORD   dwLength;
    DWORD   dwSaveLength;
    USHORT  usNumAttr;
    char   *pszTemp;
    BFTP_ATTRIBUTE *pAttr;
    BFTP_ATTRIBUTE *pNextAttr;

    *pdwBftpOp = 0;
    *ppPutData = 0;
    *pdwPutDataSize = 0;

    #ifdef LITTLE_ENDIAN
    usNumAttr = ByteSwapShort( *((USHORT*)pBftpData) );
    #endif

    pAttr = (BFTP_ATTRIBUTE*)(pBftpData + sizeof(USHORT));
    dwAttrSize = dwBftpDataSize - sizeof(USHORT);

    for (i=0; i<usNumAttr; i++)
        {
        #ifdef LITTLE_ENDIAN
        pAttr->Length = ByteSwapLong( pAttr->Length );
        #endif

        pNextAttr = ParseBftpAttributeName( pAttr,
                                            &dwAttrSize,
                                            &dwWhichAttr );

        if (dwWhichAttr == INVALID_ATTR)
            {
            return ERROR_BFTP_INVALID_PROTOCOL;
            }

        if (dwWhichAttr == CMD0)
            {
            if (pAttr->Length == 2+sizeof(DWORD))
                {
                #ifdef LITTLE_ENDIAN
                *((DWORD*)(pAttr->Value)) = ByteSwapLong( *((DWORD*)(pAttr->Value)) );
                #endif
                }

            // Expect Value == 0x00010040 for a Query "WHT0" Request.
            //        Value == 0x00000000 for a Put Request.
            if ( *((DWORD*)(pAttr->Value)) == 0x00010040 )
                {
                *pdwBftpOp = BFTP_QUERY_RIMG;
                }
            else if ( *((DWORD*)(pAttr->Value)) == 0 )
                {
                *pdwBftpOp = BFTP_PUT;
                }
            else
                {
                *pdwBftpOp = BFTP_UNKNOWN;
                }
            }
        else if (dwWhichAttr == WHT0)
            {
            if (Match4("RIMG",pAttr->Value))
                {
                dwWhichAttr = RIMG;
                *pdwBftpOp = BFTP_QUERY_RIMG;
                }
            else if (Match4("RINF",pAttr->Value))
                {
                dwWhichAttr = RINF;
                *pdwBftpOp = BFTP_QUERY_RINF;
                }
            else if (Match4("RCMD",pAttr->Value))
                {
                dwWhichAttr = RCMD;
                *pdwBftpOp = BFTP_QUERY_RCMD;
                }
            else
                {
                dwWhichAttr = INVALID_ATTR;
                *pdwBftpOp = BFTP_UNKNOWN;
                return ERROR_BFTP_INVALID_PROTOCOL;
                }
            }
        //
        // Short (8.3) file name:
        //
        else if (dwWhichAttr == FIL0)
            {
            // Note: That the specification limits the file
            //       name to 8.3...
            dwLength = BftpValueLength(pAttr->Length);
            if (dwLength > FILE_NAME_SIZE)
                {
                dwLength = FILE_NAME_SIZE;
                }

            if (m_pszFileName)
                {
                FreeMemory(m_pszFileName);
                }

            m_pszFileName = (CHAR*)AllocateMemory(1+dwLength);
            if (!m_pszFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            memcpy(m_pszFileName,pAttr->Value,dwLength);
            m_pszFileName[dwLength] = 0;

            //
            // Create the name that the file will actually be saved as:
            //
            if (m_pszSaveFileName)
                {
                FreeMemory(m_pszSaveFileName);
                }

            dwSaveLength = sizeof(CHAR)*(1+dwLength) + sizeof(SZ_JPEG);
            m_pszSaveFileName = (CHAR*)AllocateMemory(dwSaveLength);
            if (!m_pszSaveFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            strcpy(m_pszSaveFileName,m_pszFileName);

            // File name is currently XXXXXX.UPF. Change to
            // XXXXXX.JPG or XXXXXX.UPF as appropriate:
            CHAR *psz = strrchr(m_pszSaveFileName,PERIOD);
            if (psz)
                {
                *psz = 0;  // Remove old suffix.
                }

            if (fSaveAsUPF)
                {
                strcat(m_pszSaveFileName,SZ_UPF);    // UPF file.
                }
            else
                {
                strcat(m_pszSaveFileName,SZ_JPEG);   // JPG file.
                }
            }
        //
        // UPF body: headers + thumbnail + jpeg image ...
        //
        else if (dwWhichAttr == BDY0)
            {
            // This is a PUT.
            ASSERT(*pdwBftpOp == BFTP_PUT);
            *ppPutData = pAttr->Value;
            *pdwPutDataSize = dwBftpDataSize - (DWORD)(pAttr->Value - pBftpData);
            }
        //
        // Long file name:
        //
        else if (dwWhichAttr == LFL0)
            {
            if (m_pszLongFileName)
                {
                FreeMemory(m_pszLongFileName);
                }

            dwLength = BftpValueLength(pAttr->Length);
            m_pszLongFileName = (CHAR*)AllocateMemory(1+dwLength);
            if (!m_pszLongFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            memcpy(m_pszLongFileName,pAttr->Value,dwLength);
            m_pszLongFileName[dwLength] = 0;

            CHAR *pszLongFileName = strrchr(m_pszLongFileName,'\\');
            if (pszLongFileName)
                {
                pszLongFileName++;  // Skip over the file separator...
                }
            else
                {
                pszLongFileName = m_pszLongFileName;
                }

            dwLength = strlen(pszLongFileName);

            if (m_pszSaveFileName)
                {
                FreeMemory(m_pszSaveFileName);
                }

            dwSaveLength = sizeof(CHAR)*(1+dwLength) + sizeof(SZ_JPEG);
            m_pszSaveFileName = (CHAR*)AllocateMemory(dwSaveLength);
            if (!m_pszSaveFileName)
                {
                return ERROR_OUTOFMEMORY;
                }

            // File name is now XXXXXX.JPG. Change to
            // XXXXXX.JPEG or XXXXXX.UPF as appropriate:
            CHAR *psz = strrchr(m_pszSaveFileName,PERIOD);
            if (psz)
                {
                *psz = 0;
                }

            if (fSaveAsUPF)
                {
                strcat(m_pszSaveFileName,SZ_UPF);
                }
            else
                {
                strcat(m_pszSaveFileName,SZ_JPEG);
                }

            #ifdef DBG_IO
            WIAS_TRACE((g_hInst,"CSCEP_CONNECTION::ParseBftp(): File: %s", m_pszSaveFileName));
            #endif
            }
        //
        // Create Date/Time:
        //
        else if (dwWhichAttr == TIM0)
            {
            dwLength = BftpValueLength(pAttr->Length);

            SaveBftpCreateDate(pAttr->Value,dwLength);

            #ifdef DBG_DATE
            pszTemp = (char*)AllocateMemory(1+dwLength);
            if (pszTemp)
                {
                memcpy(pszTemp,pAttr->Value,dwLength);
                pszTemp[dwLength] = 0;
                FreeMemory(pszTemp);
                }
            #endif
            }
        //
        // Camera sent back a bFTP error code:
        //
        else if (dwWhichAttr == ERR0)
            {
            *pdwBftpOp = BFTP_ERROR;

            *ppPutData = pAttr->Value;
            *pdwPutDataSize = BftpValueLength(pAttr->Length);

            dwStatus = ByteSwapShort( *((USHORT*)(pAttr->Value)) );
            }

        // BUGBUG: May need to byte swap other attributes as well when
        // the protocol is extended...

        pAttr = pNextAttr;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseUpfHeaders()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseUpfHeaders( IN  UCHAR  *pPutData,
                                         IN  DWORD   dwPutDataSize,
                                         OUT DWORD  *pdwJpegOffset,
                                         OUT DWORD  *pdwJpegSize )
    {
    DWORD   dwStatus = NO_ERROR;
    DWORD   dwStartAddress;
    DWORD   dwDataSize;
    INT     iGmtOffset = 0;
    WORD    wYear;
    WORD    wMonth;
    WORD    wDay;
    SYSTEMTIME  SystemTime;
    FILETIME    LocalTime;
    FILETIME    FileTime;
    UPF_HEADER *pUpfHeader;
    UPF_ENTRY  *pUpfEntry1;
    UPF_ENTRY  *pUpfEntry2;
    PICTURE_INFORMATION_DATA *pThumbnailInfo = 0;
    PICTURE_INFORMATION_DATA *pPictureInfo = 0;

    ASSERT(dwPutDataSize >= UPF_TOTAL_HEADER_SIZE);

    if (!pPutData)
        {
        *pdwJpegOffset = 0;
        *pdwJpegSize = 0;
        return ERROR_BFTP_INVALID_PROTOCOL;
        }

    pUpfHeader = (UPF_HEADER*)pPutData;

    pUpfEntry1 = (UPF_ENTRY*)(UPF_HEADER_SIZE + (UCHAR*)pUpfHeader);
    pUpfEntry2 = (UPF_ENTRY*)(UPF_ENTRY_SIZE + (UCHAR*)pUpfEntry1);

    dwStartAddress = ByteSwapLong(pUpfEntry2->dwStartAddress);

    dwDataSize = ByteSwapLong(pUpfEntry2->dwDataSize);

    #ifdef DBG_PROPERTIES
    WIAS_TRACE((g_hInst,"CSCEP_CONNECTION::ParseUpfHeaders(): NumTables: %d", pUpfHeader->NumTables));

    pPictureInfo = (PICTURE_INFORMATION_DATA*)pUpfEntry2->InformationData;

    WIAS_TRACE((g_hInst,"CSCEP_CONNECTION::ParseUpfHeaders(): Rotation: %d", pPictureInfo->RotationSet));
    #endif

    *pdwJpegOffset = UPF_HEADER_SIZE + 4*UPF_ENTRY_SIZE + dwStartAddress;
    *pdwJpegSize = dwDataSize;

    #ifdef UPF_FILES
    *pdwJpegOffset = 0;
    *pdwJpegSize = 0;
    #endif

    // Ok, now parse the picture creation date/time, if one is
    // defined.
    //
    // Note that the date/time is local time, with a GMT offset.
    // Since we will use local system time conversions, we will
    // not need the GMT offset.
    if (pUpfHeader->CreateDate[UPF_GMT_OFFSET] != 0x80)
        {
        iGmtOffset = (pUpfHeader->CreateDate[UPF_GMT_OFFSET])/4;
        }

    memcpy(&wYear,&(pUpfHeader->CreateDate[UPF_YEAR]),sizeof(SHORT) );
    wYear = ByteSwapShort(wYear);

    wMonth = pUpfHeader->CreateDate[UPF_MONTH];
    wDay = pUpfHeader->CreateDate[UPF_DAY];

    // At least the Year/Month/Day must be specified, else we
    // won't use the date. If the Hour/Minute/Second are known,
    // then we will use them as well.
    if ((wYear != 0xffff) && (wMonth != 0xff) && (wDay != 0xff))
        {
        memset(&SystemTime,0,sizeof(SystemTime));
        SystemTime.wYear = wYear;
        SystemTime.wMonth = wMonth;
        SystemTime.wDay = wDay;
        if (pUpfHeader->CreateDate[UPF_HOUR] != 0xff)
            {
            SystemTime.wHour = pUpfHeader->CreateDate[UPF_HOUR];

            if (pUpfHeader->CreateDate[UPF_MINUTE] != 0xff)
                {
                SystemTime.wMinute = pUpfHeader->CreateDate[UPF_MINUTE];

                if (pUpfHeader->CreateDate[UPF_SECOND] != 0xff)
                    {
                    SystemTime.wSecond = pUpfHeader->CreateDate[UPF_SECOND];
                    }
                }
            }


        if (SystemTimeToFileTime(&SystemTime,&LocalTime))
            {
            // 
            // Before we save the date/time, we need to convert it to
            // UTC (its currently in "local time". Note that:
            //
            if (LocalFileTimeToFileTime(&LocalTime,&FileTime))
                { 
                m_CreateTime = FileTime;
                }
            else
                {
                WIAS_ERROR((g_hInst,"IrTranP: SaveBftpCreateDate(): LocalFileTimeToFileTime() Failed: %d",GetLastError()));
                }
            }
        else
            {
            dwStatus = GetLastError();
            WIAS_ERROR((g_hInst,"IrTranP: ParseUpfHeaders(): Invalid Picture Create Date/Time. Status: %d", dwStatus));
            dwStatus = NO_ERROR;
            }
        }
    else
        {
        WIAS_TRACE((g_hInst,"IrTranP: ParseUpfHeaders(): No Picture Create Date/Time."));
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildBftpWht0RinfPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildBftpWht0RinfPdu(
                             OUT SCEP_HEADER          **ppPdu,
                             OUT DWORD                 *pdwPduSize,
                             OUT SCEP_REQ_HEADER_LONG **ppCommand,
                             OUT COMMAND_HEADER       **ppCommandHeader )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_HEADER          *pHeader;
    SCEP_REQ_HEADER_LONG *pCommand;
    COMMAND_HEADER       *pCommandHeader;
    UCHAR                *pUserData;
    USHORT               *pwNumAttributes;
    BFTP_ATTRIBUTE       *pAttrib;

    *ppPdu = 0;
    *pdwPduSize = 0;
    *ppCommand = 0;
    *ppCommandHeader = 0;

    pHeader = NewPdu();  // Size is MAX_PDU_SIZE by default...
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    // This is the total size of the PDU that we will construct:
    DWORD  dwPduSize = sizeof(SCEP_HEADER)
                     + sizeof(SCEP_REQ_HEADER_LONG)
                     + sizeof(USHORT)        // Num Attributes
                     + sizeof(BFTP_ATTRIBUTE)
                     + sizeof(DWORD)
                     + sizeof(BFTP_ATTRIBUTE)
                     + WHT0_ATTRIB_SIZE;

    // Length2 is the total size of the PDU minus the offset+size
    // of Length2:
    USHORT wLength2 = (USHORT)dwPduSize - 6;

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pCommand = (SCEP_REQ_HEADER_LONG*)(pHeader->Rest);
    pCommand->InfType = INF_TYPE_USER_DATA;
    pCommand->Length1 = USE_LENGTH2;           // 0xff
    pCommand->Length2 = wLength2;
    pCommand->InfVersion = INF_VERSION;
    pCommand->DFlag = DFLAG_SINGLE_PDU;
    pCommand->Length3 = pCommand->Length2 - 4; //

    pCommandHeader = (COMMAND_HEADER*)(pCommand->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_REQUEST;
    pCommandHeader->Length4 = pCommand->Length2 - 10;
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    memcpy( pCommandHeader->DestMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pCommandHeader->SrcMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    #ifdef LITTLE_ENDIAN
    pCommand->Length2 = ByteSwapShort(pCommand->Length2);
    pCommand->Length3 = ByteSwapShort(pCommand->Length3);
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    // Setup the bFTP:
    pUserData = pCommand->UserData;
    pwNumAttributes = (USHORT*)pUserData;

    *pwNumAttributes = 2;     // Two bFTP attributes.
    #ifdef LITTLE_ENDIAN
    *pwNumAttributes = ByteSwapShort(*pwNumAttributes);
    #endif
    pUserData += sizeof(*pwNumAttributes);

    // First attribute is CMD0:
    DWORD  dwCmd0AttrValue = CMD0_ATTR_VALUE; // Fixed constant!
    pAttrib = (BFTP_ATTRIBUTE*)pUserData;
    memcpy( pAttrib->Name, Attributes[CMD0].pName, BFTP_NAME_SIZE );
    pAttrib->Length = sizeof(pAttrib->Type)
                    + sizeof(pAttrib->Flag)
                    + sizeof(dwCmd0AttrValue);
    pAttrib->Type = ATTR_TYPE_BINARY;   // 0x00
    pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
    memcpy( pAttrib->Value, &dwCmd0AttrValue, sizeof(dwCmd0AttrValue) );

    #ifdef LITTLE_ENDIAN
    pAttrib->Length = ByteSwapLong(pAttrib->Length);
    #endif

    // Second attribute is WHT0:RINF
    pAttrib = (BFTP_ATTRIBUTE*)(pUserData
                                + sizeof(BFTP_ATTRIBUTE)
                                + sizeof(dwCmd0AttrValue));
    memcpy( pAttrib->Name, Attributes[WHT0].pName, BFTP_NAME_SIZE );
    pAttrib->Length = sizeof(pAttrib->Type)
                    + sizeof(pAttrib->Flag)
                    + WHT0_ATTRIB_SIZE;
    pAttrib->Type = ATTR_TYPE_CHAR;     // 0x00
    pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
    memcpy( pAttrib->Value, SZ_RINF, WHT0_ATTRIB_SIZE );

    #ifdef LITTLE_ENDIAN
    pAttrib->Length = ByteSwapLong(pAttrib->Length);
    #endif


    // Done.
    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;
    *ppCommand = pCommand;
    *ppCommandHeader = pCommandHeader;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildBftpPutPdu()
//
// The PUT command will span multiple PDUs, this function builds the
// Nth fragment. Note that the first will also hold the attributes
// for the UPF file to be sent (in addition to the SCEP header stuff).
//
// Each PDU will also contain (MAX_PDU_SIZE - *pdwPduSize) bytes
// of the UPF file, but that isn't added in here. You add that
// yourself in the PDU starting at *ppCommand->UserData[].
//
// On success, return NO_ERROR, else return a non-zero error code.
//
// dwUpfFileSize   -- The total UPF file size.
//
// pszUpfFile      -- The 8.3 name of the UPF file.
//
// pdwFragNo       -- The fragment number that was built, cycle this
//                    back into each successive call to BuildBftpPutPdu().
//                    Initialize *pdwFragNo to zero before the first
//                    iteration, then leave it alone.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildBftpPutPdu(
                             IN  DWORD             dwUpfFileSize,
                             IN  CHAR             *pszUpfFileName,
                             IN OUT DWORD         *pdwFragNo,
                             OUT SCEP_HEADER     **ppPdu,
                             OUT DWORD            *pdwHeaderSize,
                             OUT SCEP_REQ_HEADER_LONG_FRAG **ppCommand )
    {
    DWORD            dwStatus = NO_ERROR;
    SCEP_HEADER     *pHeader;
    SCEP_REQ_HEADER_LONG_FRAG *pCommand;
    COMMAND_HEADER  *pCommandHeader;
    UCHAR           *pUserData;
    USHORT          *pwNumAttributes;
    BFTP_ATTRIBUTE  *pAttrib;
    DWORD            dwUpfFileNameLength = strlen(pszUpfFileName);


    *ppPdu = 0;
    *pdwHeaderSize = 0;
    *ppCommand = 0;

    pHeader = NewPdu();  // Size is MAX_PDU_SIZE by default...
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    // This is the size of the SCEP (and bFTP) headers part of the
    // PDU that we will construct. dwHeaderSize1 is the header size for
    // the first PDU, dwHeaderSizeN is the header size for the rest of
    // the PDUs. Note that the Nth (N>1) header does not include the
    // COMMAN_HEADER (28 bytes).
    DWORD  dwHeaderSize;
    DWORD  dwHeaderSize1 = sizeof(SCEP_HEADER)
                         + sizeof(SCEP_REQ_HEADER_LONG_FRAG)
                         + sizeof(USHORT)          // Num Attributes
                         + sizeof(BFTP_ATTRIBUTE)  // For CMD0
                         + sizeof(DWORD)
                         + sizeof(BFTP_ATTRIBUTE)  // For FIL0
                         + dwUpfFileNameLength
                         + sizeof(BFTP_ATTRIBUTE); // For BDY0

    DWORD  dwHeaderSizeN = sizeof(SCEP_HEADER)
                         + FIELD_OFFSET(SCEP_REQ_HEADER_LONG_FRAG,CommandHeader);

    DWORD  dwSpace1;       // Space left after the header in PDU #1.
    DWORD  dwSpaceN;       // Space left after the header in the Nth PDU.
    DWORD  dwFileSizeLeft; // File Size minus what will fit in the
                           // first PDU.
    DWORD  dwNumFullPdus;  // Number of "full" PDUs after PDU #1.
    DWORD  dwLastPdu;      // = 1 iff the last PDU is partially full.
    DWORD  dwNumPdus;      // Total number of fragments to hold the file.

    // Figure out which fragment we are on:
    if (*pdwFragNo == 0)
        {
        dwHeaderSize = dwHeaderSize1;
        m_Fragmented = TRUE;
        m_DFlag = DFLAG_FIRST_FRAGMENT;

        // The space in the PDU left after the first and Nth headers:
        dwSpace1 = MAX_PDU_SIZE - dwHeaderSize1;
        dwSpaceN = MAX_PDU_SIZE - dwHeaderSizeN;

        // The number of full PDUs following the first PDU:
        dwFileSizeLeft = dwUpfFileSize - dwSpace1;
        dwNumFullPdus = dwFileSizeLeft / dwSpaceN;

        // See if there is a trailer PDU with remaining data:
        dwLastPdu = ((dwFileSizeLeft % dwSpaceN) > 0)? 1 : 0;

        dwNumPdus = 1 + dwNumFullPdus + dwLastPdu;

        *pdwFragNo = 1;
        m_dwSequenceNo = 0;     // First Seq.No. is 0.
        m_dwRestNo = dwNumPdus; // Rest starts at Total Num. Fragments.
        }
    else
        {
        dwHeaderSize = dwHeaderSizeN;

        *pdwFragNo++;
        m_dwSequenceNo++;
        m_dwRestNo--;

        if (m_dwRestNo == 0)
            {
            return ERROR_BFTP_NO_MORE_FRAGMENTS; // Called to many times...
            }
        else if (m_dwRestNo == 1)
            {
            m_DFlag = DFLAG_LAST_FRAGMENT;
            }
        else
            {
            m_DFlag = DFLAG_FRAGMENT;
            }
        }

    // Length2 is the total size of the PDU minus the offset+size
    // of Length2:
    USHORT wLength2 = (USHORT)(MAX_PDU_SIZE - 6);
    DWORD  dwLength4 = dwUpfFileSize + 22 + 48;
    DWORD  dwBdy0Length = dwUpfFileSize + 2;

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pCommand = (SCEP_REQ_HEADER_LONG_FRAG*)(pHeader->Rest);
    pCommand->InfType = INF_TYPE_USER_DATA;
    pCommand->Length1 = USE_LENGTH2;           // 0xff
    pCommand->Length2 = wLength2;
    pCommand->InfVersion = INF_VERSION;
    pCommand->DFlag = m_DFlag;
    pCommand->Length3 = pCommand->Length2 - 12; //
    pCommand->SequenceNo = m_dwSequenceNo;
    pCommand->RestNo = m_dwRestNo;

    #ifdef LITTLE_ENDIAN
    pCommand->Length2 = ByteSwapShort(pCommand->Length2);
    pCommand->Length3 = ByteSwapShort(pCommand->Length3);
    pCommand->SequenceNo = ByteSwapLong(pCommand->SequenceNo);
    pCommand->RestNo = ByteSwapLong(pCommand->RestNo);
    #endif

    // Note that there is a COMMAND_HEADER in the SCEP header only
    // for the first fragment.
    if (m_DFlag == DFLAG_FIRST_FRAGMENT)
        {
        pCommandHeader = (COMMAND_HEADER*)(pCommand->CommandHeader);
        pCommandHeader->Marker58h = 0x58;
        pCommandHeader->PduType = PDU_TYPE_REQUEST;
        pCommandHeader->Length4 = dwLength4;
        pCommandHeader->DestPid = m_SrcPid;
        pCommandHeader->SrcPid = m_DestPid;
        pCommandHeader->CommandId = (USHORT)m_dwCommandId;

        memcpy( pCommandHeader->DestMachineId,
                m_pPrimaryMachineId,
                MACHINE_ID_SIZE );

        memcpy( pCommandHeader->SrcMachineId,
                m_pSecondaryMachineId,
                MACHINE_ID_SIZE );

        #ifdef LITTLE_ENDIAN
        ByteSwapCommandHeader(pCommandHeader);
        #endif

        // Setup the bFTP:
        pUserData = pCommand->UserData;
        pwNumAttributes = (USHORT*)pUserData;

        *pwNumAttributes = 3;     // Three bFTP attributes.
        #ifdef LITTLE_ENDIAN
        *pwNumAttributes = ByteSwapShort(*pwNumAttributes);
        #endif
        pUserData += sizeof(*pwNumAttributes);

        // First attribute is CMD0:
        DWORD  dwCmd0AttrValue = 0x00000000;
        pAttrib = (BFTP_ATTRIBUTE*)pUserData;
        memcpy( pAttrib->Name, Attributes[CMD0].pName, BFTP_NAME_SIZE );
        pAttrib->Length = sizeof(pAttrib->Type)
                        + sizeof(pAttrib->Flag)
                        + sizeof(ULONG);
        pAttrib->Type = ATTR_TYPE_BINARY;   // 0x00
        pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
        memcpy( pAttrib->Value, &dwCmd0AttrValue, sizeof(dwCmd0AttrValue) );

        #ifdef LITTLE_ENDIAN
        pAttrib->Length = ByteSwapLong(pAttrib->Length);
        #endif

        // Second attribute is FIL0 (with the 8.3 UPF file name):
        pAttrib = (BFTP_ATTRIBUTE*)(pUserData
                                    + sizeof(BFTP_ATTRIBUTE)
                                    + sizeof(dwCmd0AttrValue));
        memcpy( pAttrib->Name, Attributes[FIL0].pName, BFTP_NAME_SIZE );
        pAttrib->Length = sizeof(pAttrib->Type)
                        + sizeof(pAttrib->Flag)
                        + dwUpfFileNameLength;
        pAttrib->Type = ATTR_TYPE_CHAR;     // 0x01
        pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
        memcpy( pAttrib->Value, pszUpfFileName, dwUpfFileNameLength );

        #ifdef LITTLE_ENDIAN
        pAttrib->Length = ByteSwapLong(pAttrib->Length);
        #endif

        // Third attribute is BDY0 (with the value being the whole UPF file):
        pAttrib = (BFTP_ATTRIBUTE*)( (char*)pAttrib
                                   + sizeof(BFTP_ATTRIBUTE)
                                   + dwUpfFileNameLength );
        memcpy( pAttrib->Name, Attributes[BDY0].pName, BFTP_NAME_SIZE );
        pAttrib->Length = dwBdy0Length;
        pAttrib->Type = ATTR_TYPE_BINARY;   // 0x00
        pAttrib->Flag = ATTR_FLAG_DEFAULT;  // 0x00
        // pAttrib->Value is not copied in (its the entire UPF file).

        #ifdef LITTLE_ENDIAN
        pAttrib->Length = ByteSwapLong(pAttrib->Length);
        #endif
        }

    // Done.
    *ppPdu = pHeader;
    *pdwHeaderSize = dwHeaderSize;
    *ppCommand = pCommand;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildBftpRespPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildBftpRespPdu(
                             IN  DWORD            dwPduSize,
                             OUT SCEP_HEADER    **ppPdu,
                             OUT SCEP_REQ_HEADER_SHORT **ppCommand,
                             OUT COMMAND_HEADER **ppCommandHeader )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pCommand;
    COMMAND_HEADER        *pCommandHeader;

    *ppPdu = 0;
    *ppCommand = 0;
    *ppCommandHeader = 0;

    pHeader = NewPdu();  // BUGBUG: Use dwPduSize?
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // BUGBUG: Use dwPduSize?

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pCommand = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pCommand->InfType = INF_TYPE_USER_DATA;
    pCommand->Length1 = (UCHAR)dwPduSize - 4;  // Four bytes from the start.
    pCommand->InfVersion = INF_VERSION;
    pCommand->DFlag = DFLAG_SINGLE_PDU;
    pCommand->Length3 = (USHORT)dwPduSize - 8; // Eight bytes from the start.

    #ifdef LITTLE_ENDIAN
    pCommand->Length3 = ByteSwapShort(pCommand->Length3);
    #endif

    pCommandHeader = (COMMAND_HEADER*)(pCommand->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_REPLY_ACK;
    pCommandHeader->Length4 = dwPduSize - 14;  // Twelve bytes from the start.
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    memcpy( pCommandHeader->DestMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pCommandHeader->SrcMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    #ifdef LITTLE_ENDIAN
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    *ppPdu = pHeader;
    *ppCommand = pCommand;
    *ppCommandHeader = pCommandHeader;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildWht0RespPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildWht0RespPdu( IN  DWORD         dwWht0Type,
                                          OUT SCEP_HEADER **ppPdu,
                                          OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    DWORD  dwRespSize;
    DWORD  dwAttrValueSize;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pCommand;
    COMMAND_HEADER        *pCommandHeader;
    UCHAR                 *pQueryResp;
    USHORT                *pUShort;
    BFTP_ATTRIBUTE        *pAttr;
    UCHAR                 *pAttrValue;

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwWht0Type == BFTP_QUERY_RIMG)
        {
        dwRespSize = BFTP_RIMG_RESP_SIZE;
        dwAttrValueSize = BFTP_RIMG_ATTR_VALUE_SIZE;
        pAttrValue = BftpRimgRespAttrValue;
        }
    else if (dwWht0Type == BFTP_QUERY_RINF)
        {
        dwRespSize = BFTP_RINF_RESP_SIZE;
        dwAttrValueSize = BFTP_RINF_ATTR_VALUE_SIZE;
        pAttrValue = BftpRinfRespAttrValue;
        }
    else if (dwWht0Type == BFTP_QUERY_RCMD)
        {
        dwRespSize = BFTP_RCMD_RESP_SIZE;
        dwAttrValueSize = BFTP_RCMD_ATTR_VALUE_SIZE;
        pAttrValue = BftpRcmdRespAttrValue;
        }
    else
        {
        return ERROR_BFTP_INVALID_PROTOCOL;
        }

    dwPduSize = SCEP_HEADER_SIZE
                + SCEP_REQ_HEADER_SHORT_SIZE
                + dwRespSize;

    dwStatus = BuildBftpRespPdu( dwPduSize,
                                 &pHeader,
                                 &pCommand,
                                 &pCommandHeader );

    if (dwStatus == NO_ERROR)
        {
        pQueryResp = pCommand->UserData;

        // Set the number of bFTP attributes:
        pUShort = (USHORT*)pQueryResp;
        *pUShort = 1;
        #ifdef LITTLE_ENDIAN
        *pUShort = ByteSwapShort(*pUShort);
        #endif

        // Set the BDY0 for the query response:
        pAttr = (BFTP_ATTRIBUTE*)(sizeof(USHORT)+pQueryResp);
        memcpy(pAttr->Name,Attributes[BDY0].pName,BFTP_NAME_SIZE);
        pAttr->Length = 2 + dwAttrValueSize;
        pAttr->Type = ATTR_TYPE_BINARY;
        pAttr->Flag = ATTR_FLAG_DEFAULT;
        memcpy(pAttr->Value,pAttrValue,dwAttrValueSize);

        #ifdef LITTLE_ENDIAN
        pAttr->Length = ByteSwapLong(pAttr->Length);
        #endif

        *ppPdu = pHeader;
        *pdwPduSize = dwPduSize;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildPutRespPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildPutRespPdu( IN  DWORD         dwPduAckOrNack,
                                         IN  USHORT        usErrorCode,
                                         OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    DWORD  dwRespSize;
    DWORD  dwFileNameLen;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pCommand;
    COMMAND_HEADER        *pCommandHeader;
    UCHAR                 *pQueryResp;
    USHORT                *pUShort;
    BFTP_ATTRIBUTE        *pAttr;
    UCHAR                 *pAttrValue;

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwPduAckOrNack == PDU_TYPE_REPLY_ACK)
        {
        if (!m_pszFileName)
            {
            return ERROR_BFTP_INVALID_PROTOCOL;
            }

        dwFileNameLen = strlen( (const char *)m_pszFileName );
        dwRespSize = sizeof(USHORT) + sizeof(BFTP_ATTRIBUTE) + dwFileNameLen;
        }
    else
        {
        dwRespSize = sizeof(USHORT) + sizeof(BFTP_ATTRIBUTE) + sizeof(USHORT);
        }

    dwPduSize = SCEP_HEADER_SIZE
                + SCEP_REQ_HEADER_SHORT_SIZE
                + dwRespSize;

    dwStatus = BuildBftpRespPdu( dwPduSize,
                                 &pHeader,
                                 &pCommand,
                                 &pCommandHeader );

    if (dwStatus == NO_ERROR)
        {
        pQueryResp = pCommand->UserData;

        // Set the number of bFTP attributes:
        pUShort = (USHORT*)pQueryResp;
        *pUShort = 1;
        #ifdef LITTLE_ENDIAN
        *pUShort = ByteSwapShort(*pUShort);
        #endif

        pAttr = (BFTP_ATTRIBUTE*)(sizeof(USHORT)+pQueryResp);

        if (dwPduAckOrNack == PDU_TYPE_REPLY_ACK)
            {
            // Set the RPL0 for the put response (ACK):
            memcpy(pAttr->Name,Attributes[RPL0].pName,BFTP_NAME_SIZE);
            pAttr->Length = 2 + dwFileNameLen;
            pAttr->Type = ATTR_TYPE_CHAR;
            pAttr->Flag = ATTR_FLAG_DEFAULT;
            memcpy(pAttr->Value,m_pszFileName,dwFileNameLen);
            }
        else
            {
            // Nack the PUT:
            pCommandHeader->PduType = PDU_TYPE_REPLY_NACK;

            // Set the ERR0 for the put response (NACK):
            memcpy(pAttr->Name,Attributes[RPL0].pName,BFTP_NAME_SIZE);
            pAttr->Length = 2 + sizeof(USHORT);
            pAttr->Type = ATTR_TYPE_BINARY;
            pAttr->Flag = ATTR_FLAG_DEFAULT;

            #ifdef LITTLE_ENDIAN
            usErrorCode = ByteSwapShort(usErrorCode);
            #endif
            memcpy(pAttr->Value,&usErrorCode,sizeof(USHORT));
            }

        #ifdef LITTLE_ENDIAN
        pAttr->Length = ByteSwapLong(pAttr->Length);
        #endif

        *ppPdu = pHeader;
        *pdwPduSize = dwPduSize;
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\sources.inc ===
#-----------------------------------------------------------------
#  Copyright (c) 1999  Microsoft Corporation
#
#  Author:
#     EdwardR
#
#  Date:
#     22-Jul-1999
#
#  Module Name:
#     sources.inc
#
#  Abstract:
#    The build sources file for the IrTran-P USD.
#
#  This directory builds
#    IrTran-P USD
#
#-----------------------------------------------------------------

!include $(IMAGE_DIR)\wiaenv.inc

TARGETNAME=ircamera
TARGETTYPE=DYNLINK
TARGETPATH=obj
TARGETEXT=dll

DLLDEF = $O\ircamera.def
DLLENTRY=DllEntryPoint

# SYNCHRONIZE_DRAIN=1

#
# Set calling convention to __cdecl
#

386_STDCALL=0

INCLUDES=.;..\irtranp;$(INCLUES);$(IMAGE_DIR)\inc;$(IMAGE_DIR)\common\jpeglib

C_DEFINES=$(C_DEFINES) -DHAVE_BOOLEAN

SOURCES=            \
    ..\camevent.cpp \
    ..\camopen.cpp  \
    ..\camxfer.cpp  \
    ..\device.cpp   \
    ..\miniitem.cpp \
    ..\ircamera.cpp \
    ..\wiadev.cpp   \
    ..\jpegutil.cpp \
    ..\progress.cpp \
    ..\ircamera.rc

TARGETLIBS= $(TARGETLIBS) \
        $(BASEDIR)\public\sdk\lib\*\kernel32.lib           \
        $(BASEDIR)\public\sdk\lib\*\wsock32.lib            \
        $(BASEDIR)\public\sdk\lib\*\shell32.lib            \
        $(IMAGE_DIR)\lib\$(PLATFORM_SUFFIX)\*\wiaguid.lib  \
        $(IMAGE_DIR)\lib\$(PLATFORM_SUFFIX)\*\wiaservc.lib \
        $(IMAGE_DIR)\lib\$(PLATFORM_SUFFIX)\*\jpeg.lib     \
        ..\irtranp\i386\irtranp.lib


#       $(LIBRARY_PATH)\sti.lib                            \
#       $(BASEDIR)\public\sdk\lib\*\ole32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\bftp.h ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// bftp.h
//
// Constants and Types for the Binary File Transfer Protocol
// (bFTP). This is the file transfer protocol for IrTran-P V1.0.
//
// NOTE: That IrTran-P is a big-endian protocol when on the net.
//
// NOTE: That the protocol data structures below assume that the
//       compiler generates structures with natural alignment by
//       field type.
//
// Author:
//
//   Edward Reus (edwardr)     02-26-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _BFTP_H_
#define _BFTP_H_

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#define  BFTP_NAME_SIZE              4

#define  ATTR_TYPE_BINARY         0x00
#define  ATTR_TYPE_CHAR           0x01
#define  ATTR_TYPE_TIME           0x06

#define  ATTR_FLAG_DEFAULT        0x00

// These are the attribute names, converted from character strings
// to values (see: FTP_ATTRIBUTE_MAP_ENTRY field dwWhichAttr):
#define  FIL0                        0
#define  LFL0                        1
#define  TIM0                        2
#define  TYP0                        3
#define  TMB0                        4
#define  BDY0                        5
#define  CMD0                        6
#define  WHT0                        7
#define  ERR0                        8
#define  RPL0                        9

#define  RIMG                      100  // Convert WHT0 values as well.
#define  RINF                      101
#define  RCMD                      102

#define  CMD0_ATTR_VALUE    0x40001000  // Byte swapped: 0x00010040.
#define  INVALID_ATTR       0xffffffff

// bFTP Operations:
#define  BFTP_QUERY         0x00000001
#define  BFTP_QUERY_RIMG    0x00000011
#define  BFTP_QUERY_RINF    0x00000021
#define  BFTP_QUERY_RCMD    0x00000031
#define  BFTP_PUT           0x00000100
#define  BFTP_ERROR         0x00000200
#define  BFTP_UNKNOWN       0xffffffff

#define  BFTP_QUERY_MASK    0x00000001

// bFTP WHT0 subtypes:
#define  WHT0_ATTRIB_SIZE            4
#define  SZ_RINF                 "RINF"
#define  SZ_RCMD                 "RCMD"
#define  SZ_RIMG                 "RIMG"


// UPF File Constants:
#define  UPF_HEADER_SIZE           240
#define  UPF_ENTRY_SIZE             36

#define  UPF_TOTAL_HEADER_SIZE     384

//--------------------------------------------------------------------
//  Macro functions
//--------------------------------------------------------------------

#define  Match4( pName1, pName2 )    \
             (  ((pName1)[0] == (pName2)[0]) \
             && ((pName1)[1] == (pName2)[1]) \
             && ((pName1)[2] == (pName2)[2]) \
             && ((pName1)[3] == (pName2)[3]) )

#define  IsBftpQuery(dwBftpOp)       \
             (((dwBftpOp)&BFTP_QUERY_MASK) != 0)

#define  IsBftpPut(dwBftpOp)         \
             ((dwBftpOp) == BFTP_PUT)

#define  IsBftpError(dwBftpOp)       \
             ((dwBftpOp) == BFTP_ERROR)

#define  BftpValueLength(length)     \
              ((length) - 2)
//            Note: that the Length field in the BFTP_ATTRIBUE is
//            two bytes longer than the actual value length.

//--------------------------------------------------------------------
//  bFTP Protocol Headers:
//--------------------------------------------------------------------

// There can (optionally) be a bFTP attribute for the picture
// create/modify date/time. If there then it will be exactly
// this size:
//
#define  BFTP_DATE_TIME_SIZE    14

// Turn off warning for zero-sized array...
#pragma warning(disable:4200)
#pragma pack(1)

typedef struct _BFTP_ATTRIBUTE
   {
   UCHAR  Name[BFTP_NAME_SIZE]; // Attribute Name.
   DWORD  Length;               // Attribute Length.
   UCHAR  Type;                 // Attribute Type (see ATTR_TYPE_xxx).
   UCHAR  Flag;                 // Attribute Flag.
   UCHAR  Value[];              // Attribute Data.
   } BFTP_ATTRIBUTE;

typedef struct _BFTP_ATTRIBUTE_MAP_ENTRY
   {
   DWORD  dwWhichAttr;
   CHAR  *pName;
   UCHAR  Type;
   } BFTP_ATTRIBUTE_MAP_ENTRY;

//--------------------------------------------------------------------
//  Internal parts of a .UPF file:
//--------------------------------------------------------------------

typedef struct _UPF_HEADER
   {
   UCHAR  UpfDeclaration[8];   // "SSS V100", no trailing zero.
   UCHAR  FileDeclaration[8];  // "UPF V100", no trailing zero.
   USHORT FileId;              // Should be 0x0100
   USHORT FileVersion;         // Should be 0x0100
   UCHAR  CreateDate[8];       // See "Date Format" note below.
   UCHAR  EditDate[8];         // See "Date Format" note below.
   UCHAR  MarkerModelCode[4];  // 
   UCHAR  EditMarkerModelCode[4];
   UCHAR  Reserve[16];
   UCHAR  NumDataEntries;
   UCHAR  NumTables;
   UCHAR  Reserve1;
   UCHAR  CharSetCode;         // See "Character Set Codes" below.
   UCHAR  Title[128];
   UCHAR  Reserve2[48];
   } UPF_HEADER;               // 240 Bytes

// NOTE: Date format for the UPF header:
//
// Date/time are held in an 8-byte binary block:
//
//   Field          Size       Meaning
//   -----------    ----       -------
//   Time Offset       1       Difference from UTC (in 15 minute
//                             units). 0x80 implies N/A.
//
//   Year              2       4-digit year (0xFFFF == N/A).
//   Month             1       Month        (0xFF == N/A).
//   Day               1       Day of month (0xFF == N/A).
//   Hour              1       Hour 0-23    (0xFF == N/A).
//   Minute            1       Minute 0-59  (0xFF == N/A).
//   Second            1       Second 0-59  (0xFF == N/A).
//
// So, below are the char[] array offsets for each of the date/time
// fields:
#define  UPF_GMT_OFFSET       0
#define  UPF_YEAR             1
#define  UPF_MONTH            3
#define  UPF_DAY              4
#define  UPF_HOUR             5
#define  UPF_MINUTE           6
#define  UPF_SECOND           7

//
// Character Set Codes:
//
#define  UPF_CCODE_ASCII      0x00
#define  UPF_CCODE_ISO_8859_1 0x01
#define  UPF_CCODE_SHIFT_JIS  0x02
#define  UPF_CCODE_NONE       0xFF

//
// There are usually two of these, one for a thumbnail and one for 
// the image itself. Note that the UPF_ENTRY for the thumbnail will
// usually be present event if there isn't a thumbnail. There is 
// space for four of these in the UPF header area.
//
typedef struct _UPF_ENTRY
   {
   DWORD  dwStartAddress;
   DWORD  dwDataSize;
   UCHAR  DataTypeId;
   UCHAR  Reserve;
   UCHAR  InformationData[26];
   } UPF_ENTRY;                // 36 Bytes.

typedef struct _PICTURE_INFORMATION_DATA
   {
   USHORT ImageWidth;
   USHORT ImageHieght;
   UCHAR  PixelConfiguration;
   UCHAR  RotationSet;      // Amount to rotate image (counter-clockwise).
   UCHAR  Reserved1;
   UCHAR  CompressionRatio;
   UCHAR  WhiteLevel;
   UCHAR  InputDevice;
   UCHAR  Reserved2[3];
   UCHAR  DummyData;        // This is like a border.
   USHORT XBegin;           // This is the inset of the picture.
   USHORT YBegin;
   USHORT XSize;            // Embedded size of the picture.
   USHORT YSize;
   UCHAR  NonCompressionId;
   UCHAR  Reserved3[3];
   } PICTURE_INFORMATION_DATA;  // 26 Bytes.


// Image Rotation Flags. This is the amount to rotate the image in
// a counter clockwise direction. Note that most cameras don't know
// the camera orientation, so ROTATE_0 means upright or unknown
// orientation:
//
#define ROTATE_0           0x00
#define ROTATE_90          0x01
#define ROTATE_180         0x02
#define ROTATE_270         0x03


typedef struct _CAMERA_INFORMATION_TABLE
   {
   UCHAR  TableID;    // 0x24
   UCHAR  NextTableOffset;
   USHORT ShutterSpeed;     // In 1/100ths APEX units (0x8000=Undefined).
   USHORT Aperture;         // In 1/100ths APEX units (0x8000=Undefined).
   USHORT Brightness;       // In 1/100ths APEX units (0x8000=Undefined).
   USHORT Exposurebias;     // In 1/100ths APEX units (0x8000=Undefined).
   USHORT MaxApertureRatio; // In 1/100ths APEX units (0x8000=Undefined).
   USHORT FocalLength;      // In 1/10th mm (0xFFFF=Undefined)
   USHORT SubjectDistance;  // In 1/10th m  (0xFFFE=Infinite,0xFFFF=Undefined)
   UCHAR  MeteringMode;
   UCHAR  LightSource;
   UCHAR  FlashMode;
   UCHAR  Reserved1;
   USHORT IntervalInformation;
   UCHAR  Reserved2[2];
   } CAMERA_INFORMATION_TABLE;  // 24 Bytes.

// APEX Units:
//
// ShutterSpeed to Exposure Time (seconds)
//
//  APEX          -5   -4   -3   -2   -1    0    1    2     3      4
//  Exposure Time 30   15    8    4    2    1   1/2  1/4   1/8    1/16
//
//  APEX           5     6     7      8      9      10     11
//  Exposure Time 1/30  1/60  1/125  1/250  1/500  1/1000 1/2000
//
// Aperture to F-Number
//
//   APEX        0    1    2    3    4    5    6    7    8    9    10
//   F-Number    1   1.4   2   2.8   5   5.6   8   11   16   22    32
// 
// Brightness to Foot Lambert
//
//   APEX         -2   -1    0    1    2    3    4    5
//   Foot Lambert 1/4  1/2   1    2    4    8   15   30
//


// MeteringMode:
#define  METERING_AVERAGED         0x00
#define  METERING_CENTER_WEIGHTED  0x01
#define  METERING_SPOT             0x02
#define  METERING_MULTI_SPOT       0x03

// LightSource:
#define  LIGHT_SOURCE_DAYLIGHT     0x00
#define  LIGHT_SOURCE_FLUORESCENT  0x01
#define  LIGHT_SOURCE_TUNGSTEN     0x03
#define  LIGHT_SOURCE_STANDARD_A   0x10
#define  LIGHT_SOURCE_STANDARD_B   0x11
#define  LIGHT_SOURCE_STANDARD_C   0x12
#define  LIGHT_SOURCE_D55          0x20
#define  LIGHT_SOURCE_D65          0x21
#define  LIGHT_SOURCE_D75          0x22
#define  LIGHT_SOURCE_UNDEFINED    0xFF

// FlashMode:
#define  FLASH_NO_FLASH            0x00
#define  FLASH_FLASH               0x01
#define  FLASH_UNKNOWN             0xFF

#pragma warning(default:4200)
#pragma pack()

#endif //_BFTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\byteswap.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// byteswap.cpp
//
// Routines to byteswap SCEP and bFTP headers from the wire format 
// (which is Big-Endian) to Little-Endian (Intel) format.
//
// Author:
//
//   Edward Reus (EdwardR)   02-26-98  Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

//--------------------------------------------------------------------
//  ByteSwapCommandHeader()
//
//  A command header is a 28 byte sub-header embedded in some of the
//  SCEP headers.
//--------------------------------------------------------------------
void ByteSwapCommandHeader( COMMAND_HEADER *pCommandHeader )
    {
    pCommandHeader->Length4 = ByteSwapLong(pCommandHeader->Length4);
    pCommandHeader->DestPid = ByteSwapShort(pCommandHeader->DestPid);
    pCommandHeader->SrcPid = ByteSwapShort(pCommandHeader->SrcPid);
    pCommandHeader->CommandId = ByteSwapShort(pCommandHeader->CommandId);
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderShortNonFrag()
//
//  Short non-fragmented SCEP request header.
//--------------------------------------------------------------------
void ByteSwapReqHeaderShortNonFrag( SCEP_REQ_HEADER_SHORT *pReqHeaderShort )
    {
    pReqHeaderShort->Length3 = ByteSwapShort(pReqHeaderShort->Length3);

    if (pReqHeaderShort->Length3 >= COMMAND_HEADER_SIZE)
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderShort->CommandHeader );
        }
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderLongNonFrag()
//
//  Long non-fragmented SCEP request header.
//--------------------------------------------------------------------
void ByteSwapReqHeaderLongNonFrag( SCEP_REQ_HEADER_LONG *pReqHeaderLong )
    {
    pReqHeaderLong->Length2 = ByteSwapShort(pReqHeaderLong->Length2);
    pReqHeaderLong->Length3 = ByteSwapShort(pReqHeaderLong->Length3);

    if (pReqHeaderLong->Length3 >= COMMAND_HEADER_SIZE)
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderLong->CommandHeader );
        }
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderShortFrag()
//
//  Short fragmented SCEP request header. SCEP PDUs can be fragmented.
//
//  Note: In practice a short fragmented PDU will probably never
//  show up, but its part of the spec...
//--------------------------------------------------------------------
void ByteSwapReqHeaderShortFrag( 
                   SCEP_REQ_HEADER_SHORT_FRAG *pReqHeaderShortFrag )
    {
    pReqHeaderShortFrag->Length3 = ByteSwapShort(pReqHeaderShortFrag->Length3);
    pReqHeaderShortFrag->SequenceNo = ByteSwapLong(pReqHeaderShortFrag->SequenceNo);
    pReqHeaderShortFrag->RestNo = ByteSwapLong(pReqHeaderShortFrag->RestNo);

    if ( (pReqHeaderShortFrag->Length3 >= COMMAND_HEADER_SIZE)
       && (pReqHeaderShortFrag->DFlag == DFLAG_FIRST_FRAGMENT) )
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderShortFrag->CommandHeader );
        }
    }

//--------------------------------------------------------------------
//  ByteSwapReqHeaderLongFrag()
//
//  Long fragmented SCEP request header.
//--------------------------------------------------------------------
void ByteSwapReqHeaderLongFrag( SCEP_REQ_HEADER_LONG_FRAG *pReqHeaderLongFrag )
    {
    pReqHeaderLongFrag->Length2 = ByteSwapShort(pReqHeaderLongFrag->Length2);
    pReqHeaderLongFrag->Length3 = ByteSwapShort(pReqHeaderLongFrag->Length3);
    pReqHeaderLongFrag->SequenceNo = ByteSwapLong(pReqHeaderLongFrag->SequenceNo);
    pReqHeaderLongFrag->RestNo = ByteSwapLong(pReqHeaderLongFrag->RestNo);

    if ( (pReqHeaderLongFrag->Length3 >= COMMAND_HEADER_SIZE)
       && (pReqHeaderLongFrag->DFlag == DFLAG_FIRST_FRAGMENT) )
        {
        ByteSwapCommandHeader( (COMMAND_HEADER*)pReqHeaderLongFrag->CommandHeader );
        }
    }

//--------------------------------------------------------------------
// ByteSwapReqHeaderShort()
//
//--------------------------------------------------------------------
void ByteSwapReqHeaderShort( SCEP_REQ_HEADER_SHORT *pReqHeaderShort )
    {
    if ( (pReqHeaderShort->DFlag == DFLAG_SINGLE_PDU)
       || (pReqHeaderShort->DFlag == DFLAG_INTERRUPT)
       || (pReqHeaderShort->DFlag == DFLAG_CONNECT_REJECT) )
        {
        ByteSwapReqHeaderShortNonFrag( pReqHeaderShort );
        }
    else
        {
        ByteSwapReqHeaderShortFrag( 
                       (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort );
        }
    }

//--------------------------------------------------------------------
// ByteSwapReqHeaderLong()
//
//--------------------------------------------------------------------
void ByteSwapReqHeaderLong( SCEP_REQ_HEADER_LONG *pReqHeaderLong )
    {
    if ( (pReqHeaderLong->DFlag == DFLAG_SINGLE_PDU)
       || (pReqHeaderLong->DFlag == DFLAG_INTERRUPT)
       || (pReqHeaderLong->DFlag == DFLAG_CONNECT_REJECT) )
        {
        ByteSwapReqHeaderLongNonFrag( pReqHeaderLong );
        }
    else
        {
        ByteSwapReqHeaderLongFrag( 
                        (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong );
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\complete.cpp ===
//---------------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  complete.cpp
//
//  This is the main for the IrTran-P service.
//---------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE        g_hInst;           // Instance of ircamera.dll
extern void            *g_pvIrUsdDevice;   // Devined: irtranp.cpp

extern CCONNECTION_MAP *g_pConnectionMap;  // Defined: irtranp.cpp
extern BOOL  ReceivesAllowed();            // Defined: irtranp.cpp
extern BOOL  CheckSaveAsUPF();             // Defined: irtranp.cpp

extern DWORD SignalWIA( IN char *pszFileName,
                        IN void *pvIrUsdDevice );  // see ../device.cpp

//---------------------------------------------------------------------
// Constants:
//---------------------------------------------------------------------

#define DEFAULT_TIMEOUT      10000

//---------------------------------------------------------------------
// ReceiveComplete()
//
//---------------------------------------------------------------------
void ReceiveComplete( IN CCONNECTION *pConnection,
                      IN DWORD        dwStatusCode )
    {
    DWORD    dwError = 0;

    if (  (dwStatusCode == NO_ERROR)
       || (dwStatusCode == ERROR_SCEP_UNSPECIFIED_DISCONNECT)
       || (dwStatusCode == ERROR_SCEP_USER_DISCONNECT)
       || (dwStatusCode == ERROR_SCEP_PROVIDER_DISCONNECT) )
        {
        //
        // A new picture has just been received, so we need to signal
        // WIA...
        //
        SignalWIA( pConnection->GetPathPlusFileName(), g_pvIrUsdDevice );
        }
    }

//---------------------------------------------------------------------
// ProcessConnectRequest()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_CONNECT_REQ.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectRequest()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessConnectRequest( IN CCONNECTION *pConnection,
                             IN SCEP_HEADER *pPdu,
                             IN DWORD        dwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwRespPduSize;
    BOOL   fReceivesAllowed = ::ReceivesAllowed();
    SCEP_HEADER *pRespPdu;
    CIOPACKET   *pNewIoPacket;    // Posted IO packet (by SendPdu()).

    CSCEP_CONNECTION *pScepConnection
                 = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    if (fReceivesAllowed)
        {
        // Build an connection accept acknowledgement:
        dwStatus = pScepConnection->BuildConnectRespPdu(&pRespPdu,
                                                        &dwRespPduSize);
        }
    else
        {
        // Build a connect NACK:
        dwStatus = pScepConnection->BuildConnectNackPdu(&pRespPdu,
                                                        &dwRespPduSize);
        }

    if (dwStatus == NO_ERROR)
        {
        pConnection->SendPdu(pRespPdu,dwRespPduSize,&pNewIoPacket);
        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pRespPdu);
            }
        else
            {
            DeletePdu(pRespPdu);
            }

        if (!fReceivesAllowed)
            {
            // Note: After sending a NACK, the camera should close
            // the connection, but at lease some don't, so I'm
            // forced to slam the connection...
            pConnection->CloseSocket();  // Was: ShutdownSocket().
            }
        }

    DeletePdu(pPdu);

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessConnectResponse()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_CONNECT_RESP.
//
// NOTE: Note implemented in the IrTran-P server, because the server
//       is not currently setup to connect to a camera to download
//       pictures back to the camera... We should never get this PDU
//       during normal operation.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectResponse()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessConnectResponse( CCONNECTION *pConnection,
                              SCEP_HEADER *pPdu,
                              DWORD        dwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;

    WIAS_TRACE((g_hInst,"ProcessClient(): Unimplemented MSG_TYPE_CONNECT_RESP"));

    DeletePdu(pPdu);

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessData()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_DATA.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectResponse()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessData( CCONNECTION    *pConnection,
                   SCEP_HEADER    *pPdu,
                   DWORD           dwPduSize,
                   COMMAND_HEADER *pCommandHeader,
                   UCHAR          *pUserData,
                   DWORD           dwUserDataSize )
    {
    DWORD        dwStatus = NO_ERROR;
    DWORD        dwRespPduSize;
    DWORD        dwBftpOp;
    UCHAR       *pPutData;
    DWORD        dwPutDataSize;
    DWORD        dwJpegOffset;
    DWORD        dwJpegSize;
    SCEP_HEADER *pRespPdu;
    CIOPACKET   *pNewIoPacket;    // Posted IO packet (by SendPdu()).


    CSCEP_CONNECTION *pScepConnection
                 = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    // First, check to see if this is an abort PDU, send by the camera:
    if ( (pCommandHeader) && (pCommandHeader->PduType == PDU_TYPE_ABORT) )
        {
        DeletePdu(pPdu);
        return ERROR_SCEP_ABORT;
        }

    // Is one of the 2nd through Nth fragments of a fragmented PDU?
    if ( (pScepConnection->IsFragmented())
       && (pScepConnection->GetSequenceNo() > 0))
        {
        #ifdef DBG_IO
        WIAS_TRACE((g_hInst,"ProcessClient(): Put Fragment: SequenceNo: %d RestNo: %d", pScepConnection->GetSequenceNo(), pScepConnection->GetRestNo() ));
        #endif

        pConnection->WritePictureFile( pUserData,
                                       dwUserDataSize,
                                       &pNewIoPacket );
        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pPdu);
            }
        else
            {
            DeletePdu(pPdu);
            }

        if (pScepConnection->GetDFlag() == DFLAG_LAST_FRAGMENT)
            {
            pScepConnection->BuildPutRespPdu( PDU_TYPE_REPLY_ACK,
                                              ERROR_PUT_NO_ERROR,
                                              &pRespPdu,
                                              &dwRespPduSize);
            pConnection->SendPdu( pRespPdu,
                                  dwRespPduSize,
                                  &pNewIoPacket);

            if (pNewIoPacket)
                {
                pNewIoPacket->SetWritePdu(pRespPdu);
                }
            else
                {
                DeletePdu(pRespPdu);
                }
            }
        }
    else if (pCommandHeader)
        {
        // Length4 in the COMMAN_HEADER is the user data size
        // plus the bytes for machine ids (16), the DestPid (2),
        // SrcPid (2) and CommandId (2) so offset by 22.

        dwStatus = pScepConnection->ParseBftp( pUserData,
                                               dwUserDataSize,
                                               pConnection->CheckSaveAsUPF(),
                                               &dwBftpOp,
                                               &pPutData,
                                               &dwPutDataSize );
        if ((dwStatus == NO_ERROR) && (IsBftpQuery(dwBftpOp)))
            {
            pScepConnection->BuildWht0RespPdu(dwBftpOp,
                                              &pRespPdu,
                                              &dwRespPduSize);

            pConnection->SendPdu( pRespPdu,
                                  dwRespPduSize,
                                  &pNewIoPacket );

            if (pNewIoPacket)
                {
                pNewIoPacket->SetWritePdu(pRespPdu);
                }
            else
                {
                DeletePdu(pRespPdu);
                }

            DeletePdu(pPdu);
            }
        else if ((dwStatus == NO_ERROR) && (IsBftpPut(dwBftpOp)))
            {
            //
            // Ok, we have a bFTP PUT command, so open a file
            // and get ready to start collecting image data.
            //
            dwStatus = pScepConnection->ParseUpfHeaders( pPutData,
                                                         dwPutDataSize,
                                                         &dwJpegOffset,
                                                         &dwJpegSize );

            pConnection->SetJpegOffsetAndSize(dwJpegOffset,dwJpegSize);

            dwStatus = pConnection->Impersonate();

            dwStatus = pConnection->CreatePictureFile();

            dwStatus = pConnection->SetPictureFileTime( pScepConnection->GetCreateTime() );

            dwStatus = pConnection->RevertToSelf();

            dwStatus = pConnection->WritePictureFile( pPutData,
                                                      dwPutDataSize,
                                                      &pNewIoPacket );
            if (pNewIoPacket)
                {
                pNewIoPacket->SetWritePdu(pPdu);
                }
            else
                {
                DeletePdu(pPdu);
                }
            }
        else if (IsBftpError(dwBftpOp))
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"ProcessClient(): bFTP Error: %d", dwStatus));
            #endif

            DeletePdu(pPdu);
            dwStatus = ERROR_BFTP_INVALID_PROTOCOL;
            }
        else
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"ProcessClient(): Unknown bFTP Command: %d",dwBftpOp));
            #endif

            DeletePdu(pPdu);
            dwStatus = ERROR_BFTP_INVALID_PROTOCOL;
            }
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessDisconnect()
//
// Called by ProcessClient() when the input PDU message type is
// MSG_TYPE_DISCONNECT.
//
// pConnection - The newly established Winsock connection with the
//               camera.
//
// pPdu        - The SCEP PDU holding the connect request. It was
//               allocated in ProcessClient() by AssemblePdu() and
//               will always be free'd when ProcessConnectResponse()
//               finishes.
//
// dwPduSize   - The size of the input PDU in bytes.
//
//---------------------------------------------------------------------
DWORD ProcessDisconnect( CCONNECTION *pConnection,
                         SCEP_HEADER *pPdu,
                         DWORD        dwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;

    // Don't need to do anything special here, since
    // ParsePdu() will set dwStatus to one of:
    //          ERROR_SCEP_UNSPECIFIED_DISCONNECT  (5002)
    //          ERROR_SCEP_USER_DISCONNECT         (5003)
    //      or  ERROR_SCEP_PROVIDER_DISCONNECT     (5004)

    pConnection->SetReceiveComplete(TRUE);

    DeletePdu(pPdu);

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessClient()                       Synchronous Version
//
//---------------------------------------------------------------------
DWORD ProcessClient( CIOSTATUS   *pIoStatus,
                     CCONNECTION *pConnection,
                     char        *pBuffer,
                     DWORD        dwNumBytes )
    {
    DWORD           dwStatus = NO_ERROR;
    CSCEP_CONNECTION *pScepConnection;
    SCEP_HEADER    *pPdu;
    DWORD           dwPduSize;
    COMMAND_HEADER *pCommandHeader;
    UCHAR          *pUserData;       // Location of bFTP data.
    DWORD           dwUserDataSize;
    DWORD           dwError = 0;


    pScepConnection = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    WIAS_ASSERT(g_hInst,pScepConnection!=NULL);

    while (dwStatus == NO_ERROR)
        {
        dwStatus = pScepConnection->AssemblePdu( pBuffer,
                                                 dwNumBytes,
                                                 &pPdu,
                                                 &dwPduSize );
        if (dwStatus == NO_ERROR)
            {
            dwStatus = pScepConnection->ParsePdu( pPdu,
                                                  dwPduSize,
                                                  &pCommandHeader,
                                                  &pUserData,
                                                  &dwUserDataSize );

            switch (pPdu->MsgType)
                {
                case MSG_TYPE_CONNECT_REQ:
                    //
                    // Message was an SCEP Connection Request:
                    //
                    dwStatus = ProcessConnectRequest(pConnection,
                                                     pPdu,
                                                     dwPduSize );

                    if ((dwStatus) || (!ReceivesAllowed()))
                        {
                        pConnection->ClosePictureFile();
                        ReceiveComplete(pConnection,dwStatus);
                        }
                    else
                        {
                        pConnection->StartProgress();
                        }
                    break;

                case MSG_TYPE_CONNECT_RESP:
                    // Message was a reply from a connection request:
                    dwStatus = ProcessConnectResponse(pConnection,
                                                      pPdu,
                                                      dwPduSize );
                    break;

                case MSG_TYPE_DATA:
                    // Message is a SCEP command of some sort:
                    dwStatus = ProcessData(pConnection,
                                           pPdu,
                                           dwPduSize,
                                           pCommandHeader,
                                           pUserData,
                                           dwUserDataSize );
                    pConnection->UpdateProgress();
                    break;

                case MSG_TYPE_DISCONNECT:
                    // Message from the camera was a disconnect:
                    ProcessDisconnect(pConnection,
                                      pPdu,
                                      dwPduSize );
                    pConnection->ClosePictureFile();
                    ReceiveComplete(pConnection,dwStatus);
                    pConnection->EndProgress();
                    break;

                default:
                    #ifdef DBG_ERROR
                    WIAS_ERROR((g_hInst,"ProcessClient(): Unknown MSG_TYPE_xxx: %d", pPdu->MsgType));
                    #endif
                    DeletePdu(pPdu);
                    pConnection->EndProgress();
                    break;
                }
            }
        else
            {
            break;
            }

        pBuffer = 0;
        dwNumBytes = 0;
        }

    if (dwStatus == ERROR_CONTINUE)
        {
        dwStatus = NO_ERROR;
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// SendAbortPdu()
//
// Stop the camera.
//
// I should be able to send a Stop PDU, followed by a Disconnect, or
// maybe an Abort PDU, but these don't work on all the cameras, so I
// currently end up just doing a hard close on the connection to the
// camera.
//---------------------------------------------------------------------
DWORD SendAbortPdu( IN CCONNECTION *pConnection )
    {
    DWORD  dwStatus = NO_ERROR;

    #if TRUE
    pConnection->CloseSocket();

    #else
    DWORD  dwPduSize;
    SCEP_HEADER *pPdu;
    CIOPACKET        *pNewIoPacket = 0;
    CSCEP_CONNECTION *pScepConnection
                 = (CSCEP_CONNECTION*)pConnection->GetScepConnection();

    if (pScepConnection)
        {
        dwStatus = pScepConnection->BuildStopPdu(&pPdu,&dwPduSize);

        if (dwStatus != NO_ERROR)
            {
            pConnection->CloseSocket();
            return dwStatus;
            }

        dwStatus = pConnection->SendPdu(pPdu,dwPduSize,&pNewIoPacket);

        if (dwStatus != NO_ERROR)
            {
            DeletePdu(pPdu);
            pConnection->CloseSocket();
            return dwStatus;
            }

        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pPdu);
            }

        dwStatus = pScepConnection->BuildDisconnectPdu(
                                         REASON_CODE_PROVIDER_DISCONNECT,
                                         &pPdu,
                                         &dwPduSize);

        if (dwStatus != NO_ERROR)
            {
            pConnection->CloseSocket();
            return dwStatus;
            }

        dwStatus = pConnection->SendPdu(pPdu,dwPduSize,&pNewIoPacket);

        if (dwStatus != NO_ERROR)
            {
            DeletePdu(pPdu);
            pConnection->CloseSocket();
            return dwStatus;
            }

        if (pNewIoPacket)
            {
            pNewIoPacket->SetWritePdu(pPdu);
            }
        }
    #endif

    return dwStatus;
    }

//---------------------------------------------------------------------
// MapStatusCode()
//
//---------------------------------------------------------------------
DWORD MapStatusCode( DWORD dwStatus,
                     DWORD dwDefaultStatus )
    {
    // The Facility part of an error code are the first 12 bits of the
    // high word (16bits):
    #define FACILITY_MASK   0x0FFF0000

    // If the error code is already an IrTran-P error code, then don't
    // remap it:
    if ( ((dwStatus&FACILITY_MASK) >> 16) == FACILITY_IRTRANP)
        {
        return dwStatus;
        }

    // Map other errors:
    if (dwStatus != NO_ERROR)
        {
        if (  (dwStatus == ERROR_DISK_FULL)
           || (dwStatus == ERROR_WRITE_FAULT)
           || (dwStatus == ERROR_WRITE_PROTECT)
           || (dwStatus == ERROR_GEN_FAILURE)
           || (dwStatus == ERROR_NOT_DOS_DISK) )
            {
            dwStatus = ERROR_IRTRANP_DISK_FULL;
            }
        else
            {
            dwStatus = dwDefaultStatus;
            }
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// ProcessIoPackets()               Synchronous Version
//
//---------------------------------------------------------------------
DWORD ProcessIoPackets( CIOSTATUS *pIoStatus )
    {
    DWORD   dwStatus = NO_ERROR;
    DWORD   dwProcessStatus = NO_ERROR;   // Processing IO status.
    DWORD   dwNumBytes;
    DWORD   dwState;
    SOCKET  Socket = INVALID_SOCKET;
    CCONNECTION    *pConnection;
    CCONNECTION    *pNewConnection;
    CSCEP_CONNECTION *pScepConnection;
    DWORD   dwKind = PACKET_KIND_LISTEN;
    int     iCount;


    while (TRUE)
        {
        if (dwKind == PACKET_KIND_LISTEN)
            {
            dwState = 0;

            Socket = g_pConnectionMap->ReturnNextSocket(&dwState);

            pConnection = g_pConnectionMap->Lookup(Socket);
            if (!pConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Lookup(%d) Failed."));
                #endif
                continue;
                }

            //
            // New connection:
            //
            SOCKET NewSocket = accept(Socket,NULL,NULL);

            if (NewSocket == INVALID_SOCKET)
                {
                dwStatus = WSAGetLastError();

                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Accept() failed: %d",dwStatus));
                #endif

                break;
                }

            WIAS_TRACE((g_hInst,"ProcessIoPackets(): Accept(): Socket: %d",NewSocket));

            pScepConnection = new CSCEP_CONNECTION;
            if (!pScepConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Out of memeory on allocate of new SCEP connection object."));
                #endif

                closesocket(NewSocket);
                continue;
                }

            pNewConnection = new CCONNECTION(
                                        PACKET_KIND_READ,
                                        NewSocket,
                                        NULL, // No IO Completion port...
                                        pScepConnection,
                                        ::CheckSaveAsUPF() );
            if (!pNewConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Out of memeory on allocate of new connection object."));
                #endif

                delete pScepConnection;
                closesocket(NewSocket);
                continue;
                }

            g_pConnectionMap->Add(pNewConnection,
                                  pNewConnection->GetSocket() );

            Socket = NewSocket;
            dwKind = PACKET_KIND_READ;
            }
        else
            {
            //
            // Incomming data from connected client:
            //
            DWORD   dwFlags = 0;

            char  ReadBuffer[DEFAULT_READ_BUFFER_SIZE];
            int   iReadBufferSize = DEFAULT_READ_BUFFER_SIZE;


            pConnection = g_pConnectionMap->Lookup(Socket);
            if (!pConnection)
                {
                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Lookup(%d) Failed."));
                #endif

                dwKind = PACKET_KIND_LISTEN;
                continue;
                }

            iCount = recv(Socket,ReadBuffer,iReadBufferSize,dwFlags);

            if (iCount == SOCKET_ERROR)
                {
                //
                // Error on Recv().
                //
                dwStatus = WSAGetLastError();

                #ifdef DBG_ERROR
                WIAS_ERROR((g_hInst,"ProcessIoPackets(): Recv() failed: %d",dwStatus));
                #endif

                g_pConnectionMap->Remove(Socket);

                delete pConnection;

                dwKind = PACKET_KIND_LISTEN;
                continue;
                }

            if (iCount == 0)
                {
                //
                // Graceful close.
                //
                g_pConnectionMap->Remove(Socket);

                delete pConnection;

                dwKind = PACKET_KIND_LISTEN;
                continue;
                }

            WIAS_ASSERT(g_hInst, iCount>0 );

            dwNumBytes = iCount;

            dwProcessStatus 
                = ProcessClient(pIoStatus,
                                pConnection,
                                ReadBuffer,
                                dwNumBytes);

            if (dwProcessStatus != NO_ERROR)
                {
                #ifdef DBG_ERROR
                if (  (dwProcessStatus != ERROR_SCEP_UNSPECIFIED_DISCONNECT)
                   && (dwProcessStatus != ERROR_SCEP_USER_DISCONNECT)
                   && (dwProcessStatus != ERROR_SCEP_PROVIDER_DISCONNECT) )
                    {
                    WIAS_ERROR((g_hInst,"ProcessIoPackets(): ProcessClient(): Failed: 0x%x",dwProcessStatus));
                    }
                #endif

                SendAbortPdu(pConnection);
                pConnection->ClosePictureFile();
                pConnection->EndProgress();
                pConnection->DeletePictureFile();
                g_pConnectionMap->Remove(Socket);
                delete pConnection;

                dwProcessStatus = MapStatusCode(
                                             dwProcessStatus,
                                             ERROR_SCEP_INVALID_PROTOCOL );
                // pConnection->ClosePictureFile();
                // ReceiveComplete(pConnection,dwProcessStatus);

                dwKind = PACKET_KIND_LISTEN;
                }
            }
        }

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\iostatus.cpp ===
//---------------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  iostatus.cpp
//
//  Author:
//
//    Edward Reus (edwardr)     02-28-98   Initial coding.
//
//---------------------------------------------------------------------

#include "precomp.h"

//---------------------------------------------------------------------
// CIOSTATUS::CIOSTATUS()
//
//---------------------------------------------------------------------
CIOSTATUS::CIOSTATUS()
    {
    m_dwMainThreadId = 0;

    m_lNumThreads = 0;
    m_lNumPendingThreads = 0;
    }

//---------------------------------------------------------------------
// CIOSTATUS::~CIOSTATUS()
//
//---------------------------------------------------------------------
CIOSTATUS::~CIOSTATUS()
    {
    }

//------------------------------------------------------------------------
//  CIOSTATUS::operator new()
//
//------------------------------------------------------------------------
void *CIOSTATUS::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CIOSTATUS::operator delete()
//
//------------------------------------------------------------------------
void CIOSTATUS::operator delete( IN void *pObj,
                                 IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);

        #ifdef DBG_MEM
        if (dwStatus)
            {
            DbgPrint("IrXfer: IrTran-P: CIOSTATUS::delete Failed: %d\n",
                     dwStatus );
            }
        #endif
        }
    }

//---------------------------------------------------------------------
// CIOSTATUS::Initialize();
//
//---------------------------------------------------------------------
DWORD CIOSTATUS::Initialize()
    {
    DWORD  dwStatus = NO_ERROR;

    m_dwMainThreadId = GetCurrentThreadId();

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\irthread.h ===
//--------------------------------------------------------------------
// Copyright (c)1999 Microsoft Corporation, All Rights Reserved.
//
// irthread.h
//
// Author:
//
//   Edward Reus (edwardr)     08-30-99   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _IRTRANP_H_
#define _IRTRANP_H_


//
// IrTran-P thread procedure:
//
extern DWORD WINAPI  IrTranP( LPVOID pv );

//
// Call this guy to stop the IrTran-P protocol engine thread.
//
extern BOOL  UninitializeIrTranP( HANDLE hThread );

//
// Call this function to get the location that the IrTran-P places
// the images as they are sent by the camera.
//
extern CHAR *GetImageDirectory();


#endif //_IRTRANP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\conn.cpp ===
//---------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  conn.cpp
//
//  Connection mapping between sockets and CCONNECTION objects.
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//---------------------------------------------------------------

#include "precomp.h"
#include <userenv.h>
#include <time.h>
#include <malloc.h>
#include <shlwapi.h>

#ifdef DBG_MEM
static LONG g_lCConnectionCount = 0;
#endif

extern HINSTANCE  g_hInst;   // Instance of ircamera.dll

//------------------------------------------------------------------------
//  CCONNECTION::CCONNECTION()
//
//------------------------------------------------------------------------
CCONNECTION::CCONNECTION( IN DWORD             dwKind,
                          IN SOCKET            Socket,
                          IN HANDLE            hIoCP,
                          IN CSCEP_CONNECTION *pScepConnection,
                          IN BOOL              fSaveAsUPF )
    {
    this->SetKind(dwKind);
    m_pszServiceName = 0;
    m_ListenSocket = INVALID_SOCKET;
    m_Socket = Socket;
    m_hFile = INVALID_HANDLE_VALUE;
    m_pszPathPlusFileName = 0;
    m_dwFileBytesWritten = 0;
    m_lPendingReads = 0;
    // m_lMaxPendingReads is set in SetKind().
    m_lPendingWrites = 0;
    // m_lMaxPendingWrites is set in SetKind().
    m_dwJpegOffset = 0;
    m_fSaveAsUPF = fSaveAsUPF;
    m_dwUpfBytes = 0;
    m_dwBytesWritten = 0;
    m_fReceiveComplete = FALSE;
    m_fImpersonating = FALSE;
    m_pScepConnection = pScepConnection;

    // If the new connection is to a camera, then tell the system that
    // we don't want it to hibrenate while the connection is active.
    if (m_dwKind != PACKET_KIND_LISTEN)
        {
        #ifdef USE_WINNT_CALLS
        m_ExecutionState
             = SetThreadExecutionState( ES_SYSTEM_REQUIRED|ES_CONTINUOUS );
        #else
        #pragma message("Missing important call: SetThreadExecutionState  on Windows9x ")
        #endif
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::~CCONNECTION()
//
//------------------------------------------------------------------------
CCONNECTION::~CCONNECTION()
    {
    if (m_pszServiceName)
        {
        FreeMemory(m_pszServiceName);
        }

    if ( (m_dwKind == PACKET_KIND_LISTEN)
       && (m_ListenSocket != INVALID_SOCKET))
        {
        closesocket(m_ListenSocket);
        }

    if (m_Socket != INVALID_SOCKET)
        {
        closesocket(m_Socket);
        }

    if (m_pScepConnection)
        {
        delete m_pScepConnection;
        }

    if (m_hFile != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hFile);
        }

    if (m_pszPathPlusFileName)
        {
        FreeMemory(m_pszPathPlusFileName);
        }

    // Tell the system that it can go to sleep now if it wants
    // to...
    if (m_dwKind != PACKET_KIND_LISTEN)
        {
        #ifdef USE_WINNT_CALLS
        SetThreadExecutionState( m_ExecutionState );
        #else
        #pragma message("Missing important call SetThreadExecutionState on Windows9x ")
        #endif
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::operator new()
//
//------------------------------------------------------------------------
void *CCONNECTION::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CCONNECTION::operator delete()
//
//------------------------------------------------------------------------
void CCONNECTION::operator delete( IN void *pObj,
                                   IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::InitializeForListen()
//
//------------------------------------------------------------------------
DWORD  CCONNECTION::InitializeForListen( IN char  *pszServiceName,
                                         IN BOOL   fIsIrCOMM,
                                         IN HANDLE hIoCP )
    {
    DWORD          dwStatus = NO_ERROR;
    SOCKADDR_IRDA  AddrLocal;
    BYTE           bIASSetBuffer[sizeof(IAS_SET) - 3 + IAS_SET_ATTRIB_MAX_LEN];
    int            iIASSetSize = sizeof(bIASSetBuffer);
    IAS_SET       *pIASSet = (IAS_SET*)bIASSetBuffer;
    int            iEnable9WireMode = 1;


    // Connections are initialized in listen mode:
    SetKind(PACKET_KIND_LISTEN);

    // Save the service name for listen sockets:
    m_pszServiceName = (char*)AllocateMemory(1+strlen(pszServiceName));
    if (m_pszServiceName)
        {
        strcpy(m_pszServiceName,pszServiceName);
        }

    // Create a socket that we will listen on:
    m_ListenSocket = socket(AF_IRDA,SOCK_STREAM,IPPROTO_IP);

    if (m_ListenSocket == INVALID_SOCKET)
        {
        dwStatus = WSAGetLastError();
        #ifdef DBG_ERROR
        WIAS_ERROR((g_hInst,"InitializeForListen(%s): socket() Failed: %d\n",pszServiceName,dwStatus));
        #endif
        return dwStatus;
        }

    // If this is IrCOMM, the we need to do a little extra work.
    if (fIsIrCOMM)
        {
        // Fill in the 9-wire attributes:
        memset(pIASSet,0,iIASSetSize);

        memcpy(pIASSet->irdaClassName,IRCOMM_9WIRE,sizeof(IRCOMM_9WIRE));

        memcpy(pIASSet->irdaAttribName,IRDA_PARAMETERS,sizeof(IRDA_PARAMETERS));

        pIASSet->irdaAttribType = IAS_ATTRIB_OCTETSEQ;
        pIASSet->irdaAttribute.irdaAttribOctetSeq.Len = OCTET_SEQ_SIZE;

        memcpy(pIASSet->irdaAttribute.irdaAttribOctetSeq.OctetSeq,OCTET_SEQ,OCTET_SEQ_SIZE);

        // Add IrCOMM IAS attributes for 3-wire cooked and 9-wire
        // raw modes (see the IrCOMM spec)...
        if (SOCKET_ERROR == setsockopt(m_ListenSocket,
                                       SOL_IRLMP,
                                       IRLMP_IAS_SET,
                                       (const char*)pIASSet,
                                       iIASSetSize))
            {
            dwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            WIAS_TRACE((g_hInst,"InitializeForListen(%s): setsockopt(IRLMP_IAS_SET) Failed: %d",pszServiceName,dwStatus));
            #endif
            closesocket(m_ListenSocket);
            m_ListenSocket = INVALID_SOCKET;
            return dwStatus;
            }

        // Need to enable 9-wire mode before the bind():
        if (SOCKET_ERROR == setsockopt(m_ListenSocket,
                                       SOL_IRLMP,
                                       IRLMP_9WIRE_MODE,
                                       (const char*)&iEnable9WireMode,
                                       sizeof(iEnable9WireMode)))
            {
            dwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            WIAS_TRACE((g_hInst,"InitializeForListen(%s): setsockopt(IRLMP_9WIRE_MODE) Failed: %d",pszServiceName,dwStatus));
            #endif
            closesocket(m_ListenSocket);
            m_ListenSocket = INVALID_SOCKET;
            return dwStatus;
            }
        }

    // Setup the local address for the bind():
    memset(&AddrLocal,0,sizeof(AddrLocal));
    AddrLocal.irdaAddressFamily = AF_IRDA;
    strcpy(AddrLocal.irdaServiceName,pszServiceName);
    // Note: AddrLocal.irdaDeviceID ignored by server applications...

    if (SOCKET_ERROR == bind( m_ListenSocket,
                              (struct sockaddr *)&AddrLocal,
                              sizeof(AddrLocal)) )
        {
        dwStatus = WSAGetLastError();
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
        return dwStatus;
        }

    if (SOCKET_ERROR == listen(m_ListenSocket,2))
        {
        dwStatus = WSAGetLastError();
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
        return dwStatus;
        }

    #ifdef USE_IOCOMPLETION
    //
    // If this is NT, then associate the listen socket with
    // an IO completion port (not supported in Windows98).
    //
    hIoCP = CreateIoCompletionPort( (void*)m_ListenSocket,
                                    hIoCP,
                                    m_ListenSocket,
                                    0 );

    m_hIoCompletionPort = hIoCP;
    #endif

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::PostMoreIos()
//
//------------------------------------------------------------------------
#if FALSE
DWORD CCONNECTION::PostMoreIos( CIOPACKET *pIoPacket )
    {
    DWORD  dwStatus = S_OK;
    LONG   lNumPendingReads;


    while (m_lPendingReads < m_lMaxPendingReads)
        {
        if (!pIoPacket)
            {
            pIoPacket = new CIOPACKET;
            if (!pIoPacket)
                {
                WIAS_ERROR((g_hInst,"new CIOPACKET failed."));
                dwStatus = ERROR_OUTOFMEMORY;
                break;
                }

            dwStatus = pIoPacket->Initialize( GetKind(),
                                              GetListenSocket(),
                                              GetSocket(),
                                              GetIoCompletionPort() );
            }

        dwStatus = pIoPacket->PostIo();
        if (dwStatus != NO_ERROR)
            {
            WIAS_ERROR((g_hInst,"pNewIoPacket->PostIo() failed: %d\n", dwStatus ));
            delete pIoPacket;
            break;
            }

        // Increment the count of the number of pending reads on
        // this connection:
        lNumPendingReads = IncrementPendingReads();
        WIAS_ASSERT(g_hInst,lNumPendingReads > 0);

        pIoPacket = 0;  // don't delete this line... this is a loop...
        }

    return dwStatus;
    }
#endif

//------------------------------------------------------------------------
//  CCONNECTION::SendPdu()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::SendPdu( IN  SCEP_HEADER *pPdu,
                            IN  DWORD        dwPduSize,
                            OUT CIOPACKET  **ppIoPacket )
    {
    DWORD      dwStatus = NO_ERROR;
    CIOPACKET *pIoPacket = new CIOPACKET;

    *ppIoPacket = 0;

    if (!pIoPacket)
        {
        return ERROR_OUTOFMEMORY;
        }

    dwStatus = pIoPacket->Initialize( PACKET_KIND_WRITE_SOCKET,
                                      INVALID_SOCKET,  // ListenSocket
                                      GetSocket(),
                                      GetIoCompletionPort() );
    if (dwStatus != NO_ERROR)
        {
        delete pIoPacket;
        return dwStatus;
        }

    dwStatus = pIoPacket->PostIoWrite(pPdu,dwPduSize,0);

    delete pIoPacket;

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::ShutdownSocket()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::ShutdownSocket()
    {
    this->CloseSocket();

    return NO_ERROR;
    }

//------------------------------------------------------------------------
//  CCONNECTION::CloseSocket()
//
//------------------------------------------------------------------------
void CCONNECTION::CloseSocket()
    {
    if (m_Socket != INVALID_SOCKET)
        {
        closesocket(m_Socket);
        m_Socket = INVALID_SOCKET;
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::CloseListenSocket()
//
//------------------------------------------------------------------------
void CCONNECTION::CloseListenSocket()
    {
    if (m_ListenSocket != INVALID_SOCKET)
        {
        closesocket(m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::CleanupDateString()
//
//  Make sure that the specified date string doesn't contain any slashes
//  which could be confused as subdirectories if the date is used as part
//  of a path.
//------------------------------------------------------------------------
void CCONNECTION::CleanupDateString( IN OUT CHAR *pszDateStr )
    {
    if (pszDateStr)
        {
        while (*pszDateStr)
            {
            if ((*pszDateStr == '/') || (*pszDateStr == '\\'))
                {
                *pszDateStr = '-';
                }
            else if (*pszDateStr < 30)
                {
                *pszDateStr = '_';
                }

            pszDateStr++;
            }
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION::ConstructPicturesSubDirectory()
//
//  Generate the path for the directory where pictures will be stored
//  in.
//
//  The return path string should be free'd using FreeMemory().
//------------------------------------------------------------------------
char *CCONNECTION::ConstructPicturesSubDirectory( IN DWORD dwExtraChars )
    {
    char *pszTempDirectory = 0;

    char *psz = ::GetImageDirectory();

    if (psz)
        {
        pszTempDirectory = (char*)AllocateMemory( strlen(psz)
                                                + dwExtraChars
                                                + 2 );
        }

    if (pszTempDirectory)
        {
        strcpy(pszTempDirectory,psz);
        }

    // Don't try to free psz !!.

    return pszTempDirectory;
    }

//------------------------------------------------------------------------
//  CCONNECTION::ConstructFullFileName()
//
//  Generate the path + file name that the picture will be stored
//  in. If dwCopyCount is zero, then its just a straight file name.
//  If dwCopyCount is N, then "N_" is prefixed to the file name.
//------------------------------------------------------------------------
CHAR *CCONNECTION::ConstructFullFileName( IN DWORD dwCopyCount )
    {
#   define MAX_DATE   64
#   define MAX_PREFIX 64
    DWORD  dwLen;
    DWORD  dwFileNameLen;
    DWORD  dwPrefixStrLen;
    DWORD  dwExtraChars;
    CHAR  *pszFullFileName = 0;      // Path + file name.
    CHAR  *pszFileName = 0;          // File name only.
    CHAR   szPrefixStr[MAX_PREFIX];

    if (!m_pScepConnection)
        {
        return 0;
        }

    pszFileName = m_pScepConnection->GetFileName();
    if (!pszFileName)
        {
        return 0;
        }

    dwFileNameLen = strlen(pszFileName);

    if (dwCopyCount == 0)
        {
        dwExtraChars = 1 + dwFileNameLen;  // Extra 1 for the "\".
        }
    else
        {
        _itoa(dwCopyCount,szPrefixStr,10);
        strcat(szPrefixStr,SZ_UNDERSCORE);
        dwPrefixStrLen = strlen(szPrefixStr);
        dwExtraChars = 1 + dwFileNameLen + dwPrefixStrLen;
        }


    pszFullFileName = CCONNECTION::ConstructPicturesSubDirectory(dwExtraChars);
    if (!pszFullFileName)
        {
        return 0;
        }

    if (dwCopyCount == 0)
        {
        strcat(pszFullFileName,SZ_SLASH);
        strcat(pszFullFileName,pszFileName);
        }
    else
        {
        strcat(pszFullFileName,SZ_SLASH);
        strcat(pszFullFileName,szPrefixStr);
        strcat(pszFullFileName,pszFileName);
        }

    #ifdef DBG_IO
    WIAS_TRACE((g_hInst,"CCONNECTION::ConstructFullFileName(): return: %s",pszFullFileName));
    #endif

    return pszFullFileName;
    }

//------------------------------------------------------------------------
//  CCONNECTION::Impersonate()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::Impersonate()
    {
    DWORD   dwStatus = NO_ERROR;
    HANDLE  hToken = ::GetUserToken();

    if (hToken)
        {
        if (!ImpersonateLoggedOnUser(hToken))
            {
            dwStatus = GetLastError();
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"IrXfer: IrTran-P: CreatePictureFile(): Impersonate Failed: %d\n",dwStatus));
            #endif
            }
        else
            {
            m_fImpersonating = TRUE;
            #ifdef DBG_IMPERSONATE
            WIAS_ERROR((g_hInst,"CCONNECTION::Impersonate(): Impersonate\n"));
            #endif
            }
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::RevertToSelf()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::RevertToSelf()
    {
    DWORD   dwStatus = NO_ERROR;
    HANDLE  hToken = ::GetUserToken();

    if ((hToken) && (m_fImpersonating))
        {
        ::RevertToSelf();
        m_fImpersonating = FALSE;
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::CreatePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::CreatePictureFile()
    {
    DWORD  dwStatus = NO_ERROR;
    CHAR  *pszFile;
    CHAR  *pszPathPlusFileName = 0;
    DWORD  dwFlags = FILE_ATTRIBUTE_NORMAL;

    // Make sure that the counters start at zero:
    m_dwUpfBytes = 0;
    m_dwBytesWritten = 0;

    // See if we already have an image file open, if yes then
    // close it.
    if (m_hFile != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hFile);
        }

    // Get the full path + name for the file we will create.
    // Note, that ConstructFullFileName() may create a subdirectory,
    // so it needs to be done after the impersonation...
    // This is important if we have a remoted \My Documents\
    // directory.

    DWORD  dwCopyCount;
    for (dwCopyCount=0; dwCopyCount<=MAX_COPYOF_TRIES; dwCopyCount++)
        {
        pszPathPlusFileName = ConstructFullFileName(dwCopyCount);
        if (!pszPathPlusFileName)
            {
            return ERROR_SCEP_CANT_CREATE_FILE;
            }

        //
        // Try to create new image (JPEG) file:
        //
        m_hFile = CreateFile( pszPathPlusFileName,
                              GENERIC_WRITE,
                              FILE_SHARE_READ, // Share mode.
                              0,               // Security attr (BUGBUG).
                              CREATE_NEW,      // Open mode.
                              dwFlags,         // Attributes.
                              0 );             // Template file (none).

        if (m_hFile != INVALID_HANDLE_VALUE)
            {
            // This is the success exit point.
            m_pszPathPlusFileName = pszPathPlusFileName;
            break;
            }
        else
            {
            dwStatus = GetLastError();
            if (dwStatus != ERROR_FILE_EXISTS)
                {
                #ifdef DBG_TARGET_DIR
                WIAS_ERROR((g_hInst,"CCONNECTION::CreatePictureFile(): CreateFile(): %s Failed: %d",pszPathPlusFileName,dwStatus));
                #endif
                FreeMemory(pszPathPlusFileName);
                break;
                }

            // If we get here, then then a picture file by that name
            // alreay exists, so try again...
            FreeMemory(pszPathPlusFileName);
            }
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::SetPictureFileTime()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::SetPictureFileTime( IN FILETIME *pFileTime )
    {
    DWORD dwStatus = NO_ERROR;

    if (!pFileTime)
        {
        return dwStatus;  // Empty case, no time to set.
        }

    if (!SetFileTime(m_hFile,pFileTime,pFileTime,pFileTime))
        {
        dwStatus = GetLastError();

        WIAS_ERROR((g_hInst,"IrTranP: SetFileTime() Failed: %d",dwStatus));
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::WritePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::WritePictureFile( IN  UCHAR       *pBuffer,
                                     IN  DWORD        dwBufferSize,
                                     OUT CIOPACKET  **ppIoPacket )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwOffset = m_dwBytesWritten;
    DWORD  dwBytesToWrite;
    LONG   lPendingWrites;

    *ppIoPacket = 0;

    CIOPACKET *pIoPacket = new CIOPACKET;

    if (!pIoPacket)
        {
        return ERROR_OUTOFMEMORY;
        }

    dwStatus = pIoPacket->Initialize( PACKET_KIND_WRITE_FILE,
                                      INVALID_SOCKET,  // ListenSocket
                                      INVALID_SOCKET,  // Camera...
                                      GetIoCompletionPort() );
    if (dwStatus != NO_ERROR)
        {
        delete pIoPacket;
        return dwStatus;
        }

    pIoPacket->SetFileHandle(m_hFile);

    //
    // If we are writing just the JPEG image out of the UPF file,
    // then we don't want to write the first m_dwJpegOffset bytes
    // of the UPF file.
    //
    if ((m_dwUpfBytes >= m_dwJpegOffset) || (m_fSaveAsUPF))
        {
        dwBytesToWrite = dwBufferSize;
        }
    else if ((m_dwUpfBytes + dwBufferSize) > m_dwJpegOffset)
        {
        dwBytesToWrite = (m_dwUpfBytes + dwBufferSize) - m_dwJpegOffset;
        for (DWORD i=0; i<dwBytesToWrite; i++)
            {
            pBuffer[i] = pBuffer[i+m_dwJpegOffset-m_dwUpfBytes];
            }
        }
    else
        {
        dwBytesToWrite = 0;
        }

    //
    // When we start writing the JPEG file we want to cut off the
    // file save writes once we've written out the m_dwJpegSize
    // bytes that are the JPEG image inside of the UPF file.
    //
    if (!m_fSaveAsUPF)
        {
        if (m_dwBytesWritten < m_dwJpegSize)
            {
            if ((m_dwBytesWritten+dwBytesToWrite) > m_dwJpegSize)
                {
                dwBytesToWrite = m_dwJpegSize - m_dwBytesWritten;
                }
            }
        else
            {
            dwBytesToWrite = 0;
            }
        }

    //
    // If there are bytes to actually write, then let's do it.
    //
    if (dwBytesToWrite > 0)
        {
        dwStatus = pIoPacket->PostIoWrite(pBuffer,dwBytesToWrite,dwOffset);

        if (dwStatus == NO_ERROR)
            {
            lPendingWrites = IncrementPendingWrites();
            WIAS_ASSERT(g_hInst, lPendingWrites > 0 );

            m_dwBytesWritten += dwBytesToWrite;

            *ppIoPacket = pIoPacket;
            }
        }

    delete pIoPacket;

    m_dwUpfBytes += dwBufferSize;

    return dwStatus;
    }


//------------------------------------------------------------------------
//  CCONNECTION::DeletePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::DeletePictureFile()
    {
    DWORD  dwStatus = NO_ERROR;

    if (m_hFile == INVALID_HANDLE_VALUE)
        {
        return NO_ERROR;
        }

    CloseHandle(m_hFile);
    m_hFile = INVALID_HANDLE_VALUE;

    if (m_pszPathPlusFileName)
        {
        DeleteFile(m_pszPathPlusFileName);
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::ClosePictureFile()
//
//------------------------------------------------------------------------
DWORD CCONNECTION::ClosePictureFile()
    {
    DWORD  dwStatus = NO_ERROR;

#if FALSE
    if (m_pszPathPlusFileName)
        {
        FreeMemory(m_pszPathPlusFileName);
        m_pszPathPlusFileName = 0;
        }
#endif

    if (m_hFile != INVALID_HANDLE_VALUE)
        {
        if (!CloseHandle(m_hFile))
            {
            dwStatus = GetLastError();
            }

        m_hFile = INVALID_HANDLE_VALUE;
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::IncompleteFile()
//
//  Check to see if we have a complete picture file, if yes, then return
//  FALSE, else return TRUE.
//------------------------------------------------------------------------
BOOL CCONNECTION::IncompleteFile()
    {
    BOOL  fIncomplete = FALSE;

    if (m_fSaveAsUPF)
        {
        // Note: currently save the .UPF file, even if its incomplete.
        // This file mode is set in the registry and is for testing
        // only...
        fIncomplete = FALSE;
        }
    else if (!m_fReceiveComplete)
        {
        fIncomplete = (m_dwBytesWritten < m_dwJpegSize);
        }

    return fIncomplete;
    }

//------------------------------------------------------------------------
//  CCONNECTION::StartProgress()
//
//  Startup the progress bar for the incomming JPEG.
//------------------------------------------------------------------------
DWORD CCONNECTION::StartProgress()
    {
    DWORD  dwStatus = 0;

    if (!m_pIrProgress)
        {
        m_pIrProgress = new CIrProgress;

        if (m_pIrProgress)
            {
            dwStatus = m_pIrProgress->Initialize(g_hInst,IDR_TRANSFER_AVI);
            }
        else
            {
            return E_OUTOFMEMORY;
            }
        }

    if (m_pIrProgress)
        {
        dwStatus = m_pIrProgress->StartProgressDialog();
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::UpdateProgress()
//
//  Update the progress bar's completion display.
//------------------------------------------------------------------------
DWORD CCONNECTION::UpdateProgress()
    {
    DWORD  dwStatus = 0;

    if (m_pIrProgress)
        {
        dwStatus = m_pIrProgress->UpdateProgressDialog( m_dwBytesWritten,
                                                        m_dwJpegSize );
        }

    return dwStatus;
    }

//------------------------------------------------------------------------
//  CCONNECTION::EndProgress()
//
//  File transfer complete, hide the progress bar.
//------------------------------------------------------------------------
DWORD CCONNECTION::EndProgress()
    {
    DWORD  dwStatus = 0;

    if (m_pIrProgress)
        {
        dwStatus = m_pIrProgress->EndProgressDialog();

        delete m_pIrProgress;

        m_pIrProgress = NULL;
        }

    return dwStatus;
    }


//************************************************************************


//------------------------------------------------------------------------
//  CCONNECTION_MAP::CCONNECTION_MAP()
//
//------------------------------------------------------------------------
CCONNECTION_MAP::CCONNECTION_MAP()
    {
    m_dwMapSize = 0;
    m_pMap = 0;

    ZeroMemory(&m_cs, sizeof(m_cs));
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::~CCONNECTION_MAP()
//
//------------------------------------------------------------------------
CCONNECTION_MAP::~CCONNECTION_MAP()
    {
    if (m_pMap)
        {
        DeleteCriticalSection(&m_cs);
        FreeMemory(m_pMap);
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::operator new()
//
//------------------------------------------------------------------------
void *CCONNECTION_MAP::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::operator delete()
//
//------------------------------------------------------------------------
void CCONNECTION_MAP::operator delete( IN void *pObj,
                                       IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);
        }
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Initialize()
//
//------------------------------------------------------------------------
BOOL CCONNECTION_MAP::Initialize( IN DWORD dwNewMapSize )
    {
    if (!dwNewMapSize)
        {
        return FALSE;
        }

    if (!m_dwMapSize)
        {
        m_pMap = (CONNECTION_MAP_ENTRY*)AllocateMemory( dwNewMapSize*sizeof(CONNECTION_MAP_ENTRY) );
        if (!m_pMap)
            {
            return FALSE;
            }

        __try
            {
            if(!InitializeCriticalSectionAndSpinCount(&m_cs, MINLONG))
                {
                FreeMemory(m_pMap);
                m_pMap = NULL;
                return FALSE;
                }
            }
        __except(EXCEPTION_EXECUTE_HANDLER)
            {
                FreeMemory(m_pMap);
                m_pMap = NULL;
                return FALSE;
            }

        m_dwMapSize = dwNewMapSize;

        memset(m_pMap,0,m_dwMapSize*sizeof(CONNECTION_MAP_ENTRY));

        for (DWORD i=0; i<m_dwMapSize; i++)
            {
            m_pMap[i].Socket = INVALID_SOCKET;
            }
        }

    return TRUE;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Lookup()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::Lookup( IN SOCKET Socket )
    {
    DWORD     i;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket == Socket)
            {
            LeaveCriticalSection(&m_cs);
            return m_pMap[i].pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::LookupByServiceName()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::LookupByServiceName( IN char *pszServiceName )
    {
    DWORD        i;
    CCONNECTION *pConnection;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        pConnection = m_pMap[i].pConnection;
        if (  (pConnection)
           && (pConnection->GetServiceName())
           && (!strcmp(pConnection->GetServiceName(),pszServiceName)))
            {
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Add()
//
//------------------------------------------------------------------------
BOOL CCONNECTION_MAP::Add( IN CCONNECTION *pConnection,
                           IN SOCKET       Socket )
    {
    DWORD   i;

    // Only add entries that look valid...
    if ((Socket == 0)||(Socket==INVALID_SOCKET)||(pConnection == 0))
        {
        return FALSE;
        }

    EnterCriticalSection(&m_cs);

    // Look for an empty place in the table:
    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket == INVALID_SOCKET)
            {
            m_pMap[i].Socket = Socket;
            m_pMap[i].pConnection = pConnection;
            LeaveCriticalSection(&m_cs);
            return TRUE;
            }
        }

    // The table is full, expand it...
    DWORD  dwNewMapSize = 3*m_dwMapSize/2;   // 50% bigger.
    CONNECTION_MAP_ENTRY *pMap = (CONNECTION_MAP_ENTRY*)AllocateMemory( dwNewMapSize*sizeof(CONNECTION_MAP_ENTRY) );

    if (!pMap)
        {
        LeaveCriticalSection(&m_cs);
        return FALSE;  // Out of memory...
        }

    memset(pMap,0,dwNewMapSize*sizeof(CONNECTION_MAP_ENTRY));
    for (i=0; i<dwNewMapSize; i++)
        {
        pMap[i].Socket = INVALID_SOCKET;
        }

    for (i=0; i<m_dwMapSize; i++)
        {
        pMap[i].Socket = m_pMap[i].Socket;
        pMap[i].pConnection = m_pMap[i].pConnection;
        }

    pMap[i].Socket = Socket;
    pMap[i].pConnection = pConnection;

    FreeMemory(m_pMap);
    m_pMap = pMap;
    m_dwMapSize = dwNewMapSize;

    LeaveCriticalSection(&m_cs);

    return TRUE;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::Remove()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::Remove( IN SOCKET Socket )
    {
    DWORD        i;
    CCONNECTION *pConnection;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket == Socket)
            {
            pConnection = m_pMap[i].pConnection;
            m_pMap[i].Socket = INVALID_SOCKET;
            m_pMap[i].pConnection = 0;
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
}

//------------------------------------------------------------------------
//  CCONNECTION_MAP::RemoveConnection()
//
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::RemoveConnection( IN CCONNECTION *pConnection )
    {
    DWORD     i;
    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].pConnection == pConnection)
            {
            m_pMap[i].Socket = INVALID_SOCKET;
            m_pMap[i].pConnection = 0;
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
}

//------------------------------------------------------------------------
//  CCONNECTION_MAP::RemoveNext()
//
//  Walk through the connection map and get the next entry, remove the
//  entry from the map as well.
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::RemoveNext()
    {
    DWORD        i;
    CCONNECTION *pConnection;

    EnterCriticalSection(&m_cs);

    for (i=0; i<m_dwMapSize; i++)
        {
        if (m_pMap[i].Socket)
            {
            pConnection = m_pMap[i].pConnection;
            m_pMap[i].Socket = INVALID_SOCKET;
            m_pMap[i].pConnection = 0;
            LeaveCriticalSection(&m_cs);
            return pConnection;
            }
        }

    LeaveCriticalSection(&m_cs);

    return 0;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::ReturnNext()
//
//  Walk through the connection map returning the next entry. To start at
//  the "begining", pass in state equal zero. When you get to the end of
//  the list of connections, return NULL;
//------------------------------------------------------------------------
CCONNECTION *CCONNECTION_MAP::ReturnNext( IN OUT DWORD *pdwState )
    {
    CCONNECTION  *pConnection = NULL;
    EnterCriticalSection(&m_cs);

    if (*pdwState >= m_dwMapSize)
        {
        LeaveCriticalSection(&m_cs);
        return NULL;
        }

    while ((pConnection == NULL) && (*pdwState < m_dwMapSize))
        {
        pConnection = m_pMap[(*pdwState)++].pConnection;
        }

    LeaveCriticalSection(&m_cs);

    return pConnection;
    }

//------------------------------------------------------------------------
//  CCONNECTION_MAP::ReturnNextSocket()
//
//  Walk through the connection map returning the SOCKET associated with
//  the next entry. To start at the "begining", pass in state equal zero.
//  When you get to the end of the list of connections, return
//  INVALID_SOCKET.
//------------------------------------------------------------------------
SOCKET CCONNECTION_MAP::ReturnNextSocket( IN OUT DWORD *pdwState )
    {
    SOCKET  Socket = INVALID_SOCKET;
    EnterCriticalSection(&m_cs);

    if (*pdwState >= m_dwMapSize)
        {
        LeaveCriticalSection(&m_cs);
        return INVALID_SOCKET;
        }

    while ((Socket == INVALID_SOCKET) && (*pdwState < m_dwMapSize))
        {
        Socket = m_pMap[(*pdwState)++].Socket;
        }

    LeaveCriticalSection(&m_cs);

    return Socket;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\irtranp.cpp ===
//---------------------------------------------------------------------
//  Copyright (c)1998-1999 Microsoft Corporation, All Rights Reserved.
//
//  irtranp.cpp
//
//  This file holds the main entry points for the IrTran-P service.
//  IrTranP() is the entry point that starts the listening, and
//  UninitializeIrTranP() shuts it down (and cleans everything up).
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//    Edward Reus (edwardr)     08-27-99   Finish modifications for
//                                         WIA Millennium port.
//
//  Note: Currently the Millennium version will only listen on IrCOMM.
//
//---------------------------------------------------------------------

#include "precomp.h"
#include <mbstring.h>

#define SZ_REG_KEY_IRTRANP     "Control Panel\\Infrared\\IrTranP"
#define SZ_REG_DISABLE_IRCOMM  "DisableIrCOMM"

//---------------------------------------------------------------------
// Listen ports array:
//---------------------------------------------------------------------

typedef struct _LISTEN_PORT
    {
    char  *pszService;      // Service to start.
    BOOL   fIsIrCOMM;       // TRUE iff IrCOMM 9-wire mode.
    DWORD  dwListenStatus;  // Status for port.
    } LISTEN_PORT;

static LISTEN_PORT aListenPorts[] =
    {
    // Service Name   IrCOMM  ListenStatus
    {IRCOMM_9WIRE,    TRUE,   STATUS_STOPPED },
//  {IRTRANP_SERVICE, FALSE,  STATUS_STOPPED },
//  {IR_TEST_SERVICE, FALSE,  STATUS_STOPPED }, 2nd test listen port.
    {0,               FALSE,  STATUS_STOPPED }
    };

#define  INDEX_IRCOMM           0
#define  INDEX_IRTRANPV1        1

CCONNECTION_MAP  *g_pConnectionMap = 0;
CIOSTATUS        *g_pIoStatus = 0;
HANDLE            g_hShutdownEvent;

BOOL              g_fShuttingDownTRANPThread = FALSE;
DWORD             g_dwTRANPThreadId = 0;

extern HINSTANCE  g_hInst;   // Handle to ircamera.dll USD

//---------------------------------------------------------------------
//  Globals:
//---------------------------------------------------------------------

HANDLE     g_UserToken = NULL;
HKEY       g_hUserKey = NULL;
BOOL       g_fDisableIrTranPv1 = FALSE;
BOOL       g_fDisableIrCOMM = FALSE;
BOOL       g_fExploreOnCompletion = TRUE;
BOOL       g_fSaveAsUPF = FALSE;
BOOL       g_fAllowReceives = TRUE;

char      *g_pszTempPicturesFolder = 0;

BOOL       g_fWSAStartupCalled = FALSE;

void      *g_pvIrUsdDevice = 0;  // WIA IrUsdDevice Object.


//---------------------------------------------------------------------
// GetUserToken()
//
// The "main" part of irxfer.dll (in ..\irxfer) maintains a token
// for user that is currently logged in (if any).
//---------------------------------------------------------------------
HANDLE GetUserToken()
    {
    return g_UserToken;
    }

//---------------------------------------------------------------------
// GetUserKey()
//
//---------------------------------------------------------------------
HKEY GetUserKey()
    {
    return g_hUserKey;
    }

//---------------------------------------------------------------------
// GetModule()
//
//---------------------------------------------------------------------
HINSTANCE GetModule()
    {
    return g_hInst;
    }

//---------------------------------------------------------------------
// CheckSaveAsUPF()
//
// Return TRUE iff pictures need to be saved in .UPF (as opposed to
// .JPEG) format.
//---------------------------------------------------------------------
BOOL CheckSaveAsUPF()
    {
    return g_fSaveAsUPF;
    }

//---------------------------------------------------------------------
// CheckExploreOnCompletion()
//
// Return TRUE iff we want to popup an explorer on the directory
// containing the newly transfered pictures.
//---------------------------------------------------------------------
BOOL CheckExploreOnCompletion()
    {
    return g_fExploreOnCompletion;
    }


/* FlushInputQueue is a private routine to collect and dispatch all
 * messages in the input queue.  It returns TRUE if a WM_QUIT message
 * was detected in the queue, FALSE otherwise.
 */
BOOL FlushInputQueue(VOID)
{
    MSG msgTemp;
    while (PeekMessage(&msgTemp, NULL, 0, 0, PM_REMOVE)) {
        DispatchMessage(&msgTemp);

        // If we see a WM_QUIT in the queue, we need to do the same
        // sort of thing that a modal dialog does:  break out of our
        // waiting, and repost the WM_QUIT to the queue so that the
        // next message loop up in the app will also see it.
        if (msgTemp.message == WM_QUIT) {
            PostQuitMessage((int)msgTemp.wParam);
            return TRUE;
        }
    }
    return FALSE;
}

/* WaitAndYield() waits for the specified object using
 * MsgWaitForMultipleObjects.  If messages are received,
 * they are dispatched and waiting continues.  The return
 * value is the same as from MsgWaitForMultipleObjects.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout)
{
    DWORD dwTickCount, dwWakeReason, dwTemp;

    do {
        /* Flush any messages before we wait.  This is because
         * MsgWaitForMultipleObjects will only return when NEW
         * messages are put in the queue.
         */
        if (FlushInputQueue()) {
            dwWakeReason = WAIT_TIMEOUT;
            break;
        }

        // in case we handle messages, we want close to a true timeout
        if ((dwTimeout != 0) &&
            (dwTimeout != (DWORD)-1)) {
            // if we can timeout, store the current tick count
            // every time through
            dwTickCount = GetTickCount();
        }
        dwWakeReason = MsgWaitForMultipleObjects(1,
                                                 &hObject,
                                                 FALSE,
                                                 dwTimeout,
                                                 QS_ALLINPUT);
        // if we got a message, dispatch it, then try again
        if (dwWakeReason == 1) {
            // if we can timeout, see if we did before processing the message
            // that way, if we haven't timed out yet, we'll get at least one
            // more shot at the event
            if ((dwTimeout != 0) &&
                (dwTimeout != (DWORD)-1)) {
                if ((dwTemp = (GetTickCount()-dwTickCount)) >= dwTimeout) {
                    // if we timed out, make us drop through
                    dwWakeReason = WAIT_TIMEOUT;
                } else {
                    // subtract elapsed time from timeout and continue
                    // (we don't count time spent dispatching message)
                    dwTimeout -= dwTemp;
                }
            }
            if (FlushInputQueue()) {
                dwWakeReason = WAIT_TIMEOUT;
                break;
            }
        }
    } while (dwWakeReason == 1);

    return dwWakeReason;
}


//---------------------------------------------------------------------
// GetImageDirectory();
//
// This is the temporary directory where the pictures sent by the
// camera will be held. WIA will then "down load" these to their
// final destination (usually this will be My Pictures).
//
//---------------------------------------------------------------------
CHAR *GetImageDirectory()
    {
    char  *pszPicturesFolder;
    char   szTempFolder[1+MAX_PATH];
    DWORD  dwPicturesFolderLen;
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwLen;


    if (!g_pszTempPicturesFolder)
        {
        dwLen = GetTempPath(MAX_PATH,szTempFolder);

        if ((!dwLen)||(dwLen > MAX_PATH))
            {
            dwStatus = GetLastError();
            WIAS_TRACE((g_hInst,"GetUserDirectroy(): GetTempPath() failed: %d",dwStatus));
            return NULL;
            }

        //
        // Make sure the directory exists:
        //
        if (!CreateDirectory(szTempFolder,0))
            {
            dwStatus = GetLastError();
            if ( (dwStatus == ERROR_ALREADY_EXISTS)
               || (dwStatus == ERROR_ACCESS_DENIED) )
                {
                dwStatus = NO_ERROR;
                }
            else if (dwStatus != NO_ERROR)
                {
                return 0;
                }
            }

        //
        // Construct the subdirectory path string that will actually hold the pictures:
        // This will be something like: C:\temp\irtranp
        //
        dwPicturesFolderLen = sizeof(CHAR)*( strlen(szTempFolder)
                                           + sizeof(SZ_SLASH)
                                           + sizeof(SZ_SUBDIRECTORY)
                                           + 1 );

        g_pszTempPicturesFolder = (CHAR*)AllocateMemory(dwPicturesFolderLen);

        if (!g_pszTempPicturesFolder)
            {
            return 0;    // Memory allocation failed!
            }

        strcpy(g_pszTempPicturesFolder,szTempFolder);
        if (szTempFolder[dwLen-1] != SLASH)
            {
            strcat(g_pszTempPicturesFolder,SZ_SLASH);
            }
        strcat(g_pszTempPicturesFolder,SZ_SUBDIRECTORY);

        //
        // Make sure the subdirectory exists:
        //
        if (!CreateDirectory(g_pszTempPicturesFolder,0))
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_ALREADY_EXISTS)
                {
                dwStatus = NO_ERROR;
                }
            else if (dwStatus != NO_ERROR)
                {
                return 0;
                }
            }
        }

    pszPicturesFolder = g_pszTempPicturesFolder;

    return pszPicturesFolder;
    }

//---------------------------------------------------------------------
// ReceivesAllowed()
//
// Using the IR configuration window (available from the wireless network
// icon in the control panel) you can disable communications with IR
// devices. This function returns the state of IR communications, FALSE
// is disabled, TRUE is enabled.
//---------------------------------------------------------------------
BOOL ReceivesAllowed()
    {
    return g_fAllowReceives;
    }

//---------------------------------------------------------------------
// SetupListenConnection()
//
//---------------------------------------------------------------------
DWORD SetupListenConnection( IN  CHAR  *pszService,
                             IN  BOOL   fIsIrCOMM,
                             IN  HANDLE hIoCompletionPort )
    {
    DWORD        dwStatus = NO_ERROR;
    CIOPACKET   *pIoPacket;
    CCONNECTION *pConnection;

    // See if the connection already exists:
    if (g_pConnectionMap->LookupByServiceName(pszService))
        {
        return NO_ERROR;
        }

    // Makeup and initialize a new connection object:
    pConnection = new CCONNECTION;
    if (!pConnection)
        {
        return E_OUTOFMEMORY;
        }

    dwStatus = pConnection->InitializeForListen( pszService,
                                                 fIsIrCOMM,
                                                 hIoCompletionPort );
    if (dwStatus)
        {
        WIAS_ERROR((g_hInst,"SetupForListen(): InitializeForListen(%s) failed: %d",pszService, dwStatus));
        return dwStatus;
        }

    pIoPacket = new CIOPACKET;
    if (!pIoPacket)
        {
        WIAS_ERROR((g_hInst,"SetupForListen(): new CIOPACKET failed"));
        delete pConnection;
        return E_OUTOFMEMORY;
        }

    // Setup the IO packet:
    dwStatus = pIoPacket->Initialize( PACKET_KIND_LISTEN,
                                      pConnection->GetListenSocket(),
                                      INVALID_SOCKET,
                                      hIoCompletionPort );
    if (dwStatus != NO_ERROR)
        {
        return dwStatus;
        }

    pConnection->SetSocket(pIoPacket->GetSocket());

    if (!g_pConnectionMap->Add(pConnection,pIoPacket->GetListenSocket()))
        {
        WIAS_ERROR((g_hInst,"SetupForListen(): Add(pConnection) ConnectionMap Failed."));
        return 1;
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// TeardownListenConnection()
//
//---------------------------------------------------------------------
DWORD TeardownListenConnection( IN char *pszService )
    {
    DWORD        dwStatus = NO_ERROR;
    CCONNECTION *pConnection;

    // Look for the connection associated with the service name:
    pConnection = g_pConnectionMap->LookupByServiceName(pszService);

    if (pConnection)
        {
        g_pConnectionMap->RemoveConnection(pConnection);
        pConnection->CloseSocket();
        pConnection->CloseListenSocket();
        }

    return dwStatus;
    }


//---------------------------------------------------------------------
// EnableDisableIrCOMM()
//
//---------------------------------------------------------------------
DWORD EnableDisableIrCOMM( IN BOOL fDisable )
   {
   DWORD     dwStatus;


   if (fDisable)
       {
       dwStatus = TeardownListenConnection(
                      aListenPorts[INDEX_IRCOMM].pszService);
       WIAS_ERROR((g_hInst,"IrTranP: TeardownListenConnection(%s): %d", aListenPorts[INDEX_IRCOMM].pszService,dwStatus));
       }
   else
       {
       dwStatus = SetupListenConnection(
                      aListenPorts[INDEX_IRCOMM].pszService,
                      aListenPorts[INDEX_IRCOMM].fIsIrCOMM,
                      g_pIoStatus->GetIoCompletionPort() );

       WIAS_TRACE((g_hInst,"IrTranP: SetupListenConnection(%s): %d", aListenPorts[INDEX_IRCOMM].pszService, dwStatus));
       }

   return dwStatus;
   }

//---------------------------------------------------------------------
// EnableDisableIrTranPv1()
//
//---------------------------------------------------------------------
DWORD EnableDisableIrTranPv1( IN BOOL fDisable )
   {
   DWORD  dwStatus;

   if (fDisable)
       {
       dwStatus = TeardownListenConnection(
                      aListenPorts[INDEX_IRTRANPV1].pszService);
       }
   else
       {
       dwStatus = SetupListenConnection(
                      aListenPorts[INDEX_IRTRANPV1].pszService,
                      aListenPorts[INDEX_IRTRANPV1].fIsIrCOMM,
                      g_pIoStatus->GetIoCompletionPort() );
       }

   return dwStatus;
   }

//---------------------------------------------------------------------
// IrTranp()
//
//---------------------------------------------------------------------
DWORD WINAPI IrTranP( IN void *pvIrUsdDevice )
    {
    int     i = 0;
    WSADATA wsaData;
    WORD    wVersion = MAKEWORD(1,1);
    DWORD   dwStatus;
    CCONNECTION *pConnection;

    g_dwTRANPThreadId = ::GetCurrentThreadId();

    //
    // Initialize Memory Management:
    //
    dwStatus = InitializeMemory();
    if (dwStatus)
        {
        WIAS_ERROR((g_hInst,"IrTranP(): InitializeMemory() failed: %d\n",dwStatus));
        return dwStatus;
        }

    //
    // This directory will be set as needed. It is only non-null in the case
    // where we are re-starting the IrTran-P thread:
    //
    if (g_pszTempPicturesFolder)
        {
        FreeMemory(g_pszTempPicturesFolder);
        g_pszTempPicturesFolder = 0;
        }

    //
    // Initialize Winsock2 if neccessary:
    //
    if (!g_fWSAStartupCalled)
        {
        if (WSAStartup(wVersion,&wsaData) == SOCKET_ERROR)
            {
            dwStatus = WSAGetLastError();
            WIAS_ERROR((g_hInst,"WSAStartup(0x%x) failed with error %d\n", wVersion, dwStatus ));
            return dwStatus;
            }

        g_fWSAStartupCalled = TRUE;
        }

    // Event used to signal back to "main" thread that the
    // IrTran-P thread is exiting.
    //
    // NoSecurity, Auto-Reset, Initially Not Signaled, No Name.
    //
    g_hShutdownEvent = CreateEventA( NULL, FALSE, FALSE, NULL );

    if (!g_hShutdownEvent)
        {
        dwStatus = GetLastError();
        WIAS_ERROR((g_hInst,"IrTranP(): CreateEvent() Failed: %d",dwStatus));
        return dwStatus;
        }

    // Create/initialize a object to keep track of the threading...
    g_pIoStatus = new CIOSTATUS;
        if (!g_pIoStatus)
        {
        WIAS_ERROR((g_hInst,"new CIOSTATUS failed."));
        return E_OUTOFMEMORY;
            }

    dwStatus = g_pIoStatus->Initialize();
    if (dwStatus != NO_ERROR)
        {
        WIAS_ERROR((g_hInst,"g_pIoStatus->Initialize(): Failed: %d",dwStatus));
        return dwStatus;
        }

    // Need to keep track of the open sockets and the number of
    // pending IOs on each...
    g_pConnectionMap = new CCONNECTION_MAP;
    if (!g_pConnectionMap)
        {
        WIAS_ERROR((g_hInst,"new CCONNECTION_MAP failed."));
        return E_OUTOFMEMORY;
        }

    if (!g_pConnectionMap->Initialize())
        {
        return 1;
        }

    // Create a CIOPACKET for each defined listen port. These are
    // what we will listen on.

    //
    // BUGBUG Should we really loop indefintely setting up connection or establish some limit on retries ? VS
    //
    while (!g_fShuttingDownTRANPThread )
        {
        dwStatus = SetupListenConnection(
                        aListenPorts[INDEX_IRCOMM].pszService,
                        aListenPorts[INDEX_IRCOMM].fIsIrCOMM,
                        g_pIoStatus->GetIoCompletionPort() );

        if (dwStatus)
            {
            WIAS_TRACE((g_hInst,"SetupListenConnection(%s) Status: %d",aListenPorts[i].pszService,dwStatus));
            //
            // BUGBUG Analyze error and stop processing if it doesn't make sense !!! VS
            //
            }
        else
            {
            WIAS_TRACE((g_hInst,"SetupListenConnection(%s) Ready",aListenPorts[i].pszService));
            aListenPorts[INDEX_IRCOMM].dwListenStatus = STATUS_RUNNING;
            break;
            }

        // Wait for timeout period, but wake up if we need to stop
        // Sleep(5000);
        WaitAndYield(g_hShutdownEvent,5000);
        }

    if (!g_fShuttingDownTRANPThread) {

        //
        // Wait on incomming connections and data, then process it.
        //
        g_pvIrUsdDevice = pvIrUsdDevice;

        dwStatus = ProcessIoPackets(g_pIoStatus);

    }

    //
    // Shutting down
    //
    g_pvIrUsdDevice = 0;

    WIAS_TRACE((g_hInst,"ProcessIoPackets(): dwStatus: %d",dwStatus));

    //
    // Cleanup and close any open handles:
    //
    while (pConnection=g_pConnectionMap->RemoveNext())
        {
        delete pConnection;
        }

    delete g_pConnectionMap;
    g_pConnectionMap = 0;
    delete g_pIoStatus;
    g_pIoStatus = 0;

    // Signal the shutdown event that the IrTran-P thread is exiting:
    if (g_hShutdownEvent)
        {
        SetEvent(g_hShutdownEvent);
        }

    return dwStatus;
    }

//---------------------------------------------------------------------
// IrTranPEnableIrCOMMFailed()
//
//---------------------------------------------------------------------
void IrTranPEnableIrCOMMFailed( DWORD dwErrorCode )
    {
    DWORD  dwStatus;

    // An error occured on enable, make sure the registry value
    // is set to disable (so UI will match the actual state).
    HKEY      hKey = 0;
    HKEY      hUserKey = GetUserKey();
    HANDLE    hUserToken = GetUserToken();
    HINSTANCE hInstance = GetModule();
    DWORD     dwDisposition;

    if (RegCreateKeyEx(hUserKey,
                       SZ_REG_KEY_IRTRANP,
                       0,              // reserved MBZ
                       0,              // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_SET_VALUE,
                       0,              // security attributes
                       &hKey,
                       &dwDisposition))
        {
        WIAS_TRACE((g_hInst,"IrTranP: RegCreateKeyEx(): '%' failed %d", SZ_REG_KEY_IRTRANP, GetLastError()));
        }

    if (  (hKey)
       && (hUserToken)
       && (::ImpersonateLoggedOnUser(hUserToken)))
        {
        DWORD  dwDisableIrCOMM = TRUE;
        dwStatus = RegSetValueEx(hKey,
                                 SZ_REG_DISABLE_IRCOMM,
                                 0,
                                 REG_DWORD,
                                 (UCHAR*)&dwDisableIrCOMM,
                                 sizeof(dwDisableIrCOMM) );
        if (dwStatus != ERROR_SUCCESS)
            {
            WIAS_TRACE((g_hInst,"IrTranP: Can't set DisableIrCOMM to TRUE in registry. Error: %d",dwStatus));
            }

        ::RevertToSelf();
        }

    if (hKey)
        {
        RegCloseKey(hKey);
        }

#if FALSE
    WCHAR *pwszMessage = NULL;
    WCHAR *pwszCaption = NULL;
    DWORD  dwFlags = ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                     | FORMAT_MESSAGE_IGNORE_INSERTS
                     | FORMAT_MESSAGE_FROM_HMODULE);

    dwStatus = FormatMessageW(dwFlags,
                              hInstance,
                              CAT_IRTRANP,
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPTSTR)(&pwszCaption),
                              0,     // Minimum size to allocate.
                              NULL); // va_list args...
    if (dwStatus == 0)
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: FormatMessage() failed: %d\n",GetLastError() );
        #endif
        return;
        }

    //
    // Hack: Make sure the caption doesn't end with newline-formfeed...
    //
    WCHAR  *pwsz = pwszCaption;

    while (*pwsz)
        {
        if (*pwsz < 0x20)   // 0x20 is always a space...
            {
            *pwsz = 0;
            break;
            }
        else
            {
            pwsz++;
            }
        }


    WCHAR   wszErrorCode[20];
    WCHAR  *pwszErrorCode = (WCHAR*)wszErrorCode;

    wsprintfW(wszErrorCode,L"%d",dwErrorCode);

    dwFlags = ( FORMAT_MESSAGE_ALLOCATE_BUFFER
              | FORMAT_MESSAGE_ARGUMENT_ARRAY
              | FORMAT_MESSAGE_FROM_HMODULE);

    dwStatus = FormatMessageW(dwFlags,
                              hInstance,
                              MC_IRTRANP_IRCOM_FAILED,
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPTSTR)(&pwszMessage),
                              0,    // Minimum size to allocate.
                              (va_list*)&pwszErrorCode);
    if (dwStatus == 0)
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: FormatMessage() failed: %d\n",GetLastError() );
        #endif

        if (pwszMessage)
            {
            LocalFree(pwszMessage);
            }

        return;
        }

    dwStatus = MessageBoxW( NULL,
                            pwszMessage,
                            pwszCaption,
                            (MB_OK|MB_ICONERROR|MB_SETFOREGROUND|MB_TOPMOST) );

    if (pwszMessage)
        {
        LocalFree(pwszMessage);
        }

    if (pwszCaption)
        {
        LocalFree(pwszCaption);
        }
#endif
    }

//---------------------------------------------------------------------
// UninitializeIrTranP()
//
//---------------------------------------------------------------------
BOOL UninitializeIrTranP( HANDLE hThread )
    {
    BOOL   fSuccess = TRUE;
    DWORD  dwStatus;
    HANDLE hIoCP = g_pIoStatus->GetIoCompletionPort();

    g_fShuttingDownTRANPThread = TRUE;

    // Inform TRANP thread it has to die
    ::PostThreadMessage(g_dwTRANPThreadId,WM_QUIT,0,0);

    if (hIoCP != INVALID_HANDLE_VALUE)
        {
        if (!PostQueuedCompletionStatus(hIoCP,0,IOKEY_SHUTDOWN,0))
            {
            // Unexpected error...
            dwStatus = GetLastError();
            }

        while (WAIT_TIMEOUT == WaitForSingleObject(g_hShutdownEvent,0))
            {
            Sleep(100);
            }

        CloseHandle(g_hShutdownEvent);
        }

    //
    // TRANP thread should be dead by now . In case it isn't wait on it's handle and terminate
    // Otherwise we have a small chance of unloading DLL before thread is dead, shutting down WIA service
    //
    dwStatus = ::WaitForSingleObject(hThread,100);
    if (dwStatus == WAIT_TIMEOUT) {
        // Have to be rude
        // BUGBUG Assert
        ::TerminateThread(hThread,NOERROR);
    }

    // Shutdown memory management:
    dwStatus = UninitializeMemory();

    return fSuccess;
    }


#ifdef RUN_AS_EXE

//---------------------------------------------------------------------
// main()
//
//---------------------------------------------------------------------
int __cdecl main( int argc, char **argv )
    {
    DWORD  dwStatus;

    printf("IrTran-P: Start\n");

    dwStatus = IrTranP( NULL );

    if (dwStatus)
        {
        printf("IrTran-P: Status: 0x%x (%d)\n",dwStatus,dwStatus);
        }

    return 0;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\conn.h ===
//---------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  conn.h
//
//  Connection mapping between sockets and CCONNECTION objects.
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//---------------------------------------------------------------

#ifndef __CONN_HXX__
#define __CONN_HXX__

#define  MAX_MAP_ENTRIES        16

//---------------------------------------------------------------
//  Class CCONNECTION
//---------------------------------------------------------------

class CCONNECTION
{
public:
    // CCONNECTION();
    CCONNECTION( DWORD  dwKind = PACKET_KIND_LISTEN,
                 SOCKET Socket = 0,
                 HANDLE hIoCP  = INVALID_HANDLE_VALUE,
                 CSCEP_CONNECTION *pScepConnection = 0,
                 BOOL   fSaveAsUPF = FALSE );

    ~CCONNECTION();

    void   *operator new( IN size_t Size );

    void    operator delete( IN void   *pObj,
                             IN size_t  Size );

    DWORD   InitializeForListen( IN char  *pszServiceName,
                                 IN BOOL   fIsIrCOMM,
                                 IN HANDLE hIoCP );

    char   *GetServiceName();
    char   *GetPathPlusFileName();

    void    SetKind( DWORD dwKind );
    DWORD   GetKind();

    void    SetSocket( SOCKET Socket );
    SOCKET  GetSocket();
    DWORD   ShutdownSocket();
    void    CloseSocket();

    void    SetListenSocket( SOCKET ListenSocket );
    SOCKET  GetListenSocket();
    void    CloseListenSocket();

    void    SetIoCompletionPort( HANDLE hIoCP );
    HANDLE  GetIoCompletionPort();

    void    SetScepConnection( CSCEP_CONNECTION *pScepConnection );
    CSCEP_CONNECTION *GetScepConnection();

    void    SetJpegOffsetAndSize( DWORD dwOffset,
                                  DWORD dwSize );

    LONG    IncrementPendingReads();
    LONG    DecrementPendingReads();

    LONG    IncrementPendingWrites();
    LONG    DecrementPendingWrites();

    LONG    NumPendingIos();

    DWORD   PostMoreIos( CIOPACKET *pIoPacket = NULL );

    DWORD   SendPdu( IN  SCEP_HEADER *pPdu,
                     IN  DWORD        dwPduSize,
                     OUT CIOPACKET  **ppIoPacket );

    static  char  *ConstructPicturesSubDirectory( IN DWORD dwExtraChars = 0 );

    char   *ConstructFullFileName( IN DWORD dwCopyCount );

    BOOL    CheckSaveAsUPF();

    DWORD   Impersonate();

    DWORD   RevertToSelf();

    DWORD   CreatePictureFile();

    DWORD   SetPictureFileTime( IN FILETIME *pFileTime );

    DWORD   WritePictureFile( IN  UCHAR      *pBuffer,
                              IN  DWORD       dwBufferSize,
                              OUT CIOPACKET **ppIoPacket );

    DWORD   DeletePictureFile();
    DWORD   ClosePictureFile();
    BOOL    IncompleteFile();

    void    SetReceiveComplete( IN BOOL fReceiveComplete );

    DWORD   StartProgress();
    DWORD   UpdateProgress();
    DWORD   EndProgress();

private:
    static void CleanupDateString( IN OUT char *pszDateStr );

    DWORD  m_dwKind;
    char  *m_pszServiceName;   // Service name (for Listen Sockets).
    SOCKET m_ListenSocket;
    SOCKET m_Socket;
    HANDLE m_hFile;
    char  *m_pszPathPlusFileName;
    DWORD  m_dwFileBytesWritten;
    LONG   m_lMaxPendingReads;
    LONG   m_lPendingReads;
    LONG   m_lMaxPendingWrites;
    LONG   m_lPendingWrites;
    DWORD  m_dwJpegOffset;     // Offset in UPF file of JPEG image.
    DWORD  m_dwJpegSize;       // Size of JPEG image in UPF file.
    BOOL   m_fSaveAsUPF;       // If TRUE, write the entire UPF file.
    DWORD  m_dwUpfBytes;       // Total UPF bytes read in from Camera.
    DWORD  m_dwBytesWritten;   // Actual number of bytes written to disk.
    BOOL   m_fReceiveComplete; // Set to TRUE when a SCEP disconnect 
                               //   packet is received from the camera.
    BOOL   m_fImpersonating;   // TRUE iff we are currently impersonating.

    CIrProgress      *m_pIrProgress;     // Progress bar during receive.
    CSCEP_CONNECTION *m_pScepConnection; // SCEP protocol object.

    EXECUTION_STATE   m_ExecutionState;  // Use to tell the system not to
                                         // hibernate during file transfer.
};

//---------------------------------------------------------------
//  Class CCONNECTION_MAP
//---------------------------------------------------------------

typedef struct _CONNECTION_MAP_ENTRY
{
    SOCKET       Socket;
    CCONNECTION *pConnection;
} CONNECTION_MAP_ENTRY;

class CCONNECTION_MAP
{
public:

	CCONNECTION_MAP();
	~CCONNECTION_MAP();

    void *operator new( IN size_t Size );

    void  operator delete( IN void   *pObj,
                           IN size_t  Size );

	BOOL  Initialize( DWORD dwMapSize = MAX_MAP_ENTRIES );

	// Lookup
	CCONNECTION *Lookup( IN SOCKET Socket );

    // Lookup Connection by name:
    CCONNECTION *LookupByServiceName( IN char *pszServiceName );

	// Add a new (value,key) pair
    BOOL Add( IN CCONNECTION *pConnection,
              IN SOCKET       Socket );

    // Remove an entry from the mapping
    CCONNECTION *Remove( IN SOCKET Socket );
    CCONNECTION *RemoveConnection( IN CCONNECTION *pConnection );

    // Remove the "next" entry from the mapping
    CCONNECTION *RemoveNext();

    // Walk through all the connections (set State to 0 for "first").
    CCONNECTION *ReturnNext( IN OUT DWORD *pdwState );
    SOCKET       ReturnNextSocket( IN OUT DWORD *pdwState );

private:
    CRITICAL_SECTION      m_cs;
    DWORD                 m_dwMapSize;
    CONNECTION_MAP_ENTRY *m_pMap;
};

//---------------------------------------------------------------
//  CCONNECTION::GetServiceName()
//---------------------------------------------------------------
inline char *CCONNECTION::GetServiceName()
    {
    return m_pszServiceName;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetPathPlusFileName()
//---------------------------------------------------------------
inline char *CCONNECTION::GetPathPlusFileName()
    {
    return m_pszPathPlusFileName;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetKind()
//---------------------------------------------------------------
inline void CCONNECTION::SetKind( DWORD dwKind )
    {
    m_dwKind = dwKind;
    if (m_dwKind == PACKET_KIND_LISTEN)
       {
       m_lMaxPendingReads = MAX_PENDING_LISTEN;
       }
    else if (m_dwKind == PACKET_KIND_READ)
       {
       m_lMaxPendingReads = MAX_PENDING_READ;
       }
    }

//---------------------------------------------------------------
//  CCONNECTION::GetKind()
//---------------------------------------------------------------
inline DWORD CCONNECTION::GetKind()
    {
    return m_dwKind;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetSocket()
//---------------------------------------------------------------
inline void CCONNECTION::SetSocket( SOCKET Socket )
    {
    m_Socket = Socket;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetSocket()
//---------------------------------------------------------------
inline SOCKET CCONNECTION::GetSocket()
    {
    return m_Socket;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetListenSocket()
//---------------------------------------------------------------
inline void CCONNECTION::SetListenSocket( SOCKET ListenSocket )
    {
    m_ListenSocket = ListenSocket;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetListenSocket()
//---------------------------------------------------------------
inline SOCKET CCONNECTION::GetListenSocket()
    {
    return m_ListenSocket;
    }

//---------------------------------------------------------------
//  CCONNECTION::IncrementPendingReads()
//---------------------------------------------------------------
inline LONG CCONNECTION::IncrementPendingReads()
    {
    return InterlockedIncrement(&m_lPendingReads);
    }

//---------------------------------------------------------------
//  CCONNECTION::DecrementPendingReads()
//---------------------------------------------------------------
inline LONG CCONNECTION::DecrementPendingReads()
    {
    return InterlockedDecrement(&m_lPendingReads);
    }

//---------------------------------------------------------------
//  CCONNECTION::IncrementPendingWrites()
//---------------------------------------------------------------
inline LONG CCONNECTION::IncrementPendingWrites()
    {
    return InterlockedIncrement(&m_lPendingWrites);
    }

//---------------------------------------------------------------
//  CCONNECTION::DecrementPendingReads()
//---------------------------------------------------------------
inline LONG CCONNECTION::DecrementPendingWrites()
    {
    return InterlockedDecrement(&m_lPendingWrites);
    }

//---------------------------------------------------------------
//  CCONNECTION::NumPendingIos()
//---------------------------------------------------------------
inline LONG CCONNECTION::NumPendingIos()
    {
    return m_lPendingReads + m_lPendingWrites;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetIoCompletionPort()
//---------------------------------------------------------------
inline void CCONNECTION::SetIoCompletionPort( HANDLE hIoCP )
    {
    }

//---------------------------------------------------------------
//  CCONNECTION::GetIoCompletionPort()
//---------------------------------------------------------------
inline HANDLE CCONNECTION::GetIoCompletionPort()
    {
    return INVALID_HANDLE_VALUE;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetScepConnection()
//---------------------------------------------------------------
inline void CCONNECTION::SetScepConnection( CSCEP_CONNECTION *pScepConnection )
    {
    m_pScepConnection = pScepConnection;
    }

//---------------------------------------------------------------
//  CCONNECTION::GetScepConnection()
//---------------------------------------------------------------
inline CSCEP_CONNECTION *CCONNECTION::GetScepConnection()
    {
    return m_pScepConnection;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetJpegOffset()
//---------------------------------------------------------------
inline void CCONNECTION::SetJpegOffsetAndSize( IN DWORD dwOffset,
                                               IN DWORD dwSize )
    {
    m_dwJpegOffset = dwOffset;
    m_dwJpegSize = dwSize;
    }

//---------------------------------------------------------------
//  CCONNECTION::CheckSaveAsUPF()
//---------------------------------------------------------------
inline BOOL CCONNECTION::CheckSaveAsUPF()
    {
    return m_fSaveAsUPF;
    }

//---------------------------------------------------------------
//  CCONNECTION::SetReceiveComplete()
//---------------------------------------------------------------
inline void CCONNECTION::SetReceiveComplete( IN BOOL fReceiveComplete )
    {
    m_fReceiveComplete = fReceiveComplete;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\io.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// io.cpp
//
// Author:
//
//   Edward Reus (edwardr)     02-27-98   Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

#ifdef DBG_MEM
static LONG g_lCIoPacketCount = 0;
#endif

extern HINSTANCE g_hInst;  // ircamera.dll instance.

//--------------------------------------------------------------------
// CIOPACKET::CIOPACKET()
//
//--------------------------------------------------------------------
CIOPACKET::CIOPACKET()
    {
    m_dwKind = PACKET_KIND_LISTEN;

    m_ListenSocket = INVALID_SOCKET;
    m_Socket = INVALID_SOCKET;
    m_hFile = INVALID_HANDLE_VALUE;
    m_pLocalAddr = 0;
    m_pFromAddr = 0;
    m_pAcceptBuffer = 0;
    m_pReadBuffer = 0;
    m_pvWritePdu = 0;
    m_dwReadBufferSize = 0;
    }

//--------------------------------------------------------------------
// CIOPACKET::~CIOPACKET()
//
//--------------------------------------------------------------------
CIOPACKET::~CIOPACKET()
    {
    // NOTE: Don't free m_pLocalAddr or m_pFromAddr, they just point
    // into m_pAcceptBuffer.

    if (m_pAcceptBuffer)
       {
       FreeMemory(m_pAcceptBuffer);
       }

    if (m_pReadBuffer)
       {
       FreeMemory(m_pReadBuffer);
       }

    // NOTE: Don't delete the write PDU (m_pvWritePdu), its free'd by 
    // somebody else (when the IO completes)...
    }

//------------------------------------------------------------------------
//  CIOPACKET::operator new()
//
//------------------------------------------------------------------------
void *CIOPACKET::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    #ifdef DBG_MEM
    if (pObj)
        {
        InterlockedIncrement(&g_lCIoPacketCount);
        }

    WIAS_TRACE((g_hInst,"new CIOPACKET: Count: %d\n",g_lCIoPacketCount));
    #endif

    return pObj;
    }

//------------------------------------------------------------------------
//  CIOPACKET::operator delete()
//
//------------------------------------------------------------------------
void CIOPACKET::operator delete( IN void *pObj,
                                 IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);

        #ifdef DBG_MEM
        if (dwStatus)
            {
            WIAS_TRACE((g_hInst,"IrXfer: IrTran-P: CIOPACKET::delete: FreeMemory Failed: %d\n",dwStatus));
            }

        InterlockedDecrement(&g_lCIoPacketCount);

        if (g_lCIoPacketCount < 0)
            {
            WIAS_TRACE((g_hInst,"IrXfer: IrTran-P: CIOPACKET::delete Count: %d\n",g_lCIoPacketCount));
            }
        #endif
        }
    }

//--------------------------------------------------------------------
// CIOPACKET::Initialize()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::Initialize( IN DWORD  dwKind,
                             IN SOCKET ListenSocket,
                             IN SOCKET Socket,
                             IN HANDLE hIoCP )
    {
    DWORD  dwStatus = NO_ERROR;

    m_dwKind = dwKind;

    if (dwKind == PACKET_KIND_LISTEN)
        {
        // The accept buffer needs to be large enough to hold
        // the "from" and "to" addresses:
        m_pAcceptBuffer = AllocateMemory(2*(16+sizeof(SOCKADDR_IRDA)));
        if (!m_pAcceptBuffer)
            {
            return ERROR_OUTOFMEMORY;
            }
        }

    m_ListenSocket = ListenSocket;
    m_Socket = Socket;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CIOPACKET::PostIoRead()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::PostIoRead()
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwBytes;

    if (!m_pReadBuffer)
        {
        m_pReadBuffer = AllocateMemory(DEFAULT_READ_BUFFER_SIZE);
        m_dwReadBufferSize = DEFAULT_READ_BUFFER_SIZE;

        if (!m_pReadBuffer)
            {
            return ERROR_OUTOFMEMORY;
            }
        }

    memset(&m_Overlapped,0,sizeof(m_Overlapped));

    BOOL b = ReadFile( (HANDLE)m_Socket,
                       m_pReadBuffer,
                       m_dwReadBufferSize,
                       0,  // Can be zero for overlapped IO.
                       &m_Overlapped );

    if (!b)
        {
        dwStatus = GetLastError();
        if ((dwStatus == ERROR_HANDLE_EOF)||(dwStatus == ERROR_IO_PENDING))
            {
            dwStatus = NO_ERROR;
            }
        }

    #ifdef DBG_IO
    WIAS_TRACE((g_hInst,"CIOPACKET::PostIoRead(): ReadFile(): Socket: %d",m_Socket));
    #endif

    return dwStatus;
    }

//--------------------------------------------------------------------
// CIOPACKET::PostIoWrite()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::PostIoWrite( IN void  *pvBuffer,
                              IN DWORD  dwBufferSize,
                              IN DWORD  dwOffset      )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwBytes;
    HANDLE hFile;

    memset(&m_Overlapped,0,sizeof(m_Overlapped));

    if (m_dwKind == PACKET_KIND_WRITE_SOCKET)
        {
        hFile = (HANDLE)m_Socket;
        int iBytes = send(m_Socket,(const char*)pvBuffer,dwBufferSize,0);
        if (iBytes == SOCKET_ERROR)
            {
            dwStatus = WSAGetLastError();

            WIAS_ERROR((g_hInst,"CIOPACKET::PostIoWrite(): send() Failed: Handle: %d Error: %d\n",m_Socket,dwStatus));

            return dwStatus;
            }
        }
    else if (m_dwKind == PACKET_KIND_WRITE_FILE)
        {
        hFile = m_hFile;
        m_Overlapped.Offset = dwOffset;

        DWORD  dwBytesWritten = 0;
        BOOL   b = WriteFile( hFile,
                              pvBuffer,
                              dwBufferSize,
                              &dwBytesWritten,
                              0 );

        if (!b)
            {
            dwStatus = GetLastError();

            WIAS_ERROR((g_hInst,"CIOPACKET::PostIoWrite(): WriteFile() Failed: Handle: %d Error: %d\n",hFile,dwStatus));

            return dwStatus;
            }
        }
    else
        {
        WIAS_TRACE((g_hInst,"CIOPACKET::PostIoWrite(): Invalid m_dwKind: %d.\n",m_dwKind));

        dwStatus = ERROR_INVALID_PARAMETER;
        }

    #ifdef DBG_IO
    WIAS_TRACE((g_hInst,"CIOPACKET::PostIoWrite(): WriteFile(): Handle: %d Bytes: %d\n", hFile, dwBufferSize ));
    #endif

    return dwStatus;
    }

//--------------------------------------------------------------------
// CIOPACKET::PostIo()
//
//--------------------------------------------------------------------
DWORD CIOPACKET::PostIo()
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwBytes;

    if (m_dwKind == PACKET_KIND_LISTEN)
        {
        }
    else if (m_dwKind == PACKET_KIND_READ)
        {
        dwStatus = PostIoRead();
        }
    else
        {
        // Packet writes back to the camera (via socket) and writes to
        // the image (jpeg) file are posted only when data is ready to
        // send...
        WIAS_ASSERT( g_hInst,
                     (m_dwKind == PACKET_KIND_WRITE_SOCKET)
                     || (m_dwKind == PACKET_KIND_WRITE_FILE) );
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\io.h ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// io.h
//
// Author:
//
//   Edward Reus (edwardr)     02-24-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _IO_H_
#define _IO_H_

   // Different debug flags for various aspects of the code:
   #ifdef DBG
   // #define DBG_ERROR
   // #define DBG_IO
   // #define DBG_TARGET_DIR
   // #define DBG_MEM
   // #define DBG_MEM_VALIDATE
   // #define DBG_ASSEMBLE
   // #define DBG_DATE
   // #define DBG_REGISTRY
   // #define DBG_RETURN_STATUS
   // #define DBG_IMPERSONATE
   // #define DBG_PROPERTIES
   #endif

   // For NT we want to use IO Completion ports, for Windows98 we can't:
   // #define  USE_IOCOMPLETION
   #define  SYNCHRONOUS_FILES

   #ifndef NTENV

      #define  DbgPrint       printf

      #undef   ASSERT
      #define  ASSERT(x)

      #ifndef NTSTATUS
      #define  NTSTATUS       DWORD
      #endif

      #ifndef NT_SUCCESS
      #define  NT_SUCCESS(x)  ((x)==0)
      #endif

      #define  RTL_CRITICAL_SECTION   CRITICAL_SECTION

      NTSTATUS
      RtlInitializeCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );

      NTSTATUS
      RtlDeleteCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );

      NTSTATUS
      RtlEnterCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );

      NTSTATUS
      RtlLeaveCriticalSection( IN OUT RTL_CRITICAL_SECTION *pcs );


   //  Doubly-linked list manipulation routines.  Implemented as macros
   //  but logically these are procedures.
   //

   //
   //  VOID
   //  InitializeListHead(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define InitializeListHead(ListHead) (\
       (ListHead)->Flink = (ListHead)->Blink = (ListHead))

   //
   //  BOOLEAN
   //  IsListEmpty(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define IsListEmpty(ListHead) \
       ((ListHead)->Flink == (ListHead))

   //
   //  PLIST_ENTRY
   //  RemoveHeadList(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define RemoveHeadList(ListHead) \
       (ListHead)->Flink;\
       {RemoveEntryList((ListHead)->Flink)}

   //
   //  PLIST_ENTRY
   //  RemoveTailList(
   //      PLIST_ENTRY ListHead
   //      );
   //

   #define RemoveTailList(ListHead) \
       (ListHead)->Blink;\
       {RemoveEntryList((ListHead)->Blink)}

   //
   //  VOID
   //  RemoveEntryList(
   //      PLIST_ENTRY Entry
   //      );
   //

   #define RemoveEntryList(Entry) {\
       PLIST_ENTRY _EX_Blink;\
       PLIST_ENTRY _EX_Flink;\
       _EX_Flink = (Entry)->Flink;\
       _EX_Blink = (Entry)->Blink;\
       _EX_Blink->Flink = _EX_Flink;\
       _EX_Flink->Blink = _EX_Blink;\
       }

   //
   //  VOID
   //  InsertTailList(
   //      PLIST_ENTRY ListHead,
   //      PLIST_ENTRY Entry
   //      );
   //

   #define InsertTailList(ListHead,Entry) {\
       PLIST_ENTRY _EX_Blink;\
       PLIST_ENTRY _EX_ListHead;\
       _EX_ListHead = (ListHead);\
       _EX_Blink = _EX_ListHead->Blink;\
       (Entry)->Flink = _EX_ListHead;\
       (Entry)->Blink = _EX_Blink;\
       _EX_Blink->Flink = (Entry);\
       _EX_ListHead->Blink = (Entry);\
       }

   //
   //  VOID
   //  InsertHeadList(
   //      PLIST_ENTRY ListHead,
   //      PLIST_ENTRY Entry
   //      );
   //

   #define InsertHeadList(ListHead,Entry) {\
       PLIST_ENTRY _EX_Flink;\
       PLIST_ENTRY _EX_ListHead;\
       _EX_ListHead = (ListHead);\
       _EX_Flink = _EX_ListHead->Flink;\
       (Entry)->Flink = _EX_Flink;\
       (Entry)->Blink = _EX_ListHead;\
       _EX_Flink->Blink = (Entry);\
       _EX_ListHead->Flink = (Entry);\
       }

   //
   //
   //  PSINGLE_LIST_ENTRY
   //  PopEntryList(
   //      PSINGLE_LIST_ENTRY ListHead
   //      );
   //

   #define PopEntryList(ListHead) \
       (ListHead)->Next;\
       {\
           PSINGLE_LIST_ENTRY FirstEntry;\
           FirstEntry = (ListHead)->Next;\
           if (FirstEntry != NULL) {     \
               (ListHead)->Next = FirstEntry->Next;\
           }                             \
       }


   //
   //  VOID
   //  PushEntryList(
   //      PSINGLE_LIST_ENTRY ListHead,
   //      PSINGLE_LIST_ENTRY Entry
   //      );
   //

   #define PushEntryList(ListHead,Entry) \
       (Entry)->Next = (ListHead)->Next; \
       (ListHead)->Next = (Entry)


#endif

// Maximum number of "Copy XX of" files to create:
#define  MAX_COPYOF_TRIES                 100

// CIOPACKET objects can have the following kinds:
#define  PACKET_KIND_LISTEN                 0
#define  PACKET_KIND_READ                   1
#define  PACKET_KIND_WRITE_SOCKET           2
#define  PACKET_KIND_WRITE_FILE             3

// The number of pending IOs depends on what you are doing:
#define  MAX_PENDING_LISTEN                 1
#define  MAX_PENDING_READ                   2
#define  MAX_PENDING_WRITE                  3

// This dwKey value for the key in IO completion is a special
// value used to shutdown the IrTran-P thread:
#define  IOKEY_SHUTDOWN            0xFFFFFFFF

// This is the default size for the read buffer in IO reads
// posted to the IO completion port:
#define  DEFAULT_READ_BUFFER_SIZE        4096

// Used in setting up the IrCOMM listen socket:
#define  IAS_SET_ATTRIB_MAX_LEN            32
#define  IAS_QUERY_ATTRIB_MAX_LEN          IAS_SET_ATTRIB_MAX_LEN

#define  IRDA_PARAMETERS                   "Parameters"
#define  OCTET_SEQ_SIZE                     6
#define  OCTET_SEQ                         "\000\001\006\001\001\001"

// The names of the services we will provide listen sockets for:
#define  IRTRANP_SERVICE                   "IrTranPv1"
#define  IRCOMM_9WIRE                      "IrDA:IrCOMM"

// The status of the listen socket for each service:
#define  STATUS_STOPPED                     0
#define  STATUS_RUNNING                     1

// Registry paths and value names:
#define  REG_PATH_HKCU                     "Control Panel\\Infrared\\IrTranP"
#define  REG_DWORD_SAVE_AS_UPF             "SaveAsUPF"
#define  REG_DWORD_DISABLE_IRTRANP         "DisableIrTranPv1"
#define  REG_DWORD_DISABLE_IRCOMM          "DisableIrCOMM"
#define  REG_DWORD_EXPLORE                 "ExploreOnCompletion"
#define  REG_SZ_DESTINATION                "RecvdFileLocation"

// Last chance location to put image files.
#define  SZ_UNDERSCORE                     "_"
#define  SZ_SLASH                          "\\"
#define  SZ_SUBDIRECTORY                   "IrTranP"
#define  SZ_BACKUP_MY_PICTURES             "\\TEMP"
#define  SZ_BACKUP_DRIVE                   "C:"

// File Suffix:
#define  SLASH                             '\\'
#define  PERIOD                            '.'
#define  SZ_JPEG                           ".JPG"
#define  SZ_UPF                            ".UPF"

// Forward reference:
class CIOSTATUS;

extern "C" DWORD    ProcessIoPackets( CIOSTATUS *pIoStatus );

//--------------------------------------------------------------------
// Global functions (in irtranp.cpp)
//--------------------------------------------------------------------

extern HANDLE   GetUserToken();
extern BOOL     CheckSaveAsUPF();
extern BOOL     CheckExploreOnCompletion();
extern BOOL     ReceivesAllowed();
extern char    *GetImageDirectory();

//--------------------------------------------------------------------
// class CIOPACKET
//--------------------------------------------------------------------
class CIOPACKET
{
public:
    CIOPACKET();
    ~CIOPACKET();

    void   *operator new( IN size_t Size );

    void    operator delete( IN void   *pObj,
                             IN size_t  Size );

    DWORD  Initialize( IN DWORD  dwKind = PACKET_KIND_LISTEN,
                       IN SOCKET ListenSocket = INVALID_SOCKET,
                       IN SOCKET Socket = INVALID_SOCKET,
                       IN HANDLE hIoCP = INVALID_HANDLE_VALUE );

    // void * operator new( size_t ObjectSize );

    // void   operator delete( void * pObject );

    DWORD  PostIo();

    DWORD  PostIoRead();    // Called by PostIo().

    DWORD  PostIoWrite( IN void  *pvBuffer,
                        IN DWORD  dwBufferSize,
                        IN DWORD  dwOffset   );

    #ifdef NTENV
    void   GetSockAddrs( OUT SOCKADDR_IRDA **ppAddrLocal,
                         OUT SOCKADDR_IRDA **ppAddrFrom );
    #endif

    DWORD  GetIoPacketKind();
    void   SetIoPacketKind( IN DWORD dwKind );

    HANDLE GetIoCompletionPort();

    char  *GetReadBuffer();

    SOCKET GetSocket();
    void   SetSocket( SOCKET Socket );
    SOCKET GetListenSocket();
    void   SetListenSocket( SOCKET Socket );
    HANDLE GetFileHandle();
    void   SetFileHandle( HANDLE hFile );

    void  *GetWritePdu();
    void   SetWritePdu( void *pvPdu );

    static CIOPACKET *CIoPacketFromOverlapped( OVERLAPPED *pOverlapped );

private:
    DWORD          m_dwKind;
    SOCKET         m_ListenSocket;
    SOCKET         m_Socket;
    HANDLE         m_hFile;
    SOCKADDR_IRDA *m_pLocalAddr;
    SOCKADDR_IRDA *m_pFromAddr;
    void          *m_pAcceptBuffer;
    void          *m_pReadBuffer;
    void          *m_pvWritePdu;           // SCEP_HEADER PDU holder.
    DWORD          m_dwReadBufferSize;
    OVERLAPPED     m_Overlapped;
};

//--------------------------------------------------------------------
// class CIOSTATUS
//
//--------------------------------------------------------------------
class CIOSTATUS
{
public:
    CIOSTATUS();
    ~CIOSTATUS();

    void   *operator new( IN size_t Size );

    void    operator delete( IN void   *pObj,
                             IN size_t  Size );

    DWORD  Initialize();

    BOOL   IsMainThreadId( DWORD dwTid );

    HANDLE GetIoCompletionPort();

    LONG   IncrementNumThreads();
    LONG   DecrementNumThreads();

    LONG   IncrementNumPendingThreads();
    LONG   DecrementNumPendingThreads();

private:
    DWORD     m_dwMainThreadId;

    LONG      m_lNumThreads;

    LONG      m_lNumPendingThreads;
};

//--------------------------------------------------------------------
// CIOPACKET::GetIoCompletionPort()
//--------------------------------------------------------------------
inline HANDLE CIOPACKET::GetIoCompletionPort()
    {
    return INVALID_HANDLE_VALUE;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetSocket()
//--------------------------------------------------------------------
inline SOCKET CIOPACKET::GetSocket()
    {
    return m_Socket;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetSocket()
//--------------------------------------------------------------------
inline void CIOPACKET::SetSocket( SOCKET Socket )
    {
    m_Socket = Socket;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetListenSocket()
//--------------------------------------------------------------------
inline SOCKET CIOPACKET::GetListenSocket()
    {
    return m_ListenSocket;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetListenSocket()
//--------------------------------------------------------------------
inline void CIOPACKET::SetListenSocket( SOCKET ListenSocket )
    {
    m_ListenSocket = ListenSocket;
    }

//--------------------------------------------------------------------
// CIOPACKET::CIoPacketFromOverlapped()
//--------------------------------------------------------------------
inline CIOPACKET *CIOPACKET::CIoPacketFromOverlapped( OVERLAPPED *pOverlapped )
    {
    return CONTAINING_RECORD(pOverlapped,CIOPACKET,m_Overlapped);
    }

//--------------------------------------------------------------------
// CIOPACKET::GetIoPacketKind()
//--------------------------------------------------------------------
inline DWORD CIOPACKET::GetIoPacketKind()
    {
    return m_dwKind;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetIoPacketKind()
//--------------------------------------------------------------------
inline void CIOPACKET::SetIoPacketKind( DWORD dwKind )
    {
    m_dwKind = dwKind;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetReadBuffer()
//--------------------------------------------------------------------
inline char *CIOPACKET::GetReadBuffer()
    {
    return (char*)m_pReadBuffer;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetFileHandle()
//--------------------------------------------------------------------
inline HANDLE CIOPACKET::GetFileHandle()
    {
    return m_hFile;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetFileHandle()
//--------------------------------------------------------------------
inline void CIOPACKET::SetFileHandle( HANDLE hFile )
    {
    m_hFile = hFile;
    }

//--------------------------------------------------------------------
// CIOPACKET::GetWritePdu()
//--------------------------------------------------------------------
inline void *CIOPACKET::GetWritePdu()
    {
    return m_pvWritePdu;
    }

//--------------------------------------------------------------------
// CIOPACKET::SetWritePdu()
//--------------------------------------------------------------------
inline void CIOPACKET::SetWritePdu( void *pvWritePdu )
    {
    m_pvWritePdu = pvWritePdu;
    }


//********************************************************************

//--------------------------------------------------------------------
// CIOSTATUS::IsMainTheadId()
//--------------------------------------------------------------------
inline BOOL CIOSTATUS::IsMainThreadId( DWORD dwTid )
    {
    return (dwTid == m_dwMainThreadId);
    }

//--------------------------------------------------------------------
// CIOSTATUS::GetIoCompletionPort()
//--------------------------------------------------------------------
inline HANDLE CIOSTATUS::GetIoCompletionPort()
    {
    return INVALID_HANDLE_VALUE;
    }

//--------------------------------------------------------------------
// CIOSTATUS::IncrementNumThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::IncrementNumThreads()
    {
    return InterlockedIncrement(&m_lNumThreads);
    }

//--------------------------------------------------------------------
// CIOSTATUS::DecrementNumThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::DecrementNumThreads()
    {
    return InterlockedDecrement(&m_lNumThreads);
    }

//--------------------------------------------------------------------
// CIOSTATUS::IncrementNumPendingThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::IncrementNumPendingThreads()
    {
    return InterlockedIncrement(&m_lNumPendingThreads);
    }

//--------------------------------------------------------------------
// CIOSTATUS::DecrementNumPendingThreads()
//--------------------------------------------------------------------
inline LONG CIOSTATUS::DecrementNumPendingThreads()
    {
    return InterlockedDecrement(&m_lNumPendingThreads);
    }

#endif //_IO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\precomp.h ===
//---------------------------------------------------------------------
//  Copyright (c)1998-1999 Microsoft Corporation, All Rights Reserved.
//
//  precomp.h
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//    Edward Reus (edwardr)     08-27-99   Modified for Millennium & WIA.
//
//---------------------------------------------------------------------


#include <windows.h>
#include <winsock2.h>

#ifndef  _WIN32_WINDOWS
   #define  _WIN32_WINDOWS
#endif

#include <af_irda.h>
#include <shlobj.h>
#include "irtranp.h"
#include "io.h"
#include "scep.h"
#include "../progress.h"
#include "conn.h"

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"
#include "wiamindr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\memory.cpp ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// memory.cpp
//
// Simple memory allocation routines. We use our own private heap
// so we won't (have less chances of) interfering with any other 
// service code.
//
// Author:
//
//   Edward Reus (EdwardR)   03-04-98  Initial coding.
//
//   Edward Reus (EdwardR)   06-08-98  Convert to use private heap.
//
//--------------------------------------------------------------------

#include "precomp.h"

#pragma warning (disable:4200)

typedef struct _PDU_MEMORY
    {
    LIST_ENTRY  Link;
    DWORD       dwPduSize;
    UCHAR       Pdu[];
    } PDU_MEMORY;

#pragma warning (default:4200)

static HANDLE      g_hHeap = 0;   // Can't use INVALID_HANDLE_VALUE.

static LIST_ENTRY  g_FreePduList;
static BOOL        g_fListInitialized = FALSE;

#ifdef DBG_MEM
static LONG        g_lPduCount = 0;
#endif


//--------------------------------------------------------------------
// InitializeMemory()
//
//--------------------------------------------------------------------
DWORD InitializeMemory()
    {
    DWORD   dwStatus = NO_ERROR;
    #define INITIAL_HEAP_PAGES    64

    if (!g_hHeap)
        {
        SYSTEM_INFO  SystemInfo;

        GetSystemInfo(&SystemInfo);

        DWORD  dwFlags = 0;
        DWORD  dwInitialSize = INITIAL_HEAP_PAGES * SystemInfo.dwPageSize;
        DWORD  dwMaxSize = 0;
        g_hHeap = HeapCreate( dwFlags, dwInitialSize, dwMaxSize );
        if (!g_hHeap)
            {
            dwStatus = GetLastError();
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// AllocateMemory()
//
//--------------------------------------------------------------------
void *AllocateMemory( DWORD dwBytes )
    {
    DWORD  dwStatus;
    void  *pvMemory;

    if (!g_hHeap)
        {
        dwStatus = InitializeMemory();
        }

    if ((g_hHeap) && (dwBytes > 0))
        {
        #ifdef DBG_MEM_VALIDATE
        HeapValidate(g_hHeap,0,0);
        #endif

        pvMemory = HeapAlloc(g_hHeap,0,dwBytes);
        }
    else
        {
        pvMemory = 0;
        }

    return pvMemory;
    }


//--------------------------------------------------------------------
// FreeMemory()
//
//--------------------------------------------------------------------
DWORD FreeMemory( void *pvMemory )
    {
    DWORD  dwStatus = NO_ERROR;

    if (g_hHeap)
        {
        #ifdef DBG_MEM_VALIDATE
        HeapValidate(g_hHeap,0,0);
        #endif

        if (pvMemory)
            {
            if (!HeapFree(g_hHeap,0,pvMemory))
                {
                dwStatus = GetLastError();
                }
            }
        }
    else
        {
        #ifdef DBG_MEM
        DbgPrint("IrXfer.dll: IrTran-P: Free memory with NULL g_hHeap.\n");
        #endif
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// UninitializeMemory()
//
//--------------------------------------------------------------------
DWORD UninitializeMemory()
    {
    DWORD  dwStatus = NO_ERROR;

    #ifdef DBG_MEM_VALIDATE
    HeapValidate(g_hHeap,0,0);
    #endif

    if (g_hHeap)
        {
        if (!HeapDestroy(g_hHeap))
            {
            dwStatus = GetLastError();
            }
        }

    g_hHeap = 0;

    return dwStatus;
    }

//--------------------------------------------------------------------
// NewPdu()
//
//--------------------------------------------------------------------
SCEP_HEADER *NewPdu( DWORD dwPduSize )
    {
    SCEP_HEADER  *pPdu;
    PDU_MEMORY   *pPduMemory;
    LIST_ENTRY   *pLink;

    if (!g_fListInitialized)
        {
        InitializeListHead(&g_FreePduList);
        g_fListInitialized = TRUE;
        }

    if (dwPduSize == 0)
        {
        dwPduSize = MAX_PDU_SIZE;
        }

    if (IsListEmpty(&g_FreePduList))
        {
        pPduMemory 
            = (PDU_MEMORY*)AllocateMemory( sizeof(PDU_MEMORY)+dwPduSize );

        if (pPduMemory)
            {
            pPduMemory->Link.Flink = 0;
            pPduMemory->Link.Blink = 0;
            pPduMemory->dwPduSize = dwPduSize;
            }
        }
    else
        {
        pLink = RemoveHeadList(&g_FreePduList);
        pPduMemory = CONTAINING_RECORD(pLink,PDU_MEMORY,Link);
        }

    if (pPduMemory)
        {
        pPdu = (SCEP_HEADER*)(pPduMemory->Pdu);
        }
    else
        {
        pPdu = 0;
        }

    #ifdef DBG_MEM
    if (pPdu)
        {
        InterlockedIncrement(&g_lPduCount);
        }
    DbgPrint("NewPdu(): Count: %d Bytes: %d Addr: 0x%x\n",
             g_lPduCount, dwPduSize, pPdu );
    #endif

    return pPdu;
    }

//--------------------------------------------------------------------
// DeletePdu()
//
//--------------------------------------------------------------------
void DeletePdu( SCEP_HEADER *pPdu )
    {
    PDU_MEMORY  *pPduMemory;

    if (pPdu)
        {
        pPduMemory = CONTAINING_RECORD(pPdu,PDU_MEMORY,Pdu);
        InsertTailList(&g_FreePduList,&pPduMemory->Link);

        #ifdef DBG_MEM
        InterlockedDecrement(&g_lPduCount);
        DbgPrint("DeletePdu(): Count: %d\n",g_lPduCount);
        #endif
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\scep.cpp ===
//--------------------------------------------------------------------
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
//  scep.cpp
//
//  This file holds most of the implementation of CSCEP_CONNECTION
//  objects. Each active connection to a camera is represented by
//  a separate CSCEP_CONNECTION object. The CSCEP_CONNECTION is then
//  destroyed when the connection (socket) to the camera is closed.
//
//  Author:
//
//    Edward Reus (edwardr)     02-24-98   Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

typedef struct _ATTRIBUTE_TOKEN
    {
      DWORD  dwTokenType;
      UCHAR *pChars;
      DWORD  dwSize;
    } ATTRIBUTE_TOKEN;

#define ATTRIBUTE_NAME_SIZE        2

#define COLON                     ':'
#define ONE                       '1'
#define SPACE                     ' '
#define TAB                       '\t'
#define CR                        0x0d
#define LF                        0x0a

#define ATTRIBUTE_NAME             0
#define ATTRIBUTE_COLON            1
#define ATTRIBUTE_VALUE            2
#define ATTRIBUTE_CRLF             3

#define ATTR_PDU_SIZE              0
#define ATTR_PRODUCT_ID            1
#define ATTR_USER_NAME             2
#define ATTR_PASSWORD              3

//--------------------------------------------------------------------
// Globals:
//--------------------------------------------------------------------

extern  HINSTANCE  g_hInst;    // Instance for DLL ircamera.dll

static  DWORD      g_adwPduSizes[] 
                      = { PDU_SIZE_1, PDU_SIZE_2, PDU_SIZE_3, PDU_SIZE_4 };

#ifdef DBG_MEM
static  LONG g_lCScepConnectionCount = 0;
#endif

//--------------------------------------------------------------------
// SkipBlanks()
//
//--------------------------------------------------------------------
void SkipBlanks( IN OUT UCHAR **ppAttributes,
                 IN OUT DWORD  *pdwAttributeSize )
    {
    while ( (*pdwAttributeSize > 0)
          && ((**ppAttributes == SPACE)||(**ppAttributes == TAB)) )
        {
        (*ppAttributes)++;
        (*pdwAttributeSize)--;
        }
    }

//--------------------------------------------------------------------
// NextToken()
//
//--------------------------------------------------------------------
ATTRIBUTE_TOKEN *NextToken( IN     DWORD   dwTokenType,
                            IN OUT UCHAR **ppAttributes,
                            IN OUT DWORD  *pdwAttributeSize )
    {
    ATTRIBUTE_TOKEN *pToken = 0;

    SkipBlanks(ppAttributes,pdwAttributeSize);

    if ((!*ppAttributes) || (*pdwAttributeSize == 0))
        {
        return 0;
        }

    pToken = (ATTRIBUTE_TOKEN*)AllocateMemory(sizeof(ATTRIBUTE_TOKEN));
    if (!pToken)
        {
        return 0;
        }

    pToken->dwTokenType = dwTokenType;

    switch (dwTokenType)
        {
        case ATTRIBUTE_NAME:
            if (*pdwAttributeSize < ATTRIBUTE_NAME_SIZE)
                {
                FreeMemory(pToken);
                pToken = 0;
                break;
                }

            pToken->pChars = *ppAttributes;
            pToken->dwSize = ATTRIBUTE_NAME_SIZE;
            *ppAttributes += ATTRIBUTE_NAME_SIZE;
            *pdwAttributeSize -= ATTRIBUTE_NAME_SIZE;
            break;

        case ATTRIBUTE_COLON:
            if (**ppAttributes == COLON)
                {
                pToken->pChars = *ppAttributes;
                pToken->dwSize = 1;
                *ppAttributes += 1;
                *pdwAttributeSize -= 1;
                }
            break;

        case ATTRIBUTE_VALUE:
            pToken->pChars = *ppAttributes;
            pToken->dwSize = 0;
            while ((**ppAttributes != CR) && (*pdwAttributeSize > 0))
                {
                (*ppAttributes)++;
                (*pdwAttributeSize)--;
                (pToken->dwSize)++;
                }
            break;

        case ATTRIBUTE_CRLF:
            pToken->pChars = *ppAttributes;
            pToken->dwSize = 2;
            *ppAttributes += 2;
            *pdwAttributeSize -= 2;
            if ((pToken->pChars[0] != CR)||(pToken->pChars[1] != LF))
                {
                FreeMemory(pToken);
                pToken = 0;
                }
            break;

        default:
            FreeMemory(pToken);
            pToken = 0;
            break;
        }

    return pToken;
    }

//--------------------------------------------------------------------
// IsAttributeName()
//
//--------------------------------------------------------------------
BOOL IsAttributeName( ATTRIBUTE_TOKEN *pToken,
                      int        *piAttribute )
    {
    BOOL fIsName = FALSE;

    if ((pToken->pChars[0] == 'f')&&(pToken->pChars[1] == 'r'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PDU_SIZE;
        }
    else
    if ((pToken->pChars[0] == 'i')&&(pToken->pChars[1] == 'd'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PRODUCT_ID;
        }
    else
    if ((pToken->pChars[0] == 'n')&&(pToken->pChars[1] == 'm'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_USER_NAME;
        }
    else
    if ((pToken->pChars[0] == 'p')&&(pToken->pChars[1] == 'w'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PASSWORD;
        }

    return fIsName;
    }

//--------------------------------------------------------------------
// NewTokenString()
//
//--------------------------------------------------------------------
UCHAR *NewTokenString( IN  ATTRIBUTE_TOKEN *pToken,
                       OUT DWORD           *pdwStatus )
    {
    UCHAR *pszNewStr = (UCHAR*)AllocateMemory(1+pToken->dwSize);

    if (!pszNewStr)
        {
        *pdwStatus = ERROR_OUTOFMEMORY;
        return 0;
        }

    memcpy(pszNewStr,pToken->pChars,pToken->dwSize);
    pszNewStr[pToken->dwSize] = 0;

    return pszNewStr;
    }
                      
//--------------------------------------------------------------------
// CSCEP_CONNECTION::CSCEP_CONNECTION()
//
//--------------------------------------------------------------------
CSCEP_CONNECTION::CSCEP_CONNECTION()
    {
    m_dwConnectionState = STATE_CLOSED;
    m_dwPduSendSize = PDU_SIZE_1;    // default is 512 bytes.
    m_dwPduReceiveSize = PDU_SIZE_4;
    m_CFlag = 0;
    m_pPrimaryMachineId = 0;
    m_pSecondaryMachineId = 0;
    m_DestPid = DEFAULT_PID;
    m_SrcPid = DEFAULT_PID;
    m_pszUserName = 0;
    m_pszPassword = 0;

    m_pAssembleBuffer = 0;
    m_dwAssembleBufferSize = 0;
    m_dwMaxAssembleBufferSize = 0;
    m_fDidByteSwap = FALSE;

    m_Fragmented = FALSE;
    m_DFlag = 0;
    m_dwSequenceNo = 0;
    m_dwRestNo = 0;
    m_dwCommandId = 0;
    m_pCommandHeader = 0;

    m_pszFileName = 0;
    m_pszSaveFileName = 0;
    m_pszLongFileName = 0;

    m_CreateTime.dwLowDateTime = 0;   // Picture create date/time.
    m_CreateTime.dwHighDateTime = 0;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::~CSCEP_CONNECTION()
//
//--------------------------------------------------------------------
CSCEP_CONNECTION::~CSCEP_CONNECTION()
    {
    if (m_pPrimaryMachineId)
        {
        FreeMemory(m_pPrimaryMachineId);
        }

    if (m_pSecondaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        }

    if (m_pszUserName)
        {
        FreeMemory(m_pszUserName);
        }

    if (m_pszPassword)
        {
        FreeMemory(m_pszPassword);
        }

    if (m_pAssembleBuffer)
        {
        FreeMemory(m_pAssembleBuffer);
        }

    if (m_pCommandHeader)
        {
        FreeMemory(m_pCommandHeader);
        }

    if (m_pszFileName)
        {
        FreeMemory(m_pszFileName);
        }

    if (m_pszSaveFileName)
        {
        FreeMemory(m_pszSaveFileName);
        }

    if (m_pszLongFileName)
        {
        FreeMemory(m_pszLongFileName);
        }
    }

//------------------------------------------------------------------------
//  CSCEP_CONNECTION::operator new()
//
//------------------------------------------------------------------------
void *CSCEP_CONNECTION::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    #ifdef DBG_MEM
    if (pObj)
        {
        InterlockedIncrement(&g_lCScepConnectionCount);
        }
    #endif

    return pObj;
    }

//------------------------------------------------------------------------
//  CSCEP_CONNECTION::operator delete()
//
//------------------------------------------------------------------------
void CSCEP_CONNECTION::operator delete( IN void *pObj,
                                        IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);
        }
    }


//--------------------------------------------------------------------
// CSCEP_CONNECTION::AssemblePdu()
//
// Take in bits of data as its read in. When a complete SCEP PDU has
// been read and assembled return it.
//
//   pInputData      - This is the data that just came in.
//
//   dwInputDataSize - Size in bytes of pInputData.
//
//   ppPdu           - Returns a complete SCEP PDU when this function
//                     returns NO_ERROR, otherwise set to 0.
//
//   pdwPduSize      - Size of the returned PDU.
//
// Return values:
//
//   NO_ERROR         - A new SCEP PDU is complete and ready.
//   ERROR_CONTINUE   - Data read so far is Ok, still waiting for more.
//   ERROR_SCEP_INVALID_PROTOCOL
//   ERROR_OUTOFMEMORY
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::AssemblePdu( IN  void         *pInputData,
                                     IN  DWORD         dwInputDataSize,
                                     OUT SCEP_HEADER **ppPdu,
                                     OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = ERROR_CONTINUE;
    UCHAR *pEnd;

    ASSERT(dwInputDataSize <= MAX_PDU_SIZE);

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwInputDataSize > 0)
        {
        if (!m_pAssembleBuffer)
           {
           m_dwMaxAssembleBufferSize = 2*MAX_PDU_SIZE;
           m_pAssembleBuffer 
                   = (UCHAR*)AllocateMemory(m_dwMaxAssembleBufferSize);
           if (!m_pAssembleBuffer)
               {
               return ERROR_OUTOFMEMORY;
               }

            memcpy(m_pAssembleBuffer,pInputData,dwInputDataSize);
            m_dwAssembleBufferSize = dwInputDataSize;
            }
        else
            {
            if (m_dwAssembleBufferSize+dwInputDataSize >= m_dwMaxAssembleBufferSize)
                {
                WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::AssemblePdu(): Buffer Overrun!"));
                }
            pEnd = &(m_pAssembleBuffer[m_dwAssembleBufferSize]);
            memcpy(pEnd,pInputData,dwInputDataSize);
            m_dwAssembleBufferSize += dwInputDataSize;
            }
        }

    // Check to see if enough data has come in for a complete PDU.
    dwStatus = CheckPdu(ppPdu,pdwPduSize);

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckPdu()
//
// Run through the "current" PDU and see if its complete. If its
// not yet complete, return ERROR_CONTINUE. If it is complete then
// return NO_ERROR.
//
// Return values:
//
//   NO_ERROR         - The current SCEP PDU is complete and ready.
//   ERROR_CONTINUE   - Data read so far is Ok, still waiting for more.
//   ERROR_SCEP_INVALID_PROTOCOL
//   ERROR_OUTOFMEMORY
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckPdu( OUT SCEP_HEADER **ppPdu,
                                  OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_NEGOTIATION *pInfNegotiation;

    if (m_dwAssembleBufferSize < 2)
        {
        return ERROR_CONTINUE;
        }

    switch ( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType )
        {
        case MSG_TYPE_CONNECT_REQ:
            dwStatus = CheckConnectPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_CONNECT_RESP:
            dwStatus = CheckConnectRespPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_DATA:
            dwStatus = CheckDataPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_DISCONNECT:
            dwStatus = CheckDisconnectPdu(ppPdu,pdwPduSize);
            break;

        default:
            // BUGBUG: Need different error return so we can 
            // return a proper nack to the camera...
            WIAS_ERROR((g_hInst,"CheckPdu(): Invalid Msgtype: %d\n", ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType ));
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            break;
        }
    
    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckConnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckConnectPdu( OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_VERSION     *pInfVersion;
    SCEP_NEGOTIATION *pInfNegotiation;
    SCEP_EXTEND      *pInfExtend;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_CONNECT_REQ);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_CONNECT)
        {
        return ERROR_CONTINUE;
        }

    if (m_dwAssembleBufferSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pInfVersion = (SCEP_VERSION*)(((SCEP_HEADER*)m_pAssembleBuffer)->Rest);

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_VERSION)
                                           + (char*)pInfVersion );

    pInfExtend = (SCEP_EXTEND*)( FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
                                 + pInfNegotiation->Length
                                 + (char*)pInfNegotiation );

    // Check to see if we have a complete connect PDU size-wise:
    dwSize = 10 + pInfNegotiation->Length;
    if (m_dwAssembleBufferSize == dwSize)
        {
        // Have a complete PDU.
        dwStatus = NO_ERROR;
        }
    else if (m_dwAssembleBufferSize < dwSize)
        {
        // Need to wait for more data to arrive
        dwStatus = ERROR_CONTINUE;
        }
    else
        {
        // Too much data...
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        // Check to make sure the contents of the PDU "look" Ok:

        if ( (pInfVersion->InfType != INF_TYPE_VERSION)
           || (pInfVersion->Version != PROTOCOL_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }

        if ( (pInfNegotiation->InfType != INF_TYPE_NEGOTIATION)
           || (pInfNegotiation->InfVersion < INF_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }

        if ( (pInfExtend->InfType != INF_TYPE_EXTEND)
           || (pInfExtend->Length != (sizeof(pInfExtend->Parameter1)
                                      +sizeof(pInfExtend->Parameter2)))
           || (pInfExtend->Parameter1 != 0)
           || (pInfExtend->Parameter2 != 0) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckConnectPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = m_dwAssembleBufferSize;
            memcpy(*ppPdu,m_pAssembleBuffer,m_dwAssembleBufferSize);
            m_dwAssembleBufferSize = 0;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
//  CSCEP_CONNECTION::CheckConnectRespPdu()                     CLIENT
//
//  A connect response from the IrTran-P server is either a ACK or
//  NACK PDU. If we get here then it's an ACK. We'll make sure the
//  entire PDU is here and that it is formatted correctly. There is
//  a specific message type for ACK PDUs, the NACK is just a special
//  case of MSG_TYPE_DATA and is handled elsewere (CheckDataPdu()).
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_HEADER      *pHeader;
    SCEP_NEGOTIATION *pInfNegotiation;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_CONNECT_RESP);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_CONNECT_RESP)
        {
        return ERROR_CONTINUE;
        }

    if (m_dwAssembleBufferSize > MAX_PDU_SIZE_CONNECT_RESP)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pHeader = (SCEP_HEADER*)m_pAssembleBuffer;

    pInfNegotiation = (SCEP_NEGOTIATION*)(pHeader->Rest);

    // Check to see if we have a complete connect PDU size-wise:
    dwSize = sizeof(SCEP_HEADER)
             + FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
             + pInfNegotiation->Length;

    if (m_dwAssembleBufferSize == dwSize)
        {
        // Have a complete PDU.
        dwStatus = NO_ERROR;
        }
    else if (m_dwAssembleBufferSize < dwSize)
        {
        // Need to wait for more data to arrive
        dwStatus = ERROR_CONTINUE;
        }
    else
        {
        // Too much data...
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        // Check to make sure the contents of the PDU "look" Ok:

        if ( (pInfNegotiation->InfType != INF_TYPE_NEGOTIATION)
           || (pInfNegotiation->InfVersion < INF_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckConnectRespPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = m_dwAssembleBufferSize;
            memcpy(*ppPdu,m_pAssembleBuffer,m_dwAssembleBufferSize);
            m_dwAssembleBufferSize = 0;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckDisconnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckDisconnectPdu( OUT SCEP_HEADER **ppPdu,
                                            OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwSize;
    SCEP_DISCONNECT  *pDisconnect;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_DISCONNECT);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_DISCONNECT)
        {
        return ERROR_CONTINUE;
        }

    pDisconnect = (SCEP_DISCONNECT*)(((SCEP_HEADER*)m_pAssembleBuffer)->Rest);

    // Check to make sure the contents of the PDU "look" Ok:

    if (pDisconnect->InfType != INF_TYPE_REASON)
        {
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (pDisconnect->Length1 != sizeof(USHORT))
        {
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckDisonnectPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = sizeof(SCEP_HEADER) + 2 + pDisconnect->Length1;
            memcpy(*ppPdu,m_pAssembleBuffer,*pdwPduSize);
            m_dwAssembleBufferSize -= *pdwPduSize;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckDataPdu()
//
// The goal here is to check to see if we have a complete formatted
// PDU, if yes the return NO_ERROR, if the PDU looks ok so far, but
// isn't complete (we need to read more), then return ERROR_CONTINUE.
//
// Also if this is a little-endian machine, byteswap the header
// fields accordingly.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckDataPdu( OUT SCEP_HEADER **ppPdu,
                                      OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwExpectedPduSize;
    UCHAR *pEnd;
    SCEP_REQ_HEADER_SHORT *pReqHeaderShort;
    SCEP_REQ_HEADER_LONG  *pReqHeaderLong;

    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType == MSG_TYPE_DATA);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_DATA)
        {
        return ERROR_CONTINUE;
        }

    // Get the length out of the PDU and see if we have a
    // complete PDU:

    pReqHeaderShort = (SCEP_REQ_HEADER_SHORT*)
                             (((SCEP_HEADER*)m_pAssembleBuffer)->Rest);
    if (pReqHeaderShort->Length1 == USE_LENGTH2)
        {
        // We have a long PDU:

        pReqHeaderLong = (SCEP_REQ_HEADER_LONG*)(pReqHeaderShort);

        #ifdef LITTLE_ENDIAN
        if (!m_fDidByteSwap)
            {
            ByteSwapReqHeaderLong(pReqHeaderLong);
            m_fDidByteSwap = TRUE;
            }
        #endif

        dwExpectedPduSize = sizeof(SCEP_HEADER)
                            + FIELD_OFFSET(SCEP_REQ_HEADER_LONG,InfVersion)
                            + pReqHeaderLong->Length2;
        }
    else
        {
        // We have a short PDU:

        #ifdef LITTLE_ENDIAN
        if (!m_fDidByteSwap)
            {
            ByteSwapReqHeaderShort(pReqHeaderShort);
            m_fDidByteSwap = TRUE;
            }
        #endif

        dwExpectedPduSize = sizeof(SCEP_HEADER)
                            + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT,InfVersion)
                            + pReqHeaderShort->Length1;
        }

    // Ok, see if we have a complete PDU:
    if (m_dwAssembleBufferSize == dwExpectedPduSize)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckDataPdu(): Out of memory."));
            #endif
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = dwExpectedPduSize;
            memcpy(*ppPdu,m_pAssembleBuffer,dwExpectedPduSize);
            m_dwAssembleBufferSize = 0;
            m_fDidByteSwap = FALSE;
            dwStatus = NO_ERROR;
            }
        }
    else if (m_dwAssembleBufferSize > dwExpectedPduSize)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            WIAS_ERROR((g_hInst,"CSCEP_CONNECTION::CheckDataPdu(): Out of memory."));
            dwStatus = ERROR_OUTOFMEMORY;
            }
        else
            {
            *pdwPduSize = dwExpectedPduSize;
            memcpy(*ppPdu,m_pAssembleBuffer,dwExpectedPduSize);
            pEnd = dwExpectedPduSize + (UCHAR*)m_pAssembleBuffer;
            m_dwAssembleBufferSize -= dwExpectedPduSize;
            m_fDidByteSwap = FALSE;
            memcpy(m_pAssembleBuffer,pEnd,m_dwAssembleBufferSize);
            dwStatus = NO_ERROR;
            }
        }
    else
        {
        dwStatus = ERROR_CONTINUE;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseConnectPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectPdu()), so at this point we'll assume everything
// is Ok.
//
// NOTE: The Connect PDU is limited to 256 bytes in total length,
// so it will never be fragmented.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseConnectPdu( IN SCEP_HEADER *pPdu,
                                         IN DWORD        dwInputDataSize )
    {
    DWORD  dwStatus;
    DWORD  dwLength;

    if (dwInputDataSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    SCEP_VERSION     *pInfVersion;
    SCEP_NEGOTIATION *pInfNegotiation;
    SCEP_EXTEND      *pInfExtend;

    pInfVersion = (SCEP_VERSION*)pPdu->Rest;

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_VERSION)
                                           + (char*)pInfVersion );

    pInfExtend = (SCEP_EXTEND*)( FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
                                 + pInfNegotiation->Length
                                 + (char*)pInfNegotiation );

    // 
    m_CFlag = pInfNegotiation->CFlag;
    
    m_pSecondaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pSecondaryMachineId)
        {
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pSecondaryMachineId,
            pInfNegotiation->SecondaryMachineId,
            MACHINE_ID_SIZE );
    
    m_pPrimaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pPrimaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pPrimaryMachineId,
            pInfNegotiation->PrimaryMachineId,
            MACHINE_ID_SIZE );

    // NOTE: The size of the negotiaion "text" is 18 bytes less than
    // the length in the SCEP_NEGOTIATION record:
    dwLength = pInfNegotiation->Length
             - ( sizeof(pInfNegotiation->InfVersion)
               + sizeof(pInfNegotiation->CFlag)
               + sizeof(pInfNegotiation->SecondaryMachineId)
               + sizeof(pInfNegotiation->PrimaryMachineId));

    dwStatus = ParseNegotiation( pInfNegotiation->Negotiation, dwLength );

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseConnectRespPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectRespPdu()), so at this point we'll assume 
// everything is Ok.
//
// NOTE: The Connect Response PDU is limited to 255 bytes in total
// length, so it will never be fragmented.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseConnectRespPdu( IN SCEP_HEADER *pPdu,
                                             IN DWORD        dwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwLength;
    SCEP_NEGOTIATION *pInfNegotiation;


    if (dwPduSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_HEADER)
                                           + (char*)pPdu );

    // This is the CFlag sent by the other machine.
    m_CFlag = pInfNegotiation->CFlag;

    m_pSecondaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pSecondaryMachineId)
        {
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pSecondaryMachineId,
            pInfNegotiation->SecondaryMachineId,
            MACHINE_ID_SIZE );
    
    m_pPrimaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pPrimaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        return ERROR_OUTOFMEMORY;
        }

    memcpy( m_pPrimaryMachineId,
            pInfNegotiation->PrimaryMachineId,
            MACHINE_ID_SIZE );

    // NOTE: The size of the negotiaion "text" is 18 bytes less than
    // the length in the SCEP_NEGOTIATION record:
    dwLength = pInfNegotiation->Length
             - ( sizeof(pInfNegotiation->InfVersion)
               + sizeof(pInfNegotiation->CFlag)
               + sizeof(pInfNegotiation->SecondaryMachineId)
               + sizeof(pInfNegotiation->PrimaryMachineId));

    dwStatus = ParseNegotiation( pInfNegotiation->Negotiation, dwLength );

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseNegotiation()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseNegotiation( IN UCHAR *pNegotiation,
                                          IN DWORD  dwNegotiationSize )
    {
    DWORD  dwStatus = NO_ERROR;
    UCHAR *pNext = pNegotiation;
    DWORD  dwSize = dwNegotiationSize;

    if (dwNegotiationSize <= 1)
        {
        return NO_ERROR;
        }

    if (*(pNext++) < NEGOTIATION_VERSION)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    dwSize--;

    while (pNext=ParseAttribute(pNext,
                                &dwSize,
                                &dwStatus))
       {
       if (dwStatus != NO_ERROR)
           {
           break;
           }
       }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseAttribute()
//
// Attributes are of the form:
//  
// Attr      <- AttrName Colon AttrValue CrLf
//
// AttrName  <- Two byte attribute name.
//
// Colon     <- ':'
//
// AttrValue <- Character string (bytes > 0x1f and < 0x8f).
//
// CrLf      <- 0x0d 0x0a
//
//--------------------------------------------------------------------
UCHAR *CSCEP_CONNECTION::ParseAttribute( IN  UCHAR *pAttributes,
                                         IN  DWORD *pdwAttributeSize,
                                         OUT DWORD *pdwStatus )
    {
    int  iAttribute;
    int  iPduSize;
    ATTRIBUTE_TOKEN  *pToken1 = 0;
    ATTRIBUTE_TOKEN  *pToken2 = 0;
    ATTRIBUTE_TOKEN  *pToken3 = 0;
    ATTRIBUTE_TOKEN  *pToken4 = 0;

    *pdwStatus = NO_ERROR;

    if (  (pToken1=NextToken(ATTRIBUTE_NAME,&pAttributes,pdwAttributeSize))
       && (IsAttributeName(pToken1,&iAttribute))
       && (pToken2=NextToken(ATTRIBUTE_COLON,&pAttributes,pdwAttributeSize))
       && (pToken3=NextToken(ATTRIBUTE_VALUE,&pAttributes,pdwAttributeSize))
       && (pToken4=NextToken(ATTRIBUTE_CRLF,&pAttributes,pdwAttributeSize)) )
        {
        if (iAttribute == ATTR_PDU_SIZE)
            {
            iPduSize = pToken3->pChars[0] - ONE;
            if ((pToken3->dwSize == 1)&&(iPduSize >= 1)&&(iPduSize <= 4))
                {
                m_dwPduSendSize = g_adwPduSizes[iPduSize];
                }
            }
        else
        if (iAttribute == ATTR_PRODUCT_ID)
            {
            m_pszProductId = NewTokenString(pToken3,pdwStatus);
            if (!m_pszProductId)
                {
                pAttributes = 0;
                }
            }
        else
        if (iAttribute == ATTR_USER_NAME)
            {
            m_pszUserName = NewTokenString(pToken3,pdwStatus);
            if (!m_pszUserName)
                {
                pAttributes = 0;
                }
            }
        else
        if (iAttribute == ATTR_PASSWORD)
            {
            m_pszPassword = NewTokenString(pToken3,pdwStatus);
            if (!m_pszPassword)
                {
                pAttributes = 0;
                }
            }
        }
    else
        {
        if (*pdwAttributeSize > 0)
            {
            *pdwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        pAttributes = 0;
        }

    if (pToken1) FreeMemory(pToken1);
    if (pToken2) FreeMemory(pToken2);
    if (pToken3) FreeMemory(pToken3);
    if (pToken4) FreeMemory(pToken4);

    return pAttributes;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseDataPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectPdu()), so at this point we'll assume everything
// is Ok.
//
// NOTE: The Data PDU is limited to m_dwPduReceiveSize bytes in total
// length, if data is longer then you will get the fragmented versions
// of the Data PDU.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseDataPdu( IN  SCEP_HEADER     *pPdu,
                                      IN  DWORD            dwPduSize,
                                      OUT COMMAND_HEADER **ppCommand,
                                      OUT UCHAR          **ppUserData,
                                      OUT DWORD           *pdwUserDataSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwLengthOffset1;
    DWORD  dwLengthOffset3;

    // There are four cases of Data PDUs, single (unfragmented)
    // "short" and "long" PDUs, and fragmented "short" and
    // "long" PDUs:
    SCEP_REQ_HEADER_SHORT *pReqHeaderShort;
    SCEP_REQ_HEADER_LONG  *pReqHeaderLong;
    SCEP_REQ_HEADER_SHORT_FRAG *pReqHeaderShortFrag;
    SCEP_REQ_HEADER_LONG_FRAG  *pReqHeaderLongFrag;

    *ppCommand = 0;

    // Make sure the packet length makes sense...
    if (dwPduSize > m_dwPduReceiveSize)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pReqHeaderShort = (SCEP_REQ_HEADER_SHORT*)(pPdu->Rest);

    if (pReqHeaderShort->InfType != INF_TYPE_USER_DATA)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    //
    // See if we have a short or long PDU:
    //
    if (pReqHeaderShort->Length1 != USE_LENGTH2)
        {
        // This is a short PDU (use Length1).

        m_DFlag = pReqHeaderShort->DFlag;

        if ( (pReqHeaderShort->DFlag == DFLAG_SINGLE_PDU)
           || (pReqHeaderShort->DFlag == DFLAG_CONNECT_REJECT))
            {
            //
            // This is a short unfragmented PDU.
            //

            // Make sure that a command header is present:
            if (pReqHeaderShort->Length1 > 4)
                {
                *ppCommand = (COMMAND_HEADER*)(pReqHeaderShort->CommandHeader);
                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderShort->CommandHeader;
            *pdwUserDataSize = pReqHeaderShort->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = FALSE;
            m_dwSequenceNo = 0;
            m_dwRestNo = 0;

            // In this case, there are two different lengths
            // in the PDU that must add up to dwPduSize...
            //
            // Note: Note: Not currently testing Length1 for 
            //       consistency...
            //
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT,CommandHeader);

            if (dwPduSize != dwLengthOffset3+pReqHeaderShort->Length3)
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (pReqHeaderShort->DFlag == DFLAG_FIRST_FRAGMENT)
            {
            //
            // This is a short fragmented PDU, and is the first 
            // fragment, so it will contain a COMMAND_HEADER.
            //
            // In practice, this should probably never show up...

            pReqHeaderShortFrag = (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort;

            // The command header is present only on the first fragment
            // of a multi-fragment PDU:
            if (pReqHeaderShortFrag->SequenceNo == 0)
                {
                *ppCommand 
                    = (COMMAND_HEADER*)(pReqHeaderShortFrag->CommandHeader);

                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData 
                = COMMAND_HEADER_SIZE + pReqHeaderShortFrag->CommandHeader;
            *pdwUserDataSize 
                = pReqHeaderShortFrag->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderShortFrag->SequenceNo;
            m_dwRestNo = pReqHeaderShortFrag->RestNo;

            // Check the two length fields for consistency:
            dwLengthOffset1 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,InfVersion);
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,SequenceNo);

            if ( (dwPduSize != dwLengthOffset1+pReqHeaderShortFrag->Length1)
               || (dwPduSize != dwLengthOffset3+pReqHeaderShortFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (  (pReqHeaderShort->DFlag == DFLAG_FRAGMENT)
                || (pReqHeaderShort->DFlag == DFLAG_LAST_FRAGMENT))
            {
            //
            // This is a short fragmented PDU.
            //
            // The 2nd through last fragmented PDUs don't contain a
            // COMMAND_HEADER, just data after Length3.
            pReqHeaderShortFrag = (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort;

            // The command header is present only on the first fragment
            // of a multi-fragment PDU:
            if (pReqHeaderShortFrag->SequenceNo == 0)
                {
                *ppCommand 
                    = (COMMAND_HEADER*)(pReqHeaderShortFrag->CommandHeader);

                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData = pReqHeaderShortFrag->CommandHeader;
            *pdwUserDataSize = pReqHeaderShortFrag->Length3;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderShortFrag->SequenceNo;
            m_dwRestNo = pReqHeaderShortFrag->RestNo;

            // Check the two length fields for consistency:
            dwLengthOffset1 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,InfVersion);
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,SequenceNo);

            if ( (dwPduSize != dwLengthOffset1+pReqHeaderShortFrag->Length1)
               || (dwPduSize != dwLengthOffset3+pReqHeaderShortFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else
            {
            // Undefined DFlag, we've got a problem...
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }
    else
        {
        // We have a long PDU.

        pReqHeaderLong = (SCEP_REQ_HEADER_LONG*)pReqHeaderShort;

        m_DFlag = pReqHeaderLong->DFlag;

        if ( (pReqHeaderLong->DFlag == DFLAG_SINGLE_PDU)
           || (pReqHeaderLong->DFlag == DFLAG_CONNECT_REJECT))
            {
            //
            // This is a long unfragmented PDU.
            //
            *ppCommand = (COMMAND_HEADER*)(pReqHeaderLong->CommandHeader);
            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderLong->CommandHeader;
            *pdwUserDataSize = pReqHeaderLong->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = FALSE;
            m_dwSequenceNo = 0;
            m_dwRestNo = 0;
            m_SrcPid = (*ppCommand)->SrcPid;
            m_DestPid = (*ppCommand)->DestPid;
            m_dwCommandId = (*ppCommand)->CommandId;

            // In this case, there are two different lengths
            // in the PDU that must add up to dwPduSize...
            if ( (dwPduSize != 6UL+pReqHeaderLong->Length2)
               || (dwPduSize != 10UL+pReqHeaderLong->Length3))
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (pReqHeaderLong->DFlag == DFLAG_FIRST_FRAGMENT)
            {
            //
            // This is the first fragment of a long fragmented PDU.
            //
            pReqHeaderLongFrag = (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong;

            m_pCommandHeader = (COMMAND_HEADER*)AllocateMemory(sizeof(COMMAND_HEADER));
            if (!m_pCommandHeader)
                {
                dwStatus = ERROR_OUTOFMEMORY;
                }
            else
                {
                memcpy(m_pCommandHeader,
                       pReqHeaderLongFrag->CommandHeader,
                       COMMAND_HEADER_SIZE );

                *ppCommand = m_pCommandHeader;
                }

            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderLongFrag->CommandHeader;
            *pdwUserDataSize = pReqHeaderLongFrag->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderLongFrag->SequenceNo;
            m_dwRestNo = pReqHeaderLongFrag->RestNo;
            m_dwCommandId = (*ppCommand)->CommandId;

            // Check the two length fields for consistency:
            if ( (dwPduSize != (DWORD)6+pReqHeaderLongFrag->Length2)
               || (dwPduSize != (DWORD)18+pReqHeaderLongFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if ( (pReqHeaderLong->DFlag == DFLAG_FRAGMENT)
                  || (pReqHeaderLong->DFlag == DFLAG_LAST_FRAGMENT) )
            {
            //
            // This is the second through last fragment of a long 
            // fragmented PDU.
            //
            // In this case the PDU doesn't contain a command
            // header, just more user data...
            //
            pReqHeaderLongFrag = (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong;

            *ppCommand = m_pCommandHeader;
            *ppUserData = (UCHAR*)(pReqHeaderLongFrag->CommandHeader);
            *pdwUserDataSize = pReqHeaderLongFrag->Length3;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderLongFrag->SequenceNo;
            m_dwRestNo = pReqHeaderLongFrag->RestNo;
            if (*ppCommand)
               {
               m_dwCommandId = (*ppCommand)->CommandId;
               }

            // Check the two length fields for consistency:
            if ( (dwPduSize != (DWORD)6+pReqHeaderLongFrag->Length2)
               || (dwPduSize != (DWORD)18+pReqHeaderLongFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else
            {
            // Undefined DFlag, we've got a problem...
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseDisconnectPdu()
//
// NOTE: In practice, reason codes should always be 2 bytes for
//       SCEP version 1.0.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseDisconnectPdu( IN  SCEP_HEADER *pPdu,
                                            IN  DWORD        dwPduSize )
    {
    DWORD  dwStatus;

    SCEP_DISCONNECT *pDisconnect = (SCEP_DISCONNECT*)(pPdu->Rest);

    if ( (pDisconnect->InfType != INF_TYPE_REASON)
       || (pDisconnect->Length1 != sizeof(USHORT))
       || (pDisconnect->ReasonCode == 0) )
        {
        dwStatus = ERROR_SCEP_UNSPECIFIED_DISCONNECT;
        }
    else if (pDisconnect->ReasonCode == 1)
        {
        dwStatus = ERROR_SCEP_USER_DISCONNECT;
        }
    else if (pDisconnect->ReasonCode == 2)
        {
        dwStatus = ERROR_SCEP_PROVIDER_DISCONNECT;
        }
    else
        {
        dwStatus = ERROR_SCEP_UNSPECIFIED_DISCONNECT;
        }
    
    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParsePdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParsePdu( IN  SCEP_HEADER *pPdu,
                                  IN  DWORD        dwPduSize,
                                  OUT COMMAND_HEADER **ppCommandHeader,
                                  OUT UCHAR          **ppUserData,
                                  OUT DWORD           *pdwUserDataSize )
    {
    DWORD  dwStatus = NO_ERROR;

    *ppCommandHeader = 0;
    *ppUserData = 0;
    *pdwUserDataSize = 0;

    switch (pPdu->MsgType)
        {
        case MSG_TYPE_CONNECT_REQ:
            dwStatus = ParseConnectPdu( pPdu, dwPduSize );
            break;

        case MSG_TYPE_CONNECT_RESP:
            dwStatus = ParseConnectRespPdu( pPdu, dwPduSize );
            break;

        case MSG_TYPE_DATA:
            dwStatus = ParseDataPdu( pPdu, 
                                     dwPduSize, 
                                     ppCommandHeader, 
                                     ppUserData,
                                     pdwUserDataSize );
            break;

        case MSG_TYPE_DISCONNECT:
            dwStatus = ParseDisconnectPdu( pPdu, dwPduSize );
            break;

        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectPdu( OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_VERSION      *pVersion;
    SCEP_NEGOTIATION  *pNegotiation;
    SCEP_EXTEND       *pExtend;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // Note that the PDU size doesn't include a trailing zero, as you 
    // would think by lookin at "sizeof(CONNECT_PDU_ATTRIBUTES)" below.
    // The extra byte is for the first byte of the Negotiation string
    // (which is the Negotiation version), so the eqn below is +1-1...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_VERSION)
                + sizeof(SCEP_NEGOTIATION)
                + sizeof(CONNECT_PDU_ATTRIBUTES)
                + sizeof(SCEP_EXTEND);

    pHeader = NewPdu();  // PDU size is defaulted to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_REQ;

    pVersion = (SCEP_VERSION*)(pHeader->Rest);
    pVersion->InfType = INF_TYPE_VERSION;
    pVersion->Version = PROTOCOL_VERSION;

    pNegotiation = (SCEP_NEGOTIATION*)((char*)pVersion + sizeof(SCEP_VERSION));
    pNegotiation->InfType = INF_TYPE_NEGOTIATION;
    pNegotiation->Length = 18 + sizeof(CONNECT_PDU_ATTRIBUTES);
    pNegotiation->InfVersion = INF_VERSION;
    pNegotiation->CFlag = CFLAG_ISSUE_OR_EXECUTE;
    // pNegotiation->SecondaryMachineId -- Leave set to zeros...
    // pNegotiation->PrimaryMachineId   -- Leave set to zeros...

    pNegotiation->Negotiation[0] = NEGOTIATION_VERSION;
    memcpy( &(pNegotiation->Negotiation[1]),
            CONNECT_PDU_ATTRIBUTES,
            sizeof(CONNECT_PDU_ATTRIBUTES)-1 );  // No Trailing zero...

    pExtend = (SCEP_EXTEND*)( (char*)pHeader + dwPduSize - sizeof(SCEP_EXTEND));
    pExtend->InfType = INF_TYPE_EXTEND;
    pExtend->Length = 2;
    pExtend->Parameter1 = 0;
    pExtend->Parameter2 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectRespPdu()
//
// This is the response PDU for a connection request from a camera.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_NEGOTIATION  *pNegotiation;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // Note that the PDU size doesn't include a trailing zero, as you 
    // would think by lookin at "sizeof(RESPONSE_PDU_ATTRIBUTES)" below,
    // the extra byte in for the first byte of the Negotiation string
    // which is the Negotiation version, so the eqn below is +1-1...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_NEGOTIATION)
                + sizeof(RESPONSE_PDU_ATTRIBUTES);

    pHeader = NewPdu();   // PDU size defaults to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_RESP;
    
    pNegotiation = (SCEP_NEGOTIATION*)(pHeader->Rest);
    pNegotiation->InfType = INF_TYPE_NEGOTIATION;
    pNegotiation->Length = 18 + sizeof(RESPONSE_PDU_ATTRIBUTES);
    pNegotiation->InfVersion = INF_VERSION;
    pNegotiation->CFlag = CFLAG_ISSUE_OR_EXECUTE;

    memcpy( pNegotiation->SecondaryMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pNegotiation->PrimaryMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    pNegotiation->Negotiation[0] = NEGOTIATION_VERSION;
    memcpy( &(pNegotiation->Negotiation[1]),
            RESPONSE_PDU_ATTRIBUTES,
            sizeof(RESPONSE_PDU_ATTRIBUTES)-1 );  // No Trailing zero...

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectNackPdu()
//
// This is the response PDU for a connection request from a camera
// when we want to reject the connection request.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectNackPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // A short PDU, there is now command header, so Length3 is zero...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_REQ_HEADER_SHORT)
                - sizeof(COMMAND_HEADER);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_REQ;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = sizeof(pReqHeader->InfVersion)
                        + sizeof(pReqHeader->DFlag)
                        + sizeof(pReqHeader->Length3);
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_CONNECT_REJECT;
    pReqHeader->Length3 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildAbortPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildAbortPdu( OUT SCEP_HEADER **ppPdu,
                                       OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    COMMAND_HEADER    *pCommandHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) + sizeof(SCEP_REQ_HEADER_SHORT);

    pHeader = NewPdu();   // PDU size default to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = 4 + sizeof(COMMAND_HEADER);
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_SINGLE_PDU;
    pReqHeader->Length3 = sizeof(COMMAND_HEADER);

    #ifdef LITTLE_ENDIAN
    pReqHeader->Length3 = ByteSwapShort(pReqHeader->Length3);
    #endif

    pCommandHeader = (COMMAND_HEADER*)(pReqHeader->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_ABORT;
    pCommandHeader->Length4 = 22;
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    #ifdef LITTLE_ENDIAN
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildStopPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildStopPdu( OUT SCEP_HEADER **ppPdu,
                                      OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) 
                + sizeof(SCEP_REQ_HEADER_SHORT)
                - sizeof(COMMAND_HEADER);

    pHeader = NewPdu();   // PDU size defaults to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = 4;
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_INTERRUPT;
    pReqHeader->Length3 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildDisconnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildDisconnectPdu( IN  USHORT        ReasonCode,
                                            OUT SCEP_HEADER **ppPdu,
                                            OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER     *pHeader;
    SCEP_DISCONNECT *pDisconnect;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) 
                + sizeof(SCEP_DISCONNECT);

    pHeader = NewPdu();   // PDU size defaults to MAX_PDU_SIZE.
    if (!pHeader)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DISCONNECT;

    pDisconnect = (SCEP_DISCONNECT*)(pHeader->Rest);
    pDisconnect->InfType = INF_TYPE_REASON;
    pDisconnect->Length1 = sizeof(pDisconnect->ReasonCode);
    pDisconnect->ReasonCode = ReasonCode;

    #ifdef LITTLE_ENDIAN
    pDisconnect->ReasonCode = ByteSwapShort(pDisconnect->ReasonCode);
    #endif

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::SetScepLength()
//
// Update the length fields in a PDU to reflect the total length
// of a PDU.
//
// WARNING: Currently only supports long fragmented PDUs.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::SetScepLength( IN SCEP_HEADER *pPdu,
                                       IN DWORD        dwTotalPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_REQ_HEADER_LONG_FRAG *pScepHeader;

    if (dwTotalPduSize > MAX_PDU_SIZE)
        {
        dwStatus = ERROR_SCEP_PDU_TOO_LARGE;
        }
    else
        {
        pScepHeader = (SCEP_REQ_HEADER_LONG_FRAG *)(pPdu->Rest);
        pScepHeader->Length1 = USE_LENGTH2;
        pScepHeader->Length2 = (USHORT)dwTotalPduSize - 6;
        pScepHeader->Length3 = (USHORT)dwTotalPduSize - 18;

        #ifdef LITTLE_ENDIAN
        pScepHeader->Length2 = ByteSwapShort(pScepHeader->Length2);
        pScepHeader->Length3 = ByteSwapShort(pScepHeader->Length3);
        #endif
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\version.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       version.h
//
//  Contents:   Provides version info
//
//  Author:     edwardr   04-28-99
//
//----------------------------------------------------------------------------

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Configuration Tool"
#define VER_INTERNALNAME_STR            "netafx.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\camera.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camera.cpp

Abstract:

    This module implements the CPTPCamera class, which is a generic implementation
    of a PTP camera. Transport-specific processing is implemented in a sub-class.

Author:

    William Hsieh (williamh) created

Revision History:

--*/

#include "ptppch.h"

//
// This thread reads event data from the device and sends it back to the minidriver
//
// Input:
//   pParam -- pointer to the CPTPCamera subclassed object which can read the data
// Output:
//   Thread exit code
//
DWORD
WINAPI
EventThread(
    LPVOID pParam
    )
{
    DBG_FN("EventThread");
    
    HRESULT hr = S_OK;
    
    CPTPCamera *pDevice;

    wiauDbgTrace("EventThread", "starting");

    pDevice = (CPTPCamera *)pParam;
    if (!pDevice)
    {
        wiauDbgError("EventThread", "invalid arg");
        return ERROR_INVALID_PARAMETER;
    }

    DWORD Win32Err;

    //
    // Call the callback once with a NULL pointer so that it can initialize itself
    //
    hr = (pDevice->GetPTPEventCallback())(pDevice->GetEventCallbackParam(), NULL);
    if (FAILED(hr))
    {
        //
        // Log an error, but keep on catching events
        //
        wiauDbgError("EventThread", "event callback failed");
    }

    //
    // Read an event from the device. If an error occurs, log an error message and then
    // continue, unless the operation was aborted by the main thread.
    //
    PPTP_EVENT pEventBuffer = pDevice->GetEventBuffer();
    while (TRUE)
    {
        ZeroMemory(pEventBuffer, sizeof(*pEventBuffer));
        hr = pDevice->ReadEvent(pEventBuffer);
        if (FAILED(hr))
        {
            wiauDbgError("EventThread", "ReadEvent failed");
            break;;
        }

        if (hr == S_FALSE) {
            wiauDbgTrace("EventThread", "ReadEvent cancelled");
            break;
        }

        if (g_dwDebugFlags & WIAUDBG_DUMP) {
            DumpEvent(pEventBuffer);
        }
        
        //
        // Send the event back to the minidriver via its callback function
        //
        hr = (pDevice->GetPTPEventCallback())(pDevice->GetEventCallbackParam(), pEventBuffer);
        if (FAILED(hr))
        {
            wiauDbgError("EventThread", "event callback failed");
        }
    }

    //
    // The thread will now exit normally
    //
    wiauDbgTrace("EventThread", "exiting");
    
    return 0;
}


//
// Constructor for CPTPCamera
//
CPTPCamera::CPTPCamera()
:   m_hEventThread(NULL),
    m_SessionId(0),
    m_Phase(CAMERA_PHASE_NOTREADY),
    m_NextTransactionId(PTP_TRANSACTIONID_MIN),
    m_pTransferBuffer(NULL),
    m_pPTPEventCB(NULL),
    m_pPTPDataCB(NULL),
    m_pEventCallbackParam(NULL),
    m_pDataCallbackParam(NULL), 
    m_HackModel(HACK_MODEL_NONE),
    m_HackVersion(0.0)
{
    //PP_INIT_TRACING(L"Microsoft\\WIA\\PtpUsb");
}

//
// Destructor for CPTPCamera
//
CPTPCamera::~CPTPCamera()
{
    if (m_pTransferBuffer)
    {
        delete [] m_pTransferBuffer;
        m_pTransferBuffer = NULL;
    }

    //PP_CLEANUP();
}

//
// This function is the first one called by the driver to open access to the camera. The
// subclass Open should call this function first.
//
// Input:
//   DevicePortName -- name used by sub-class to access device
//   pPTPEventCB -- pointer to event callback function
//
HRESULT
CPTPCamera::Open(
    LPWSTR DevicePortName,
    PTPEventCallback pPTPEventCB,
    PTPDataCallback pPTPDataCB,
    LPVOID pEventParam,
    BOOL bEnableEvents
    )
{
    DBG_FN("CPTPCamera::Open");

    HRESULT hr = S_OK;
    
    if (!DevicePortName ||
        ((bEnableEvents == TRUE) && (!pPTPEventCB)))
    {
        wiauDbgError("Open", "invalid arg");
        return E_INVALIDARG;
    }

    m_bEventsEnabled = bEnableEvents;

    //
    // Allocate the re-usable transfer buffer
    //
    m_pTransferBuffer = new BYTE[TRANSFER_BUFFER_SIZE];
    if (!m_pTransferBuffer)
    {
        wiauDbgError("Open", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Save the callback pointers and object
    //
    m_pPTPEventCB = pPTPEventCB;
    m_pPTPDataCB = pPTPDataCB;
    m_pEventCallbackParam = pEventParam;
    m_pDataCallbackParam = NULL;
    
    //
    // The camera isn't actually ready yet, but this is the best place to set the phase to idle
    //
    m_Phase = CAMERA_PHASE_IDLE;

    if (m_bEventsEnabled)
    {
        //
        // Create a thread to listen for events
        //
        DWORD ThreadId;
        m_hEventThread = CreateThread(NULL,             // security descriptor
                                      0,                // stack size, use same size as this thread
                                      EventThread,      // thread procedure
                                      this,             // parameter to the thread
                                      CREATE_SUSPENDED, // creation flags
                                      &ThreadId         // to receive thread id
                                     );
        if (!m_hEventThread)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "Open", "CreateThread failed");
            return hr;
        }
    }

    //
    // The subclass should now open the device with CreateFile or equivalent
    //

    return hr;
}

//
// This function closes the connection to the camera.
//
HRESULT
CPTPCamera::Close()
{
    DBG_FN("CPTPCamera::Close");

    HRESULT hr = S_OK;

    if (IsCameraSessionOpen())
    {
        hr = CloseSession();
        if (FAILED(hr))
        {
            wiauDbgError("Close", "CloseSession failed");
            return hr;
        }
    }

    return hr;
}

//
// This function is responsible for executing a PTP command, reading or
// writing any necessary data, and reading the response
//
// Input/Output:
//   pData -- pointer to use for optional reading or writing of data
//
HRESULT
CPTPCamera::ExecuteCommand(
    BYTE *pReadData,
    UINT *pReadDataSize,
    BYTE *pWriteData,
    UINT WriteDataSize,
    UINT NumCommandParams,
    CAMERA_PHASE NextPhase
    )
{
    DBG_FN("CPTPCamera::ExecuteCommand");

    HRESULT hr = S_OK;

    BOOL bCommandCancelled = FALSE;

    //
    // If data is being tranferred, check the appropriate buffer pointer
    //
    if ((NextPhase == CAMERA_PHASE_DATAIN && (!pReadData || !pReadDataSize)) ||
        (NextPhase == CAMERA_PHASE_DATAOUT && !pWriteData))
    {
        wiauDbgError("ExecuteCommand", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Verify that the camera is ready
    //
    if (m_Phase != CAMERA_PHASE_IDLE)
    {
        wiauDbgError("ExecuteCommand", "camera is not in idle phase, phase = %d", m_Phase);
        return E_FAIL;
    }

    //
    // Set the session and transaction IDs
    //
    
    if (IsCameraSessionOpen())
    {
        m_CommandBuffer.SessionId = m_SessionId;
        m_CommandBuffer.TransactionId = GetNextTransactionId();
    }
    else
    {
        if (m_CommandBuffer.OpCode == PTP_OPCODE_GETDEVICEINFO ||
            m_CommandBuffer.OpCode == PTP_OPCODE_OPENSESSION)
        {
            m_CommandBuffer.SessionId = PTP_SESSIONID_NOSESSION;
            m_CommandBuffer.TransactionId = PTP_TRANSACTIONID_NOSESSION;
        }
        else
        {
            wiauDbgError("ExecuteCommand", "session must first be opened");
            return E_FAIL;
        }
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        DumpCommand(&m_CommandBuffer, NumCommandParams);

    //
    // Send the command to the camera
    //
    m_Phase = CAMERA_PHASE_CMD;
    hr = SendCommand(&m_CommandBuffer, NumCommandParams);
    if (FAILED(hr))
    {
        wiauDbgError("ExecuteCommand", "SendCommand failed");
        m_Phase = CAMERA_PHASE_IDLE;

        RecoverFromError();
        
        return hr;
    }
    
    m_Phase = NextPhase;

    //
    // Get data, if necessary
    //
    if (m_Phase == CAMERA_PHASE_DATAIN)
    {
        hr = ReadData(pReadData, pReadDataSize);
        if (FAILED(hr))
        {
            m_Phase = CAMERA_PHASE_IDLE;
            wiauDbgError("ExecuteCommand", "ReadData failed");
            RecoverFromError();
            return hr;
        }
        
        if (hr == S_FALSE)
        {
            bCommandCancelled = TRUE;
        }
        else
        {
            //
            // If transfer was cancelled, ReadData has already set appropriate next phase
            // If not, set it to CAMERA_PHASE_RESPONSE now
            //
            m_Phase = CAMERA_PHASE_RESPONSE;
        }
    } 
    else 
    {
        // there is no data phase, tell caller there is no in data
        // (please, note that caller knows and will adjust for
        // obligatory response size) #337129
        if(pReadDataSize) *pReadDataSize = 0;
    }

    //
    // Send data, if necessary
    //
    if (m_Phase == CAMERA_PHASE_DATAOUT)
    {
        hr = SendData(pWriteData, WriteDataSize);
        if (FAILED(hr))
        {
            wiauDbgError("ExecuteCommand", "SendData failed");
            m_Phase = CAMERA_PHASE_IDLE;
            RecoverFromError();
            return hr;
        }

        if (hr == S_FALSE)
        {
            bCommandCancelled = TRUE;
        }
        else
        {
            //
            // If transfer was cancelled, SendData has already set appropriate next phase
            // If not, set it to CAMERA_PHASE_RESPONSE now
            //
            m_Phase = CAMERA_PHASE_RESPONSE;
        }
    }

    //
    // Read the response, if necessary
    //
    if (m_Phase == CAMERA_PHASE_RESPONSE)
    {
        memset(&m_ResponseBuffer, NULL, sizeof(m_ResponseBuffer));

        hr = ReadResponse(&m_ResponseBuffer);
        if (FAILED(hr))
        {
            wiauDbgError("ExecuteCommand", "ReadResponse failed");
            m_Phase = CAMERA_PHASE_IDLE;
            RecoverFromError();
            return hr;
        }

        if (g_dwDebugFlags & WIAUDBG_DUMP)
            DumpResponse(&m_ResponseBuffer);

        if (m_ResponseBuffer.ResponseCode != PTP_RESPONSECODE_OK && 
            m_ResponseBuffer.ResponseCode != PTP_RESPONSECODE_SESSIONALREADYOPENED)
        {
            wiauDbgError("ExecuteCommand", "bad response code = 0x%04x", m_ResponseBuffer.ResponseCode);
            //
            // Convert the PTP response code to an HRESULT;
            //
            hr = HRESULT_FROM_PTP(m_ResponseBuffer.ResponseCode);
        }

        m_Phase = CAMERA_PHASE_IDLE;
    }

    if (SUCCEEDED(hr) && bCommandCancelled)
    {
        hr = S_FALSE;
    }

    return hr;
}

//
// All of the "command" functions below have the same basic structure:
//   1. Check the arguments (if any) to make sure they are valid
//   2. Set up the opcode and parameters (if any) in the command buffer
//   3. Call ExecuteCommand
//   4. Check the return code
//   5. Parse the returned raw data (if any) into a PTP structure
//   6. If debugging is turned on, dump the data
//   7. Return
//

//
// This function gets the device info structure from the camera
//
// Output:
//   pDeviceInfo -- to receive the structure
//
HRESULT
CPTPCamera::GetDeviceInfo(
    CPtpDeviceInfo *pDeviceInfo
    )
{
    DBG_FN("CPTPCamera::GetDeviceInfo");

    HRESULT hr = S_OK;
    
    if (!pDeviceInfo)
    {
        wiauDbgError("GetDeviceInfo", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETDEVICEINFO;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 0, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetDeviceInfo", "ExecuteCommand failed");
        return hr;
    }

    hr = pDeviceInfo->Init(m_pTransferBuffer);
    if (FAILED(hr))
    {
        wiauDbgError("GetDeviceInfo", "couldn't parse DeviceInfo data");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pDeviceInfo->Dump();

    //
    // Set the model and version hack variables
    //
    SetupHackInfo(pDeviceInfo);

    return hr;
}

//
// This function opens a session on the camera for the caller. It is a little different
// than the other command functions. If it initially fails, it tries to recover and
// execute the OpenSession command again. It also starts the event thread.
//
// Input:
//   SessionId -- the session ID to open
//
HRESULT
CPTPCamera::OpenSession(
    DWORD SessionId
    )
{
    DBG_FN("CPTPCamera::OpenSession");

    HRESULT hr = S_OK;
    
    if (!SessionId)
    {
        wiauDbgError("OpenSession", "invalid arg");
        return E_INVALIDARG;
    }

    if (IsCameraSessionOpen())
    {
        wiauDbgError("OpenSession", "tried to open a session when one is already open");
        return E_FAIL;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_OPENSESSION;
    m_CommandBuffer.Params[0] = SessionId;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("OpenSession", "ExecuteCommand failed... attempting to recover and re-execute");
        
        hr = RecoverFromError();
        if (FAILED(hr))
        {
            wiauDbgError("OpenSession", "RecoverFromError failed");
            return hr;
        }

        //
        // Trying executing the command again
        //
        hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
        if (FAILED(hr))
        {
            wiauDbgError("OpenSession", "ExecuteCommand failed the second time");
            return hr;
        }
    }

    //
    // Set the session id
    //
    m_SessionId = SessionId;

    wiauDbgTrace("OpenSession", "session %d opened", m_SessionId);

    //
    // Resume the event thread that was created suspended
    //
    if (!m_hEventThread)
    {
        wiauDbgError("OpenSession", "event thread is null");
        return E_FAIL;
    }

    if (ResumeThread(m_hEventThread) != 1)
    {
        wiauDbgError("OpenSession", "ResumeThread failed");
        return E_FAIL;
    }

    //
    // Shouldn't need the handle to the thread anymore, so close it now
    //
    if (!CloseHandle(m_hEventThread))
    {
        wiauDbgError("OpenSession", "CloseHandle failed");
    }
    m_hEventThread = NULL;

    return hr;
}

//
// This function closes the session
//
HRESULT
CPTPCamera::CloseSession()
{
    DBG_FN("CPTPCamera::CloseSession");

    HRESULT hr = S_OK;
    
    m_CommandBuffer.OpCode = PTP_OPCODE_CLOSESESSION;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 0, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("CloseSession", "ExecuteCommand failed");
        return hr;
    }

    wiauDbgTrace("CloseSession", "session closed");

    //
    // The session is closed, so reset the session and transaction ids
    //
    m_SessionId = PTP_SESSIONID_NOSESSION;
    m_NextTransactionId = PTP_TRANSACTIONID_MIN;
    m_Phase = CAMERA_PHASE_NOTREADY;

    return hr;
}

//
// This function retrieves the list of all available storages on the device
//
// Output:
//   pStorageIdArray -- An empty array to receive the storage IDs
//
HRESULT
CPTPCamera::GetStorageIDs(
    CArray32 *pStorageIdArray
    )
{
    DBG_FN("CPTPCamera::GetStorageIDs");

    HRESULT hr = S_OK;

    if (!pStorageIdArray)
    {
        wiauDbgError("GetStorageIDs", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETSTORAGEIDS;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 0, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetStorageIDs", "ExecuteCommand failed");
        return hr;
    }

    BYTE *pTemp = m_pTransferBuffer;
    if (!pStorageIdArray->Parse(&pTemp))
    {
        wiauDbgError("GetStorageIDs", "couldn't parse storage id array");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pStorageIdArray->Dump("  Storage ids       =", "                     ");

    return hr;
}

//
// This function gets the information about the given storage
//
// Input:
//   StorageId -- the storage ID to get info about
// Output:
//   pStorageInfo -- the structure to receive the information
//
HRESULT
CPTPCamera::GetStorageInfo(
    DWORD StorageId,
    CPtpStorageInfo *pStorageInfo
    )
{
    DBG_FN("CPTPCamera::GetStorageInfo");

    HRESULT hr = S_OK;

    if (!StorageId ||
        !pStorageInfo)
    {
        wiauDbgError("GetStorageInfo", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETSTORAGEINFO;
    m_CommandBuffer.Params[0] = StorageId;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetStorageInfo", "ExecuteCommand failed");
        return hr;
    }

    hr = pStorageInfo->Init(m_pTransferBuffer, StorageId);
    if (FAILED(hr))
    {
        wiauDbgError("GetStorageInfo", "couldn't parse storage info");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pStorageInfo->Dump();

    return hr;
}

//
// This function gets the number of objects on a storage, optionally in a specific
// format or under a specific association object
//
// Input:
//   StorageId -- the designated storage, e.g. PTP_STORAGEID_ALL
//   FormatCode -- optional format type, e.g. PTP_FORMATCODE_ALL, PTP_FORMATCODE_IMAGE
//   ParentObjectHandle -- the object handle under which to count objects
// Output:
//   pNumObjects -- to receive the number of the object.
//
HRESULT
CPTPCamera::GetNumObjects(
    DWORD StorageId,
    WORD FormatCode,
    DWORD ParentObjectHandle,
    UINT *pNumObjects
    )
{
    DBG_FN("CPTPCamera::GetNumObjects");

    HRESULT hr = S_OK;
    
    if (!StorageId ||
        !pNumObjects)
    {
        wiauDbgError("GetNumObjects", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETNUMOBJECTS;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 3, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("GetNumObjects", "ExecuteCommand failed");
        return hr;
    }

    *pNumObjects = m_ResponseBuffer.Params[0];

    wiauDbgTrace("GetNumObjects", "number of objects = %d", *pNumObjects);

    return hr;
}

//
// This function gets the object handles under the given parent object
//
// Input:
//   StorageId -- the designated storage, e.g. PTP_STORAGEID_ALL
//   FormatCode -- specifies what format type, e.g. PTP_FORMATCODE_ALL, PTP_FORMATCODE_IMAGE
//   ParentObjectHandle -- the object handle under which to enumerate the objects
// Output:
//   pObjectHandleArray -- the array to receive the object handles
//
HRESULT
CPTPCamera::GetObjectHandles(
    DWORD StorageId,
    WORD FormatCode,
    DWORD ParentObjectHandle,
    CArray32 *pObjectHandleArray
    )
{
    DBG_FN("CPTPCamera::GetObjectHandles");

    HRESULT hr = S_OK;

    if (!StorageId ||
        !pObjectHandleArray)
    {
        wiauDbgError("GetObjectHandles", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETOBJECTHANDLES;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 3, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectHandles", "ExecuteCommand failed");
        return hr;
    }

    BYTE *pTemp = m_pTransferBuffer;
    if (!pObjectHandleArray->Parse(&pTemp))
    {
        wiauDbgError("GetStorageIDs", "couldn't parse object handle array");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pObjectHandleArray->Dump("  Object handles    =", "                     ");

    return hr;
}

//
// This function gets the object info structure
//
// Input:
//   ObjectHandle -- the object handle
// Output:
//   pObjectInfo -- pointer to retreived object info
//
HRESULT
CPTPCamera::GetObjectInfo(
    DWORD ObjectHandle,
    CPtpObjectInfo *pObjectInfo
    )
{
    DBG_FN("CPTPCamera::GetObjectInfo");

    HRESULT hr = S_OK;

    if (!ObjectHandle ||
        !pObjectInfo)
    {
        wiauDbgError("GetObjectInfo", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETOBJECTINFO;
    m_CommandBuffer.Params[0] = ObjectHandle;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectInfo", "ExecuteCommand failed");
        return hr;
    }
    
    hr = pObjectInfo->Init(m_pTransferBuffer, ObjectHandle);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectInfo", "couldn't parse object info");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pObjectInfo->Dump();

    return hr;
}

//
// This function retrieves an object
//
// Input:
//   ObjectHandle -- the handle that represents the object
//   pBuffer -- the buffer to use for transfer
//   BufferLen -- the buffer size
//
HRESULT
CPTPCamera::GetObjectData(
    DWORD ObjectHandle,
    BYTE *pBuffer,
    UINT *pBufferLen,
    LPVOID pCallbackParam
    )
{
    DBG_FN("CPTPCamera::GetObjectData");
    
    HRESULT hr = S_OK;

    if (!pBuffer ||
        !pBufferLen ||
        *pBufferLen == 0)
    {
        wiauDbgError("GetObjectData", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;

    m_pDataCallbackParam = pCallbackParam;

    hr = ExecuteCommand(pBuffer, pBufferLen, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetObjectData", "ExecuteCommand failed");
        return hr;
    }

    m_pDataCallbackParam = NULL;
    
    return hr;
}

//
// This function gets the thumbnail for an object
//
// Input:
//   ObjectHandle -- the handle that represents the object
//   pBuffer -- the buffer to use for transfer
//   BufferLen -- the buffer size
//
HRESULT
CPTPCamera::GetThumb(
    DWORD ObjectHandle,
    BYTE *pBuffer,
    UINT *pBufferLen
    )
{
    DBG_FN("CPTPCamera::GetThumb");
    
    HRESULT hr = S_OK;

    if (!pBuffer ||
        !pBufferLen ||
        *pBufferLen == 0)
    {
        wiauDbgError("GetThumb", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETTHUMB;
    m_CommandBuffer.Params[0] = ObjectHandle;

    hr = ExecuteCommand(pBuffer, pBufferLen, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetThumb", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function deletes the given object and its children
//
// Input:
//   ObjectHandle -- object handle that represents the object to be deleted, e.g. PTP_OBJECTHANDLE_ALL
//   FormatCode -- Limits the scope of the deletion if objects of FormatCode type, e.g. PTP_FORMATCODE_NOTUSED, PTP_FORMATCODE_ALLIMAGES
//
HRESULT
CPTPCamera::DeleteObject(
    DWORD ObjectHandle,
    WORD FormatCode
    )
{
    DBG_FN("CPTPCamera::DeleteObject");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_DELETEOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = FormatCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("DeleteObject", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function sends an ObjectInfo structure to the device in preparation for sending an object
//
// Input:
//   StorageId -- storage id for the new object, e.g. PTP_STORAGEID_UNDEFINED
//   ParentObjectHandle -- parent to use for the new object, e.g. PTP_OBJECTHANDLE_UNDEFINED, PTP_OBJECTHANDLE_ROOT
//   pDeviceInfo -- pointer to DeviceInfo structure
// Output:
//   pResultStorageId -- location to store storage id where object will be stored
//   pResultParentObjectHandle -- parent object under which object will be stored
//   pResultObjectHandle -- location to store handle for the new object
//
HRESULT
CPTPCamera::SendObjectInfo(
    DWORD StorageId,
    DWORD ParentObjectHandle,
    CPtpObjectInfo *pObjectInfo,
    DWORD *pResultStorageId,
    DWORD *pResultParentObjectHandle,
    DWORD *pResultObjectHandle
    )
{
    DBG_FN("CPTPCamera::SendObjectInfo");
    
    HRESULT hr = S_OK;

    if (!pObjectInfo ||
        !pResultStorageId ||
        !pResultParentObjectHandle ||
        !pResultObjectHandle)
    {
        wiauDbgError("SendObjectInfo", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_SENDOBJECTINFO;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = ParentObjectHandle;

    BYTE *pRaw = m_pTransferBuffer;
    pObjectInfo->WriteToBuffer(&pRaw);
    UINT size = (UINT) (pRaw - m_pTransferBuffer);

    hr = ExecuteCommand(NULL, NULL, m_pTransferBuffer, size, 2, CAMERA_PHASE_DATAOUT);
    if (FAILED(hr))
    {
        wiauDbgError("SendObjectInfo", "ExecuteCommand failed");
        return hr;
    }

    *pResultStorageId = m_ResponseBuffer.Params[0];
    *pResultParentObjectHandle = m_ResponseBuffer.Params[1];
    *pResultObjectHandle = m_ResponseBuffer.Params[2];

    wiauDbgTrace("SendObjectInfo", "ObjectInfo added, storage = 0x%08x, parent = 0x%08x, handle = 0x%08x",
                   *pResultStorageId, *pResultParentObjectHandle, *pResultObjectHandle);
    
    return hr;
}

//
// This function sends data for a new object
//
// Input:
//   pBuffer -- pointer to raw data
//   BufferLen -- length of the buffer
//
HRESULT
CPTPCamera::SendObjectData(
    BYTE *pBuffer,
    UINT BufferLen
    )
{
    DBG_FN("CPTPCamera::SendObjectData");
    
    HRESULT hr = S_OK;

    if (!pBuffer)
    {
        wiauDbgError("SendObjectData", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_SENDOBJECT;

    hr = ExecuteCommand(NULL, NULL, pBuffer, BufferLen, 0, CAMERA_PHASE_DATAOUT);
    if (FAILED(hr))
    {
        wiauDbgError("SendObjectData", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function asks the device to initiate a capture. The newly added object
// will be reported via an ObjectAdded event, or StoreFull event if the store is full.
//
// Input:
//   StorageId -- where to save the capture object, e.g. PTP_STORAGEID_DEFAULT
//   FormatCode -- indicates what kind of object to capture, e.g. PTP_FORMATCODE_DEFAULT
//
HRESULT
CPTPCamera::InitiateCapture(
    DWORD StorageId,
    WORD FormatCode
    )
{
    DBG_FN("CPTPCamera::InitiateCapture");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_INITIATECAPTURE;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("InitiateCapture", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function formats a store on the device
//
// Input:
//   StorageId -- storage to format
//   FilesystemFormat -- optional format to use
//
HRESULT
CPTPCamera::FormatStore(
    DWORD StorageId,
    WORD FilesystemFormat
    )
{
    DBG_FN("CPTPCamera::FormatStore");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_FORMATSTORE;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FilesystemFormat;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("FormatStore", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function resets the camera. A DeviceReset event will be sent and all open
// sessions will be closed.
//
HRESULT
CPTPCamera::ResetDevice()
{
    DBG_FN("CPTPCamera::ResetDevice");
    
    HRESULT hr = S_OK;

    hr = SendResetDevice();
    if (FAILED(hr))
    {
        wiauDbgError("ResetDevice", "SendResetDevice failed");
        return hr;
    }

    wiauDbgTrace("ResetDevice", "device reset successfully");

    return hr;
}

//
// This function tests the camera
//
HRESULT
CPTPCamera::SelfTest(WORD SelfTestType)
{
    DBG_FN("CPTPCamera::SelfTest");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_SELFTEST;
    m_CommandBuffer.Params[0] = SelfTestType;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 0, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("SelfTest", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function sets the protection status of an object
//
// Input:
//   ObjectHandle -- handle of the object
//   ProtectionStatus -- protection status
//
HRESULT
CPTPCamera::SetObjectProtection(
    DWORD ObjectHandle,
    WORD ProtectionStatus
    )
{
    DBG_FN("CPTPCamera::SetObjectProtection");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_SETOBJECTPROTECTION;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = ProtectionStatus;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("SetObjectProtection", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function will cause the device to turn off
//
HRESULT
CPTPCamera::PowerDown()
{
    DBG_FN("CPTPCamera::PowerDown");
    
    HRESULT hr = S_OK;

    m_CommandBuffer.OpCode = PTP_OPCODE_POWERDOWN;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 0, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("PowerDown", "ExecuteCommand failed");
        return hr;
    }
    
    return hr;
}

//
// This function retrieves a property description structure from the camera, allocating
// the appropriate CPtpPropDesc structure.
//
// Input:
//   PropCode -- property code to retrieve
//   pPropDesc -- pointer property description object
//
HRESULT
CPTPCamera::GetDevicePropDesc(
    WORD PropCode,
    CPtpPropDesc *pPropDesc
    )
{
    DBG_FN("CPtpCamera::GetDevicePropDesc");

    HRESULT hr = S_OK;
    
    if (!PropCode ||
        !pPropDesc)
    {
        wiauDbgError("GetDevicePropDesc", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETDEVICEPROPDESC;
    m_CommandBuffer.Params[0] = PropCode;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropDesc", "ExecuteCommand failed");
        return hr;
    }

    hr = pPropDesc->Init(m_pTransferBuffer);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropDesc", "couldn't parse property description");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pPropDesc->Dump();

    return hr;
}

//
// This function retrieves the current setting for a property.
//
// Input:
//   PropCode -- property code to get value for
//   pPropDesc -- pointer to property description object
//
HRESULT
CPTPCamera::GetDevicePropValue(
    WORD PropCode,
    CPtpPropDesc *pPropDesc
    )
{
    DBG_FN("CPtpCamera::GetDevicePropValue");

    HRESULT hr = S_OK;
    
    if (!PropCode ||
        !pPropDesc)
    {
        wiauDbgError("GetDevicePropValue", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_GETDEVICEPROPVALUE;
    m_CommandBuffer.Params[0] = PropCode;

    UINT size = TRANSFER_BUFFER_SIZE;
    hr = ExecuteCommand(m_pTransferBuffer, &size, NULL, 0, 1, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropValue", "ExecuteCommand failed");
        return hr;
    }

    hr = pPropDesc->ParseValue(m_pTransferBuffer);
    if (FAILED(hr))
    {
        wiauDbgError("GetDevicePropValue", "couldn't parse property value");
        return hr;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pPropDesc->DumpValue();

    return hr;
}

//
// This function sends a new setting for a property to the device
//
// Input:
//   PropCode -- property code to set
//   pPropDesc -- pointer to property description object
//
HRESULT
CPTPCamera::SetDevicePropValue(
    WORD PropCode,
    CPtpPropDesc *pPropDesc
    )
{
    DBG_FN("CPtpCamera::SetDevicePropValue");

    HRESULT hr = S_OK;
    
    if (!PropCode ||
        !pPropDesc)
    {
        wiauDbgError("SetDevicePropValue", "invalid arg");
        return E_INVALIDARG;
    }

    if (g_dwDebugFlags & WIAUDBG_DUMP)
        pPropDesc->DumpValue();

    m_CommandBuffer.OpCode = PTP_OPCODE_SETDEVICEPROPVALUE;
    m_CommandBuffer.Params[0] = PropCode;

    BYTE *pRaw = m_pTransferBuffer;
    pPropDesc->WriteValue(&pRaw);
    UINT size = (UINT) (pRaw - m_pTransferBuffer);

    hr = ExecuteCommand(NULL, NULL, m_pTransferBuffer, size, 1, CAMERA_PHASE_DATAOUT);
    if (FAILED(hr))
    {
        wiauDbgError("SetDevicePropValue", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function resets the of a property
//
// Input:
//   PropCode -- property code to set
//
HRESULT
CPTPCamera::ResetDevicePropValue(
    WORD PropCode
    )
{
    DBG_FN("CPtpCamera::ResetDevicePropValue");

    HRESULT hr = S_OK;
    
    if (!PropCode)
    {
        wiauDbgError("ResetDevicePropValue", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_RESETDEVICEPROPVALUE;
    m_CommandBuffer.Params[0] = PropCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("ResetDevicePropValue", "ExecuteCommand failed");
        return hr;
    }

    //
    // WIAFIX-10/2/2000-davepar This function should reset the current value being held by the minidriver
    //

    return hr;
}

//
// This function terminates an open capture
//
// Input:
//   TransactionId -- transaction id of InitiateOpenCapture command
//
HRESULT
CPTPCamera::TerminateCapture(
    DWORD TransactionId
    )
{
    DBG_FN("CPtpCamera::TerminateCapture");

    HRESULT hr = S_OK;
    
    if (!TransactionId)
    {
        wiauDbgError("TerminateCapture", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_TERMINATECAPTURE;
    m_CommandBuffer.Params[0] = TransactionId;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 1, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("TerminateCapture", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function moves an object on the device
//
// Input:
//   ObjectHandle -- handle of object to move
//   StorageId -- storage id of new location for object
//   ParentObjectHandle -- handle of new parent for object
//
HRESULT
CPTPCamera::MoveObject(
    DWORD ObjectHandle,
    DWORD StorageId,
    DWORD ParentObjectHandle
    )
{
    DBG_FN("CPtpCamera::MoveObject");

    HRESULT hr = S_OK;
    
    if (!ObjectHandle)
    {
        wiauDbgError("MoveObject", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_MOVEOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = StorageId;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 3, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("MoveObject", "ExecuteCommand failed");
        return hr;
    }

    return hr;
}

//
// This function copies an object to a new location on the device
//
// Input:
//   ObjectHandle -- handle of object to copy
//   StorageId -- storage id for new object
//   ParentObjectHandle -- handle of parent for new object
//   pResultObjectHandle -- pointer to location to receive new object's handle
//
HRESULT
CPTPCamera::CopyObject(
    DWORD ObjectHandle,
    DWORD StorageId,
    DWORD ParentObjectHandle,
    DWORD *pResultObjectHandle
    )
{
    DBG_FN("CPtpCamera::CopyObject");

    HRESULT hr = S_OK;
    
    if (!ObjectHandle ||
        !pResultObjectHandle)
    {
        wiauDbgError("CopyObject", "invalid arg");
        return E_INVALIDARG;
    }
    
    m_CommandBuffer.OpCode = PTP_OPCODE_COPYOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = StorageId;
    m_CommandBuffer.Params[2] = ParentObjectHandle;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 3, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("CopyObject", "ExecuteCommand failed");
        return hr;
    }

    *pResultObjectHandle = m_ResponseBuffer.Params[0];

    wiauDbgTrace("CopyObject", "Object 0x%08x copied to 0x%08x", ObjectHandle, *pResultObjectHandle);

    return hr;
}

//
// This function retrieves a portion of an object
//
// Input:
//   ObjectHandle -- the handle that represents the object
//   pBuffer -- the buffer to use for transfer
//   BufferLen -- the buffer size
//
HRESULT
CPTPCamera::GetPartialObject(
    DWORD ObjectHandle,
    UINT Offset,
    UINT *pLength,
    BYTE *pBuffer,
    UINT *pResultLength,
    LPVOID pCallbackParam
    )
{
    DBG_FN("CPTPCamera::GetPartialObject");
    
    HRESULT hr = S_OK;

    if (!pBuffer ||
        !pLength ||
        *pLength == 0 ||
        !pResultLength)
    {
        wiauDbgError("GetPartialObject", "invalid arg");
        return E_INVALIDARG;
    }

    m_CommandBuffer.OpCode = PTP_OPCODE_GETPARTIALOBJECT;
    m_CommandBuffer.Params[0] = ObjectHandle;
    m_CommandBuffer.Params[1] = Offset;
    m_CommandBuffer.Params[2] = *pLength;

    m_pDataCallbackParam = pCallbackParam;

    hr = ExecuteCommand(pBuffer, pLength, NULL, 0, 3, CAMERA_PHASE_DATAIN);
    if (FAILED(hr))
    {
        wiauDbgError("GetPartialObject", "ExecuteCommand failed");
        return hr;
    }

    m_pDataCallbackParam = NULL;

    *pResultLength = m_ResponseBuffer.Params[0];
    
    return hr;
}

//
// This function initiates an open capture
//
// Input:
//   StorageId -- storage to use for new object(s)
//   FormatCode -- format for new object(s)
//
HRESULT
CPTPCamera::InitiateOpenCapture(
    DWORD StorageId,
    WORD FormatCode
    )
{
    DBG_FN("CPtpCamera::InitiateOpenCapture");

    HRESULT hr = S_OK;
    
    m_CommandBuffer.OpCode = PTP_OPCODE_INITIATEOPENCAPTURE;
    m_CommandBuffer.Params[0] = StorageId;
    m_CommandBuffer.Params[1] = FormatCode;

    hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
    if (FAILED(hr))
    {
        wiauDbgError("InitiateOpenCapture", "ExecuteCommand failed");
        
        hr = RecoverFromError();
        if(FAILED(hr))
        {
            wiauDbgError("InitiateOpenCapture", "RecoverFromError failed");
            return hr;
        }

        hr = ExecuteCommand(NULL, NULL, NULL, 0, 2, CAMERA_PHASE_RESPONSE);
        if (FAILED(hr))
        {
            wiauDbgError("InitiateOpenCapture", "ExecuteCommand failed 2nd time");
            return hr;
        }
    }

    return hr;
}

//
// This function executes a vendor command
//
HRESULT
CPTPCamera::VendorCommand(
    PTP_COMMAND *pCommand,
    PTP_RESPONSE *pResponse,
    UINT *pReadDataSize,
    BYTE *pReadData,
    UINT WriteDataSize,
    BYTE *pWriteData,
    UINT NumCommandParams,
    int NextPhase
    )
{
    DBG_FN("CPTPCamera::VendorCommand");

    HRESULT hr = S_OK;

    memcpy(&m_CommandBuffer, pCommand, sizeof(m_CommandBuffer));

    hr = ExecuteCommand(pReadData, pReadDataSize, pWriteData, WriteDataSize,
                        NumCommandParams, (CAMERA_PHASE) NextPhase);
    
    if (FAILED(hr))
    {
        wiauDbgError("VendorCommand", "ExecuteCommand failed");
        return hr;
    }

    memcpy(pResponse, &m_ResponseBuffer, sizeof(m_ResponseBuffer));

    return hr;
}

//
// This function increments the transaction ID, rolling over if necessary
//
// Output:
//   next transaction ID
//
DWORD
CPTPCamera::GetNextTransactionId()
{
    // Valid transaction IDs range from PTP_TRANSACTIONID_MIN to
    // PTP_TRANSACTIONID_MAX, inclusive.
    //
    if (PTP_TRANSACTIONID_MAX == m_NextTransactionId)
    {
        m_NextTransactionId = PTP_TRANSACTIONID_MIN;
        return PTP_TRANSACTIONID_MAX;
    }
    else
    {
        return m_NextTransactionId++;
    }
}

//
// Set m_HackModel and m_HackVersion according to device info
//
HRESULT CPTPCamera::SetupHackInfo(CPtpDeviceInfo *pDeviceInfo)
{
    DBG_FN("CWiaMiniDriver::SetupHackInfo");

    if (pDeviceInfo == NULL)
    {
        wiauDbgError("SetupHackInfo", "Invalid device info");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    m_HackModel = HACK_MODEL_NONE;
    m_HackVersion = 0.0;

    //
    // Kodak DC4800
    //
    if (wcscmp(pDeviceInfo->m_cbstrModel.String(), L"DC4800 Zoom Digital Camera") == 0)
    {
        m_HackModel = HACK_MODEL_DC4800;
        wiauDbgTrace("SetupHackInfo", "Detected Kodak DC4800 camera");
    }

    //
    // Any Sony camera
    //
    else if (wcsstr(pDeviceInfo->m_cbstrModel.String(), L"Sony") != NULL)
    {
        //
        // Sony cameras report version as "01.0004"
        //
        WCHAR *pszStopChar = NULL;
        double dbVersion = wcstod(pDeviceInfo->m_cbstrDeviceVersion.String(), &pszStopChar);
        if (dbVersion != 0.0)
        {
            m_HackModel = HACK_MODEL_SONY;
            m_HackVersion = dbVersion;
            wiauDbgTrace("SetupHackInfo", "Detected Sony camera, version = %f", m_HackVersion);
        }
    }

    //
    // Nikon E2500 
    //
    else if (wcsstr(pDeviceInfo->m_cbstrManufacturer.String(), L"Nikon") != NULL &&
             wcscmp(pDeviceInfo->m_cbstrModel.String(), L"E2500") == 0)
    {
        //
        // Nikon E2500 reports version as "E2500v1.0"
        //
        WCHAR *pch = wcsrchr(pDeviceInfo->m_cbstrDeviceVersion.String(), L'v');
        if (pch != NULL)
        {
            WCHAR *pszStopChar = NULL;
            double dbVersion = wcstod(pch + 1, &pszStopChar);
            if (dbVersion != 0)
            {
                m_HackModel = HACK_MODEL_NIKON_E2500;
                m_HackVersion = dbVersion;
                wiauDbgTrace("SetupHackInfo", "Detected Nikon E2500 camera, version = %f", m_HackVersion);
            }
        }
    }
    else
    {
        wiauDbgTrace("SetupHackInfo", "Not detected any hack model");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\camera.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camera.h

Abstract:

    This module declares CPTPCamera class

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#ifndef CAMERA__H_
#define CAMERA__H_


//
// Reserve 8KB of memory as a re-usable transaction buffer
//
const UINT TRANSFER_BUFFER_SIZE = 0x2000;

//
// Hack models
//
typedef enum tagHackModel
{
    HACK_MODEL_NONE = 0,
    HACK_MODEL_DC4800,
    HACK_MODEL_NIKON_E2500,
    //
    // Right now, Sony cameras do not provide model in DeviceInfo. m_HackVersion is used to 
    // differentiate newer and older firmware of Sony cameras
    //
    HACK_MODEL_SONY
} HACK_MODEL;

//
// Camera is always in one of these phases
//
typedef enum tagCameraPhase
{
    CAMERA_PHASE_NOTREADY,
    CAMERA_PHASE_IDLE,
    CAMERA_PHASE_CMD,
    CAMERA_PHASE_DATAIN,
    CAMERA_PHASE_DATAOUT,
    CAMERA_PHASE_RESPONSE
}CAMERA_PHASE, *PCAMERA_PHASE;

//
// Definition for function to call when event occurs
//
typedef HRESULT (*PTPEventCallback)(LPVOID pCallbackParam, PPTP_EVENT pEvent);

//
// Definition for function to call while data is transferred
//
typedef HRESULT (*PTPDataCallback)(LPVOID pCallbackParam, LONG lPercentComplete,
                                   LONG lOffset, LONG lLength, BYTE **ppBuffer, LONG *plBufferSize);

//
// CPTPCamera - generic PTP camera
//
class CPTPCamera
{
public:
    CPTPCamera();
    virtual ~CPTPCamera();

    virtual HRESULT Open(LPWSTR DevicePortName, PTPEventCallback pPTPEventCB,
                         PTPDataCallback pPTPDataCB, LPVOID pEventParam, BOOL bEnableEvents = TRUE);
    virtual HRESULT Close();
    HRESULT GetDeviceInfo(CPtpDeviceInfo *pDeviceInfo);
    HRESULT OpenSession(DWORD SessionId);
    HRESULT CloseSession();
    HRESULT GetStorageIDs(CArray32 *pStorageIds);
    HRESULT GetStorageInfo(DWORD StorageId, CPtpStorageInfo *pStorageInfo);
    HRESULT GetNumObjects(DWORD StorageId, WORD FormatCode,
                          DWORD ParentObjectHandle, UINT *pNumObjects);
    HRESULT GetObjectHandles(DWORD StorageId, WORD FormatCode,
                             DWORD ParentObjectHandle, CArray32 *pObjectHandles);
    HRESULT GetObjectInfo(DWORD ObjectHandle, CPtpObjectInfo *pObjectInfo);
    HRESULT GetObjectData(DWORD ObjectHandle, BYTE *pBuffer, UINT *pBufferLen, LPVOID pCallbackParam);
    HRESULT GetThumb(DWORD ObjectHandle, BYTE *pBuffer, UINT *pBufferLen);
    HRESULT DeleteObject(DWORD ObjectHandle, WORD FormatCode);
    HRESULT SendObjectInfo(DWORD StorageId, DWORD ParentObjectHandle, CPtpObjectInfo *pObjectInfo,
                           DWORD *pResultStorageId, DWORD *pResultParentObjectHandle, DWORD *pResultObjectHandle);
    HRESULT SendObjectData(BYTE *pBuffer, UINT BufferLen);
    HRESULT InitiateCapture(DWORD StorageId, WORD FormatCode);
    HRESULT FormatStore(DWORD StorageId, WORD FilesystemFormat);
    HRESULT ResetDevice();
    HRESULT SelfTest(WORD SelfTestType);
    HRESULT SetObjectProtection(DWORD ObjectHandle, WORD ProtectionStatus);
    HRESULT PowerDown();
    HRESULT GetDevicePropDesc(WORD PropCode, CPtpPropDesc *pPropDesc);
    HRESULT GetDevicePropValue(WORD PropCode, CPtpPropDesc *pPropDesc);
    HRESULT SetDevicePropValue(WORD PropCode, CPtpPropDesc *pPropDesc);
    HRESULT ResetDevicePropValue(WORD PropCode);
    HRESULT TerminateCapture(DWORD TransactionId);
    HRESULT MoveObject(DWORD ObjectHandle, DWORD StorageId, DWORD ParentObjectHandle);
    HRESULT CopyObject(DWORD ObjectHandle, DWORD StorageId, DWORD ParentObjectHandle, DWORD *pResultObjectHandle);
    HRESULT GetPartialObject(DWORD ObjectHandle, UINT Offset, UINT *pLength, BYTE *pBuffer,
                             UINT *pResultLength, LPVOID pCallbackParam);
    HRESULT InitiateOpenCapture(DWORD StorageId, WORD FormatCode);

    HRESULT VendorCommand(PTP_COMMAND *pCommand, PTP_RESPONSE *pResponse,
                          UINT *pReadDataSize, BYTE *pReadData,
                          UINT WriteDataSize, BYTE *pWriteData,
                          UINT NumCommandParams, int NextPhase);

    //
    // Camera state functions
    //
    BOOL IsCameraOpen()         { return m_Phase != CAMERA_PHASE_NOTREADY; }
    BOOL IsCameraSessionOpen()  { return m_SessionId != PTP_SESSIONID_NOSESSION; }

    //
    // Model identification for model-specific handling
    //
    HRESULT             SetupHackInfo(CPtpDeviceInfo *pDeviceInfo);
    HACK_MODEL          GetHackModel() { return m_HackModel; }
    double              GetHackVersion() { return m_HackVersion; }

    //
    // Member access functions (for the event thread)
    //
    PPTP_EVENT          GetEventBuffer()        { return &m_EventBuffer; }
    PTPEventCallback    GetPTPEventCallback()   { return m_pPTPEventCB; }
    LPVOID              GetEventCallbackParam() { return m_pEventCallbackParam; }

    //
    // This function must be overriden by a transport-specific subclass
    //
    virtual HRESULT ReadEvent(PTP_EVENT *pEvent) = 0;
    virtual HRESULT RecoverFromError() = 0;

protected:
    //
    // These functions must be overriden by a transport-specific subclass
    //
    virtual HRESULT SendCommand(PTP_COMMAND *pCommand, UINT NumParams) = 0;
    virtual HRESULT ReadData(BYTE *pData, UINT *pBufferSize) = 0;
    virtual HRESULT SendData(BYTE *pData, UINT BufferSize) = 0;
    virtual HRESULT ReadResponse(PTP_RESPONSE *pResponse) = 0;
    virtual HRESULT AbortTransfer() = 0;
    virtual HRESULT SendResetDevice() = 0;

    //
    // Member variables
    //
    HANDLE                  m_hEventThread;         // Event thread handle
    DWORD                   m_SessionId;            // Current session ID
    CAMERA_PHASE            m_Phase;                // Current camera phase
    DWORD                   m_NextTransactionId;    // Next transaction ID
    PTPEventCallback        m_pPTPEventCB;          // Event callback function pointer
    PTPDataCallback         m_pPTPDataCB;           // Data callback function pointer
    LPVOID                  m_pEventCallbackParam;  // Pointer to pass to event callback functions
    LPVOID                  m_pDataCallbackParam;   // Pointer to pass to data callback functions
    BOOL                    m_bEventsEnabled;       // GetDeviceInfo is used to query camera for its name.  We don't want to start up entire eventing just for this.
    HACK_MODEL              m_HackModel;            // Indicator for model-specific hacks
    double                  m_HackVersion;          // Indicator for model and version specific hacks

private:
    HRESULT ExecuteCommand(BYTE *pReadData, UINT *pReadDataSize, BYTE *pWriteData, UINT WriteDataSize,
                           UINT NumCommandParams, CAMERA_PHASE NextPhase);
    DWORD   GetNextTransactionId();
    
    BYTE                   *m_pTransferBuffer;     // Re-usable buffer for small transfers
    PTP_COMMAND             m_CommandBuffer;       // Re-usable buffer for commands
    PTP_RESPONSE            m_ResponseBuffer;      // Re-usable buffer for responses
    PTP_EVENT               m_EventBuffer;         // Re-usable buffer for events

};

#endif // CAMERA__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\ircamera\irtranp\scep.h ===
//--------------------------------------------------------------------
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved.
//
// scep.h
//
// Constants and Types for the Simple Command Execution Protocol
// (SCEP). This is the transport protocol for IrTran-P V1.0.
//
// NOTE: That IrTran-P is a big-endian protocol when on the net.
//
// NOTE: That the protocol data structures below assume that the
//       compiler generates structures with natural alignment by
//       field type.
//
// Author:
//
//   Edward Reus (edwardr)     02-05-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _SCEP_H_
#define _SCEP_H_

#ifndef _BFTP_H_
#include "bftp.h"
#endif

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#define  LITTLE_ENDIAN

#define  PROTOCOL_VERSION             0x01
#define  NEGOTIATION_VERSION          0x11   // SCEP_NEGOTIATION revision.
#define  INF_VERSION                  0x10   // Information Struct version.

#define  USE_LENGTH2                  0xff

// These PDU sizes are the default and negotiated sizes:
#define  PDU_SIZE_1                    512
#define  PDU_SIZE_2                   1024
#define  PDU_SIZE_3                   2048
#define  PDU_SIZE_4                   4096
#define  MAX_PDU_SIZE           PDU_SIZE_4

#define  DEFAULT_PDU_SIZE     MAX_PDU_SIZE

// These sizes are used to check if we have a complete PDU:
#define  MIN_PDU_SIZE_CONNECT           28
#define  MAX_PDU_SIZE_CONNECT          256
#define  MIN_PDU_SIZE_CONNECT_RESP      24
#define  MAX_PDU_SIZE_CONNECT_RESP     255

#define  MIN_PDU_SIZE_DATA               8

#define  MIN_PDU_SIZE_DISCONNECT         6

// These are the sizes of the SCEP headers:
#define  SCEP_HEADER_SIZE                2
#define  SCEP_REQ_HEADER_SHORT_SIZE     34
#define  COMMAND_HEADER_SIZE            28

#define  FILE_NAME_SIZE                 12  // 8.3

// These are the attribute strings that go in the negotiation part
// of connect request and response PDUs:
#define  CONNECT_PDU_ATTRIBUTES  "fr:3\r\nid:Microsoft IrTran-P v1.0\r\n"
#define  RESPONSE_PDU_ATTRIBUTES "fr:4\r\nid:Microsoft IrTran-P v1.0\r\n"

// Message Types (field: MsgType):
#define  MSG_TYPE_CONNECT_REQ         0x10  // Connection request.
#define  MSG_TYPE_CONNECT_RESP        0x11  // Connection confirmation.
#define  MSG_TYPE_DATA                0x20  // Data PDU.
#define  MSG_TYPE_DISCONNECT          0x30  // Disconnection.

// Information Types (field: InfType):
#define  INF_TYPE_VERSION             0x00  // Connection establishment.
#define  INF_TYPE_NEGOTIATION         0x01  // Connection establish or accept.
#define  INF_TYPE_USER_DATA           0x03  // Only if MsgType is MSG_TYPE_DATA.
#define  INF_TYPE_EXTEND              0x10  // Connection establishment.
#define  INF_TYPE_REASON              0x20  // Only for disconnect.

// Command Header: Pdu Types (top two bits in PduType):
#define  PDU_TYPE_REQUEST             0x00  // b:00000000
#define  PDU_TYPE_REPLY_ACK           0x40  // b:01000000
#define  PDU_TYPE_REPLY_NACK          0x80  // b:10000000
#define  PDU_TYPE_ABORT               0xc0  // b:11000000

#define  PDU_TYPE_MASK                0xc0  // b:11000000
#define  PDU_TYPE_RESERVED            0x3f  // b:00111111

// The machine ID is in the Connect PDU (SCEP_NEGOTIATION), it
// is in EUI-64 format:
#define  MACHINE_ID_SIZE                 8

// Machine PIDs: In the command header, the default source and destination
// program Ids are unsigned shorts with value 8. Some machines will have
// a PID other than this (see the first command header sent to us):
#define  DEFAULT_PID                     8

// CFlag meanings:
//
// There are two cases, one where a device/machine can only issue commands,
// the other when a device can both issue and execute commands.
//
#define  CFLAG_ISSUE_ONLY             0x00
#define  CFLAG_ISSUE_OR_EXECUTE       0x04

// DFlag Meanings:
//
// DFlag give information about the data and fragmentation (why did they
// put the reject in here?).
//
#define  DFLAG_SINGLE_PDU             0xc1
#define  DFLAG_FIRST_FRAGMENT         0x41
#define  DFLAG_FRAGMENT               0x01
#define  DFLAG_LAST_FRAGMENT          0x81
#define  DFLAG_INTERRUPT              0xc2
#define  DFLAG_CONNECT_REJECT         0xc3

// Reason Codes:
//
// Currently for V1.0 all reason codes are 2-byte numbers:
#define  REASON_CODE_UNSPECIFIED          0x0000
#define  REASON_CODE_USER_DISCONNECT      0x0001
#define  REASON_CODE_PROVIDER_DISCONNECT  0x0002

// Connection States:
#define  STATE_CLOSED                       0
#define  STATE_CONNECTING                   1
#define  STATE_CONNECTED                    2

// Put Response Protocol Error Codes (sent back to the camera):
#define  ERROR_PUT_UNDEFINED_ERROR     0x0000
#define  ERROR_PUT_ILLEGAL_DATA        0x0001
#define  ERROR_PUT_UNSUPPORTED_PID     0x0002
#define  ERROR_PUT_ILLEGAL_ATTRIBUTE   0x0010
#define  ERROR_PUT_UNSUPPORTED_CMD     0x0011
#define  ERROR_PUT_FILE_SYSTEM_FULL    0x0020
#define  ERROR_PUT_NO_FILE_OR_DIR      0x0021
#define  ERROR_PUT_LOW_BATTERY         0x0030
#define  ERROR_PUT_ABORT_EXECUTION     0x0031
#define  ERROR_PUT_NO_ERROR            0xffff

//--------------------------------------------------------------------
//  SCEP Protocol Headers:
//--------------------------------------------------------------------

// Turn off warning for zero-sized array...
#pragma warning(disable:4200)
#pragma pack(1)

typedef struct _SCEP_HEADER
   {
   UCHAR  Null;          // Always zero.
   UCHAR  MsgType;       // See MSG_TYPE_* above.
   UCHAR  Rest[];        // Dependent on the MsgType...
   } SCEP_HEADER;

typedef struct _SCEP_VERSION
   {
   UCHAR  InfType;       // Always INF_TYPE_VERSION (0x00).
   UCHAR  Version;       // Currently 0x01 (Version = 1).
   } SCEP_VERSION;

typedef struct _SCEP_NEGOTIATION
   {
   UCHAR  InfType;       // Always INF_TYPE_NEGOTATION (0x01).
   UCHAR  Length;        // Length (bytes) from InfVersion to
                         //   the end of the Negotiation information.
                         //   This will be from 0 to 228.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  CFlag;         //
   UCHAR  SecondaryMachineId[8]; //
   UCHAR  PrimaryMachineId[8];   //
   UCHAR  Negotiation[]; //
   } SCEP_NEGOTIATION;

typedef struct _SCEP_DISCONNECT
   {
   UCHAR  InfType;       // Always INF_TYPE_REASON (0x20).
   UCHAR  Length1;       // For V1.0 this should be 2.
   USHORT ReasonCode;    // See the REASON_CODE_xxx
   } SCEP_DISCONNECT;

typedef struct _SCEP_EXTEND
   {
   UCHAR  InfType;       // Always INF_TYPE_EXTEND (0x10).
   UCHAR  Length;        // Always 2 (bytes).
   UCHAR  Parameter1;
   UCHAR  Parameter2;
   } SCEP_EXTEND;

typedef struct _COMMAND_HEADER
   {
   UCHAR  Marker58h;      // Always 0x58 (See: 3.2.2.1.3 of Protocol).
   UCHAR  PduType;        // One of: PDU_TYPE_xxxx.
   ULONG  Length4;
   UCHAR  DestMachineId[MACHINE_ID_SIZE];
   UCHAR  SrcMachineId[MACHINE_ID_SIZE];
   USHORT DestPid;
   USHORT SrcPid;
   USHORT CommandId;
   } COMMAND_HEADER;

typedef struct _SCEP_REQ_HEADER_SHORT
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_SHORT;

typedef struct _SCEP_REQ_HEADER_LONG
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   USHORT Length2;       // Only present if Length1 == 0xff.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_LONG;

typedef struct _SCEP_REQ_HEADER_SHORT_FRAG
   {
   UCHAR  Inftype;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   DWORD  SequenceNo;    // Fragment number.
   DWORD  RestNo;        // Number of fragments left for this PDU.
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_SHORT_FRAG;

typedef struct _SCEP_REQ_HEADER_LONG_FRAG
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   USHORT Length2;       // Only present if Length1 == 0xff.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   DWORD  SequenceNo;    // Fragment number.
   DWORD  RestNo;        // Number of fragments left for this PDU.
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_LONG_FRAG;

#pragma pack()
#pragma warning(default:4200)

//--------------------------------------------------------------------
//  SCEP API Structures:
//--------------------------------------------------------------------

class CSCEP_CONNECTION
{
public:
    CSCEP_CONNECTION();
    ~CSCEP_CONNECTION();

    void  *operator new( IN size_t Size );

    void   operator delete( IN void  *pObj,
                            IN size_t Size );

    // Assemble the next PDU as data comes in:
    DWORD  AssemblePdu( IN  void         *pInputData,
                        IN  DWORD         dwInputDataSize,
                        OUT SCEP_HEADER **ppPdu,
                        OUT DWORD        *pdwPduSize );

    // Parse the PDU returned from AssemblePdu():
    DWORD  ParsePdu( IN  SCEP_HEADER *pPdu,
                     IN  DWORD        dwPduSize,
                     OUT COMMAND_HEADER **ppCommand,
                     OUT UCHAR          **ppUserData,
                     OUT DWORD           *pdwUserDataSize );

    DWORD  SetScepLength( IN SCEP_HEADER *pPdu,
                          IN DWORD        dwTotalPduSize );

    // Construct SCEP connection/control PDUs:
    DWORD  BuildConnectPdu( OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    DWORD  BuildConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  BuildConnectNackPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  BuildAbortPdu( OUT SCEP_HEADER **ppPdu,
                          OUT DWORD        *pdwPduSize );

    DWORD  BuildStopPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  BuildDisconnectPdu( IN  USHORT        ReasonCode,
                               OUT SCEP_HEADER **ppPdu,
                               OUT DWORD        *pdwPduSize );

    // Build bFTP request (client-side) PDUs:
    DWORD  BuildBftpWht0RinfPdu( OUT SCEP_HEADER          **ppPdu,
                                 OUT DWORD                 *pdwPduSize,
                                 OUT SCEP_REQ_HEADER_LONG **ppCommand,
                                 OUT COMMAND_HEADER       **ppCommandHeader );

    DWORD  BuildBftpPutPdu( IN  DWORD                       dwUpfFileSize,
                            IN  CHAR                       *pszUpfFile,
                            IN OUT DWORD                   *pdwFragNo,
                            OUT SCEP_HEADER               **ppPdu,
                            OUT DWORD                      *pdwPduSize,
                            OUT SCEP_REQ_HEADER_LONG_FRAG **ppCommand );

    // Build bFTP response PDUs:
    DWORD  BuildBftpRespPdu( IN  DWORD            dwPduSize,
                             OUT SCEP_HEADER    **ppPdu,
                             OUT SCEP_REQ_HEADER_SHORT **ppCommand,
                             OUT COMMAND_HEADER **ppCommandHeader );

    DWORD  BuildWht0RespPdu( IN  DWORD         dwWht0Type,
                             OUT SCEP_HEADER **ppPdu,
                             OUT DWORD        *pdwPduSize );

    DWORD  BuildPutRespPdu( IN  DWORD         dwPduAckOrNack,
                            IN  USHORT        usErrorCode,
                            OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    // Parse the bFTP in a SCEP command request PDU:
    DWORD  ParseBftp( IN  UCHAR  *pvBftpData,
                      IN  DWORD   dwDataSize,
                      IN  BOOL    fSaveAsUPF,
                      OUT DWORD  *pdwBftpOp,
                      OUT UCHAR **ppPutData,
                      OUT DWORD  *pdwPutDataSize );

    // Parse and save the create date/time that was specified as a 
    // bFTP option:
    DWORD  SaveBftpCreateDate( IN UCHAR *pDate,
                               IN DWORD  dwLength );

    // Parse the UPF file header to find the image JPEG file:
    DWORD  ParseUpfHeaders( IN UCHAR  *pPutData,
                            IN DWORD   dwPutDataSize,
                            OUT DWORD *pdwJpegOffset,
                            OUT DWORD *pdwJpegSize );

    // Used when a SCEP command PDU is received:
    BOOL   IsFragmented();
    DWORD  GetSequenceNo();
    DWORD  GetRestNo();
    DWORD  GetCommandId();
    CHAR  *GetFileName();
    UCHAR  GetDFlag();
    FILETIME *GetCreateTime();

protected:

    DWORD  CheckPdu( OUT SCEP_HEADER **ppPdu,
                     OUT DWORD        *pdwPduSize );

    DWORD  CheckConnectPdu( OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    DWORD  CheckAckPdu( OUT SCEP_HEADER **ppPdu,
                        OUT DWORD        *pdwPduSize );

    DWORD  CheckNackPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  CheckConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  CheckDataPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  CheckDisconnectPdu( OUT SCEP_HEADER **ppPdu,
                               OUT DWORD        *pdwPduSize );

    DWORD  ParseConnectPdu( IN SCEP_HEADER *pPdu,
                            IN DWORD        dwPduSize );

    DWORD  ParseConnectRespPdu( IN SCEP_HEADER *pPdu,
                                IN DWORD        dwPduSize );

    DWORD  ParseDataPdu( IN  SCEP_HEADER *pPdu,
                         IN  DWORD        dwPduSize,
                         OUT COMMAND_HEADER **ppCommand,
                         OUT UCHAR          **ppUserData,
                         OUT DWORD           *pdwUserDataSize );

    DWORD  ParseDisconnectPdu( IN SCEP_HEADER *pPdu,
                               IN DWORD        dwPduSize );

    DWORD  ParseNegotiation( IN UCHAR *pNegotiation,
                             IN DWORD  dwNegotiationSize );

    UCHAR *ParseAttribute( IN     UCHAR *pAttributes,
                           IN OUT DWORD *pdwAttributeSize,
                           OUT    DWORD *pdwStatus );

    DWORD  ParseSingleLongPdu( IN SCEP_HEADER *pPdu,
                               IN DWORD        dwPduSize );

    BFTP_ATTRIBUTE *ParseBftpAttributeName(
                               IN BFTP_ATTRIBUTE *pAttr,
                               IN OUT DWORD      *pdwSize,
                               OUT    DWORD      *pdwWhichAttr );

    DWORD   m_dwConnectionState;
    DWORD   m_dwPduSendSize;
    DWORD   m_dwPduReceiveSize;
    UCHAR   m_CFlag;
    UCHAR  *m_pPrimaryMachineId;
    UCHAR  *m_pSecondaryMachineId;
    USHORT  m_DestPid;        // My PID (Camera point of view).
    USHORT  m_SrcPid;         // Camera's PID (Camera point of view).
    UCHAR  *m_pszProductId;
    UCHAR  *m_pszUserName;
    UCHAR  *m_pszPassword;

    // Used during PDU assembley process.
    UCHAR  *m_pAssembleBuffer;
    DWORD   m_dwAssembleBufferSize;
    DWORD   m_dwMaxAssembleBufferSize;
    BOOL    m_fDidByteSwap;

    // Used to manage the current SCEP command PDU.
    UCHAR   m_Fragmented;
    UCHAR   m_DFlag;
    DWORD   m_dwSequenceNo;
    DWORD   m_dwRestNo;
    DWORD   m_dwCommandId;
    COMMAND_HEADER *m_pCommandHeader;

    //
    // NOTE: The m_pszFileName is the file name that the camera sent us,
    //       while pszSaveFileName is the file name will will actually
    //       save the file under (different extension). m_pszLongFileName
    //       is the optional BFTP file name (not currently used), it
    //       is not usually present in the BFTP.
    //
    CHAR    *m_pszFileName;
    CHAR    *m_pszSaveFileName;
    CHAR    *m_pszLongFileName;

    FILETIME m_CreateTime;
};

//--------------------------------------------------------------------
// Inline Functions:
//--------------------------------------------------------------------

inline BOOL CSCEP_CONNECTION::IsFragmented()
    {
    return m_Fragmented;
    }

inline DWORD CSCEP_CONNECTION::GetSequenceNo()
    {
    return m_dwSequenceNo;
    }

inline DWORD CSCEP_CONNECTION::GetRestNo()
    {
    return m_dwRestNo;
    }

inline DWORD CSCEP_CONNECTION::GetCommandId()
    {
    return m_dwCommandId;
    }

inline CHAR *CSCEP_CONNECTION::GetFileName()
    {
    return m_pszSaveFileName;
    }

inline UCHAR CSCEP_CONNECTION::GetDFlag()
    {
    return m_DFlag;
    }

inline FILETIME *CSCEP_CONNECTION::GetCreateTime()
    {
    if ( (m_CreateTime.dwLowDateTime)
       || (m_CreateTime.dwHighDateTime) )
        {
        return &m_CreateTime;
        }
    else
        {
        return 0;
        }
    }

//--------------------------------------------------------------------
// Utility Functions/Macros:
//--------------------------------------------------------------------

#define ByteSwapShort(Value)              \
            (  (((Value) & 0x00FF) << 8)  \
             | (((Value) & 0xFF00) >> 8))

#define ByteSwapLong(Value) \
            (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8)  \
             | (((Value) & 0x0000FF00) << 8)  \
             | (((Value) & 0x000000FF) << 24))

extern void ByteSwapReqHeaderShort( SCEP_REQ_HEADER_SHORT *pSingleShort );

extern void ByteSwapReqHeaderLong( SCEP_REQ_HEADER_LONG *pSingleLong );

extern void ByteSwapCommandHeader( COMMAND_HEADER *pCommandHeader );


//--------------------------------------------------------------------
// Memory management functions:
//--------------------------------------------------------------------

DWORD        InitializeMemory();

DWORD        UninitializeMemory();

void        *AllocateMemory( DWORD dwBytes );
 
DWORD        FreeMemory( void *pvMemory );

SCEP_HEADER *NewPdu( DWORD dwPduSize = MAX_PDU_SIZE );

void         DeletePdu( SCEP_HEADER *pPdu );

#if FALSE
//--------------------------------------------------------------------

    SCEP Connect PDU
    ----------------

    Connection request PDU. This is a SCEP_HEADER with Rest[] filled
    with three Inf Records, a SCEP_VERSION followed by a SCEP_NEGOTIATION
    followed by a SCEP_EXTEND. The Connect PDU must be less than or equal
    to 256 bytes in length.

      SCEP_HEADER                        2 bytes.
      Rest[]: SCEP_VERSION               2 bytes.
              SCEP_NEGOTIATION    20 - 228 bytes.
              SCEP_EXTEND                4 bytes.
                                  --------
                                  28 - 256 bytes.

    - If either the SecondaryMachineId[] or PrimariyMachineId is unused,
      then they are set to 00,00,00,00,00,00,00,00.
    - If a machine gets a Connect PDU but can't  execute commands
      (CFlag = CFLAG_ISSUE_ONLY), then it needs to respond with a
      NACK PDU.
    - The negotiation information is a simple text based command
      language.


    SCEP Connection ACK PDU
    -----------------------

    Connection acceptance PDU. This is a SCEP_HEADER with Rest[] filled
    with two Inf Records, a SCEP_VERSION followed by a SCEP_NEGOTIATION.

      SCEP_HEADER                        2 bytes.
      SCEP_VERSION                       2 bytes.
      Rest[]: SCEP_NEGOTIATION      20-251 bytes.
                                    ------
                                    24-255 bytes.

    - Note that the size of the ACK PDU is limited by the fact that
      the Length field is a single byte and that the ACK PDU can not
      be fragmented. Normally these PDUs will never be this long.


    SCEP Connection NACK PDU
    ------------------------

    Connection rejected PDU. This one can have either of two different
    formats.

      SCEP_HEADER
      Rest[]: SCEP_REQ_HEADER_SHORT

      or

      SCEP_HEADER
      Rest[]: SCEP_REQ_HEADER_LONG

    - In the first case, Length1 = 4, DFlag = DFLAG_CONNECT_REJECT,
      and Length 3 = 0.
    - In the second case, Length1 = 0xff, DFlag = DFLAG_CONNECT_REJECT,
      and Length 3 = 0.


    SCEP Disconnect PDU
    -------------------

    A disconnect can be generated by either side of the connection,
    or by one of the transports at any time.

      SCEP_HEADER
      Rest[]: SCEP_DISCONNECT

    - For V1.0, Length1 = 2, and ReasonCode is a USHORT.


    SCEP Command Request and Response PDUs (Non-fragmented)
    -------------------------------------------------------

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT    4 + 0-254 bytes
                                       ---------
                                         6 - 260 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG    4 + 0-4090 bytes (1)
                                      ----------
                                        6 - 4096 bytes

    - In either case, DFlag = DFLAG_SINGLE_PDU.
    - PduType = PDU_TYPE_REQUEST.
    - If Length1 = 0xff then the long version is used.
    - The Length1(2) field specifies the byte size from InfVersion to the
      end of the user data. If the total size will exceed the maximum PDU
      size then the request must be fragmented.
    - So the total PDU size is: 6 + Length1(2) bytes.

    (1) Assuming the maximum PDU size is 4096 (fr:4).


    SCEP Command Request and Response PDUs (Fragmented)
    ---------------------------------------------------

    For requests these PDUs are generated when the PDU size is greater
    than that of the responder that you are connected to. For responses,
    the PDUs are fragmented when the returned data is greater than the
    maximum that the requester specified during the connection establishment.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT_FRAG    6 + 0-254 bytes
                                       ---------
                                         8 - 260 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG_FRAG    8 + 0-4088 bytes (1)
                                       ---------
                                       10 - 4096 bytes

    - For the first PDU fragment, DFlag = DFLAG_FIRST_FRAGMENT, for
      intermediate fragments, DFlag = DFLAG_FRAGMENT, and for the
      last fragment, DFlag = DFLAG_LAST_FRAGMENT.
    - PduType = PDU_TYPE_REQUEST for the request.
    - PduType = PDU_TYPE_REPLY_ACK or PDU_TYPE_REPLY_NACK in the
      response.
    - If Length1 = 0xff then the long version is used.
    - Length1(2) can not exceed the maximum PDU size - 6 bytes.
    - SequenceNo is 0 for the first PDU (NOTE: 4 bytes).
    - RestNo is the remaining number of PDUs to get. It is 1 for
      the last PDU (really, it says so in the spec!). So, a client
      should start this as the total number of PDUs in the first
      fragment (not really the number remaining). NOTE: 4 bytes.

    (1) Assuming the maximum PDU size is 4096 (fr:4).


    SCEP Abort PDU
    --------------

    Use the abort to stop execution of a command (specified by the
    DestPid and CommandId) after ALL of the request PDUs have been
    sent. An abort PDU also has two possible formats.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT           34 bytes
                                              --
                                              36 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG            36 bytes
                                              --
                                              38 bytes

    - In either case, DFlag = DFLAG_SINGLE_PDU.
    - In either case, PduType = PDU_TYPE_ABORT.
    - For the short PDU, Length1 = 0x20 (32), and Length3 = 0x1c
      (28).
    - For the long PDU, Length1 = 0xff, Length2 = 0x20 (32),
      and Length3 = 0x1c (28).


    SCEP Stop (Interrupt) PDU
    -------------------------

    If an Abort PDU has been sent out to stop a command, and as the
    command is halted some response data has already been sent, the
    the responder will send this PDU. It appears that a Stop PDU should
    not be sent if no response has yet been sent back.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT            6 bytes
                                              --
                                               8 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG             8 bytes
                                              --
                                              10 bytes

    - In either case, DFlag = DFLAG_INTERRUPT.
    - For the short PDU, Length1 = 4, and Length3 = 0.
    - For the long PDU, Length1 = 0xff, Length2 = 4, and
      Length3 = 0.

    Negotiation Information
    -----------------------

    The negotiation information is used to convey the frame size,
    authentication data, and product information, etc.

    Its structure is a version code (currently 0x11) followed by
    text in the following syntax:

      NegInf    -> Attribute ':' Spaces Value CrLf

      Attribute -> AttribChar AttribChar

      AttribChar-> 'a-zA-Z'

      Value     -> ValueChar Value
                ->

      ValueChar -> 'ASCII string, bytes must be between 0x20 and 0x8e
                    inclusive'

      Spaces    -> ' ' Spaces
                ->

      CrLf      -> 0x0d 0x0a

      Attribute    Meaning
      ---------    -------
      fr           Frame (PDU) size. The sender requests the maximum
                   receivable PDU size, the receiver decides the
                   transmission PDU size in accordance with the senders
                   requested PDU size. The maximum PDU size of the sender
                   may be different than that of the receiver. The value
                   is one of:

                   1 -  512 bytes PDU size (default).
                   2 - 1024 bytes PDU size.
                   3 - 2048 bytes PDU size.
                   4 - 4096 bytes PDU size.

      id           Product Identification string.

      nm           User name. any byte string that doesn't include CR or
                   LF (note the conflict in by values with the syntax
                   specification above). The user name may be up to 32
                   characters long.

      pw           Password. This is a MD5 encoded password expressed
                   in a 16 byte "hex" string, no spaces are allowd.
                   It appears that this will always be 32 characters
                   long. For example: 0aff3728e4a62791337984282871a6bc

//--------------------------------------------------------------------
#endif

#endif //_SCEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\camusb.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camusb.cpp

Abstract:

    This module implements CUsbCamera object

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "ptppch.h"

#include <wiaconv.h>
#include <devioctl.h>

//
// Private IOCTL to workaround #446466 (Whistler)
//
#define IOCTL_SEND_USB_REQUEST_PTP  CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+20,METHOD_BUFFERED,FILE_ANY_ACCESS)



//
// Constructor for CUsbCamera
//
CUsbCamera::CUsbCamera() :
    m_hUSB(NULL),
    m_hEventUSB(NULL),
    m_hEventCancel(NULL),
    m_hEventRead(NULL),
    m_hEventCancelDone(NULL),
    m_pUsbData(NULL),
    m_UsbDataSize(0),
    m_prevOpCode(0),
    m_prevTranId(0)
{
    DBG_FN("CUsbCamera::CUsbCamera");

    memset(&m_EndpointInfo, NULL, sizeof(m_EndpointInfo));
}

CUsbCamera::~CUsbCamera()
{
}

//
// This function takes care of USB-specific processing for opening
// a connection with a device.
//
// Input:
//   DevicePortName -- name used to access device via CreateFile
//   pIPTPEventCB   -- IWiaPTPEventCallback interface pointer
//
HRESULT
CUsbCamera::Open(
    LPWSTR DevicePortName,
    PTPEventCallback pPTPEventCB,
    PTPDataCallback pPTPDataCB,
    LPVOID pEventParam,
    BOOL bEnableEvents
    )
{
    USES_CONVERSION;

    DBG_FN("CUsbCamera::Open");

    HRESULT hr = S_OK;

    //
    // Call the base class Open function first
    //
    hr = CPTPCamera::Open(DevicePortName, pPTPEventCB, pPTPDataCB, pEventParam, bEnableEvents);
    if (FAILED(hr))
    {
        wiauDbgError("Open", "base class Open failed");
        return hr;
    }
    
    //
    // Open another handle to talk with the device, to work around possible
    // bug in Usbscan.sys
    //
    m_hEventUSB = ::CreateFile(W2T(DevicePortName),        // file name
                               GENERIC_READ | GENERIC_WRITE,   // desired access
                               0,                              // sharing mode
                               NULL,                           // security descriptor
                               OPEN_EXISTING,                  // creation disposition
                               FILE_FLAG_OVERLAPPED,           // file attributes
                               NULL                            // template file
                              );

    if (m_hEventUSB == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateFile failed");
        m_hUSB = NULL;
        return hr;
    }

    //
    // Open a handle to talk with the device
    //
    m_hUSB = ::CreateFile(W2T(DevicePortName),        // file name
                        GENERIC_READ | GENERIC_WRITE,   // desired access
                        0,                              // sharing mode
                        NULL,                           // security descriptor
                        OPEN_EXISTING,                  // creation disposition
                        0,                              // file attributes
                        NULL                            // template file
                       );

    if (m_hUSB == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "Second CreateFile failed");
        m_hUSB = NULL;
        return hr;
    }

    //
    // Create event handle that will cancel interrupt pipe read
    //
    m_hEventCancel = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventCancel)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateEvent failed");
        return hr;
    }

    //
    // Create event handle for reading interrupt pipe
    //
    m_hEventRead = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventRead)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateEvent failed");
        return hr;
    }

    //
    // Create event handle for detecting when the cancel interrupt pipe read is done
    //
    m_hEventCancelDone = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hEventCancelDone)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "CreateEvent failed");
        return hr;
    }

    //
    // Set up array used by WaitForMultipleObjects
    //
    m_EventHandles[0] = m_hEventCancel;
    m_EventHandles[1] = m_hEventRead;

    //
    // Get the pipe configuration information of each pipe
    //
    USBSCAN_PIPE_CONFIGURATION PipeCfg;
    DWORD BytesReturned;
    
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_GET_PIPE_CONFIGURATION,
                         NULL,
                         0,
                         &PipeCfg,
                         sizeof(PipeCfg),
                         &BytesReturned,
                         NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "get pipe config DeviceIoControl failed");
        return hr;
    }

    //
    // Loop through the pipe configurations and store the information we'll need
    // later (maximum packet size and address). Also make sure there is at least
    // one endpoint of each: bulk-in, bulk-out, and interrupt.
    //
    USBSCAN_PIPE_INFORMATION *pPipeInfo;  // Temporary pointer

    for (ULONG count = 0; count < PipeCfg.NumberOfPipes; count++)
    {
        pPipeInfo = &PipeCfg.PipeInfo[count];
        switch (pPipeInfo->PipeType)
        {
        case USBSCAN_PIPE_BULK:

            if (pPipeInfo->EndpointAddress & BULKIN_FLAG)
            {
                m_EndpointInfo.BulkInMaxSize = pPipeInfo->MaximumPacketSize;
                m_EndpointInfo.BulkInAddress = pPipeInfo->EndpointAddress;
                wiauDbgTrace("Open", "found a bulk-in endpoint, address = 0x%04x, packet size = %d, index = %d",
                             pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);
            }
            else
            {
                m_EndpointInfo.BulkOutMaxSize = pPipeInfo->MaximumPacketSize;
                m_EndpointInfo.BulkOutAddress = pPipeInfo->EndpointAddress;
                wiauDbgTrace("Open", "found a bulk-out endpoint, address = 0x%04x, packet size = %d, index = %d",
                             pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);
            }

            break;

        case USBSCAN_PIPE_INTERRUPT:

            m_EndpointInfo.InterruptMaxSize = pPipeInfo->MaximumPacketSize;
            m_EndpointInfo.InterruptAddress = pPipeInfo->EndpointAddress;
            wiauDbgTrace("Open", "found an interrupt endpoint, address = 0x%02x, packet size = %d, index = %d",
                         pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);

            break;
            
        default:
            wiauDbgTrace("Open", "found an endpoint of unknown type, type = 0x%04x, address = 0x%02x, packet size = %d, index = %d",
                           pPipeInfo->PipeType, pPipeInfo->EndpointAddress, pPipeInfo->MaximumPacketSize, count);
        }
    }

    //
    // Each of these endpoints must be present and have non-zero packet size
    //
    if (!m_EndpointInfo.BulkInMaxSize ||
        !m_EndpointInfo.BulkOutMaxSize ||
        !m_EndpointInfo.InterruptMaxSize)
    {
        wiauDbgError("Open", "At least one endpoint is invalid");
        return E_FAIL;
    }

    //
    // Allocate a re-usable buffer for handling the USB header during reads
    // and writes. It needs to be large enough to hold one packet and large
    // enough to hold a USB header.
    //
    m_UsbDataSize = max(m_EndpointInfo.BulkInMaxSize, m_EndpointInfo.BulkOutMaxSize);
    while (m_UsbDataSize < sizeof(m_pUsbData->Header))
    {
        m_UsbDataSize += m_UsbDataSize;
    }
    m_pUsbData = (PUSB_PTP_DATA) new BYTE[m_UsbDataSize];
    if (!m_pUsbData)
    {
        wiauDbgError("Open", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    return hr;
}

//
// This function closes the connection to the camera
//
HRESULT
CUsbCamera::Close()
{
    DBG_FN("CUsbCamera::Close");

    HRESULT hr = S_OK;

    //
    // Call the base class Close function first
    //
    hr = CPTPCamera::Close();
    if (FAILED(hr))
    {
        wiauDbgError("Close", "base class Close failed");
    }

    //
    // Signal event to cancel interrupt pipe I/O
    //
    if (!SetEvent(m_hEventCancel))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Close", "SetEvent failed");
    } else {

        if (m_bEventsEnabled)
        {
            //
            // Wait for the cancel interrupt pipe I/O to be done. After 2 seconds,
            // assume the thread is stuck and continue.
            //
            DWORD ret = WaitForSingleObject(m_hEventCancelDone, 2 * 1000);
            if (ret != WAIT_OBJECT_0) {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                wiauDbgErrorHr(hr, "Close", "WaitForSingleObject failed");
            }
        }
    }

    //
    // Close the file handles and event handles
    //
    if (m_hUSB)
    {
        CloseHandle(m_hUSB);
        m_hUSB = NULL;
    }

    if (m_hEventUSB)
    {
        CloseHandle(m_hEventUSB);
        m_hEventUSB = NULL;
    }

    if (m_hEventCancel)
    {
        CloseHandle(m_hEventCancel);
        m_hEventCancel = NULL;
    }

    if (m_hEventRead)
    {
        CloseHandle(m_hEventRead);
        m_hEventRead = NULL;
    }

    //
    // Free memory used for reading/writing data
    //
    if (m_pUsbData)
    {
        delete m_pUsbData;
        m_pUsbData = NULL;
    }

    return hr;
}

//
// This function writes a command buffer to the device
//
// Input:
//   pCommand -- pointer to the command to send
//   NumParams -- number of parameters in the command
//
HRESULT
CUsbCamera::SendCommand(
    PTP_COMMAND *pCommand,
    UINT NumParams
    )
{
    DBG_FN("CUsbCamera::SendCommand");

    HRESULT hr = S_OK;
    
    if (!pCommand)
    {
        wiauDbgError("SendCommand", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Check for the reset command, and send it via the control pipe instead
    //
    if (pCommand->OpCode == PTP_OPCODE_RESETDEVICE)
    {
        wiauDbgTrace("SendCommand", "sending reset request");

        hr = ResetDevice();
        if (FAILED(hr))
        {
            wiauDbgError("SendCommand", "ResetDevice failed");
            return hr;
        }
    }

    else
    {
        //
        // Put the PTP command into a USB container
        //
        m_UsbCommand.Header.Len = sizeof(m_UsbCommand.Header) + sizeof(DWORD) * NumParams;
        m_UsbCommand.Header.Type = PTPCONTAINER_TYPE_COMMAND;
        m_UsbCommand.Header.Code = pCommand->OpCode;
        m_UsbCommand.Header.TransactionId = pCommand->TransactionId;

        if (NumParams > 0)
        {
            memcpy(m_UsbCommand.Params, pCommand->Params, sizeof(DWORD) * NumParams);
        }

        //
        // Send the command to the device
        //
        DWORD BytesWritten = 0;
        wiauDbgTrace("SendCommand", "writing command");

        if (!WriteFile(m_hUSB, &m_UsbCommand, m_UsbCommand.Header.Len, &BytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "SendCommand", "WriteFile failed");
            return hr;
        }

        if (BytesWritten != m_UsbCommand.Header.Len)
        {
            wiauDbgError("SendCommand", "wrong amount of data written = %d", BytesWritten);
            return E_FAIL;
        }

        //
        // If the amount written is a multiple of the packet size, send a null packet
        //
        if (m_UsbCommand.Header.Len % m_EndpointInfo.BulkOutMaxSize == 0)
        {
            wiauDbgTrace("SendCommand", "sending null packet");

            if (!WriteFile(m_hUSB, NULL, 0, &BytesWritten, NULL))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                wiauDbgErrorHr(hr, "SendCommand", "second WriteFile failed");
                return hr;
            }

            if (BytesWritten != 0)
            {
                wiauDbgError("SendCommand", "wrong amount of data written = %d -", BytesWritten);
                return E_FAIL;
            }
        }
    }

    //
    // Save the opcode, because we need it for the data container header
    //
    m_prevOpCode = pCommand->OpCode;
    m_prevTranId = pCommand->TransactionId;

    wiauDbgTrace("SendCommand", "command successfully sent");

    return hr;
}

//
// This function reads bulk data from the device
//
// Input:
//   pData -- pointer to a buffer to receive read data
//   BufferSize -- size of buffer
//
HRESULT
CUsbCamera::ReadData(
    BYTE *pData,
    UINT *pBufferSize
    )
{
    DBG_FN("CUsbCamera::ReadData");

    HRESULT hr = S_OK;

    BOOL bAbortTransfer = FALSE;
    
    if (!pData ||
        !pBufferSize ||
        *pBufferSize == 0)
    {
        wiauDbgError("ReadData", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // First read the header from the device
    //
    memset(m_pUsbData, NULL, m_UsbDataSize);

    DWORD BytesRead = 0;
    wiauDbgTrace("ReadData", "reading data header");

    if (!ReadFile(m_hUSB, m_pUsbData, sizeof(m_pUsbData->Header), &BytesRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "ReadData", "ReadFile failed");
        return hr;
    }

    if (BytesRead != sizeof(m_pUsbData->Header))
    {
        wiauDbgError("ReadData", "wrong amount of data read = %d", BytesRead);
        return E_FAIL;
    }

    //
    // Check the type code in the header to make sure it's correct
    //
    if (m_pUsbData->Header.Type != PTPCONTAINER_TYPE_DATA)
    {
        wiauDbgError("ReadData", "expected a data header but received type = %d", m_pUsbData->Header.Type);
        return E_FAIL;
    }

    //
    // Check the opcode and transaction id in the header just to make sure they are correct
    //
    if ((m_pUsbData->Header.Code != m_prevOpCode) ||
        (m_pUsbData->Header.TransactionId != m_prevTranId))
    {
        wiauDbgError("ReadData", "fields in the data header were incorrect, opcode=0x%04x tranid=0x%08x",
                       m_pUsbData->Header.Code, m_pUsbData->Header.TransactionId);
        return E_FAIL;
    }

    //
    // Loop, reading the data. The callback function will be called at least 10 times during
    // the transfer. More if the buffer size is small.
    //
    LONG lOffset = 0;
    UINT BytesToRead = 0;
    UINT TotalRead = 0;
    UINT TotalToRead = m_pUsbData->Header.Len - sizeof(m_pUsbData->Header);
    UINT TotalRemaining = TotalToRead;

    //
    // Make sure the buffer is large enough, unless a callback function is being used
    //
    if (m_pDataCallbackParam == NULL &&
        *pBufferSize < TotalToRead)
    {
        wiauDbgError("ReadData", "buffer is too small");
        return E_FAIL;
    }

    //
    // When doing callbacks, read the data in chunk sizes slightly
    // larger the 1/10 the total and divisible by 4.
    //
    if (m_pDataCallbackParam)
        BytesToRead = (TotalToRead / 40 + 1) * 4;
    else
        BytesToRead = *pBufferSize;

    //
    // Set time out values for Usbscan
    //
    USBSCAN_TIMEOUT TimeOut;
    DWORD BytesReturned = 0;

    TimeOut.TimeoutRead = PTP_READ_TIMEOUT + max(BytesToRead / 100000, 114);
    TimeOut.TimeoutWrite = PTP_WRITE_TIMEOUT;
    TimeOut.TimeoutEvent = PTP_EVENT_TIMEOUT;
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_SET_TIMEOUT,
                         &TimeOut,
                         sizeof(TimeOut),
                         NULL,
                         0,
                         &BytesReturned,
                         NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "Open", "set timeout DeviceIoControl failed");
        return hr;
    }

    while (TotalRemaining > 0)
    {
        //
        // Make sure the amount to read is never larger than the buffer size. The buffer size may
        // be updated by the callback function.
        //
        if (BytesToRead > *pBufferSize)
            BytesToRead = *pBufferSize;

        //
        // On the last read, the bytes to read may need to be reduced
        //
        if (BytesToRead > TotalRemaining)
            BytesToRead = TotalRemaining;

        wiauDbgTrace("ReadData", "reading a chunk of data = %d", BytesToRead);

        BytesRead = 0;
        if (!ReadFile(m_hUSB, pData, BytesToRead, &BytesRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadData", "ReadFile failed");
            return hr;
        }

        if ((BytesRead > *pBufferSize) ||
            (BytesRead != BytesToRead))
        {
            wiauDbgError("ReadData", "wrong amount of data read = %d -", BytesRead);
            return E_FAIL;
        }

        TotalRemaining -= BytesRead;
        TotalRead += BytesRead;

        if (m_pDataCallbackParam &&
            !bAbortTransfer)
        {
            //
            // Call the callback function reporting percent complete, offset, and amount read.
            // The callback may update pData and BufferSize.
            //
            hr = m_pPTPDataCB(m_pDataCallbackParam, (TotalRead * 100 / TotalToRead),
                              lOffset, BytesRead, &pData, (LONG *) pBufferSize);

            if (FAILED(hr))
            {
                //
                // Report the error
                //
                wiauDbgErrorHr(hr, "ReadData", "data callback failed");
            }
            
            //
            // Check if caller wants to cancel the transfer or returns error
            //
            if (hr == S_FALSE || FAILED(hr))
            {
                //
                // Do not send CancelRequest to cameras that do not support it, just read the 
                // remainder of the object without reporting progress and return S_FALSE.
                //
                // Cameras not supporting CancelRequest are:
                //   all Sony cameras with DeviceVersion < 1.0004
                //   Nikon E2500 with DeviceVersion = 1.0
                //
                const double NIKON_E2500_VERSION_NOT_SUPPORTING_CANCEL = 1.0;
                const double MIN_SONY_VERSION_SUPPORTING_CANCEL = 1.0004;

                if ((GetHackModel() == HACK_MODEL_NIKON_E2500 && 
                     GetHackVersion() == NIKON_E2500_VERSION_NOT_SUPPORTING_CANCEL) || 

                    (GetHackModel() == HACK_MODEL_SONY && 
                     GetHackVersion() < MIN_SONY_VERSION_SUPPORTING_CANCEL))
                {
                    wiauDbgWarning("ReadData", 
                        "Transfer cancelled, reading but ignoring remainder of the object (%d bytes)", TotalRemaining);

                    bAbortTransfer = TRUE;
                    m_Phase = CAMERA_PHASE_RESPONSE; // camera will send response
                    hr = S_OK;
                }
                else
                {
                    wiauDbgWarning("ReadData", "Transfer cancelled, aborting current transfer");
                    
                    hr = SendCancelRequest(m_prevTranId);
                    if (FAILED(hr))
                    {
                        wiauDbgErrorHr(hr, "ReadData", "SendCancelRequest failed");
                        return hr;
                    }

                    m_Phase = CAMERA_PHASE_IDLE; // camera will not send response
                    return S_FALSE;
                }
            }
        }

        //
        // Increment the offset
        //
        lOffset += BytesRead;
    }

    if ((TotalRead + sizeof(m_pUsbData->Header)) % m_EndpointInfo.BulkInMaxSize == 0)
    {
        //
        // Read the extra null packet
        //
        wiauDbgTrace("ReadData", "reading a null packet");

        BytesRead = 0;
        if (!ReadFile(m_hUSB, m_pUsbData, m_UsbDataSize, &BytesRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadData", "ReadFile failed");
            return hr;
        }
        
        if (BytesRead != 0)
        {
            wiauDbgError("ReadData", "tried to read null packet but read %d bytes instead", BytesRead);
            return E_FAIL;
        }
    }

    *pBufferSize = TotalRead;

    wiauDbgTrace("ReadData", "%d bytes of data successfully read", TotalRead);

    if (bAbortTransfer)
        hr = S_FALSE;

    return hr;
}

//
// This function writes bulk data to the device
//
// Input:
//   pData -- pointer to a buffer of data to write
//   BufferSize -- amount of data to write
//
HRESULT
CUsbCamera::SendData(
    BYTE *pData,
    UINT BufferSize
    )
{
    DBG_FN("CUsbCamera::SendData");

    HRESULT hr = S_OK;

    if (!pData ||
        BufferSize == 0)
    {
        wiauDbgError("SendData", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Figure out how many packets it will take to contain the header
    //
    UINT BytesToWrite = m_EndpointInfo.BulkOutMaxSize;
    while (BytesToWrite < sizeof(m_pUsbData->Header))
    {
        BytesToWrite += m_EndpointInfo.BulkOutMaxSize;
    }

    //
    // The first write will contain the USB header plus as much of the data as it
    // takes to fill out the packet. We need to write full packets, otherwise the device
    // will think the transfer is done.
    //
    UINT FirstWriteDataAmount = min(BufferSize, BytesToWrite - sizeof(m_pUsbData->Header));
    BytesToWrite = sizeof(m_pUsbData->Header) + FirstWriteDataAmount;

    //
    // Fill out header fields
    //
    m_pUsbData->Header.Len = BufferSize + sizeof(m_pUsbData->Header);
    m_pUsbData->Header.Type = PTPCONTAINER_TYPE_DATA;
    m_pUsbData->Header.Code = m_prevOpCode;
    m_pUsbData->Header.TransactionId = m_prevTranId;

    //
    // Copy the part of the data needed to fill out the packets
    //
    memcpy(m_pUsbData->Data, pData, FirstWriteDataAmount);

    //
    // Write the header plus partial data
    //
    wiauDbgTrace("SendData", "Writing first packet, length = %d", BytesToWrite);
    DWORD BytesWritten = 0;
    if (!WriteFile(m_hUSB, m_pUsbData, BytesToWrite, &BytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "SendData", "WriteFile failed");
        return hr;
    }

    if (BytesWritten != BytesToWrite)
    {
        wiauDbgError("SendData", "wrong amount of data written = %d", BytesWritten);
        return E_FAIL;
    }

    UINT TotalBytesWritten = BytesWritten;

    //
    // The next write (if necessary) will include the remainder of the data
    //
    if (BufferSize > FirstWriteDataAmount)
    {
        BytesToWrite = BufferSize - FirstWriteDataAmount;
        BytesWritten = 0;
        wiauDbgTrace("SendData", "writing remainder of data, length = %d", BytesToWrite);

        if (!WriteFile(m_hUSB, &pData[FirstWriteDataAmount], BytesToWrite, &BytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "SendData", "second WriteFile failed");
            return hr;
        }

        if (BytesWritten != BytesToWrite)
        {
            wiauDbgError("SendData", "wrong amount of data written = %d -", BytesWritten);
            return E_FAIL;
        }

        TotalBytesWritten += BytesWritten;
    }

    //
    // If the amount written is exactly a multiple of the packet size, send an empty packet
    // so the device knows we are done sending data
    //
    if (TotalBytesWritten % m_EndpointInfo.BulkOutMaxSize == 0)
    {
        BytesWritten = 0;
        wiauDbgTrace("SendData", "writing null packet");

        if (!WriteFile(m_hUSB, NULL, 0, &BytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "SendData", "third WriteFile failed");
            return hr;
        }

        if (BytesWritten != 0)
        {
            wiauDbgError("SendData", "wrong amount of data written = %d --", BytesWritten);
            return E_FAIL;
        }
    }

    wiauDbgTrace("SendData", "%d bytes of data successfully written", TotalBytesWritten);

    return hr;
}

//
// This function reads the response data from the device
//
// Input:
//   pResponse -- pointer to a response structure to receive the response data
//
HRESULT
CUsbCamera::ReadResponse(
    PTP_RESPONSE *pResponse
    )
{
    DBG_FN("CUsbCamera::ReadResponse");

    HRESULT hr = S_OK;

    if (!pResponse)
    {
        wiauDbgError("ReadResponse", "invalid arg");
        return E_INVALIDARG;
    }
    
    //
    // Handle response from reset command
    //
    if (m_prevOpCode == PTP_OPCODE_RESETDEVICE)
    {
        wiauDbgTrace("ReadResponse", "creating reset response");

        pResponse->ResponseCode = PTP_RESPONSECODE_OK;
        pResponse->SessionId = m_SessionId;
        pResponse->TransactionId = m_prevTranId;
    }

    else
    {
        //
        // Clear the USB response buffer
        //
        memset(&m_UsbResponse, NULL, sizeof(m_UsbResponse));

        //
        // Read the response from the device
        //
        DWORD BytesRead = 0;
        wiauDbgTrace("ReadResponse", "reading response");

        if (!ReadFile(m_hUSB, &m_UsbResponse, sizeof(m_UsbResponse), &BytesRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadResponse", "ReadFile failed");
            return hr;
        }

        if ((BytesRead < sizeof(m_UsbResponse.Header)) ||
            (BytesRead > sizeof(m_UsbResponse)))
        {
            wiauDbgError("ReadResponse", "wrong amount of data read = %d", BytesRead);
            return E_FAIL;
        }

        //
        // Check the type code in the response to make sure it's correct
        //
        if (m_UsbResponse.Header.Type != PTPCONTAINER_TYPE_RESPONSE)
        {
            wiauDbgError("ReadResponse", "expected a response but received type = %d", m_UsbResponse.Header.Type);
            return E_FAIL;
        }

        //
        // Unwrap the PTP response from the USB container
        //
        pResponse->ResponseCode = m_UsbResponse.Header.Code;
        pResponse->SessionId = m_SessionId;  // USB doesn't care about session id, so just use the one we have stored
        pResponse->TransactionId = m_UsbResponse.Header.TransactionId;

        DWORD ParamLen = BytesRead - sizeof(m_UsbResponse.Header);
        if (ParamLen > 0)
        {
            memcpy(pResponse->Params, m_UsbResponse.Params, ParamLen);
        }
    }

    wiauDbgTrace("ReadResponse", "response successfully read");

    return hr;
}

//
// This function reads event data from the device
//
// Input:
//   pEvent -- pointer to a PTP event structure to receive the event data
//
HRESULT
CUsbCamera::ReadEvent(
    PTP_EVENT *pEvent
    )
{
    DBG_FN("CUsbCamera::ReadEvent");

    HRESULT hr = S_OK;
    
    if (!pEvent)
    {
        wiauDbgError("ReadEvent", "invalid arg");
        return E_INVALIDARG;
    }
    
    //
    // Clear the re-usable USB event buffer
    //
    memset(&m_UsbEvent, NULL, sizeof(m_UsbEvent));

    //
    // Read the event from the device. DeviceIoControl is called in overlapped mode. If
    // no information is ready on the interrupt pipe, GetOverlappedResult will wait for
    // data to arrive. Unfortunately, DeviceIoControl returns after each packet, so keep
    // reading until a short packet is received.
    //
    DWORD BytesRead = 0;
    DWORD TotalBytesRead = 0;
    BOOL bReceivedShortPacket = FALSE;
    BYTE *pData = (BYTE *) &m_UsbEvent;

    wiauDbgTrace("ReadEvent", "reading event");

    while (!bReceivedShortPacket)
    {
        if (!ResetEvent(m_hEventRead))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ReadEvent", "ResetEvent failed");
            return hr;
        }

        memset(&m_Overlapped, 0, sizeof(OVERLAPPED));
        m_Overlapped.hEvent = m_hEventRead;

        if (!DeviceIoControl(m_hEventUSB,
                             IOCTL_WAIT_ON_DEVICE_EVENT,
                             NULL,
                             0,
                             pData,
                             sizeof(m_UsbEvent) - TotalBytesRead,
                             &BytesRead,
                             &m_Overlapped))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING))
            {
                hr = S_OK;
                DWORD ret;
                wiauDbgTrace("ReadEvent", "waiting for interrupt pipe data");

                ret = WaitForMultipleObjects(2, m_EventHandles, FALSE, INFINITE);
                if (ret == WAIT_FAILED)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    wiauDbgErrorHr(hr, "ReadEvent", "WaitForMultipleObjects failed");
                    return hr;
                }
                else if (ret == WAIT_OBJECT_0)
                {
                    //
                    // Indicate to caller that I/O was cancelled
                    //
                    wiauDbgTrace("ReadEvent", "Cancelling I/O on the interrupt pipe");
                    hr = S_FALSE;

                    HRESULT temphr = S_OK;

                    //
                    // Cancel the pending I/O on the interrupt pipe
                    //
                    if (!CancelIo(m_hEventUSB))
                    {
                        temphr = HRESULT_FROM_WIN32(::GetLastError());
                        wiauDbgErrorHr(hr, "ReadEvent", "CancelIo failed");
                        //
                        // Still SetEvent and then exit
                        //
                    }

                    //
                    // Signal event to cancel interrupt pipe I/O
                    //
                    if (!SetEvent(m_hEventCancelDone))
                    {
                        temphr = HRESULT_FROM_WIN32(::GetLastError());
                        wiauDbgErrorHr(hr, "ReadEvent", "SetEvent failed");
                    }

                    //
                    // Exit point when I/O is cancelled!!!
                    //
                    return hr;

                }
                else
                {
                    //
                    // Get result of read
                    //
                    if (!GetOverlappedResult(m_hEventUSB, &m_Overlapped, &BytesRead, TRUE))
                    {
                        hr = HRESULT_FROM_WIN32(::GetLastError());
                        wiauDbgErrorHr(hr, "ReadEvent", "GetOverlappedResult failed");
                        return hr;
                    }
                }
            }
            else
            {
                wiauDbgErrorHr(hr, "ReadEvent", "DeviceIoControl failed");
                return hr;
            }
        }

        if (BytesRead == 0) {
            bReceivedShortPacket = TRUE;
        }
        else {
            TotalBytesRead += BytesRead;
            pData += BytesRead;
            bReceivedShortPacket = (BytesRead % m_EndpointInfo.InterruptMaxSize != 0);
        }
    }

    if ((TotalBytesRead < sizeof(m_UsbEvent.Header)) ||
        (TotalBytesRead > sizeof(m_UsbEvent)))
    {
        wiauDbgError("ReadEvent", "wrong amount of data read by DeviceIoControl = %d", TotalBytesRead);
        return E_FAIL;
    }

    //
    // Check the type code in the response to make sure it's correct
    //
    if (m_UsbEvent.Header.Type != PTPCONTAINER_TYPE_EVENT)
    {
        wiauDbgError("ReadEvent", "expected an event but received type = %d", m_UsbEvent.Header.Type);
        return E_FAIL;
    }
    
    //
    // Unwrap the PTP event from the USB container
    //
    pEvent->EventCode = m_UsbEvent.Header.Code;
    pEvent->SessionId = m_SessionId;  // USB doesn't care about session id, so just use the one we have stored
    pEvent->TransactionId = m_UsbEvent.Header.TransactionId;

    DWORD ParamLen = TotalBytesRead - sizeof(m_UsbEvent.Header);
    if (ParamLen > 0)
    {
        memcpy(pEvent->Params, m_UsbEvent.Params, ParamLen);
    }

    wiauDbgTrace("ReadEvent", "event successfully read, byte count = %d", TotalBytesRead);

    return hr;
}

//
// This function cancels the remainder of a data transfer.
//
HRESULT
CUsbCamera::AbortTransfer()
{
    DBG_FN("CUsbCamera::AbortTransfer");

    HRESULT hr = S_OK;

    //
    // WIAFIX-8/28/2000-davepar Fill in the details:
    // 1. If usbscan.sys already transferred the data, clear it's buffer
    // 2. If not, send cancel control code to camera
    //

    return hr;
}

//
// This function attempts to recover from an error. When this function returns, the
// device will be in one of three states:
// 1. Ready for more commands, indicated by S_OK
// 2. Reset, indicated by S_FALSE
// 3. Unreachable, indicated by FAILED(hr)
//
HRESULT
CUsbCamera::RecoverFromError()
{
    DBG_FN("CUsbCamera::RecoverFromError");

    HRESULT hr = S_OK;

    //
    // WIAFIX-7/29/2000-davepar Maybe first should cancel all pending I/O with IOCTL_CANCEL_IO??
    //

    //
    // Attempt to get status on the device
    //
    USB_PTPDEVICESTATUS DeviceStatus;
    hr = GetDeviceStatus(&DeviceStatus);

    //
    // If that worked, clear any stalls returned
    //
    if (SUCCEEDED(hr))
    {
        hr = ClearStalls(&DeviceStatus);

        //
        // If clearing all the stalls worked, exit
        //
        if (SUCCEEDED(hr))
        {
            wiauDbgTrace("RecoverFromError", "device is ready for more commands");
            return S_OK;
        }
    }

    //
    // Either the GetDeviceStatus or ClearStall failed, reset the device
    //
    hr = ResetDevice();

    //
    // If that worked, return S_FALSE
    //
    if (SUCCEEDED(hr))
    {
        wiauDbgWarning("RecoverFromError", "the device was reset");
        return S_FALSE;
    }
    
    //
    // If that fails, the device is unreachable
    //
    wiauDbgError("RecoverFromError", "ResetDevice failed");

    return hr;
}

//
// This function gets the device status, used mainly after an error occurs. It
// may return an endpoint number that the device has intentionally stalled to
// cancel a transaction. The caller should be prepared to clear the stall.
//
// Input:
//       pDeviceStatus -- the receive the status.
//
HRESULT
CUsbCamera::GetDeviceStatus(
                           USB_PTPDEVICESTATUS *pDeviceStatus
                           )
{
    DBG_FN("CUsbCamera::GetDeviceStatus");

    HRESULT hr = S_OK;
    
    //
    // Set up the request
    //
    IO_BLOCK_EX IoBlock;

    IoBlock.bRequest = USB_PTPREQUEST_GETSTATUS;
    IoBlock.bmRequestType = USB_PTPREQUEST_TYPE_IN;
    IoBlock.fTransferDirectionIn = TRUE;
    IoBlock.uOffset = 0;
    IoBlock.uLength = sizeof(*pDeviceStatus);
    IoBlock.pbyData = (UCHAR *) pDeviceStatus;
    IoBlock.uIndex = 0;

    pDeviceStatus->Header.Code = 0;

    //
    // Send the request
    //
    wiauDbgTrace("GetDeviceStatus", "sending GetDeviceStatus request");
    DWORD BytesRead = 0;
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_SEND_USB_REQUEST_PTP,
                         &IoBlock,
                         sizeof(IoBlock),
                         pDeviceStatus,
                         sizeof(*pDeviceStatus),
                         &BytesRead,
                         NULL
                         ))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "GetDeviceStatus", "DeviceIoControl failed");
        return hr;
    }

    if (BytesRead < sizeof(USB_PTPDEVICESTATUS_HEADER) ||
        BytesRead > sizeof(*pDeviceStatus))
    {
        wiauDbgError("GetDeviceStatus", "wrong amount of data returned = %d", BytesRead);
        return E_FAIL;
    }

    if((HIBYTE(pDeviceStatus->Header.Code) & 0xF0) != 0x20 &&
       (HIBYTE(pDeviceStatus->Header.Code) & 0xF0) != 0xA0)
    {
        wiauDbgError("GetDeviceStatus", "PTP status code (0x%x)is invalid ", pDeviceStatus->Header.Code);
        return E_FAIL;
    }


    wiauDbgTrace("GetDeviceStatus", "read %d bytes", BytesRead);

    if (g_dwDebugFlags & WIAUDBG_DUMP)
    {
        wiauDbgTrace("GetDeviceStatus", "Dumping device status:");
        wiauDbgTrace("GetDeviceStatus", "  Length            = 0x%04x", pDeviceStatus->Header.Len);
        wiauDbgTrace("GetDeviceStatus", "  Response code     = 0x%04x", pDeviceStatus->Header.Code);

        ULONG NumParams = (ULONG)min(MAX_NUM_PIPES, (BytesRead - sizeof(pDeviceStatus->Header) / sizeof(pDeviceStatus->Params[0])));
        for (ULONG count = 0; count < NumParams; count++)
        {
            wiauDbgTrace("GetDeviceStatus", "  Param %d           = 0x%08x", count, pDeviceStatus->Params[count]);
        }
    }

    return hr;
}

//
// This function clears all the stalls listed in the given device status
//
// Input:
//       pDeviceStatus -- lists zero or more stalled endpoints
//
HRESULT
CUsbCamera::ClearStalls(
    USB_PTPDEVICESTATUS *pDeviceStatus
    )
{
    DBG_FN("CUsbCamera::ClearStalls");

    HRESULT hr = S_OK;
    
    if (!pDeviceStatus)
    {
        wiauDbgError("ClearStalls", "invalid arg");
        return E_INVALIDARG;
    }


    PIPE_TYPE PipeType;
    ULONG NumStalls = (pDeviceStatus->Header.Len - sizeof(pDeviceStatus->Header)) / sizeof(pDeviceStatus->Params[0]);

    for (ULONG count = 0; count < NumStalls; count++)
    {
        //
        // Translate the endpoint address to the pipe type
        //
        if ((UCHAR)pDeviceStatus->Params[count] == m_EndpointInfo.BulkInAddress)
        {
            PipeType = READ_DATA_PIPE;
        }
        else if ((UCHAR)pDeviceStatus->Params[count] == m_EndpointInfo.BulkOutAddress)
        {
            PipeType = WRITE_DATA_PIPE;
        }
        else if ((BYTE)pDeviceStatus->Params[count] == m_EndpointInfo.InterruptAddress)
        {
            PipeType = EVENT_PIPE;
        }
        else
        {
            //
            // Unrecognized, ignore it
            //
            wiauDbgError("ClearStalls", "unrecognized pipe address 0x%08x", pDeviceStatus->Params[count]);
            continue;
        }
        
        //
        // Reset the endpoint
        //
        DWORD BytesRead;
        if (!DeviceIoControl(m_hUSB,
                             IOCTL_RESET_PIPE,
                             &PipeType,
                             sizeof(PipeType),
                             NULL,
                             0,
                             &BytesRead,
                             NULL
                             ))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "ClearStalls", "DeviceIoControl failed");
            return hr;
        }
    }
    
    if(NumStalls) {
        for(count = 0; count < 3; count++) {
            if(FAILED(GetDeviceStatus(pDeviceStatus))) {
                wiauDbgErrorHr(hr, "ClearStalls", "GetDeviceStatus failed");
                return hr;
            }
            if(pDeviceStatus->Header.Code == PTP_RESPONSECODE_OK) {
                break;
            }
        }
    }

    //
    // Device should be ready to receive commands again
    //
    m_Phase = CAMERA_PHASE_IDLE;

    return hr;
}

//
// Reset the device
//
HRESULT
CUsbCamera::SendResetDevice()
{
    DBG_FN("CUsbCamera::SendResetDevice");

    HRESULT hr = S_OK;
    
    //
    // Set up the request
    //
    IO_BLOCK_EX IoBlock;
    IoBlock.bRequest = USB_PTPREQUEST_RESET;
    IoBlock.bmRequestType = USB_PTPREQUEST_TYPE_IN;
    IoBlock.fTransferDirectionIn = TRUE;
    IoBlock.uOffset = 0;
    IoBlock.uLength = 0;
    IoBlock.pbyData = NULL;
    IoBlock.uIndex = 0;

    //
    // Send the request
    //
    DWORD BytesRead;
    if (!DeviceIoControl(m_hUSB,
                         IOCTL_SEND_USB_REQUEST_PTP,
                         &IoBlock,
                         sizeof(IoBlock),
                         NULL,
                         0,
                         &BytesRead,
                         NULL
                        ))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "ResetDevice", "DeviceIoControl failed");
        return hr;
    }
    //
    // Let the device settle
    //
    Sleep(1000);

    //
    // Side effect of reseting the device is that the phase, session id, and transaction id get reset
    //
    m_Phase = CAMERA_PHASE_IDLE;
    m_SessionId = 0;
    m_NextTransactionId = PTP_TRANSACTIONID_MIN;

    return hr;
}


//
// This function sends the class CancelRequest command to the device
// and wait for the device to complete the request.
// Input:
//      dwTransactionId -- transaction being canceled
//
HRESULT
CUsbCamera::SendCancelRequest(DWORD dwTransactionId)
{
    DBG_FN("CUsbCamera::CancelRequest");
    
    HRESULT hr = S_OK;
    IO_BLOCK_EX IoBlock;
    USB_PTPCANCELIOREQUEST CancelRequest;
    DWORD BytesReturned;

    IoBlock.bRequest = USB_PTPREQUEST_CANCELIO;
    IoBlock.bmRequestType = USB_PTPREQUEST_TYPE_OUT;
    IoBlock.fTransferDirectionIn = FALSE;             // Host to device
    IoBlock.uOffset = 0;                              // 0 for this request
    IoBlock.uLength = sizeof(USB_PTPCANCELIOREQUEST); // Data output length
    IoBlock.pbyData = (BYTE *)&CancelRequest;         // output data
    IoBlock.uIndex = 0;                               // 0 for this request

    CancelRequest.Id = USB_PTPCANCELIO_ID;
    CancelRequest.TransactionId = dwTransactionId;

    if (DeviceIoControl(m_hUSB,
                        IOCTL_SEND_USB_REQUEST_PTP,
                        &IoBlock,
                        sizeof(IoBlock),
                        NULL,
                        0,
                        &BytesReturned,
                        NULL
                       ))
    {
        //
        // Poll device until it returns to idle state
        //
        USB_PTPDEVICESTATUS DeviceStatus;
        const UINT MAX_CANCEL_RECOVERY_MILLISECONDS = 3000;
        const UINT SLEEP_BETWEEN_RETRIES            = 100;
        DWORD RetryCounts = MAX_CANCEL_RECOVERY_MILLISECONDS / SLEEP_BETWEEN_RETRIES;

        while (RetryCounts--)
        {
            hr = GetDeviceStatus(&DeviceStatus);
            if (SUCCEEDED(hr))
            {
                if (PTP_RESPONSECODE_OK == DeviceStatus.Header.Code)
                {
                    //
                    // CancelRequest completed and device is back idle
                    //
                    hr = S_OK;
                    break;
                }
                else if (PTP_RESPONSECODE_DEVICEBUSY != DeviceStatus.Header.Code)
                {
                    //
                    // This is wrong. Device must be either busy or idle
                    //
                    wiauDbgError("SendCancelRequest", 
                        "Device is in invalid state, DeviceStatus=0x%X", DeviceStatus.Header.Code);
                    hr = E_FAIL;
                    break;
                }
            }
            else
            {
                if (RetryCounts)
                {
                    hr = S_OK;
                    wiauDbgWarning("CancelRequest", "GetDeviceStatus failed, retrying...");
                }
                else
                {
                    wiauDbgError("CancelRequest", "GetDeviceStatus failed");
                }
            }

            Sleep(SLEEP_BETWEEN_RETRIES);
        }

        //
        // Flush system buffers - otherwise we'll get old data on next read
        //
        FlushFileBuffers(m_hUSB);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "CancelRequest", "send USB request failed");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\dllmain.h ===
#ifndef DLLMAIN__H_
#define DLLMAIN__H_

extern "C"
{
    BOOL
    APIENTRY
    DllMain(
           HINSTANCE hInstance,
           DWORD dwReason,
           LPVOID lpReserved
           );
}

extern HINSTANCE g_hInst;

#endif // #ifndef DLLMAIN__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\dllmain.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    dllmain.cpp

Abstract:

    This module implements the dll exported APIs

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "ptppch.h"

#include <locale.h>

HINSTANCE g_hInst;

//
// Entry point of this transport DLL
// Input:
//	hInstance   -- Instance handle of this dll
//	dwReason    -- reason why this entry was called.
//	lpReserved  -- reserved!
//
// Output:
//	TRUE	    if our initialization went well
//	FALSE	    if for GetLastError() reason, we failed.
//
BOOL
APIENTRY
DllMain(
        HINSTANCE hInstance,
        DWORD dwReason,
        LPVOID lpReserved
        )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        
        g_hInst = hInstance;
        
        //
        // Set the locale to system default so that wcscmp and similary functions
        // would work on non-unicode platforms(Millenium, for example).
        //
        setlocale(LC_ALL, "");

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\camusb.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camusb.h

Abstract:

    Header file that declares CUsbCamera object

Author:

    William Hsieh (williamh) created

Revision History:

--*/

#ifndef CAMUSB__H_
#define CAMUSB__H_

//
// These are the USB timeout values in seconds
//
const PTP_READ_TIMEOUT = 5;
const PTP_WRITE_TIMEOUT = 5;
const PTP_EVENT_TIMEOUT = 0;
//
// USB Still image device container types
//
const WORD PTPCONTAINER_TYPE_UNDEFINED = 0;
const WORD PTPCONTAINER_TYPE_COMMAND   = 1;
const WORD PTPCONTAINER_TYPE_DATA      = 2;
const WORD PTPCONTAINER_TYPE_RESPONSE  = 3;
const WORD PTPCONTAINER_TYPE_EVENT     = 4;

//
// Used to store info about the endpoints
//
typedef struct _USB_PTP_ENDPOINT_INFO
{
    USHORT BulkInMaxSize;
    UCHAR  BulkInAddress;
    USHORT BulkOutMaxSize;
    UCHAR  BulkOutAddress;
    USHORT InterruptMaxSize;
    UCHAR  InterruptAddress;
} USB_PTP_ENDPOINT_INFO, *PUSB_PTP_ENDPOINT_INFO;


#pragma pack(push, Old, 1)


//
// When a USB device stalls, the usb kernel mode stack driver returns
// a NTSTATUS code, STATUS_DEVICE_DATA_ERROR. Translates this NT status
// code to WIN32 error code, we get ERROR_CRC.
//
const DWORD WIN32ERROR_USBSTALL = ERROR_CRC;

//
// Container header
//
typedef struct _USB_PTP_HEADER
{
    DWORD   Len;            // total length of container in bytes including header
    WORD    Type;           // container type, one of CONTAINER_TYPE_COMMAND/RESPONSE/DATA/EVENT
    WORD    Code;           // opcode, response code, or event code
    DWORD   TransactionId;  // transaction id

}USB_PTP_HEADER, *PUSB_PTP_HEADER;

//
// USB PTP command structure
//
typedef struct _USB_PTP_COMMAND
{
    USB_PTP_HEADER  Header;
    DWORD           Params[COMMAND_NUMPARAMS_MAX];

}USB_PTP_COMMAND, *PUSB_PTP_COMMAND;

//
// USB PTP response structure
//
typedef struct _USB_PTP_RESPONSE
{
    USB_PTP_HEADER  Header;
    DWORD           Params[RESPONSE_NUMPARAMS_MAX];
}USB_PTP_RESPONSE, *PUSB_PTP_RESPONSE;

//
// USB PTP event structure
//
typedef struct _USB_PTP_EVENT
{
    USB_PTP_HEADER  Header;
    DWORD           Params[EVENT_NUMPARAMS_MAX];

}USB_PTP_EVENT, *PUSB_PTP_EVENT;

//
// USB PTP data structure
//
typedef struct _USB_PTP_DATA
{
    USB_PTP_HEADER  Header;
    BYTE            Data[1];

}USB_PTP_DATA, *PUSB_PTP_DATA;

//
// GetDeviceStatus header
//
typedef struct tagUSBPTPDeviceStatusHeader
{
    WORD  Len;                        // status
    WORD  Code;                       // ptp response code

}USB_PTPDEVICESTATUS_HEADER, *PUSB_PTPDEVICESTATUS_HEADER;

//
// GetDeviceStatus data
//
typedef struct  tagUSBPTPDeviceStatus
{
    USB_PTPDEVICESTATUS_HEADER  Header;      // the header
    DWORD                       Params[MAX_NUM_PIPES];
}USB_PTPDEVICESTATUS, *PUSB_PTPDEVICESTATUS;

const BYTE USB_PTPREQUEST_TYPE_OUT  = 0x21;
const BYTE USB_PTPREQUEST_TYPE_IN   = 0xA1;
const BYTE USB_PTPREQUEST_CANCELIO  = 0x64;
const BYTE USB_PTPREQUEST_GETEVENT  = 0x65;
const BYTE USB_PTPREQUEST_RESET     = 0x66;
const BYTE USB_PTPREQUEST_GETSTATUS = 0x67;

const WORD USB_PTPCANCELIO_ID = 0x4001;

//
// Other USB Imaging Class-specific commands
//
typedef struct tagUSBPTPCancelIoRequest
{
    WORD    Id;
    DWORD   TransactionId;

}USB_PTPCANCELIOREQUEST, *PUSB_PTPCANCELIOREQUEST;

typedef struct tagUSBPTPResetRequest
{
    DWORD   TransactionId;

}USB_PTPRESETREQUEST, *PUSB_PTPRESETREQUEST;

typedef struct tagUSBPTPGetEventRequest
{
    WORD    EventCode;
    DWORD   TransactionId;
    DWORD   Params;

}USB_PTPGETEVENTREQUEST, *PUSB_PTPGETEVENTREQUEST;


#pragma pack(pop, Old)


//
// A CPTPCamera derived class to support PTP USB devices
//
class CUsbCamera : public CPTPCamera
{
public:
    CUsbCamera();
    ~CUsbCamera();

private:
    HRESULT Open(LPWSTR DevicePortName, PTPEventCallback pPTPEventCB,
                 PTPDataCallback pPTPDataCB, LPVOID pEventParam, BOOL bEnableEvents = TRUE);
    HRESULT Close();

    //
    // Functions called by the base class
    //
    HRESULT SendCommand(PTP_COMMAND *pCommand, UINT NumParams);
    HRESULT ReadData(BYTE *pData, UINT *pBufferSize);
    HRESULT SendData(BYTE *pData, UINT BufferSize);
    HRESULT ReadResponse(PTP_RESPONSE *pResponse);
    HRESULT ReadEvent(PTP_EVENT *pEvent);
    HRESULT AbortTransfer();
    HRESULT RecoverFromError();

private:
    //
    // Private utility functions
    //
    HRESULT GetDeviceStatus(USB_PTPDEVICESTATUS *pDeviceStatus);
    HRESULT ClearStalls(USB_PTPDEVICESTATUS *pDeviceStatus);
    HRESULT SendResetDevice();
    HRESULT SendCancelRequest(DWORD dwTransactionId);    
    
    //
    // Member variables
    //
    HANDLE                  m_hUSB;             // File handle used to communicate with USB device
    HANDLE                  m_hEventUSB;        // File handle used to read events
    OVERLAPPED              m_Overlapped;       // Overlapped structure for event reads
    HANDLE                  m_hEventRead;       // Event handle used by event read
    HANDLE                  m_hEventCancel;     // Event handle used to cancel interrupt read
    HANDLE                  m_hEventCancelDone; // Event that indicates the cancel interrupt read is complete
    HANDLE                  m_EventHandles[2];  // Array used by WaitForMultipleObjects

    USB_PTP_ENDPOINT_INFO   m_EndpointInfo;     // Info about the endpoints

    USB_PTP_COMMAND         m_UsbCommand;       // Re-usable buffer for commands
    USB_PTP_RESPONSE        m_UsbResponse;      // Re-usable buffer for responses
    USB_PTP_EVENT           m_UsbEvent;         // Re-usable buffer for events
    USB_PTP_DATA           *m_pUsbData;         // Pointer to re-usable buffer for short data transfers
    UINT                    m_UsbDataSize;      // Size allocated for the data transfer buffer

    WORD                    m_prevOpCode;       // Used to store opcode between command and data phases
    DWORD                   m_prevTranId;       // Used to store transaction id between command and data phases
};

#endif  // #ifndef CAMUSB__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\ptppch.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ptppch.h

Abstract:

    Precompiled header

Author:

    DavePar

Revision History:


--*/


#ifndef _PTPPCH_H
#define _PTPPCH_H

#include <windows.h>
#include <stddef.h>
#include <tchar.h>
#include <objbase.h>
#include <assert.h>
#include <stdio.h>

#include <usbscan.h>

#include <wiamindr.h>
#include <wiautil.h>

#include "wiatempl.h"
#include "iso15740.h"
#include "camera.h"
#include "camusb.h"
#include "ptputil.h"

#endif // _PTPPCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\ptputil.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    ptputil.h

Abstract:

    This module declares PTP data manipulating utility functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef PTPUTIL__H_
#define PTPUTIL__H_

//
// Time conversion functions
//
HRESULT PtpTime2SystemTime(CBstr *pptpTime, SYSTEMTIME *pSystemTime);
HRESULT SystemTime2PtpTime(SYSTEMTIME *pSystemTime, CBstr *pptpTime);

//
// File utility functions
//
HRESULT WriteBmpToFile(TCHAR *pFileName, ULONG bmpSize, BYTE *pbmp,
                       INT bmpWidth, INT bmpHeight, UINT LineSize);

//
// Functions that dump a PTP structure to the log file
//
VOID    DumpCommand(PTP_COMMAND *pCommand, DWORD NumParams);
VOID    DumpResponse(PTP_RESPONSE *pResponse);
VOID    DumpEvent(PTP_EVENT *pEvent);
VOID    DumpGuid(GUID *pGuid);

//
// Class for reading registry entries
//
class CPTPRegistry
{
public:
    CPTPRegistry() :
        m_hKey(NULL)
    {
    }

    ~CPTPRegistry()
    {
        if (m_hKey)
            RegCloseKey(m_hKey);
    }

    HRESULT Open(HKEY hkAncestor, LPCTSTR KeyName, REGSAM Access = KEY_READ);
    HRESULT GetValueStr(LPCTSTR ValueName, TCHAR *string, DWORD *pStringLen);
    HRESULT GetValueDword(LPCTSTR ValueName, DWORD *pValue);
    HRESULT GetValueCodes(LPCTSTR ValueName, CArray16 *pCodeArray);

private:
    HKEY    m_hKey;
};

#endif // PTPUTIL__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\ptputil.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    ptputil.cpp

Abstract:

    This module implements PTP data structure manipulating functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "ptppch.h"

//
// This function converts a PTP datetime string to Windows FILETIME.
//
// Input:
//  pptpTime    -- the PTP datetime string
//  SystemTime  -- SYSTEMTIME structure to receive the converted time
//
// Notes:
//   PTP timestamp is a string with the format "YYYYMMDDThhmmss.s", where
//     YYYY is the year
//     MM   is the month(1 - 12)
//     DD   is the day(1 - 31)
//     T    is the constant used to separate date and time
//     hh   is the hour(0 - 23)
//     mm   is the minute(0 - 59)
//     ss   is the second(0 - 59)
//     .s   is the optional 10th of second
//
//   Append it with 'Z' means it is a UTC time.
//   Append it with "+/-hhmm" means it is relative to a time zone.
//   Append neither means the time zone is unknown, assume time zone of the host.
//
HRESULT
PtpTime2SystemTime(
    CBstr *pptpTime,
    SYSTEMTIME *pSystemTime
    )
{
    DBG_FN("PTPTime2FileTime");

    HRESULT hr = S_OK;
    
    if (!pSystemTime || !pptpTime || !pptpTime->String() ||
        pptpTime->Length() < 4 + 2 + 2 + 1 + 2 + 2 + 2 ||
        L'T' != pptpTime->String()[4 + 2 + 2])
    {
        wiauDbgTrace("PtpTime2SystemTime", "Invalid arg");
        return E_INVALIDARG;
    }

    WCHAR TimeString[MAX_PATH];
    wcscpy(TimeString, pptpTime->String());
    WCHAR wch;
    LPWSTR pwcsEnd;

    wch = TimeString[4];
    TimeString[4] = UNICODE_NULL;
    pSystemTime->wYear = (WORD)wcstol(TimeString, &pwcsEnd, 10);
    TimeString[4] = wch;
    wch = TimeString[6];
    TimeString[6] = UNICODE_NULL;
    pSystemTime->wMonth = (WORD)wcstol(TimeString + 4, &pwcsEnd, 10);
    TimeString[6] = wch;
    wch = TimeString[8];
    TimeString[8] = UNICODE_NULL;
    pSystemTime->wDay =   (WORD)wcstol(TimeString + 6 , &pwcsEnd, 10);
    TimeString[8] = wch;
    wch = TimeString[11];
    TimeString[11] = UNICODE_NULL;
    pSystemTime->wHour = (WORD)wcstol(TimeString + 9, &pwcsEnd, 10);
    TimeString[11] = wch;
    wch = TimeString[13];
    TimeString[13] = UNICODE_NULL;
    pSystemTime->wMinute = (WORD)wcstol(TimeString + 11, &pwcsEnd, 10);
    TimeString[13] = wch;
    wch = TimeString[15];
    TimeString[15] = UNICODE_NULL;
    pSystemTime->wSecond = (WORD)wcstol(TimeString + 13, &pwcsEnd, 10);
    TimeString[15] = wch;
    if (L'.' == wch)
    {
        wch = TimeString[17];
        TimeString[17] = UNICODE_NULL;
        pSystemTime->wMilliseconds = 100 * (WORD)wcstol(TimeString + 16, &pwcsEnd, 10);
        TimeString[17] = wch;
    }
    else
    {
        pSystemTime->wMilliseconds = 0;
    }

    pSystemTime->wDayOfWeek = 0;

    //
    // WIAFIX-8/17/2000-davepar Time zone information is being ignored
    //

    return hr;
}

//
// This function converts a SYSTEMTIME to PTP datetime string.
//
// Input:
//   pSystemTime -- the SYSTEMTIME
//   pptpTime    -- target PTP datatime string
//
HRESULT
SystemTime2PtpTime(
    SYSTEMTIME  *pSystemTime,
    CBstr *pptpTime
    )
{
    DBG_FN("SystemTime2PTPTime");

    HRESULT hr = S_OK;
    
    if (!pptpTime || !pSystemTime)
    {
        wiauDbgError("SystemTime2PtpTime", "Invalid arg");
        return E_INVALIDARG;
    }

    WCHAR ptpTimeStr[MAX_PATH];
    WCHAR *pwstr;
    pwstr = ptpTimeStr;

    //
    // Four digits for year, two for month, and two for day
    //
    swprintf(pwstr, L"%04d%02d%02d", pSystemTime->wYear, pSystemTime->wMonth, pSystemTime->wDay);

    //
    // Separator
    //
    pwstr[8] = L'T';
    pwstr += 9;

    //
    // Two digits for hour, two for minute, and two for second
    //
    swprintf(pwstr, L"%02d%02d%02d", pSystemTime->wHour, pSystemTime->wMinute, pSystemTime->wSecond);
    pwstr += 6;

    //
    // Optional tenth second
    //
    if (pSystemTime->wMilliseconds)
    {
        *pwstr++ = L'.';
        swprintf(pwstr, L"%02d", (WORD)((DWORD)pSystemTime->wMilliseconds * 100));
        pwstr += 2;
    }

    //
    // NULL terminates the string
    //
    *pwstr = UNICODE_NULL;

    hr = pptpTime->Copy(ptpTimeStr);
    if (FAILED(hr))
    {
        wiauDbgError("SystemTime2PtpTime", "Copy failed");
        return hr;
    }

    return hr;
}

//
// This function writes a bitmap image to a file with the appropriate header
//
// Input:
//   pFileName   -- the file name to use
//   bmpSize     -- bmp size in bytes
//   pbmp        -- the bitmap
//   bmpWidth    -- the bmp width in pixels
//   bmpHeight   -- the bmp height in pixels, negative if the bitmap is a top-down DIB
//   LineSize    -- bmp scanline size in bytes
//
HRESULT
WriteBmpToFile(
              TCHAR *pFileName,
              ULONG  bmpSize,
              BYTE  *pbmp,
              INT    bmpWidth,
              INT    bmpHeight,
              UINT   LineSize
              )
{
    DBG_FN("WriteBmpToFile");
    
    HRESULT hr = S_OK;
    
    HANDLE hFile;
    BITMAPINFO bmi;
    BITMAPFILEHEADER bmfh;

    if (!pFileName ||
        !bmpSize ||
        !pbmp)
    {
        wiauDbgError("WriteBmpToFile", "Invalid arg");
        return E_INVALIDARG;
    }

    bmfh.bfType = 'MB';
    bmfh.bfOffBits = sizeof(bmi) + sizeof(bmfh);
    bmfh.bfSize = bmpSize + bmfh.bfOffBits;
    bmfh.bfReserved1 = 0;
    bmfh.bfReserved2 = 0;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = bmpWidth;
    bmi.bmiHeader.biHeight = bmpHeight;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = LineSize * abs(bmpHeight);
    bmi.bmiHeader.biBitCount = 24;
    bmi.bmiHeader.biPlanes = 1;

    hFile = CreateFile(pFileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "WriteBmpToFile", "CreateFile failed");
        return hr;
    }

    DWORD BytesWritten;
    BOOL bResult;

    if (!WriteFile(hFile, &bmfh, sizeof(bmfh), &BytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "WriteBmpToFile", "WriteFile failed");
        CloseHandle(hFile);
        return hr;
    }

    if (!WriteFile(hFile, &bmi, sizeof(bmi), &BytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "WriteBmpToFile", "WriteFile failed");
        CloseHandle(hFile);
        return hr;
    }
            
    if (!WriteFile(hFile, pbmp, bmpSize, &BytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "WriteBmpToFile", "WriteFile failed");
        CloseHandle(hFile);
        return hr;
    }

    CloseHandle(hFile);

    return hr;
}

//
// This function dumps a PTP command block to the log
//
// Input:
//   pCommand -- pointer to a PTP command
//   NumParams -- number of parameters in the command
//
VOID
DumpCommand(
    PTP_COMMAND *pCommand,
    DWORD NumParams
    )
{
    if (!pCommand)
    {
        wiauDbgError("DumpCommand", "Invalid arg");
        return;
    }
    wiauDbgDump("DumpCommand", "Dumping command:");
    wiauDbgDump("DumpCommand", "  Opcode            = 0x%04x", pCommand->OpCode);
    wiauDbgDump("DumpCommand", "  Session id        = 0x%08x", pCommand->SessionId);
    wiauDbgDump("DumpCommand", "  Transaction id    = 0x%08x", pCommand->TransactionId);
    if (NumParams)
    {
        for (DWORD count = 0; count < NumParams; count++)
        {
            wiauDbgDump("DumpCommand", "  Parameter %d       = 0x%08x = %d",
                           count, pCommand->Params[count], pCommand->Params[count]);
        }
    }
}

//
// This function dumps a PTP response block to the log
//
// Input:
//   pResponse -- pointer to a PTP response
//
VOID
DumpResponse(
    PTP_RESPONSE *pResponse
    )
{
    if (!pResponse)
    {
        wiauDbgError("DumpResponse", "Invalid arg");
        return;
    }
    wiauDbgDump("DumpResponse", "Dumping response:");
    wiauDbgDump("DumpResponse", "  Response code     = 0x%04x", pResponse->ResponseCode);
    wiauDbgDump("DumpResponse", "  Session id        = 0x%08x", pResponse->SessionId);
    wiauDbgDump("DumpResponse", "  Transaction id    = 0x%08x", pResponse->TransactionId);
    for (DWORD count = 0; count < RESPONSE_NUMPARAMS_MAX; count++)
    {
        wiauDbgDump("DumpResponse", "  Parameter %d       = 0x%08x = %d",
                       count, pResponse->Params[count], pResponse->Params[count]);
    }
}

//
// This function dumps a PTP event block to the log
//
// Input:
//   pEvent -- pointer to a PTP event
//
VOID
DumpEvent(
    PTP_EVENT *pEvent
    )
{
    if (!pEvent)
    {
        wiauDbgError("DumpEvent", "Invalid arg");
        return;
    }
    wiauDbgDump("DumpEvent", "Dumping event:");
    wiauDbgDump("DumpEvent", "  Event code        = 0x%04x", pEvent->EventCode);
    wiauDbgDump("DumpEvent", "  Session id        = 0x%08x", pEvent->SessionId);
    wiauDbgDump("DumpEvent", "  Transaction id    = 0x%08x", pEvent->TransactionId);
    for (DWORD count = 0; count < EVENT_NUMPARAMS_MAX; count++)
    {
        wiauDbgDump("DumpEvent", "  Parameter %d       = 0x%08x = %d",
                       count, pEvent->Params[count], pEvent->Params[count]);
    }
}

//
// This function dumps a GUID to the log
//
// Input:
//  pGuid  -- GUID to dump
//
VOID
DumpGuid(
        GUID *pGuid
        )
{
    HRESULT hr = S_OK;
    
    if (!pGuid)
    {
        wiauDbgError("DumpGuid", "Invalid arg");
        return;
    }

    WCHAR GuidStringW[128];
    hr = StringFromGUID2(*pGuid, GuidStringW, sizeof(GuidStringW) / sizeof(WCHAR));
    if (FAILED(hr))
    {
        wiauDbgError("DumpGuid", "StringFromGUID2 failed");
        return;
    }

    wiauDbgDump("DumpGuid", "Guid = %S", GuidStringW);
    
    return;
}

//
// This function opens a registry key
//
HRESULT
CPTPRegistry::Open(
                  HKEY hkAncestor,
                  LPCTSTR KeyName,
                  REGSAM Access
                  )
{
    DBG_FN("CPTPRegistry::Open");

    HRESULT hr = S_OK;
    
    if (m_hKey)
    {
        wiauDbgError("Open", "Registry is already open");
        return E_ACCESSDENIED;
    }

    DWORD Win32Err;
    Win32Err = ::RegOpenKeyEx(hkAncestor, KeyName, 0, Access, &m_hKey);
    if (Win32Err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(Win32Err);
        wiauDbgErrorHr(hr, "Open", "RegOpenKeyEx failed");
        return hr;
    }

    return hr;
}

//
// This function gets a string type registry value
//
// Input:
//   ValueName -- the value's name
//   pptpStr   -- the receive the value
//
HRESULT
CPTPRegistry::GetValueStr(
    LPCTSTR ValueName,
    TCHAR *string,
    DWORD *pStringLen
    )
{
    DBG_FN("CPTPRegistry::GetValueStr");

    HRESULT hr = S_OK;
    
    if (!ValueName || !string)
    {
        wiauDbgError("GetValueStr", "Invalid arg");
        return E_INVALIDARG;
    }

    //
    // Need to handle non-Unicode
    //
    DWORD Win32Err;
    Win32Err = ::RegQueryValueEx(m_hKey, ValueName, NULL, NULL, (BYTE *) string, pStringLen);
    if (Win32Err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(Win32Err);
        wiauDbgErrorHr(hr, "GetValueStr", "RegQueryValueEx failed");
        return hr;
    }

    return hr;
}

//
// This function gets a string type registry value and converts it to a DWORD
//
// Input:
//   ValueName -- the value's name
//   pptpStr   -- the receive the value
//
HRESULT
CPTPRegistry::GetValueDword(
    LPCTSTR ValueName,
    DWORD *pValue
    )
{
    DBG_FN("CPTPRegistry::GetValueDword");

    HRESULT hr = S_OK;
    
    if (!ValueName || !pValue)
    {
        wiauDbgError("GetValueDword", "Invalid arg");
        return E_INVALIDARG;
    }

    //
    // Get the string from the registry
    //
    TCHAR string[MAX_PATH];
    DWORD stringLen = MAX_PATH;
    hr = GetValueStr(ValueName, string, &stringLen);
    if (FAILED(hr))
    {
        wiauDbgError("GetValueDword", "GetValueStr failed");
        return hr;
    }

    *pValue = _tcstol(string, NULL, 0);

    return hr;
}

//
// This function gets a list of codes registry value
//
// Input:
//   ValueName -- the value's name
//
//   pptpStr   -- the receive the value
//
HRESULT
CPTPRegistry::GetValueCodes(
    LPCTSTR ValueName,
    CArray16 *pCodeArray
    )
{
    DBG_FN("CPTPRegistry::GetValueCodes");

    HRESULT hr = S_OK;
    
    if (!ValueName || !pCodeArray)
    {
        wiauDbgError("GetValueCodes", "Invalid arg");
        return E_INVALIDARG;
    }

    //
    // Get the string from the registry
    //
    TCHAR valueString[MAX_PATH];
    DWORD stringLen = MAX_PATH;
    hr = GetValueStr(ValueName, valueString, &stringLen);
    if (FAILED(hr))
    {
        wiauDbgError("GetValueCodes", "GetValueStr failed");
        return hr;
    }

    //
    // Parse the string for codes
    //
    TCHAR *pCurrent = _tcstok(valueString, TEXT(","));
    WORD code;
    while (pCurrent)
    {
        code = (WORD) _tcstol(pCurrent, NULL, 0);
        pCodeArray->Add(code);
        pCurrent = _tcstok(NULL, TEXT(","));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\iso15740.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    iso15740.cpp

Abstract:

    This module implements methods used for manipulating PTP structures

Author:

    Dave Parsons

Revision History:


--*/

#include "ptppch.h"
#include <platform.h> // for MAKELONGLONG

//
// This function returns a 2 byte integer from raw data and advances the pointer
//
// Input:
//   ppRaw -- pointer to a pointer to the raw data
//
WORD
ParseWord(BYTE **ppRaw)
{
    WORD w;

    // we know that **ppRaw points to a little-endian word
    w = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
    
    *ppRaw += sizeof(WORD);
    
    return w;
}

//
// This function returns a 4 byte integer from raw data and advances the pointer
//
// Input:
//   ppRaw -- pointer to a pointer to the raw data
//
DWORD
ParseDword(BYTE **ppRaw)
{
    DWORD dw;

    // we know that **ppRaw points to a little-endian dword
    dw = MAKELONG(MAKEWORD((*ppRaw)[0],(*ppRaw)[1]),
                  MAKEWORD((*ppRaw)[2],(*ppRaw)[3]));

    *ppRaw += sizeof(DWORD);

    return dw;
}

//
// This function returns an 8 byte integer from raw data and advances the pointer
//
// Input:
//   ppRaw -- pointer to a pointer to the raw data
//
QWORD
ParseQword(BYTE **ppRaw)
{
    QWORD qw;
    
    // we know that **ppRaw points to a little-endian qword
    qw = MAKELONGLONG(MAKELONG(MAKEWORD((*ppRaw)[0],(*ppRaw)[1]),
                               MAKEWORD((*ppRaw)[2],(*ppRaw)[3])),
                      MAKELONG(MAKEWORD((*ppRaw)[4],(*ppRaw)[5]),
                               MAKEWORD((*ppRaw)[6],(*ppRaw)[7])));

    *ppRaw += sizeof(QWORD);

    return qw;
}

//
// This function writes a 2 byte integer to a raw data buffer and advances the pointer
//
// Input:
//   ppRaw -- pointer to pointer to the raw data
//   value -- value to write
//
VOID
WriteWord(BYTE **ppRaw, WORD value)
{
    (*ppRaw)[0] = LOBYTE(LOWORD(value));
    (*ppRaw)[1] = HIBYTE(LOWORD(value));
    
    *ppRaw += sizeof(WORD);
    
    return;
}

//
// This function writes a 4 byte integer to a raw data buffer and advances the pointer
//
// Input:
//   ppRaw -- pointer to pointer to the raw data
//   value -- value to write
//
VOID
WriteDword(BYTE **ppRaw, DWORD value)
{
    (*ppRaw)[0] = LOBYTE(LOWORD(value));
    (*ppRaw)[1] = HIBYTE(LOWORD(value));
    (*ppRaw)[2] = LOBYTE(HIWORD(value));
    (*ppRaw)[3] = HIBYTE(HIWORD(value));
    
    *ppRaw += sizeof(DWORD);
    
    return;
}

//
// CBstr constructor
//
CBstr::CBstr() :
    m_bstrString(NULL)
{
}

//
// CBstr copy constructor
//
CBstr::CBstr(const CBstr &src)
{
    m_bstrString = SysAllocString(src.m_bstrString);
}

//
// CBstr destructor
//
CBstr::~CBstr()
{
    if (m_bstrString)
        SysFreeString(m_bstrString);
}

//
// Make a copy of a string
//
HRESULT
CBstr::Copy(WCHAR *wcsString)
{
    HRESULT hr = S_OK;

    if (m_bstrString)
    {
        if (!SysReAllocString(&m_bstrString, wcsString))
        {
            wiauDbgError("Copy", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    else
    {
        m_bstrString = SysAllocString(wcsString);
        if (!m_bstrString)
        {
            wiauDbgError("Copy", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    return hr;
}

//
// This function initializes a BSTR from a raw PTP string, clearing
// the BSTR first, if needed
//
// Input:
//   ppRaw -- pointer to pointer to raw data to initialize the string from
//   bParse -- indicates whether to advance the raw pointer or not
//
HRESULT
CBstr::Init(
    BYTE **ppRaw,
    BOOL bParse
    )
{
    HRESULT hr = S_OK;

    //
    // Check arguments
    //
    if (!ppRaw || !*ppRaw)
    {
        wiauDbgError("Init", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Extract the length from the raw data, and set up a more convenient pointer
    // to the string data (skipping over the length byte)
    //
    int length = (UCHAR) **ppRaw;
    OLECHAR *pRaw = (OLECHAR *) (*ppRaw + sizeof(UCHAR));

    if (m_bstrString)
    {
        if (!SysReAllocStringLen(&m_bstrString, pRaw, length))
        {
            wiauDbgError("Init", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    else
    {
        m_bstrString = SysAllocStringLen(pRaw, length);
        if (!m_bstrString)
        {
            wiauDbgError("Init", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    //
    // If requested, advance the raw pointer past the string. One byte for the length and
    // 2 times the number of chars in the wide string.
    //
    if (bParse)
    {
        *ppRaw += sizeof(UCHAR) + length * sizeof(USHORT);
    }

    return hr;
}

//
// This function writes the string to a buffer in PTP format
//
// Input:
//   ppRaw -- pointer to pointer to buffer
//   Length -- amount of space left in the buffer in bytes
//
VOID
CBstr::WriteToBuffer(
    BYTE **ppRaw
    )
{
    UCHAR NumChars = (UCHAR) Length();

    //
    // Add one for null terminating char, but only if string is non-empty
    //
    if (NumChars > 0)
        NumChars++;

    int NumBytes = NumChars * sizeof(WCHAR);

    **ppRaw = NumChars;
    (*ppRaw)++;

    if (NumChars > 0)
    {
        memcpy(*ppRaw, String(), NumBytes);
        *ppRaw += NumBytes;
    }

    return;
}

//
// This function dumps a PTP string to the log
// 
// Input:
//  szDesc -- Description for the string
//
VOID
CBstr::Dump(char *szDesc)
{
    if (m_bstrString && SysStringLen(m_bstrString) > 0)
    {
        wiauDbgDump("", "%s %S", szDesc, m_bstrString);
    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// Dumps the contents of a CArray8 to the log
//
// Input:
//   szDesc -- description for the string
//   szFiller -- filler to use for subsequent lines
//
VOID
CArray8::Dump(
    char *szDesc,
    char *szFiller
    )
{
    int count;
    char szMsg[MAX_PATH], szPart[MAX_PATH];
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Prime output string
        //
        strcpy(szMsg, szDesc);

        //
        // Loop through the elements
        //
        for (count = 0; count < GetSize(); count++)
        {
            //
            // Start a new line every 8 values
            //
            if ((count != 0) && (count % 8 == 0))
            {
                wiauDbgDump("", "%s", szMsg);
                strcpy(szMsg, szFiller);
            }
            sprintf(szPart, " 0x%02x", m_aT[count]);
            strcat(szMsg, szPart);
        }
        wiauDbgDump("", "%s", szMsg);

    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// Dumps the contents of a CArray16 to the log
//
// Input:
//   szDesc -- description for the string
//   szFiller -- filler to use for subsequent lines
//
VOID
CArray16::Dump(
    char *szDesc,
    char *szFiller
    )
{
    int count;
    char szMsg[MAX_PATH], szPart[MAX_PATH];
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Prime output string
        //
        strcpy(szMsg, szDesc);

        //
        // Loop through the elements
        //
        for (count = 0; count < GetSize(); count++)
        {
            //
            // Start a new line every 4 values
            //
            if ((count != 0) && (count % 4 == 0))
            {
                wiauDbgDump("", "%s", szMsg);
                strcpy(szMsg, szFiller);
            }
            sprintf(szPart, " 0x%04x", m_aT[count]);
            strcat(szMsg, szPart);
        }
        wiauDbgDump("", "%s", szMsg);

    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// This function parses a CArray32 from an array of UCHARs
//
BOOL
CArray32::ParseFrom8(
    BYTE **ppRaw,
    int NumSize
    )
{
    if (!ppRaw || !*ppRaw)
        return FALSE;

    RemoveAll();

    // Get the number of elements from the raw data
    ULONG NumElems;
    switch (NumSize)
    {
    case 4:
        NumElems = MAKELONG(MAKEWORD((*ppRaw)[0], (*ppRaw)[1]), MAKEWORD((*ppRaw)[2], (*ppRaw)[3]));
        break;
    case 2:
        NumElems = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
        break;
    case 1:
        NumElems = **ppRaw;
        break;
    default:
        return FALSE;
    }

    *ppRaw += NumSize;

    // Allocate space for the array
    if (!GrowTo(NumElems))
        return FALSE;

    // Copy in the elements, one at a time
    BYTE *pValues = *ppRaw;
    ULONG value = 0;
    for (ULONG count = 0; count < NumElems; count++)
    {
        value = (ULONG) pValues[count];
        if (!Add(value))
            return FALSE;
    }

    // Advance the raw pointer past the array and number of elements field
    *ppRaw += NumElems * sizeof(BYTE);

    return TRUE;
}

//
// This function parses a CArray32 from an array of WORDs
//
BOOL
CArray32::ParseFrom16(
    BYTE **ppRaw,
    int NumSize
    )
{
    if (!ppRaw || !*ppRaw)
        return FALSE;

    RemoveAll();

    // Get the number of elements from the raw data
    ULONG NumElems;
    
    switch (NumSize)
    {
    case 4:
        NumElems = MAKELONG(MAKEWORD((*ppRaw)[0], (*ppRaw)[1]), MAKEWORD((*ppRaw)[2], (*ppRaw)[3]));
        break;
    case 2:
        NumElems = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
        break;
    case 1:
        NumElems = **ppRaw;
        break;
    default:
        return FALSE;
    }

    *ppRaw += NumSize;

    // Allocate space for the array
    if (!GrowTo(NumElems))
        return FALSE;

    // Copy in the elements, one at a time
    ULONG value = 0;
    for (ULONG count = 0; count < NumElems; count++)
    {
        value = (ULONG) MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
        *ppRaw += sizeof(WORD);
        if (!Add(value))
            return FALSE;
    }

    return TRUE;
}

//
// Copies values from an array of bytes
//
BOOL
CArray32::Copy(CArray8 values8)
{
    RemoveAll();

    GrowTo(values8.GetSize());

    for (int count = 0; count < values8.GetSize(); count++)
    {
        ULONG value = values8[count];
        if (!Add(value))
            return FALSE;
    }

    return TRUE;
}

//
// Copies values from an array of bytes
//
BOOL
CArray32::Copy(CArray16 values16)
{
    RemoveAll();

    GrowTo(values16.GetSize());

    for (int count = 0; count < values16.GetSize(); count++)
    {
        ULONG value = values16[count];
        if (!Add(value))
            return FALSE;
    }

    return TRUE;
}

//
// Dumps the contents of a CArray32 to the log
//
// Input:
//  szDesc -- description for the string
//  szFiller -- filler to use for subsequent lines
//
VOID
CArray32::Dump(
    char *szDesc,
    char *szFiller
    )
{
    int count;
    char szMsg[MAX_PATH], szPart[MAX_PATH];
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Prime output string
        //
        strcpy(szMsg, szDesc);

        //
        // Loop through the elements
        //
        for (count = 0; count < GetSize(); count++)
        {
            //
            // Start a new line every 4 values
            //
            if ((count != 0) && (count % 4 == 0))
            {
                wiauDbgDump("", "%s", szMsg);
                strcpy(szMsg, szFiller);
            }
            sprintf(szPart, " 0x%08x", m_aT[count]);
            strcat(szMsg, szPart);
        }
        wiauDbgDump("", "%s", szMsg);

    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// This function initializes a string array from raw data, clearing
// the array first, if needed
//
// Input:
//   ppRaw -- pointer to pointer to raw data to initialize the string from
//   bParse -- indicates whether to advance the raw pointer or not
//
HRESULT
CArrayString::Init(
    BYTE **ppRaw,
    int NumSize
    )
{
    HRESULT hr = S_OK;

    if (!ppRaw || !*ppRaw)
        return E_INVALIDARG;

    RemoveAll();

    // Get the number of elements from the raw data
    int NumElems;
    switch (NumSize)
    {
    case 4:
        NumElems = MAKELONG(MAKEWORD((*ppRaw)[0],(*ppRaw)[1]),
                            MAKEWORD((*ppRaw)[2],(*ppRaw)[3]));
        break;
    case 2:
        NumElems = MAKEWORD((*ppRaw)[0],(*ppRaw)[1]);
        break;
    case 1:
        NumElems = (BYTE) **ppRaw;
        break;
    default:
        return E_FAIL;
    }

    // Allocate space for the array
    if (!GrowTo(NumElems))
        return E_OUTOFMEMORY;

    // Advance past the number of elements field
    *ppRaw += NumSize;

    // Read in each string
    CBstr tempStr;
    for (int count = 0; count < NumElems; count++)
    {
        tempStr.Init(ppRaw, TRUE);
        if (!Add(tempStr))
            return E_FAIL;
    }

    return hr;
}

//
// Dumps the contents of a CArrayString to the log
//
// Input:
//  szDesc -- description for the string
//  szFiller -- filler to use for subsequent lines
//
VOID
CArrayString::Dump(
    char *szDesc,
    char *szFiller
    )
{
    int count;
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Dump first string with description
        //
        m_aT[0].Dump(szDesc);

        //
        // Loop through the elements, dumping with the filler
        //
        for (count = 1; count < GetSize(); count++)
            m_aT[count].Dump(szFiller);
    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// CPtpDeviceInfo constructor
//
CPtpDeviceInfo::CPtpDeviceInfo() :
    m_Version(0),
    m_VendorExtId(0),
    m_VendorExtVersion(0),
    m_FuncMode(0)
{
}

//
// CPtpDeviceInfo destructor
//
CPtpDeviceInfo::~CPtpDeviceInfo()
{
}

//
// This function initializes the device info from raw data
//
// Input:
//   pRawData -- the raw data
//
HRESULT
CPtpDeviceInfo::Init(BYTE *pRawData)
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_Version = ParseWord(&pCurrent);
    m_VendorExtId = ParseDword(&pCurrent);
    m_VendorExtVersion = ParseWord(&pCurrent);

    hr = m_cbstrVendorExtDesc.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    m_FuncMode = ParseWord(&pCurrent);

    if (!m_SupportedOps.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedEvents.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedProps.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedCaptureFmts.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedImageFmts.Parse(&pCurrent))
        return E_FAIL;

    hr = m_cbstrManufacturer.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrModel.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrDeviceVersion.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrSerialNumber.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    return hr;
}

//
// This function dumps the device information to the log
//
VOID
CPtpDeviceInfo::Dump()
{
    wiauDbgDump("", "DumpDeviceInfo, dumping DeviceInfo:");
    wiauDbgDump("", "  Standard version  = 0x%04x", m_Version);
    wiauDbgDump("", "  Vendor ext id     = 0x%08x", m_VendorExtId);
    wiauDbgDump("", "  Vendor ext ver    = 0x%04x", m_VendorExtVersion);

    m_cbstrVendorExtDesc.Dump(   "  Vendor ext desc   =");
    
    m_SupportedOps.Dump(         "  Ops supported     =", "                     ");
    m_SupportedEvents.Dump(      "  Events supported  =", "                     ");
    m_SupportedProps.Dump(       "  Props supported   =", "                     ");
    m_SupportedCaptureFmts.Dump( "  Capture fmts supp =", "                     ");
    m_SupportedImageFmts.Dump(   "  Img formats supp  =", "                     ");

    m_cbstrManufacturer.Dump(    "  Manufacturer      =");
    m_cbstrModel.Dump(           "  Model             =");
    m_cbstrDeviceVersion.Dump(   "  Device Version    =");
    m_cbstrSerialNumber.Dump(    "  Serial Number     =");

    return;
}

//
// CPtpStorageInfo constructor
//
CPtpStorageInfo::CPtpStorageInfo() :
    m_StorageId(0),
    m_StorageType(0),           
    m_FileSystemType(0),    
    m_AccessCapability(0),  
    m_MaxCapacity(0),       
    m_FreeSpaceInBytes(0),  
    m_FreeSpaceInImages(0)
{
}

//
// CPtpStorageInfo destructor
//
CPtpStorageInfo::~CPtpStorageInfo()
{
}

//
// This function initializes the device info from raw data
//
// Input:
//   pRawData -- the raw data
//
HRESULT
CPtpStorageInfo::Init(
    BYTE *pRawData,
    DWORD StorageId
    )
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_StorageId = StorageId;

    m_StorageType = ParseWord(&pCurrent);
    m_FileSystemType = ParseWord(&pCurrent);
    m_AccessCapability = ParseWord(&pCurrent);
    m_MaxCapacity = ParseQword(&pCurrent);
    m_FreeSpaceInBytes = ParseQword(&pCurrent);
    m_FreeSpaceInImages = ParseDword(&pCurrent);

    hr = m_cbstrStorageDesc.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrStorageLabel.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    return hr;
}

//
// This function dumps the storage information to the log
//
VOID
CPtpStorageInfo::Dump()
{
    wiauDbgDump("", "DumpStorageInfo, dumping StorageInfo for store 0x%08x:", m_StorageId);
    
    
    wiauDbgDump("", "  Storage type      = 0x%04x", m_StorageType);
    wiauDbgDump("", "  File system type  = 0x%04x", m_FileSystemType);
    wiauDbgDump("", "  Access capability = 0x%04x", m_AccessCapability);
    wiauDbgDump("", "  Max capacity      = %I64u", m_MaxCapacity);
    wiauDbgDump("", "  Free space (byte) = %I64u", m_FreeSpaceInBytes);
    wiauDbgDump("", "  Free space (imgs) = %u", m_FreeSpaceInImages);

    m_cbstrStorageDesc.Dump(  "  Storage desc      =");
    m_cbstrStorageLabel.Dump( "  Storage label     =");

    return;
}

//
// CPtpObjectInfo constructor
//
CPtpObjectInfo::CPtpObjectInfo() :
    m_ObjectHandle(0),
    m_StorageId(0),           
    m_FormatCode(0),          
    m_ProtectionStatus(0),    
    m_CompressedSize(0),      
    m_ThumbFormat(0),         
    m_ThumbCompressedSize(0), 
    m_ThumbPixWidth(0),       
    m_ThumbPixHeight(0),      
    m_ImagePixWidth(0),       
    m_ImagePixHeight(0),      
    m_ImageBitDepth(0),       
    m_ParentHandle(0),        
    m_AssociationType(0),     
    m_AssociationDesc(0),     
    m_SequenceNumber(0)      
{
}

//
// CPtpObjectInfo destructor
//
CPtpObjectInfo::~CPtpObjectInfo()
{
}

//
// This function initializes the object info from raw data
//
// Input:
//   pRawData -- the raw data
//   ObjectHandle -- the object's handle
//
HRESULT
CPtpObjectInfo::Init(
    BYTE *pRawData,
    DWORD ObjectHandle
    )
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_ObjectHandle = ObjectHandle;

    m_StorageId = ParseDword(&pCurrent);
    m_FormatCode = ParseWord(&pCurrent);
    m_ProtectionStatus = ParseWord(&pCurrent);
    m_CompressedSize = ParseDword(&pCurrent);
    m_ThumbFormat = ParseWord(&pCurrent);
    m_ThumbCompressedSize = ParseDword(&pCurrent);
    m_ThumbPixWidth = ParseDword(&pCurrent);
    m_ThumbPixHeight = ParseDword(&pCurrent);
    m_ImagePixWidth = ParseDword(&pCurrent);
    m_ImagePixHeight = ParseDword(&pCurrent);
    m_ImageBitDepth = ParseDword(&pCurrent);
    m_ParentHandle = ParseDword(&pCurrent);
    m_AssociationType = ParseWord(&pCurrent);
    m_AssociationDesc = ParseDword(&pCurrent);
    m_SequenceNumber = ParseDword(&pCurrent);

    hr = m_cbstrFileName.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrCaptureDate.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrModificationDate.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrKeywords.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    return hr;
}

//
// This function writes the ObjectInfo structure to a buffer in PTP format
//
// Input:
//   ppRaw -- pointer to pointer to buffer
//   Length -- amount of space left in the buffer in bytes
//
VOID
CPtpObjectInfo::WriteToBuffer(
    BYTE **ppRaw
    )
{
    WriteDword(ppRaw, m_StorageId);
    WriteWord(ppRaw, m_FormatCode);
    WriteWord(ppRaw, m_ProtectionStatus);
    WriteDword(ppRaw, m_CompressedSize);
    WriteWord(ppRaw, m_ThumbFormat);
    WriteDword(ppRaw, m_ThumbCompressedSize);
    WriteDword(ppRaw, m_ThumbPixWidth);
    WriteDword(ppRaw, m_ThumbPixHeight);
    WriteDword(ppRaw, m_ImagePixWidth);
    WriteDword(ppRaw, m_ImagePixHeight);
    WriteDword(ppRaw, m_ImageBitDepth);
    WriteDword(ppRaw, m_ParentHandle);
    WriteWord(ppRaw, m_AssociationType);
    WriteDword(ppRaw, m_AssociationDesc);
    WriteDword(ppRaw, m_SequenceNumber);
    m_cbstrFileName.WriteToBuffer(ppRaw);
    m_cbstrCaptureDate.WriteToBuffer(ppRaw);
    m_cbstrModificationDate.WriteToBuffer(ppRaw);
    m_cbstrKeywords.WriteToBuffer(ppRaw);

    return;
}


//
// This function dumps the object information to the log
//
VOID
CPtpObjectInfo::Dump()
{
    wiauDbgDump("", "DumpObjectInfo, dumping ObjectInfo for object 0x%08x:", m_ObjectHandle);
    wiauDbgDump("", "  Storage id        = 0x%08x", m_StorageId);
    wiauDbgDump("", "  Format code       = 0x%04x", m_FormatCode);
    wiauDbgDump("", "  Protection status = 0x%04x", m_ProtectionStatus);
    wiauDbgDump("", "  Compressed size   = %u", m_CompressedSize);
    wiauDbgDump("", "  Thumbnail format  = 0x%04x", m_ThumbFormat);
    wiauDbgDump("", "  Thumbnail size    = %u", m_ThumbCompressedSize);
    wiauDbgDump("", "  Thumbnail width   = %u", m_ThumbPixWidth);
    wiauDbgDump("", "  Thumbnail height  = %u", m_ThumbPixHeight);
    wiauDbgDump("", "  Image width       = %u", m_ImagePixWidth);
    wiauDbgDump("", "  Image height      = %u", m_ImagePixHeight);
    wiauDbgDump("", "  Image bit depth   = %u", m_ImageBitDepth);
    wiauDbgDump("", "  Parent obj handle = 0x%08x", m_ParentHandle);
    wiauDbgDump("", "  Association type  = 0x%04x", m_AssociationType);
    wiauDbgDump("", "  Association desc  = 0x%08x", m_AssociationDesc);
    wiauDbgDump("", "  Sequence number   = %u", m_SequenceNumber);

    m_cbstrFileName.Dump(         "  File name         =");
    m_cbstrCaptureDate.Dump(      "  Capture date      =");
    m_cbstrModificationDate.Dump( "  Modification date =");
    m_cbstrKeywords.Dump(         "  Keywords          =");

    return;
}

//
// CPtpPropDesc constructor
//
CPtpPropDesc::CPtpPropDesc() :
    m_PropCode(0),
    m_DataType(0),
    m_GetSet(0),
    m_FormFlag(0),
    m_NumValues(0),
    m_lDefault(0),
    m_lCurrent(0),
    m_lRangeMin(0),
    m_lRangeMax(0),
    m_lRangeStep(0)
{
}

//
// CPtpPropDesc destructor
//
CPtpPropDesc::~CPtpPropDesc()
{
}

//
// This function initializes a CPtpPropDesc from raw data
//
// Input:
//   pRawData -- pointer to the raw data
//
HRESULT
CPtpPropDesc::Init(BYTE *pRawData)
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_PropCode = ParseWord(&pCurrent);
    m_DataType = ParseWord(&pCurrent);
    m_GetSet = *pCurrent++;

    switch (m_DataType)
    {
    case PTP_DATATYPE_INT8:
    case PTP_DATATYPE_UINT8:
        m_lDefault = *pCurrent++;
        m_lCurrent = *pCurrent++;
        break;
    case PTP_DATATYPE_INT16:
    case PTP_DATATYPE_UINT16:
        m_lDefault = ParseWord(&pCurrent);
        m_lCurrent = ParseWord(&pCurrent);
        break;
    case PTP_DATATYPE_INT32:
    case PTP_DATATYPE_UINT32:
        m_lDefault = ParseDword(&pCurrent);
        m_lCurrent = ParseDword(&pCurrent);
        break;
    case PTP_DATATYPE_STRING:
        hr = m_cbstrDefault.Init(&pCurrent, TRUE);
        if (FAILED(hr)) return hr;
        hr = m_cbstrCurrent.Init(&pCurrent, TRUE);
        if (FAILED(hr)) return hr;
        break;
    default:
        return E_FAIL;
    }

    m_FormFlag = *pCurrent++;

    if (m_FormFlag == PTP_FORMFLAGS_RANGE)
    {
        switch (m_DataType)
        {
        case PTP_DATATYPE_INT8:
        case PTP_DATATYPE_UINT8:
            m_lRangeMin = *pCurrent++;
            m_lRangeMax = *pCurrent++;
            m_lRangeStep = *pCurrent++;
            m_lRangeStep = max(1, m_lRangeStep);
            break;
        case PTP_DATATYPE_INT16:
        case PTP_DATATYPE_UINT16:
            m_lRangeMin = ParseWord(&pCurrent);
            m_lRangeMax = ParseWord(&pCurrent);
            m_lRangeStep = ParseWord(&pCurrent);
            m_lRangeStep = max(1, m_lRangeStep);
            break;
        case PTP_DATATYPE_INT32:
        case PTP_DATATYPE_UINT32:
            m_lRangeMin = ParseDword(&pCurrent);
            m_lRangeMax = ParseDword(&pCurrent);
            m_lRangeStep = ParseDword(&pCurrent);
            m_lRangeStep = max(1, m_lRangeStep);
            break;
        case PTP_DATATYPE_STRING:
            hr = m_cbstrRangeMin.Init(&pCurrent, TRUE);
            if (FAILED(hr)) return hr;
            hr = m_cbstrRangeMax.Init(&pCurrent, TRUE);
            if (FAILED(hr)) return hr;
            hr = m_cbstrRangeStep.Init(&pCurrent, TRUE);
            if (FAILED(hr)) return hr;
            break;
        default:
            return E_FAIL;
        }
    }

    else if (m_FormFlag == PTP_FORMFLAGS_ENUM)
    {
        switch (m_DataType)
        {
        case PTP_DATATYPE_INT8:
        case PTP_DATATYPE_UINT8:
            if (!m_lValues.ParseFrom8(&pCurrent, 2))
                return E_FAIL;
            break;
        case PTP_DATATYPE_INT16:
        case PTP_DATATYPE_UINT16:
            if (!m_lValues.ParseFrom16(&pCurrent, 2))
                return E_FAIL;
            break;
        case PTP_DATATYPE_INT32:
        case PTP_DATATYPE_UINT32:
            if (!m_lValues.Parse(&pCurrent, 2))
                return E_FAIL;
            break;
        case PTP_DATATYPE_STRING:
            hr = m_cbstrValues.Init(&pCurrent, 2);
            if (FAILED(hr)) return hr;
            break;
        default:
            return E_FAIL;
        }

        m_NumValues = max(m_lValues.GetSize(), m_cbstrValues.GetSize());

    }

    return hr;
}

//
// This function sets the current value of a CPtpPropDesc from raw data
//
// Input:
//   pRaw -- pointer to the raw data
//
HRESULT
CPtpPropDesc::ParseValue(BYTE *pRaw)
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRaw;

    switch (m_DataType)
    {
    case PTP_DATATYPE_INT8:
    case PTP_DATATYPE_UINT8:
        m_lCurrent = *pCurrent++;
        break;
    case PTP_DATATYPE_INT16:
    case PTP_DATATYPE_UINT16:
        m_lCurrent = ParseWord(&pCurrent);
        break;
    case PTP_DATATYPE_INT32:
    case PTP_DATATYPE_UINT32:
        m_lCurrent = ParseDword(&pCurrent);
        break;
    case PTP_DATATYPE_STRING:
        hr = m_cbstrCurrent.Init(&pCurrent, TRUE);
        break;
    default:
        return E_FAIL;
    }

    return hr;
}

//
// This function writes the current value of a CPtpPropDesc to a raw buffer
//
// Input:
//   ppRaw -- pointer to pointer to a raw buffer
//
VOID
CPtpPropDesc::WriteValue(BYTE **ppRaw)
{
    switch (m_DataType)
    {
    case PTP_DATATYPE_INT8:
    case PTP_DATATYPE_UINT8:
        **ppRaw = (BYTE) m_lCurrent;
        (*ppRaw)++;
        break;
    case PTP_DATATYPE_INT16:
    case PTP_DATATYPE_UINT16:
        WriteWord(ppRaw, (WORD) m_lCurrent);
        break;
    case PTP_DATATYPE_INT32:
    case PTP_DATATYPE_UINT32:
        WriteDword(ppRaw, m_lCurrent);
        break;
    case PTP_DATATYPE_STRING:
        m_cbstrCurrent.WriteToBuffer(ppRaw);
        break;
    }

    return;
}

//
// This function dumps the property description information to the log
//
VOID
CPtpPropDesc::Dump()
{
    wiauDbgDump("", "CPtpPropDesc::Dump, dumping PropDesc for property 0x%04x:", m_PropCode);
    wiauDbgDump("", "  Data type         = 0x%04x", m_DataType);
    wiauDbgDump("", "  GetSet            = 0x%02x", m_GetSet);

    if (m_DataType == PTP_DATATYPE_STRING)
    {
        m_cbstrDefault.Dump("  Default           =");
        m_cbstrCurrent.Dump("  Current           =");
        wiauDbgDump("", "  Form flag         = 0x%02x", m_FormFlag);

        switch (m_FormFlag)
        {
        case PTP_FORMFLAGS_RANGE:
            m_cbstrRangeMin.Dump("  Range min         =");
            m_cbstrRangeMax.Dump("  Range max         =");
            m_cbstrRangeStep.Dump("  Range step        =");
            break;
        case PTP_FORMFLAGS_ENUM:
            m_cbstrValues.Dump("  Valid values      =", "                     ");
            break;
        default:
            wiauDbgDump("", "  <unknown valid value type>");
        }
    }

    else
    {
        wiauDbgDump("", "  Default           = 0x%08x", m_lDefault);
        wiauDbgDump("", "  Current           = 0x%08x", m_lCurrent);
        wiauDbgDump("", "  Form flag         = 0x%02x", m_FormFlag);

        switch (m_FormFlag)
        {
        case PTP_FORMFLAGS_RANGE:
            wiauDbgDump("", "  Range min         = 0x%08x", m_lRangeMin);
            wiauDbgDump("", "  Range max         = 0x%08x", m_lRangeMax);
            wiauDbgDump("", "  Range step        = 0x%08x", m_lRangeStep);
            break;
        case PTP_FORMFLAGS_ENUM:
            m_lValues.Dump("  Valid values      =", "                     ");
            break;
        default:
            wiauDbgDump("", "  <unknown valid value type>");
        }
    }

    return;
}

//
// This function dumps the property value to the log
//
VOID
CPtpPropDesc::DumpValue()
{
    wiauDbgDump("", "CPtpPropDescDumpValue, current value for property 0x%04x:", m_PropCode);

    if (m_DataType == PTP_DATATYPE_STRING)
        m_cbstrCurrent.Dump("  Current           =");

    else
        wiauDbgDump("", "  Current           = 0x%08x", m_lCurrent);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\iso15740.h ===
/*++
Copyright (c) 1999- Microsoft Corporation

Module Name:

    ISO15740.h

Abstract:
    This module contains PIMA15740 defined data types and their predefined
    values(if there are any).

Revision History:

--*/

#ifndef ISO15740__H_
#define ISO15740__H_

//
// This is PTP_STRING maximum string length in characters.
//
const UINT32 PTP_MAXSTRINGSIZE = 255;

//
// Define QWORD type
//
typedef unsigned __int64 QWORD;

//
// Every structure must be packed on byte boundary
//
#pragma pack(push,Old,1)
//
// Define 128 bits integer and unsigned integer
// This will be the base type of INT128 and UINT128
//
typedef struct tagInt128
{
    unsigned __int64 LowPart;
         __int64 HighPart;
}INT128, *PINT128;

typedef struct tagUInt128
{
    unsigned __int64 LowPart;
    unsigned __int64 HighPart;
}UINT128, *PUINT128;

//
// Data code ranges and masks. Each data code has 16 bits:
//
// Bit 15(std/vendor)
//    0 -- the code is defined by PTP standard
//    1 -- the code is vendor specific
//
// Bit 14 - 12(data type)
//   14 13 12
//   0  0  0    -- undefined data type
//   0  0  1    -- op code
//   0  1  0    -- response code
//   0  1  1    -- format code
//   1  0  0    -- event code
//   1  0  1    -- property code
//   1  1  0    -- reserved
//   1  1  1    -- reserved
//
// Bit 11 - bit 0 (data value)
//
const WORD  PTP_DATACODE_VENDORMASK         = 0x8000;
const WORD  PTP_DATACODE_TYPEMASK           = 0x7000;
const WORD  PTP_DATACODE_VALUEMASK          = 0x0FFF;
const WORD  PTP_DATACODE_TYPE_UNKNOWN       = 0x0000;
const WORD  PTP_DATACODE_TYPE_OPERATION     = 0x1000;
const WORD  PTP_DATACODE_TYPE_RESPONSE      = 0x2000;
const WORD  PTP_DATACODE_TYPE_FORMAT        = 0x3000;
const WORD  PTP_DATACODE_TYPE_EVENT         = 0x4000;
const WORD  PTP_DATACODE_TYPE_PROPERTY      = 0x5000;
const WORD  PTP_DATACODE_TYPE_RESERVED_1    = 0x6000;
const WORD  PTP_DATACODE_TYPE_RESERVED_2    = 0x7000;
//
// To verify an op code
//  (Code & PTP_DATACODE_TYPEMASK) == PTP_DATACODE_TYPE_OPERATION
// To verify a response code
//  (Code & PTP_DATACODE_TYPEMASK) == PTP_DATACODE_TYPE_RESPONSE)

//
// Image format codes receive special treatment.
//
const WORD  PTP_DATACODE_TYPEIMAGEMASK      = 0x7800;
const WORD  PTP_DATACODE_TYPE_IMAGEFORMAT   = 0x3800;
const WORD  PTP_DATACODE_VALUE_IMAGEVMASK   = 0x07FF;
// To verify an image code
// (Code & PTP_DATACODE_TYPEIMAGEMASK) == PTP_DATACODE_TYPE_IMAGEFORMAT
//

//
// PTP specially defined constants
//
const DWORD PTP_OBJECTHANDLE_ALL        = 0x0;
const DWORD PTP_OBJECTHANDLE_UNDEFINED  = 0x0;
const DWORD PTP_OBJECTHANDLE_ROOT       = 0xFFFFFFFF;
const DWORD PTP_STORAGEID_ALL           = 0xFFFFFFFF;
const DWORD PTP_STORAGEID_DEFAULT       = 0;
const DWORD PTP_STORAGEID_UNDEFINED     = 0;
const DWORD PTP_STORAGEID_PHYSICAL      = 0xFFFF0000;
const DWORD PTP_STORAGEID_LOGICAL       = 0x0000FFFF;
const DWORD PTP_SESSIONID_ALL           = 0;
const DWORD PTP_SESSIONID_NOSESSION     = 0;
const WORD  PTP_FORMATCODE_IMAGE        = 0xFFFF;
const WORD  PTP_FORMATCODE_ALL          = 0x0000;
const WORD  PTP_FORMATCODE_DEFAULT      = 0x0000;
const DWORD PTP_TRANSACTIONID_ALL       = 0xFFFFFFFF;
const DWORD PTP_TRANSACTIONID_NOSESSION = 0;
const DWORD PTP_TRANSACTIONID_MIN       = 1;
const DWORD PTP_TRANSACTIONID_MAX       = 0xFFFFFFFE;

//
// Data type codes.
//
const WORD PTP_DATATYPE_UNDEFINED   = 0x0000;
const WORD PTP_DATATYPE_INT8        = 0x0001;
const WORD PTP_DATATYPE_UINT8       = 0x0002;
const WORD PTP_DATATYPE_INT16       = 0x0003;
const WORD PTP_DATATYPE_UINT16      = 0x0004;
const WORD PTP_DATATYPE_INT32       = 0x0005;
const WORD PTP_DATATYPE_UINT32      = 0x0006;
const WORD PTP_DATATYPE_INT64       = 0x0007;
const WORD PTP_DATATYPE_UINT64      = 0x0008;
const WORD PTP_DATATYPE_INT128      = 0x0009;
const WORD PTP_DATATYPE_UINT128     = 0x000A;
const WORD PTP_DATATYPE_STRING      = 0xFFFF;


//
// standard operation codes
//
const WORD PTP_OPCODE_UNDEFINED             = 0x1000;
const WORD PTP_OPCODE_GETDEVICEINFO         = 0x1001;
const WORD PTP_OPCODE_OPENSESSION           = 0x1002;
const WORD PTP_OPCODE_CLOSESESSION          = 0x1003;
const WORD PTP_OPCODE_GETSTORAGEIDS         = 0x1004;
const WORD PTP_OPCODE_GETSTORAGEINFO        = 0x1005;
const WORD PTP_OPCODE_GETNUMOBJECTS         = 0x1006;
const WORD PTP_OPCODE_GETOBJECTHANDLES      = 0x1007;
const WORD PTP_OPCODE_GETOBJECTINFO         = 0x1008;
const WORD PTP_OPCODE_GETOBJECT             = 0x1009;
const WORD PTP_OPCODE_GETTHUMB              = 0x100A;
const WORD PTP_OPCODE_DELETEOBJECT          = 0x100B;
const WORD PTP_OPCODE_SENDOBJECTINFO        = 0x100C;
const WORD PTP_OPCODE_SENDOBJECT            = 0x100D;
const WORD PTP_OPCODE_INITIATECAPTURE       = 0x100E;
const WORD PTP_OPCODE_FORMATSTORE           = 0x100F;
const WORD PTP_OPCODE_RESETDEVICE           = 0x1010;
const WORD PTP_OPCODE_SELFTEST              = 0x1011;
const WORD PTP_OPCODE_SETOBJECTPROTECTION   = 0x1012;
const WORD PTP_OPCODE_POWERDOWN             = 0x1013;
const WORD PTP_OPCODE_GETDEVICEPROPDESC     = 0x1014;
const WORD PTP_OPCODE_GETDEVICEPROPVALUE    = 0x1015;
const WORD PTP_OPCODE_SETDEVICEPROPVALUE    = 0x1016;
const WORD PTP_OPCODE_RESETDEVICEPROPVALUE  = 0x1017;
const WORD PTP_OPCODE_TERMINATECAPTURE      = 0x1018;
const WORD PTP_OPCODE_MOVEOBJECT            = 0x1019;
const WORD PTP_OPCODE_COPYOBJECT            = 0x101A;
const WORD PTP_OPCODE_GETPARTIALOBJECT      = 0x101B;
const WORD PTP_OPCODE_INITIATEOPENCAPTURE   = 0x101C;

//
// standard event codes
//
const WORD PTP_EVENTCODE_UNDEFINED              = 0x4000;
const WORD PTP_EVENTCODE_CANCELTRANSACTION      = 0x4001;
const WORD PTP_EVENTCODE_OBJECTADDED            = 0x4002;
const WORD PTP_EVENTCODE_OBJECTREMOVED          = 0x4003;
const WORD PTP_EVENTCODE_STOREADDED             = 0x4004;
const WORD PTP_EVENTCODE_STOREREMOVED           = 0x4005;
const WORD PTP_EVENTCODE_DEVICEPROPCHANGED      = 0x4006;
const WORD PTP_EVENTCODE_OBJECTINFOCHANGED      = 0x4007;
const WORD PTP_EVENTCODE_DEVICEINFOCHANGED      = 0x4008;
const WORD PTP_EVENTCODE_REQUESTOBJECTTRANSFER  = 0x4009;
const WORD PTP_EVENTCODE_STOREFULL              = 0x400A;
const WORD PTP_EVENTCODE_DEVICERESET            = 0x400B;
const WORD PTP_EVENTCODE_STORAGEINFOCHANGED     = 0x400C;
const WORD PTP_EVENTCODE_CAPTURECOMPLETE        = 0x400D;
const WORD PTP_EVENTCODE_UNREPORTEDSTATUS       = 0x400E;
const WORD PTP_EVENTCODE_VENDOREXTENTION        = 0xC000;

//
// standard response codes
//
const WORD PTP_RESPONSECODE_UNDEFINED                   = 0x2000;
const WORD PTP_RESPONSECODE_OK                          = 0x2001;
const WORD PTP_RESPONSECODE_GENERALERROR                = 0x2002;
const WORD PTP_RESPONSECODE_SESSIONNOTOPEN              = 0x2003;
const WORD PTP_RESPONSECODE_INVALIDTRANSACTIONID        = 0x2004;
const WORD PTP_RESPONSECODE_OPERATIONNOTSUPPORTED       = 0x2005;
const WORD PTP_RESPONSECODE_PARAMETERNOTSUPPORTED       = 0x2006;
const WORD PTP_RESPONSECODE_INCOMPLETETRANSFER          = 0x2007;
const WORD PTP_RESPONSECODE_INVALIDSTORAGEID            = 0x2008;
const WORD PTP_RESPONSECODE_INVALIDOBJECTHANDLE         = 0x2009;
const WORD PTP_RESPONSECODE_INVALIDPROPERTYCODE         = 0x200A;
const WORD PTP_RESPONSECODE_INVALIDOBJECTFORMATCODE     = 0x200B;
const WORD PTP_RESPONSECODE_STOREFULL                   = 0x200C;
const WORD PTP_RESPONSECODE_OBJECTWRITEPROTECTED        = 0x200D;
const WORD PTP_RESPONSECODE_STOREWRITEPROTECTED         = 0x200E;
const WORD PTP_RESPONSECODE_ACCESSDENIED                = 0x200F;
const WORD PTP_RESPONSECODE_NOTHUMBNAILPRESENT          = 0x2010;
const WORD PTP_RESPONSECODE_SELFTESTFAILED              = 0x2011;
const WORD PTP_RESPONSECODE_PARTIALDELETION             = 0x2012;
const WORD PTP_RESPONSECODE_STORENOTAVAILABLE           = 0x2013;
const WORD PTP_RESPONSECODE_NOSPECIFICATIONBYFORMAT     = 0x2014;
const WORD PTP_RESPONSECODE_NOVALIDOBJECTINFO           = 0x2015;
const WORD PTP_RESPONSECODE_INVALIDCODEFORMAT           = 0x2016;
const WORD PTP_RESPONSECODE_UNKNOWNVENDORCODE           = 0x2017;
const WORD PTP_RESPONSECODE_CAPTUREALREADYTERMINATED    = 0x2018;
const WORD PTP_RESPONSECODE_DEVICEBUSY                  = 0x2019;
const WORD PTP_RESPONSECODE_INVALIDPARENT               = 0x201A;
const WORD PTP_RESPONSECODE_INVALIDPROPFORMAT           = 0x201B;
const WORD PTP_RESPONSECODE_INVALIDPROPVALUE            = 0x201C;
const WORD PTP_RESPONSECODE_INVALIDPARAMETER            = 0x201D;
const WORD PTP_RESPONSECODE_SESSIONALREADYOPENED        = 0x201E;
const WORD PTP_RESPONSECODE_TRANSACTIONCANCELLED        = 0x201F;

//
// offset for returning PTP response codes in an HRESULT
//
const HRESULT PTP_E_BASEERROR = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0);
#define HRESULT_FROM_PTP(x) (PTP_E_BASEERROR | (HRESULT) (x))


//
// standard property codes
//
const WORD PTP_PROPERTYCODE_UNDEFINED               = 0x5000;
const WORD PTP_PROPERTYCODE_BATTERYLEVEL            = 0x5001;
const WORD PTP_PROPERTYCODE_FUNCTIONMODE            = 0x5002;
const WORD PTP_PROPERTYCODE_IMAGESIZE               = 0x5003;
const WORD PTP_PROPERTYCODE_COMPRESSIONSETTING      = 0x5004;
const WORD PTP_PROPERTYCODE_WHITEBALANCE            = 0x5005;
const WORD PTP_PROPERTYCODE_RGBGAIN                 = 0x5006;
const WORD PTP_PROPERTYCODE_FNUMBER                 = 0x5007;
const WORD PTP_PROPERTYCODE_FOCALLENGTH             = 0x5008;
const WORD PTP_PROPERTYCODE_FOCUSDISTANCE           = 0x5009;
const WORD PTP_PROPERTYCODE_FOCUSMODE               = 0x500A;
const WORD PTP_PROPERTYCODE_EXPOSUREMETERINGMODE    = 0x500B;
const WORD PTP_PROPERTYCODE_FLASHMODE               = 0x500C;
const WORD PTP_PROPERTYCODE_EXPOSURETIME            = 0x500D;
const WORD PTP_PROPERTYCODE_EXPOSUREPROGRAMMODE     = 0x500E;
const WORD PTP_PROPERTYCODE_EXPOSUREINDEX           = 0x500F;
const WORD PTP_PROPERTYCODE_EXPOSURECOMPENSATION    = 0x5010;
const WORD PTP_PROPERTYCODE_DATETIME                = 0x5011;
const WORD PTP_PROPERTYCODE_CAPTUREDELAY            = 0x5012;
const WORD PTP_PROPERTYCODE_STILLCAPTUREMODE        = 0x5013;
const WORD PTP_PROPERTYCODE_CONTRAST                = 0x5014;
const WORD PTP_PROPERTYCODE_SHARPNESS               = 0x5015;
const WORD PTP_PROPERTYCODE_DIGITALZOOM             = 0x5016;
const WORD PTP_PROPERTYCODE_EFFECTMODE              = 0x5017;
const WORD PTP_PROPERTYCODE_BURSTNUMBER             = 0x5018;
const WORD PTP_PROPERTYCODE_BURSTINTERVAL           = 0x5019;
const WORD PTP_PROPERTYCODE_TIMELAPSENUMBER         = 0x501A;
const WORD PTP_PROPERTYCODE_TIMELAPSEINTERVAL       = 0x501B;
const WORD PTP_PROPERTYCODE_FOCUSMETERINGMODE       = 0x501C;


//
// standard format codes
//
const WORD  PTP_FORMATMASK_IMAGE        = 0x0800;

const WORD  PTP_FORMATCODE_NOTUSED      = 0x0000;
const WORD  PTP_FORMATCODE_ALLIMAGES    = 0xFFFF;
const WORD  PTP_FORMATCODE_UNDEFINED    = 0x3000;
const WORD  PTP_FORMATCODE_ASSOCIATION  = 0x3001;
const WORD  PTP_FORMATCODE_SCRIPT       = 0x3002;
const WORD  PTP_FORMATCODE_EXECUTABLE   = 0x3003;
const WORD  PTP_FORMATCODE_TEXT         = 0x3004;
const WORD  PTP_FORMATCODE_HTML         = 0x3005;
const WORD  PTP_FORMATCODE_DPOF         = 0x3006;
const WORD  PTP_FORMATCODE_AIFF         = 0x3007;
const WORD  PTP_FORMATCODE_WAVE         = 0x3008;
const WORD  PTP_FORMATCODE_MP3          = 0x3009;
const WORD  PTP_FORMATCODE_AVI          = 0x300A;
const WORD  PTP_FORMATCODE_MPEG         = 0x300B;

const WORD  PTP_FORMATCODE_IMAGE_UNDEFINED  = 0x3800;
const WORD  PTP_FORMATCODE_IMAGE_EXIF       = 0x3801;
const WORD  PTP_FORMATCODE_IMAGE_TIFFEP     = 0x3802;
const WORD  PTP_FORMATCODE_IMAGE_FLASHPIX   = 0x3803;
const WORD  PTP_FORMATCODE_IMAGE_BMP        = 0x3804;
const WORD  PTP_FORMATCODE_IMAGE_CIFF       = 0x3805;
const WORD  PTP_FORMATCODE_IMAGE_GIF        = 0x3807;
const WORD  PTP_FORMATCODE_IMAGE_JFIF       = 0x3808;
const WORD  PTP_FORMATCODE_IMAGE_PCD        = 0x3809;
const WORD  PTP_FORMATCODE_IMAGE_PICT       = 0x380A;
const WORD  PTP_FORMATCODE_IMAGE_PNG        = 0x380B;
const WORD  PTP_FORMATCODE_IMAGE_TIFF       = 0x380D;
const WORD  PTP_FORMATCODE_IMAGE_TIFFIT     = 0x380E;
const WORD  PTP_FORMATCODE_IMAGE_JP2        = 0x380F;
const WORD  PTP_FORMATCODE_IMAGE_JPX        = 0x3810;

//
// Property values definitions
//

//
// Property description data set form flags definitions
//
const BYTE PTP_FORMFLAGS_NONE      = 0;
const BYTE PTP_FORMFLAGS_RANGE     = 1;
const BYTE PTP_FORMFLAGS_ENUM      = 2;

//
// power states
//
const WORD PTP_POWERSTATE_DEVICEOFF   = 0x0000;
const WORD PTP_POWERSTATE_SLEEP       = 0x0001;
const WORD PTP_POWERSTATE_FULL        = 0x0002;


//
// white balances
//
const WORD PTP_WHITEBALANCE_UNDEFINED   = 0x0000;
const WORD PTP_WHILEBALANCE_MANUAL      = 0x0001;
const WORD PTP_WHITEBALANCE_AUTOMATIC   = 0x0002;
const WORD PTP_WHITEBALANCE_ONEPUSHAUTO = 0x0003;
const WORD PTP_WHITEBALANCE_DAYLIGHT    = 0x0004;
const WORD PTP_WHITEBALANCE_FLORESCENT  = 0x0005;
const WORD PTP_WHITEBALANCE_TUNGSTEN    = 0x0006;
const WORD PTP_WHITEBALANCE_FLASH       = 0x0007;


//
// focus modes
//
const WORD PTP_FOCUSMODE_UNDEFINED = 0x0000;
const WORD PTP_FOCUSMODE_MANUAL    = 0x0001;
const WORD PTP_FOCUSMODE_AUTO      = 0x0002;
const WORD PTP_FOCUSMODE_MACRO     = 0x0003;

//
// focus metering
//
const WORD  PTP_FOCUSMETERING_UNDEFINED    = 0x0000;
const WORD  PTP_FOCUSMETERING_CENTERSPOT   = 0x0001;
const WORD  PTP_FOCUSMETERING_MULTISPOT    = 0x0002;

//
// flash modes
//
const WORD PTP_FLASHMODE_UNDEFINED     = 0x0000;
const WORD PTP_FLASHMODE_AUTO          = 0x0001;
const WORD PTP_FLASHMODE_OFF           = 0x0002;
const WORD PTP_FLASHMODE_FILL          = 0x0003;
const WORD PTP_FLASHMODE_REDEYEAUTO    = 0x0004;
const WORD PTP_FLASHMODE_REDEYEFILL    = 0x0005;
const WORD PTP_FLASHMODE_EXTERNALSYNC  = 0x0006;

//
// exposure modes
//
const WORD PTP_EXPOSUREMODE_UNDEFINED           = 0x0000;
const WORD PTP_EXPOSUREMODE_MANUALSETTING       = 0x0001;
const WORD PTP_EXPOSUREMODE_AUTOPROGRAM         = 0x0002;
const WORD PTP_EXPOSUREMODE_APERTUREPRIORITY    = 0x0003;
const WORD PTP_EXPOSUREMODE_SHUTTERPRIORITY     = 0x0004;
const WORD PTP_EXPOSUREMODE_PROGRAMCREATIVE     = 0x0005;
const WORD PTP_EXPOSUREMODE_PROGRAMACTION       = 0x0006;
const WORD PTP_EXPOSUREMODE_PORTRAIT            = 0x0007;

//
// capturing modes
//
const WORD  PTP_CAPTUREMODE_UNDEFINED    = 0x0000;
const WORD  PTP_CAPTUREMODE_NORMAL       = 0x0001;
const WORD  PTP_CAPTUREMODE_BURST        = 0x0002;
const WORD  PTP_CAPTUREMODE_TIMELAPSE    = 0x0003;

//
// focus metering modes
//
const WORD   PTP_FOCUSMETERMODE_UNDEFINED   = 0x0000;
const WORD   PTP_FOCUSMETERMODE_CENTERSPOT  = 0x0001;
const WORD   PTP_FOCUSMETERMODE_MULTISPOT   = 0x0002;


//
// effect modes
//
const WORD PTP_EFFECTMODE_UNDEFINED = 0x0000;
const WORD PTP_EFFECTMODE_COLOR     = 0x0001;
const WORD PTP_EFFECTMODE_BW        = 0x0002;
const WORD PTP_EFFECTMODE_SEPIA     = 0x0003;


//
// storage types
//
const WORD PTP_STORAGETYPE_UNDEFINED     = 0x0000;
const WORD PTP_STORAGETYPE_FIXEDROM      = 0x0001;
const WORD PTP_STORAGETYPE_REMOVABLEROM  = 0x0002;
const WORD PTP_STORAGETYPE_FIXEDRAM      = 0x0003;
const WORD PTP_STORAGETYPE_REMOVABLERAM  = 0x0004;

//
// storage access capabilities
//
const WORD PTP_STORAGEACCESS_RWD = 0x0000;
const WORD PTP_STORAGEACCESS_R   = 0x0001;
const WORD PTP_STORAGEACCESS_RD  = 0x0002;

//
// association types
//
const WORD PTP_ASSOCIATIONTYPE_UNDEFINED        = 0x0000;
const WORD PTP_ASSOCIATIONTYPE_FOLDER           = 0x0001;
const WORD PTP_ASSOCIATIONTYPE_ALBUM            = 0x0002;
const WORD PTP_ASSOCIATIONTYPE_BURST            = 0x0003;
const WORD PTP_ASSOCIATIONTYPE_HPANORAMA        = 0x0004;
const WORD PTP_ASSOCIATIONTYPE_VPANORAMA        = 0x0005;
const WORD PTP_ASSOCIATIONTYPE_2DPANORAMA       = 0x0006;
const WORD PTP_ASSOCIATIONTYPE_ANCILLARYDATA    = 0x0007;

//
// protection status
//
const WORD PTP_PROTECTIONSTATUS_NONE        = 0x0000;
const WORD PTP_PROTECTIONSTATUS_READONLY    = 0x0001;

//
// file system types
//
const WORD PTP_FILESYSTEMTYPE_UNDEFINED     = 0x0000;
const WORD PTP_FILESYSTEMTYPE_FLAT          = 0x0001;
const WORD PTP_FILESYSTEMTYPE_HIERARCHICAL  = 0x0002;
const WORD PTP_FILESYSTEMTYPE_DCF           = 0x0003;

//
// functional modes
//
const WORD  PTP_FUNCTIONMODE_STDANDARD  = 0x0000;
const WORD  PTP_FUNCTIONMODE_SLEEP      = 0x0001;

//
// Get/Set
//
const BYTE    PTP_PROPGETSET_GETONLY  = 0x00;
const BYTE    PTP_PROPGETSET_GETSET   = 0x01;

//
// PTP command request
//
const DWORD COMMAND_NUMPARAMS_MAX = 5;
typedef struct tagPTPCommand
{
    WORD    OpCode;         // the opcode
    DWORD   SessionId;      // the session id
    DWORD   TransactionId;  // the transaction id
    DWORD   Params[COMMAND_NUMPARAMS_MAX];  // parameters
}PTP_COMMAND, *PPTP_COMMAND;

//
// PTP response block
//
const DWORD RESPONSE_NUMPARAMS_MAX = 5;
typedef struct tagPTPResponse
{
    WORD    ResponseCode;       // response code
    DWORD   SessionId;          // the session id
    DWORD   TransactionId;      // the transaction id
    DWORD   Params[RESPONSE_NUMPARAMS_MAX];  // parameters
}PTP_RESPONSE, *PPTP_RESPONSE;

//
// PTP event data
//
const DWORD EVENT_NUMPARAMS_MAX = 3;
typedef struct tagPTPEvent
{
    WORD    EventCode;      // the event code
    DWORD   SessionId;      // the session id
    DWORD   TransactionId;  // the transaction id
    DWORD   Params[EVENT_NUMPARAMS_MAX];  // parameters
}PTP_EVENT, *PPTP_EVENT;


#pragma pack(pop, Old)

//
// Raw data parsing utility functions
//
WORD  ParseWord(BYTE **ppRaw);
DWORD ParseDword(BYTE **ppRaw);
QWORD ParseQword(BYTE **ppRaw);

//
// Raw data writing utility functions
//
VOID  WriteWord(BYTE **ppRaw, WORD value);
VOID  WriteDword(BYTE **ppRaw, DWORD value);

//
// Class that holds a BSTR
//
class CBstr
{
public:
    CBstr();
    CBstr(const CBstr& src);
    ~CBstr();

    HRESULT Copy(WCHAR *wcsString);
    HRESULT Init(BYTE **ppRaw, BOOL bParse = FALSE);
    VOID    WriteToBuffer(BYTE **ppRaw);
    VOID    Dump(char *szDesc);

    UINT    Length() { return (m_bstrString == NULL ? 0 : SysStringLen(m_bstrString)); }
    BSTR    String() { return m_bstrString; }

    BSTR    m_bstrString;
};

//
// Array definitions for 8, 16, and 32 bit integers
//
class CArray8 : public CWiaArray<BYTE>
{
public:
    VOID    Dump(char *szDesc, char *szFiller);
};

class CArray16 : public CWiaArray<USHORT>
{
public:
    VOID    Dump(char *szDesc, char *szFiller);
};

class CArray32 : public CWiaArray<ULONG>
{
public:
    BOOL    ParseFrom8(BYTE **ppRaw, int NumSize = 4);
    BOOL    ParseFrom16(BYTE **ppRaw, int NumSize = 4);
    BOOL    Copy(CArray8 values8);
    BOOL    Copy(CArray16 values16);

    VOID    Dump(char *szDesc, char *szFiller);
};

//
// Array of CBstr
//
class CArrayString : public CWiaArray<CBstr>
{
public:
    HRESULT Init(BYTE **ppRaw, int NumSize = 4);
    VOID    Dump(char *szDesc, char *szFiller);
};

//
// Class that holds a PTP DeviceInfo structure
//
class CPtpDeviceInfo
{
public:
    CPtpDeviceInfo();
    ~CPtpDeviceInfo();

    HRESULT Init(BYTE *pRawData);
    VOID    Dump();

    BOOL    IsValid() { return m_SupportedOps.GetSize() > 0; }
                                        
    WORD        m_Version;               // version in hundredths
    DWORD       m_VendorExtId;           // PIMA assigned vendor id
    WORD        m_VendorExtVersion;      // vender extention version
    CBstr       m_cbstrVendorExtDesc;    // Optional vender description
    WORD        m_FuncMode;              // current functional mode
    CArray16    m_SupportedOps;          // supported operations
    CArray16    m_SupportedEvents;       // supported events
    CArray16    m_SupportedProps;        // supported properties
    CArray16    m_SupportedCaptureFmts;  // supported capture formats
    CArray16    m_SupportedImageFmts;    // supported image formats
    CBstr       m_cbstrManufacturer;     // optional manufacturer description
    CBstr       m_cbstrModel;            // optional model description
    CBstr       m_cbstrDeviceVersion;    // optional firmware description
    CBstr       m_cbstrSerialNumber;     // optional serial number description
};

//
// Class that holds a PTP StorageInfo structure
//
class CPtpStorageInfo
{
public:
    CPtpStorageInfo();
    ~CPtpStorageInfo();

    HRESULT Init(BYTE *pRawData, DWORD StorageId);
    VOID    Dump();

    DWORD       m_StorageId;             // the "id" for this store
    WORD        m_StorageType;           // storage type
    WORD        m_FileSystemType;        // file system type
    WORD        m_AccessCapability;      // access capability (e.g. read/write)
    QWORD       m_MaxCapacity;           // maximum capacity in bytes
    QWORD       m_FreeSpaceInBytes;      // free space in bytes
    DWORD       m_FreeSpaceInImages;     // free space in images
    CBstr       m_cbstrStorageDesc;      // description
    CBstr       m_cbstrStorageLabel;     // volume label
};

//
// Class that holds a PTP ObjectInfo structure
//
class CPtpObjectInfo
{
public:
    CPtpObjectInfo();
    ~CPtpObjectInfo();

    HRESULT Init(BYTE *pRawData, DWORD ObjectHandle);
    VOID    WriteToBuffer(BYTE **ppRaw);
    VOID    Dump();

    DWORD       m_ObjectHandle;          // the "handle" for this object
    DWORD       m_StorageId;             // The storage the object resides
    WORD        m_FormatCode;            // object format code
    WORD        m_ProtectionStatus;      // object protection status
    DWORD       m_CompressedSize;        // object compressed size
    WORD        m_ThumbFormat;           // thumbnail format(image object only)
    DWORD       m_ThumbCompressedSize;   // thumbnail compressedsize
    DWORD       m_ThumbPixWidth;         // thumbnail width in pixels
    DWORD       m_ThumbPixHeight;        // thumbmail height in pixels
    DWORD       m_ImagePixWidth;         // image width in pixels
    DWORD       m_ImagePixHeight;        // image height in pixels
    DWORD       m_ImageBitDepth;         // image color depth
    DWORD       m_ParentHandle;          // parent objec handle
    WORD        m_AssociationType;       // association type
    DWORD       m_AssociationDesc;       // association description
    DWORD       m_SequenceNumber;        // sequence number
    CBstr       m_cbstrFileName;         // optional file name
    CBstr       m_cbstrExtension;        // file name extension
    CBstr       m_cbstrCaptureDate;      // Captured date
    CBstr       m_cbstrModificationDate; // when it was last modified.
    CBstr       m_cbstrKeywords;         // optional keywords
};

//
// Generic class for holding property information
//
class CPtpPropDesc
{
public:
    CPtpPropDesc();
    ~CPtpPropDesc();

    HRESULT Init(BYTE *pRawData);
    HRESULT ParseValue(BYTE *pRaw);
    VOID    WriteValue(BYTE **ppRaw);
    VOID    Dump();
    VOID    DumpValue();

    WORD    m_PropCode;   // Property code for this property
    WORD    m_DataType;   // Contains the type of the data (2=BYTE, 4=WORD, 6=DWORD, 0xFFFF=String)
    BYTE    m_GetSet;     // Indicates whether the property can be set or not (0=get-only, 1=get-set)
    BYTE    m_FormFlag;   // Indicates the form of the valid values (0=none, 1=range, 2=enum)

    int     m_NumValues;  // Number of values in the enumeration

    //
    // Integer values
    //
    DWORD       m_lDefault;    // Default value
    DWORD       m_lCurrent;    // Current value
    DWORD       m_lRangeMin;   // Minimum value
    DWORD       m_lRangeMax;   // Maximum value
    DWORD       m_lRangeStep;  // Step value
    CArray32    m_lValues;     // Array of values

    //
    // String values
    //
    CBstr           m_cbstrDefault;    // Default value
    CBstr           m_cbstrCurrent;    // Current value
    CBstr           m_cbstrRangeMin;   // Minimum value
    CBstr           m_cbstrRangeMax;   // Maximum value
    CBstr           m_cbstrRangeStep;  // Step value
    CArrayString    m_cbstrValues;     // Array of values
};

#endif      // #ifndef ISO15740__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\trace.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This module declares software tracing stuff

Author:

    Dave Parsons (davepar)

Revision History:


--*/

#ifndef TRACE__H_
#define TRACE__H_

//
// Software tracing setup
//

#define WPP_CONTROL_GUIDS       \
    WPP_DEFINE_CONTROL_GUID(Regular,(E4F5B1AE,0699,41c2,BC5F,DFEEB3A1BAF6), \
    WPP_DEFINE_BIT(Error)       \
    WPP_DEFINE_BIT(Warning)     \
    WPP_DEFINE_BIT(Trace)       \
    WPP_DEFINE_BIT(Entry)       \
    WPP_DEFINE_BIT(Exit)        \
    WPP_DEFINE_BIT(DumpPtp)        \
    )

class CTraceProc {
private:
    CHAR   m_szMessage[MAX_PATH];

public:
    CTraceProc(CHAR *pszMsg);
    ~CTraceProc();
};

VOID DoTraceHresult(HRESULT hr);

#endif // TRACE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\common\sources.inc ===
#############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   DavePar
#
#Date:
#   20-Jul-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     ISO/PIMA 15740 Picture Transfer Protocol driver
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ptpusb
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

#DLLDEF=..\ptpusb.def
#DLLENTRY=_DllMainCRTStartup

USE_MSVCRT = 1

INCLUDES= \
        $(DDK_INC_PATH);        \
        ..\..\..\..\inc;        \
        $(INCLUDES);

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\ptppch.h
PRECOMPILED_OBJ = ptppch.obj

SOURCES=                \
        ..\iso15740.cpp \
        ..\camera.cpp   \
        ..\camusb.cpp   \
        ..\ptputil.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\idl\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds the PTP includes and proxy
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ptpusb
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

DLLDEF=..\ptpproxy.def
DLLENTRY=DllMain

#USE_MSVCRT = 1

# Only publish to PUBLIC
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

C_DEFINES=$(C_DEFINES) -DREGISTER_PROXY_DLL

SOURCES= \
        ..\ptpusd.idl      \
        $(O)\ptpusd_i.c      \
        $(O)\ptpusd_p.c      \
        $(O)\dlldata.c       \
        ..\ptpproxy.rc

TARGETLIBS = \
        $(SDK_LIB_PATH)\kernel32.lib    \
        $(SDK_LIB_PATH)\rpcndr.lib      \
        $(SDK_LIB_PATH)\rpcns4.lib      \
        $(SDK_LIB_PATH)\rpcrt4.lib      \
        $(SDK_LIB_PATH)\uuid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\dllmain.h ===
#ifndef DLLMAIN__H_
#define DLLMAIN__H_

extern "C"
{
    BOOL
    APIENTRY
    DllMain(
           HINSTANCE hInstance,
           DWORD dwReason,
           LPVOID lpReserved
           );
}

STDAPI
DllCanUnloadNow(void);

STDAPI
DllGetClassObject(
                 REFCLSID    rclsid,
                 REFIID      riid,
                 LPVOID      *ppv
                 );


extern HINSTANCE g_hInst;

#endif // #ifndef DLLMAIN__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\devitem.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    devitem.cpp

Abstract:

    This module implements device related function of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include <wiaconv.h>

//
// Strings that will be loaded from resource
//
WCHAR UnknownString[MAX_PATH] = L"\0";
WCHAR FolderString[MAX_PATH] = L"\0";
WCHAR ScriptString[MAX_PATH] = L"\0";
WCHAR ExecString[MAX_PATH] = L"\0";
WCHAR TextString[MAX_PATH] = L"\0";
WCHAR HtmlString[MAX_PATH] = L"\0";
WCHAR DpofString[MAX_PATH] = L"\0";
WCHAR AudioString[MAX_PATH] = L"\0";
WCHAR VideoString[MAX_PATH] = L"\0";
WCHAR UnknownImgString[MAX_PATH] = L"\0";
WCHAR ImageString[MAX_PATH] = L"\0";
WCHAR AlbumString[MAX_PATH] = L"\0";
WCHAR BurstString[MAX_PATH] = L"\0";
WCHAR PanoramaString[MAX_PATH] = L"\0";

//
// Mapping of non-image PTP formats to format info structures. Index is the
// lower 16 bits of the format code. The fields going across are WIA format GUID,
// string, and item type.
// Note: For associations, these fields depend on the type (e.g. burst, panorama)
//

FORMAT_INFO g_NonImageFormatInfo[] =
{
    { (GUID *)&WiaImgFmt_UNDEFINED, UnknownString,   ITEMTYPE_FILE,   L""    },  // Undefined                
    { NULL,                         FolderString,    ITEMTYPE_FOLDER, L""    },  // Association
    { (GUID *)&WiaImgFmt_SCRIPT,    ScriptString,    ITEMTYPE_FILE,   L""    },  // Script                   
    { (GUID *)&WiaImgFmt_EXEC,      ExecString,      ITEMTYPE_FILE,   L"EXE" },  // Executable               
    { (GUID *)&WiaImgFmt_UNICODE16, TextString,      ITEMTYPE_FILE,   L"TXT" },  // Text                     
    { (GUID *)&WiaImgFmt_HTML,      HtmlString,      ITEMTYPE_FILE,   L"HTM" },  // HTML                     
    { (GUID *)&WiaImgFmt_DPOF,      DpofString,      ITEMTYPE_FILE,   L""    },  // DPOF                     
    { (GUID *)&WiaAudFmt_AIFF,      AudioString,     ITEMTYPE_AUDIO,  L"AIF" },  // AIFF                     
    { (GUID *)&WiaAudFmt_WAV,       AudioString,     ITEMTYPE_AUDIO,  L"WAV" },  // WAV                      
    { (GUID *)&WiaAudFmt_MP3,       AudioString,     ITEMTYPE_AUDIO,  L"MP3" },  // MP3                      
    { (GUID *)&WiaImgFmt_AVI,       VideoString,     ITEMTYPE_VIDEO,  L"AVI" },  // AVI                      
    { (GUID *)&WiaImgFmt_MPG,       VideoString,     ITEMTYPE_VIDEO,  L"MPG" },  // MPEG                     
    { (GUID *)&WiaImgFmt_ASF,       VideoString,     ITEMTYPE_VIDEO,  L"ASF" }   // ASF
};
const UINT g_NumNonImageFormatInfo = sizeof(g_NonImageFormatInfo) / sizeof(g_NonImageFormatInfo[0]);

//
// Mapping of image PTP formats to format info structures.  Index is the
// lower 16 bits of the format code.
//
FORMAT_INFO g_ImageFormatInfo[] =
{
    { NULL,                        UnknownImgString, ITEMTYPE_IMAGE,  L""    },  // Undefined image
    { (GUID *)&WiaImgFmt_JPEG,     ImageString,      ITEMTYPE_IMAGE,  L"JPG" },  // EXIF/JPEG
    { (GUID *)&WiaImgFmt_TIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // TIFF/EP
    { (GUID *)&WiaImgFmt_FLASHPIX, ImageString,      ITEMTYPE_IMAGE,  L"FPX" },  // FlashPix
    { (GUID *)&WiaImgFmt_BMP,      ImageString,      ITEMTYPE_IMAGE,  L"BMP" },  // BMP
    { (GUID *)&WiaImgFmt_CIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // CIFF
    { NULL,                        UnknownString,    ITEMTYPE_IMAGE,  L""    },  // Undefined (Reserved)
    { (GUID *)&WiaImgFmt_GIF,      ImageString,      ITEMTYPE_IMAGE,  L"GIF" },  // GIF
    { (GUID *)&WiaImgFmt_JPEG,     ImageString,      ITEMTYPE_IMAGE,  L"JPG" },  // JFIF
    { (GUID *)&WiaImgFmt_PHOTOCD,  ImageString,      ITEMTYPE_IMAGE,  L"PCD" },  // PCD (PhotoCD Image Pac)
    { (GUID *)&WiaImgFmt_PICT,     ImageString,      ITEMTYPE_IMAGE,  L""    },  // PICT
    { (GUID *)&WiaImgFmt_PNG,      ImageString,      ITEMTYPE_IMAGE,  L"PNG" },  // PNG
    { NULL,                        UnknownString,    ITEMTYPE_IMAGE,  L""    },  // Undefined (Reserved)
    { (GUID *)&WiaImgFmt_TIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // TIFF
    { (GUID *)&WiaImgFmt_TIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // TIFF/IT
    { (GUID *)&WiaImgFmt_JPEG2K,   ImageString,      ITEMTYPE_IMAGE,  L""    },  // JPEG2000 Baseline
    { (GUID *)&WiaImgFmt_JPEG2KX,  ImageString,      ITEMTYPE_IMAGE,  L""    }   // JPEG2000 Extended
};
const UINT g_NumImageFormatInfo = sizeof(g_ImageFormatInfo) / sizeof(g_ImageFormatInfo[0]);

//
// Mapping of association types to format info structures.
//
FORMAT_INFO g_AssocFormatInfo[] =
{
    { NULL,                         UnknownString,   ITEMTYPE_FOLDER },  // Undefined
    { NULL,                         FolderString,    ITEMTYPE_FOLDER },  // Generic folder
    { NULL,                         AlbumString,     ITEMTYPE_FOLDER },  // Album
    { NULL,                         BurstString,     ITEMTYPE_BURST  },  // Time burst
    { NULL,                         PanoramaString,  ITEMTYPE_HPAN   },  // Horizontal panorama
    { NULL,                         PanoramaString,  ITEMTYPE_VPAN   },  // Vertical panorama
    { NULL,                         PanoramaString,  ITEMTYPE_FOLDER },  // 2D panorama
    { NULL,                         FolderString,    ITEMTYPE_FOLDER }   // Ancillary data
};
const UINT g_NumAssocFormatInfo = sizeof(g_AssocFormatInfo) / sizeof(g_AssocFormatInfo[0]);

//
// Mapping of property codes to property info structures. Index is the lower 12 bites of the
// prop code. The fields going across are WIA property ID, and WIA property string.
//
PROP_INFO g_PropInfo[] =
{
    { 0,                                NULL                                },  // Undefined property code
    { WIA_DPC_BATTERY_STATUS,           WIA_DPC_BATTERY_STATUS_STR          },
    { 0,                                NULL                                },  // Functional mode, not used
    { 0,                                NULL                                },  // Image capture dimensions (needs special processing)
    { WIA_DPC_COMPRESSION_SETTING,      WIA_DPC_COMPRESSION_SETTING_STR     },
    { WIA_DPC_WHITE_BALANCE,            WIA_DPC_WHITE_BALANCE_STR           },
    { WIA_DPC_RGB_GAIN,                 WIA_DPC_RGB_GAIN_STR                },
    { WIA_DPC_FNUMBER,                  WIA_DPC_FNUMBER_STR                 },
    { WIA_DPC_FOCAL_LENGTH,             WIA_DPC_FOCAL_LENGTH_STR            },
    { WIA_DPC_FOCUS_DISTANCE,           WIA_DPC_FOCUS_DISTANCE_STR          },
    { WIA_DPC_FOCUS_MODE,               WIA_DPC_FOCUS_MODE_STR              },
    { WIA_DPC_EXPOSURE_METERING_MODE,   WIA_DPC_EXPOSURE_METERING_MODE_STR  },
    { WIA_DPC_FLASH_MODE,               WIA_DPC_FLASH_MODE_STR              },
    { WIA_DPC_EXPOSURE_TIME,            WIA_DPC_EXPOSURE_TIME_STR           },
    { WIA_DPC_EXPOSURE_MODE,            WIA_DPC_EXPOSURE_MODE_STR           },
    { WIA_DPC_EXPOSURE_INDEX,           WIA_DPC_EXPOSURE_INDEX_STR          },
    { WIA_DPC_EXPOSURE_COMP,            WIA_DPC_EXPOSURE_COMP_STR           },
    { WIA_DPA_DEVICE_TIME,              WIA_DPA_DEVICE_TIME_STR             },
    { WIA_DPC_CAPTURE_DELAY,            WIA_DPC_CAPTURE_DELAY_STR           },
    { WIA_DPC_CAPTURE_MODE,             WIA_DPC_CAPTURE_MODE_STR            },
    { WIA_DPC_CONTRAST,                 WIA_DPC_CONTRAST_STR                },
    { WIA_DPC_SHARPNESS,                WIA_DPC_SHARPNESS_STR               },
    { WIA_DPC_DIGITAL_ZOOM,             WIA_DPC_DIGITAL_ZOOM_STR            },
    { WIA_DPC_EFFECT_MODE,              WIA_DPC_EFFECT_MODE_STR             },
    { WIA_DPC_BURST_NUMBER,             WIA_DPC_BURST_NUMBER_STR            },
    { WIA_DPC_BURST_INTERVAL,           WIA_DPC_BURST_INTERVAL_STR          },
    { WIA_DPC_TIMELAPSE_NUMBER,         WIA_DPC_TIMELAPSE_NUMBER_STR        },
    { WIA_DPC_TIMELAPSE_INTERVAL,       WIA_DPC_TIMELAPSE_INTERVAL_STR      },
    { WIA_DPC_FOCUS_METERING_MODE,      WIA_DPC_FOCUS_METERING_MODE_STR     },
    { WIA_DPC_UPLOAD_URL,               WIA_DPC_UPLOAD_URL_STR              },
    { WIA_DPC_ARTIST,                   WIA_DPC_ARTIST_STR                  },
    { WIA_DPC_COPYRIGHT_INFO,           WIA_DPC_COPYRIGHT_INFO_STR          }
};
    
const UINT g_NumPropInfo = sizeof(g_PropInfo) / sizeof(g_PropInfo[0]);

//
// Helper function - returns number of logical storages (those which have 
// StorageId & PTP_STORAGEID_LOGICAL > 0)
//
int CWiaMiniDriver::NumLogicalStorages()
{
    DBG_FN("CWiaMiniDriver::NumLogicalStorages");

    int nResult = 0;
    for (int i = 0; i < m_StorageIds.GetSize(); i++)
    {
        if (m_StorageIds[i] & PTP_STORAGEID_LOGICAL)
        {
            nResult++;
        }
    }
    return nResult;
}

//
// This function creates the driver item tree
//
// Input:
//   RootItemFullName -- the root item full name
//   ppRoot -- to receive the root driver item
//
HRESULT
CWiaMiniDriver::CreateDrvItemTree(IWiaDrvItem **ppRoot)
{
    DBG_FN("CWiaMiniDriver::CreateDrvItemTree");
    
    HRESULT hr = S_OK;

    DRVITEM_CONTEXT *pDrvItemContext;

    if (!ppRoot)
    {
        wiauDbgError("CreateDrvItemTree", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Create the root item name
    //
    BSTR bstrRoot = SysAllocString(L"Root");
    if (!bstrRoot)
    {
        wiauDbgError("CreateDrvItemTree", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Create the root item.
    //
    *ppRoot = NULL;
    pDrvItemContext = NULL;
    hr = wiasCreateDrvItem(WiaItemTypeDevice | WiaItemTypeRoot | WiaItemTypeFolder,
                           bstrRoot,
                           m_bstrRootItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(DRVITEM_CONTEXT),
                           (BYTE **) &pDrvItemContext,
                           ppRoot
                          );

    SysFreeString(bstrRoot);

    if (FAILED(hr) || !*ppRoot || !pDrvItemContext)
    {
        wiauDbgError("CreateDrvItemTree", "wiasCreateDrvItem failed");
        return hr;
    }
    
    pDrvItemContext->pObjectInfo = NULL;
    pDrvItemContext->NumFormatInfos = 0;
    pDrvItemContext->pFormatInfos = NULL;

    pDrvItemContext->ThumbSize = 0;
    pDrvItemContext->pThumb = NULL;
    
    //
    // Add an entry in the object handle/driver item association mapping for the root
    //
    if (!m_HandleItem.Add(0, *ppRoot))
    {
        wiauDbgError("CreateDrvItemTree", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Now create all the other items by looping through the list of all of the object
    // handles on the device
    //
    CArray32 ObjectHandleList;

    if (NumLogicalStorages() > 0)
    {
        hr = m_pPTPCamera->GetObjectHandles(PTP_STORAGEID_ALL, PTP_FORMATCODE_ALL, PTP_OBJECTHANDLE_ALL,
                                            &ObjectHandleList);
        if (FAILED(hr))
        {
            wiauDbgError("CreateDrvItemTree", "GetObjectHandles failed");
            return hr;
        }
    }

    //
    // Iterate through the object handles, creating a WIA driver item for each
    //
    for (int count = 0; count < ObjectHandleList.GetSize(); count++)
    {
        hr = AddObject(ObjectHandleList[count]);
        if (FAILED(hr))
        {
            wiauDbgError("CreateDrvItemTree", "AddObject failed");
            return hr;
        }
    }

    return hr;
}

//
// This function adds an object to the driver item tree
//
// Input:
//   ObjectHandle -- PTP handle for the object
//
HRESULT
CWiaMiniDriver::AddObject(
    DWORD ObjectHandle,
    BOOL bQueueEvent
    )
{
    USES_CONVERSION;
    
    DBG_FN("CWiaMiniDriver::AddObject");

    HRESULT hr = S_OK;

    //
    // Create an ObjectInfo
    //
    CPtpObjectInfo *pObjectInfo = new CPtpObjectInfo;

    if (!pObjectInfo)
    {
        wiauDbgError("AddObject", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Get the ObjectInfo for the object
    //
    hr = m_pPTPCamera->GetObjectInfo(ObjectHandle, pObjectInfo);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "GetObjectInfo failed");
        delete pObjectInfo;
        pObjectInfo = NULL;
        return hr;
    }

    int storeIdx = m_StorageIds.Find(pObjectInfo->m_StorageId);

    //
    // Look for objects to hide if this is a DCF store
    //
    if (m_StorageInfos[storeIdx].m_FileSystemType == PTP_FILESYSTEMTYPE_DCF)
    {
        BOOL bHideObject = FALSE;
        
        //
        // If the DCIM folder has been identified and this is a folder under DCIM, hide it
        //
        if (m_DcimHandle[storeIdx])
        {
            if (pObjectInfo->m_ParentHandle == m_DcimHandle[storeIdx])
                bHideObject = TRUE;
        }

        //
        // Otherwise see if this is the DCIM folder
        //
        else if (wcscmp(pObjectInfo->m_cbstrFileName.String(), L"DCIM") == 0)
        {
            bHideObject = TRUE;
            m_DcimHandle[storeIdx] = ObjectHandle;
        }

        if (bHideObject)
        {
            //
            // Create a dummy entry in the handle/item map so that objects under this
            // folder will be put under the root
            //
            if (!m_HandleItem.Add(ObjectHandle, m_pDrvItemRoot))
            {
                wiauDbgError("AddObject", "add handle item failed");
                return E_OUTOFMEMORY;
            }

            wiauDbgTrace("AddObject", "hiding DCIM folder 0x%08x", ObjectHandle);

            delete pObjectInfo;
            pObjectInfo = NULL;
            return hr;
        }
    }

    //
    // If this is an "ancillary data" association, don't create an item but put the handle
    // in the ancillary association array
    //
    if (pObjectInfo->m_AssociationType == PTP_ASSOCIATIONTYPE_ANCILLARYDATA)
    {
        if (!m_AncAssocParent.Add(ObjectHandle, m_HandleItem.Lookup(pObjectInfo->m_ParentHandle)))
        {
            wiauDbgError("AddObject", "add ancillary assoc handle failed");
            return E_OUTOFMEMORY;
        }
        
        delete pObjectInfo;
        pObjectInfo = NULL;
        return hr;
    }

    //
    // Keep count of the number of images
    //
    UINT16 FormatCode = pObjectInfo->m_FormatCode;
    if (FormatCode & PTP_FORMATMASK_IMAGE)
    {
        m_NumImages++;

        //
        // Also make sure that the bit depth is non-zero.
        //
        if (pObjectInfo->m_ImageBitDepth == 0) {
            switch(pObjectInfo->m_FormatCode) {
                case PTP_FORMATCODE_IMAGE_GIF:
                    pObjectInfo->m_ImageBitDepth = 8;
                    break;
                default:
                    pObjectInfo->m_ImageBitDepth = 24;
            }
        }
    }

    //
    // Update Storage Info (we are especially interested in Free Space info)
    //
    hr  = UpdateStorageInfo(pObjectInfo->m_StorageId);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "UpdateStorageInfo failed");
        // we can proceed, even if storage info can't be updated
    }

    //
    // For images, check to see if the parent is an ancillary association
    //
    IWiaDrvItem *pParent = NULL;
    LONG ExtraItemFlags = 0;
    int ancIdx = m_AncAssocParent.FindKey(pObjectInfo->m_ParentHandle);
    if ((FormatCode & PTP_FORMATMASK_IMAGE) &&
        (ancIdx >= 0))
    {
        ExtraItemFlags |= WiaItemTypeHasAttachments;
        pParent = m_AncAssocParent.GetValueAt(ancIdx);
    }

    //
    // For normal images, just look up the parent item in the map
    //
    else
    {
        pParent = m_HandleItem.Lookup(pObjectInfo->m_ParentHandle);
    }

    //
    // If a parent wasn't found, just use the root as the parent
    //
    if (!pParent)
    {
        pParent = m_pDrvItemRoot;
    }

    //
    // Look up info about the object's format
    //
    FORMAT_INFO *pFormatInfo = FormatCodeToFormatInfo(FormatCode, pObjectInfo->m_AssociationType);
    
    //
    // Get the item's name, generating it if necessary
    //
    CBstr *pFileName = &(pObjectInfo->m_cbstrFileName);
    TCHAR tcsName[MAX_PATH];
    TCHAR *ptcsDot;

    if (pFileName->Length() == 0)
    {
        wsprintf((TCHAR *)tcsName, W2T(pFormatInfo->FormatString), ObjectHandle);

        hr = pFileName->Copy(T2W(tcsName));
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "CBstr::Copy failed");
            return hr;
        }
    }

    //
    // For images Chop off the filename extension, if it exists 
    //
    WCHAR *pDot = wcsrchr(pFileName->String(), L'.');
    if (pDot)
    {

        // Copy extension first
        hr = pObjectInfo->m_cbstrExtension.Copy(pDot + 1);
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "copy string failed");
            return hr;
        }

        // then remove the extension from the item name
        lstrcpy(tcsName, W2T(pFileName->String()));
        ptcsDot = _tcsrchr(tcsName, TEXT('.'));
        *ptcsDot = TEXT('\0');
        
        hr = pFileName->Copy(T2W(tcsName));
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "copy string failed");
            return hr;
        }

    }

    if(pObjectInfo->m_cbstrExtension.Length()) {
        // this is special-case handling of .MOV files for which we
        // don't have GUID, but which need to be treated as video
        // elsewhere
        if(_wcsicmp(pObjectInfo->m_cbstrExtension.String(), L"MOV") == 0) {
            pFormatInfo->ItemType = ITEMTYPE_VIDEO;
        }
    }

    //
    // Create the item's full name
    //
    BSTR bstrItemFullName = NULL;
    BSTR bstrParentName = NULL;

    hr = pParent->GetFullItemName(&bstrParentName);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "GetFullItemName failed");
        return hr;
    }

    if(_sntprintf(tcsName, MAX_PATH - 1, TEXT("%s\\%s"), W2T(bstrParentName), W2T(pFileName->String())) == -1) {
        tcsName[MAX_PATH - 1] = TEXT('\0');
    }

    bstrItemFullName = SysAllocString(T2W(tcsName));
    if (!bstrItemFullName)
    {
        wiauDbgError("AddObject", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Create the driver item
    //
    IWiaDrvItem *pItem = NULL;
    DRVITEM_CONTEXT *pDrvItemContext = NULL;
    hr = wiasCreateDrvItem(pFormatInfo->ItemType | ExtraItemFlags,
                           pFileName->String(),
                           bstrItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(DRVITEM_CONTEXT),
                           (BYTE **) &pDrvItemContext,
                           &pItem);

    SysFreeString(bstrParentName);

    if (FAILED(hr) || !pItem || !pDrvItemContext)
    {
        wiauDbgError("AddObject", "wiasCreateDriverItem failed");
        return hr;
    }

    //
    // Fill in the driver item context. Wait until the thumbnail is requested before
    // reading it in.
    //
    pDrvItemContext->pObjectInfo = pObjectInfo;
    pDrvItemContext->NumFormatInfos = 0;
    pDrvItemContext->pFormatInfos = NULL;

    pDrvItemContext->ThumbSize = 0;
    pDrvItemContext->pThumb = NULL;

    //
    // Place the new item under it's parent
    //
    hr = pItem->AddItemToFolder(pParent);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "AddItemToFolder failed");
        return hr;
    }

    //
    // Add the object handle/driver item association to the list
    //
    if (!m_HandleItem.Add(ObjectHandle, pItem))
    {
        wiauDbgError("AddObject", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // If this image is replacing an ancillary association folder, put another entry
    // in the object handle/item map for that folder
    //
    if (ancIdx >= 0)
    {
        if (!m_HandleItem.Add(pObjectInfo->m_ParentHandle, pItem))
        {
            wiauDbgError("AddObject", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    //
    // Post an item added event, if requested
    //
    if (bQueueEvent)
    {
        hr = wiasQueueEvent(m_bstrDeviceId, &WIA_EVENT_ITEM_CREATED, bstrItemFullName);
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "wiasQueueEvent failed");
            return hr;
        }
    }

    SysFreeString(bstrItemFullName);

    return hr;
}

//
// This function initializes device properties
//
// Input:
//   pWiasContext    -- wias context
//
HRESULT
CWiaMiniDriver::InitDeviceProperties(BYTE *pWiasContext)
{
    DBG_FN("CWiaMiniDriver::InitDeviceProperties");
    
    HRESULT hr = S_OK;

    const INT NUM_ROOT_PROPS = 12;

    //
    // Define things here that need to live until SendToWia() is called
    //
    CArray32 widthList, heightList;     // Used by code that split image width and height
    SYSTEMTIME SystemTime;              // Used for device time
    int NumFormats = 0;                 // Used by format setting code
    LPGUID *pFormatGuids = NULL;        // Used by format setting code
    FORMAT_INFO *pFormatInfo = NULL;    // Used by format setting code
    int FormatCount = 0;                // Used by format setting code

    //
    // Create the property list for the device
    //
    CWiauPropertyList RootProps;
    CArray16 *pSupportedProps = &m_DeviceInfo.m_SupportedProps;

    hr = RootProps.Init(pSupportedProps->GetSize() + NUM_ROOT_PROPS);
    if (FAILED(hr))
    {
        wiauDbgError("InitDeviceProperties", "Init failed");
        return hr;
    }

    INT index;
    int count;

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    hr = RootProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                             WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, (LONG) WIA_ITEM_READ|WIA_ITEM_WRITE);

    //
    // WIA_DPA_FIRMWARE_VERSION
    //
    hr = RootProps.DefineProperty(&index, WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR,
                             WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.m_cbstrDeviceVersion.String());

    //
    // WIA_DPC_PICTURES_TAKEN
    //
    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_NumImages);

    //
    // WIA_DPC_PICTURES_REMAINING
    //
    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, GetTotalFreeImageSpace());

    //
    // WIA_IPA_FORMAT -- Translate from the CaptureFormats field of DeviceInfo
    //
    hr = RootProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    NumFormats = m_DeviceInfo.m_SupportedCaptureFmts.GetSize();
    pFormatGuids = new LPGUID[NumFormats];
    FormatCount = 0;

    if (!pFormatGuids)
    {
        wiauDbgError("InitDeviceProperties", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    for (count = 0; count < NumFormats; count++)
    {
        pFormatInfo = FormatCodeToFormatInfo(m_DeviceInfo.m_SupportedCaptureFmts[count]);
        if (pFormatInfo->FormatGuid != NULL)
            pFormatGuids[FormatCount++] = pFormatInfo->FormatGuid;
    }

    //
    // Kodak DC4800 needs to have WIA_IPA_FORMAT set to JPEG. This hack can be removed
    // only if support of DC4800 is removed
    //
    if (m_pPTPCamera && m_pPTPCamera->GetHackModel() == HACK_MODEL_DC4800)
    {
        RootProps.SetCurrentValue(index, (CLSID *) &WiaImgFmt_JPEG);
    }

    else if (FormatCount == 1)
    {
        RootProps.SetCurrentValue(index, pFormatGuids[0]);
    }

    else if (FormatCount > 1)
    {
        RootProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_NONE);
        RootProps.SetValidValues(index, pFormatGuids[0], pFormatGuids[0], FormatCount, pFormatGuids);
    }

    else
        wiauDbgWarning("InitDeviceProperties", "Device has no valid formats");

    delete []pFormatGuids;

    //
    // Loop through PTP property description structures, translating them to WIA properties
    //
    PPROP_INFO pPropInfo;
    ULONG Access;
    ULONG SubType;

    for (count = 0; count < m_PropDescs.GetSize(); count++)
    {
        CPtpPropDesc *pCurrentPD = &m_PropDescs[count];
        WORD PropCode = pCurrentPD->m_PropCode;

        //
        // Set the property access
        //
        if (pCurrentPD->m_GetSet == PTP_PROPGETSET_GETSET)
        {
            Access = WIA_PROP_RW;
            SubType = 0;
        }
        else
        {
            Access = WIA_PROP_READ;
            SubType = WIA_PROP_NONE;
        }
        
        //
        // Process image capture dimensions separately, since they are in a string
        //
        if (PropCode == PTP_PROPERTYCODE_IMAGESIZE)
        {
            //
            // Define separate properties for image width and height
            //
            hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR, Access, SubType);
            if (FAILED(hr)) goto failure;

            hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR, Access, SubType);
            if (FAILED(hr)) goto failure;

            LONG curWidth, curHeight;
            SplitImageSize(pCurrentPD->m_cbstrCurrent, &curWidth, &curHeight);

            //
            // If the image capture size property is read-only, just set the current values
            //
            if (Access == WIA_PROP_READ)
            {
                RootProps.SetCurrentValue(index-1, curWidth);
                RootProps.SetCurrentValue(index, curHeight);
            }

            //
            // Otherwise, set the valid values too
            //
            else
            {
                //
                // Convert default values
                //
                LONG defWidth, defHeight;
                SplitImageSize(pCurrentPD->m_cbstrDefault, &defWidth, &defHeight);

                if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_RANGE)
                {
                    //
                    // Convert max, min, and step
                    //
                    LONG minWidth, minHeight, maxWidth, maxHeight, stepWidth, stepHeight;
                    SplitImageSize(pCurrentPD->m_cbstrRangeMin, &minWidth, &minHeight);
                    SplitImageSize(pCurrentPD->m_cbstrRangeMax, &maxWidth, &maxHeight);
                    SplitImageSize(pCurrentPD->m_cbstrRangeStep, &stepWidth, &stepHeight);

                    RootProps.SetValidValues(index-1, defWidth, curWidth, minWidth, maxWidth, stepWidth);
                    RootProps.SetValidValues(index, defHeight, curHeight, minHeight, maxHeight, stepHeight);
                }
                else if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_ENUM)
                {
                    //
                    // Convert list of strings
                    //
                    ULONG width, height;
                    
                    int numElem = pCurrentPD->m_NumValues;

                    if (!widthList.GrowTo(numElem) ||
                        !heightList.GrowTo(numElem))
                    {
                        wiauDbgError("InitDeviceProperties", "memory allocation failed");
                        return E_OUTOFMEMORY;
                    }

                    for (int countVals = 0; countVals < numElem; countVals++)
                    {
                        SplitImageSize(pCurrentPD->m_cbstrValues[countVals], (LONG*) &width, (LONG*) &height);

                        if (!widthList.Add(width) ||
                            !heightList.Add(height))
                        {
                            wiauDbgError("InitDeviceProperties", "error adding width or height");
                            return E_FAIL;
                        }
                    }

                    RootProps.SetValidValues(index-1, defWidth, curWidth, numElem, (LONG *) widthList.GetData());
                    RootProps.SetValidValues(index, defHeight, curHeight, numElem, (LONG *) heightList.GetData());
                }
            }

            continue;

        } // if (PropCode == PTP_PROPERTYCODE_IMAGESIZE)

        //
        // Look up the property info structure, which contains the WIA prop id and string
        //
        pPropInfo = PropCodeToPropInfo(PropCode);
        if (!pPropInfo->PropId)
        {
            wiauDbgError("InitDeviceProperties", "property code not found in array, 0x%04x", PropCode);
            return E_FAIL;
        }
        
        //
        // Define the property based on the fields in the property info structure
        //
        hr = RootProps.DefineProperty(&index, pPropInfo->PropId, pPropInfo->PropName, Access, SubType);
        if (FAILED(hr)) goto failure;

        //
        // Handle the device date/time. Convert it to SYSTEMTIME and create the property, skipping the rest.
        //
        if (PropCode == PTP_PROPERTYCODE_DATETIME)
        {
            hr = PtpTime2SystemTime(&(pCurrentPD->m_cbstrCurrent), &SystemTime);
            if (FAILED(hr))
            {
                wiauDbgError("InitDeviceProperties", "invalid date/time string");
                continue;
            }

            RootProps.SetCurrentValue(index, &SystemTime);

            continue;
        }

        //
        // Handle all other properties
        //
        if (Access == WIA_PROP_RW)
        {
            //
            // Set the valid values for ranges
            //
            if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_RANGE)
            {
                //
                // WIA can't handle string ranges, so handle just integers
                //
                if (pCurrentPD->m_DataType != PTP_DATATYPE_STRING)
                    RootProps.SetValidValues(index, (LONG) pCurrentPD->m_lDefault,
                                             (LONG) pCurrentPD->m_lCurrent,
                                             (LONG) pCurrentPD->m_lRangeMin,
                                             (LONG) pCurrentPD->m_lRangeMax,
                                             (LONG) pCurrentPD->m_lRangeStep);
            }

            //
            // Set the valid values for lists
            //
            else if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_ENUM)
            {
                if (pCurrentPD->m_DataType == PTP_DATATYPE_STRING)
                    RootProps.SetValidValues(index, pCurrentPD->m_cbstrDefault.String(),
                                             pCurrentPD->m_cbstrCurrent.String(),
                                             pCurrentPD->m_NumValues,
                                             (BSTR *) (pCurrentPD->m_cbstrValues.GetData()));
                else
                    RootProps.SetValidValues(index, (LONG) pCurrentPD->m_lDefault,
                                             (LONG) pCurrentPD->m_lCurrent,
                                             pCurrentPD->m_NumValues,
                                             (LONG *) (pCurrentPD->m_lValues.GetData()));
            }

            //
            // Unrecognized form. Just set the current values
            //
            if (pCurrentPD->m_DataType == PTP_DATATYPE_STRING)
                RootProps.SetCurrentValue(index, pCurrentPD->m_cbstrCurrent.String());
            else
                RootProps.SetCurrentValue(index, (LONG) pCurrentPD->m_lCurrent);
        }
        else
        {
            //
            // For read-only properties, just set the current value
            //
            if (pCurrentPD->m_DataType == PTP_DATATYPE_STRING)
                RootProps.SetCurrentValue(index, pCurrentPD->m_cbstrCurrent.String());
            else
                RootProps.SetCurrentValue(index, (LONG) pCurrentPD->m_lCurrent);
        }

    }

    // Last step: send all the properties to WIA

    hr = RootProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "InitDeviceProperties", "SendToWia failed");
        return hr;
    }

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //

    failure:
        wiauDbgErrorHr(hr, "InitDeviceProperties", "DefineProperty failed");
        return hr;
}

// This function reads the device properties
//
// Input:
//  pWiasContext  -- wias context
//  NumPropSpecs  -- number of properties to be read
//  pPropSpecs    -- list of PROPSPEC that designates what properties to read
//
HRESULT
CWiaMiniDriver::ReadDeviceProperties(
    BYTE *pWiasContext,
    LONG NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaMiniDriver::ReadDeviceProperties");
    
    HRESULT hr = S_OK;
    
    if (!NumPropSpecs || !pPropSpecs)
    {
        wiauDbgError("ReadDeviceProperties", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Update the device properties
    //
    if (m_PropDescs.GetSize() > 0)
    {
        //
        // Loop through all of the PropSpecs
        //
        for (int count = 0; count < NumPropSpecs; count++)
        {
            PROPID propId = pPropSpecs[count].propid;
            
            //
            // Update free image space, if requested
            //
            if (propId == WIA_DPC_PICTURES_REMAINING)
            {
                hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_REMAINING, GetTotalFreeImageSpace());
                if (FAILED(hr))
                {
                    wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                    return hr;
                }
            }

            //
            // Update pictures taken, if requested
            //
            else if (propId == WIA_DPC_PICTURES_TAKEN)
            {
                hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, m_NumImages);
                if (FAILED(hr))
                {
                    wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                    return hr;
                }
            }
            
            //
            // Image size is a special case property, which we handle here
            //
            else if (propId == WIA_DPC_PICT_WIDTH ||
                     propId == WIA_DPC_PICT_HEIGHT)
            {
                int propDescIdx = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_IMAGESIZE);
                if (propDescIdx < 0)
                    continue;

                LONG width, height;
                SplitImageSize(m_PropDescs[propDescIdx].m_cbstrCurrent, &width, &height);

                if (propId == WIA_DPC_PICT_WIDTH)
                    hr = wiasWritePropLong(pWiasContext, propId, width);
                else
                    hr = wiasWritePropLong(pWiasContext, propId, height);

                if (FAILED(hr))
                {
                    wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                    return hr;
                }
            }
            
            //
            // See if the property is one that is contained in the PropSpec array
            //
            else
            {
                //
                // Try to convert the WIA prop id to a PTP prop code
                //
                WORD propCode = PropIdToPropCode(propId);
                if (propCode == 0)
                    continue;

                //
                // Try to find the prop code (and thus the prop desc structure) in the member array
                //
                int propDescIdx = m_DeviceInfo.m_SupportedProps.Find(propCode);
                if (propDescIdx < 0)
                    continue;

                //
                // If it's the device time property, convert to SYSTEMTIME and write to WIA
                //
                if (propId == WIA_DPA_DEVICE_TIME)
                {
                    hr = m_pPTPCamera->GetDevicePropValue(propCode, &m_PropDescs[propDescIdx]);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "GetDevicePropValue failed");
                        return hr;
                    }
                    
                    SYSTEMTIME st;
                    hr = PtpTime2SystemTime(&m_PropDescs[propDescIdx].m_cbstrCurrent, &st);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "PtpTime2SystemTime failed");
                        return hr;
                    }

                    PROPVARIANT pv;
                    pv.vt = VT_UI2 | VT_VECTOR;
                    pv.caui.cElems = sizeof(SYSTEMTIME)/sizeof(WORD);
                    pv.caui.pElems = (USHORT *) &st;

                    PROPSPEC ps;
                    ps.ulKind = PRSPEC_PROPID;
                    ps.propid = propId;

                    hr = wiasWriteMultiple(pWiasContext, 1, &ps, &pv);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "wiasWriteMultiple failed");
                        return hr;
                    }
                }

                //
                // If it's a string property, write the updated value to WIA
                //
                else if (m_PropDescs[propDescIdx].m_DataType == PTP_DATATYPE_STRING)
                {
                    hr = wiasWritePropStr(pWiasContext, propId,
                                          m_PropDescs[propDescIdx].m_cbstrCurrent.String());
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                        return hr;
                    }
                }

                //
                // If it's an integer property, write the updated value to WIA
                //
                else
                {
                    hr = wiasWritePropLong(pWiasContext, propId,
                                           m_PropDescs[propDescIdx].m_lCurrent);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                        return hr;
                    }
                }
            }
        }
    }

    return hr;
}

//
// This function does nothing, since the values were already sent to the device in ValidateDeviceProp
//
// Input:
//   pWiasContext -- the WIA item context
//   pmdtc        -- the transfer context
//
HRESULT
CWiaMiniDriver::WriteDeviceProperties(
    BYTE *pWiasContext
    )
{
    DBG_FN("CWiaMiniDriver::WriteDeviceProperties");

    HRESULT hr = S_OK;

    return hr;
}

//
// This function validates device property current settings and writes them to the device. The
// settings need to be written here vs. WriteDeviceProperties in case the user unplugs the camera.
//
// Input:
//   pWiasContext    -- the item's context
//   NumPropSpecs    -- number of properties to be validated
//   pPropSpecs  -- properties to be validated
//
HRESULT
CWiaMiniDriver::ValidateDeviceProperties(
    BYTE    *pWiasContext,
    LONG    NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    USES_CONVERSION;
    
    DBG_FN("CWiaMiniDriver::ValidateDeviceProperties");
    
    HRESULT hr = S_OK;

    //
    // Call WIA service helper to check against valid values
    //
    hr = wiasValidateItemProperties(pWiasContext, NumPropSpecs, pPropSpecs);
    if (FAILED(hr))
    {
        wiauDbgWarning("ValidateDeviceProperties", "wiasValidateItemProperties failed");
        return hr;
    }

    {
        //
        // Ensure exclusive access
        //
        CPtpMutex cpm(m_hPtpMutex);

        //
        // Read all of the new property values
        //
        PROPVARIANT *pPropVar = new PROPVARIANT[NumPropSpecs];
        hr = wiasReadMultiple(pWiasContext, NumPropSpecs, pPropSpecs, pPropVar, NULL);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateDeviceProperties", "wiasReadMultiple failed");
            delete []pPropVar;
            return hr;
        }
    
        //
        // First do validation
        //
        LONG width, height;
        
        for (int count = 0; count < NumPropSpecs; count++)
        {
            //
            // Handle changes to the picture width
            //
            if (pPropSpecs[count].propid == WIA_DPC_PICT_WIDTH)
            {
                width = pPropVar[count].lVal;
                height = 0;
    
                //
                // Look through the valid values and find the corresponding height
                //
                hr = FindCorrDimension(pWiasContext, &width, &height);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "FindCorrDimension failed");
                    delete []pPropVar;
                    return hr;
                }
                
                //
                // If the app is trying to set height, make sure it's correct
                //
                int idx;
                if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_DPC_PICT_HEIGHT, &idx))
                {
                    if (height != pPropVar[idx].lVal)
                    {
                        wiauDbgError("ValidateDeviceProperties", "app attempting to set incorrect height");
                        delete []pPropVar;
                        return E_INVALIDARG;
                    }
                }
    
                else
                {
                    hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICT_HEIGHT, height);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "wiasWritePropLong failed");
                        delete []pPropVar;
                        return hr;
                    }
                }
    
            } // if (pPropSpecs[count].propid == WIA_DPC_PICT_WIDTH)
    
            
            //
            // Handle changes to the picture height
            //
            else if (pPropSpecs[count].propid == WIA_DPC_PICT_HEIGHT)
            {
                //
                // See if the app is trying to set width also. If so, the height has
                // already been set, so don't set it again.
                //
                if (!wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_DPC_PICT_WIDTH))
                {
                    width = 0;
                    height = pPropVar[count].lVal;
    
                    //
                    // Look through the valid values and find the corresponding width
                    //
                    hr = FindCorrDimension(pWiasContext, &width, &height);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "FindCorrDimension failed");
                        delete []pPropVar;
                        return hr;
                    }
    
                    //
                    // Set the width
                    //
                    hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICT_WIDTH, width);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "wiasWritePropLong failed");
                        delete []pPropVar;
                        return hr;
                    }
                }
            
            } // else if (pPropSpecs[count].propid == WIA_DPC_PICT_HEIGHT)
    
            //
            // Handle device time
            //
            else if (pPropSpecs[count].propid == WIA_DPA_DEVICE_TIME)
            {
                int propIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_DATETIME);
                CPtpPropDesc *pCurrentPD = &m_PropDescs[propIndex];
    
                //
                // Convert the date/time to a string
                //
                SYSTEMTIME *pSystemTime = (SYSTEMTIME *) pPropVar[count].caui.pElems;
                hr = SystemTime2PtpTime(pSystemTime, &pCurrentPD->m_cbstrCurrent);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "invalid date/time string");
                    delete []pPropVar;
                    return E_FAIL;
                }
    
                //
                // Write the new date/time to the device
                //
                hr = m_pPTPCamera->SetDevicePropValue(PTP_PROPERTYCODE_DATETIME, pCurrentPD);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "SetDevicePropValue failed");
                    delete []pPropVar;
                    return hr;
                }
            } // else if (pPropSpecs[count].propid == WIA_DPA_DEVICE_TIME)
        } // for (count...
    
        //
        // Now write the new values to the camera
        //
        PROPSPEC propSpec;
        BOOL bWroteWidthHeight = FALSE;
        WORD propCode = 0;
        int pdIdx = 0;
        CPtpPropDesc *pCurrentPD = NULL;
        
        for (int count = 0; count < NumPropSpecs; count++)
        {
            //
            // Skip date/time since it was already written above
            //
            if (pPropSpecs[count].propid == WIA_DPA_DEVICE_TIME)
                continue;
            
            //
            // Handle changes to the picture width or height
            //
            if ((pPropSpecs[count].propid == WIA_DPC_PICT_WIDTH) ||
                (pPropSpecs[count].propid == WIA_DPC_PICT_HEIGHT))
            {
                //
                // If width and height were already written, don't do it again
                //
                if (bWroteWidthHeight)
                    continue;
    
                TCHAR ptcsImageSize[MAX_PATH];
                int num = wsprintf(ptcsImageSize, TEXT("%dx%d"), width, height);
                if (num < 2)
                {
                    wiauDbgError("ValidateDeviceProperties", "swprintf failed");
                    delete []pPropVar;
                    return E_FAIL;
                }
    
                propCode = PTP_PROPERTYCODE_IMAGESIZE;
                pdIdx = m_DeviceInfo.m_SupportedProps.Find(propCode);
                if (pdIdx < 0)
                {
                    wiauDbgWarning("ValidateDeviceProperties", "Width/height not supported by camera");
                    continue;
                }
                pCurrentPD = &m_PropDescs[pdIdx];
                
                hr = pCurrentPD->m_cbstrCurrent.Copy(T2W(ptcsImageSize));
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "Copy bstr failed");
                    delete []pPropVar;
                    return hr;
                }
    
                //
                // Write the new value to the device
                //
                hr = m_pPTPCamera->SetDevicePropValue(propCode, pCurrentPD);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "SetDevicePropValue failed");
                    delete []pPropVar;
                    return hr;
                }
                
                bWroteWidthHeight = TRUE;
            }
    
            else
            {
                //
                // Find the prop code and prop desc structure
                //
                propCode = PropIdToPropCode(pPropSpecs[count].propid);
                pdIdx = m_DeviceInfo.m_SupportedProps.Find(propCode);
                if (pdIdx < 0)
                {
                    wiauDbgWarning("ValidateDeviceProperties", "Property not supported by camera");
                    continue;
                }
                pCurrentPD = &m_PropDescs[pdIdx];
    
                //
                // Put the new value into the PropSpec structure
                //
                if (pPropVar[count].vt == VT_BSTR)
                {
                    hr = pCurrentPD->m_cbstrCurrent.Copy(pPropVar[count].bstrVal);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "Copy bstr failed");
                        delete []pPropVar;
                        return hr;
                    }
                }
                else if (pPropVar[count].vt == VT_I4)
                {
                    pCurrentPD->m_lCurrent = pPropVar[count].lVal;
                }
                else
                {
                    wiauDbgError("ValidateDeviceProperties", "unsupported variant type");
                    delete []pPropVar;
                    return E_FAIL;
                }
    
                //
                // Write the new value to the device
                //
                hr = m_pPTPCamera->SetDevicePropValue(propCode, pCurrentPD);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "SetDevicePropValue failed");
                    delete []pPropVar;
                    return hr;
                }
            }
        }
        delete []pPropVar;
    }

    return hr;
}

//
// This function finds the corresponding height for a width value, or vice versa. Set the
// value to find to zero.
//
// Input:
//   pWidth -- pointer to the width value
//   pHeight -- pointer to the height value
//
HRESULT
CWiaMiniDriver::FindCorrDimension(BYTE *pWiasContext, LONG *pWidth, LONG *pHeight)
{
    DBG_FN("CWiaMiniDriver::FindCorrDimensions");
    
    HRESULT hr = S_OK;

    if (!pWiasContext ||
        (*pWidth == 0 && *pHeight == 0))
    {
        wiauDbgError("FindCorrDimension", "invalid args");
        return E_INVALIDARG;
    }
    
    PROPSPEC ps[2];
    ULONG af[2];
    PROPVARIANT pv[2];

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_DPC_PICT_WIDTH;
    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = WIA_DPC_PICT_HEIGHT;

    hr = wiasGetPropertyAttributes(pWiasContext, 2, ps, af, pv);
    if (FAILED(hr))
    {
        wiauDbgError("FindCorrDimension", "wiasGetPropertyAttributes failed");
        return E_FAIL;
    }

    int count = 0 ;

    if (af[0] & WIA_PROP_LIST)
    {
        LONG numValues = pv[0].cal.pElems[WIA_LIST_COUNT];
        LONG *pValidWidths = &pv[0].cal.pElems[WIA_LIST_VALUES];
        LONG *pValidHeights = &pv[1].cal.pElems[WIA_LIST_VALUES];

        if (*pWidth == 0)
        {
            //
            // Find the height in the valid values array
            //
            for (count = 0; count < numValues; count++)
            {
                if (pValidHeights[count] == *pHeight)
                {
                    //
                    // Set the width and exit
                    //
                    *pWidth = pValidWidths[count];
                    break;
                }
            }
        }

        else
        {
            //
            // Find the width in the valid values array
            //
            for (count = 0; count < numValues; count++)
            {
                if (pValidWidths[count] == *pWidth)
                {
                    //
                    // Set the height and exit
                    //
                    *pHeight = pValidHeights[count];
                    break;
                }
            }
        }
    }

    else if (af[0] & WIA_PROP_RANGE)
    {
        LONG minWidth   = pv[0].cal.pElems[WIA_RANGE_MIN];
        LONG maxWidth   = pv[0].cal.pElems[WIA_RANGE_MAX];
        LONG stepWidth  = pv[0].cal.pElems[WIA_RANGE_STEP];
        LONG minHeight  = pv[1].cal.pElems[WIA_RANGE_MIN];
        LONG maxHeight  = pv[1].cal.pElems[WIA_RANGE_MAX];
        LONG stepHeight = pv[1].cal.pElems[WIA_RANGE_STEP];

        if (*pWidth == 0)
        {
            //
            // Set the width to the proportionally correct value, clipping to the step value
            //
            *pWidth = FindProportionalValue(*pHeight, minHeight, maxHeight, minWidth, maxWidth, stepWidth);
        }
        else
        {
            //
            // Set the height to the proportionally correct value, clipping to the step value
            //
            *pHeight = FindProportionalValue(*pWidth, minWidth, maxWidth, minHeight, maxHeight, stepHeight);
        }
    }

    return hr;
}

//
// This function takes the proportion of valueX between minX and maxX and uses that to
// find a value of the same proportion between minY and maxY. It then clips that value
// to the step value
//
int CWiaMiniDriver::FindProportionalValue(int valueX, int minX, int maxX, int minY, int maxY, int stepY)
{
    int valueY;

    //
    // Find proportional value
    //
    valueY = (valueX - minX) * (maxY - minY) / (maxX - minX)  + minY;

    //
    // Clip the value to the step
    //
    valueY = ((valueY + ((stepY - 1) / 2)) - minY) / stepY * stepY + minY;

    return valueY;
}


//
// This helper function returns a pointer to the property info structure
// based on the property code
//
// Input:
//   PropCode -- the format code
//
// Output:
//   Returns pointer to the property info structure
//
PPROP_INFO
CWiaMiniDriver::PropCodeToPropInfo(WORD PropCode)
{
    DBG_FN("CWiaMiniDriver::PropCodeToPropInfo");

    PPROP_INFO pPropInfo = NULL;
    UINT index = 0;
    const WORD PROPCODE_MASK = 0x0fff;
    
    if (PropCode & PTP_DATACODE_VENDORMASK)
    {
        //
        // Look up vendor extended PropCode
        //
        pPropInfo = m_VendorPropMap.Lookup(PropCode);
        if (!pPropInfo)
        {
            pPropInfo = &g_PropInfo[0];
        }
    }

    else
    {
        //
        // Look up the prop code in the prop info array
        //
        index = PropCode & PROPCODE_MASK;

        if (index >= g_NumPropInfo)
        {
            index = 0;
        }

        pPropInfo = &g_PropInfo[index];
    }

    return pPropInfo;
}

//
// This helper function returns a pointer to the format info structure
// based on the format code
//
// Input:
//   FormatCode -- the format code
//   AssocType -- association type (for associations)
//
// Output:
//   Returns pointer to the format info structure
//
PFORMAT_INFO
FormatCodeToFormatInfo(WORD FormatCode, WORD AssocType)
{
    DBG_FN("FormatCodeToFormatString");

    PFORMAT_INFO pFormatInfo = NULL;
    UINT index = 0;
    const WORD FORMATCODE_MASK = 0x07ff;
    
    if (FormatCode & PTP_DATACODE_VENDORMASK)
    {
        //
        // WIAFIX-9/6/2000-davepar This should ideally query GDI+ somehow for a filter
        // which the vendor could register
        //
        pFormatInfo = &g_NonImageFormatInfo[0];
    }

    else if (FormatCode == PTP_FORMATCODE_ASSOCIATION)
    {
        //
        // Look up the association type
        //
        index = AssocType;
        
        if (index > g_NumAssocFormatInfo)
        {
            index = 0;
        }
        pFormatInfo = &g_AssocFormatInfo[index];
    }

    else
    {
        //
        // Look up the format code in either the image or non-image format info array
        //
        index = FormatCode & FORMATCODE_MASK;

        if (FormatCode & PTP_FORMATMASK_IMAGE)
        {
            if (index > g_NumImageFormatInfo)
            {
                index = 0;
            }
            pFormatInfo = &g_ImageFormatInfo[index];
        }
        else
        {
            if (index >= g_NumNonImageFormatInfo)
            {
                index = 0;
            }
            pFormatInfo = &g_NonImageFormatInfo[index];
        }
    }

    return pFormatInfo;
}

//
// This function converts a WIA format GUID into a PTP format code
//
WORD
FormatGuidToFormatCode(GUID *pFormatGuid)
{
    WORD count = 0;

    //
    // Look through the image formats first
    //
    for (count = 0; count < g_NumImageFormatInfo; count++)
    {
        if (g_ImageFormatInfo[count].FormatGuid &&
            IsEqualGUID(*pFormatGuid, *(g_ImageFormatInfo[count].FormatGuid)))
        {
            return count | PTP_FORMATCODE_IMAGE_UNDEFINED;
        }
    }

    //
    // Then look through the non image formats
    //
    for (count = 0; count < g_NumNonImageFormatInfo; count++)
    {
        if (g_NonImageFormatInfo[count].FormatGuid &&
            IsEqualGUID(*pFormatGuid, *(g_NonImageFormatInfo[count].FormatGuid)))
        {
            return count | PTP_FORMATCODE_UNDEFINED;
        }
    }

    //
    // The GUID wasn't found in either array
    //
    return PTP_FORMATCODE_UNDEFINED;
}

//
// This function looks up a prop id in the property info array and returns a
// property code for it.
//
WORD
PropIdToPropCode(PROPID PropId)
{
    WORD PropCode;
    for (PropCode = 0; PropCode < g_NumPropInfo; PropCode++)
    {
        if (g_PropInfo[PropCode].PropId == PropId)
        {
            return PropCode | PTP_PROPERTYCODE_UNDEFINED;
        }
    }

    //
    // Not found
    //
    return 0;
}

//
// This function splits a PTP image size string (WXH) into two separate longs
//
VOID
SplitImageSize(
    CBstr cbstr,
    LONG *pWidth,
    LONG *pHeight
    )
{
    USES_CONVERSION;
    
    int num = _stscanf(W2T(cbstr.String()), TEXT("%dx%d"), pWidth, pHeight);

    //
    // The spec mentions "x" as divider, but let's be paranoid and check "X" as well
    //
    if (num != 2)
    {
        num = _stscanf(W2T(cbstr.String()), TEXT("%dX%d"), pWidth, pHeight);
    }

    if (num != 2)
    {
        wiauDbgError("SplitImageSize", "invalid current image dimensions");
        *pWidth = 0;
        *pHeight = 0;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\dllmain.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    dllmain.cpp

Abstract:

    This module implements the dll exported APIs

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include <locale.h>

HINSTANCE g_hInst;

//
// Entry point of this transport DLL
// Input:
//	hInstance   -- Instance handle of this dll
//	dwReason    -- reason why this entry was called.
//	lpReserved  -- reserved!
//
// Output:
//	TRUE	    if our initialization went well
//	FALSE	    if for GetLastError() reason, we failed.
//
BOOL
APIENTRY
DllMain(
        HINSTANCE hInstance,
        DWORD dwReason,
        LPVOID lpReserved
        )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        
        g_hInst = hInstance;
        
        //
        // Set the locale to system default so that wcscmp and similary functions
        // would work on non-unicode platforms(Millenium, for example).
        //
        setlocale(LC_ALL, "");

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return TRUE;
}

STDAPI
DllCanUnloadNow(void)
{
    return CClassFactory::CanUnloadNow();
}


//
// This api returns an inteface on the given class object
// Input:
//	rclsid	-- the class object.
//
STDAPI
DllGetClassObject(
                 REFCLSID    rclsid,
                 REFIID      riid,
                 LPVOID      *ppv
                 )
{
    return CClassFactory::GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\factory.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    factory.h

Abstract:

    Header file that declares CClassFactory object

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __FACTORY_H_
#define __FACTORY_H_


class CClassFactory : public IClassFactory
{
public:

    CClassFactory();

    ~CClassFactory();

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef) ();

    STDMETHOD_(ULONG, Release) ();

    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);

    STDMETHOD(LockServer)(BOOL fLock);

    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
    static HRESULT RegisterAll();
    static HRESULT UnregisterAll();
    static HRESULT CanUnloadNow(void);
    static  LONG    s_Locks;
    static  LONG    s_Objects;

private:
    ULONG   m_Refs;
};

#endif // __FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\factory.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    factory.cpp

Abstract:

    This module implements CClassFactory class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include "dllmain.h"
#include "camera.h"
#include "utils.h"
#include "minidrv.h"
#include "factory.h"


//
// CClassFactory implmentation
//


LONG CClassFactory::s_Locks = 0;
LONG CClassFactory::s_Objects = 0;

CClassFactory::CClassFactory()
: m_Refs(1)
{
}
CClassFactory::~CClassFactory()
{
}

ULONG
CClassFactory::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Refs);
    return m_Refs;
}
ULONG
CClassFactory::Release()
{
    ::InterlockedDecrement((LONG*)&m_Refs);
    if (!m_Refs)
    {
        delete this;
        return 0;
    }
    return m_Refs;
}

STDMETHODIMP
CClassFactory::QueryInterface(
                             REFIID riid,
                             LPVOID*  ppv
                             )
{

    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IClassFactory *)this;
    }
    else if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    if (SUCCEEDED(hr))
        AddRef();
    else
        *ppv = NULL;
    return hr;
}


STDMETHODIMP
CClassFactory::CreateInstance(
                             IUnknown    *pUnkOuter,
                             REFIID       riid,
                             LPVOID      *ppv
                             )
{

    if (!ppv)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    *ppv = NULL;
    CWiaMiniDriver *pWiaMiniDrv;

    if (pUnkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }

    pWiaMiniDrv = new CWiaMiniDriver(pUnkOuter);
    if (pWiaMiniDrv)
    {
        hr = pWiaMiniDrv->NonDelegatingQueryInterface(riid, ppv);
        pWiaMiniDrv->NonDelegatingRelease();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return hr;
}



STDMETHODIMP
CClassFactory::LockServer(
                         BOOL fLock
                         )
{
    if (fLock)
        ::InterlockedIncrement((LONG*)&s_Locks);
    else
        ::InterlockedDecrement((LONG*)&s_Locks);
    return S_OK;
}

HRESULT
CClassFactory::CanUnloadNow()
{
    return(s_Objects || s_Locks) ? S_FALSE : S_OK;
}


//
// This function create a CClassFactory. It is mainly called
// by DllGetClassObject API
// INPUT:
//  rclsid  -- reference to the CLSID
//  riid    -- reference to the interface IID
//  ppv -- interface pointer holder
//
// OUTPUT:
//  S_OK if succeeded else standard OLE error code
//
//
HRESULT
CClassFactory::GetClassObject(
                             REFCLSID rclsid,
                             REFIID   riid,
                             void**   ppv
                             )
{
    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    HRESULT hr = S_OK;


    CClassFactory* pClassFactory;
    pClassFactory = new CClassFactory();
    if (pClassFactory)
    {
        hr = pClassFactory->QueryInterface(riid, ppv);
        pClassFactory->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


HRESULT
CClassFactory::RegisterAll()
{

    //
    // We have nothing to register
    //
    return S_OK;
}

HRESULT
CClassFactory::UnregisterAll()
{

    //
    // We have nothing to unregister
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\imgitem.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    imgitem.cpp

Abstract:

    This module implements image item related function of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

//
// Minimum data call back transfer buffer size
//
const LONG MIN_BUFFER_SIZE   = 0x8000;

//
// Arrays used for setting up valid value lists for properties
//
LONG g_TymedArray[] = {
    TYMED_FILE,
    TYMED_CALLBACK
};

//
// This function initializes the item's properties
// Input:
//  pWiasContext    -- wias service context
//  lFlags      -- misc flags
//  plDevErrVal -- to return device error;
//
HRESULT
CWiaMiniDriver::InitItemProperties(BYTE *pWiasContext)
{
    DBG_FN("CWiaMiniDriver::InitItemProperties");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG ItemType = 0;
    FORMAT_INFO *pFormatInfo = NULL;
    BSTR bstrFileExt = NULL;
    CLSID *pImageFormats = NULL;


    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "wiasGetItemType failed");
        return hr;
    }

    BOOL bBitmap = FALSE;   // Indicates that preferred format is bitmap
    LONG lBytesPerLine = 0;

    //
    // There are no properties for storage items. In fact, there are no driver items created for
    // stores.
    //
    if (ItemType & WiaItemTypeStorage)
        return hr;

    DRVITEM_CONTEXT *pItemCtx;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx, NULL);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // Set up properties that are used for all item types
    //
    CWiauPropertyList ItemProps;
    CPtpObjectInfo *pObjectInfo = pItemCtx->pObjectInfo;

    const INT NUM_ITEM_PROPS = 24;
    hr = ItemProps.Init(NUM_ITEM_PROPS);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "Init failed");
        return hr;
    }

    INT index;

    //
    // WIA_IPA_ITEM_TIME
    //
    SYSTEMTIME SystemTime;
    hr = GetObjectTime(pObjectInfo, &SystemTime);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "GetObjectTime failed");
        return hr;
    }

    hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    ItemProps.SetCurrentValue(index, &SystemTime);

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    LONG lProtection;
    hr = IsObjectProtected(pObjectInfo, lProtection);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "IsObjectProtected failed");
        return hr;
    }

    hr = ItemProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_FLAG | WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    //
    // If device does not support delete command, access rights are always Read-Only
    //
    if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_DELETEOBJECT) < 0)
    {
        lProtection = WIA_PROP_READ;
        ItemProps.SetCurrentValue(index, lProtection);
    }
    else
    {
        //
        // If device supports the SetObjectProtection command, item access rights is r/w
        //
        if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_SETOBJECTPROTECTION) >= 0)
        {
            ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_FLAG);
            ItemProps.SetValidValues(index, lProtection, lProtection, WIA_ITEM_RWD);
        }
        else
        {
            ItemProps.SetCurrentValue(index, lProtection);
        }
    }

    pFormatInfo = FormatCodeToFormatInfo(pObjectInfo->m_FormatCode);

    //
    // WIA_IPA_FILENAME_EXTENSION
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    if(pFormatInfo->ExtString && pFormatInfo->ExtString[0]) {
        bstrFileExt = SysAllocString(pFormatInfo->ExtString);
    } else {
        if(pObjectInfo->m_cbstrExtension.Length()) {
            bstrFileExt = SysAllocString(pObjectInfo->m_cbstrExtension.String());
        }
    }
    ItemProps.SetCurrentValue(index, bstrFileExt);

    //
    // Set up properties common to files
    //
    if (ItemType & WiaItemTypeFile)
    {
        //
        // WIA_IPA_PREFERRED_FORMAT
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pFormatInfo->FormatGuid);

        bBitmap = IsEqualGUID(WiaImgFmt_BMP, *pFormatInfo->FormatGuid) ||
                  IsEqualGUID(WiaImgFmt_MEMORYBMP, *pFormatInfo->FormatGuid);

        //
        // WIA_IPA_FORMAT
        //
        // For images, BMP may also be added below
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_LIST);
        ItemProps.SetCurrentValue(index, pFormatInfo->FormatGuid);
        ItemProps.SetValidValues(index, pFormatInfo->FormatGuid, pFormatInfo->FormatGuid,
                                 1, &pFormatInfo->FormatGuid);

        //
        // WIA_IPA_COMPRESSION
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_COMPRESSION_NONE);

        //
        // WIA_IPA_TYMED
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_TYMED, WIA_IPA_TYMED_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        if (FAILED(hr)) goto failure;
        ItemProps.SetValidValues(index, TYMED_FILE, TYMED_FILE,
                                 sizeof(g_TymedArray) / sizeof(g_TymedArray[0]), g_TymedArray);

        //
        // WIA_IPA_ITEM_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        if (bBitmap) {
            lBytesPerLine = ((pObjectInfo->m_ImagePixWidth * pObjectInfo->m_ImageBitDepth + 31) & ~31) / 8;
            ItemProps.SetCurrentValue(index, (LONG) (lBytesPerLine * pObjectInfo->m_ImagePixHeight));
        }
        else
            ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_CompressedSize);

        //
        // WIA_IPA_MIN_BUFFER_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        LONG minBufSize;
        if (!bBitmap && pObjectInfo->m_CompressedSize > 0)
            minBufSize = min(MIN_BUFFER_SIZE, pObjectInfo->m_CompressedSize);
        else
            minBufSize = MIN_BUFFER_SIZE;
        ItemProps.SetCurrentValue(index, minBufSize);
    }

    //
    // Set up the image-only properties
    //
    if (ItemType & WiaItemTypeImage)
    {
        //
        // WIA_IPA_DATATYPE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        if(pObjectInfo->m_ImageBitDepth <= 8) {
            ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_GRAYSCALE);
        } else {
            ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_COLOR);
        }

        //
        // WIA_IPA_DEPTH
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ImageBitDepth);

        //
        // WIA_IPA_FORMAT
        //
        // If the image format is something that can be converted, change the access to
        // read/write and add BMP to the valid value list.
        //
        if (pFormatInfo->FormatGuid) 
        {
            index = ItemProps.LookupPropId(WIA_IPA_FORMAT);
            ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_LIST);
            pImageFormats = new CLSID[3];
            if(!pImageFormats) {
                wiauDbgError("InitItemProperties", "failed to allocate 3 GUIDs");
                hr = E_OUTOFMEMORY;
                goto failure;
            }
            pImageFormats[0] = *pFormatInfo->FormatGuid;
            pImageFormats[1] = WiaImgFmt_BMP;
            pImageFormats[2] = WiaImgFmt_MEMORYBMP;
            ItemProps.SetValidValues(index, pFormatInfo->FormatGuid, pFormatInfo->FormatGuid,
                                     3,
                                     &pImageFormats);
        }

        //
        // WIA_IPA_CHANNELS_PER_PIXEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) (pObjectInfo->m_ImageBitDepth == 8 ? 1 : 3));

        //
        // WIA_IPA_BITS_PER_CHANNEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) 8);

        //
        // WIA_IPA_PLANAR
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_PACKED_PIXEL);

        //
        // WIA_IPA_PIXELS_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ImagePixWidth);

        //
        // WIA_IPA_BYTES_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        if (bBitmap)
            lBytesPerLine;
        else
            ItemProps.SetCurrentValue(index, (LONG) 0);

        //
        // WIA_IPA_NUMBER_OF_LINES
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ImagePixHeight);

        //
        // WIA_IPC_SEQUENCE
        //
        if (pObjectInfo->m_SequenceNumber > 0)
        {
            hr = ItemProps.DefineProperty(&index, WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            if (FAILED(hr)) goto failure;
            ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_SequenceNumber);
        }

        //
        // WIA_IPC_TIMEDELAY
        //
        // This property needs to be populated from the AssociationDesc field in the parent's ObjectInfo
        // structure, but only if the parent's AssociationType field is TimeSequence.

        // WIAFIX-10/3/2000-davepar Implement this property
    }

    //
    // Set up properties common to image and video items that have
    // thumbnails
    //
    if (ItemType & (WiaItemTypeImage | WiaItemTypeVideo) && pObjectInfo->m_ThumbPixWidth)
    {
        //
        // WIA_IPC_THUMBNAIL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);

        //
        // WIA_IPC_THUMB_WIDTH
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ThumbPixWidth);

        //
        // WIA_IPC_THUMB_HEIGHT
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ThumbPixHeight);

    }

    //
    // Last step: send all the properties to WIA
    //
    hr = ItemProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "InitItemProperties", "SendToWia failed");
        goto failure;
    }

    if (bstrFileExt)
        SysFreeString(bstrFileExt);

    delete [] pImageFormats;

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //
    failure:

        delete [] pImageFormats;
    
        if (bstrFileExt)
            SysFreeString(bstrFileExt);

        wiauDbgErrorHr(hr, "InitItemProperties", "DefineProperty failed");
        return hr;
}

//
// This function determines the protection status (whether an object can be
// deleted or written to) of an object on the device.
//
// Input:
//   pObjectInfo -- pointer to the ObjectInfo structure
// Output:
//   bProtected -- indicates whether the object is protected
//
HRESULT
CWiaMiniDriver::IsObjectProtected(
    CPtpObjectInfo *pObjectInfo,
    LONG &lProtection)
{
    DBG_FN("CWiaMiniDriver::IsObjectProtected");

    HRESULT hr = S_OK;
    lProtection = WIA_ITEM_READ;

    if (!pObjectInfo)
    {
        wiauDbgError("ObjectProtected", "invalid arg");
        return E_INVALIDARG;
    }

    if (pObjectInfo->m_ProtectionStatus == PTP_PROTECTIONSTATUS_READONLY)
        return hr;

    //
    // Check the protection status of the store as well
    //
    INT storeIndex = m_StorageIds.Find(pObjectInfo->m_StorageId);
    if (storeIndex < 0)
    {
        wiauDbgWarning("ObjectProtected", "couldn't find the object's store");
        return hr;
    }

    switch (m_StorageInfos[storeIndex].m_AccessCapability)
    {
    case PTP_STORAGEACCESS_RWD:
        lProtection = WIA_ITEM_RWD;
        break;

    case PTP_STORAGEACCESS_R:
        lProtection = WIA_ITEM_READ;
        break;

    case PTP_STORAGEACCESS_RD:
        lProtection = WIA_ITEM_RD;
        break;

    default:
        //
        // Not a fatal error, but this is an unknown access capability. Use read-only.
        //
        wiauDbgError("ObjectProtected", "unknown storage access capability");
        lProtection = WIA_ITEM_READ;
        break;
    }

    return hr;
}

//
// This function gets the object time and converts it to a system time
//
// Input:
//  pObjNode  -- the object
//  pSystemTime -- to receive the object time
// Output:
//  HRESULT
//
HRESULT
CWiaMiniDriver::GetObjectTime(
    CPtpObjectInfo *pObjectInfo,
    SYSTEMTIME  *pSystemTime
    )
{
    DBG_FN("CWiaMiniDriver::GetObjectTime");

    HRESULT hr = S_OK;

    CBstr *pTimeStr = NULL;

    if (!pObjectInfo || !pSystemTime)
    {
        wiauDbgError("GetObjectTime", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Try to use the modification date, then the capture date
    //
    if (pObjectInfo->m_cbstrModificationDate.Length() > 0)
        pTimeStr = &pObjectInfo->m_cbstrModificationDate;

    else if (pObjectInfo->m_cbstrCaptureDate.Length() > 0)
        pTimeStr = &pObjectInfo->m_cbstrCaptureDate;


    //
    // See if a valid date/time was found, otherwise use system time
    //
    if (pTimeStr)
    {
        hr = PtpTime2SystemTime(pTimeStr, pSystemTime);
        if (FAILED(hr))
        {
            wiauDbgError("GetObjectTime", "PtpTime2SystemTime failed");
            return hr;
        }
    }
    else
    {
        GetLocalTime(pSystemTime);
    }

    return hr;
}

//
// This function reads item properties. In this situation, only the thumbnail
// properties are important.
//
// Input:
//   pWiasContext -- wia service context
//   NumPropSpecs -- number of properties to read
//   pPropSpecs   -- what properties to read
//
HRESULT
CWiaMiniDriver::ReadItemProperties(
    BYTE    *pWiasContext,
    LONG    NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaMiniDriver::ReadItemProperties");

    HRESULT hr = S_OK;

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("ReadItemProperties", "wiasGetItemType failed");
        return hr;
    }

    PDRVITEM_CONTEXT pItemCtx = NULL;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("ReadItemProperties", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // For all items (except the root or stores), update the item time if requested. The time may
    // have been updated by an ObjectInfoChanged event.
    //
    if (IsItemTypeFolder(ItemType) || ItemType & WiaItemTypeFile)
    {
        if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_ITEM_TIME))
        {
            SYSTEMTIME SystemTime;
            hr = GetObjectTime(pItemCtx->pObjectInfo, &SystemTime);
            if (FAILED(hr))
            {
                wiauDbgError("ReadItemProperties", "GetObjectTime failed");
                return hr;
            }

            PROPVARIANT propVar;
            PROPSPEC    propSpec;
            propVar.vt = VT_VECTOR | VT_UI2;
            propVar.caui.cElems = sizeof(SystemTime) / sizeof(WORD);
            propVar.caui.pElems = (WORD *) &SystemTime;
            propSpec.ulKind = PRSPEC_PROPID;
            propSpec.propid = WIA_IPA_ITEM_TIME;
            hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar );
            if (FAILED(hr))
            {
                wiauDbgError("ReadItemProperties", "wiasWriteMultiple failed");
                return hr;
            }
        }
    }

    if(ItemType & WiaItemTypeImage && pItemCtx->pObjectInfo->m_ImagePixWidth == 0) {
        // image geometry is missing -- see if this is what we are asked 
        PROPID propsToUpdate[] = {
            WIA_IPA_PIXELS_PER_LINE,
            WIA_IPA_NUMBER_OF_LINES
            };
        
        if(wiauPropsInPropSpec(NumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {
            // we can deal with any image as long as GDI+ understands it
            UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
            UINT width, height, depth;

            wiauDbgWarning("ReadImageProperties", "Retrieving missing geometry! Expensive!");
                
            //
            // Allocate memory for the native image
            //
            BYTE *pNativeImage = new BYTE[NativeImageSize];
            if(pNativeImage == NULL) {
                return E_OUTOFMEMORY;
            }

            //
            // Get the data from the camera
            //
            hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                             pNativeImage, &NativeImageSize,  (LPVOID) 0);
            if(hr == S_FALSE) {
                wiauDbgWarning("ReadItemProperties", "GetObjectData() cancelled");
                delete [] pNativeImage;
                return S_FALSE;
            }
            
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "GetObjectData() failed");
                delete [] pNativeImage;
                return S_FALSE;
            }    

            //
            // get image geometry, discard native image
            //
            if(pItemCtx->pObjectInfo->m_FormatCode == PTP_FORMATCODE_IMAGE_EXIF ||
               pItemCtx->pObjectInfo->m_FormatCode == PTP_FORMATCODE_IMAGE_JFIF)
            {
                hr = GetJpegDimensions(pNativeImage, NativeImageSize, &width, &height, &depth);
            } else {
                hr = GetImageDimensions(pItemCtx->pObjectInfo->m_FormatCode, pNativeImage, NativeImageSize, &width, &height, &depth);
            }
            delete [] pNativeImage;
                
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "failed to get image geometry from compressed image");
                return hr;
            }

            pItemCtx->pObjectInfo->m_ImagePixWidth = width;
            pItemCtx->pObjectInfo->m_ImagePixHeight = height;
            
            hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, width);
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "failed to write image width");
                return hr;
            }
            
            hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, height);
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "failed to set image height");
                return hr;
            }
        }
    }

    //
    // For images and video, update the thumbnail properties if requested
    //
    if (ItemType & (WiaItemTypeImage | WiaItemTypeVideo))
    {
        //
        // Get the thumbnail if requested to update any of the thumbnail properties and
        // the thumbnail is not already cached.
        //
        PROPID propsToUpdate[] = {
            WIA_IPC_THUMB_WIDTH,
            WIA_IPC_THUMB_HEIGHT,
            WIA_IPC_THUMBNAIL
            };

        if (wiauPropsInPropSpec(NumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {
            if (!pItemCtx->pThumb)
            {
                hr = CacheThumbnail(pItemCtx);
                if (FAILED(hr))
                {
                    wiauDbgError("ReadItemProperties", "CacheThumbnail failed");
                    return hr;
                }
            }

            //
            // Update the related thumbnail properties. Update the thumb width and height in case
            // the device didn't report them in the ObjectInfo structure (they are optional there).
            //
            PROPSPEC propSpecs[3];
            PROPVARIANT propVars[3];

            propSpecs[0].ulKind = PRSPEC_PROPID;
            propSpecs[0].propid = WIA_IPC_THUMB_WIDTH;
            propVars[0].vt = VT_I4;
            propVars[0].lVal = pItemCtx->pObjectInfo->m_ThumbPixWidth;

            propSpecs[1].ulKind = PRSPEC_PROPID;
            propSpecs[1].propid = WIA_IPC_THUMB_HEIGHT;
            propVars[1].vt = VT_I4;
            propVars[1].lVal = pItemCtx->pObjectInfo->m_ThumbPixHeight;

            propSpecs[2].ulKind = PRSPEC_PROPID;
            propSpecs[2].propid = WIA_IPC_THUMBNAIL;
            propVars[2].vt = VT_VECTOR | VT_UI1;
            propVars[2].caub.cElems = pItemCtx->ThumbSize;
            propVars[2].caub.pElems = pItemCtx->pThumb;

            hr = wiasWriteMultiple(pWiasContext, 3, propSpecs, propVars);
            if (FAILED(hr))
            {
                wiauDbgError("ReadItemProperties", "wiasWriteMultiple failed");
                delete pItemCtx->pThumb;
                pItemCtx->pThumb = NULL;
            }
        }
    }

    return hr;
}

//
// This function caches the thumbnail into the given DRVITEM_CONTEXT
//
// Input:
//   pItemCtx -- the designated DRVITEM_CONTEXT
//
HRESULT
CWiaMiniDriver::CacheThumbnail(PDRVITEM_CONTEXT pItemCtx)
{
    DBG_FN("CWiaMiniDriver::CacheThumbnail");

    HRESULT hr = S_OK;

    if (pItemCtx->pThumb)
    {
        wiauDbgError("CacheThumbnail", "thumbnail is already cached");
        return E_FAIL;
    }

    CPtpObjectInfo *pObjectInfo = pItemCtx->pObjectInfo;
    if (!pObjectInfo) {
        wiauDbgError("CacheThumbnail", "Object info pointer is null");
        return E_FAIL;
    }

    if (pObjectInfo->m_ThumbCompressedSize <= 0)
    {
        wiauDbgWarning("CacheThumbnail", "No thumbnail available for this item");
        return hr;
    }

    //
    // We have to load the thumbnail in its native format
    //
    BYTE *pNativeThumb;
    pNativeThumb = new BYTE[pObjectInfo->m_ThumbCompressedSize];
    if (!pNativeThumb)
    {
        wiauDbgError("CacheThumbnail", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    UINT size = pObjectInfo->m_ThumbCompressedSize;
    hr = m_pPTPCamera->GetThumb(pObjectInfo->m_ObjectHandle, pNativeThumb, &size);
    if (FAILED(hr))
    {
        wiauDbgError("CacheThumbnail", "GetThumb failed");
        delete []pNativeThumb;
        return hr;
    }

    //
    // Figure out what base image format the thumbnail is in. Note that BMP thumbnails
    // are not allowed currently.
    //
    BOOL bTiff = FALSE;
    BOOL bJpeg = FALSE;

    if (PTP_FORMATCODE_IMAGE_TIFF == pObjectInfo->m_ThumbFormat ||
        PTP_FORMATCODE_IMAGE_TIFFEP == pObjectInfo->m_ThumbFormat ||
        PTP_FORMATCODE_IMAGE_TIFFIT == pObjectInfo->m_ThumbFormat)
        bTiff = TRUE;

    else if (PTP_FORMATCODE_IMAGE_EXIF == pObjectInfo->m_ThumbFormat ||
             PTP_FORMATCODE_IMAGE_JFIF == pObjectInfo->m_ThumbFormat)
        bJpeg = TRUE;

    else
    {
        wiauDbgWarning("CacheThumbnail", "unknown thumbnail format");
        delete []pNativeThumb;
        return hr;
    }

    //
    // If the thumbnail format is JPEG or TIFF, get the real thumbnail
    // width and height from the header information.
    //
    UINT BitDepth;
    UINT width, height;
    if (bTiff)
    {
        hr = GetTiffDimensions(pNativeThumb,
                               pObjectInfo->m_ThumbCompressedSize,
                               &width,
                               &height,
                               &BitDepth);
    }

    else if (bJpeg)
    {
        hr  = GetJpegDimensions(pNativeThumb,
                                pObjectInfo->m_ThumbCompressedSize,
                                &width,
                                &height,
                                &BitDepth);
    }

    if (FAILED(hr))
    {
        wiauDbgError("CacheThumbnail", "get image dimensions failed");
        delete []pNativeThumb;
        return hr;
    }

    pObjectInfo->m_ThumbPixWidth  = width;
    pObjectInfo->m_ThumbPixHeight = height;

    //
    // Calculate the size of the headerless BMP and allocate space for it
    //
    ULONG LineSize;
    LineSize = GetDIBLineSize(pObjectInfo->m_ThumbPixWidth, 24);
    pItemCtx->ThumbSize = LineSize * pObjectInfo->m_ThumbPixHeight;
    pItemCtx->pThumb = new BYTE [pItemCtx->ThumbSize];
    if (!pItemCtx->pThumb)
    {
        wiauDbgError("CacheThumbnail", "memory allocation failure");
        delete []pNativeThumb;
        return E_OUTOFMEMORY;
    }

    //
    // Convert the thumbnail format to headerless BMP
    //
    if (bTiff)
    {
        hr = Tiff2DIBBitmap(pNativeThumb,
                            pObjectInfo->m_ThumbCompressedSize,
                            pItemCtx->pThumb + LineSize * (height - 1),
                            pItemCtx->ThumbSize,
                            LineSize,
                            0
                           );
    }
    else if (bJpeg)
    {
        hr = Jpeg2DIBBitmap(pNativeThumb,
                            pObjectInfo->m_ThumbCompressedSize,
                            pItemCtx->pThumb + LineSize * (height - 1),
                            pItemCtx->ThumbSize,
                            LineSize,
                            0
                           );
    }

    if (FAILED(hr))
    {
        wiauDbgError("CacheThumbnail", "conversion to bitmap failed");
        delete []pNativeThumb;
        delete []pItemCtx->pThumb;
        pItemCtx->pThumb = NULL;
        return hr;
    }

    delete []pNativeThumb;

    return hr;
}

//
// This function validates the given item properties.
//
// Input:
//   pWiasContext -- wia service context
//   NumPropSpecs -- number of properties to validate
//   pPropSpecs -- the properties
//
HRESULT
CWiaMiniDriver::ValidateItemProperties(
    BYTE    *pWiasContext,
    LONG    NumPropSpecs,
    const PROPSPEC *pPropSpecs,
    LONG ItemType
    )
{
    DBG_FN("CWiaMiniDriver::ValidateItemProperties");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    FORMAT_INFO *pFormatInfo = NULL;

    DRVITEM_CONTEXT *pItemCtx;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("ValidateItemProperties", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // If access rights are changed, send the new value to the camera
    //
    // WIAFIX-10/3/2000-davepar To be 100% correct, a change in the store protection should
    // update the access rights for all of the items on the store. This could be done in response
    // to a StoreInfoChanged event.
    //
    if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_ACCESS_RIGHTS))
    {
        LONG rights;
        hr = wiasReadPropLong(pWiasContext, WIA_IPA_ACCESS_RIGHTS, &rights, NULL, TRUE);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "wiasReadPropLong");
            return hr;
        }

        WORD objProt = (rights == WIA_ITEM_READ) ? PTP_PROTECTIONSTATUS_READONLY : PTP_PROTECTIONSTATUS_NONE;
        hr = m_pPTPCamera->SetObjectProtection(pItemCtx->pObjectInfo->m_ObjectHandle, objProt);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "SetObjectProtection failed");
            return hr;
        }
    }

    //
    // Update the valid formats by calling a WIA service function
    //
    BOOL bFormatChanged = FALSE;

    if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_TYMED))
    {
        WIA_PROPERTY_CONTEXT PropContext;
        hr = wiasCreatePropContext(NumPropSpecs, (PROPSPEC*) pPropSpecs, 0, NULL, &PropContext);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "wiasCreatePropContext failed");
            return hr;
        }

        hr = wiasUpdateValidFormat(pWiasContext, &PropContext, (IWiaMiniDrv*) this);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "wiasUpdateValidFormat failed");
            return hr;
        }

        hr = wiasFreePropContext(&PropContext);
        if (FAILED(hr)) {
            wiauDbgError("ValidateItemProperties", "wiasFreePropContext failed");
            return hr;
        }

        bFormatChanged = TRUE;
    }

    //
    // The only property change that needs to be validated is a change of format on an image
    // item. In that case, the item's size and bytes per line, and file extension need to be updated.
    //
    if (ItemType & WiaItemTypeImage &&
        (bFormatChanged || wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_FORMAT)))
    {

        if(pItemCtx->pObjectInfo->m_ImagePixWidth == 0) {
            // one of those cameras
            GUID fmt;
            hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &fmt, NULL, false);
            if(FAILED(hr)) {
                wiauDbgError("ValidateItemProperies", "Failed to retrieve new format GUID");
            }
            if(fmt == WiaImgFmt_BMP || fmt == WiaImgFmt_MEMORYBMP) {
                // for uncompressed transfers -- 
                // tell service we don't know item size 
                wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, 0);
            } else {
                // for any other transfers -- tell serivce that
                // compressed size is the item size
                wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, pItemCtx->pObjectInfo->m_CompressedSize);
            }
        } else {
            pFormatInfo = FormatCodeToFormatInfo(pItemCtx->pObjectInfo->m_FormatCode);

            hr = wiauSetImageItemSize(pWiasContext, pItemCtx->pObjectInfo->m_ImagePixWidth,
                                      pItemCtx->pObjectInfo->m_ImagePixHeight,
                                      pItemCtx->pObjectInfo->m_ImageBitDepth,
                                      pItemCtx->pObjectInfo->m_CompressedSize,
                                      pFormatInfo->ExtString);
            if (FAILED(hr))
            {
                wiauDbgError("ValidateItemProperties", "SetImageItemSize failed");
                return hr;
            }
        }
    }

    //
    // Call WIA service helper to check against valid values
    //
    hr = wiasValidateItemProperties(pWiasContext, NumPropSpecs, pPropSpecs);
    if (FAILED(hr))
    {
        wiauDbgWarning("ValidateDeviceProperties", "wiasValidateItemProperties failed");
        return hr;
    }

    return hr;
}

ULONG GetBitmapHeaderSize(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    UINT colormapsize = 0;
    UINT size = sizeof(BITMAPINFOHEADER);
    
    switch(pmdtc->lCompression) {
    case WIA_COMPRESSION_NONE: // BI_RGB
    case WIA_COMPRESSION_BI_RLE4:
    case WIA_COMPRESSION_BI_RLE8:
        switch(pmdtc->lDepth) {
        case 1:
            colormapsize = 2;
            break;
        case 4:
            colormapsize = 16;
            break;
        case 8:
            colormapsize = 256;
            break;
        case 15:
        case 16:
        case 32:
            colormapsize = 3;
            break;
        case 24:
            colormapsize = 0;
            break;
        }
    }

    size += colormapsize * sizeof(RGBQUAD);
    
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP)) {
        size += sizeof(BITMAPFILEHEADER);
    }

    return size;
}

VOID
VerticalFlip(
    PBYTE pImageTop,
    LONG  iWidthInBytes,
    LONG  iHeight)
{
    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,iWidthInBytes);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * iWidthInBytes;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,iWidthInBytes);
            memcpy(pImageTop,pImageBottom,iWidthInBytes);
            memcpy(pImageBottom,pBuffer,iWidthInBytes);

            pImageTop    += iWidthInBytes;
            pImageBottom -= iWidthInBytes;
        }

        LocalFree(pBuffer);
    }
}


HRESULT
CWiaMiniDriver::AcquireAndTranslateAnyImage(
    BYTE *pWiasContext,
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
#define REQUIRE(x, y) if(!(x)) { wiauDbgError("AcquireAndTranslateAnyImage", y); goto Cleanup; }
    DBG_FN("CWiaMiniDriver::AcquireAndTranslateAnyImage");
    HRESULT hr = S_OK;
    BYTE *pNativeImage = NULL;
    BYTE *pRawImageBuffer = NULL;
    BOOL bPatchedMDTC = FALSE;
    UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
    UINT width, height, depth, imagesize, headersize;
    BOOL bFileTransfer = (pmdtc->tymed & TYMED_FILE);
    LONG lMsg = (bFileTransfer ? IT_MSG_STATUS : IT_MSG_DATA);
    LONG percentComplete;


    // we can deal with any image as long as GDIPlus can handle it

    //
    // Allocate memory for the native image
    //
    pNativeImage = new BYTE[NativeImageSize];
    hr = E_OUTOFMEMORY;
    REQUIRE(pNativeImage, "memory allocation failed");

    //
    // Get the data from the camera
    //
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                     pNativeImage, &NativeImageSize, (LPVOID) pmdtc);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "GetObjectData failed");

    //
    // decompress image, retrieve its geometry
    //
    hr = ConvertAnyImageToBmp(pNativeImage, NativeImageSize, &width, &height, &depth, &pRawImageBuffer, &imagesize, &headersize);
    REQUIRE(hr == S_OK, "failed to convert image to bitmap format");

    pmdtc->lWidthInPixels = pItemCtx->pObjectInfo->m_ImagePixWidth = width;
    pmdtc->cbWidthInBytes = (width * depth) / 8L;
    pmdtc->lLines = pItemCtx->pObjectInfo->m_ImagePixHeight = height;
    pmdtc->lDepth = pItemCtx->pObjectInfo->m_ImageBitDepth = depth;
    pmdtc->lImageSize = imagesize = ((width * depth) / 8L) * height;
    
    if(IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        pmdtc->lHeaderSize = headersize - sizeof(BITMAPFILEHEADER); 
    } else {
        pmdtc->lHeaderSize = headersize;
    }
    pmdtc->lItemSize = pmdtc->lImageSize + pmdtc->lHeaderSize;

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, width);
    REQUIRE(hr == S_OK, "failed to set image width");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, height);
    REQUIRE(hr == S_OK, "failed to set image height");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, 0);
    REQUIRE(hr == S_OK, "failed to set item size");


    // setup buffer for uncompressed image
    if(pmdtc->pTransferBuffer == NULL) {
        if(IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
            pmdtc->pTransferBuffer = pRawImageBuffer + sizeof(BITMAPFILEHEADER);
        } else {
            pmdtc->pTransferBuffer = pRawImageBuffer;
        }
        pmdtc->lBufferSize = pmdtc->lItemSize;
        bPatchedMDTC = TRUE;
    } else {
        if(IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
            memcpy(pmdtc->pTransferBuffer, pRawImageBuffer + sizeof(BITMAPFILEHEADER),
                   pmdtc->lHeaderSize);
        } else {
            memcpy(pmdtc->pTransferBuffer, pRawImageBuffer, pmdtc->lHeaderSize);
        }
    }
    
    //
    // Send the header to the app
    //
    percentComplete = 90 + (10 * pmdtc->lHeaderSize) / pmdtc->lItemSize;

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
        percentComplete, 0, pmdtc->lHeaderSize, pmdtc, 0);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "sending header to app failed");

    if(bFileTransfer) {
        // write the whole image to file
        ULONG   ulWritten;
        BOOL    bRet;

        //
        //  NOTE:  The mini driver transfer context should have the
        //  file handle as a pointer, not a fixed 32-bit long.  This
        //  may not work on 64bit.
        //
        
        bRet = WriteFile((HANDLE)ULongToPtr(pmdtc->hFile),
                         pRawImageBuffer,
                         pmdtc->lItemSize,
                         &ulWritten,
                         NULL);
        
        if (!bRet) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgError("AcquireAndTranslateAnyImage", "WriteFile failed (0x%X)", hr);
        }
    } else {
        LONG BytesToWrite, BytesLeft = pmdtc->lImageSize;
        BYTE *pCurrent = pRawImageBuffer + headersize;
        UINT offset = pmdtc->lHeaderSize;

        while(BytesLeft) {
            BytesToWrite = min(pmdtc->lBufferSize, BytesLeft);
            memcpy(pmdtc->pTransferBuffer, pCurrent, BytesToWrite);

                //
                // Calculate the percentage done using 90 as a base. This makes a rough assumption that
                // transferring the data from the device takes 90% of the time. If the this is the last
                // transfer, set the percentage to 100, otherwise make sure it is never larger than 99.
                //
            if (BytesLeft == BytesToWrite)
                percentComplete = 100;
            else
                percentComplete = min(99, 90 + (10 * offset) / pmdtc->lItemSize);

            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                percentComplete, offset, BytesToWrite, pmdtc, 0);
            REQUIRE(hr != S_FALSE, "transfer cancelled");
            REQUIRE(SUCCEEDED(hr), "sending header to app failed");

            pCurrent += BytesToWrite;
            offset += BytesToWrite;
            BytesLeft -= BytesToWrite;
        }
    }

Cleanup:    
    delete [] pNativeImage;
    delete [] pRawImageBuffer;

    // restore mdtc
    pmdtc->lItemSize = 0;

    if(bPatchedMDTC) {
        pmdtc->pTransferBuffer = 0;
        pmdtc->lBufferSize = 0;
    }

    return hr;
#undef REQUIRE    
}



HRESULT
CWiaMiniDriver::AcquireAndTranslateJpegWithoutGeometry(
    BYTE *pWiasContext,
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
#define REQUIRE(x, y) if(!(x)) { wiauDbgError("AcquireAndTranslateWithoutGeometry", y); goto Cleanup; }
    DBG_FN("CWiaMiniDriver::AcquireAndTranslateWithoutGeometry");
    HRESULT hr = E_FAIL;
    BYTE *pNativeImage = NULL;
    BYTE *pRawImageBuffer = NULL;
    BOOL bPatchedMDTC = FALSE;
    UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
    UINT width, height, depth, imagesize, headersize;
    BOOL bFileTransfer = (pmdtc->tymed & TYMED_FILE);
    LONG lMsg = (bFileTransfer ? IT_MSG_STATUS : IT_MSG_DATA);
    LONG percentComplete;

    // we can only deal with JPEG images
    if(pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_JFIF &&
       pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_EXIF)
    {
        hr = E_INVALIDARG;
        REQUIRE(0, "don't know how to get image geometry from non-JPEG image");
    }

    //
    // Allocate memory for the native image
    //
    pNativeImage = new BYTE[NativeImageSize];
    hr = E_OUTOFMEMORY;
    REQUIRE(pNativeImage, "memory allocation failed");

    //
    // Get the data from the camera
    //
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                     pNativeImage, &NativeImageSize, (LPVOID) pmdtc);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "GetObjectData failed");


    //
    // get image geometry
    //
    hr = GetJpegDimensions(pNativeImage, NativeImageSize, &width, &height, &depth);
    REQUIRE(hr == S_OK, "failed to get image geometry from JPEG file");

    pmdtc->lWidthInPixels = pItemCtx->pObjectInfo->m_ImagePixWidth = width;
    pmdtc->lLines = pItemCtx->pObjectInfo->m_ImagePixHeight = height;
    pmdtc->lDepth = pItemCtx->pObjectInfo->m_ImageBitDepth = depth;
    pmdtc->lImageSize = imagesize = ((((width + 31) * depth) / 8L) & 0xFFFFFFFC) * height;
    pmdtc->lHeaderSize = headersize = GetBitmapHeaderSize(pmdtc);
    pmdtc->lItemSize = imagesize + headersize;

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, width);
    REQUIRE(hr == S_OK, "failed to set image width");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, height);
    REQUIRE(hr == S_OK, "failed to set image height");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, 0);
    REQUIRE(hr == S_OK, "failed to set item size");


    // setup buffer for uncompressed image
    pRawImageBuffer = new BYTE[pmdtc->lImageSize + pmdtc->lHeaderSize];
    REQUIRE(pRawImageBuffer, "failed to allocate intermdiate buffer");
    if(pmdtc->pTransferBuffer == NULL) {
        pmdtc->pTransferBuffer = pRawImageBuffer;
        pmdtc->lBufferSize = pmdtc->lItemSize;
        bPatchedMDTC = TRUE;
    }

    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
    REQUIRE(SUCCEEDED(hr), "wiasGetImageInformation failed");

    percentComplete = 90 + (10 * pmdtc->lHeaderSize) / pmdtc->lItemSize;
    
    //
    // Send the header to the app
    //
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        UNALIGNED BITMAPINFOHEADER*   pbmih   = (BITMAPINFOHEADER*)pmdtc->pTransferBuffer;
        
        pbmih->biHeight = -pmdtc->lLines;
    }

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
        percentComplete, 0, pmdtc->lHeaderSize, pmdtc, 0);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "sending header to app failed");

    //
    // Convert the image to BMP
    //
    hr = Jpeg2DIBBitmap(pNativeImage, NativeImageSize,
                        pRawImageBuffer + pmdtc->lHeaderSize + pmdtc->cbWidthInBytes * (pmdtc->lLines - 1),
                        pmdtc->lImageSize, pmdtc->cbWidthInBytes, 1);
    REQUIRE(SUCCEEDED(hr), "image format conversion failed");

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        VerticalFlip(pRawImageBuffer + pmdtc->lHeaderSize, pmdtc->cbWidthInBytes, pmdtc->lLines);
    }
    
    if(bFileTransfer) {
        // write the whole image to file
#ifdef UNICODE        
        hr = wiasWriteBufToFile(0, pmdtc);
#else
        if (pmdtc->lItemSize <= pmdtc->lBufferSize) {
            ULONG   ulWritten;
            BOOL    bRet;

        //
        //  NOTE:  The mini driver transfer context should have the
        //  file handle as a pointer, not a fixed 32-bit long.  This
        //  may not work on 64bit.
        //

            bRet = WriteFile((HANDLE)pmdtc->hFile,
                             pmdtc->pTransferBuffer,
                             pmdtc->lItemSize,
                             &ulWritten,
                             NULL);

            if (!bRet) {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                wiauDbgError("AcquireDataAndTranslate", "WriteFile failed (0x%X)", hr);
            }
        }
        else {
            wiauDbgError("AcquireDataAndTranslate", "lItemSize is larger than buffer");
            hr = E_FAIL;
        }

#endif        
        REQUIRE(SUCCEEDED(hr), "writing image body to file");
    } else {
        LONG BytesToWrite, BytesLeft = pmdtc->lImageSize;
        BYTE *pCurrent = pRawImageBuffer + pmdtc->lHeaderSize;
        UINT offset = pmdtc->lHeaderSize;
        
        while(BytesLeft) {
            BytesToWrite = min(pmdtc->lBufferSize, BytesLeft);
            memcpy(pmdtc->pTransferBuffer, pCurrent, BytesToWrite);

                //
                // Calculate the percentage done using 90 as a base. This makes a rough assumption that
                // transferring the data from the device takes 90% of the time. If the this is the last
                // transfer, set the percentage to 100, otherwise make sure it is never larger than 99.
                //
            if (BytesLeft == BytesToWrite)
                percentComplete = 100;
            else
                percentComplete = min(99, 90 + (10 * offset) / pmdtc->lItemSize);

            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                percentComplete, offset, BytesToWrite, pmdtc, 0);
            REQUIRE(hr != S_FALSE, "transfer cancelled");
            REQUIRE(SUCCEEDED(hr), "sending header to app failed");
            
            pCurrent += BytesToWrite;
            offset += BytesToWrite;
            BytesLeft -= BytesToWrite;
        }
    }

Cleanup:    
    delete [] pNativeImage;
    delete [] pRawImageBuffer;

    // restore mdtc
    pmdtc->lItemSize = 0;
    
    if(bPatchedMDTC) {
        pmdtc->pTransferBuffer = 0;
        pmdtc->lBufferSize = 0;
    }
    
    return hr;
}
    
   

//
// This function transfers image from the camera and translates it to BMP
// format.
//
// Input:
//   pWiasContext -- wias context
//   pItemCtx     -- the mini driver item context
//   pmdtc        -- the transfer context
//
HRESULT
CWiaMiniDriver::AcquireDataAndTranslate(
    BYTE    *pWiasContext,
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc
    )
{
    DBG_FN("CWiaMiniDriver::AcquireDataAndTranslate");
    HRESULT hr = S_OK;

    // non-jpeg images are handled by GDI+ process
    if(pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_JFIF &&
       pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_EXIF)
    {
        return AcquireAndTranslateAnyImage(pWiasContext, pItemCtx, pmdtc);
    }


    if(pItemCtx->pObjectInfo->m_ImagePixWidth == 0) {
        return AcquireAndTranslateJpegWithoutGeometry(pWiasContext, pItemCtx, pmdtc);
    }

    //
    // Allocate memory for the native image
    //
    UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
    BYTE *pNativeImage = new BYTE[NativeImageSize];
    if (!pNativeImage)
    {
        wiauDbgError("AcquireDataAndTranslate", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Get the data from the camera
    //
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                     pNativeImage, &NativeImageSize, (LPVOID) pmdtc);
    if (FAILED(hr))
    {
        wiauDbgError("AcquireDataAndTranslate", "GetObjectData failed");
        delete []pNativeImage;
        return hr;
    }
    if (hr == S_FALSE)
    {
        wiauDbgWarning("AcquireDataAndTranslate", "transfer cancelled");
        delete []pNativeImage;
        return hr;
    }

    //
    // Call the WIA service helper to fill in the BMP header
    //
    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "AcquireDataAndTranslate", "wiasGetImageInformation failed");
        return hr;
    }

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        UNALIGNED BITMAPINFOHEADER*   pbmih   = (BITMAPINFOHEADER*)pmdtc->pTransferBuffer;
        
        pbmih->biHeight = -pmdtc->lLines;
    }

    //
    // Send the header to the app
    //
    BOOL bFileTransfer = (pmdtc->tymed & TYMED_FILE);
    LONG lMsg = (bFileTransfer ? IT_MSG_STATUS : IT_MSG_DATA);

    LONG percentComplete = 90 + (10 * pmdtc->lHeaderSize) / pmdtc->lItemSize;

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
        percentComplete, 0, pmdtc->lHeaderSize, pmdtc, 0);
    
    if (FAILED(hr))
    {
        wiauDbgError("AcquireDataAndTranslate", "sending header to app failed");
        return hr;
    }
    if (hr == S_FALSE)
    {
        wiauDbgWarning("AcquireDataAndTranslate", "transfer cancelled");
        delete []pNativeImage;
        return S_FALSE;
    }

    //
    // Set up the buffer for the rest of the transfer
    //
    BYTE *pTranslateBuffer = pmdtc->pTransferBuffer;
    LONG BytesLeft = pmdtc->lBufferSize;

    if (bFileTransfer)
    {
        pTranslateBuffer += pmdtc->lHeaderSize;
        BytesLeft -= pmdtc->lHeaderSize;
    }

    //
    // If the buffer is too small, allocate a new, bigger one
    //
    BOOL bIntermediateBuffer = FALSE;
    if (BytesLeft < pmdtc->lImageSize)
    {
        pTranslateBuffer = new BYTE[pmdtc->lImageSize];
        BytesLeft = pmdtc->lImageSize;
        bIntermediateBuffer = TRUE;
    }

    //
    // Convert the image to BMP
    //
    hr = Jpeg2DIBBitmap(pNativeImage, NativeImageSize,
                        pTranslateBuffer + pmdtc->cbWidthInBytes * (pmdtc->lLines - 1),
                        BytesLeft, pmdtc->cbWidthInBytes, 1);
    //
    // Free the native image buffer
    //
    delete []pNativeImage;
    pNativeImage = NULL;

    if (FAILED(hr))
    {
        wiauDbgError("AcquireDataAndTranslate", "image format conversion failed");
        if (bIntermediateBuffer)
            delete []pTranslateBuffer;
        return hr;
    }

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        VerticalFlip(pTranslateBuffer, pmdtc->cbWidthInBytes, pmdtc->lLines);
    }
    
    LONG lOffset = pmdtc->lHeaderSize;
    if (bIntermediateBuffer)
    {
    //
    // Send the data back a chunk at a time. This assumes that it is a callback transfer, e.g. the
    // buffer pointer is not being incremented.
    //
        LONG BytesToCopy = 0;
        BYTE *pCurrent = pTranslateBuffer;
        BytesLeft = pmdtc->lImageSize;


        while (BytesLeft > 0)
        {
            BytesToCopy = min(BytesLeft, pmdtc->lBufferSize);
            memcpy(pmdtc->pTransferBuffer, pCurrent, BytesToCopy);

                //
                // Calculate the percentage done using 90 as a base. This makes a rough assumption that
                // transferring the data from the device takes 90% of the time. If the this is the last
                // transfer, set the percentage to 100, otherwise make sure it is never larger than 99.
                //
            if (BytesLeft == BytesToCopy)
                percentComplete = 100;
            else
                percentComplete = min(99, 90 + (10 * lOffset) / pmdtc->lItemSize);

            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                percentComplete, lOffset, BytesToCopy, pmdtc, 0);
            if (FAILED(hr))
            {
                wiauDbgError("AcquireDataAndTranslate", "sending header to app failed");
                if (bIntermediateBuffer)
                    delete []pTranslateBuffer;
                return hr;
            }
            if (hr == S_FALSE)
            {
                wiauDbgWarning("AcquireDataAndTranslate", "transfer cancelled");
                if (bIntermediateBuffer)
                    delete []pTranslateBuffer;
                return S_FALSE;
            }

            pCurrent += BytesToCopy;
            lOffset += BytesToCopy;
            BytesLeft -= BytesToCopy;
        }
    }       
    else
    {
        //
        // Send the data to the app in one big chunk
        //
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
            100, lOffset, pmdtc->lImageSize, pmdtc, 0);
        if (FAILED(hr))
        {
            wiauDbgError("AcquireDataAndTranslate", "sending header to app failed");
            if (bIntermediateBuffer)
                delete []pTranslateBuffer;
            return hr;
        }
    }

    //
    // Free the translate buffer
    //
    if (bIntermediateBuffer)
        delete []pTranslateBuffer;

    return hr;
}

//
// This function transfers native data to the application without translating it.
//
// Input:
//   pItemCtx -- driver item context
//   pmdtc -- transfer context
//
HRESULT
CWiaMiniDriver::AcquireData(
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc
    )
{
    DBG_FN("CWiaMiniDriver::AcquireData");

    HRESULT hr = S_OK;

    //
    // If the class driver does not allocate the transfer buffer,
    // we have to allocate a temporary one
    //
    if (!pmdtc->bClassDrvAllocBuf)
    {
        pmdtc->pTransferBuffer = new BYTE[pItemCtx->pObjectInfo->m_CompressedSize];
        if (!pmdtc->pTransferBuffer)
        {
            wiauDbgError("AcquireData", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
        pmdtc->pBaseBuffer = pmdtc->pTransferBuffer;
        pmdtc->lBufferSize = pItemCtx->pObjectInfo->m_CompressedSize;
    }

    //
    // Get the data from the camera
    //
    UINT size = pmdtc->lBufferSize;
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle, pmdtc->pTransferBuffer,
                                     &size, (LPVOID) pmdtc);
    //
    // Check the return code, but keep going so that the buffer gets freed
    //
    if (FAILED(hr))
        wiauDbgError("AcquireData", "GetObjectData failed");
    else if (hr == S_FALSE)
        wiauDbgWarning("AcquireData", "data transfer cancelled");

    //
    // Free the temporary buffer, if needed
    //
    if (!pmdtc->bClassDrvAllocBuf)
    {
        if (pmdtc->pTransferBuffer)
        {
            delete []pmdtc->pTransferBuffer;
            pmdtc->pBaseBuffer = NULL;
            pmdtc->pTransferBuffer = NULL;
            pmdtc->lBufferSize = 0;

        }
        else
        {
            wiauDbgWarning("AcquireData", "transfer buffer is NULL");
        }
    }

    return hr;
}

//
// This function passes the data transfer callback through to the
// IWiaMiniDrvCallBack interface using the appropriate
// parameters.
//
// Input:
//   pCallbackParam -- should hold a pointer to the transfer context
//   lPercentComplete -- percent of transfer completed
//   lOffset -- offset into the buffer where the data is located
//   lLength -- amount of data transferred
//
HRESULT
DataCallback(
    LPVOID pCallbackParam,
    LONG lPercentComplete,
    LONG lOffset,
    LONG lLength,
    BYTE **ppBuffer,
    LONG *plBufferSize
    )
{
    DBG_FN("DataCallback");

    HRESULT hr = S_OK;

    if (!pCallbackParam || !ppBuffer || !*ppBuffer || !plBufferSize)
    {
        wiauDbgError("DataCallback", "invalid argument");
        return E_INVALIDARG;
    }

    PMINIDRV_TRANSFER_CONTEXT pmdtc = (PMINIDRV_TRANSFER_CONTEXT) pCallbackParam;

    //
    // If app is asking for BMP, most likely it's being converted. Thus just give the app
    // status messages. Calculate percent done so that the transfer takes 90% of the time
    // and the conversion takes the last 10%.
    //
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
        IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP))
    {
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS, IT_STATUS_TRANSFER_FROM_DEVICE,
                                                          lPercentComplete * 9 / 10, lOffset, lLength, pmdtc, 0);
        *ppBuffer += lLength;
    }

    //
    // Otherwise, see if it's a file transfer
    //
    else if (pmdtc->tymed & TYMED_FILE)
    {
        if (pmdtc->bClassDrvAllocBuf && lPercentComplete == 100)
        {
            //
            // Call WIA to write the data to the file. There is a small a bug that causes
            // TIFF headers to be changed, so temporarily change the format GUID to null.
            //
            GUID tempFormat;
            tempFormat = pmdtc->guidFormatID;
            pmdtc->guidFormatID = GUID_NULL;

            hr = wiasWritePageBufToFile(pmdtc);
            pmdtc->guidFormatID = tempFormat;

            if (FAILED(hr))
            {
                wiauDbgError("DataCallback", "wiasWritePageBufToFile failed");
                return hr;
            }
        }

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          lPercentComplete, lOffset, lLength, pmdtc, 0);
        *ppBuffer += lLength;
    }

    //
    // Otherwise, it's a callback transfer
    //
    else
    {
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          lPercentComplete, lOffset, lLength, pmdtc, 0);
        //
        // Update the buffer pointer and size in case the app is using double buffering
        //
        *ppBuffer = pmdtc->pTransferBuffer;
        *plBufferSize = pmdtc->lBufferSize;
    }

    if (FAILED(hr))
    {
        wiauDbgError("DataCallback", "MiniDrvCallback failed");
    }
    else if (hr == S_FALSE)
    {
        wiauDbgWarning("DataCallback", "data transfer was cancelled by MiniDrvCallback");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\jpegutil.cpp ===
/***********************************************************************
 *
 * JPEG decompression utility functions
 *
 *   Implement (1) JPEG memory data source
 *             (2) JPEG error manager using setjmp/longjmp
 *
 *   Author : Indy Zhu    [indyz]
 *   Date   : 5/20/98
 *  
 ***********************************************************************/

#include "pch.h"

#include <setjmp.h>

//
// Workaround for redefinition of INT32
//

#define   XMD_H  1

//
// Header file for JPEG library
//

extern "C"
{
#include "jpeglib.h"
}
#include "utils.h"

//
// Buf source manager definition
//

typedef struct _buf_source_mgr
{
    struct jpeg_source_mgr  pub;

    //
    // Fields specific to buf_source_mgr
    //

    LPBYTE                  pJPEGBlob;
    DWORD                   dwSize;   
} buf_source_mgr;

//
// Jump error manager definition
//

typedef struct _jmp_error_mgr
{
    struct jpeg_error_mgr  pub;

    //
    // Private fields for jump error manager
    //

    jmp_buf                stackContext;
} jmp_error_mgr;

/******************************************************************************\
*
* init_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
init_source(
           j_decompress_ptr       pDecompInfo)
{
    //
    // No working necessary here
    //
}

/******************************************************************************\
*
* fill_input_buffer()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static boolean __cdecl
fill_input_buffer(
                 j_decompress_ptr       pDecompInfo)
{
    buf_source_mgr        *pBufSrcMgr;

    //
    // Recover buf source manager itself
    //

    pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;

    //
    // buf_source_mgr can only fire one shot    
    //

    pBufSrcMgr->pub.next_input_byte = pBufSrcMgr->pJPEGBlob;
    pBufSrcMgr->pub.bytes_in_buffer = pBufSrcMgr->dwSize;

    return(TRUE);
}

/******************************************************************************\
*
* skip_input_data()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
skip_input_data(
               j_decompress_ptr       pDecompInfo, 
               long                   lBytes)
{
    buf_source_mgr        *pBufSrcMgr;

    //
    // For buf source manager, it is very easy to implement
    //

    if (lBytes > 0)
    {

        pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;

        pBufSrcMgr->pub.next_input_byte += lBytes;
        pBufSrcMgr->pub.bytes_in_buffer -= lBytes;
    }
}

/******************************************************************************\
*
* term_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
term_source(
           j_decompress_ptr       pDecompInfo)
{
}

/******************************************************************************\
*
* jpeg_buf_src()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
jpeg_buf_src(
            j_decompress_ptr       pDecompInfo,
            LPBYTE                 pJPEGBlob, 
            DWORD                  dwSize)
{
    buf_source_mgr        *pBufSrcMgr;

    //
    // Allocate memory for the buf source manager
    //

    pBufSrcMgr = (buf_source_mgr *)
                 (pDecompInfo->mem->alloc_small)((j_common_ptr)pDecompInfo, 
                                                 JPOOL_PERMANENT, 
                                                 sizeof(buf_source_mgr));

    //
    // Record the pJPEGBlob
    //

    pBufSrcMgr->pJPEGBlob = pJPEGBlob;
    pBufSrcMgr->dwSize    = dwSize;

    //
    // Fill in the function pointers
    //

    pBufSrcMgr->pub.init_source       = init_source;
    pBufSrcMgr->pub.fill_input_buffer = fill_input_buffer;
    pBufSrcMgr->pub.skip_input_data   = skip_input_data;
    pBufSrcMgr->pub.resync_to_restart = jpeg_resync_to_restart;
    pBufSrcMgr->pub.term_source       = term_source;

    //
    // Initialize the pointer into the buffer
    //

    pBufSrcMgr->pub.bytes_in_buffer = 0;
    pBufSrcMgr->pub.next_input_byte = NULL;

    //
    // Ask the decompression context to remember it
    //

    pDecompInfo->src = (struct jpeg_source_mgr *)pBufSrcMgr;
}

/******************************************************************************\
*
* jmp_error_exit()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
jmp_error_exit(
              j_common_ptr           pDecompInfo)
{
    jmp_error_mgr         *pJmpErrorMgr;

    //
    // Get the jump error manager back
    //

    pJmpErrorMgr = (jmp_error_mgr *)pDecompInfo->err;

    //
    // Display the error message
    //

#ifdef _DEBUG
    (pDecompInfo->err->output_message)(pDecompInfo);
#endif

    //
    // Recover the original stack
    //

    longjmp(pJmpErrorMgr->stackContext, 1);
}

/******************************************************************************\
*
* jpeg_jmp_error()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

struct jpeg_error_mgr *
jpeg_jmp_error(
              jmp_error_mgr         *pJmpErrorMgr)
{
    //
    // Initialize the public part
    //

    jpeg_std_error(&pJmpErrorMgr->pub);

    //
    // Set up jump error manager exit method
    //

    pJmpErrorMgr->pub.error_exit = jmp_error_exit;

    return((jpeg_error_mgr *)pJmpErrorMgr);
}

/******************************************************************************\
*
* GetJpegDimensions
*
* Arguments:
*   pJpeg   -- jpeg file in memory. It could be in JFIF and EXIF
*          format
*   JpegSize -- the jpeg file size
*   pWidth  -- to return the image width in pixels
*   pHeight -- to return the image height in pixels
*   pBitDepth -- to return the image bit depth.
*
* Return Value:
*
*    HRESULT
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

HRESULT
WINAPI
GetJpegDimensions(
                 BYTE    *pJpeg,
                 UINT   JpegSize,
                 UINT   *pWidth,
                 UINT   *pHeight,
                 UINT   *pBitDepth
                 )
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    int ret;

    //
    // Step 1 : Initialize JPEG session data-structure
    //

    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);

    //
    // Reserve the state of the current stack
    //

    if (setjmp(jpegErrMgr.stackContext))
    {

        //
        // JPEG lib will longjump here when there is an error
        //

        jpeg_destroy_decompress(&decompInfo);

        return(E_FAIL);
    }

    //
    // Step 2 : Specify the source of the compressed data
    //

    jpeg_buf_src(&decompInfo, pJpeg, JpegSize);

    //
    // Step 3 : Read JPEG file header information
    //

    ret = jpeg_read_header(&decompInfo, TRUE);

    //
    // Release the decompression context
    //

    jpeg_destroy_decompress(&decompInfo);

    //
    // Fill in the dimension info for the caller
    //

    *pWidth   = decompInfo.image_width;
    *pHeight  = decompInfo.image_height;
    *pBitDepth = 24;

    if (ret != JPEG_HEADER_OK)
    {
        return(E_FAIL);
    }

    return S_OK;
}

//
// This function flips the given bitmap
// Input:
//  pbmp    -- the bitmap
//  bmpHeight -- the bmp height
//  bmpLineSize -- bmp scanline size in bytes
// Output:
//  HRESULT
//
HRESULT
VerticalFlipBmp(
               BYTE *pbmp,
               UINT bmpHeight,
               UINT bmpLineSize
               )
{
    if (!pbmp || !bmpHeight || !bmpLineSize)
        return E_INVALIDARG;
    BYTE *pScanline;
    BYTE *pSrc;
    BYTE *pDst;

    pScanline = new BYTE[bmpLineSize];
    if (!pScanline)
        return E_OUTOFMEMORY;
    pDst = pbmp + (bmpHeight - 1) * bmpLineSize;
    //
    // Do not need to flip the center scanline if  bmpHeight is an odd number.
    //
    for (bmpHeight /= 2; bmpHeight; bmpHeight--)
    {
        memcpy(pScanline, pbmp, bmpLineSize);
        memcpy(pbmp, pDst, bmpLineSize);
        memcpy(pDst, pScanline, bmpLineSize);
        pbmp += bmpLineSize;
        pDst -= bmpLineSize;
    }
    delete [] pScanline;
    return S_OK;
}

//
// This function converts a jpeg file in memory to DIB bitmap
//
// Input:
//   pJpeg   -- jpeg file in memory. JFIF or EXIF are supported
//   JpegSize -- the jpeg file size
//   DIBBmpSize -- DIB bitmap buffer size
//   pDIBBmp    -- DIB bitmap buffer
//   LineSize    -- desitnation scanline size in bytes
//   MaxLines    -- maximum scanlines per transfer
//
HRESULT
WINAPI
Jpeg2DIBBitmap(
              BYTE *pJpeg,
              UINT JpegSize,
              BYTE *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              )
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;


    //
    // Parameter checking
    //
    if (!pJpeg || !JpegSize || !DIBBmpSize || !pDIBBmp || !LineSize)
        return E_INVALIDARG;

    //
    // Step 1 : Initialize JPEG session data-structure
    //

    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);

    //
    // Reserve the state of the current stack
    //

    if (setjmp(jpegErrMgr.stackContext))
    {

        //
        // JPEG lib will longjump here when there is an error
        //

        jpeg_destroy_decompress(&decompInfo);

        return(E_FAIL);
    }

    //
    // Step 2 : Specify the source of the compressed data
    //

    jpeg_buf_src(&decompInfo, pJpeg, JpegSize);

    //
    // Step 3 : Read JPEG file header information
    //

    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK)
    {

        jpeg_destroy_decompress(&decompInfo);
        return(E_FAIL);
    }

    //
    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion
    // Specify the JCS_BGR output colorspace so that the returned
    // decompressed image has the same format as DIB. Also, it forces
    // the decompressor to return a 24-bits RGB colors image
    //

    decompInfo.out_color_space = JCS_BGR;

    //
    // Calculate DIB scan line size, assuming 24bits color.
    //
    HRESULT hr;

    hr = S_OK;

    //
    // Step 5 : Start the real action
    //

    jpeg_start_decompress(&decompInfo);

    //
    // Step 6 : Acquire the scan line
    //

    while (S_OK == hr &&
           decompInfo.output_scanline < decompInfo.output_height)
    {
        if (DIBBmpSize >= LineSize)
        {
            //
            // Decompress line by line. Ignore the MaxLines since
            // we do not do more than one line at a time.
            //
            jpeg_read_scanlines(&decompInfo, &pDIBBmp, 1);
            pDIBBmp -= LineSize;
            DIBBmpSize -= LineSize;
        }
        else
        {
            //
            // The provided buffer is too small.
            //
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    //
    // Step 7 : Finish the job
    //

    if (SUCCEEDED(hr))
    {
        jpeg_finish_decompress(&decompInfo);
    }
    else
    {
        jpeg_abort_decompress(&decompInfo);
    }
    //
    // Step 8 : Garbage collection
    //

    jpeg_destroy_decompress(&decompInfo);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\pch.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header

Author:

    DavePar

Revision History:


--*/


#ifndef _PCH_H
#define _PCH_H

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <assert.h>

#include <wiamindr.h>
#include <gdiplus.h>
#include <wiautil.h>
#include <usbscan.h>

#define INITGUID
#include <initguid.h>
#include <sti.h>
#include <stiusd.h>

#include "wiatempl.h"
#include "iso15740.h"

#include "dllmain.h"
#include "utils.h"
#include "camera.h"
#include "camusb.h"
#include "factory.h"
#include "ptputil.h"
#include "resource.h"
#include "ptpusd.h"

#include "minidrv.h"
#include "trace.h"

#endif // _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\eventcb.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    eventcb.cpp

Abstract:

    This module implements CWiaPTPEventCallback class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

//
// This method is the callback function for every PTP event
//
// Input:
//   pEvent -- PTP event block
//
HRESULT
CWiaMiniDriver::EventCallbackDispatch(
    PPTP_EVENT pEvent
    )
{
    DBG_FN("CWiaMiniDriver::EventCallback");
    
    HRESULT hr = S_OK;

    CPtpMutex cpm(m_hPtpMutex);

    if (!pEvent)
    {
        wiauDbgError("EventCallback", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Figure out what the event is and call the appropriate function
    //
    switch (pEvent->EventCode)
    {
    case PTP_EVENTCODE_CANCELTRANSACTION:
        hr = S_OK;
        break;

    case PTP_EVENTCODE_OBJECTADDED:
        hr = AddNewObject(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_OBJECTREMOVED:
        hr = RemoveObject(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_STOREADDED:
        hr = AddNewStorage(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_STOREREMOVED:
        hr = RemoveStorage(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_DEVICEPROPCHANGED:
        hr = DevicePropChanged((WORD) pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_OBJECTINFOCHANGED:
        hr = ObjectInfoChanged(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_DEVICEINFOCHANGED:

        // WIAFIX-8/29/2000-davepar Need to handle this

        //hr = RebuildDrvItemTree(&DevErrVal);
        break;

    case PTP_EVENTCODE_REQUESTOBJECTTRANSFER:
        //
        // This event is ignored, because we don't know where to put the image. Maybe
        // it should cause a "button pushed" event.
        //
        break;
    
    case PTP_EVENTCODE_STOREFULL:
        hr = StorageFull(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_DEVICERESET:

        // WIAFIX-8/29/2000-davepar Need to handle this

        //hr = RebuildDrvItemTree(&DevErrVal);
        break;
    
    case PTP_EVENTCODE_STORAGEINFOCHANGED:
        hr = StorageInfoChanged(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_CAPTURECOMPLETE:
        hr = CaptureComplete();
        break;

    case PTP_EVENTCODE_UNREPORTEDSTATUS:

        // WIAFIX-8/29/2000-davepar Need to handle this

        //hr = RebuildDrvItemTree(&DevErrVal);
        break;


    default:

        //
        // If it is a vendor's event, post it
        //
        if (pEvent->EventCode & PTP_DATACODE_VENDORMASK)
        {
            hr = PostVendorEvent(pEvent->EventCode);
        }

        break;
    }

    return hr;
}

//
// This function adds a new object to the driver item tree. If a new driver
// item is added, a WIA_EVENT_ITEM_CREATED event will be signaled.
//
// Input:
//   ObjectHandle -- the new object handle
//
HRESULT
CWiaMiniDriver::AddNewObject(DWORD ObjectHandle)
{
    DBG_FN("CWiaMiniDriver::AddNewObject");
    
    HRESULT hr = S_OK;

    hr = AddObject(ObjectHandle, TRUE);
    if (FAILED(hr))
    {
        wiauDbgError("AddNewObject", "AddObject failed");
        return hr;
    }

    return hr;
}

//
// This function removes the given object handle from the driver item tree.
// If the object handle has a driver item associated with it and the
// driver item is removed, a WIA_EVENT_ITEM_REMOVED event will be signaled.
//
// Input:
//   ObjectHandle -- the object handle to be removed
//
HRESULT
CWiaMiniDriver::RemoveObject(DWORD ObjectHandle)
{
    DBG_FN("CWiaMiniDriver::RemoveObject");
    
    HRESULT hr = S_OK;

    //
    // Find the driver item for the object handle.
    //
    IWiaDrvItem *pDrvItem = m_HandleItem.Lookup(ObjectHandle);
    if (!pDrvItem)
    {
        wiauDbgError("RemoveObject", "tried to remove object that doesn't exist");
        return S_FALSE;
    }

    //
    // Try to remove the object from the ancillary assoc array, in case it's there too. Ancillary
    // association objects actually point to images in the handle/item map, so don't delete the
    // actual item
    //
    if (m_AncAssocParent.Remove(ObjectHandle))
    {
        wiauDbgTrace("RemoveObject", "ancillary association object removed");
    }
    else
    {
        BSTR bstrFullName;
        hr = pDrvItem->GetFullItemName(&bstrFullName);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveObject", "GetFullItemName failed");
            return hr;
        }

        hr = pDrvItem->RemoveItemFromFolder(WiaItemTypeDisconnected);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveObject", "UnlinkItemTree failed");
            return hr;
        }

        hr = wiasQueueEvent(m_bstrDeviceId, &WIA_EVENT_ITEM_DELETED, bstrFullName);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveObject", "wiasQueueEvent failed");
            return hr;
        }

        SysFreeString(bstrFullName);
    }

    //
    // Remove the object from the handle/drvItem association
    //
    m_HandleItem.Remove(ObjectHandle);
    
    return hr;
}

//
// This function adds a new storage to the driver item tree.
// A WIA_EVENT_STORAGE_CREATED event will be singaled.
//
// Input:
//   StorageId   -- the new storage id to be added
//
HRESULT
CWiaMiniDriver::AddNewStorage(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::AddNewStorage");
    
    HRESULT hr = S_OK;

    CArray32 StorageIdList;

    //
    // If several logical stores were added, the device may indicate
    // to re-enumerate the stores
    //
    if (StorageId == PTP_STORAGEID_UNDEFINED)
    {
        hr = m_pPTPCamera->GetStorageIDs(&StorageIdList);
        if (FAILED(hr))
        {
            wiauDbgError("AddNewStorage", "GetStorageIDs failed");
            return hr;
        }

        //
        // Loop through the list of new storage ids, removing the ones
        // that have already been enumerated
        //
        int index;
        for (int count = 0; count < StorageIdList.GetSize(); count++)
        {
            index = m_StorageIds.Find(StorageIdList[count]);
            if (index >= 0)
            {
                StorageIdList.RemoveAt(index);
            }
        }
    }

    //
    // Otherwise there is just one storage id to work on
    //
    else
    {
        StorageIdList.Add(StorageId);
    }

    //
    // Loop through all of the new storage ids
    //
    CPtpStorageInfo tempSI;
    for (int storageIndex = 0; storageIndex < StorageIdList.GetSize(); storageIndex++)
    {
        //
        // Get info for the new storage
        //
        hr = m_pPTPCamera->GetStorageInfo(StorageIdList[storageIndex], &tempSI);
        if (FAILED(hr))
        {
            wiauDbgError("drvInitializeWia", "GetStorageInfo failed");
            return hr;
        }

        //
        // Add the storage id to the main list
        //
        if (!m_StorageIds.Add(StorageIdList[storageIndex]))
        {
            wiauDbgError("AddNewStorage", "add storage id failed");
            return E_OUTOFMEMORY;
        }

        //
        // Add storage info to array
        //
        if (!m_StorageInfos.Add(tempSI))
        {
            wiauDbgError("drvInitializeWia", "add storage info failed");
            return E_OUTOFMEMORY;
        }

        //
        // Add an empty entry to the DCIM handle array
        //
        ULONG dummy = 0;
        if (!m_DcimHandle.Add(dummy))
        {
            wiauDbgError("AddNewStorage", "add dcim handle failed");
            return E_OUTOFMEMORY;
        }
        
        //
        // Loop through all of the objects on the new storage, adding them one
        // at a time.
        //
        CArray32 ObjectHandleList;
    
        hr = m_pPTPCamera->GetObjectHandles(StorageIdList[storageIndex], PTP_FORMATCODE_ALL,
                                            PTP_OBJECTHANDLE_ALL, &ObjectHandleList);
        if (FAILED(hr))
        {
            wiauDbgError("AddNewStorage", "GetObjectHandles failed");
            return hr;
        }
    
        //
        // Iterate through the object handles, creating a WIA driver item for each
        //
        for (int objectindex = 0; objectindex < ObjectHandleList.GetSize(); objectindex++)
        {
            hr = AddObject(ObjectHandleList[objectindex], TRUE);
            if (FAILED(hr))
            {
                wiauDbgError("AddNewStorage", "AddObject failed");
                return hr;
            }
        }
    }

    return hr;
}

//
// This function removes all of the objects on a storage from the
// driver item tree, signalling WIA_EVENT_ITEM_DELETED as appropriate.
//
// Input:
//   StorageId -- storage to delete
//
HRESULT
CWiaMiniDriver::RemoveStorage(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::RemoveStorage");
    
    HRESULT hr = S_OK;

    //
    // If the lower 16 bits of the storage id is 0xffff, an entire physical store
    // was removed--match only the upper 16 bits of the storage id
    //
    DWORD StorageIdMask = PTP_STORAGEID_ALL;
    if ((StorageId & PTP_STORAGEID_LOGICAL) == PTP_STORAGEID_LOGICAL)
    {
        StorageIdMask = PTP_STORAGEID_PHYSICAL;
        StorageId &= StorageIdMask;
    }

    //
    // Traverse the driver item tree depth-first looking for objects that were on
    // the removed storage
    //
    CWiaArray<IWiaDrvItem*> ItemStack;
    IWiaDrvItem *pCurrent = NULL;
    IWiaDrvItem *pChild = NULL;
    IWiaDrvItem *pSibling = NULL;
    
    hr = m_pDrvItemRoot->GetFirstChildItem(&pCurrent);
    if (FAILED(hr))
    {
        wiauDbgError("RemoveStorage", "GetFirstChildItem failed");
        return hr;
    }

    while (pCurrent)
    {
        hr = pCurrent->GetFirstChildItem(&pChild);
        
        //
        // GetFirstChildItem returns E_INVALIDARG if there are no child items
        //
        if (FAILED(hr) && hr != E_INVALIDARG)
        {
            wiauDbgError("RemoveStorage", "GetFirstChildItem failed");
            return hr;
        }

        //
        // Children exist, so traverse down the tree
        //
        if (hr != E_INVALIDARG && pChild)
        {
            if (!ItemStack.Push(pCurrent))
            {
                wiauDbgError("RemoveStorage", "memory allocation failed");
                return E_OUTOFMEMORY;
            }
            pCurrent = pChild;
            pChild = NULL;
        }

        //
        // No children, so look for siblings and potentially delete the current driver item
        //
        else
        {
            //
            // Loop through all of the siblings
            //
            while (TRUE)
            {
                hr = pCurrent->GetNextSiblingItem(&pSibling);
                if (FAILED(hr))
                {
                    wiauDbgError("RemoveStorage", "GetNextSiblingItem failed");
                    return hr;
                }

                //
                // See if the item is on the storage which was removed
                //
                PDRVITEM_CONTEXT pDrvItemContext;
                hr = pCurrent->GetDeviceSpecContext((BYTE **) &pDrvItemContext);
                if (FAILED(hr))
                {
                    wiauDbgError("RemoveStorage", "GetDeviceSpecContext failed");
                    return hr;
                }

                if ((pDrvItemContext->pObjectInfo->m_StorageId & StorageIdMask) == StorageId)
                {
                    //
                    // Remove the item
                    //
                    hr = RemoveObject(pDrvItemContext->pObjectInfo->m_ObjectHandle);
                    if (FAILED(hr))
                    {
                        wiauDbgError("RemoveStorage", "RemoveObject failed");
                        return hr;
                    }
                }

                //
                // Found a sibling, so go to the top and look for children
                //
                if (pSibling)
                {
                    pCurrent = pSibling;
                    pSibling = NULL;
                    break;
                }

                //
                // No sibling, so pop up a level
                //
                else
                {
                    if (ItemStack.GetSize() > 0)
                    {
                        if (!ItemStack.Pop(pCurrent))
                        {
                            wiauDbgError("RemoveStorage", "Pop failed");
                            return E_FAIL;
                        }
                    }
                    
                    //
                    // No more levels to pop, so the loop is done
                    //
                    else
                    {
                        pCurrent = NULL;
                        break;
                    }
                }
            }
        }
    }

    //
    // Remove the store from the appropriate arrays
    //
    for (int count = 0; count < m_StorageIds.GetSize(); count++)
    {
        if ((m_StorageIds[count] & StorageIdMask) == StorageId)
        {
            m_StorageIds.RemoveAt(count);
            m_StorageInfos.RemoveAt(count);
            m_DcimHandle.RemoveAt(count);
            count--;
        }
    }


    return hr;
}

//
// This function updates the value for a property
//
// Input:
//   PropCode -- property code that was updated
//
HRESULT
CWiaMiniDriver::DevicePropChanged(WORD PropCode)
{
    DBG_FN("CWiaMiniDriver::DevicePropChanged");

    HRESULT hr = S_OK;

    int idx = m_DeviceInfo.m_SupportedProps.Find(PropCode);
    if (idx < 0)
    {
        wiauDbgWarning("DevicePropChanged", "prop code not found %d", PropCode);
        return hr;
    }

    hr = m_pPTPCamera->GetDevicePropValue(PropCode, &m_PropDescs[idx]);
    if (FAILED(hr))
    {
        wiauDbgError("DevicePropChanged", "GetDevicePropValue failed");
        return hr;
    }

    return hr;
}

//
// This function updates the object info for an object
//
// Input:
//   ObjectHandle -- the object whose ObjectInfo needs updating
//
HRESULT
CWiaMiniDriver::ObjectInfoChanged(DWORD ObjectHandle)
{
    DBG_FN("CWiaMiniDriver::ObjectInfoChanged");
    
    HRESULT hr = S_OK;


    //
    // Find the driver item for the object handle.
    //
    IWiaDrvItem *pDrvItem = m_HandleItem.Lookup(ObjectHandle);
    if (!pDrvItem)
    {
        wiauDbgError("ObjectInfoChanged", "tried to update object that doesn't exist");
        return S_FALSE;
    }

    PDRVITEM_CONTEXT pDrvItemContext;
    hr = pDrvItem->GetDeviceSpecContext((BYTE **) &pDrvItemContext);
    if (FAILED(hr))
    {
        wiauDbgError("ObjectInfoChanged", "GetDeviceSpecContext failed");
        return hr;
    }

    hr = m_pPTPCamera->GetObjectInfo(ObjectHandle, pDrvItemContext->pObjectInfo);
    if (FAILED(hr))
    {
        wiauDbgError("ObjectInfoChanged", "GetObjectInfo failed");
        return hr;
    }

    return hr;
}

//
// This function marks a storage as full
//
// Input:
//   StorageId -- the storage to be marked
//
HRESULT
CWiaMiniDriver::StorageFull(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::StorageFull");
    
    HRESULT hr = S_OK;

    INT index = m_StorageIds.Find(StorageId);
    if (index < 0)
    {
        wiauDbgError("StorageFull", "storage id not found");
        return S_FALSE;
    }

    CPtpStorageInfo *pStorageInfo = &m_StorageInfos[index];

    pStorageInfo->m_FreeSpaceInBytes = 0;
    pStorageInfo->m_FreeSpaceInImages = 0;
    
    //
    // Signal that the TakePicture command is complete, if the driver was waiting for one
    //
    if (!SetEvent(m_TakePictureDoneEvent))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "EventCallbackDispatch", "SetEvent failed");
        return hr;
    }

    return hr;
}

//
// This function updates a StorageInfo
//
// Input:
//   StorageId -- the storage id to be updated
//
HRESULT
CWiaMiniDriver::StorageInfoChanged(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::StorageInfoChanged");
    
    HRESULT hr = S_OK;
    
    INT index = m_StorageIds.Find(StorageId);
    if (index < 0)
    {
        wiauDbgError("StorageInfoChanged", "storage id not found");
        return S_FALSE;
    }

    CPtpStorageInfo *pStorageInfo = &m_StorageInfos[index];

    hr = m_pPTPCamera->GetStorageInfo(StorageId, pStorageInfo);
    if (FAILED(hr))
    {
        wiauDbgError("StorageInfoChanged", "GetStorageInfo failed");
        return hr;
    }

    return hr;
}

//
// This function processes the CaptureComplete event
//
// Input:
//   StorageId -- the storage id to be updated
//
HRESULT
CWiaMiniDriver::CaptureComplete()
{
    DBG_FN("CWiaMiniDriver::CaptureComplete");
    
    HRESULT hr = S_OK;

    //
    // Signal that the TakePicture command is complete
    //
    if (!SetEvent(m_TakePictureDoneEvent))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "EventCallbackDispatch", "SetEvent failed");
        return hr;
    }

    return hr;
}

//
// This function posts a vendor defined event
//
// Input:
//   EventCode -- the event code
//
HRESULT
CWiaMiniDriver::PostVendorEvent(WORD EventCode)
{
    DBG_FN("CWiaMiniDriver::PostVendorEvent");
    
    HRESULT hr = S_OK;

    CVendorEventInfo *pEventInfo = NULL;

    pEventInfo = m_VendorEventMap.Lookup(EventCode);
    if (pEventInfo)
    {
        hr = wiasQueueEvent(m_bstrDeviceId, pEventInfo->pGuid, NULL);
        if (FAILED(hr))
        {
            wiauDbgError("PostVendorEvent", "wiasQueueEvent failed");
            return hr;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\minidrv.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    This module declares CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef MINIDRV__H_
#define MINIDRV__H_


DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef) (THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease) (THIS) PURE;
};

//
// General purpose GUIDs
//
DEFINE_GUID(GUID_NULL, 0,0,0,0,0,0,0,0,0,0,0);

DEFINE_GUID(FMT_NOTHING,
            0x81a566e7,0x8620,0x4fba,0xbc,0x8e,0xb2,0x7c,0x17,0xad,0x9e,0xfd);

//
// This is the HRESULT code we used to report that a device error has occurred
//
const HRESULT   HRESULT_DEVICE_ERROR  = HRESULT_FROM_WIN32(ERROR_GEN_FAILURE);
const HRESULT   HRESULT_DEVICE_NOT_RESPONDING = HRESULT_FROM_WIN32(ERROR_TIMEOUT);

//
// Device error codes
//
enum
{
    DEVERR_OK = 0,
    DEVERR_UNKNOWN
};
#define DEVERR_MIN DEVERR_OK
#define DEVERR_MAX DEVERR_UNKNOWN

//
// Session ID to use
//
const ULONG WIA_SESSION_ID = 1;

//
// Handy constants for common item types
//
const ULONG ITEMTYPE_FILE   = WiaItemTypeFile;
const ULONG ITEMTYPE_IMAGE  = WiaItemTypeFile | WiaItemTypeImage;
const ULONG ITEMTYPE_AUDIO  = WiaItemTypeFile | WiaItemTypeAudio;
const ULONG ITEMTYPE_VIDEO  = WiaItemTypeFile | WiaItemTypeVideo;
const ULONG ITEMTYPE_FOLDER = WiaItemTypeFolder;
const ULONG ITEMTYPE_BURST  = WiaItemTypeFolder | WiaItemTypeBurst;
const ULONG ITEMTYPE_HPAN   = WiaItemTypeFolder | WiaItemTypeHPanorama;
const ULONG ITEMTYPE_VPAN   = WiaItemTypeFolder | WiaItemTypeVPanorama;

//
// Maximum number of vendor-defined events supported
//
const ULONG MAX_VENDOR_EVENTS = 128;

//
// Structure which holds everything needed for each format type.
//
typedef struct _FORMAT_INFO
{
    LPGUID  FormatGuid;     // WIA format GUID
    PWSTR   FormatString;   // item name in a printf-style format string
    LONG    ItemType;       // WIA item type
    PWSTR   ExtString;      // file name extension

} FORMAT_INFO, *PFORMAT_INFO;

//
// Structure for holding information about each property.
//
typedef struct _PROP_INFO
{
    PROPID      PropId;     // WIA property id
    LPOLESTR    PropName;   // WIA property name

} PROP_INFO, *PPROP_INFO;

//
// structure for holding information about vendor events
//
class CVendorEventInfo
{
public:
    GUID       *pGuid;      // WIA GUID for event
    BSTR        EventName;  // may be NULL if vendor did not provide event name in INF file
    CVendorEventInfo() : pGuid(NULL), EventName(NULL) {};
    ~CVendorEventInfo() 
    {
        if (pGuid) delete pGuid;
        SysFreeString(EventName);
    }
};

//
// Driver item context
//
typedef struct tagDrvItemContext
{
    CPtpObjectInfo  *pObjectInfo;        // pointer to the PTP ObjectInfo structure

    ULONG            NumFormatInfos;     // number of format infos stored
    WIA_FORMAT_INFO *pFormatInfos;       // supported formats array

    ULONG            ThumbSize;          // thumnail image size in bytes
    BYTE            *pThumb;             // thumnail bits

}DRVITEM_CONTEXT, *PDRVITEM_CONTEXT;

#ifdef DEADCODE
//
// Tree node. These are used to temporarily hold the items between reading
// all of the PTP objects and creating the PTP item tree.
//
typedef struct _OBJECT_TREE_NODE
{
    CPtpObjectInfo *pObjectInfo;
    struct _OBJECT_TREE_NODE *pNext;
    struct _OBJECT_TREE_NODE *pFirstChild;
} OBJECT_TREE_NODE, *POBJECT_TREE_NODE;
#endif // DEADCODE

//
// Our minidriver clsid.
//
#if defined( _WIN32 ) && !defined( _NO_COM)
// b5ee90b0-d5c5-11d2-82d5-00c04f8ec183
DEFINE_GUID(CLSID_PTPWiaMiniDriver,
            0xb5ee90b0,0xd5c5,0x11d2,0x82,0xd5,0x00,0xc0,0x4f,0x8e,0xc1,0x83);
#endif

class CWiaMiniDriver :
public INonDelegatingUnknown,
public IStiUSD,
public IWiaMiniDrv
{
public:
    CWiaMiniDriver(LPUNKNOWN punkOuter);
    ~CWiaMiniDriver();
    //
    // INonDelegatingUnknown interface
    //
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);

    //
    // IUnknown interface
    //
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);

    //
    // IStiUSD interface
    //
    STDMETHODIMP Initialize(PSTIDEVICECONTROL pHelDcb, DWORD dwStiVersion, HKEY hParametersKey);
    STDMETHODIMP GetCapabilities (PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus (PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPDIAG pBuffer);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE EscapeFunction, LPVOID lpInData, DWORD  cbInDataSize,
                        LPVOID pOutData, DWORD dwOutDataSize, LPDWORD pdwActualDataSize);
    STDMETHODIMP GetLastError (LPDWORD pdwLastDeviceError);
    STDMETHODIMP GetLastErrorInfo (STI_ERROR_INFO *pLastErrorInfo);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);

    //
    // IWiaMiniDrv interface
    //
    STDMETHODIMP drvInitializeWia(BYTE *pWiasContext, LONG lFlags, BSTR bstrDeviceID, BSTR bstrRootFullItemName,
                                  IUnknown *pStiDevice, IUnknown *pIUnknownOuter, IWiaDrvItem  **ppIDrvItemRoot,
                                  IUnknown **ppIUnknownInner, LONG *plDevErrVal);
    STDMETHODIMP drvUnInitializeWia(BYTE* pWiasContext);
    STDMETHODIMP drvDeviceCommand(BYTE *pWiasContext, LONG lFlags, const GUID *pGUIDCommand,
                                  IWiaDrvItem **ppMiniDrvItem, LONG *plDevErrVal);
    STDMETHODIMP drvDeleteItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetCapabilities(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                    WIA_DEV_CAP_DRV **ppCapabilities, LONG *plDevErrVal);
    STDMETHODIMP drvInitItemProperties(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvLockWiaDevice(BYTE  *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvUnLockWiaDevice(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvAnalyzeItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetWiaFormatInfo(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                     WIA_FORMAT_INFO **ppwfi, LONG *plDevErrVal);
    STDMETHODIMP drvNotifyPnpEvent(const GUID *pEventGUID, BSTR bstrDeviceID, ULONG ulReserved);
    STDMETHODIMP drvReadItemProperties(BYTE *pWiaItem, LONG lFlags, ULONG nPropSpec,
                                       const PROPSPEC *pPropSpec, LONG  *plDevErrVal);
    STDMETHODIMP drvWriteItemProperties(BYTE *pWiasContext, LONG lFLags,
                                        PMINIDRV_TRANSFER_CONTEXT pmdtc, LONG *plDevErrVal);
    STDMETHODIMP drvValidateItemProperties(BYTE *pWiasContext, LONG lFlags, ULONG nPropSpec,
                                           const PROPSPEC *pPropSpec, LONG *plDevErrVal);
    STDMETHODIMP drvAcquireItemData(BYTE *pWiasContext, LONG lFlags,
                                    PMINIDRV_TRANSFER_CONTEXT pDataContext, LONG *plDevErrVal);
    STDMETHODIMP drvGetDeviceErrorStr(LONG lFlags, LONG lDevErrVal, LPOLESTR *ppszDevErrStr, LONG *plDevErrVal);
    STDMETHODIMP drvFreeDrvItemContext(LONG lFlags, BYTE *pDevContext, LONG *plDevErrVal);

    //
    // Public helper functions (in eventcb.cpp)
    //
    HRESULT EventCallbackDispatch(PPTP_EVENT pEvent);

private:

    //
    // Private helper functions (in minidriver.cpp)
    //
    HRESULT GetDeviceName(const WCHAR *pwszPortName,
                          WCHAR       *pwszManufacturer,
                          DWORD       cchManufacturer,
                          WCHAR       *pwszModelName,
                          DWORD       cchModelName);

    HRESULT Shutdown();
    HRESULT TakePicture(BYTE *pWiasContext, IWiaDrvItem **ppNewItem);
    LONG    GetTotalFreeImageSpace();
    HRESULT WiasContextToItemContext(BYTE *pWiasContext, DRVITEM_CONTEXT **ppItemContext,
                                     IWiaDrvItem **ppDrvItem = NULL);
    HRESULT LoadStrings();
    HRESULT GetResourceString(LONG lResourceID, WCHAR *pString, int length);
    HRESULT InitVendorExtentions(HKEY hkDevParams);
    HRESULT UpdateStorageInfo(ULONG StorageId);

    //
    // Private helper functions (in devitem.cpp)
    //
    HRESULT CreateDrvItemTree(IWiaDrvItem **ppRoot);
    HRESULT AddObject(DWORD ObjectHandle, BOOL bQueueEvent = FALSE);
    HRESULT InitDeviceProperties(BYTE *pWiasContext);
    HRESULT ReadDeviceProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT WriteDeviceProperties(BYTE *pWiasContext);
    HRESULT ValidateDeviceProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT FindCorrDimension(BYTE *pWiasContext, LONG *pWidth, LONG *pHeight);
    int     FindProportionalValue(int valueX, int minX, int maxX, int minY, int maxY, int stepY);
    PPROP_INFO PropCodeToPropInfo(WORD PropCode);
    int     NumLogicalStorages();

    //
    // Private helper functions (in imgitem.cpp)
    //
    HRESULT InitItemProperties(BYTE *pWiasContext);
    HRESULT IsObjectProtected(CPtpObjectInfo *pObjectInfo, LONG &lProtection);
    HRESULT GetObjectTime(CPtpObjectInfo *pObjectInfo, SYSTEMTIME  *pSystemTime);
    HRESULT ReadItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT CacheThumbnail(PDRVITEM_CONTEXT pDrvItemCtx);
    HRESULT ValidateItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs, LONG ItemType);
    HRESULT AcquireDataAndTranslate(BYTE *pWiasContext, DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);
    HRESULT AcquireAndTranslateJpegWithoutGeometry(BYTE *pWiasContext, DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);
    HRESULT AcquireAndTranslateAnyImage(BYTE *pWiasContext, DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);
    HRESULT AcquireData(DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);

    //
    // Event handling functions (in eventcb.cpp)
    //
    HRESULT AddNewObject(DWORD ObjectHandle);
    HRESULT RemoveObject(DWORD ObjectHandle);
    HRESULT AddNewStorage(DWORD StorageId);
    HRESULT RemoveStorage(DWORD StorageId);
    HRESULT DevicePropChanged(WORD PropCode);
    HRESULT ObjectInfoChanged(DWORD ObjectHandle);
    HRESULT StorageFull(DWORD StorageId);
    HRESULT StorageInfoChanged(DWORD StorageId);
    HRESULT CaptureComplete();
    HRESULT PostVendorEvent(WORD EventCode);

    //
    // Inline utilities
    //
    BOOL IsItemTypeFolder(LONG ItemType)
    {
        return ((WiaItemTypeFolder & ItemType) &&
                !(ItemType & (WiaItemTypeStorage | WiaItemTypeRoot)));
    }

    //
    // Member variables
    //
    WIA_DEV_CAP_DRV    *m_Capabilities;         // List of device capabilities. Build once and use every time we are asked
    UINT                m_nEventCaps;           // Number of events supported
    UINT                m_nCmdCaps;             // Number of commands supported
    BOOL                m_fInitCaptureChecked;  // Indicates if we have already queried camera for InitiateCapture command support

    int                 m_OpenApps;             // Number of apps that are communicating with this driver

    IWiaDrvItem        *m_pDrvItemRoot;         // Pointer to the root of the driver item tree

    CPTPCamera         *m_pPTPCamera;           // Pointer to camera object--actually holds CUsbCamera object
    CPtpDeviceInfo      m_DeviceInfo;           // DeviceInfo structure for the camera
    CArray32            m_StorageIds;           // Holds the current storage ids
    CWiaArray<CPtpStorageInfo>
                        m_StorageInfos;         // Holds the StorageInfo structures
    CWiaArray<CPtpPropDesc>
                        m_PropDescs;            // Property description structures
    CWiaMap<ULONG, IWiaDrvItem *>
                        m_HandleItem;           // Used to map PTP object handles to WIA driver items
    LONG                m_NumImages;            // The number of images currently on the device

    IStiDevice         *m_pStiDevice;           // Pointer to the driver's STI interface
    BSTR                m_bstrDeviceId;         // STI device ID
    BSTR                m_bstrRootItemFullName; // Full name of root item
    PSTIDEVICECONTROL   m_pDcb;                 // Pointer to the IStiDeviceControl interface

    HANDLE              m_TakePictureDoneEvent; // Event handle to indicate when TakePicture command is done
    
    DWORD               m_VendorExtId;          // Vendor extension id (from registry)
    CWiaMap<WORD, PROP_INFO *>
                        m_VendorPropMap;        // Maps PropCodes to PROP_INFO structures
    CWiaMap<WORD, CVendorEventInfo*>
                        m_VendorEventMap;       // Maps EventCodes to event info

    HANDLE              m_hPtpMutex;            // Mutex used for exclusive access to device

    CArray32            m_DcimHandle;           // ObjectHandle of the DCIM folder for each storage, if it exists
    CWiaMap<ULONG, IWiaDrvItem *>
                        m_AncAssocParent;       // Maps ancillary association handles to their parents
    DWORD               m_dwObjectBeingSent;    // Temporary location for object handle between SendObjectInfo and SendObject

    ULONG               m_Refs;                 // Reference count on the object
    IUnknown           *m_punkOuter;            // Pointer to outer IUnknown
};

//
// Functions for handling PTP callbacks
//
HRESULT EventCallback(LPVOID pCallbackParam, PPTP_EVENT pEvent);
HRESULT DataCallback(LPVOID pCallbackParam, LONG lPercentComplete,
                     LONG lOffset, LONG lLength, BYTE **ppBuffer, LONG *plBufferSize);

//
// Helper functions
//
PFORMAT_INFO    FormatCodeToFormatInfo(WORD FormatCode, WORD AssocType = 0);
WORD            FormatGuidToFormatCode(GUID *pFormatGuid);
WORD            PropIdToPropCode(PROPID PropId);
VOID            SplitImageSize(CBstr cbstr, LONG *pWidth, LONG *pHeight);

//
// Simple object for handling mutexes. It will make sure that the mutex is released
// no matter how the function is exited.
//
class CPtpMutex
{
public:
    CPtpMutex(HANDLE hMutex);
    ~CPtpMutex();

private:
    HANDLE m_hMutex;
};

#endif  // #ifndef MINIDRV__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\minidrv.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    minidrv.cpp

Abstract:

    This module implements main part of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include <wiaconv.h>
#include <wiatempl.h>
#include <stiregi.h>
#include "utils.h"

//
// Locations for holding resource strings
//
extern WCHAR UnknownString[];
extern WCHAR FolderString[];
extern WCHAR ScriptString[];
extern WCHAR ExecString[];
extern WCHAR TextString[];
extern WCHAR HtmlString[];
extern WCHAR DpofString[];
extern WCHAR AudioString[];
extern WCHAR VideoString[];
extern WCHAR UnknownImgString[];
extern WCHAR ImageString[];
extern WCHAR AlbumString[];
extern WCHAR BurstString[];
extern WCHAR PanoramaString[];


//
// Structures for setting up WIA capabilities
//
WCHAR DeviceConnectedString[MAX_PATH] = L"\0";
WCHAR DeviceDisconnectedString[MAX_PATH] = L"\0";
WCHAR ItemCreatedString[MAX_PATH] = L"\0";
WCHAR ItemDeletedString[MAX_PATH] = L"\0";
WCHAR TakePictureString[MAX_PATH] = L"\0";
WCHAR SynchronizeString[MAX_PATH] = L"\0";
WCHAR VendorEventIconString[MAX_PATH] = WIA_ICON_DEVICE_CONNECTED;

const BYTE     NUMEVENTCAPS = 4;
const BYTE     NUMCMDCAPS = 2;
WIA_DEV_CAP_DRV g_EventCaps[NUMEVENTCAPS] =
{
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,
        WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT,
        DeviceConnectedString,
        DeviceConnectedString,
        WIA_ICON_DEVICE_CONNECTED
    },
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED,
        WIA_NOTIFICATION_EVENT,
        DeviceDisconnectedString,
        DeviceDisconnectedString,
        WIA_ICON_DEVICE_DISCONNECTED
    },
    {(GUID *)&WIA_EVENT_ITEM_CREATED,
        WIA_NOTIFICATION_EVENT,
        ItemCreatedString,
        ItemCreatedString,
        WIA_ICON_ITEM_CREATED
    },
    {(GUID *)&WIA_EVENT_ITEM_DELETED,
        WIA_NOTIFICATION_EVENT,
        ItemDeletedString,
        ItemDeletedString,
        WIA_ICON_ITEM_DELETED
    }
};

WIA_DEV_CAP_DRV g_CmdCaps[NUMCMDCAPS] =
{
    {(GUID*)&WIA_CMD_SYNCHRONIZE,
        0,
        SynchronizeString,
        SynchronizeString,
        WIA_ICON_SYNCHRONIZE
    },
    {(GUID*)&WIA_CMD_TAKE_PICTURE,
        0,
        TakePictureString,
        TakePictureString,
        WIA_ICON_TAKE_PICTURE
    }
};

//
// Constructor
//
CWiaMiniDriver::CWiaMiniDriver(LPUNKNOWN punkOuter) :
    m_Capabilities(NULL),  
    m_nEventCaps(0),
    m_nCmdCaps(0),
    m_fInitCaptureChecked(FALSE),

    m_OpenApps(0),
    m_pDrvItemRoot(NULL),
    m_pPTPCamera(NULL),
    m_NumImages(0),

    m_pStiDevice(NULL),
    m_bstrDeviceId(NULL),
    m_bstrRootItemFullName(NULL),
    m_pDcb(NULL),
    m_dwObjectBeingSent(0),

    m_TakePictureDoneEvent(NULL),
    m_hPtpMutex(NULL),

    m_Refs(1)
{
    ::InterlockedIncrement(&CClassFactory::s_Objects);
    if (punkOuter)
        m_punkOuter = punkOuter;
    else
        m_punkOuter = (IUnknown *)(INonDelegatingUnknown *)this;
}

//
// Destructor
//
CWiaMiniDriver::~CWiaMiniDriver()
{
    HRESULT hr = S_OK;

    Shutdown();

    m_VendorPropMap.RemoveAll();
    m_VendorEventMap.RemoveAll();

    if (m_Capabilities)
    {
        delete[] m_Capabilities;
    }

    if (m_pStiDevice)
        m_pStiDevice->Release();

    if (m_pDcb)
        m_pDcb->Release();

    UnInitializeGDIPlus();

    ::InterlockedDecrement(&CClassFactory::s_Objects);
}

//
// INonDelegatingUnknown interface
//
STDMETHODIMP_(ULONG)
CWiaMiniDriver::NonDelegatingAddRef()
{
    ::InterlockedIncrement((LONG *)&m_Refs);
    return m_Refs;
}

STDMETHODIMP_(ULONG)
CWiaMiniDriver::NonDelegatingRelease()
{
    ::InterlockedDecrement((LONG*)&m_Refs);
    if (!m_Refs)
    {
        delete this;
        return 0;
    }
    return m_Refs;
}

STDMETHODIMP
CWiaMiniDriver::NonDelegatingQueryInterface(
                                           REFIID riid,
                                           void   **ppv
                                           )
{
    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<INonDelegatingUnknown *>(this);
    else if (IsEqualIID(riid, IID_IStiUSD))
        *ppv = static_cast<IStiUSD *>(this);
    else if (IsEqualIID(riid, IID_IWiaMiniDrv))
        *ppv = static_cast<IWiaMiniDrv *>(this);
    else
    {
        return E_NOINTERFACE;
    }
    //
    // Do not call NonDelegatingAddRef() ....
    //
    (reinterpret_cast<IUnknown *>(*ppv))->AddRef();
    return S_OK;
}

//
// IUnknown interface
//

STDMETHODIMP_(ULONG)
CWiaMiniDriver::AddRef()
{
    return m_punkOuter->AddRef();
}

STDMETHODIMP_(ULONG)
CWiaMiniDriver::Release()
{
    return m_punkOuter->Release();
}

STDMETHODIMP
CWiaMiniDriver::QueryInterface(
                              REFIID riid,
                              void   **ppv
                              )
{
    return m_punkOuter->QueryInterface(riid, ppv);
}


//
// GetDeviceName
//
// This function gets the name of the device from the 
// camera without a session.  We need this because the 
// Initialize function needs to fix up registry
// settings set up by the class installer so that the 
// model name is used instead of the generic
// "Digital Still Camera" name.
//

HRESULT CWiaMiniDriver::GetDeviceName(const WCHAR *pwszPortName,
                                      WCHAR       *pwszManufacturer,
                                      DWORD       cchManufacturer,
                                      WCHAR       *pwszModelName,
                                      DWORD       cchModelName)
{
    DBG_FN("CWiaMiniDriver::GetDeviceName");
    
    HRESULT         hr          = S_OK;
    CPTPCamera      *pPTPCamera = NULL;
    CPtpDeviceInfo  DeviceInfo;

    //
    // If we did receive a valid port name, abort.
    //
    if ((pwszPortName == NULL) || (pwszPortName[0] == 0))
    {
        hr = E_POINTER;
    }

    //
    // Create a new camera object.
    //
    if (hr == S_OK)
    {
        pPTPCamera = new CUsbCamera;

        if (pPTPCamera == NULL)
        {
            hr = E_OUTOFMEMORY;
            wiauDbgError("", "CWiaMiniDriver::GetDeviceName, failed to create "
                         "new camera object, hr = 0x%08lx", hr);
        }
    }

    //
    // Open a connection to the camera
    //
    if (hr == S_OK)
    {
        if (!pPTPCamera->IsCameraOpen())
        {
            hr = pPTPCamera->Open((LPWSTR) pwszPortName, NULL, NULL, NULL, FALSE);
        }

        if (hr != S_OK)
        {
            wiauDbgError("", "CWiaMiniDriver::GetDeviceName, failed to open connection "
                         "to camera, hr = 0x%08lx", hr);
        }
    }

    //
    // Query the camera for its DeviceInfo 
    //
    if (hr == S_OK)
    {
        hr = pPTPCamera->GetDeviceInfo(&DeviceInfo);

        if (hr != S_OK)
        {
            wiauDbgError("", "CWiaMiniDriver::GetDeviceName, GetDeviceInfo failed, "
                         "hr = 0x%08lx", hr);
        }
    }

    //
    // Copy the returned Manufacturer and/or ModelName into the OUT params.
    //
    if (hr == S_OK)
    {
        //
        // If user is requesting manufacturer name, and camera returned a value 
        // for it, copy the name into OUT param.
        //
        if ((pwszManufacturer != NULL) && 
            (cchManufacturer > 0)      && 
            (DeviceInfo.m_cbstrManufacturer.String() != NULL))
        {
            wcsncpy(pwszManufacturer, 
                    DeviceInfo.m_cbstrManufacturer.String(),
                    cchManufacturer);
        }

        //
        // If user is requesting Model name, and camera returned a value 
        // for it, copy the name into OUT param.
        //
        if ((pwszModelName != NULL) && 
            (cchModelName  > 0)      && 
            (DeviceInfo.m_cbstrModel.String() != NULL))
        {
            wcsncpy(pwszModelName, 
                    DeviceInfo.m_cbstrModel.String(),
                    cchModelName);
        }
    }

    //
    // Close the connection to the camera and delete the camera object.
    //
    if (pPTPCamera) 
    {
        pPTPCamera->Close();
        delete pPTPCamera;
    }

    return hr;
}

//
// IStiUSD interface
//
STDMETHODIMP
CWiaMiniDriver::Initialize(
                          PSTIDEVICECONTROL pDcb,
                          DWORD             dwStiVersion,
                          HKEY              hParametersKey
                          )
{
    USES_CONVERSION;

    HRESULT hr;

    wiauDbgInit(g_hInst);

    DBG_FN("CWiaMiniDriver::Initialize");

    if (!pDcb)
        return STIERR_INVALID_PARAM;

    //
    // Check STI specification version number
    //

    m_pDcb = pDcb;
    m_pDcb->AddRef();

    hr = InitVendorExtentions(hParametersKey);
    if (FAILED(hr))
    {
        wiauDbgError("Initialize", "vendor extensions not loaded");
        //
        // Ignore errors from loading vendor extensions
        //
        hr = S_OK;
    }

    ///////////////////////////////////////
    ///////////////////////////////////////
    // Begin Workaround
    //
    // This workaround queries the camera
    // for its name, then resets the FriendlyName
    // and DeviceDesc registry values to reflect
    // this new name.  We do this because PTP
    // cameras can have a generic class ID, in
    // which case the device name from the INF
    // will be "Digital Still Camera".
    //
    // This is what we do:
    //    - Get Friendly Name and Driver Desc from Registry
    //    - If their values are "Digital Still Camera", then attempt to update.
    //    - Query device for its model name
    //    - Extract suffix from FriendlyName that class installer added to device name
    //    - Set FriendlyName to the retrieved ModelName - after appending suffix to it.
    //    - Set DriverDesc to retrieved ModelName.
    //

    HRESULT hrNameChange              = S_OK;
    BOOL    bUpdateDeviceName         = FALSE;
    HKEY    hDeviceData               = NULL;
    LRESULT lResult                   = ERROR_SUCCESS;
    DWORD   dwType                    = 0;
    DWORD   dwSize                    = 0;
    WCHAR   wszPortName[MAX_PATH]     = {0};
    WCHAR   wszManufacturer[255 + 1]  = {0};    // As per PTP spec, max string length is 255
    WCHAR   wszModelName[255 + 1]     = {0};    // As per PTP spec, max string length is 255
    TCHAR   szFriendlyName[511 + 1]   = {0};    // This is size of ModelName, plus suffix added by Class Installer
    TCHAR   szDriverDesc[255 + 1]     = {0};    // This is size of ModelName

    //
    // Get the "QueryDeviceForName" registry entry.
    //
    if (hrNameChange == S_OK)
    {
        lResult = RegOpenKeyEx(hParametersKey, 
                               W2T(REGSTR_VAL_DATA_W),
                               0,
                               KEY_ALL_ACCESS,
                               &hDeviceData);

        //
        // if we failed to open the DeviceData key, assume it doesn't exist
        // and therefore we should not query the device for its name.
        //

        if (lResult == ERROR_SUCCESS)
        {
            dwType = REG_DWORD;
            dwSize = sizeof(bUpdateDeviceName);
            lResult = RegQueryValueEx(hDeviceData,
                                      REGSTR_VAL_QUERYDEVICEFORNAME,
                                      NULL,
                                      &dwType,
                                      (BYTE*) &bUpdateDeviceName,
                                      &dwSize);
        }

        if (lResult != ERROR_SUCCESS)
        {
            bUpdateDeviceName = FALSE;
        }
    }

    if (bUpdateDeviceName)
    {
        //
        // Get the friendly name from the registry.
        //
        if (hrNameChange == S_OK)
        {
            dwType = REG_SZ;
            dwSize = sizeof(szFriendlyName);
            lResult = RegQueryValueEx(hParametersKey, 
                                      W2T(REGSTR_VAL_FRIENDLY_NAME_W),
                                      NULL,
                                      &dwType,
                                      (BYTE*) szFriendlyName,
                                      &dwSize);

            if (lResult != ERROR_SUCCESS)
            {
                //
                // for some reason we couldn't get the value of the FriendlyName.  Abort in this
                // case since there is no reason for this value to not be present and 
                // accessible.
                //
                wiauDbgError("", "CWiaMiniDriver::Initialize, the RegQueryValueEx attempt for "
                             "the 'FriendlyName' failed, this should never happen.  Aborting "
                             "attempt to update PTP device name, lResult = %lu", lResult);

                hrNameChange = E_FAIL;
            }
        }

        //
        // Get the DriverDesc from the registry.
        //
        if (hrNameChange == S_OK)
        {
            dwType = REG_SZ;
            dwSize = sizeof(szDriverDesc);
            lResult = RegQueryValueEx(hParametersKey, 
                                      W2T(REGSTR_VAL_DRIVER_DESC_W),
                                      NULL,
                                      &dwType,
                                      (BYTE*) szDriverDesc,
                                      &dwSize);

            if (lResult != ERROR_SUCCESS)
            {
                //
                // for some reason we couldn't get the value of the DriverDesc.  Abort in this
                // case since there is no reason for this value to not be present and 
                // accessible.
                //
                wiauDbgError("", "CWiaMiniDriver::Initialize, the RegQueryValueEx attempt for "
                             "the 'DriverDesc' failed, this should never happen.  Aborting "
                             "attempt to update PTP device name, lResult = %lu", lResult);

                hrNameChange = E_FAIL;
            }
        }

        //
        // Get the port to speak to the device with.
        //
        if (hrNameChange == S_OK)
        {
            hrNameChange = m_pDcb->GetMyDevicePortName(wszPortName, sizeof(wszPortName));
        }

        //
        // Query the device name for its model and manufacturer name.
        //
        if (hrNameChange == S_OK)
        {
            hrNameChange = GetDeviceName(wszPortName, 
                                         wszManufacturer, 
                                         sizeof(wszManufacturer) / sizeof(WCHAR),
                                         wszModelName, 
                                         sizeof(wszModelName) / sizeof(WCHAR));

            //
            // If we successfully queried the device, also verify that the model name
            // is not empty.  As per the PTP spec, the "Model" variable in the device 
            // info is OPTIONAL.
            //
            if (hrNameChange == S_OK)
            {
                wiauDbgTrace("", "CWiaMiniDriver::Initialize, retrieved device "
                             "info: Name='%ls' Manufacturer='%ls'", 
                             wszModelName, wszManufacturer);

                if (wszModelName[0] == 0)
                {
                    wiauDbgWarning("","CWiaMiniDriver::Initialize, successfully queried "
                                   "the device for its device name, but the device returned "
                                   "an empty model name.  Camera name will NOT be modified");

                    hrNameChange = S_FALSE;
                }
            }
            else
            {
                wiauDbgError("", "CWiaMiniDriver::Initialize, could not get the name "
                             "of the device from the PTP device.  hr = 0x%08lx", hr);
            }
        }

        //
        // Set the FriendlyName registry setting
        //
        // Get the suffix appended to the friendly name.  This suffix is 
        // will be preceeded with a '#'.  
        //
        // NOTE:  This code is dependant on the Class Installer appending 
        //        a '#' as a suffix to the PTP friendly name.  If this 
        //        ever changes, this will have to change too.
        //
        if (hrNameChange == S_OK)
        {
            TCHAR szTemp[63 + 1] = {0};
            TCHAR *pszSuffix = NULL;

            //
            // Look for the suffix on the friendly name
            //
            pszSuffix = _tcsrchr(szFriendlyName, '#');

            //
            // If we found the suffix store the suffix in a temp location.
            //
            if (pszSuffix)
            {
                _tcsncpy(szTemp, pszSuffix, sizeof(szTemp) / sizeof(TCHAR));
            }

            //
            // Build the new friendly name based on the device's model name.
            //
            ZeroMemory(szFriendlyName, sizeof(szFriendlyName));

            if (pszSuffix)
            {
                _sntprintf(szFriendlyName, 
                           sizeof(szFriendlyName) / sizeof(TCHAR),
                           TEXT("%ls %s"),
                           wszModelName,
                           szTemp);
            }
            else
            {
                _sntprintf(szFriendlyName, 
                           sizeof(szFriendlyName) / sizeof(TCHAR),
                           TEXT("%ls"),
                           wszModelName);
            }

            //
            // Write the updated friendly name value into the registry.
            // 
            lResult = RegSetValueEx(hParametersKey,
                                    W2T(REGSTR_VAL_FRIENDLY_NAME_W),
                                    0,
                                    REG_SZ,
                                    (BYTE*) szFriendlyName,
                                    (_tcslen(szFriendlyName) * sizeof(TCHAR)) + sizeof(TCHAR));

            if (lResult != ERROR_SUCCESS)
            {
                hrNameChange = E_FAIL;
                wiauDbgError("", "CWiaMiniDriver::Initialize, failed to write the "
                             "FriendlyName value '%ls' into the registry",
                             szFriendlyName);
            }
        }

        //
        // Update the device's DriverDesc registry value.
        //
        if (hrNameChange == S_OK)
        {
            lResult = RegSetValueEx(hParametersKey,
                                    W2T(REGSTR_VAL_DRIVER_DESC_W),
                                    0,
                                    REG_SZ,
                                    (BYTE*) W2T(wszModelName),
                                    (wcslen(wszModelName) * sizeof(WCHAR)) + sizeof(TCHAR));

            if (lResult != ERROR_SUCCESS)
            {
                hrNameChange = E_FAIL;
                wiauDbgError("", "CWiaMiniDriver::Initialize, failed to write the "
                             "DriverDesc value '%ls' into the registry",
                             wszModelName);
            }
        }

        //
        // Update the QueryDeviceForName value so we don't have to do this 
        // next time this function is called.
        //
        if (hrNameChange == S_OK)
        {
            DWORD dwQueryDeviceForName = 0;

            dwType = REG_DWORD;
            dwSize = sizeof(dwQueryDeviceForName);
            lResult = RegSetValueEx(hDeviceData,
                                    REGSTR_VAL_QUERYDEVICEFORNAME,
                                    0,
                                    REG_DWORD,
                                    (BYTE*) &dwQueryDeviceForName,
                                    dwSize);

            if (lResult != ERROR_SUCCESS)
            {
                hrNameChange = E_FAIL;
                wiauDbgError("", "CWiaMiniDriver::Initialize, failed to update the "
                             "'QueryDeviceForName' value into the registry");
            }
        }
    }

    //
    // Close the HKEY if it was opened.
    //
    if (hDeviceData)
    {
        RegCloseKey(hDeviceData);
        hDeviceData = NULL;
    }
    
    // 
    // End Workaround
    ///////////////////////////////////////
    ///////////////////////////////////////

    return hr;
}


STDMETHODIMP
CWiaMiniDriver::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    DBG_FN("CWiaMiniDriver::GetCapabilities");

    if (!pUsdCaps)
        return STIERR_INVALID_PARAM;

    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;
    pUsdCaps->dwGenericCaps = STI_GENCAP_AUTO_PORTSELECT;


    return S_OK;
}


STDMETHODIMP
CWiaMiniDriver::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    DBG_FN("CWiaMiniDriver::GetStatus");

    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)
        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
    return S_OK;
}

STDMETHODIMP
CWiaMiniDriver::DeviceReset(VOID)
{
    DBG_FN("CWiaMiniDriver::DeviceReset");

    //
    // Camera may not be open if this method is called before
    // drvInitializeWia. For now just return S_OK.

//  return HRESULT_FROM_WIN32(m_pPTPCamera->ResetDevice());

    return S_OK;

}

STDMETHODIMP
CWiaMiniDriver::Diagnostic(LPDIAG pBuffer)
{
    DBG_FN("CWiaMiniDriver::Diagnostic");

    HRESULT hr = STI_OK;

    // Initialize response buffer
    pBuffer->sErrorInfo.dwGenericError = STI_NOTCONNECTED;
    pBuffer->sErrorInfo.dwVendorError = 0;

    STI_DEVICE_STATUS DevStatus;

    //
    // Call status method to verify device is available
    //
    ::ZeroMemory(&DevStatus,sizeof(DevStatus));
    DevStatus.StatusMask = STI_DEVSTATUS_ONLINE_STATE;

    // WIAFIX-8/9/2000-davepar Should this function actually talk to the camera?

    hr = GetStatus(&DevStatus);

    if (SUCCEEDED(hr))
    {
        if (DevStatus.dwOnlineState & STI_ONLINESTATE_OPERATIONAL)
        {
            pBuffer->sErrorInfo.dwGenericError = STI_OK;
        }
    }

    return(hr);
}

STDMETHODIMP
CWiaMiniDriver::SetNotificationHandle(HANDLE hEvent)
{
    DBG_FN("CWiaMiniDriver::SetNotificationHandle");

    // Use wiasQueueEvent instead

    return(S_OK);
}


STDMETHODIMP
CWiaMiniDriver::GetNotificationData(LPSTINOTIFY pBuffer)
{
    DBG_FN("CWiaMiniDriver::GetNotificationData");

    // Use wiasQueueEvent instead

    return STIERR_NOEVENTS;
}

STDMETHODIMP
CWiaMiniDriver::Escape(
                      STI_RAW_CONTROL_CODE    EscapeFunction,
                      LPVOID                  pInData,
                      DWORD                   cbInDataSize,
                      LPVOID                  pOutData,
                      DWORD                   cbOutDataSize,
                      LPDWORD                 pcbActualDataSize
                      )
{
    DBG_FN("CWiaMiniDriver::Escape");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTP_VENDOR_DATA_IN *pVendorDataIn = NULL;
    PTP_VENDOR_DATA_OUT *pVendorDataOut = NULL;
    UINT NumCommandParams = 0;
    INT NextPhase = 0;
    BYTE *pReadData = NULL;
    BYTE *pWriteData = NULL;
    UINT ReadDataSize = 0;
    UINT WriteDataSize = 0;
    DWORD dwObjectToAdd = 0;
    DWORD dwObjectToRemove = 0;
    
    CPtpMutex cpm(m_hPtpMutex);

    if (EscapeFunction & ESCAPE_PTP_VENDOR_COMMAND) {

        REQUIRE_ARGS(!pInData || !pOutData || !pcbActualDataSize, hr, "Escape");

        if (cbInDataSize < SIZEOF_REQUIRED_VENDOR_DATA_IN) {
            wiauDbgError("Escape", "InDataSize is too small");
            hr = E_FAIL;
            goto Cleanup;
        }

        if (cbOutDataSize < SIZEOF_REQUIRED_VENDOR_DATA_OUT) {
            wiauDbgError("Escape", "OutDataSize is too small");
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // Set up some more convenient pointers
        //
        pVendorDataIn = (PTP_VENDOR_DATA_IN *) pInData;
        pVendorDataOut = (PTP_VENDOR_DATA_OUT *) pOutData;

        if (!(pVendorDataIn->OpCode & PTP_DATACODE_VENDORMASK))
        {
            wiauDbgWarning("VendorCommand", "executing non-vendor command");
        }

        NumCommandParams = pVendorDataIn->NumParams;
        NextPhase = pVendorDataIn->NextPhase;

        //
        // Data to write and read buffer are right after command and response,
        // respectively
        //
        if (cbInDataSize > SIZEOF_REQUIRED_VENDOR_DATA_IN) {
            pWriteData = pVendorDataIn->VendorWriteData;
            WriteDataSize = cbInDataSize - SIZEOF_REQUIRED_VENDOR_DATA_IN;
        }

        if (cbOutDataSize > SIZEOF_REQUIRED_VENDOR_DATA_OUT) {
            pReadData = pVendorDataOut->VendorReadData;
            ReadDataSize = cbOutDataSize - SIZEOF_REQUIRED_VENDOR_DATA_OUT;
        }

        hr = m_pPTPCamera->VendorCommand((PTP_COMMAND *) pInData, (PTP_RESPONSE *) pOutData,
                                         &ReadDataSize, pReadData,
                                         WriteDataSize, pWriteData,
                                         NumCommandParams, NextPhase);
        REQUIRE_SUCCESS(hr, "Escape", "VendorCommand failed");

        *pcbActualDataSize = SIZEOF_REQUIRED_VENDOR_DATA_OUT + ReadDataSize;

        //
        // For SendObjectInfo, hand on to handle until SendObject command
        //
        if (pVendorDataIn->OpCode == PTP_OPCODE_SENDOBJECTINFO) {

            m_dwObjectBeingSent = pVendorDataOut->Params[2];

        //
        // For SendObject, add object
        //
        } else if (pVendorDataIn->OpCode == PTP_OPCODE_SENDOBJECT) {

            dwObjectToAdd = m_dwObjectBeingSent;
            m_dwObjectBeingSent = 0;


        //
        // Otherwise, see if add or remove flag is set
        //
        } else {

            if ((EscapeFunction & 0xf) >= PTP_MAX_PARAMS) {
                wiauDbgError("Escape", "Parameter number too large");
                hr = E_FAIL;
                goto Cleanup;
            }

            if (EscapeFunction & ESCAPE_PTP_ADD_OBJ_CMD) {
                dwObjectToAdd = pVendorDataIn->Params[EscapeFunction & 0xf];
            }

            if (EscapeFunction & ESCAPE_PTP_REM_OBJ_CMD) {
                dwObjectToRemove = pVendorDataIn->Params[EscapeFunction & 0xf];
            }

            if (EscapeFunction & ESCAPE_PTP_ADD_OBJ_RESP) {
                dwObjectToAdd = pVendorDataOut->Params[EscapeFunction & 0xf];
            }

            if (EscapeFunction & ESCAPE_PTP_REM_OBJ_RESP) {
                dwObjectToRemove = pVendorDataOut->Params[EscapeFunction & 0xf];
            }
        }

        if (dwObjectToAdd) {
            hr = AddObject(dwObjectToAdd, TRUE);
            REQUIRE_SUCCESS(hr, "Escape", "AddObject failed");
        }

        if (dwObjectToRemove) {
            hr = RemoveObject(dwObjectToRemove);
            REQUIRE_SUCCESS(hr, "Escape", "DeleteObject failed");
        }
    }

    else if(EscapeFunction == ESCAPE_PTP_CLEAR_STALLS) {
        hr = m_pPTPCamera->RecoverFromError();
    }

    else
        hr = STIERR_UNSUPPORTED;

Cleanup:
    return hr;
}


STDMETHODIMP
CWiaMiniDriver::GetLastError(LPDWORD pdwLastDeviceError)
{
    DBG_FN("CWiaMiniDriver::GetLastError");

    HRESULT hr = STI_OK;

    if (IsBadWritePtr(pdwLastDeviceError, 4))
    {
        hr = STIERR_INVALID_PARAM;
    }
    else
    {
        *pdwLastDeviceError = 0;
    }

    return(hr);
}

STDMETHODIMP
CWiaMiniDriver::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    DBG_FN("CWiaMiniDriver::GetLastErrorInfo");

    HRESULT hr = STI_OK;

    if (IsBadWritePtr(pLastErrorInfo, 4))
    {
        hr = STIERR_INVALID_PARAM;
    }
    else
    {
        pLastErrorInfo->dwGenericError = 0;
        pLastErrorInfo->szExtendedErrorText[0] = L'\0';
    }

    return(hr);
}

STDMETHODIMP
CWiaMiniDriver::LockDevice(VOID)
{
    DBG_FN("CWiaMiniDriver::LockDevice");

    return(S_OK);
}

STDMETHODIMP
CWiaMiniDriver::UnLockDevice(VOID)
{
    DBG_FN("CWiaMiniDriver::UnLockDevice");

    return(S_OK);
}

STDMETHODIMP
CWiaMiniDriver::RawReadData(
                           LPVOID lpBuffer,
                           LPDWORD lpdwNumberOfBytes,
                           LPOVERLAPPED lpOverlapped
                           )
{
    DBG_FN("CWiaMiniDriver::RawReadData");

    return(STIERR_UNSUPPORTED);
}

STDMETHODIMP
CWiaMiniDriver::RawWriteData(
                            LPVOID lpBuffer,
                            DWORD   dwNumberOfBytes,
                            LPOVERLAPPED lpOverlapped
                            )
{
    DBG_FN("CWiaMiniDriver::RawWriteData");

    return(STIERR_UNSUPPORTED);
}

STDMETHODIMP
CWiaMiniDriver::RawReadCommand(
                              LPVOID lpBuffer,
                              LPDWORD lpdwNumberOfBytes,
                              LPOVERLAPPED lpOverlapped
                              )
{
    DBG_FN("CWiaMiniDriver::RawReadCommand");

    return(STIERR_UNSUPPORTED);
}

STDMETHODIMP
CWiaMiniDriver::RawWriteCommand(
                               LPVOID lpBuffer,
                               DWORD nNumberOfBytes,
                               LPOVERLAPPED lpOverlapped
                               )
{
    DBG_FN("CWiaMiniDriver::RawWriteCommand");

    return(STIERR_UNSUPPORTED);
}

/////////////////////////////////////////////////////
//
// IWiaMiniDrvItem methods
//
/////////////////////////////////////////////////////

//
// This method is the first call to initialize the mini driver
// This is where a mini driver establish its IWiaDrvItem tree
//
// Input:
//   pWiasContext    -- context used to call Wias service
//   lFlags      -- misc flags. Not used for now
//   bstrDeviceId    -- the device id
//   bstrRootItemFullName -- the full name of root driver item
//   pStiDevice  -- IStiDevice interface pointer
//   punkOuter   -- not used.
//   ppDrvItemRoot   -- to return our root IWiaDrvItem
//   ppunkInner  -- mini driver special interface which allows
//              the applications to directly access.
//   plDevErrVal -- to return device error code.
//
HRESULT
CWiaMiniDriver::drvInitializeWia(
    BYTE        *pWiasContext,
    LONG        lFlags,
    BSTR        bstrDeviceID,
    BSTR        bstrRootItemFullName,
    IUnknown    *pStiDevice,
    IUnknown    *punkOuter,
    IWiaDrvItem **ppDrvItemRoot,
    IUnknown    **ppunkInner,
    LONG        *plDevErrVal
    )
{
#define REQUIRE(x, y) if(!(x)) { wiauDbgError("drvInitializeWia", y); hr = HRESULT_FROM_WIN32(::GetLastError()); goto Cleanup; }
#define REQUIRE_SUCCESS_(x, y) if(FAILED(x)) { wiauDbgError("drvInitializeWia", y); goto Cleanup; }
    DBG_FN("CWiaMiniDriver::drvInitializeWia");

    HRESULT hr = S_OK;
    *plDevErrVal = DEVERR_OK;

    if (!ppDrvItemRoot || !ppunkInner || !plDevErrVal)
    {
        wiauDbgError("drvInitializeWia", "invalid arg");
        return E_INVALIDARG;
    }

    *ppDrvItemRoot = NULL;
    *ppunkInner = NULL;

    m_OpenApps++;

    //
    // If this is the first app, create everything
    //
    if (m_OpenApps == 1)
    {
        //
        // Load the strings from the resource
        //
        hr = LoadStrings();
        REQUIRE_SUCCESS_(hr, "LoadStrings failed");

        //
        // Set up a mutex to guarantee exclusive access to the device and the minidriver's structures
        //
        if(!m_hPtpMutex) {
            m_hPtpMutex = CreateMutex(NULL, FALSE, NULL);
            REQUIRE(m_hPtpMutex, "CreateMutex failed");
        }

        {
            CPtpMutex cpm(m_hPtpMutex);

            *ppDrvItemRoot = NULL;

            //
            // Create event for waiting for TakePicture command to complete
            //
            if (!m_TakePictureDoneEvent)
            {
                m_TakePictureDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                REQUIRE(m_TakePictureDoneEvent, "CreateEvent failed");
            }

            //
            // Allocate strings needed for later
            //
            if (!m_bstrDeviceId)
            {
                m_bstrDeviceId = SysAllocString(bstrDeviceID);
                REQUIRE(m_bstrDeviceId, "failed to allocate Device ID string");
            }

            if (!m_bstrRootItemFullName)
            {
                m_bstrRootItemFullName = SysAllocString(bstrRootItemFullName);
                REQUIRE(m_bstrRootItemFullName, "failed to allocate root item name");
            }

            //
            // Create a camera object. Right now we only handle USB, but in the future this could look at the
            // port name to figure out what type of camera to create.
            //
            if (!m_pPTPCamera)
            {
                m_pPTPCamera = new CUsbCamera;
                REQUIRE(m_pPTPCamera, "failed to new CUsbCamera");
            }

            //
            // Open the camera
            //
            if (!m_pPTPCamera->IsCameraOpen())
            {

                //
                // Retrieve the port name from the ISTIDeviceControl
                //
                WCHAR wcsPortName[MAX_PATH];
                hr = m_pDcb->GetMyDevicePortName(wcsPortName, sizeof(wcsPortName));
                REQUIRE_SUCCESS_(hr, "GetMyDevicePortName failed");
                
                hr = m_pPTPCamera->Open(wcsPortName, &EventCallback, &DataCallback, (LPVOID) this);
                REQUIRE_SUCCESS_(hr, "Camera open failed");
            }

            //
            // Open a session on the camera. Doesn't matter which session ID we use, so just use 1.
            //
            if (!m_pPTPCamera->IsCameraSessionOpen())
            {
                hr = m_pPTPCamera->OpenSession(WIA_SESSION_ID);
                REQUIRE_SUCCESS_(hr, "OpenSession failed");
            }

            //
            // Get the DeviceInfo for the camera
            //
            hr = m_pPTPCamera->GetDeviceInfo(&m_DeviceInfo);
            REQUIRE_SUCCESS_(hr, "GetDeviceInfo failed");

            //
            // Remove properties that aren't supported by WIA. RGB gain isn't supported
            // because PTP defines it as a string and WIA can't handle string ranges.
            //
            m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_RGBGAIN);
            m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_FUNCTIONMODE);

            //
            // Special hack for the Kodak DC4800
            //
            // Some property codes (which the camera says it supports) cause the camera to
            // stall the endpoint when the GetDevicePropDesc command is sent
            // The hack can be removed only if support of DC4800 is removed
            //
            if (m_pPTPCamera->GetHackModel() == HACK_MODEL_DC4800)
            {
                wiauDbgTrace("drvInitializeWia", "removing DC4800 unsupported props");

                const WORD KODAK_PROPCODE_D001 = 0xD001;

                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_RGBGAIN);
                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_FNUMBER);
                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_FOCUSDISTANCE);
                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_EXPOSURETIME);
                m_DeviceInfo.m_SupportedProps.Remove(KODAK_PROPCODE_D001);
            }

            //
            // Get all the StorageInfo structures
            //
            if (m_StorageIds.GetSize() == 0)
            {
                hr = m_pPTPCamera->GetStorageIDs(&m_StorageIds);
                REQUIRE_SUCCESS_(hr, "GetStorageIDs failed");

                CPtpStorageInfo tempSI;
                for (int count = 0; count < m_StorageIds.GetSize(); count++)
                {
                    REQUIRE(m_StorageInfos.Add(tempSI), "memory allocation failed");
                    
                    //
                    // Get info about logical storages only. If we ask for info about non-logical 
                    // storage (ejected media), it may stall the camera.
                    //
                    if (m_StorageIds[count] & PTP_STORAGEID_LOGICAL)
                    {
                        hr = m_pPTPCamera->GetStorageInfo(m_StorageIds[count], &m_StorageInfos[count]);
                        REQUIRE_SUCCESS_(hr, "GetStorageInfo failed");
                    }

                    //
                    // Add an empty entry to the DCIM handle array
                    //
                    ULONG dummy = 0;
                    REQUIRE(m_DcimHandle.Add(dummy), "add dcim handle failed");
                }
            }

            //
            // Get all of the property description structures supported by the device
            //
            if (m_PropDescs.GetSize() == 0)
            {
                CPtpPropDesc tempPD;
                int NumProps = m_DeviceInfo.m_SupportedProps.GetSize();
                REQUIRE(m_PropDescs.GrowTo(NumProps), "reallocation of supported properties array failed");

                PROP_INFO *pPropInfo = NULL;
                WORD PropCode = 0;

                for (int count = 0; count < NumProps; count++)
                {
                    PropCode = m_DeviceInfo.m_SupportedProps[count];

                    //
                    // Remove properties that aren't supported by this driver or by
                    // vendor entries in the INF
                    //
                    pPropInfo = PropCodeToPropInfo(PropCode);
                    if (!pPropInfo->PropId &&
                        PropCode != PTP_PROPERTYCODE_IMAGESIZE)
                    {
                        wiauDbgTrace("drvInitializeWia", "removing unsupported prop, 0x%04x", PropCode);

                        m_DeviceInfo.m_SupportedProps.RemoveAt(count);
                        NumProps--;
                        count--;
                    }

                    else
                    {
                        //
                        // Get the property description info from the device
                        //
                        REQUIRE(m_PropDescs.Add(tempPD), "add prop desc failed");

                        hr = m_pPTPCamera->GetDevicePropDesc(PropCode, &m_PropDescs[count]);
                        REQUIRE_SUCCESS_(hr, "GetDevicePropDesc failed");
                    }
                }
            }

            //
            // Cache the STI interface
            //
            if (!m_pStiDevice)
            {
                m_pStiDevice = (IStiDevice *)pStiDevice;
                m_pStiDevice->AddRef();
            }

            //
            // Build the tree, if we haven't already
            //
            if (!m_pDrvItemRoot)
            {
                hr = CreateDrvItemTree(&m_pDrvItemRoot);
                REQUIRE_SUCCESS_(hr, "CreateDrvItemTree failed");
            }
        }
    }

    *ppDrvItemRoot = m_pDrvItemRoot;
    
Cleanup:
    if(FAILED(hr)) {
        // force re-init to happen next time someone tries to create
        // device
        m_OpenApps = 0;
    }
    
    return hr;
}


//
// This methods gets called when a client connection is going away.
//
// Input:
//   pWiasContext -- Pointer to the WIA Root item context of the client's item tree.
//
HRESULT
CWiaMiniDriver::drvUnInitializeWia(BYTE *pWiasContext)
{
    DBG_FN("CWiaMiniDriver::drvUnInitializeWia");

    HRESULT hr = S_OK;

    if (!pWiasContext)
    {
        wiauDbgError("drvUnInitializeWia", "invalid arg");
        return E_INVALIDARG;
    }

    m_OpenApps--;

    if (m_OpenApps == 0)
    {
        Shutdown();
    }

    if(m_OpenApps < 0) {

        // allow unmatched drvUninializeWia calls and don't ever make
        // m_OpenApps negative
        
        m_OpenApps = 0;
    }

    return hr;
}

//
// This method executes a command on the device
//
// Input:
//   pWiasContext -- context used to call wias services
//   lFlags       -- Misc flags, not used
//   pCommandGuid -- the command guid
//   ppDrvItem    -- new IWiaDrvItem if the command creates new item
//   plDevErrVal  -- to return device error code
//
HRESULT
CWiaMiniDriver::drvDeviceCommand(
    BYTE    *pWiasContext,
    LONG    lFlags,
    const GUID  *pCommandGuid,
    IWiaDrvItem **ppDrvItem,
    LONG    *plDevErrVal
    )
{
    DBG_FN("CWiaMiniDriver::drvDeviceCommand");
    HRESULT hr = S_OK;

    if (!pWiasContext || !pCommandGuid || !ppDrvItem || !plDevErrVal)
    {
        wiauDbgError("drvDeviceCommand", "invalid arg");
        return E_INVALIDARG;
    }

    *ppDrvItem = NULL;
    *plDevErrVal = DEVERR_OK;

    if (*pCommandGuid == WIA_CMD_TAKE_PICTURE && m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_INITIATECAPTURE) >= 0)
    {
        LONG ItemType = 0;
        hr = wiasGetItemType(pWiasContext, &ItemType);
        if (FAILED(hr))
        {
            wiauDbgError("drvDeviceCommand", "wiasGetItemType failed");
            return hr;
        }

        //
        // TakePicture only works on the root
        //

        if (WiaItemTypeRoot & ItemType)
        {
            hr = WriteDeviceProperties(pWiasContext);
            if (FAILED(hr))
            {
                wiauDbgError("drvDeviceCommand", "WriteDeviceProperties failed");
                return hr;
            }

            hr = TakePicture(pWiasContext, ppDrvItem);
            if (FAILED(hr))
            {
                wiauDbgError("drvDeviceCommand", "TakePicture failed");
                return hr;
            }
        }
    }

    else if (*pCommandGuid == WIA_CMD_SYNCHRONIZE)
    {
        //
        // Don't need to do anything, because the PTP driver is always in sync with the device
        //
    }

    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

//
// This method deletes an object from the camera. The WIA service will ensure that
// the item has no children and has access rights to be deleted, and the service will
// take care of deleting the driver item and calling drvFreeItemContext.
//
// Input:
//   pWiasContext    -- wias context that identifies the item
//   lFlags      -- misc flags
//   plDevErrVal -- to return the device error
//
STDMETHODIMP
CWiaMiniDriver::drvDeleteItem(
                             BYTE *pWiasContext,
                             LONG lFlags,
                             LONG  *plDevErrVal
                             )
{
    DBG_FN("CWiaMiniDriver::drvDeleteItem");

    HRESULT hr = S_OK;

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvDeleteItem", "invalid arg");
        return E_INVALIDARG;
    }

    // 
    // Verify that PTP_OPCODE_DELETEOBJECT command is supported by the camera
    //
    if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_DELETEOBJECT) < 0)
    {
        wiauDbgError("drvDeleteItem", "PTP_OPCODE_DELETEOBJECT command is not supported by the camera");
        return E_NOTIMPL;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);
    
    IWiaDrvItem *pDrvItem;
    DRVITEM_CONTEXT *pItemCtx;

    hr = WiasContextToItemContext(pWiasContext, &pItemCtx, &pDrvItem);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // Delete the object on the camera
    //
    hr = m_pPTPCamera->DeleteObject(pItemCtx->pObjectInfo->m_ObjectHandle, 0);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "DeleteObject failed");
        return hr;
    }

    //
    // Keep count of the number of images
    //
    if (pItemCtx->pObjectInfo->m_FormatCode & PTP_FORMATMASK_IMAGE)
    {
        m_NumImages--;
    }

    //
    // Update Storage Info (we are especially interested in Free Space info)
    //
    hr  = UpdateStorageInfo(pItemCtx->pObjectInfo->m_StorageId);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "UpdateStorageInfo failed");
        // we can proceed, even if storage info can't be updated
    }

    //
    // Remove the item from the m_HandleItem map
    //
    m_HandleItem.Remove(pItemCtx->pObjectInfo->m_ObjectHandle);

    //
    // Get the item's full name
    //
    BSTR bstrFullName;
    hr = pDrvItem->GetFullItemName(&bstrFullName);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "GetFullItemName failed");
        return hr;
    }
        
    //
    // Queue an "item deleted" event
    //
    hr = wiasQueueEvent(m_bstrDeviceId,
                        &WIA_EVENT_ITEM_DELETED,
                        bstrFullName);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "drvDeleteItem", "wiasQueueEvent failed");

        // Continue to free the string and return hr
    }

    SysFreeString(bstrFullName);

    return hr;
}

//
// This method updates Storage Info for the specified storage
// Input:
//   StorageId - ID of the sorage to be updated
//
HRESULT CWiaMiniDriver::UpdateStorageInfo(ULONG StorageId)
{
    HRESULT hr = S_FALSE;
    BOOL bDone = FALSE;
    for (int count = 0; (count < m_StorageIds.GetSize()) && (!bDone); count++)
    {
        if (m_StorageIds[count] == StorageId)
        {
            bDone = TRUE;
            hr = m_pPTPCamera->GetStorageInfo(m_StorageIds[count], &m_StorageInfos[count]);
        }
    }
    return hr;
}

//
// This method returns the device capabilities
//
// Input:
//   pWiasContext        -- wias service context
//   lFlags          -- indicate what capabilities to return
//   pCelt           -- to return number of entries are returned
//   ppCapbilities       -- to receive the capabilities
//   plDevErrVal     -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvGetCapabilities(
                                  BYTE        *pWiasContext,
                                  LONG        lFlags,
                                  LONG        *pCelt,
                                  WIA_DEV_CAP_DRV **ppCapabilities,
                                  LONG        *plDevErrVal
                                  )
{
    DBG_FN("CWiaMiniDriver::drvGetCapabilities");

    HRESULT hr = S_OK;

    if (!pCelt || !ppCapabilities || !plDevErrVal)
    {
        wiauDbgError("drvGetCapabilities", "invalid arg");
        return E_INVALIDARG;
    }
    
    *plDevErrVal = DEVERR_OK;
    
    //
    // Load the strings from the resource
    //
    hr = LoadStrings();
    if (FAILED(hr)) 
    {
        wiauDbgError("drvGetCapabilities", "LoadStrings failed");
        return E_FAIL;
    }

    //
    // check if we have already built the list of capabilities. If not, build it
    // It will have the following structure:
    //
    // XXXXXXXXXXXXXXXXXXXXXXXXX YYYYYYYYYYYYYYYYYYYYYYYYYYY ZZZZZZZZZZZZZZZZZZZZZZZ
    //    (predefined events)          (vendor events)        (predefined commands)
    //
    if (m_Capabilities == NULL)
    {
        UINT nVendorEvents = m_VendorEventMap.GetSize();
        if (nVendorEvents > MAX_VENDOR_EVENTS)
        {
            wiauDbgWarning("drvGetCapabilities", "vendor events limit exceeded, ignoring events over limit");
            nVendorEvents = MAX_VENDOR_EVENTS;
        }

        m_nEventCaps = NUMEVENTCAPS + nVendorEvents;
        m_nCmdCaps = NUMCMDCAPS; // we don't need to put vendor commands in the list. they are called through escape function

        m_Capabilities = new WIA_DEV_CAP_DRV[m_nEventCaps + m_nCmdCaps]; // WIA uses this array instead of copying, don't delete it
        if (m_Capabilities == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // create events first
        //
        memcpy(m_Capabilities, g_EventCaps, sizeof(g_EventCaps)); // default events

        for (UINT i = 0; i < nVendorEvents; i++) // vendor events
        {
            CVendorEventInfo *pEventInfo = m_VendorEventMap.GetValueAt(i);
            m_Capabilities[NUMEVENTCAPS + i].guid = pEventInfo->pGuid;
            m_Capabilities[NUMEVENTCAPS + i].ulFlags = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
            m_Capabilities[NUMEVENTCAPS + i].wszIcon = VendorEventIconString;
            m_Capabilities[NUMEVENTCAPS + i].wszName = pEventInfo->EventName;
            m_Capabilities[NUMEVENTCAPS + i].wszDescription = pEventInfo->EventName;
        }

        //
        // add commands
        //
        memcpy(m_Capabilities + m_nEventCaps, g_CmdCaps, sizeof(g_CmdCaps));
    }

    //
    // eventing code calls this entry point without first going
    // through drvInitializeWia
    //
    if(lFlags == WIA_DEVICE_EVENTS) 
    {
        *pCelt = m_nEventCaps;
        *ppCapabilities = m_Capabilities;
        return S_OK;
    }
    
    //
    // query if camera supports InitiateCapture command (if we hadn't already)
    //
    if (!m_fInitCaptureChecked)
    {
        m_fInitCaptureChecked = TRUE;
        CPtpMutex cpm(m_hPtpMutex); 
        
        if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_INITIATECAPTURE) < 0)
        {
            m_nCmdCaps--;
        }
    }

    //
    // Report commands or (events and commands)
    //
    switch (lFlags)
    {
    case WIA_DEVICE_COMMANDS:
        *pCelt = m_nCmdCaps;
        //
        // Command capability list is right behind the event list
        //
        *ppCapabilities = m_Capabilities + m_nEventCaps;
        break;

    case (WIA_DEVICE_EVENTS | WIA_DEVICE_COMMANDS):
        *pCelt = m_nEventCaps + m_nCmdCaps;
        *ppCapabilities = m_Capabilities;
        break;

    default:
        break;
    }

    return hr;
}

//
// This method initializes an item's properties. If the item is the
// root item, this function initializes the device properties.
//
// Input:
//   pWiasContext -- wias service context
//   lFlags -- misc flags
//   plDevErrVal -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvInitItemProperties(
                                     BYTE    *pWiasContext,
                                     LONG    lFlags,
                                     LONG    *plDevErrVal
                                     )
{
    DBG_FN("CWiaMiniDriver::drvInitItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvInitItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "drvInitItemProperties", "wiasGetItemType failed");
        return hr;
    }

    if (ItemType & WiaItemTypeRoot)
    {
        hr = InitDeviceProperties(pWiasContext);
        if (FAILED(hr))
        {
            wiauDbgError("drvInitItemProperties", "InitDeviceProperties failed");
            return hr;
        }
    }
    else
    {
        hr = InitItemProperties(pWiasContext);
        if (FAILED(hr))
        {
            wiauDbgError("drvInitItemProperties", "InitItemProperties failed");
            return hr;
        }
    }

    return hr;
}


//
// This method locks the device for exclusive use for the caller
//
// Input:
//   pWiasContext -- wias context
//   lFlags       -- misc flags
// Output:
//   plDevErrVal  -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvLockWiaDevice(
                                BYTE    *pWiasContext,
                                LONG    lFlags,
                                LONG    *plDevErrVal
                                )
{
    DBG_FN("CWiaMiniDriver::drvLockWiaDevice");

    *plDevErrVal = DEVERR_OK;
    return (m_pStiDevice->LockDevice(INFINITE));
}

//
// This method unlocks the device
//
// Input:
//   pWiasContext -- wias context
//   lFlags       -- misc flags
// Output:
//   plDevErrVal  -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvUnLockWiaDevice(
                                  BYTE    *pWiasContext,
                                  LONG    lFlags,
                                  LONG    *plDevErrVal
                                  )
{
    DBG_FN("CWiaMiniDriver::drvUnLockWiaDevice");

    *plDevErrVal = DEVERR_OK;
    return (m_pStiDevice->UnLockDevice());
}

//
// This method analyizes the given driver item. It is not implemented for cameras.
//
// Input:
//   pWiasContext -- wias context
//   lFlags       -- misc flags
// Output:
//   plDevErrVal  -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvAnalyzeItem(
                              BYTE *pWiasContext,
                              LONG lFlags,
                              LONG *plDevErrVal
                              )
{
    DBG_FN("CWiaMiniDriver::drvAnalyzeItem");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvAnalyzeItem", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    return E_NOTIMPL;
}

//
// This method returns the item's available format information. Every WIA
// minidriver must support WiaImgFmt_BMP and WiaImgFmt_MEMORYBMP. This could
// be a problem, because this driver can only decode JPEG and TIFF currently.
// For other formats, we will not advertise BMP formats.
//
// Input:
//   pWiasContext -- wias service context
//   lFlags       -- misc flags
//   pcelt        -- to return how many format info the item has
//   ppwfi        -- to hold a pointer to the format info
// Output:
//   plDevErrVal  -- to return device error code
//
STDMETHODIMP
CWiaMiniDriver::drvGetWiaFormatInfo(
                                   BYTE    *pWiasContext,
                                   LONG    lFlags,
                                   LONG    *pcelt,
                                   WIA_FORMAT_INFO **ppwfi,
                                   LONG    *plDevErrVal
                                   )
{
    DBG_FN("CWiaMiniDriver::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pcelt || !ppwfi || !plDevErrVal)
    {
        wiauDbgError("drvGetWiaFormatInfo", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    *pcelt = 0;
    *ppwfi = NULL;

    DRVITEM_CONTEXT *pItemCtx = NULL;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("drvGetWiaFormatInfo", "WiasContextToItemContext failed");
        return hr;
    }

    if (!pItemCtx)
    {
        wiauDbgError("drvGetWiaFormatInfo", "item context is null");
        return E_FAIL;
    }

    if (!pItemCtx->pFormatInfos)
    {
        //
        // The format info list is not intialized. Do it now.
        //

        LONG ItemType;
        DWORD ui32;

        hr = wiasGetItemType(pWiasContext, &ItemType);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "drvGetWiaFormatInfo", "wiasGetItemType failed");
            return hr;
        }

        if (ItemType & WiaItemTypeFile)
        {
            //
            // Create the supported format for the item, based on the format stored in the
            // ObjectInfo structure.
            //
            if (!pItemCtx->pObjectInfo)
            {
                wiauDbgError("drvGetWiaFormatInfo", "pObjectInfo not initialized");
                return E_FAIL;
            }

            //
            // If the format is JPEG or TIFF based, add the BMP types to the format array,
            // since this driver can convert those to BMP
            //
            WORD FormatCode = pItemCtx->pObjectInfo->m_FormatCode;
            BOOL bAddBmp = (FormatCode == PTP_FORMATCODE_IMAGE_EXIF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_TIFFEP) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_TIFF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JFIF) || 
                           (FormatCode == PTP_FORMATCODE_IMAGE_FLASHPIX) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_BMP) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_CIFF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_GIF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JFIF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_PCD) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_PICT) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_PNG) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_TIFFIT) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JP2) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JPX);


            ULONG NumWfi = bAddBmp ? 2 : 1;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            WIA_FORMAT_INFO *pwfi = new WIA_FORMAT_INFO[2 * NumWfi];
            if (!pwfi)
            {
                wiauDbgError("drvGetWiaFormatInfo", "memory allocation failed");
                return E_OUTOFMEMORY;
            }

            FORMAT_INFO *pFormatInfo = FormatCodeToFormatInfo(FormatCode);
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].lTymed = TYMED_CALLBACK;
            
            if(pFormatInfo->FormatGuid) {
                pwfi[0].guidFormatID = *pFormatInfo->FormatGuid;
                pwfi[1].guidFormatID = *pFormatInfo->FormatGuid;
            } else {
                pwfi[0].guidFormatID = WiaImgFmt_UNDEFINED;
                pwfi[1].guidFormatID = WiaImgFmt_UNDEFINED;
            }

            //
            // Add the BMP entries when appropriate
            //
            if (bAddBmp)
            {
                pwfi[2].guidFormatID = WiaImgFmt_BMP;
                pwfi[2].lTymed = TYMED_FILE;
                pwfi[3].guidFormatID = WiaImgFmt_MEMORYBMP;
                pwfi[3].lTymed = TYMED_CALLBACK;
            }

            pItemCtx->NumFormatInfos = 2 * NumWfi;
            pItemCtx->pFormatInfos = pwfi;

        }

        else if ((ItemType & WiaItemTypeFolder) ||
                 (ItemType & WiaItemTypeRoot))
        {
            //
            // Folders and the root don't really need format info, but some apps may fail
            // without it. Create a fake list just in case.
            //
            pItemCtx->pFormatInfos = new WIA_FORMAT_INFO[2];

            if (!pItemCtx->pFormatInfos)
            {
                wiauDbgError("drvGetWiaFormatInfo", "memory allocation failed");
                return E_OUTOFMEMORY;
            }

            pItemCtx->NumFormatInfos = 2;
            pItemCtx->pFormatInfos[0].lTymed = TYMED_FILE;
            pItemCtx->pFormatInfos[0].guidFormatID = FMT_NOTHING;
            pItemCtx->pFormatInfos[1].lTymed = TYMED_CALLBACK;
            pItemCtx->pFormatInfos[1].guidFormatID = FMT_NOTHING;
        }
    }

    *pcelt = pItemCtx->NumFormatInfos;
    *ppwfi = pItemCtx->pFormatInfos;

    return hr;
}

//
// This method processes pnp events
//
// Input:
//   pEventGuid   -- the event identifier
//   bstrDeviceId -- the designated device
//   ulReserved   -- reserved
//
STDMETHODIMP
CWiaMiniDriver::drvNotifyPnpEvent(
                                 const GUID  *pEventGuid,
                                 BSTR    bstrDeviceId,
                                 ULONG   ulReserved
                                 )
{
    return S_OK;
}

//
// This method reads the item properties
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     NumPropSpecs     -- number of properties to be read
//     pPropSpecs       -- an array of PROPSPEC that specifies
//                 what properties should be read
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvReadItemProperties(
                                     BYTE    *pWiasContext,
                                     LONG    lFlags,
                                     ULONG   NumPropSpecs,
                                     const PROPSPEC *pPropSpecs,
                                     LONG    *plDevErrVal
                                     )
{
    DBG_FN("CWiaMiniDriver::drvReadItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pPropSpecs || !plDevErrVal)
    {
        wiauDbgError("drvReadItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvReadItemProperties", "wiasGetItemType failed");
        return hr;
    }

    if (WiaItemTypeRoot & ItemType)
        hr = ReadDeviceProperties(pWiasContext, NumPropSpecs, pPropSpecs);
    else
        hr = ReadItemProperties(pWiasContext, NumPropSpecs, pPropSpecs);

    return hr;
}

//
// This method writes the item properties
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     pmdtc            -- mini driver transfer context
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvWriteItemProperties(
                                      BYTE    *pWiasContext,
                                      LONG    lFlags,
                                      PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                      LONG    *plDevErrVal
                                      )
{
    DBG_FN("CWiaMiniDriver::drvWriteItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pmdtc || !plDevErrVal)
    {
        wiauDbgError("drvWriteItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvWriteItemProperties", "wiasGetItemType failed");
        return hr;
    }

    //
    // Only properties to write are on the root
    //

    if (WiaItemTypeRoot & ItemType)
    {
        hr = WriteDeviceProperties(pWiasContext);
        if (FAILED(hr))
        {
            wiauDbgError("drvWriteItemProperties", "WriteDeviceProperties failed");
            return hr;
        }
    }

    return hr;
}

//
// This method validates the item properties
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     NumPropSpecs     -- number of properties to be read
//     pPropSpecs       -- an array of PROPSPEC that specifies
//                 what properties should be read
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvValidateItemProperties(
                                         BYTE    *pWiasContext,
                                         LONG    lFlags,
                                         ULONG   NumPropSpecs,
                                         const   PROPSPEC *pPropSpecs,
                                         LONG    *plDevErrVal
                                         )
{
    DBG_FN("CWiaMiniDriver::drvValidateItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pPropSpecs || !plDevErrVal)
    {
        wiauDbgError("drvValidateItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvValidateItemProperties", "wiasGetItemType failed");
        return hr;
    }

    if (WiaItemTypeRoot & ItemType)
    {
        hr = ValidateDeviceProperties(pWiasContext, NumPropSpecs, pPropSpecs);
        if (FAILED(hr))
        {
            wiauDbgError("drvValidateItemProperties", "ValidateDeviceProperties failed");
            return hr;
        }
    }
    else
    {
        hr = ValidateItemProperties(pWiasContext, NumPropSpecs, pPropSpecs, ItemType);
        if (FAILED(hr))
        {
            wiauDbgError("drvValidateItemProperties", "ValidateItemProperties failed");
            return hr;
        }
    }

    return hr;
}

//
// This method acquires the item's data
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     pmdtc            -- mini driver transfer context
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvAcquireItemData(
                                  BYTE    *pWiasContext,
                                  LONG    lFlags,
                                  PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                  LONG    *plDevErrVal
                                  )
{
    DBG_FN("CWiaMiniDriver::drvAcquireItemData");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pmdtc || !plDevErrVal)
    {
        wiauDbgError("drvAcquireItemData", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;

    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvAcquireItemData", "wiasGetItemType failed");
        return hr;
    }

    DRVITEM_CONTEXT *pItemCtx;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("AcquireData", "WiasContextToItemContext failed");
        return hr;
    }

    wiauDbgTrace("drvAcquireItemData", "transferring image with tymed, 0x%08x", pmdtc->tymed);

    //
    // Translate to BMP, if needed. Otherwise just transfer the data.
    //
    if ((IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
         IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) &&
         (pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_BMP))
    {
        hr = AcquireDataAndTranslate(pWiasContext, pItemCtx, pmdtc);
        if (FAILED(hr))
        {
            wiauDbgError("drvAcquireItemData", "AcquireDataAndTranslate failed");
            return hr;
        }
    }
    else
    {
        hr = AcquireData(pItemCtx, pmdtc);
        if (FAILED(hr))
        {
            wiauDbgError("drvAcquireItemData", "AcquireData failed");
            return hr;
        }
    }

    return hr;
}

//
// This method returns a description about the given device error code
//
// Input:
//   lFlags      -- misc flags
//   lDevErrVal  -- the designated error code
//   ppDevErrStr -- to receive a string pointer to the description
//   plDevErrVal -- device error code(used to report error if this method
//                  need to retreive the string from the device
//
STDMETHODIMP
CWiaMiniDriver::drvGetDeviceErrorStr(
                                    LONG    lFlags,
                                    LONG    lDevErrVal,
                                    LPOLESTR    *ppDevErrStr,
                                    LONG    *plDevErrVal
                                    )
{
    DBG_FN("CWiaMiniDriver::drvGetDeviceErrorStr");

    HRESULT hr = S_OK;

    if (!ppDevErrStr || !plDevErrVal)
    {
        wiauDbgError("drvGetDeviceErrorStr", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal  = DEVERR_OK;

    //
    // WIAFIX-10/2/2000-davepar No device-specific errors at this time
    //

    return E_NOTIMPL;
}

//
// This method frees the given driver item context
//
// Input:
//   lFlags      -- misc flags
//   pItemCtx    -- the item context to be freed
//   plDevErrVal -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvFreeDrvItemContext(
                                     LONG lFlags,
                                     BYTE  *pContext,
                                     LONG *plDevErrVal
                                     )
{
    DBG_FN("CWiaMiniDriver::drvFreeDrvItemContext");

    HRESULT hr = S_OK;

    if (!pContext || !plDevErrVal)
    {
        wiauDbgError("drvFreeDrvItemContext", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    DRVITEM_CONTEXT *pItemCtx = (DRVITEM_CONTEXT *)pContext;

    if (pItemCtx)
    {
        if (pItemCtx->pThumb)
        {
            delete []pItemCtx->pThumb;
            pItemCtx->pThumb = NULL;
        }

        if (pItemCtx->pFormatInfos)
        {
            delete [] pItemCtx->pFormatInfos;
            pItemCtx->pFormatInfos = NULL;
        }

        if (pItemCtx->pObjectInfo)
        {
            delete pItemCtx->pObjectInfo;
        }
    }

    return hr;
}

//
// This function will shutdown the driver
//
HRESULT
CWiaMiniDriver::Shutdown()
{
    DBG_FN("CWiaMiniDriver::Shutdown");

    HRESULT hr = S_OK;

    //
    // Close the camera
    //
    wiauDbgTrace("Shutdown", "closing connection with camera");

    if (m_pPTPCamera) {
        hr = m_pPTPCamera->Close();
        if (FAILED(hr))
        {
            wiauDbgError("Shutdown", "Close failed");
        }
    }

    //
    // Free data structures
    //
    if (m_pDrvItemRoot)
    {
        m_pDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);
        m_pDrvItemRoot = NULL;
    }

    if (m_pPTPCamera)
    {
        delete m_pPTPCamera;
        m_pPTPCamera = NULL;
    }

    m_StorageIds.RemoveAll();
    m_StorageInfos.RemoveAll();
    m_PropDescs.RemoveAll();
    m_HandleItem.RemoveAll();
    m_NumImages = 0;

    if (m_bstrDeviceId)
    {
        SysFreeString(m_bstrDeviceId);
        m_bstrDeviceId = NULL;
    }

    if (m_bstrRootItemFullName)
    {
        SysFreeString(m_bstrRootItemFullName);
        m_bstrRootItemFullName = NULL;
    }

    if (m_TakePictureDoneEvent) {
        CloseHandle(m_TakePictureDoneEvent);
        m_TakePictureDoneEvent = NULL;
    }

    if (m_hPtpMutex) {
        CloseHandle(m_hPtpMutex);
        m_hPtpMutex = NULL;
    }

    m_DcimHandle.RemoveAll();
    m_AncAssocParent.RemoveAll();

    return hr;
}

//
// This function asks the camera to take a picture. It also inserts
// the new picture into the drive item tree.
//
// Input:
//   pWiasContext        -- wias context
//   lFlags          -- misc flags
//   plDevErrVal     -- to return device error code
//
HRESULT
CWiaMiniDriver::TakePicture(
                           BYTE *pWiasContext,
                           IWiaDrvItem **ppNewItem
                           )
{
    DBG_FN("CWiaMiniDriver::TakePicture");

    HRESULT hr = S_OK;

    if (!pWiasContext || !ppNewItem)
    {
        wiauDbgError("TakePicture", "invalid arg");
        return E_INVALIDARG;
    }

    IWiaDrvItem     *pDrvItem, *pParentItem;
    DRVITEM_CONTEXT *pItemCtx = NULL;

    *ppNewItem = NULL;

    WORD FormatCode = 0;

    //
    // Kodak DC4800 must have the format code parameter set to zero
    // This hack can be removed only if support of Kodak DC4800 is removed
    //
    if (m_pPTPCamera->GetHackModel() == HACK_MODEL_DC4800)
    {
        FormatCode = 0;
    }
    else
    {
        //
        // Determine which format to capture
        //
        GUID FormatGuid;
        hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGuid, NULL, TRUE);
        if (FAILED(hr))
        {
            wiauDbgError("TakePicture", "wiasReadPropLong failed");
            return hr;
        }

        FormatCode = FormatGuidToFormatCode(&FormatGuid);
    }

    {
        CPtpMutex cpm(m_hPtpMutex);

        //
        // Reset the event that is waited upon below
        //
        if (!ResetEvent(m_TakePictureDoneEvent))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "TakePicture", "ResetEvent failed");
            return hr;
        }

        //
        // Start the image capture
        //
        hr = m_pPTPCamera->InitiateCapture(PTP_STORAGEID_DEFAULT, FormatCode);
        if (FAILED(hr))
        {
            wiauDbgError("TakePicture", "InitiateCapture failed");
            return hr;
        }
    }

    //
    // Wait for the TakePicture command to be done, indicated by CaptureComplete or StoreFull event.
    // Time out after 30 seconds.
    //

    if (WaitForSingleObject(m_TakePictureDoneEvent, 30 * 1000) != WAIT_OBJECT_0)
    {
        wiauDbgWarning("TakePicture", "WaitForSingleObject timed out");
        return S_FALSE;
    }

    //
    // The last item added to the m_HandleItem map will be the new object
    //
    wiauDbgTrace("TakePicture", "new picture is 0x%08x", m_HandleItem.GetKeyAt(m_HandleItem.GetSize() - 1));

    *ppNewItem = m_HandleItem.GetValueAt(m_HandleItem.GetSize() - 1);

    return hr;
}

//
// This function add up all the free image space on each storage.
//
LONG
CWiaMiniDriver::GetTotalFreeImageSpace()
{
    DBG_FN("CWiaMiniDriver::GetTotalFreeImageSpace");

    int count;
    LONG imageSpace = 0;
    for (count = 0; count < m_StorageInfos.GetSize(); count++)
    {
        imageSpace += m_StorageInfos[count].m_FreeSpaceInImages;
    }

    return imageSpace;
}

//
// This function gets the item context from the given wias context and
// optionally return the target IWiaDrvItem. At least one of ppItemContext
// and ppDrvItem must be valid.
//
// Input:
//   pWiasContext -- wias context obtained from every drvxxxx method
//   ppItemContext -- optional parameter to receive the item context
//   ppDrvItem -- optional parameter to receive the IWiaDrvItem
//
HRESULT
CWiaMiniDriver::WiasContextToItemContext(
    BYTE *pWiasContext,
    DRVITEM_CONTEXT **ppItemContext,
    IWiaDrvItem     **ppDrvItem
    )
{
    DBG_FN("CWiaMiniDriver::WiasContextToItemContext");

    HRESULT hr = S_OK;

    IWiaDrvItem *pWiaDrvItem;

    if (!pWiasContext || (!ppItemContext && !ppDrvItem))
    {
        wiauDbgError("WiasContextToItemContext", "invalid arg");
        return E_INVALIDARG;
    }

    if (ppDrvItem)
        *ppDrvItem = NULL;

    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "WiasContextToItemContext", "wiasGetDrvItem failed");
        return hr;
    }

    if (ppDrvItem)
        *ppDrvItem = pWiaDrvItem;

    if (ppItemContext)
    {
        *ppItemContext = NULL;
        hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **)ppItemContext);
        if (FAILED(hr))
        {
            wiauDbgError("WiasContextToItemContext", "GetDeviceSpecContext failed");
            return hr;
        }
    }

    return hr;
}

//
// This function loads all the object name strings
//
HRESULT
CWiaMiniDriver::LoadStrings()
{
    HRESULT hr = S_OK;

    if (UnknownString[0] != L'\0')
    {
        //
        // The strings are already loaded
        //
        return hr;
    }

    hr = GetResourceString(IDS_UNKNOWNSTRING, UnknownString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_FOLDERSTRING, FolderString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_SCRIPTSTRING, ScriptString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_EXECSTRING, ExecString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_TEXTSTRING, TextString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_HTMLSTRING, HtmlString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_DPOFSTRING, DpofString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_AUDIOSTRING, AudioString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_VIDEOSTRING, VideoString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_UNKNOWNIMGSTRING, UnknownImgString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_IMAGESTRING, ImageString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_ALBUMSTRING, AlbumString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_BURSTSTRING, BurstString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_PANORAMASTRING, PanoramaString, MAX_PATH);
    if (FAILED(hr)) return hr;

    hr = GetResourceString(IDS_DEVICECONNECTED, DeviceConnectedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_DEVICEDISCONNECTED, DeviceDisconnectedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_ITEMCREATED, ItemCreatedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_ITEMDELETED, ItemDeletedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_TAKEPICTURE, TakePictureString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_SYNCHRONIZE, SynchronizeString, MAX_PATH);
    if (FAILED(hr)) return hr;

    //
    // Concatenate %ld on the end of each object name string so they can be used in a sprintf statement
    //
    wcscat(UnknownString, L"%ld");
    wcscat(UnknownString, L"%ld");
    wcscat(FolderString, L"%ld");
    wcscat(ScriptString, L"%ld");
    wcscat(ExecString, L"%ld");
    wcscat(TextString, L"%ld");
    wcscat(HtmlString, L"%ld");
    wcscat(DpofString, L"%ld");
    wcscat(AudioString, L"%ld");
    wcscat(VideoString, L"%ld");
    wcscat(UnknownImgString, L"%ld");
    wcscat(ImageString, L"%ld");
    wcscat(AlbumString, L"%ld");
    wcscat(BurstString, L"%ld");
    wcscat(PanoramaString, L"%ld");

    return hr;
}

//
// This function retrieves a string from the resource file and returns a Unicode string. The caller
// is responsible for allocating space for the string before calling this function.
//
// Input:
//   lResourceID -- resource id of the string
//   pString -- pointer to receive the string
//   length -- length of the string in characters
//
HRESULT
CWiaMiniDriver::GetResourceString(
    LONG lResourceID,
    WCHAR *pString,
    int length
    )
{
    HRESULT hr = S_OK;

#ifdef UNICODE
    if (::LoadString(g_hInst, lResourceID, pString, length) == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "GetResourceString", "LoadString failed");
        return hr;
    }

#else
       TCHAR szStringValue[255];
       if (::LoadString(g_hInst,lResourceID,szStringValue,255) == 0)
       {
           hr = HRESULT_FROM_WIN32(::GetLastError());
           wiauDbgErrorHr(hr, "GetResourceString", "LoadString failed");
           return hr;
       }

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           pString,
                           sizeof(length));

#endif

    return hr;
}

//
// To support vendor extension, new registry entries are defined under the
// DeviceData subkey. These entries are created from the vendor INF
// during device setup. Sample INF entries:
//
// [DeviceData]
// VendorExtID=0x12345678
// PropCode="0xD001,0xD002,0xD003"
// PropCodeD001="0x1C01,Vendor property 1"
// PropCodeD002="0x1C02,Vendor property 2"
// PropCodeD003="0x1C03,Vendor property 3"
// EventCode="0xC001,0xC002"
// EventCodeC001={191D9AE7-EE8C-443c-B3E8-A3F87E0CF3CC}
// EventCodeC002={8162F5ED-62B7-42c5-9C2B-B1625AC0DB93}
//
// The VendorExtID entry should be the PIMA assigned vendor extension code.
//
// The PropCode entry must list all of the vendor extended PropCodes.
// For each value in PropCode, an entry of the form PropCodeXXXX must be
// present, where XXXX is the hex value of the prop code (uppercase). The
// value for that entry is the WIA property ID and description (which does not
// need to be localized).
//
// The EventCode entry work similarly, where each EventCodeXXXX entry lists the event
// GUID that will be posted when the event occurs.
//

const TCHAR REGSTR_DEVICEDATA[]     = TEXT("DeviceData");
const TCHAR REGSTR_VENDORID[]       = TEXT("VendorExtID");
const TCHAR REGSTR_PROPCODE[]       = TEXT("PropCode");
const TCHAR REGSTR_EVENTCODE[]      = TEXT("EventCode");
const TCHAR REGSTR_EVENTS_MASK[]    = TEXT("Events\\%s");

//
// This function initializes vendor extentions from the provided
// registry key
//
// Input:
//  hkDevParams -- the registry key under which the vendor extentions are defined.
//
HRESULT
CWiaMiniDriver::InitVendorExtentions(HKEY hkDevParams)
{
    USES_CONVERSION;
    
    DBG_FN("CWiaMiniDriver::InitVendorExtentions");

    HRESULT hr = S_OK;

    if (!hkDevParams)
    {
        wiauDbgError("InitVendorExtentions", "invalid arg");
        return E_INVALIDARG;
    }

    CPTPRegistry regDevData;

    hr = regDevData.Open(hkDevParams, REGSTR_DEVICEDATA);
    if (FAILED(hr))
    {
        wiauDbgError("InitVendorExtentions", "Open DeviceData failed");
        return hr;
    }

    //
    // Get the vendor extension ID
    //
    hr = regDevData.GetValueDword(REGSTR_VENDORID, &m_VendorExtId);
    if (FAILED(hr))
        wiauDbgWarning("InitVendorExtentions", "couldn't read vendor extension id");

    wiauDbgTrace("InitVendorExtentions", "vendor extension id = 0x%08x", m_VendorExtId);

    //
    // Get the list of vendor extended property codes
    //
    CArray16 VendorPropCodes;
    hr = regDevData.GetValueCodes(REGSTR_PROPCODE, &VendorPropCodes);

    wiauDbgTrace("InitVendorExtentions", "%d vendor prop codes found", VendorPropCodes.GetSize());

    //
    // For each property code, get it's information, i.e. the WIA prop id and string
    //
    int count = 0;
    TCHAR name[MAX_PATH];
    TCHAR nameFormat[MAX_PATH];
    TCHAR value[MAX_PATH];
    
    DWORD valueLen = MAX_PATH;
    PROP_INFO *pPropInfo = NULL;
    WCHAR *pPropStr = NULL;
    
    #ifndef UNICODE    
    TCHAR PropStrBuf[MAX_PATH];
    #else
    #define PropStrBuf pPropStr
    #endif
    
    int num;
    if (SUCCEEDED(hr))
    {
        lstrcpy(nameFormat, REGSTR_PROPCODE);
        lstrcat(nameFormat, TEXT("%04X"));
        for (count = 0; count < VendorPropCodes.GetSize(); count++)
        {
            wsprintf(name, nameFormat, VendorPropCodes[count]);
            valueLen = MAX_PATH;
            hr = regDevData.GetValueStr(name, value, &valueLen);
            if (FAILED(hr))
            {
                wiauDbgError("InitVendorExtentions", "vendor extended PropCode not found 0x%04x", VendorPropCodes[count]);
                return hr;
            }

            pPropInfo = new PROP_INFO;
            pPropStr = new WCHAR[MAX_PATH];
            if (!pPropInfo || !pPropStr)
            {
                wiauDbgError("InitVendorExtentions", "memory allocation failed");
                return E_OUTOFMEMORY;
            }

            pPropInfo->PropName = pPropStr;
            *PropStrBuf = TEXT('\0');
            num = _stscanf(value, TEXT("%li,%s"), &pPropInfo->PropId, PropStrBuf);

            #ifndef UNICODE
            wcscpy(pPropStr, A2W(PropStrBuf));
            #endif            
            
            if (num != 2)
            {
                wiauDbgError("InitVendorExtentions", "invalid vendor property format");
                delete pPropInfo;
                delete [] pPropStr;
                
                return E_FAIL;
            }

            m_VendorPropMap.Add(VendorPropCodes[count], pPropInfo);
        }
    }
    else
        wiauDbgWarning("InitVendorExtentions", "couldn't read vendor prop codes");

    //
    // Get the list of vendor extended event codes
    //
    hr = S_OK;
    CArray16 VendorEventCodes;
    regDevData.GetValueCodes(REGSTR_EVENTCODE, &VendorEventCodes);

    wiauDbgTrace("InitVendorExtentions", "%d vendor event codes found", VendorEventCodes.GetSize());

    int nVendorEvents = VendorEventCodes.GetSize();
    if (nVendorEvents > MAX_VENDOR_EVENTS)
    {
        wiauDbgWarning("InitVendorExtensions", "vendor events limit exceeded, ignoring events over limit");
        nVendorEvents = MAX_VENDOR_EVENTS;
    }

    //
    // For each event code, get it's information, i.e. the WIA event GUID and event name
    //
    lstrcpy(nameFormat, REGSTR_EVENTCODE);
    lstrcat(nameFormat, TEXT("%04X"));
    for (count = 0; count < nVendorEvents; count++)
    {
        wsprintf(name, nameFormat, VendorEventCodes[count]);
        valueLen = MAX_PATH;
        hr = regDevData.GetValueStr(name, value, &valueLen);
        if (FAILED(hr))
        {
            wiauDbgError("InitVendorExtentions", "vendor extended EventCode not found 0x%04x", VendorEventCodes[count]);
            return hr;
        }

        CVendorEventInfo *pEventInfo = new CVendorEventInfo;
        if (!pEventInfo)
        {
            wiauDbgError("InitVendorExtentions", "memory allocation failed");
            return E_OUTOFMEMORY;
        }

        pEventInfo->pGuid = new GUID;
        if (!pEventInfo->pGuid)
        {
            wiauDbgError("InitVendorExtentions", "memory allocation failed");
            delete pEventInfo;
            pEventInfo = NULL;
            return E_OUTOFMEMORY;
        }

        hr = CLSIDFromString(T2W(value), pEventInfo->pGuid);
        if (FAILED(hr))
        {
            wiauDbgError("InitVendorExtentions", "invalid guid format");
            delete pEventInfo;
            pEventInfo = NULL;
            return hr;
        }

        //
        // Open DevParams\Events\EventCodeXXXX key and read event's name - default value of the key
        //
        TCHAR szEventKey[MAX_PATH + 1] = TEXT("");
        CPTPRegistry regEventKey;

        if (_sntprintf(szEventKey, MAX_PATH, REGSTR_EVENTS_MASK, name) > 0)
        {
            hr = regEventKey.Open(hkDevParams, szEventKey);
            if (SUCCEEDED(hr))
            {
                valueLen = MAX_PATH;
                hr = regEventKey.GetValueStr(_T(""), value, &valueLen);
                if (SUCCEEDED(hr))
                {
                    pEventInfo->EventName = SysAllocString(T2W(value));
                    if (pEventInfo->EventName == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        else
        {
            hr = E_FAIL; // way too long registry key. should not happen
        }
        
        if (FAILED(hr))
        {
            //
            // if event name is not provided, the event info will not be added to the map
            // just proceed to the next event in VendorEventCodes
            //
            wiauDbgError("InitVendorExtensions", "can't read vendor event name");
            delete pEventInfo;
            pEventInfo = NULL;
            hr = S_OK;
        }
        else
        {
            //
            // Add the EventInfo to the map. Map will be responsible for freeing EventInfo
            //
            m_VendorEventMap.Add(VendorEventCodes[count], pEventInfo);
        }
    }

    return hr;
}

//
// Event callback function
//
HRESULT
EventCallback(
    LPVOID pCallbackParam,
    PPTP_EVENT pEvent
    )
{
    HRESULT hr = S_OK;

    if (pEvent == NULL)
    {
        hr = CoInitialize(NULL);
        wiauDbgTrace("EventCallback", "CoInitialize called");
    }
    else
    {
        DBG_FN("EventCallback");

        CWiaMiniDriver *pDriver = (CWiaMiniDriver *) pCallbackParam;

        if (pDriver)
        {
            hr = pDriver->EventCallbackDispatch(pEvent);
            if (FAILED(hr))
            {
                wiauDbgError("EventCallback", "ProcessEvent failed");
                return hr;
            }
        }
    }

    return hr;
}

//
// Constructor
//
CPtpMutex::CPtpMutex(HANDLE hMutex) :
        m_hMutex(hMutex)
{
    DWORD ret = 0;
    const DWORD MUTEX_WAIT = 30 * 1000; // 30 seconds

    ret = WaitForSingleObject(hMutex, MUTEX_WAIT);
    if (ret == WAIT_TIMEOUT)
        wiauDbgError("CPtpMutex", "wait for mutex expired");
    else if (ret == WAIT_FAILED)
        wiauDbgError("CPtpMutex", "WaitForSingleObject failed");

    wiauDbgTrace("CPtpMutex", "Entering mutex");
}

//
// Destructor
//
CPtpMutex::~CPtpMutex()
{
    wiauDbgTrace("~CPtpMutex", "Leaving mutex");

    if (!ReleaseMutex(m_hMutex))
        wiauDbgError("~CPtpMutex", "ReleaseMutex failed");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\ptpprop.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    ptpprop.h

Abstract:

    This module declares CProperty and its derived classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef PTPPROP__H_
#define PTPPROP__H_

//
// This class represnets a property.
//

class CPTPProperty
{
public:
    CPTPProperty()
    {
        m_bstrWiaPropName = NULL;
        m_WiaDataType = VT_EMPTY;
        ZeroMemory(&m_WiaPropInfo, sizeof(m_WiaPropInfo));
        ZeroMemory(&m_DefaultValue, sizeof(m_DefaultValue));
        ZeroMemory(&m_CurrentValue, sizeof(m_CurrentValue));
    }
    CPTPProperty(WORD PTPPropCode, WORD PTPDataType);
    virtual ~CPTPProperty();
    virtual HRESULT Initialize(PTP_PROPDESC *pPTPPropDesc, PROPID WiaPropId,
                               VARTYPE WiaDataType, LPCWSTR WiaPropName);
    HRESULT GetCurrentValue(PROPVARIANT *pPropVar);
    HRESULT GetCurrentValue(PTP_PROPVALUE *pPropValue);
    HRESULT GetDefaultValue(PROPVARIANT *pPropVar);
    HRESULT GetDefaultValue(PTP_PROPVALUE *pPropValue);
    HRESULT SetValue(PROPVARIANT *ppropVar);
    HRESULT SetValue(PTP_PROPVALUE *pPropValue);
    HRESULT Reset();

    const WIA_PROPERTY_INFO * GetWiaPropInfo()
    {
        return &m_WiaPropInfo;
    }
    const PTP_PROPVALUE * GetCurrentValue()
    {
        return &m_CurrentValue;
    }
    const PTP_PROPVALUE * GetDefaultValue()
    {
        return &m_DefaultValue;
    }
    const LPWSTR GetWiaPropName()
    {
        return m_bstrWiaPropName;
    }
    WORD GetPTPPropCode()
    {
        return m_PtpPropCode;
    }
    PROPID GetWiaPropId()
    {
        return m_WiaPropId;
    }
    WORD  GetPTPPropDataType()
    {
        return m_PtpDataType;
    }
    VARTYPE GetWiaPropDataType()
    {
        return m_WiaDataType;
    }
    LONG GetWiaAccessFlags()
    {
        return m_WiaPropInfo.lAccessFlags;
    }

protected:
    //
    // Override the following functions to provide different data
    // restreiving and recording methods
    //
    virtual HRESULT GetPropValueLong(PTP_PROPVALUE *pPropValue, long *plValue);
    virtual HRESULT GetPropValueBSTR(PTP_PROPVALUE *pPropValue, BSTR *pbstrValue);
    virtual HRESULT GetPropValueVector(PTP_PROPVALUE *pPropValue, void *pVector,
                                       VARTYPE BasicType);
    virtual HRESULT SetPropValueLong(PTP_PROPVALUE *pPropValue, long lValue);
    virtual HRESULT SetPropValueBSTR(PTP_PROPVALUE *pPropValue, BSTR bstrValue);
    virtual HRESULT SetPropValueVector(PTP_PROPVALUE *pPropValue,
                                       void *pVector, VARTYPE BasicType);
    HRESULT PropValue2Variant(PROPVARIANT *pPropVar, PTP_PROPVALUE *pPropValue);
    HRESULT Variant2PropValue(PTP_PROPVALUE *pPropValue, PROPVARIANT *pPropVar);

    WORD    m_PtpPropCode;
    PROPID              m_WiaPropId;
    WORD        m_PtpDataType;
    VARTYPE             m_WiaDataType;
    PTP_PROPVALUE       m_CurrentValue;
    PTP_PROPVALUE       m_DefaultValue;
    WIA_PROPERTY_INFO   m_WiaPropInfo;
    BSTR                m_bstrWiaPropName;
};


class CPTPPropertyDateTime : public CPTPProperty
{
public:
    CPTPPropertyDateTime(WORD PtpPropCode,
                         WORD     PtpDataType
                        );

protected:
    virtual HRESULT GetPropValueVector(PTP_PROPVALUE *pPropValue,
                                       void *pVector,
                                       VARTYPE BasicType
                                      );
    virtual HRESULT SetPropValueVector(PTP_PROPVALUE *pPropValue,
                                       void *pVector,
                                       VARTYPE BasicType
                                      );
};
#endif	    // #ifndef PTPPROP__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\resource.h ===
//
// Used by ptpusd.rc
//

#define IDS_UNKNOWNSTRING       102
#define IDS_FOLDERSTRING        103
#define IDS_SCRIPTSTRING        104
#define IDS_EXECSTRING          105
#define IDS_TEXTSTRING          106
#define IDS_HTMLSTRING          107
#define IDS_DPOFSTRING          108
#define IDS_AUDIOSTRING         109
#define IDS_VIDEOSTRING         110
#define IDS_UNKNOWNIMGSTRING    111
#define IDS_IMAGESTRING         112
#define IDS_ALBUMSTRING         113
#define IDS_BURSTSTRING         114
#define IDS_PANORAMASTRING      115

#define IDS_DEVICECONNECTED     120
#define IDS_DEVICEDISCONNECTED  121
#define IDS_ITEMCREATED         122
#define IDS_ITEMDELETED         123

#define IDS_TAKEPICTURE         124
#define IDS_SYNCHRONIZE         125
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\sources.inc ===
#############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   DavePar
#
#Date:
#   20-Jul-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     ISO/PIMA 15740 Picture Transfer Protocol driver
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ptpusd
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

DLLDEF=..\ptpusd.def
DLLENTRY=_DllMainCRTStartup

USE_MSVCRT = 1

INCLUDES= \
        $(PROJECT_ROOT)\wia\common\jpeglib; \
        ..\..\common; \
        $(DDK_INC_PATH); \
        $(PROJECT_ROOT)\wia\drivers\inc; \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\drivers\util; 


PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj

#
# Avoid boolean conflict with the jpeg library
#
C_DEFINES=$(C_DEFINES) -DHAVE_BOOLEAN -DWIAJPEG

!if defined(CHICAGO_PRODUCT )
LIB_SUFFIX=chicago
!else
LIB_SUFFIX=winnt
!endif

WPP_SOURCES=            \
        ..\minidrv.cpp  \
        ..\devitem.cpp  \
        ..\imgitem.cpp  \
        ..\eventcb.cpp

SOURCES=$(WPP_SOURCES)  \
        ..\jpegutil.cpp \
        ..\tiffutil.cpp \
        ..\dllmain.cpp  \
        ..\factory.cpp  \
        ..\ptpusd.rc

TARGETLIBS= $(TARGETLIBS) \
          ..\..\common\$(LIB_SUFFIX)\$(OBJ_DIR)\$(TARGET_DIRECTORY)\ptpusb.lib \
          $(WIA_LIB_PATH)\jpeg.lib        \
          $(SDK_LIB_PATH)\wiaguid.lib     \
          $(DDK_LIB_PATH)\wiaservc.lib    \
          $(SDK_LIB_PATH)\uuid.lib        \
          ..\..\..\..\util\$(LIB_SUFFIX)\$(OBJ_DIR)\$(TARGET_DIRECTORY)\wiautil.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\trace.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This module declares software tracing stuff

Author:

    Dave Parsons (davepar)

Revision History:


--*/

#ifndef TRACE__H_
#define TRACE__H_

//
// Software tracing setup
//

#define WPP_CONTROL_GUIDS       \
    WPP_DEFINE_CONTROL_GUID(Regular,(09D38237,078D,4767,BF90,9227E75562DB), \
    WPP_DEFINE_BIT(Error)       \
    WPP_DEFINE_BIT(Warning)     \
    WPP_DEFINE_BIT(Trace)       \
    WPP_DEFINE_BIT(Entry)       \
    WPP_DEFINE_BIT(Exit)        \
    WPP_DEFINE_BIT(Dump)        \
    )

class CTraceProc {
private:
    CHAR m_szMessage[MAX_PATH];

public:
    CTraceProc(CHAR *pszMsg);
    ~CTraceProc();
};

VOID DoTraceHresult(HRESULT hr);

#endif // TRACE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\utils.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module declares utilitiy functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef UTILS__H_
#define UTILS__H_



WORD
ByteSwapWord(
            WORD w
            );


DWORD
ByteSwapDword(
             DWORD dw
             );

DWORD
GetDIBLineSize(
              DWORD   Width,
              DWORD   Bitsount
              );

DWORD
GetDIBSize(
          BITMAPINFO *pbmi
          );

DWORD
GetDIBBitsOffset(
                BITMAPINFO *pbmi
                );



HRESULT
VerticalFlipBmp(
               BYTE *pbmp,
               UINT bmpHeight,
               UINT bmpLineSize
               );

HRESULT
WINAPI
GetTiffDimensions(
                 BYTE   *pTiff,
                 UINT  TiffSize,
                 UINT  *pWidth,
                 UINT  *pHeight,
                 UINT  *pBitDepth
                 );

HRESULT
WINAPI
Tiff2DIBBitmap(
              BYTE *pTiff,
              UINT TiffSize,
              BYTE  *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              );

HRESULT
WINAPI
GetJpegDimensions(
                 BYTE   *pJpeg,
                 UINT  JpegSize,
                 UINT  *pWidth,
                 UINT  *pHeight,
                 UINT  *pBitDepth
                 );

HRESULT
WINAPI
Jpeg2DIBBitmap(
              BYTE *pJpeg,
              UINT JpegSize,
              BYTE  *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              );

HRESULT
WINAPI
GetImageDimensions(
                   UINT ptpFormatCode,
                   BYTE *pCompressedData,
                   UINT CompressedSize,
                   UINT *pWidth,
                   UINT *pHeight,
                   UINT *pBitDepth
                  );

HRESULT
WINAPI
ConvertAnyImageToBmp(
                     BYTE *pImage,
                     UINT CompressedSize,
                     UINT *pWidth,
                     UINT *pHeight,
                     UINT *pBitDepth,
                     BYTE **pDIBBmp,
                     UINT *pImagesize,
                     UINT *pHeaderSize
                    );

void
WINAPI
UnInitializeGDIPlus(void);   


#endif // #ifndef UTILS__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\fakecam\pch.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       pch.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Pre-compiled header for Fake Camera device
*
***************************************************************************/

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <objbase.h>
#include <tchar.h>

//#include <sti.h>
//#include <stiusd.h>

#include <wiamindr.h>
#include <wiacammc.h>
#include <wiautil.h>
#include <stdio.h>

#include "fakecam.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\minidrv\tiffutil.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    minidrv.cpp

Abstract:

    This module implements main part of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

const WORD TIFFTAG_IMAGELENGTH              = 257;
const WORD TIFFTAG_IMAGEWIDTH               = 256;
const WORD TIFFTAG_RESOLUTIONUNIT           = 296;
const WORD TIFFTAG_PHOTOMETRIC              = 262;
const WORD TIFFTAG_COMPRESSION              = 259;
const WORD TIFFTAG_XRESOLUTION              = 282;
const WORD TIFFTAG_YRESOLUTION              = 283;
const WORD TIFFTAG_ROWSPERSTRIP             = 278;
const WORD TIFFTAG_STRIPOFFSETS             = 273;
const WORD TIFFTAG_STRIPBYTECOUNTS          = 279;
const WORD TIFFTAG_COLORMAP                 = 320;
const WORD TIFFTAG_BITSPERSAMPLE            = 258;
const WORD TIFFTAG_SAMPLESPERPIXEL          = 277;
const WORD TIFFTAG_ARTIST                   = 315;
const WORD TIFFTAG_COPYRIGHT                = 33432;
const WORD TIFFTAG_DATETIME                 = 306;
const WORD TIFFTAG_MAKE                     = 271;
const WORD TIFFTAG_IMAGEDESCRIPTION         = 270;
const WORD TIFFTAG_MAXSAMPLEVALUE           = 281;
const WORD TIFFTAG_MINSAMPLEVALUE           = 280;
const WORD TIFFTAG_MODEL                    = 272;
const WORD TIFFTAG_NEWSUBFILETYPE           = 254;
const WORD TIFFTAG_ORIENTATION              = 274;
const WORD TIFFTAG_PLANARCONFIGURATION      = 284;

const char  LITTLE_ENDIAN_MARKER = 'I';
const char  BIG_ENDIAN_MARKER    = 'M';
const WORD  TIFF_SIGNATURE_I  = 0x002A;
const WORD  TIFF_SIGNATURE_M  = 0x2A00;

const WORD  TIFF_PHOTOMETRIC_WHITE          = 0;
const WORD  TIFF_PHOTOMETRIC_BLACK          = 1;
const WORD  TIFF_PHOTOMETRIC_RGB            = 2;
const WORD  TIFF_PHOTOMETRIC_PALETTE        = 3;

const WORD  TIFF_COMPRESSION_NONE           = 1;

const WORD  TIFF_TYPE_BYTE                  = 1;
const WORD  TIFF_TYPE_ASCII                 = 2;
const WORD  TIFF_TYPE_SHORT                 = 3;
const WORD  TIFF_TYPE_LONG                  = 4;
const WORD  TIFF_TYPE_RATIONAL              = 5;
const WORD  TIFF_TYPE_SBYTE                 = 6;
const WORD  TIFF_TYPE_UNDEFINED             = 7;
const WORD  TIFF_TYPE_SSHORT                = 8;
const WORD  TIFF_TYPE_SLONG                 = 9;
const WORD  TIFF_TYPE_SRATIONAL             = 10;
const WORD  TIFF_TYPE_FLOAT                 = 11;
const WORD  TIFF_TYPE_DOUBLE                = 12;

typedef struct tagTiffHeader
{
    char    ByteOrder_1;
    char    ByteOrder_2;
    WORD    Signature;
    DWORD   IFDOffset;
}TIFF_HEADER, *PTIFF_HEADER;

typedef struct tagTiffTag
{
    WORD    TagId;          // tag id
    WORD    Type;           // tag data type
    DWORD   Count;          // how many items
    DWORD   ValOffset;      // offset to the data items
}TIFF_TAG, *PTIFF_TAG;

typedef struct tagTiffImageInfo
{
    DWORD    ImageHeight;
    DWORD    ImageWidth;
    DWORD    BitsPerSample;
    DWORD    SamplesPerPixel;
    DWORD    PhotoMetric;
    DWORD    Compression;
    DWORD    RowsPerStrip;
    DWORD    NumStrips;
    DWORD    *pStripOffsets;
    DWORD    *pStripByteCounts;
}TIFF_IMAGEINFO, *PTIFF_IMAGEINFO;


WORD
ByteSwapWord(WORD w)
{
    return((w &0xFF00) >> 8 | (w & 0xFF) << 8);
}


DWORD
ByteSwapDword(DWORD dw)
{
    return((DWORD)(ByteSwapWord((WORD)((dw &0xFFFF0000) >> 16))) |
           (DWORD)(ByteSwapWord((WORD)(dw & 0xFFFF))) << 16);
}

DWORD
GetDIBLineSize(
              DWORD   Width,
              DWORD   BitsCount
              )
{
    return(Width * (BitsCount / 8) + 3) & ~3;
}

DWORD
GetDIBSize(
          BITMAPINFO *pbmi
          )
{
    return GetDIBBitsOffset(pbmi) +
    GetDIBLineSize(pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biBitCount) *
    abs(pbmi->bmiHeader.biHeight);
}

DWORD
GetDIBBitsOffset(
                BITMAPINFO *pbmi
                )
{
    DWORD Offset = (DWORD)-1;
    if (pbmi && pbmi->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
    {
        Offset = pbmi->bmiHeader.biSize;
        if (pbmi->bmiHeader.biBitCount <= 8)
        {
            if (pbmi->bmiHeader.biClrUsed)
            {
                Offset += pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD);
            }
            else
            {
                Offset += ((DWORD) 1 << pbmi->bmiHeader.biBitCount) * sizeof(RGBQUAD);
            }
        }
        if (BI_BITFIELDS == pbmi->bmiHeader.biCompression)
        {
            Offset += 3 * sizeof(DWORD);
        }
    }
    return Offset;
}


HRESULT
WINAPI
GetTiffDimensions(
                 BYTE *pTiff,
                 UINT TiffSize,
                 UINT *pWidth,
                 UINT *pHeight,
                 UINT *pBitDepth
                 )
{

    if (!pTiff || !TiffSize || !pWidth || !pHeight || !pBitDepth)
        return E_INVALIDARG;

    DWORD CurOffset;
    WORD  TagCounts;
    BOOL bByteSwap;

    TIFF_TAG *pTiffTags;

    HRESULT hr;

    DWORD BitsPerSample;
    DWORD SamplesPerPixel;

    if (BIG_ENDIAN_MARKER == *((CHAR *)pTiff) &&
        BIG_ENDIAN_MARKER == *((CHAR *)pTiff + 1))
    {
        if (TIFF_SIGNATURE_M != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = TRUE;
        CurOffset = ByteSwapDword(*((DWORD *)(pTiff + 4)));
        TagCounts = ByteSwapWord(*((WORD *)(pTiff + CurOffset)));
    }
    else
    {
        if (TIFF_SIGNATURE_I != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = FALSE;
        CurOffset = *((DWORD *)(pTiff + 4));
        TagCounts = *((WORD *)(pTiff + CurOffset));
    }
    pTiffTags = (TIFF_TAG *)(pTiff + CurOffset + sizeof(WORD));

    hr = S_OK;

    *pWidth = 0;
    *pHeight = 0;
    *pBitDepth = 0;
    //
    // Assuming it is 24bits color
    //
    BitsPerSample = 8;
    SamplesPerPixel = 3;

    while (TagCounts && S_OK == hr)
    {
        WORD TagId;
        WORD Type;
        DWORD Count;
        DWORD ValOffset;
        WORD i;
        DWORD *pdwOffset;
        WORD  *pwOffset;
        if (bByteSwap)
        {
            TagId = ByteSwapWord(pTiffTags->TagId);
            Type = ByteSwapWord(pTiffTags->Type);
            Count = ByteSwapDword(pTiffTags->Count);
            ValOffset = ByteSwapDword(pTiffTags->ValOffset);
        }
        else
        {
            TagId = pTiffTags->TagId;
            Type = pTiffTags->Type;
            Count = pTiffTags->Count;
            ValOffset = pTiffTags->ValOffset;
        }
        switch (TagId)
        {
        case TIFFTAG_IMAGELENGTH:
            if (TIFF_TYPE_SHORT == Type)
                *pHeight =  (WORD)ValOffset;
            else
                *pHeight = ValOffset;
            break;
        case TIFFTAG_IMAGEWIDTH:
            if (TIFF_TYPE_SHORT == Type)
                *pWidth = (WORD)ValOffset;
            else
                *pWidth = ValOffset;
            break;
        case TIFFTAG_PHOTOMETRIC:
            if (TIFF_PHOTOMETRIC_RGB != (WORD)ValOffset)
            {
                //
                // bi-level or grayscale or palette.
                //
                SamplesPerPixel = 1;
            }
            else
            {
                SamplesPerPixel = 3;
            }
            break;
        case TIFFTAG_BITSPERSAMPLE:
            BitsPerSample = (WORD)ValOffset;
            break;
        case TIFFTAG_SAMPLESPERPIXEL:
            SamplesPerPixel = (WORD)ValOffset;
            break;
        default:
            break;
        }
        pTiffTags++;
        TagCounts--;
    }
    *pBitDepth = SamplesPerPixel * BitsPerSample;
    return S_OK;
}


//
// This function converts a TIFF file in memory to DIB bitmap
// Input:
//	pTiff	-- Tiff file in memory. TIFF, TIFF/EP, TIFF/IT are supported
//	TiffSize -- the TIFF file size
//	DIBBmpSize -- DIB bitmap buffer size
//	pDIBBmp    -- DIB bitmap buffer
//	LineSize   -- destination scanline size in bytes
//	MaxLines   -- maximum scanline can be delivered per callback
//		      0 if we decide it.
//	pProgressCB -- optional callback
//	pCBContext  -- context for the callback.
//			If no callback is provided, the given dib
//			bitmap buffer must be big enough to
//			receive the entire bitmap.
// Output:
//	HRESULT     -- S_FALSE if the client aborted the transfer
//
HRESULT
WINAPI
Tiff2DIBBitmap(
              BYTE *pTiff,
              UINT TiffSize,
              BYTE  *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              )
{
    if (!pTiff || !TiffSize || !pDIBBmp || !DIBBmpSize || !LineSize)
        return E_INVALIDARG;

    HRESULT hr;
    DWORD CurOffset;
    WORD  TagCounts;
    BOOL bByteSwap;

    TIFF_TAG *pTiffTags;

    TIFF_IMAGEINFO TiffImageInfo;

    ZeroMemory(&TiffImageInfo, sizeof(TiffImageInfo));
    //
    // Set some default values
    //
    TiffImageInfo.PhotoMetric = TIFF_PHOTOMETRIC_RGB;
    TiffImageInfo.SamplesPerPixel = 3;
    TiffImageInfo.BitsPerSample = 8;
    TiffImageInfo.Compression = TIFF_COMPRESSION_NONE;

    if (BIG_ENDIAN_MARKER == *((CHAR *)pTiff) &&
        BIG_ENDIAN_MARKER == *((CHAR *)pTiff + 1))
    {
        if (TIFF_SIGNATURE_M != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = TRUE;
        CurOffset = ByteSwapDword(*((DWORD *)(pTiff + 4)));
        TagCounts = ByteSwapWord(*((WORD *)(pTiff + CurOffset)));
    }
    else
    {
        if (TIFF_SIGNATURE_I != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = FALSE;
        CurOffset = *((DWORD *)(pTiff + 4));
        TagCounts = *((WORD *)(pTiff + CurOffset));
    }
    pTiffTags = (TIFF_TAG *)(pTiff + CurOffset + sizeof(WORD));

    hr = S_OK;

    while (TagCounts && SUCCEEDED(hr))
    {
        WORD TagId;
        WORD Type;
        DWORD Count;
        DWORD ValOffset;
        WORD i;
        DWORD *pdwOffset;
        WORD  *pwOffset;
        if (bByteSwap)
        {
            TagId = ByteSwapWord(pTiffTags->TagId);
            Type = ByteSwapWord(pTiffTags->Type);
            Count = ByteSwapDword(pTiffTags->Count);
            ValOffset = ByteSwapDword(pTiffTags->ValOffset);
        }
        else
        {
            TagId = pTiffTags->TagId;
            Type = pTiffTags->Type;
            Count = pTiffTags->Count;
            ValOffset = pTiffTags->ValOffset;
        }
        switch (TagId)
        {
        case TIFFTAG_IMAGELENGTH:
            if (TIFF_TYPE_SHORT == Type)
                TiffImageInfo.ImageHeight = (WORD)ValOffset;
            else
                TiffImageInfo.ImageHeight = ValOffset;
            break;
        case TIFFTAG_IMAGEWIDTH:
            if (TIFF_TYPE_SHORT == Type)
                TiffImageInfo.ImageWidth = (WORD)ValOffset;
            else
                TiffImageInfo.ImageWidth = ValOffset;
            break;
        case TIFFTAG_PHOTOMETRIC:
            TiffImageInfo.PhotoMetric = (WORD)ValOffset;
            if (TIFF_PHOTOMETRIC_RGB != (WORD)ValOffset)
            {
                //
                // bi-level or grayscale or palette.
                //
                TiffImageInfo.SamplesPerPixel = 1;
            }
            else
            {
                TiffImageInfo.SamplesPerPixel = 3;
            }
            break;
        case TIFFTAG_COMPRESSION:
            TiffImageInfo.Compression = ValOffset;
            break;
        case TIFFTAG_ROWSPERSTRIP:
            if (TIFF_TYPE_SHORT == Type)
                TiffImageInfo.RowsPerStrip = (WORD)ValOffset;
            else
                TiffImageInfo.RowsPerStrip = ValOffset;
            break;
        case TIFFTAG_STRIPOFFSETS:
            TiffImageInfo.pStripOffsets = new DWORD[Count];
            TiffImageInfo.NumStrips = Count;
            if (!TiffImageInfo.pStripOffsets)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            for (i = 0; i < Count ; i++)
            {
                if (TIFF_TYPE_SHORT == Type)
                {
                    pwOffset = (WORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripOffsets[i] = ByteSwapWord(*pwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripOffsets[i] = *pwOffset;
                    }
                }
                else if (TIFF_TYPE_LONG == Type)
                {
                    pdwOffset = (DWORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripOffsets[i] = ByteSwapDword(*pdwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripOffsets[i] = *pdwOffset;
                    }
                }
            }
            break;
        case TIFFTAG_STRIPBYTECOUNTS:
            TiffImageInfo.pStripByteCounts = new DWORD[Count];
            TiffImageInfo.NumStrips = Count;
            if (!TiffImageInfo.pStripByteCounts)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            for (i = 0; i < Count ; i++)
            {
                if (TIFF_TYPE_SHORT == Type)
                {
                    pwOffset = (WORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripByteCounts[i] = ByteSwapWord(*pwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripByteCounts[i] = *pwOffset;
                    }
                }
                else if (TIFF_TYPE_LONG == Type)
                {
                    pdwOffset = (DWORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripByteCounts[i] = ByteSwapDword(*pdwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripByteCounts[i] = *pdwOffset;
                    }
                }
            }
            break;
        case TIFFTAG_BITSPERSAMPLE:
            TiffImageInfo.BitsPerSample = (WORD)ValOffset;
            break;
        case TIFFTAG_SAMPLESPERPIXEL:
            TiffImageInfo.SamplesPerPixel = (WORD)ValOffset;
            break;
        case TIFFTAG_XRESOLUTION:
        case TIFFTAG_YRESOLUTION:
        case TIFFTAG_RESOLUTIONUNIT:
            // do this later
            break;
        default:
            break;
        }
        pTiffTags++;
        TagCounts--;
    }
    if (!SUCCEEDED(hr))
    {
        //
        // If something wrong happen along the way, free
        // any memory we have allocated.
        //
        if (TiffImageInfo.pStripOffsets)
            delete [] TiffImageInfo.pStripOffsets;
        if (TiffImageInfo.pStripByteCounts)
            delete [] TiffImageInfo.pStripByteCounts;
        return hr;
    }

    //
    // Support RGB full color for now.
    // Also, we do not support any compression.
    //
    if (TIFF_PHOTOMETRIC_RGB != TiffImageInfo.PhotoMetric ||
        TIFF_COMPRESSION_NONE != TiffImageInfo.Compression ||
        DIBBmpSize < LineSize * TiffImageInfo.ImageHeight)
    {
        delete [] TiffImageInfo.pStripOffsets;
        delete [] TiffImageInfo.pStripByteCounts;
        return E_INVALIDARG;
    }

    if (1 == TiffImageInfo.NumStrips)
    {
        //
        // With single strip, the writer may write a
        // 2**31 -1(infinity) which would confuses our
        // code below. Here, we set it to the right value
        //
        TiffImageInfo.RowsPerStrip = TiffImageInfo.ImageHeight;
    }
    //
    // DIB scanlines are DWORD aligned while TIFF scanlines
    // are BYTE aligned(when the compression value is 1 which
    // is the case we enforce). Because of this, we copy the bitmap
    // scanline by scanline
    //

    DWORD NumStrips;
    DWORD *pStripOffsets;
    DWORD *pStripByteCounts;
    DWORD TiffLineSize;
    //
    // Tiff scanlines with compression 1 are byte aligned.
    //
    TiffLineSize = TiffImageInfo.ImageWidth * TiffImageInfo. BitsPerSample *
                   TiffImageInfo.SamplesPerPixel / 8;
    //
    // For convenience
    //
    pStripOffsets = TiffImageInfo.pStripOffsets;
    pStripByteCounts = TiffImageInfo.pStripByteCounts;
    NumStrips = TiffImageInfo.NumStrips;
    for (hr = S_OK, NumStrips = TiffImageInfo.NumStrips; NumStrips; NumStrips--)
    {
        DWORD Lines;
        BYTE  *pTiffBits;

        //
        // how many lines to copy in this strip. Ignore any remaining bytes
        //
        Lines = *pStripByteCounts / TiffLineSize;
        //
        // The bits
        //
        pTiffBits = pTiff + *pStripOffsets;
        for (hr = S_OK; Lines, S_OK == hr; Lines--)
        {
            if (DIBBmpSize >= LineSize)
            {
                memcpy(pDIBBmp, pTiffBits, TiffLineSize);
                pDIBBmp -= LineSize;
                DIBBmpSize -= LineSize;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            pTiffBits += TiffLineSize;
        }
        pStripOffsets++;
        pStripByteCounts++;
    }
    delete [] TiffImageInfo.pStripOffsets;
    delete [] TiffImageInfo.pStripByteCounts;
    return hr;
}

////////////////////////////// GDI+ dynamic linking, image geometry
////////////////////////////// retrieval & decompression 

#include <gdiplus.h>
#include <gdiplusflat.h>
#include <private.h>

HINSTANCE g_hGdiPlus = NULL;
ULONG_PTR g_GdiPlusToken = 0;
GUID g_guidCodecBmp;
Gdiplus::GdiplusStartupInput g_GdiPlusStartupInput;

Gdiplus::GpStatus (WINAPI *pGdipLoadImageFromStream)(IStream *pStream,  Gdiplus::GpImage **pImage) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipSaveImageToStream)(Gdiplus::GpImage *image, IStream* stream, 
    CLSID* clsidEncoder, Gdiplus::EncoderParameters* encoderParams) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipSaveImageToFile)(Gdiplus::GpImage *image, WCHAR * stream, 
    CLSID* clsidEncoder, Gdiplus::EncoderParameters* encoderParams) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageWidth)(Gdiplus::GpImage *pImage, UINT *pWidth) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageHeight)(Gdiplus::GpImage *pImage, UINT *pWidth) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImagePixelFormat)(Gdiplus::GpImage *pImage, Gdiplus::PixelFormat *pFormat) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipDisposeImage)(Gdiplus::GpImage *pImage) = NULL;
Gdiplus::GpStatus (WINAPI *pGdiplusStartup)(ULONG_PTR *token,
                                             const Gdiplus::GdiplusStartupInput *input,
                                             Gdiplus::GdiplusStartupOutput *output) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageEncodersSize)(UINT *numEncoders, UINT *size) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageEncoders)(UINT numEncoders, UINT size, Gdiplus::ImageCodecInfo *encoders) = NULL;
VOID (WINAPI *pGdiplusShutdown)(ULONG_PTR token) = NULL;

HRESULT InitializeGDIPlus(void)
{
    HRESULT hr = E_FAIL;
    Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;


    g_hGdiPlus = LoadLibraryA("gdiplus.dll");
    if(!g_hGdiPlus) {
        wiauDbgError("InitializeGDIPlus", "Failed to load gdiplus.dll");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *((FARPROC*)&pGdipLoadImageFromStream) = GetProcAddress(g_hGdiPlus, "GdipLoadImageFromStream");
    *((FARPROC*)&pGdipSaveImageToStream) = GetProcAddress(g_hGdiPlus, "GdipSaveImageToStream");
    *((FARPROC*)&pGdipSaveImageToFile) = GetProcAddress(g_hGdiPlus, "GdipSaveImageToFile");
    *((FARPROC*)&pGdipGetImageWidth) = GetProcAddress(g_hGdiPlus, "GdipGetImageWidth");
    *((FARPROC*)&pGdipGetImageHeight) = GetProcAddress(g_hGdiPlus, "GdipGetImageHeight");
    *((FARPROC*)&pGdipGetImagePixelFormat) = GetProcAddress(g_hGdiPlus, "GdipGetImagePixelFormat");
    *((FARPROC*)&pGdipDisposeImage) = GetProcAddress(g_hGdiPlus, "GdipDisposeImage");
    *((FARPROC*)&pGdiplusStartup) = GetProcAddress(g_hGdiPlus, "GdiplusStartup");
    *((FARPROC*)&pGdipGetImageEncodersSize) = GetProcAddress(g_hGdiPlus, "GdipGetImageEncodersSize");
    *((FARPROC*)&pGdipGetImageEncoders) = GetProcAddress(g_hGdiPlus, "GdipGetImageEncoders");
    *((FARPROC*)&pGdiplusShutdown) = GetProcAddress(g_hGdiPlus, "GdiplusShutdown");


    if(!pGdipLoadImageFromStream ||
       !pGdipSaveImageToStream ||
       !pGdipGetImageWidth ||
       !pGdipGetImageHeight ||
       !pGdipGetImagePixelFormat ||
       !pGdipDisposeImage ||
       !pGdiplusStartup ||
       !pGdipGetImageEncodersSize ||
       !pGdipGetImageEncoders ||
       !pGdiplusShutdown)
    {
        wiauDbgError("InitializeGDIPlus", "Failed to retrieve all the entry points from GDIPLUS.DLL");
        hr = E_FAIL;
        goto Cleanup;
    }

    
    if(Gdiplus::Ok != pGdiplusStartup(&g_GdiPlusToken, &g_GdiPlusStartupInput, NULL)) {
        wiauDbgError("InitializeGDIPlus", "GdiPlusStartup() failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    UINT  num = 0;          // number of image encoders
    UINT  size = 0;         // size of the image encoder array in bytes

    pGdipGetImageEncodersSize(&num, &size);
    if(size == 0)
    {
        wiauDbgError("InitializeGDIPlus", "GetImageEncodersSize() failed");
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
    if(pImageCodecInfo == NULL) {
        wiauDbgError("InitializeGDIPlus", "failed to allocate encoders data");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(Gdiplus::Ok != pGdipGetImageEncoders(num, size, pImageCodecInfo))
    {
        wiauDbgError("InitializeGDIPlus", "failed to retrieve encoders data");
        hr = E_FAIL;
        goto Cleanup;
    }

    for(UINT j = 0; j < num; ++j)
    {
        if( pImageCodecInfo[j].FormatID == WiaImgFmt_BMP)
        {
            g_guidCodecBmp = pImageCodecInfo[j].Clsid;
            hr = S_OK;
            break;
        }    
    } // for

    
Cleanup:
    if(pImageCodecInfo) free(pImageCodecInfo);
    return hr;
}

void UnInitializeGDIPlus(void)
{
    if(!pGdipLoadImageFromStream) 
        return;
    if(pGdiplusShutdown)
        pGdiplusShutdown(g_GdiPlusToken);
    
    FreeLibrary(g_hGdiPlus);
    pGdipLoadImageFromStream = 0;
}

HRESULT LoadImageFromMemory(BYTE *pData, UINT CompressedDataSize, Gdiplus::GpImage **ppImage)
{
    HRESULT hr = S_OK;
    
    if(pData == NULL || CompressedDataSize == 0 || ppImage == NULL) {
        return E_INVALIDARG;
    }

    if(!pGdipLoadImageFromStream) {
        hr = InitializeGDIPlus();
        if(FAILED(hr)) {
            wiauDbgError("LoadImageFromMemory", "Failed to initialize GDI+");
            return hr;
        }
    }

    CImageStream *pStream = new CImageStream();
    if(!pStream) {
        wiauDbgError("LoadImageFromMemory", "Failed to create Image Stream");
        return E_OUTOFMEMORY;
    }

    hr = pStream->SetBuffer(pData, CompressedDataSize);
    if(FAILED(hr)) {
        wiauDbgError("LoadImageFromMemory", "Failed to create Image Stream");
        goto Cleanup;
    }

    if(Gdiplus::Ok == pGdipLoadImageFromStream(pStream, ppImage)) {
        hr = S_OK;
    } else {
        wiauDbgError("LoadImageFromMemory", "GDI+ failed to load image");
        hr = E_FAIL;
    }

    
Cleanup:
    if(pStream)
        pStream->Release();
    return hr;
}

HRESULT DisposeImage(Gdiplus::GpImage **ppImage)
{
    if(ppImage == NULL || *ppImage == NULL) {
        return E_INVALIDARG;
    }

    if(pGdipDisposeImage) {
        pGdipDisposeImage(*ppImage);
    }
    
    *ppImage = NULL;

    return S_OK;
}

HRESULT SaveImageToBitmap(Gdiplus::GpImage *pImage, BYTE *pBuffer, UINT BufferSize)
{
    HRESULT hr = S_OK;

    CImageStream *pOutStream = new CImageStream;

    if(!pOutStream) {
        wiauDbgError("SaveImageToBitmap", "failed to allocate CImageStream");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pOutStream->SetBuffer(pBuffer, BufferSize, SKIP_OFF);
    if(FAILED(hr)) {
        wiauDbgError("SaveImageToBitmap", "failed to set output buffer");
        goto Cleanup;
    }
    
    if(Gdiplus::Ok != pGdipSaveImageToStream(pImage, pOutStream, &g_guidCodecBmp, NULL)) {
        wiauDbgError("SaveImageToBitmap", "GDI+ save failed");
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    if(pOutStream) {
        pOutStream->Release();
    }

    return hr;
}

HRESULT
WINAPI
GetImageDimensions(
                   UINT ptpFormatCode,
                   BYTE *pCompressedData,
                   UINT CompressedDataSize,
                   UINT *pWidth,
                   UINT *pHeight,
                   UINT *pBitDepth
                  )
{
    HRESULT hr = S_OK;
    
    if(pWidth) *pWidth = 0;
    if(pHeight) *pHeight = 0;
    if(pBitDepth) *pBitDepth = 0;

    // locate GUID for this particular format
    FORMAT_INFO *pFormatInfo = FormatCodeToFormatInfo((WORD) ptpFormatCode);
    if(pFormatInfo == NULL ||
       pFormatInfo->FormatGuid == NULL ||
       IsEqualGUID(WiaImgFmt_UNDEFINED, *pFormatInfo->FormatGuid))
    {
        wiauDbgError("GetImageDimensions", "unrecoginzed PTP format code");
        return E_INVALIDARG;
    }

    Gdiplus::GpImage *pImage = NULL;

    hr = LoadImageFromMemory(pCompressedData, CompressedDataSize, &pImage);
    if(FAILED(hr) || !pImage) {
        wiauDbgError("GetImageDimensions", "failed to create GDI+ image from supplied data.");
        return hr;
    }

    if(pWidth) pGdipGetImageWidth(pImage, pWidth);
    if(pHeight) pGdipGetImageHeight(pImage, pHeight);
    if(pBitDepth) {
        Gdiplus::PixelFormat pf = 0;

        pGdipGetImagePixelFormat(pImage, &pf);
        *pBitDepth = Gdiplus::GetPixelFormatSize(pf);
    }

    DisposeImage(&pImage);
    
    return hr;
}


HRESULT WINAPI
ConvertAnyImageToBmp(BYTE *pCompressedImage,
                     UINT CompressedSize,
                     UINT *pWidth,
                     UINT *pHeight,
                     UINT *pBitDepth,
                     BYTE **pDIBBmp,
                     UINT *pImageSize,
                     UINT *pHeaderSize
                    )

{
    HRESULT hr = S_OK;
    Gdiplus::GpImage *pImage = NULL;
    Gdiplus::PixelFormat pf = 0;
    UINT headersize;
    UNALIGNED BITMAPINFOHEADER *pbi;
    UNALIGNED BITMAPFILEHEADER *pbf;
    

    if(!pCompressedImage || !CompressedSize || !pWidth || !pHeight || !pBitDepth || !pDIBBmp || !pImageSize || !pHeaderSize)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = LoadImageFromMemory(pCompressedImage, CompressedSize, &pImage);
    if(FAILED(hr) || !pImage) {
        wiauDbgError("ConvertAnyImageToBmp", "failed to create GDI+ image from supplied data.");
        goto Cleanup;
    }

    pGdipGetImageWidth(pImage, pWidth);
    pGdipGetImageHeight(pImage, pHeight);
    pGdipGetImagePixelFormat(pImage, &pf);
    *pBitDepth = Gdiplus::GetPixelFormatSize(pf);

    *pImageSize = ((*pWidth) * (*pBitDepth) / 8L) * *pHeight;
    headersize = 8192; // big enough to hold any bitmap header

    *pDIBBmp = new BYTE[*pImageSize + headersize];
    if(!*pDIBBmp) {
        wiauDbgError("ConvertAnyImageToBmp", "failed to convert GDI+ image to bitmap.");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SaveImageToBitmap(pImage, *pDIBBmp, *pImageSize + headersize);
    if(FAILED(hr)) {
        wiauDbgError("ConvertAnyImageToBmp", "failed to convert GDI+ image to bitmap.");
        goto Cleanup;
    }

    // find out real header size
    pbf = (BITMAPFILEHEADER *)*pDIBBmp;    
    pbi = (BITMAPINFOHEADER *)(*pDIBBmp + sizeof(BITMAPFILEHEADER));

    if(*pBitDepth == 8 && pbi->biClrUsed == 2) {
        // expand color table for bilevel images
        // (TWAIN apps don't understand 2 entry colortable (0,0,0)(1,1,1)
        UNALIGNED RGBQUAD *pRgb = (RGBQUAD *)((BYTE *)pbi + pbi->biSize);
        BYTE *src = (BYTE *)(pRgb + 2);
        BYTE *dst = (BYTE *)(pRgb + 256);
        
        int i;
        
        // negate and move image
        for(i = *pImageSize - 1; i >= 0; i--) {
            dst[i] = src[i] ? 255 : 0;
        }

        pbi->biClrUsed = 256;
        pbi->biClrImportant = 256;

        pRgb[0].rgbBlue = pRgb[0].rgbRed = pRgb[0].rgbGreen = 0;
        pRgb[0].rgbReserved = 0;
        for(i = 1; i < 256; i++) {
            pRgb[i].rgbReserved = 0;
            pRgb[i].rgbBlue = pRgb[i].rgbRed = pRgb[i].rgbGreen = 255;
        }

        
        pbf->bfOffBits = sizeof(BITMAPFILEHEADER) + pbi->biSize + sizeof(RGBQUAD) * 256;
        pbf->bfSize = pbf->bfOffBits + *pImageSize;
    }
    
    *pHeaderSize = pbf->bfOffBits;

Cleanup:
    if(FAILED(hr)) {
        delete [] *pDIBBmp;
        *pDIBBmp = NULL;
    }
    
    DisposeImage(&pImage);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\fakecam\fakecam.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       fakecam.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Camera device implementation
*
*   TODO: Every function in this file must be changed so that it actually
*         talks to a real camera.
*
***************************************************************************/

#include "pch.h"

//
// Globals
//
HINSTANCE g_hInst;
GUID      g_guidUnknownFormat;

//
// Initializes access to the camera and allocates the device info
// structure and private storage area
//
HRESULT WiaMCamInit(MCAM_DEVICE_INFO **ppDeviceInfo)
{
    wiauDbgInit(g_hInst);

    DBG_FN("WiaMCamInit");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    MCAM_DEVICE_INFO *pDeviceInfo = NULL;
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;

    REQUIRE_ARGS(!ppDeviceInfo, hr, "WiaMCamInit");
    *ppDeviceInfo = NULL;

    //
    // Allocate the MCAM_DEVICE_INFO structure
    //
    pDeviceInfo = new MCAM_DEVICE_INFO;
    REQUIRE_ALLOC(pDeviceInfo, hr, "WiaMCamInit");

    memset(pDeviceInfo, 0, sizeof(MCAM_DEVICE_INFO));
    pDeviceInfo->iSize = sizeof(MCAM_DEVICE_INFO);
    pDeviceInfo->iMcamVersion = MCAM_VERSION;
    
    //
    // Allocate the FAKECAM_DEVICE_INFO structure that the
    // microdriver uses to store info
    //
    pPrivateDeviceInfo = new FAKECAM_DEVICE_INFO;
    REQUIRE_ALLOC(pPrivateDeviceInfo, hr, "WiaMCamInit");

    memset(pPrivateDeviceInfo, 0, sizeof(FAKECAM_DEVICE_INFO));
    pDeviceInfo->pPrivateStorage = (BYTE *) pPrivateDeviceInfo;

Cleanup:
    if (FAILED(hr)) {
        if (pDeviceInfo) {
            delete pDeviceInfo;
            pDeviceInfo = NULL;
        }
        if (pPrivateDeviceInfo) {
            delete pPrivateDeviceInfo;
            pPrivateDeviceInfo = NULL;
        }
    }

    *ppDeviceInfo = pDeviceInfo;

    return hr;
}

//
// Frees any remaining structures held by the microdriver
//
HRESULT WiaMCamUnInit(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamUnInit");

    HRESULT hr = S_OK;

    if (pDeviceInfo)
    {
        //
        // Free anything that was dynamically allocated in the MCAM_DEVICE_INFO
        // structure
        //
        if (pDeviceInfo->pPrivateStorage) {
            delete pDeviceInfo->pPrivateStorage;
            pDeviceInfo->pPrivateStorage = NULL;
        }

        delete pDeviceInfo;
        pDeviceInfo = NULL;
    }

    return hr;
}

//
// Open a connection to the device
//
HRESULT WiaMCamOpen(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName)
{
    DBG_FN("WiaMCamOpen");

    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    TCHAR tszTempStr[MAX_PATH] = TEXT("");

    REQUIRE_ARGS(!pDeviceInfo || !pwszPortName, hr, "WiaMCamOpen");

    //
    // Convert the wide port string to a tstr
    //
    hr = wiauStrW2T(pwszPortName, tszTempStr, sizeof(tszTempStr));
    REQUIRE_SUCCESS(hr, "WiaMCamOpen", "wiauStrW2T failed");

    //
    // Open the camera
    //
    hr = FakeCamOpen(tszTempStr, pDeviceInfo);
    REQUIRE_SUCCESS(hr, "WiaMCamOpen", "FakeCamOpen failed");
    
Cleanup:
    return hr;
}

//
// Closes the connection with the camera
//
HRESULT WiaMCamClose(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamClose");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo, hr, "WiaMCamClose");

    //
    // For a real camera, CloseHandle should be called here
    //

Cleanup:
    return hr;
}

//
// Returns information about the camera, the list of items on the camera,
// and starts monitoring events from the camera
//
HRESULT WiaMCamGetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList)
{
    DBG_FN("WiaMCamGetDeviceInfo");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;
    PTSTR ptszRootPath = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !ppItemList || !pDeviceInfo->pPrivateStorage, hr, "WiaMCamGetDeviceInfo");
    *ppItemList = NULL;

    pPrivateDeviceInfo = (UNALIGNED FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;
    ptszRootPath = pPrivateDeviceInfo->tszRootPath;

    //
    // Build a list of all items available. The fields in the item info
    // structure can either be filled in here, or for better performance
    // wait until GetItemInfo is called.
    //
    hr = SearchDir(pPrivateDeviceInfo, NULL, ptszRootPath);
    REQUIRE_SUCCESS(hr, "WiaMCamGetDeviceInfo", "SearchDir failed");

    //
    // Fill in the MCAM_DEVICE_INFO structure
    //
    //
    // Firmware version should be retrieved from the device, converting
    // to WSTR if necessary
    //
    pDeviceInfo->pwszFirmwareVer = L"04.18.65";

    // ISSUE-8/4/2000-davepar Put properties into an INI file

    pDeviceInfo->lPicturesTaken = pPrivateDeviceInfo->iNumImages;
    pDeviceInfo->lPicturesRemaining = 100 - pDeviceInfo->lPicturesTaken;
    pDeviceInfo->lTotalItems = pPrivateDeviceInfo->iNumItems;

    GetLocalTime(&pDeviceInfo->Time);

//    pDeviceInfo->lExposureMode = EXPOSUREMODE_MANUAL;
//    pDeviceInfo->lExposureComp = 0;

    *ppItemList = pPrivateDeviceInfo->pFirstItem;

Cleanup:
    return hr;
}

//
// Called to retrieve an event from the device
//
HRESULT WiaMCamReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList)
{
    DBG_FN("WiaMCamReadEvent");
    
    HRESULT hr = S_OK;

    return hr;
}

//
// Called when events are no longer needed
//
HRESULT WiaMCamStopEvents(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamStopEvents");
    
    HRESULT hr = S_OK;

    return hr;
}

//
// Fill in the item info structure
//
HRESULT WiaMCamGetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    DBG_FN("WiaMCamGetItemInfo");

    HRESULT hr = S_OK;

    //
    // This is where the driver should fill in all the fields in the
    // ITEM_INFO structure. For this fake driver, the fields are filled
    // in by WiaMCamGetDeviceInfo because it's easier.
    //

    return hr;
}

//
// Frees the item info structure
//
HRESULT WiaMCamFreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    DBG_FN("WiaMCamFreeItemInfo");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItemInfo || !pDeviceInfo->pPrivateStorage, hr, "WiaMCamFreeItemInfo");

    if (pItemInfo->pPrivateStorage) {
        PTSTR ptszFullName = (PTSTR) pItemInfo->pPrivateStorage;

        wiauDbgTrace("WiaMCamFreeItemInfo", "Removing %" WIAU_DEBUG_TSTR, ptszFullName);

        delete []ptszFullName;
        ptszFullName = NULL;
        pItemInfo->pPrivateStorage = NULL;
    }

    if (pItemInfo->pwszName)
    {
        delete []pItemInfo->pwszName;
        pItemInfo->pwszName = NULL;
    }

    pPrivateDeviceInfo = (UNALIGNED FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;

    hr = RemoveItem(pPrivateDeviceInfo, pItemInfo);
    REQUIRE_SUCCESS(hr, "WiaMCamFreeItemInfo", "RemoveItem failed");

    if (IsImageType(pItemInfo->pguidFormat)) {
        pPrivateDeviceInfo->iNumImages--;
    }

    pPrivateDeviceInfo->iNumItems--;

    delete pItemInfo;
    pItemInfo = NULL;

Cleanup:
    return hr;
}

//
// Retrieves the thumbnail for an item
//
HRESULT WiaMCamGetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem,
                            int *pThumbSize, BYTE **ppThumb)
{
    DBG_FN("WiaMCamGetThumbnail");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTSTR ptszFullName = NULL;
    BYTE *pBuffer = NULL;
    LONG ThumbOffset = 0;

    REQUIRE_ARGS(!pDeviceInfo || !pItem || !pThumbSize || !ppThumb, hr, "WiaMCamGetThumbnail");
    *ppThumb = NULL;
    *pThumbSize = 0;

    ptszFullName = (PTSTR) pItem->pPrivateStorage;

    hr = ReadJpegHdr(ptszFullName, &pBuffer);
    REQUIRE_SUCCESS(hr, "WiaMCamGetThumbnail", "ReadJpegHdr failed");

    IFD ImageIfd, ThumbIfd;
    BOOL bSwap;
    hr = ReadExifJpeg(pBuffer, &ImageIfd, &ThumbIfd, &bSwap);
    REQUIRE_SUCCESS(hr, "WiaMCamGetThumbnail", "ReadExifJpeg failed");

    for (int count = 0; count < ThumbIfd.Count; count++)
    {
        if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_DATA) {
            ThumbOffset = ThumbIfd.pEntries[count].Offset;
        }
        else if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_LEN) {
            *pThumbSize = ThumbIfd.pEntries[count].Offset;
        }
    }

    if (!ThumbOffset || !*pThumbSize)
    {
        wiauDbgError("WiaMCamGetThumbnail", "Thumbnail not found");
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppThumb = new BYTE[*pThumbSize];
    REQUIRE_ALLOC(*ppThumb, hr, "WiaMCamGetThumbnail");

    memcpy(*ppThumb, pBuffer + APP1_OFFSET + ThumbOffset, *pThumbSize);

Cleanup:
    if (pBuffer) {
        delete []pBuffer;
    }

    FreeIfd(&ImageIfd);
    FreeIfd(&ThumbIfd);

    return hr;
}

//
// Retrieves the data for an item
//
HRESULT WiaMCamGetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem,
                           UINT uiState, BYTE *pBuf, DWORD dwLength)
{
    DBG_FN("WiaMCamGetItemData");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    PTSTR ptszFullName = NULL;
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItem || !pDeviceInfo->pPrivateStorage, hr, "WiaMCamGetItemData");

    pPrivateDeviceInfo = (UNALIGNED  FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;

    if (uiState & MCAM_STATE_FIRST)
    {
        if (pPrivateDeviceInfo->hFile != NULL)
        {
            wiauDbgError("WiaMCamGetItemData", "File handle is already open");
            hr = E_FAIL;
            goto Cleanup;
        }

        ptszFullName = (PTSTR) pItem->pPrivateStorage;

        wiauDbgTrace("WiaMCamGetItemData", "Opening %" WIAU_DEBUG_TSTR " for reading", ptszFullName);

        pPrivateDeviceInfo->hFile = CreateFile(ptszFullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
        REQUIRE_FILEHANDLE(pPrivateDeviceInfo->hFile, hr, "WiaMCamGetItemData", "CreateFile failed");
    }

    if (!(uiState & MCAM_STATE_CANCEL))
    {
        DWORD dwReceived = 0;

        if (!pPrivateDeviceInfo->hFile) {
            wiauDbgError("WiaMCamGetItemData", "File handle is NULL");
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pBuf) {
            wiauDbgError("WiaMCamGetItemData", "Data buffer is NULL");
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        ret = ReadFile(pPrivateDeviceInfo->hFile, pBuf, dwLength, &dwReceived, NULL);
        REQUIRE_FILEIO(ret, hr, "WiaMCamGetItemData", "ReadFile failed");

        if (dwLength != dwReceived)
        {
            wiauDbgError("WiaMCamGetItemData", "Incorrect amount read %d", dwReceived);
            hr = E_FAIL;
            goto Cleanup;
        }

        Sleep(100);
    }

    if (uiState & (MCAM_STATE_LAST | MCAM_STATE_CANCEL))
    {
        if (!pPrivateDeviceInfo->hFile) {
            wiauDbgError("WiaMCamGetItemData", "File handle is NULL");
            hr = E_FAIL;
            goto Cleanup;
        }

        CloseHandle(pPrivateDeviceInfo->hFile);
        pPrivateDeviceInfo->hFile = NULL;
    }

Cleanup:
    return hr;
}

//
// Deletes an item
//
HRESULT WiaMCamDeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    DBG_FN("WiaMCamDeleteItem");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    DWORD dwFileAttr = 0;
    PTSTR ptszFullName = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItem, hr, "WiaMCamDeleteItem");

    ptszFullName = (PTSTR) pItem->pPrivateStorage;

    dwFileAttr = GetFileAttributes(ptszFullName);
    REQUIRE_FILEIO(dwFileAttr != -1, hr, "WiaMCamDeleteItem", "GetFileAttributes failed");

    dwFileAttr |= FILE_ATTRIBUTE_HIDDEN;

    ret = SetFileAttributes(ptszFullName, dwFileAttr);
    REQUIRE_FILEIO(ret, hr, "WiaMCamDeleteItem", "SetFileAttributes failed");

    wiauDbgTrace("WiaMCamDeleteItem", "File %" WIAU_DEBUG_TSTR " is now hidden", ptszFullName);

Cleanup:
    return hr;
}

//
// Sets the protection for an item
//
HRESULT WiaMCamSetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly)
{
    DBG_FN("WiaMCamSetItemProt");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    DWORD dwFileAttr = 0;
    PTSTR ptszFullName = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItem, hr, "WiaMCamSetItemProt");

    ptszFullName = (PTSTR) pItem->pPrivateStorage;

    dwFileAttr = GetFileAttributes(ptszFullName);
    REQUIRE_FILEIO(dwFileAttr != -1, hr, "WiaMCamSetItemProt", "GetFileAttributes failed");

    if (bReadOnly)
        dwFileAttr |= FILE_ATTRIBUTE_READONLY;
    else
        dwFileAttr &= ~FILE_ATTRIBUTE_READONLY;

    ret = SetFileAttributes(ptszFullName, dwFileAttr);
    REQUIRE_FILEIO(ret, hr, "WiaMCamSetItemProt", "SetFileAttributes failed");

    wiauDbgTrace("WiaMCamSetItemProt", "Protection on file %" WIAU_DEBUG_TSTR " set to %d", ptszFullName, bReadOnly);

Cleanup:
    return hr;
}

//
// Captures a new image
//
HRESULT WiaMCamTakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItem)
{
    DBG_FN("WiaMCamTakePicture");
    
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo || !ppItem, hr, "WiaMCamTakePicture");
    *ppItem = NULL;

Cleanup:
    return hr;
}

//
// See if the camera is active
//
HRESULT WiaMCamStatus(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamStatus");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo, hr, "WiaMCamStatus");

    //
    // This sample device is always active, but your driver should contact the
    // device and return S_FALSE if it's not ready.
    //
    // if (NotReady)
    //   return S_FALSE;

Cleanup:
    return hr;
}

//
// Reset the camera
//
HRESULT WiaMCamReset(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamReset");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo, hr, "WiaMCamReset");

Cleanup:
    return hr;
}

////////////////////////////////
//
// Helper functions
//
////////////////////////////////

//
// This function pretends to open a camera. A real driver
// would call CreateDevice.
//
HRESULT FakeCamOpen(PTSTR ptszPortName, MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("FakeCamOpen");

    HRESULT hr = S_OK;
    BOOL ret = FALSE;

    //
    // Locals
    //
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;
    DWORD dwFileAttr = 0;
    PTSTR ptszRootPath = NULL;
    UINT uiRootPathSize = 0;
    UINT uiSize = 0;
    UINT uiSystemDirMaxSize = 0;
    TCHAR tszImage[] = TEXT("\\image");

    //
    // Get a pointer to the private storage, so we can put the
    // directory name there
    //
    pPrivateDeviceInfo = (UNALIGNED  FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;
    ptszRootPath = pPrivateDeviceInfo->tszRootPath;
    uiRootPathSize = sizeof(pPrivateDeviceInfo->tszRootPath) / sizeof(pPrivateDeviceInfo->tszRootPath[0]);

    //
    // Unless the port name is set to something other than COMx,
    // LPTx, or AUTO, use %windir%\system32\image as the
    // search directory.
    //
    if (_tcsstr(ptszPortName, TEXT("COM")) ||
        _tcsstr(ptszPortName, TEXT("LPT")) ||
    	CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ptszPortName, -1, TEXT("AUTO"), -1) == CSTR_EQUAL)
    {
        uiSystemDirMaxSize = uiRootPathSize - _tcslen(tszImage);

        uiSize = GetSystemDirectory(ptszRootPath, uiSystemDirMaxSize);
        REQUIRE_FILEIO(uiSize, hr, "WiaMCamOpen", "GetSystemDirectory failed");
        ptszRootPath[uiSystemDirMaxSize - 1] = 0;
        if (uiSize > uiSystemDirMaxSize) {
            wiauDbgError("WiaMCamOpen", "Root path is too long, %d", uiSize);
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // Make sure whole string fits into the buffer and gets zero-terminated
        //
        _tcsncat(ptszRootPath, tszImage, uiRootPathSize - _tcslen(ptszRootPath));
        ptszRootPath[uiRootPathSize - 1] = 0;
    }
    else
    {
        lstrcpyn(ptszRootPath, ptszPortName, uiRootPathSize);
    }

    wiauDbgTrace("Open", "Image directory path is %" WIAU_DEBUG_TSTR, ptszRootPath);

    dwFileAttr = GetFileAttributes(ptszRootPath);
    if (dwFileAttr == -1)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            ret = CreateDirectory(ptszRootPath, NULL);
            REQUIRE_FILEIO(ret, hr, "Open", "CreateDirectory failed");
        }
        else
        {
            wiauDbgErrorHr(hr, "Open", "GetFileAttributes failed");
            goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//
// This function searches a directory on the hard drive for
// items.
//
HRESULT SearchDir(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszPath)
{
    DBG_FN("SearchDir");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    HANDLE hFind = NULL;
    WIN32_FIND_DATA FindData;
    const cchTempStrSize = MAX_PATH;
    TCHAR tszTempStr[cchTempStrSize] = TEXT("");
    TCHAR tszFullName[MAX_PATH] = TEXT("");;
    MCAM_ITEM_INFO *pFolder = NULL;
    MCAM_ITEM_INFO *pImage = NULL;
    
    REQUIRE_ARGS(!pPrivateDeviceInfo || !ptszPath, hr, "SearchDir");

    //
    // Search for folders first
    //

    //
    // Make sure search path fits into the buffer and gets zero-terminated
    //
    if (_sntprintf(tszTempStr, cchTempStrSize, _T("%s\\*"), ptszPath) < 0)
    {
        wiauDbgError("SearchDir", "Too long path for search");
        hr = E_FAIL;
        goto Cleanup;
    }
    tszTempStr[cchTempStrSize - 1] = 0;

    wiauDbgTrace("SearchDir", "Searching directory %" WIAU_DEBUG_TSTR, tszTempStr);

    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFile(tszTempStr, &FindData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            wiauDbgWarning("SearchDir", "Directory %" WIAU_DEBUG_TSTR " is empty", tszTempStr);
            goto Cleanup;
        }
        else
        {
            wiauDbgErrorHr(hr, "SearchDir", "FindFirstFile failed");
            goto Cleanup;
        }
    }

    while (hr == S_OK)
    {
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (FindData.cFileName[0] != L'.'))
        {
            hr = MakeFullName(tszFullName, sizeof(tszFullName) / sizeof(tszFullName[0]), 
                              ptszPath, FindData.cFileName);
            REQUIRE_SUCCESS(hr, "SearchDir", "MakeFullName failed");
            
            hr = CreateFolder(pPrivateDeviceInfo, pParent, &FindData, &pFolder, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "CreateFolder failed");

            hr = AddItem(pPrivateDeviceInfo, pFolder);
            REQUIRE_SUCCESS(hr, "SearchDir", "AddItem failed");

            hr = SearchDir(pPrivateDeviceInfo, pFolder, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "Recursive SearchDir failed");
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                wiauDbgErrorHr(hr, "SearchDir", "FindNextFile failed");
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    hr = S_OK;

    //
    // Search next for JPEGs
    //

    //
    // Make sure search path fits into the buffer and gets zero-terminated
    //
    if (_sntprintf(tszTempStr, cchTempStrSize, _T("%s\\*.jpg"), ptszPath) < 0)
    {
        wiauDbgError("SearchDir", "Too long path for search");
        hr = E_FAIL;
        goto Cleanup;
    }
    tszTempStr[cchTempStrSize - 1] = 0;

    memset(&FindData, 0, sizeof(FindData));

    hFind = FindFirstFile(tszTempStr, &FindData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            wiauDbgWarning("SearchDir", "No JPEGs in directory %" WIAU_DEBUG_TSTR, tszTempStr);
            goto Cleanup;
        }
        else
        {
            wiauDbgErrorHr(hr, "SearchDir", "FindFirstFile failed");
            goto Cleanup;
        }
    }

    while (hr == S_OK)
    {
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
        {
            hr = MakeFullName(tszFullName, sizeof(tszFullName) / sizeof(tszFullName[0]), 
                              ptszPath, FindData.cFileName);
            REQUIRE_SUCCESS(hr, "SearchDir", "MakeFullName failed");

            hr = CreateImage(pPrivateDeviceInfo, pParent, &FindData, &pImage, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "CreateImage failed");

            hr = AddItem(pPrivateDeviceInfo, pImage);
            REQUIRE_SUCCESS(hr, "SearchDir", "AddItem failed");

            hr = SearchForAttachments(pPrivateDeviceInfo, pImage, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "SearchForAttachments failed");

            if (hr == S_OK)
                pImage->bHasAttachments = TRUE;

            hr = S_OK;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                wiauDbgErrorHr(hr, "SearchDir", "FindNextFile failed");
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    hr = S_OK;

    //
    // ISSUE-10/18/2000-davepar Do the same for other image types
    //

Cleanup:
    return hr;
}

//
// Searches for attachments to an image item
//
HRESULT SearchForAttachments(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszMainItem)
{
    DBG_FN("SearchForAttachments");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    INT iNumAttachments = 0;
    HANDLE hFind = NULL;
    WIN32_FIND_DATA FindData;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    TCHAR tszFullName[MAX_PATH] = TEXT("");
    TCHAR *ptcSlash = NULL;
    TCHAR *ptcDot = NULL;
    MCAM_ITEM_INFO *pNonImage = NULL;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !ptszMainItem, hr, "SearchForAttachments");
    
    //
    // Find the last dot in the filename and replace the file extension with * and do the search
    //
    lstrcpyn(tszTempStr, ptszMainItem, sizeof(tszTempStr) / sizeof(tszTempStr[0]) - 1);
    ptcDot = _tcsrchr(tszTempStr, TEXT('.'));
    
    if (ptcDot)
    {
        *(ptcDot+1) = TEXT('*');
        *(ptcDot+2) = TEXT('\0');
    }
    else
    {
        wiauDbgError("SearchForAttachments", "Filename did not contain a dot");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Replace the first four "free" characters of the name with ? (attachments only need to match
    // the last four characters of the name)
    //
    ptcSlash = _tcsrchr(tszTempStr, TEXT('\\'));
    if (ptcSlash && ptcDot - ptcSlash > 4)
    {
        for (INT i = 1; i < 5; i++)
            *(ptcSlash+i) = TEXT('?');
    }

    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFile(tszTempStr, &FindData);
    REQUIRE_FILEHANDLE(hFind, hr, "SearchForAttachments", "FindFirstFile failed");

    while (hr == S_OK)
    {
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) &&
            !(_tcsstr(ptszMainItem, FindData.cFileName)))
        {
            //
            // Figure out the full name for the item
            //
            lstrcpyn(tszTempStr, ptszMainItem, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
            ptcSlash = _tcsrchr(tszTempStr, TEXT('\\'));
            if (ptcSlash)
            {
                *ptcSlash = TEXT('\0');
            }

            hr = MakeFullName(tszFullName, sizeof(tszFullName) / sizeof(tszFullName[0]), 
                              tszTempStr, FindData.cFileName);
            REQUIRE_SUCCESS(hr, "SearchForAttachments", "MakeFullName failed");

            hr = CreateNonImage(pPrivateDeviceInfo, pParent, &FindData, &pNonImage, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchForAttachments", "CreateNonImage failed");

            hr = AddItem(pPrivateDeviceInfo, pNonImage);
            REQUIRE_SUCCESS(hr, "SearchForAttachments", "AddItem failed");

            iNumAttachments++;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                wiauDbgErrorHr(hr, "SearchForAttachments", "FindNextFile failed");
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    if (iNumAttachments > 0)
        hr = S_OK;
    else
        hr = S_FALSE;

Cleanup:
    return hr;    
}

HRESULT CreateFolder(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent,
                     WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppFolder, PTSTR ptszFullName)
{
    DBG_FN("CreateFolder");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    TCHAR *ptcDot = NULL;
    MCAM_ITEM_INFO *pItem = NULL;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pFindData || !ppFolder || !ptszFullName, hr, "CreateFolder");
    *ppFolder = NULL;

    pItem = new MCAM_ITEM_INFO;
    REQUIRE_ALLOC(pItem, hr, "CreateFolder");

    //
    // Chop off the filename extension from the name, if it exists
    //
    lstrcpyn(tszTempStr, pFindData->cFileName, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
    ptcDot = _tcsrchr(tszTempStr, TEXT('.'));
    if (ptcDot)
        *ptcDot = TEXT('\0');

    //
    // Fill in the MCAM_ITEM_INFO structure
    //
    hr = SetCommonFields(pItem, tszTempStr, ptszFullName, pFindData);
    REQUIRE_SUCCESS(hr, "CreateFolder", "SetCommonFields failed");
    
    pItem->pParent = pParent;
    pItem->iType = WiaMCamTypeFolder;

    *ppFolder = pItem;

    pPrivateDeviceInfo->iNumItems++;

    wiauDbgTrace("CreateFolder", "Created folder %" WIAU_DEBUG_TSTR " at 0x%08x under 0x%08x", pFindData->cFileName, pItem, pParent);

Cleanup:
    return hr;
}

HRESULT CreateImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent,
                    WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppImage, PTSTR ptszFullName)
{
    DBG_FN("CreateImage");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTSTR ptszDot = NULL;
    MCAM_ITEM_INFO *pItem = NULL;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    WORD width = 0;
    WORD height = 0;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pFindData || !ppImage || !ptszFullName, hr, "CreateImage");
    *ppImage = NULL;

    pItem = new MCAM_ITEM_INFO;
    REQUIRE_ALLOC(pItem, hr, "CreateImage");

    //
    // Chop off the filename extension from the name, if it exists
    //
    lstrcpyn(tszTempStr, pFindData->cFileName, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
    ptszDot = _tcsrchr(tszTempStr, TEXT('.'));
    if (ptszDot)
        *ptszDot = TEXT('\0');

    //
    // Fill in the MCAM_ITEM_INFO structure
    //
    hr = SetCommonFields(pItem, tszTempStr, ptszFullName, pFindData);
    REQUIRE_SUCCESS(hr, "CreateImage", "SetCommonFields failed");
    
    pItem->pParent = pParent;
    pItem->iType = WiaMCamTypeImage;
    pItem->pguidFormat = &WiaImgFmt_JPEG;
    pItem->lSize = pFindData->nFileSizeLow;
    pItem->pguidThumbFormat = &WiaImgFmt_JPEG;

    // 
    // Copy the file extension into the extension field
    //
    if (ptszDot) {
        hr = wiauStrT2W(ptszDot + 1, pItem->wszExt, MCAM_EXT_LEN * sizeof(pItem->wszExt[0]));
        REQUIRE_SUCCESS(hr, "CreateImage", "wiauStrT2W failed");
    }

    //
    // Interpret the JPEG image to get the image dimensions and thumbnail size
    //
    hr = ReadDimFromJpeg(ptszFullName, &width, &height);
    REQUIRE_SUCCESS(hr, "CreateImage", "ReadDimFromJpeg failed");

    pItem->lWidth = width;
    pItem->lHeight = height;
    pItem->lDepth = 24;
    pItem->lChannels = 3;
    pItem->lBitsPerChannel = 8;
    
    *ppImage = pItem;

    pPrivateDeviceInfo->iNumItems++;
    pPrivateDeviceInfo->iNumImages++;

    wiauDbgTrace("CreateImage", "Created image %" WIAU_DEBUG_TSTR " at 0x%08x under 0x%08x", pFindData->cFileName, pItem, pParent);

Cleanup:
    return hr;
}

HRESULT CreateNonImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent,
                       WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppNonImage, PTSTR ptszFullName)
{
    DBG_FN("CreateNonImage");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTSTR ptszDot = NULL;
    MCAM_ITEM_INFO *pItem = NULL;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    PTSTR ptszExt = NULL;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pFindData || !ppNonImage || !ptszFullName, hr, "CreateNonImage");
    *ppNonImage = NULL;

    pItem = new MCAM_ITEM_INFO;
    REQUIRE_ALLOC(pItem, hr, "CreateNonImage");

    //
    // The name cannot contain a dot and the name needs to be unique
    // wrt the parent image, so replace the dot with an underline character.
    //
    lstrcpyn(tszTempStr, pFindData->cFileName, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
    ptszDot = _tcsrchr(tszTempStr, TEXT('.'));
    if (ptszDot)
        *ptszDot = TEXT('_');

    //
    // Fill in the MCAM_ITEM_INFO structure
    //
    hr = SetCommonFields(pItem, tszTempStr, ptszFullName, pFindData);
    REQUIRE_SUCCESS(hr, "CreateNonImage", "SetCommonFields failed");
    
    pItem->pParent = pParent;
    pItem->iType = WiaMCamTypeOther;
    pItem->lSize = pFindData->nFileSizeLow;

    //
    // Set the format of the item based on the file extension
    //
    if (ptszDot) {
        ptszExt = ptszDot + 1;

        // 
        // Copy the file extension into the extension field
        //
        hr = wiauStrT2W(ptszExt, pItem->wszExt, MCAM_EXT_LEN * sizeof(pItem->wszExt[0]));
        REQUIRE_SUCCESS(hr, "CreateNonImage", "wiauStrT2W failed");

        if (_tcsicmp(ptszExt, TEXT("wav")) == 0) {
            pItem->pguidFormat = &WiaAudFmt_WAV;
            pItem->iType = WiaMCamTypeAudio;
        }
        else if (_tcsicmp(ptszExt, TEXT("mp3")) == 0) {
            pItem->pguidFormat = &WiaAudFmt_MP3;
            pItem->iType = WiaMCamTypeAudio;
        }
        else if (_tcsicmp(ptszExt, TEXT("wma")) == 0) {
            pItem->pguidFormat = &WiaAudFmt_WMA;
            pItem->iType = WiaMCamTypeAudio;
        }
        else if (_tcsicmp(ptszExt, TEXT("rtf")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_RTF;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("htm")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_HTML;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("html")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_HTML;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("txt")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_TXT;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("mpg")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_MPG;
            pItem->iType = WiaMCamTypeVideo;
        }
        else if (_tcsicmp(ptszExt, TEXT("avi")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_AVI;
            pItem->iType = WiaMCamTypeVideo;
        }
        else if (_tcsicmp(ptszExt, TEXT("asf")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_ASF;
            pItem->iType = WiaMCamTypeVideo;
        }
        else if (_tcsicmp(ptszExt, TEXT("exe")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_EXEC;
            pItem->iType = WiaMCamTypeOther;
        }
        else {
            //
            // Generate a random GUID for the format
            //
            if (g_guidUnknownFormat.Data1 == 0) {
                hr = CoCreateGuid(&g_guidUnknownFormat);
                REQUIRE_SUCCESS(hr, "CreateNonImage", "CoCreateGuid failed");
            }
            pItem->pguidFormat = &g_guidUnknownFormat;
            pItem->iType = WiaMCamTypeOther;
        }
    }

    *ppNonImage = pItem;

    pPrivateDeviceInfo->iNumItems++;

    wiauDbgTrace("CreateNonImage", "Created non-image %" WIAU_DEBUG_TSTR " at 0x%08x under 0x%08x", pFindData->cFileName, pItem, pParent);

Cleanup:
    return hr;
}

//
// Sets the fields of the MCAM_ITEM_INFO that are common to all items
//
HRESULT SetCommonFields(MCAM_ITEM_INFO *pItem,
                        PTSTR ptszShortName,
                        PTSTR ptszFullName,
                        WIN32_FIND_DATA *pFindData)
{
    DBG_FN("SetCommonFields");

    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    PTSTR ptszTempStr = NULL;
    INT iSize = 0;

    REQUIRE_ARGS(!pItem || !ptszShortName || !ptszFullName || !pFindData, hr, "SetFullName");

    //
    // Initialize the structure
    //
    memset(pItem, 0, sizeof(MCAM_ITEM_INFO));
    pItem->iSize = sizeof(MCAM_ITEM_INFO);
    
    iSize = lstrlen(ptszShortName) + 1;
    pItem->pwszName = new WCHAR[iSize];
    REQUIRE_ALLOC(pItem->pwszName, hr, "SetCommonFields");
    wiauStrT2W(ptszShortName, pItem->pwszName, iSize * sizeof(WCHAR));
    REQUIRE_SUCCESS(hr, "SetCommonFields", "wiauStrT2W failed");

    FILETIME ftLocalFileTime;
    memset(&pItem->Time, 0, sizeof(pItem->Time));
    memset(&ftLocalFileTime, 0, sizeof(FILETIME));
    ret = FileTimeToLocalFileTime(&pFindData->ftLastWriteTime, &ftLocalFileTime);
    REQUIRE_FILEIO(ret, hr, "SetCommonFields", "FileTimeToLocalFileTime failed");
    ret = FileTimeToSystemTime(&ftLocalFileTime, &pItem->Time);
    REQUIRE_FILEIO(ret, hr, "SetCommonFields", "FileTimeToSystemTime failed");

    pItem->bReadOnly = pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY;
    pItem->bCanSetReadOnly = TRUE;

    //
    // Set the private storage area of the MCAM_ITEM_INFO structure to the
    // full path name of the item
    //
    iSize = lstrlen(ptszFullName) + 1;
    ptszTempStr = new TCHAR[iSize];
    REQUIRE_ALLOC(ptszTempStr, hr, "SetCommonFields");
    lstrcpy(ptszTempStr, ptszFullName);
    pItem->pPrivateStorage = (BYTE *) ptszTempStr;

Cleanup:
    return hr;
}

HRESULT AddItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pItem, hr, "AddItem");

    if (pPrivateDeviceInfo->pLastItem) {
        //
        // Insert the item at the end of the list
        //
        pPrivateDeviceInfo->pLastItem->pNext = pItem;
        pItem->pPrev = pPrivateDeviceInfo->pLastItem;
        pItem->pNext = NULL;
        pPrivateDeviceInfo->pLastItem = pItem;
    }
    else
    {
        //
        // List is currently empty, add this as first and only item
        //
        pPrivateDeviceInfo->pFirstItem = pPrivateDeviceInfo->pLastItem = pItem;
        pItem->pPrev = pItem->pNext = NULL;
    }

Cleanup:
    return hr;
}

HRESULT RemoveItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pItem, hr, "RemoveItem");

    if (pItem->pPrev)
        pItem->pPrev->pNext = pItem->pNext;
    if (pItem->pNext)
        pItem->pNext->pPrev = pItem->pPrev;

    if (pPrivateDeviceInfo->pFirstItem == pItem)
        pPrivateDeviceInfo->pFirstItem = pItem->pNext;
    if (pPrivateDeviceInfo->pLastItem == pItem)
        pPrivateDeviceInfo->pLastItem = pItem->pPrev;

Cleanup:
    return hr;
}

//
// This function reads a JPEG file looking for the frame header, which contains
// the width and height of the image.
//
HRESULT ReadDimFromJpeg(PTSTR ptszFullName, WORD *pWidth, WORD *pHeight)
{
    DBG_FN("ReadDimFromJpeg");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    HANDLE hFile = NULL;
    BYTE *pBuffer = NULL;
    DWORD BytesRead = 0;
    BYTE *pCur = NULL;
    int SegmentLength = 0;
    const int Overlap = 8;  // if pCur gets within Overlap bytes of the end, read another chunk
    const DWORD BytesToRead = 32 * 1024;

    REQUIRE_ARGS(!ptszFullName || !pWidth || !pHeight, hr, "ReadDimFromJpeg");

    *pWidth = 0;
    *pHeight = 0;

    hFile = CreateFile(ptszFullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    REQUIRE_FILEHANDLE(hFile, hr, "ReadDimFromJpeg", "CreateFile failed");
    
    pBuffer = new BYTE[BytesToRead];
    REQUIRE_ALLOC(pBuffer, hr, "ReadDimFromJpeg");

    ret = ReadFile(hFile, pBuffer, BytesToRead, &BytesRead, NULL);
    REQUIRE_FILEIO(ret, hr, "ReadDimFromJpeg", "ReadFile failed");

    wiauDbgTrace("ReadDimFromJpeg", "Read %d bytes", BytesRead);

    pCur = pBuffer;

    //
    // Pretend that we read Overlap fewer bytes than were actually read
    //
    BytesRead -= Overlap;

    while (SUCCEEDED(hr) &&
           BytesRead != 0 &&
           pCur[1] != 0xc0)
    {
        if (pCur[0] != 0xff)
        {
            wiauDbgError("ReadDimFromJpeg", "Not a JFIF format image");
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // if the marker is >= 0xd0 and <= 0xd9 or is equal to 0x01
        // there is no length field
        //
        if (((pCur[1] & 0xf0) == 0xd0 &&
             (pCur[1] & 0x0f) < 0xa) ||
            pCur[1] == 0x01)
        {
            SegmentLength = 0;
        }
        else
        {
            SegmentLength = ByteSwapWord(*((UNALIGNED WORD *) (pCur + 2)));
        }

        pCur += SegmentLength + 2;

        if (pCur >= pBuffer + BytesRead)
        {
            memcpy(pBuffer, pBuffer + BytesRead, Overlap);

            pCur -= BytesRead;

            ret = ReadFile(hFile, pBuffer + Overlap, BytesToRead - Overlap, &BytesRead, NULL);
            REQUIRE_FILEIO(ret, hr, "ReadDimFromJpeg", "ReadFile failed");

            wiauDbgTrace("ReadDimFromJpeg", "Read %d more bytes", BytesRead);
        }
    }

    if (pCur[0] != 0xff)
    {
        wiauDbgError("ReadDimFromJpeg", "Not a JFIF format image");
        return E_FAIL;
    }

    *pHeight = ByteSwapWord(*((UNALIGNED WORD *) (pCur + 5)));
    *pWidth =  ByteSwapWord(*((UNALIGNED WORD *) (pCur + 7)));

Cleanup:
    if (pBuffer) {
        delete []pBuffer;
    }
    if (hFile && hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;
}

//
// The next section contains functions useful for reading information from
// Exif files.
//
HRESULT ReadJpegHdr(PTSTR ptszFullName, BYTE **ppBuf)
{
    DBG_FN("ReadJpegHdr");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    HANDLE hFile = NULL;
    BYTE JpegHdr[] = {0xff, 0xd8, 0xff, 0xe1};
    const int JpegHdrSize = sizeof(JpegHdr) + 2;
    BYTE tempBuf[JpegHdrSize];
    DWORD BytesRead = 0;
    WORD TagSize = 0;

    hFile = CreateFile(ptszFullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    REQUIRE_FILEHANDLE(hFile, hr, "ReadJpegHdr", "CreateFile failed");


    ret = ReadFile(hFile, tempBuf, JpegHdrSize, &BytesRead, NULL);
    REQUIRE_FILEIO(ret, hr, "ReadJpegHdr", "ReadFile failed");
    
    if (BytesRead != JpegHdrSize) {
        wiauDbgError("ReadJpegHdr", "Wrong amount read %d", BytesRead);
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if (memcmp(tempBuf, JpegHdr, sizeof(JpegHdr)) != 0)
    {
        wiauDbgError("ReadJpegHdr", "JPEG header not found");
        hr = E_FAIL;
        goto Cleanup;
    }

    TagSize = GetWord(tempBuf + sizeof(JpegHdr), TRUE);
    *ppBuf = new BYTE[TagSize];
    REQUIRE_ALLOC(ppBuf, hr, "ReadJpegHdr");

    ret = ReadFile(hFile, *ppBuf, TagSize, &BytesRead, NULL);
    REQUIRE_FILEIO(ret, hr, "ReadJpegHdr", "ReadFile failed");
     
    if (BytesRead != TagSize)
    {
        wiauDbgError("ReadJpegHdr", "Wrong amount read %d", BytesRead);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if (hFile && hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;
}


HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap)
{
    DBG_FN("ReadExifJpeg");
    
    HRESULT hr = S_OK;

    BYTE ExifTag[] = {0x45, 0x78, 0x69, 0x66, 0x00, 0x00};

    if (memcmp(pBuf, ExifTag, sizeof(ExifTag)) != 0)
    {
        wiauDbgError("ReadExifJpeg", "Exif tag not found");
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = ReadTiff(pBuf + APP1_OFFSET, pImageIfd, pThumbIfd, pbSwap);
    REQUIRE_SUCCESS(hr, "ReadExifJpeg", "ReadTiff failed");

Cleanup:
    return hr;
}

HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap)
{
    DBG_FN("ReadTiff");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    WORD MagicNumber = 0;

    *pbSwap = FALSE;

    if (pBuf[0] == 0x4d) {
        *pbSwap = TRUE;
        if (pBuf[1] != 0x4d)
        {
            wiauDbgError("ReadTiff", "Second TIFF byte swap indicator not present");
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else if (pBuf[0] != 0x49 ||
             pBuf[1] != 0x49)
    {
        wiauDbgError("ReadTiff", "TIFF byte swap indicator not present");
        hr = E_FAIL;
        goto Cleanup;
    }

    MagicNumber = GetWord(pBuf+2, *pbSwap);
    if (MagicNumber != 42)
    {
        wiauDbgError("ReadTiff", "TIFF magic number not present");
        hr = E_FAIL;
        goto Cleanup;
    }

    wiauDbgTrace("ReadTiff", "Reading image IFD");

    pImageIfd->Offset = GetDword(pBuf + 4, *pbSwap);
    hr = ReadIfd(pBuf, pImageIfd, *pbSwap);
    REQUIRE_SUCCESS(hr, "ReadTiff", "ReadIfd failed");

    wiauDbgTrace("ReadTiff", "Reading thumb IFD");

    pThumbIfd->Offset = pImageIfd->NextIfdOffset;
    hr = ReadIfd(pBuf, pThumbIfd, *pbSwap);
    REQUIRE_SUCCESS(hr, "ReadTiff", "ReadIfd failed");

Cleanup:
    return hr;
}

HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap)
{
    DBG_FN("ReadIfd");
    
    HRESULT hr = S_OK;

    const int DIR_ENTRY_SIZE = 12;
    
    pBuf += pIfd->Offset;

    pIfd->Count = GetWord(pBuf, bSwap);

    pIfd->pEntries = new DIR_ENTRY[pIfd->Count];
    if (!pIfd->pEntries)
        return E_OUTOFMEMORY;

    pBuf += 2;
    for (int count = 0; count < pIfd->Count; count++)
    {
        pIfd->pEntries[count].Tag = GetWord(pBuf, bSwap);
        pIfd->pEntries[count].Type = GetWord(pBuf + 2, bSwap);
        pIfd->pEntries[count].Count = GetDword(pBuf + 4, bSwap);
        pIfd->pEntries[count].Offset = GetDword(pBuf + 8, bSwap);
        pBuf += DIR_ENTRY_SIZE;

        wiauDbgDump("ReadIfd", "Tag 0x%04x, type %2d offset/value 0x%08x",
                    pIfd->pEntries[count].Tag, pIfd->pEntries[count].Type, pIfd->pEntries[count].Offset);
    }

    pIfd->NextIfdOffset = GetDword(pBuf, bSwap);

    return hr;
}

VOID FreeIfd(IFD *pIfd)
{
    if (pIfd->pEntries)
        delete []pIfd->pEntries;
    pIfd->pEntries = NULL;
}

WORD ByteSwapWord(WORD w)
{
    return (w >> 8) | (w << 8);
}

DWORD ByteSwapDword(DWORD dw)
{
    return ByteSwapWord((WORD) (dw >> 16)) | (ByteSwapWord((WORD) (dw & 0xffff)) << 16);
}

WORD GetWord(BYTE *pBuf, BOOL bSwap)
{
    WORD w = *((UNALIGNED WORD *) pBuf);

    if (bSwap)
        w = ByteSwapWord(w);
    
    return w;
}

DWORD GetDword(BYTE *pBuf, BOOL bSwap)
{
    DWORD dw = *((UNALIGNED DWORD *) pBuf);

    if (bSwap)
        dw = ByteSwapDword(dw);

    return dw;
}

/*
//
// Set the default and valid values for a property
//
VOID
FakeCamera::SetValidValues(
    INT index,
    CWiaPropertyList *pPropertyList
    )
{
    HRESULT hr = S_OK;

    ULONG ExposureModeList[] = {
        EXPOSUREMODE_MANUAL,
        EXPOSUREMODE_AUTO,
        EXPOSUREMODE_APERTURE_PRIORITY,
        EXPOSUREMODE_SHUTTER_PRIORITY,
        EXPOSUREMODE_PROGRAM_CREATIVE,
        EXPOSUREMODE_PROGRAM_ACTION,
        EXPOSUREMODE_PORTRAIT
    };

    PROPID PropId = pPropertyList->GetPropId(index);
    WIA_PROPERTY_INFO *pPropInfo = pPropertyList->GetWiaPropInfo(index);

    //
    // Based on the property ID, populate the valid values range or list information
    //
    switch (PropId)
    {
    case WIA_DPC_EXPOSURE_MODE:
        pPropInfo->ValidVal.List.Nom      = EXPOSUREMODE_MANUAL;
        pPropInfo->ValidVal.List.cNumList = sizeof(ExposureModeList) / sizeof(ExposureModeList[0]);
        pPropInfo->ValidVal.List.pList    = (BYTE*) ExposureModeList;
        break;

    case WIA_DPC_EXPOSURE_COMP:
        pPropInfo->ValidVal.Range.Nom = 0;
        pPropInfo->ValidVal.Range.Min = -200;
        pPropInfo->ValidVal.Range.Max = 200;
        pPropInfo->ValidVal.Range.Inc = 50;
        break;

    default:
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FakeCamera::SetValidValues, property 0x%08x not defined", PropId));
        return;
    }

    return;
}
*/

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
\**************************************************************************/


extern "C" __declspec( dllexport )
BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            
            break;

        case DLL_PROCESS_DETACH:
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\fakecam\fakecam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       fakecam.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Camera device
*
***************************************************************************/

#pragma once

//
// Structure to hold information about the device
//
typedef struct _FAKECAM_DEVICE_INFO
{
    TCHAR           tszRootPath[MAX_PATH];
    MCAM_ITEM_INFO *pFirstItem;
    MCAM_ITEM_INFO *pLastItem;
    INT             iNumImages;
    INT             iNumItems;
    HANDLE          hFile;

} UNALIGNED FAKECAM_DEVICE_INFO, * UNALIGNED PFAKECAM_DEVICE_INFO;

//
// Functions
//
inline BOOL IsImageType(const GUID *pFormat)
{
    return (pFormat && 
               (IsEqualGUID(*pFormat, WiaImgFmt_JPEG) ||
                IsEqualGUID(*pFormat, WiaImgFmt_BMP) ||
                IsEqualGUID(*pFormat, WiaImgFmt_TIFF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_MEMORYBMP) ||
                IsEqualGUID(*pFormat, WiaImgFmt_EXIF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_FLASHPIX) ||
                IsEqualGUID(*pFormat, WiaImgFmt_JPEG2K) ||
                IsEqualGUID(*pFormat, WiaImgFmt_JPEG2KX) ||
                IsEqualGUID(*pFormat, WiaImgFmt_EMF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_WMF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_PNG) ||
                IsEqualGUID(*pFormat, WiaImgFmt_GIF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_PHOTOCD) ||
                IsEqualGUID(*pFormat, WiaImgFmt_ICO) ||
                IsEqualGUID(*pFormat, WiaImgFmt_CIFF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_PICT)));
}

HRESULT FakeCamOpen(PTSTR ptszPortName, MCAM_DEVICE_INFO *pDeviceInfo);
HRESULT SearchDir(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszPath);
HRESULT SearchForAttachments(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszMainItem);
HRESULT CreateFolder(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppFolder, PTSTR ptszFullName);
HRESULT CreateImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppImage, PTSTR ptszFullName);
HRESULT CreateNonImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppNonImage, PTSTR ptszFullName);
HRESULT SetCommonFields(MCAM_ITEM_INFO *pItem, PTSTR ptszShortName, PTSTR ptszFullName, WIN32_FIND_DATA *pFindData);

HRESULT AddItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem);
HRESULT RemoveItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem);

//
// Helper function - generate full file name as "<Path>\<FileName>"
// cchFullNameSize - size of the buffer provided in ptszFullName. Function will return E_FAIL if
// the buffer is not big enough to accomodate full path and teminating zero character
//
inline HRESULT MakeFullName(PTSTR ptszFullName, UINT cchFullNameSize, PTSTR ptszPath, PTSTR ptszFileName)
{
    HRESULT hr = S_OK;
    if (_sntprintf(ptszFullName, cchFullNameSize, _T("%s\\%s"), ptszPath, ptszFileName) < 0)
    {
        hr = E_FAIL;
    }
    ptszFullName[cchFullNameSize - 1] = 0;
    return hr;
}

//
// Constants for reading Exif files
//
const WORD TIFF_XRESOLUTION =   0x11a;
const WORD TIFF_YRESOLUTION =   0x11b;
const WORD TIFF_JPEG_DATA =     0x201;
const WORD TIFF_JPEG_LEN =      0x202;

const int APP1_OFFSET = 6;      // Offset between the start of the APP1 segment and the start of the TIFF tags

//
// Structures for reading Exif files
//
typedef struct _DIR_ENTRY
{
    WORD    Tag;
    WORD    Type;
    DWORD   Count;
    DWORD   Offset;
} DIR_ENTRY, *PDIR_ENTRY;

typedef struct _IFD
{
    DWORD       Offset;
    WORD        Count;
    DIR_ENTRY  *pEntries;
    DWORD       NextIfdOffset;
} IFD, *PIFD;

//
// Functions for reading Exif files
//
HRESULT ReadDimFromJpeg(PTSTR ptszFullName, WORD *pWidth, WORD *pHeight);
HRESULT ReadJpegHdr(PTSTR ptszFileName, BYTE **ppBuf);
HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap);
VOID    FreeIfd(IFD *pIfd);
WORD    ByteSwapWord(WORD w);
DWORD   ByteSwapDword(DWORD dw);
WORD    GetWord(BYTE *pBuf, BOOL bSwap);
DWORD   GetDword(BYTE *pBuf, BOOL bSwap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\iso15740\testexe\ptp.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ptp.cpp

Abstract:

    Program for testing the PTP camera library without using WIA

Author:

    DavePar

Revision History:


--*/

#include <windows.h>
#include <stddef.h>
#include <tchar.h>
#include <objbase.h>
#include <assert.h>
#include <stdio.h>
#include <usbscan.h>

#include "wiatempl.h"
#include "iso15740.h"
#include "camera.h"
#include "camusb.h"

// Software Tracing goo

// {9A716C69-7A13-437c-B4EC-C6D1CAAFBCD9}
#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Regular,(9A716C69,7A13,437c,B4EC,C6D1CAAFBCD9), \
    WPP_DEFINE_BIT(Entry)      \
    WPP_DEFINE_BIT(Exit)       \
    WPP_DEFINE_BIT(Error)      \
    WPP_DEFINE_BIT(Unusual)    \
    WPP_DEFINE_BIT(Noise)      \
    )        \

#include <ptp.tmh>

#define MAX_SIZE 255

HRESULT EventCallback(LPVOID pCallbackParam, PPTP_EVENT pEvent)
{
    if (pEvent)
        printf("EventCallback called, event = 0x%08x\n", pEvent->EventCode);
    else
        printf("EventCallback initialized\n");

    return S_OK;
}

HRESULT DataCallback(LPVOID pCallbackParam, LONG lPercentComplete,
                     LONG lOffset, LONG lLength, BYTE **ppBuffer, LONG *plBufferSize)
{
    printf("DataCallback called, %3d percent complete, %5d bytes transferred\n", lPercentComplete, lLength);

    return S_OK;
}


void PrintCommands()
{
    printf("Valid commands:\n");
    printf("  op <#>   - open handle to device named Usbscan<#>\n");
    printf("  gd       - get DeviceInfo from device\n");
    printf("  os       - OpenSession\n");
    printf("  cs       - CloseSession\n");
    printf("  gs       - GetStorageIDs\n");
    printf("  gsi <id> - GetStorageInfo for StoreID <id>\n");
    printf("  gon      - GetNumObjects\n");
    printf("  goh      - GetObjectHandles\n");
    printf("  goi <h>  - GetObjectInfo for ObjectHandle <h>\n");
    printf("  go <h>   - GetObject for ObjectHandle <h>\n");
    printf("  gt <h>   - GetThumb for ObjectHandle <h>\n");
    printf("  do <h>   - DeleteObject for ObjectHandle <h>\n");
    printf("  gpd <pc> - GetDevicePropDesc for PropCode <pc>\n");
    printf("  rs       - ResetDevice\n");
    printf("  tp <f>   - TakePicture in format <f>\n");
    printf("  gds      - GetDeviceStatus (only valid for USB)\n");
    printf("  ex\n\n");
}

int __cdecl main(int argc, CHAR *argv[], CHAR *envp[])
{
    WPP_INIT_TRACING(L"PTPTest");

    printf("\nPTP Camera Test Program\n");
    printf("Version 0.5\n");
    printf("July 28, 2000\n\n");

    HRESULT hr = S_OK;

    BOOL bSessionOpen = FALSE;

    char szCommand[MAX_SIZE];
    char *szToken;
    char szWhiteSpace[] = " \t";

    DoTraceMessage(Noise, "Entering main function\n");

    //
    // Create an USB camera object
    //
    CPTPCamera *pCamera = new CUsbCamera;


    while (true)
    {
        printf("Enter command: ");

        if (!gets(szCommand))
        {
            break;
        }
        printf("\n");

        szToken = strtok(szCommand, szWhiteSpace);

        if (!szToken)
        {
            printf("ERROR: Invalid command\n");
            PrintCommands();
            continue;
        }

        //
        // Interpret command
        //
        if (strcmp(szToken, "ex") == 0)
        {
            break;
        }

        if (strcmp(szToken, "help") == 0 ||
            strcmp(szToken, "?") == 0)
        {
            PrintCommands();
            continue;
        }

        else if (strcmp(szToken, "op") == 0)
        {
            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: Open needs a Usbscan number--look at CreateFileName registry key\n\n");
                continue;
            }

            WCHAR scratch1[MAX_SIZE];
            WCHAR scratch2[MAX_SIZE];

            mbstowcs(scratch1, szToken, MAX_SIZE);
            wcscpy(scratch2, L"\\\\.\\Usbscan");
            wcscat(scratch2, scratch1);

            printf("Opening device %S\n\n", scratch2);

            hr = pCamera->Open(scratch2, EventCallback, DataCallback, NULL);
        }
        
        else if (strcmp(szToken, "gd") == 0)
        {
            CPtpDeviceInfo DeviceInfo;

            hr = pCamera->GetDeviceInfo(&DeviceInfo);
        }
        
        else if (strcmp(szToken, "os") == 0)
        {
            ULONG sessionId;
            
            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: OpenSession needs a session number\n\n");
                continue;
            }

            sscanf(szToken, "%lu", &sessionId);

            if (sessionId == 0)
            {
                printf("ERROR: OpenSession needs a non-zero session number\n\n");
                continue;
            }

            printf("Opening session %d\n\n", sessionId);
            

            hr = pCamera->OpenSession(sessionId);

            if (SUCCEEDED(hr))
                bSessionOpen = TRUE;
        }

        else if (strcmp(szToken, "cs") == 0)
        {
            printf("Closing session\n\n");

            hr = pCamera->CloseSession();
        }

        else if (strcmp(szToken, "gs") == 0)
        {
            CArray32 StorageIds;

            printf("Getting storage ids\n\n");

            hr = pCamera->GetStorageIDs(&StorageIds);
        }

        else if (strcmp(szToken, "gsi") == 0)
        {
            ULONG StorageId;
            CPtpStorageInfo StorageInfo;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetStorageInfo needs a StorageID\n\n");
                continue;
            }

            sscanf(szToken, "%li", &StorageId);

            printf("Getting storage info for storage id 0x%08x\n\n", StorageId);

            hr = pCamera->GetStorageInfo(StorageId, &StorageInfo);
        }
        
        else if (strcmp(szToken, "gon") == 0)
        {
            UINT NumObjects;

            printf("Getting number of objects\n\n");

            hr = pCamera->GetNumObjects(PTP_STORAGEID_ALL, PTP_FORMATCODE_ALL, PTP_OBJECTHANDLE_ALL, &NumObjects);
        }
        
        else if (strcmp(szToken, "goh") == 0)
        {
            CArray32 ObjectIds;

            printf("Getting object ids\n\n");

            hr = pCamera->GetObjectHandles(PTP_STORAGEID_ALL, PTP_FORMATCODE_ALL, PTP_OBJECTHANDLE_ALL, &ObjectIds);
        }
        
        else if (strcmp(szToken, "goi") == 0)
        {
            DWORD ObjectHandle;
            CPtpObjectInfo ObjectInfo;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetObjectInfo needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Getting object info for object handle 0x%08x\n\n", ObjectHandle);

            hr = pCamera->GetObjectInfo(ObjectHandle, &ObjectInfo);
        }

        else if (strcmp(szToken, "go") == 0)
        {
            DWORD ObjectHandle;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetObject needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Getting object for object handle 0x%08x\n\n", ObjectHandle);

            UINT BufferSize = 32 * 1024;
            BYTE *pBuffer = new BYTE[BufferSize];
            if (!pBuffer)
            {
                printf("ERROR: Couldn't allocate the buffer\n\n");
                continue;
            }

            hr = pCamera->GetObjectData(ObjectHandle, pBuffer, &BufferSize, NULL);

            delete []pBuffer;
        }
        
        else if (strcmp(szToken, "gt") == 0)
        {
            DWORD ObjectHandle;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetThumb needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Getting thumbnail for object handle 0x%08x\n\n", ObjectHandle);

            UINT BufferSize = 16 * 1024;
            BYTE *pBuffer = new BYTE[BufferSize];
            if (!pBuffer)
            {
                printf("ERROR: Couldn't allocate the buffer\n\n");
                continue;
            }

            hr = pCamera->GetThumb(ObjectHandle, pBuffer, &BufferSize);

            delete []pBuffer;
        }
        
        else if (strcmp(szToken, "do") == 0)
        {
            DWORD ObjectHandle;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: DeleteObject needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Deleting object for object handle 0x%08x\n\n", ObjectHandle);

            hr = pCamera->DeleteObject(ObjectHandle, PTP_FORMATCODE_NOTUSED);
        }
        
        else if (strcmp(szToken, "gpd") == 0)
        {
            WORD PropCode;
            CPtpPropDesc PropDesc;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetDevicePropDesc needs a PropCode\n\n");
                continue;
            }

            sscanf(szToken, "%i", &PropCode);

            printf("Getting property description for prop code 0x%04x\n\n", PropCode);

            hr = pCamera->GetDevicePropDesc(PropCode, &PropDesc);
        }

        else if (strcmp(szToken, "rs") == 0)
        {
            printf("Resetting device...\n");

            hr = pCamera->ResetDevice();
        }
        
        else if (strcmp(szToken, "tp") == 0)
        {
            WORD Format;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: TakePicture needs a format\n\n");
                continue;
            }

            sscanf(szToken, "%i", &Format);

            printf("Taking a picture in format 0x%04x\n\n", Format);

            hr = pCamera->InitiateCapture(PTP_STORAGEID_DEFAULT, Format);
        }
        
#ifdef DEADCODE
        else if (strcmp(szToken, "gds") == 0)
        {
            printf("Getting device status\n\n");

            USB_PTPDEVICESTATUS Status;
            hr = ((CUsbCamera *) pCamera)->GetDeviceStatus(&Status);
        }
#endif
        
        else
        {
            printf("ERROR: Invalid command\n");
            PrintCommands();
            continue;
        }

        if (SUCCEEDED(hr))
            printf("Success!!\n\n");
        else
            printf("FAILED\n\n");

    } // while (true)

    if (bSessionOpen)
    {
        printf("Closing session\n\n");

        hr = pCamera->CloseSession();
        if (SUCCEEDED(hr))
            printf("Success!!\n\n");
        else
            printf("FAILED\n\n");
    }

    WPP_CLEANUP();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\fakecam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiacam.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiacam.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\ccammicro.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        CCamMicro.h
*
*  VERSION:     1.0
*
*  DATE:        12/14/2000
*
*  DESCRIPTION:
*    Implements a simple class to wrap the microdriver DLL. This
*    class could instead call the SDK for a camera.
*
*****************************************************************************/

#pragma once

//
// Function pointer type definitions
//
typedef HRESULT (__stdcall *FPInit)(MCAM_DEVICE_INFO **ppDeviceInfo);
typedef HRESULT (__stdcall *FPUnInit)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPOpen)(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName);
typedef HRESULT (__stdcall *FPClose)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPGetDeviceInfo)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList);
typedef HRESULT (__stdcall *FPReadEvent)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **pEventList);
typedef HRESULT (__stdcall *FPStopEvents)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPGetItemInfo)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
typedef HRESULT (__stdcall *FPFreeItemInfo)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
typedef HRESULT (__stdcall *FPGetThumbnail)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb);
typedef HRESULT (__stdcall *FPGetItemData)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength);
typedef HRESULT (__stdcall *FPDeleteItem)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem);
typedef HRESULT (__stdcall *FPSetItemProt)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly);
typedef HRESULT (__stdcall *FPTakePicture)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo);
typedef HRESULT (__stdcall *FPStatus)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPReset)(MCAM_DEVICE_INFO *pDeviceInfo);

//
// Wrapper class
//
class CCamMicro {
public:
    CCamMicro();
    ~CCamMicro();

    HRESULT Init(PTSTR ptszMicroDriverName, MCAM_DEVICE_INFO **ppDeviceInfo);
    HRESULT UnInit(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT Open(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName);
    HRESULT Close(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT GetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList);
    HRESULT ReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList);
    HRESULT StopEvents(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT GetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
    HRESULT FreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
    HRESULT GetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb);
    HRESULT GetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength);
    HRESULT DeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem);
    HRESULT SetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly);
    HRESULT TakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo);
    HRESULT Status(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT Reset(MCAM_DEVICE_INFO *pDeviceInfo);

private:
    HMODULE         m_hModule;
    FPInit          m_pInit;
    FPUnInit        m_pUnInit;
    FPOpen          m_pOpen;
    FPClose         m_pClose;
    FPGetDeviceInfo m_pGetDeviceInfo;
    FPReadEvent     m_pReadEvent;
    FPStopEvents    m_pStopEvents;
    FPGetItemInfo   m_pGetItemInfo;
    FPFreeItemInfo  m_pFreeItemInfo;
    FPGetThumbnail  m_pGetThumbnail;
    FPGetItemData   m_pGetItemData;
    FPDeleteItem    m_pDeleteItem;
    FPSetItemProt   m_pSetItemProt;
    FPTakePicture   m_pTakePicture;
    FPStatus        m_pStatus;
    FPReset         m_pReset;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\ccammicro.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       CCamMicro.cpp
*
*  VERSION:     1.0
*
*  DATE:        Dec 13, 2000
*
*  DESCRIPTION:
*   Implementation of a simple class that wraps a camera microdriver DLL.
*   This class loads the DLL and retrieves the address for the exported
*   functions.
*
*******************************************************************************/

#include "pch.h"

//
// These macros make it easier to wrap the DLL functions
//
#define GET_PROC_ADDRESS(fn) \
    m_p ## fn = (FP ## fn) GetProcAddress(m_hModule, "WiaMCam" #fn); \
    REQUIRE_FILEIO(m_p ## fn != NULL, hr, "Init", "GetProcAddress failed on WiaMCam" #fn);


#define CALL_DLL_FUNCTION(fn, parm) \
    HRESULT hr = S_OK; \
    if (m_p ## fn) { \
        hr = m_p ## fn ## parm; \
    } \
    else { \
        wiauDbgError("CCamMicro::" #fn, "m_p" #fn " not initialized"); \
        hr = E_FAIL; \
    } \
    return hr;

//
// Implementation of DLL wrapper
//
CCamMicro::CCamMicro() :
    m_hModule(NULL),
    m_pInit(NULL),
    m_pUnInit(NULL),
    m_pOpen(NULL),
    m_pClose(NULL),        
    m_pGetDeviceInfo(NULL),  
    m_pReadEvent(NULL),   
    m_pStopEvents(NULL),   
    m_pGetItemInfo(NULL), 
    m_pFreeItemInfo(NULL), 
    m_pGetThumbnail(NULL), 
    m_pGetItemData(NULL),  
    m_pDeleteItem(NULL),   
    m_pSetItemProt(NULL),   
    m_pTakePicture(NULL),  
    m_pStatus(NULL),       
    m_pReset(NULL)
{
}

CCamMicro::~CCamMicro()
{
    if (m_hModule != NULL) {
        FreeLibrary(m_hModule);
    }
}

HRESULT CCamMicro::Init(PTSTR ptszMicroDriverName, MCAM_DEVICE_INFO **ppDeviceInfo)
{
    DBG_FN("CCamMicro::CCamMicro");

    HRESULT hr = S_OK;

    //
    // Load the camera microdriver
    //
    m_hModule = LoadLibrary(ptszMicroDriverName);
    REQUIRE_FILEHANDLE(m_hModule, hr, "CCamMicro::CCamMicro", "LoadLibrary failed");

    GET_PROC_ADDRESS(Init);
    GET_PROC_ADDRESS(UnInit);
    GET_PROC_ADDRESS(Open);
    GET_PROC_ADDRESS(Close);
    GET_PROC_ADDRESS(GetDeviceInfo);
    GET_PROC_ADDRESS(ReadEvent);
    GET_PROC_ADDRESS(StopEvents);
    GET_PROC_ADDRESS(GetItemInfo);
    GET_PROC_ADDRESS(FreeItemInfo);
    GET_PROC_ADDRESS(GetThumbnail);
    GET_PROC_ADDRESS(GetItemData);
    GET_PROC_ADDRESS(DeleteItem);
    GET_PROC_ADDRESS(SetItemProt);
    GET_PROC_ADDRESS(TakePicture);
    GET_PROC_ADDRESS(Status);
    GET_PROC_ADDRESS(Reset);

    if (m_pInit) {
        hr = m_pInit(ppDeviceInfo);
    }
    else {
        wiauDbgError("CCamMicro::Init", "m_pInit not initialized");
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}

HRESULT CCamMicro::UnInit(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(UnInit, (pDeviceInfo));
}

HRESULT CCamMicro::Open(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName)
{
    CALL_DLL_FUNCTION(Open, (pDeviceInfo, pwszPortName));
}

HRESULT CCamMicro::Close(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(Close, (pDeviceInfo));
}

HRESULT CCamMicro::GetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList)
{
    CALL_DLL_FUNCTION(GetDeviceInfo, (pDeviceInfo, ppItemList));
}

HRESULT CCamMicro::ReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList)
{
    CALL_DLL_FUNCTION(ReadEvent, (pDeviceInfo, ppEventList));
}

HRESULT CCamMicro::StopEvents(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(StopEvents, (pDeviceInfo));
}

HRESULT CCamMicro::GetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    CALL_DLL_FUNCTION(GetItemInfo, (pDeviceInfo, pItemInfo));
}

HRESULT CCamMicro::FreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    CALL_DLL_FUNCTION(FreeItemInfo, (pDeviceInfo, pItemInfo));
}

HRESULT CCamMicro::GetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb)
{
    CALL_DLL_FUNCTION(GetThumbnail, (pDeviceInfo, pItem, pThumbSize, ppThumb));
}

HRESULT CCamMicro::GetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength)
{
    CALL_DLL_FUNCTION(GetItemData, (pDeviceInfo, pItem, uiState, pBuf, dwLength));
}

HRESULT CCamMicro::DeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    CALL_DLL_FUNCTION(DeleteItem, (pDeviceInfo, pItem));
}

HRESULT CCamMicro::SetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly)
{
    CALL_DLL_FUNCTION(SetItemProt, (pDeviceInfo, pItem, bReadOnly));
}

HRESULT CCamMicro::TakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo)
{
    CALL_DLL_FUNCTION(TakePicture, (pDeviceInfo, ppItemInfo));
}

HRESULT CCamMicro::Status(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(Status, (pDeviceInfo));
}

HRESULT CCamMicro::Reset(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(Reset, (pDeviceInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\pch.h ===
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <objbase.h>

#include <sti.h>
#include <stiusd.h>

#include <wiamindr.h>
#include <wiacammc.h>
#include <wiautil.h>

#include "resource.h"
#include "CCamMicro.h"
#include "wiacam.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample camera IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"

/**************************************************************************\
* CWiaCameraDevice::CWiaCameraDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::CWiaCameraDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    
    m_pIStiDevControl(NULL),
    m_pStiDevice(NULL),
    m_dwLastOperationError(0),
    
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pRootItem(NULL),

    m_lNumSupportedCommands(0),
    m_lNumSupportedEvents(0),
    m_lNumCapabilities(0),
    m_pCapabilities(NULL),

    m_pDevice(NULL),
    m_pDeviceInfo(NULL),

    m_iConnectedApps(0)

{

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*> (static_cast<INonDelegatingUnknown*> (this));
    }
}

/**************************************************************************\
* CWiaCameraDevice::~CWiaCameraDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::~CWiaCameraDevice(void)
{
    HRESULT hr = S_OK;

    //
    // Free all the resources held by the minidriver. Normally this is done by
    // drvUnInitializeWia, but there are situations (like WIA service shutdown) when
    // just this destructor is called
    //
    if (m_pDevice)
    {
        hr = FreeResources();
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "~CWiaCameraDevice", "FreeResources failed, continuing...");

        hr = m_pDevice->UnInit(m_pDeviceInfo);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "~CWiaCameraDevice", "UnInit failed, continuing...");
        }
        m_pDeviceInfo = NULL;

        delete m_pDevice;
        m_pDevice = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }
}

/**************************************************************************\
* CWiaCameraDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    HKEY hkeyDeviceData = NULL;
    TCHAR tszMicroName[MAX_PATH];
    DWORD dwNameSize = sizeof(tszMicroName);

    //
    // Initialize logging
    //
    wiauDbgInit(g_hInst);

    //
    // Check and cache the pointer to the IStiDeviceControl interface
    //
    if (!pIStiDevControl) {
        wiauDbgError("Initialize", "Invalid device control interface");
        return STIERR_INVALID_PARAM;
    }

    pIStiDevControl->AddRef();
    m_pIStiDevControl = pIStiDevControl;

    //
    // Retrieve the port name from the IStiDeviceControl interface
    //
    hr = m_pIStiDevControl->GetMyDevicePortName(m_wszPortName, sizeof(m_wszPortName) / sizeof(m_wszPortName[0]));
    REQUIRE_SUCCESS(hr, "Initialize", "GetMyDevicePortName failed");
    
    //
    // Get the microdriver name from the registry
    //
    hr = wiauRegOpenData(hParametersKey, &hkeyDeviceData);
    REQUIRE_SUCCESS(hr, "Initialize", "wiauRegOpenData failed");

    hr = wiauRegGetStr(hkeyDeviceData, TEXT("MicroDriver"), tszMicroName, &dwNameSize);
    REQUIRE_SUCCESS(hr, "Initialize", "wiauRegGetStr failed");

    //
    // Create the device object
    //
    m_pDevice = new CCamMicro;
    REQUIRE_ALLOC(m_pDevice, hr, "Initialize");

    hr = m_pDevice->Init(tszMicroName, &m_pDeviceInfo);
    REQUIRE_SUCCESS(hr, "Initialize", "Init failed");
    
    //
    // Intialize image format converter
    //
    hr = m_Converter.Init();
    REQUIRE_SUCCESS(hr, "Initialize", "Init failed");
    
Cleanup:
    if (hkeyDeviceData)
        RegCloseKey(hkeyDeviceData);

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    DBG_FN("CWiaCameraDevice::GetCapabilities");

    if (!pUsdCaps)
    {
        wiauDbgError("GetCapabilities", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    DBG_FN("CWiaCameraDevice::GetStatus");

    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    REQUIRE_ARGS(!pDevStatus, hr, "GetStatus");

    //
    // If requested, verify the device is online
    //
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        pDevStatus->dwOnlineState = 0L;

        hr = m_pDevice->Status(m_pDeviceInfo);

        if (hr == S_OK) {
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }

        else if (hr == S_FALSE) {
            hr = S_OK;
        }
        else {
            wiauDbgErrorHr(hr, "GetStatus", "Status failed");
            goto Cleanup;
        }
    }

    //
    // If requested, see if the device has signaled an event.
    // For cameras, there shouldn't be any events.
    //
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {
        pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::DeviceReset(void)
{
    DBG_FN("CWiaCameraDevice::DeviceReset");

    HRESULT hr = S_OK;

    hr = m_pDevice->Reset(m_pDeviceInfo);
    REQUIRE_SUCCESS(hr, "DeviceReset", "Reset failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    DBG_FN("CWiaCameraDevice::Diagnostic");

    if (!pBuffer)
    {
        wiauDbgError("Diagnostic", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // Initialize response buffer
    //
    memset(&pBuffer->sErrorInfo, 0, sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::SetNotificationHandle(HANDLE hEvent)
{
    DBG_FN("CWiaCameraDevice::SetNotificationHandle");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetNotificationData
*
*   Provides data from an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    DBG_FN("CWiaCameraDevice::GetNotificationData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    DBG_FN("CWiaCameraDevice::Escape");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    DBG_FN("CWiaCameraDevice::GetLastError");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pdwLastDeviceError, hr, "GetLastError");

    *pdwLastDeviceError = m_dwLastOperationError;

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    DBG_FN("CWiaCameraDevice::GetLastErrorInfo");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pLastErrorInfo, hr, "GetLastErrorInfo");

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::LockDevice(void)
{
    DBG_FN("CWiaCameraDevice::LockDevice");

    HRESULT hr = S_OK;

    //
    // For devices connected to ports that cannot be shared (e.g. serial),
    // open the device and initialize access to the camera
    //
    if (m_pDeviceInfo->bExclusivePort) {
        hr = m_pDevice->Open(m_pDeviceInfo, m_wszPortName);
        REQUIRE_SUCCESS(hr, "LockDevice", "Open failed");
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::UnLockDevice(void)
{
    DBG_FN("CWiaCameraDevice::UnLockDevice");

    HRESULT hr = S_OK;

    //
    // For devices connected to ports that cannot be shared (e.g. serial),
    // close the device
    //
    if (m_pDeviceInfo->bExclusivePort) {
        hr = m_pDevice->Close(m_pDeviceInfo);
        REQUIRE_SUCCESS(hr, "UnLockDevice", "Close failed");
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawReadData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawWriteData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadCommand
*
*   Read a command from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawReadCommand");

    HRESULT hr = S_OK;

    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteCommand
*
*   Write a command to the device.
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawWriteCommand");

    HRESULT hr = S_OK;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample camera IWiaMiniDrv methods. This file
*   contains 3 sections. The first is the WIA minidriver entry points, all
*   starting with "drv". The next section is public help methods. The last
*   section is private helper methods.
*
*******************************************************************************/

#include "pch.h"

#ifndef INITGUID
#include <initguid.h>
#endif

//
// A few extra format GUIDs
//
DEFINE_GUID(GUID_NULL, 0,0,0,0,0,0,0,0,0,0,0);
DEFINE_GUID(FMT_NOTHING, 0x81a566e7,0x8620,0x4fba,0xbc,0x8e,0xb2,0x7c,0x17,0xad,0x9e,0xfd);

/**************************************************************************\
* CWiaCameraDevice::drvInitializeWia
*
*   Initialize the WIA mini driver. This function will be called each time an
*   application creates a device. The first time through, the driver item tree
*   will be created and other initialization will be done.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvInitializeWia");
    
    if (!ppIUnknownInner || !pIUnknownOuter)
    {
        // optional arguments, may be NULLs
    }

    if (!pWiasContext || !bstrDeviceID || !bstrRootFullItemName || 
        !pStiDevice || !ppIDrvItemRoot || !plDevErrVal)
    {
        wiauDbgError("drvInitializeWia", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    //
    // Locals
    //
    MCAM_ITEM_INFO *pItem = NULL;

    wiauDbgTrace("drvInitializeWia", "device ID: %S", bstrDeviceID);

    *ppIDrvItemRoot = NULL;
    if (ppIUnknownInner)
    {
        *ppIUnknownInner = NULL;
    }

    //
    // Count the number of apps connected so that resources can be
    // freed when it reaches zero
    //
    m_iConnectedApps++;;

    wiauDbgTrace("drvInitializeWia", "Number of connected apps is now %d", m_iConnectedApps);

    if (m_iConnectedApps == 1)
    {
        //
        // Save STI device interface for calling locking functions
        //
        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID
        //
        m_bstrDeviceID = SysAllocString(bstrDeviceID);
        REQUIRE_ALLOC(m_bstrDeviceID, hr, "drvInitializeWia");

        //
        // Cache the root item name
        //
        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);
        REQUIRE_ALLOC(m_bstrRootFullItemName, hr, "drvInitializeWia");

        //
        // For devices connected to ports that can be shared (e.g. USB),
        // open the device and initialize access to the camera
        //
        if (!m_pDeviceInfo->bExclusivePort) {
            hr = m_pDevice->Open(m_pDeviceInfo, m_wszPortName);
            REQUIRE_SUCCESS(hr, "Initialize", "Open failed");
        }

        //
        // Get information from the device
        //
        hr = m_pDevice->GetDeviceInfo(m_pDeviceInfo, &pItem);
        REQUIRE_SUCCESS(hr, "drvInitializeWia", "GetDeviceInfo failed");
        
        //
        // Build the capabilities array
        //
        hr = BuildCapabilities();
        REQUIRE_SUCCESS(hr, "drvInitializeWia", "BuildCapabilities failed");

        //
        //  Build the device item tree
        //
        hr = BuildItemTree(pItem);
        REQUIRE_SUCCESS(hr, "drvInitializeWia", "BuildItemTree failed");

    }

    *ppIDrvItemRoot = m_pRootItem;

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnInitializeWia(BYTE *pWiasContext)
{
    DBG_FN("CWiaCameraDevice::drvUnInitializeWia");

    if (!pWiasContext)
    {
        wiauDbgError("drvUnInitializeWia", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    m_iConnectedApps--;

    if (m_iConnectedApps == 0)
    {
        hr = FreeResources();
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "drvUnInitializeWia", "FreeResources failed, continuing...");

        //
        // Do not delete the device object here, because GetStatus may still be called later.
        //
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree. For the root item, just set the properties already
*   set up in drvInitializeWia. For child items, access the camera for
*   information about the item and for images also get the thumbnail.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvInitItemProperties");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvInitItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    REQUIRE_SUCCESS(hr, "drvInitItemProperties", "wiasGetItemType failed");

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildRootItemProperties(pWiasContext);
        REQUIRE_SUCCESS(hr, "drvInitItemProperties", "BuildRootItemProperties failed");
    }

    else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildChildItemProperties(pWiasContext);
        REQUIRE_SUCCESS(hr, "drvInitItemProperties", "BuildChildItemProperties failed");
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvLockWiaDevice");

    if (!plDevErrVal)
    {
        wiauDbgError("drvLockWiaDevice", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    return m_pStiDevice->LockDevice(100);
}

/**************************************************************************\
* CWiaCameraDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvUnLockWiaDevice");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvUnLockWiaDevice", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWiaCameraDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvFreeDrvItemContext");

    if (!pSpecContext || !plDevErrVal)
    {
        wiauDbgError("drvFreeDrvItemContext", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    ITEM_CONTEXT *pItemCtx = (ITEM_CONTEXT *) pSpecContext;
    
    if (pItemCtx)
    {
        if (pItemCtx->pItemInfo) {
            hr = m_pDevice->FreeItemInfo(m_pDeviceInfo, pItemCtx->pItemInfo);
            if (FAILED(hr))
                wiauDbgErrorHr(hr, "drvFreeDrvItemContext", "FreeItemInfo failed");
        }
        pItemCtx->pItemInfo = NULL;

        if (pItemCtx->pFormatInfo)
        {
            delete []pItemCtx->pFormatInfo;
            pItemCtx->pFormatInfo = NULL;
        }
        pItemCtx->lNumFormatInfo = 0;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvReadItemProperties");

    if (!pWiasContext || !pPropSpec || !plDevErrVal)
    {
        wiauDbgError("drvReadItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    REQUIRE_SUCCESS(hr, "drvReadItemProperties", "wiasGetItemType failed");

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadRootItemProperties(pWiasContext, nPropSpec, pPropSpec);
        REQUIRE_SUCCESS(hr, "drvReadItemProperties", "ReadRootItemProperties failed");
    }
    
    else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadChildItemProperties(pWiasContext, nPropSpec, pPropSpec);
        REQUIRE_SUCCESS(hr, "drvReadItemProperties", "ReadChildItemProperties failed");
    }
    
Cleanup:    
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvWriteItemProperties");

    if (!pWiasContext || !pmdtc || !plDevErrVal)
    {
        wiauDbgError("drvWriteItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // This function doesn't need to do anything, because all of the camera
    // properties are written in drvValidateItemProperties
    //

    *plDevErrVal = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAcquireItemData
*
*   Transfer data from a mini driver item to device manger.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvAcquireItemData");
    
    if (!pWiasContext || !plDevErrVal || !pmdtc)
    {
        wiauDbgError("drvAcquireItemData", "invalid arguments");  
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;
    
    //
    // Locals
    //
    BYTE *pTempBuf = NULL;
    LONG lBufSize = 0;
    ITEM_CONTEXT *pItemCtx = NULL;
    BOOL bConvert = FALSE;

    //
    // Get item context
    //
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
    REQUIRE_SUCCESS(hr, "drvAcquireItemData", "wiauGetDrvItemContext failed");

    //
    // If the format requested is BMP or DIB, and the image is not already in BMP
    // format, convert it
    //
    bConvert = (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
                IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) &&
               !IsEqualGUID(*(pItemCtx->pItemInfo->pguidFormat), WiaImgFmt_BMP);

    //
    // If the class driver did not allocate the transfer buffer or the image is being
    // converted to DIB or BMP, allocate a temporary buffer.
    //
    if (bConvert || !pmdtc->bClassDrvAllocBuf) {
        lBufSize = pItemCtx->pItemInfo->lSize;
        pTempBuf = new BYTE[lBufSize];
        REQUIRE_ALLOC(pTempBuf, hr, "drvAcquireItemData");
    }

    //
    // Acquire the data from the device
    //
    hr = AcquireData(pItemCtx, pmdtc, pTempBuf, lBufSize, bConvert);
    REQUIRE_SUCCESS(hr, "drvAcquireItemData", "AcquireData failed");
    if (hr == S_FALSE)
    {
        wiauDbgWarning("drvAcquireItemData", "Transfer cancelled");
        goto Cleanup;
    }

    //
    // Now convert the data to BMP, if necessary
    //
    if (bConvert)
    {
        hr = Convert(pWiasContext, pItemCtx, pmdtc, pTempBuf, lBufSize);
        REQUIRE_SUCCESS(hr, "drvAcquireItemData", "Convert failed");
    }

Cleanup:
    if (pTempBuf)
    {
        delete []pTempBuf;
        pTempBuf = NULL;
        lBufSize = 0;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvGetWiaFormatInfo");
    
    if (!pWiasContext || !pcelt || !ppwfi || !plDevErrVal)
    {
        wiauDbgError("drvGetWiaFormatInfo", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Locals
    //
    IWiaDrvItem *pWiaDrvItem = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;
    const GUID *pguidFormat = NULL;
    BOOL bAddBmp = FALSE;

    *pcelt = 0;
    *ppwfi = NULL;
    
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx, &pWiaDrvItem);
    REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiauGetDrvItemContext failed");
    
    if (!pItemCtx->pFormatInfo)
    {
        //
        // The format info list is not intialized. Do it now.
        //
        LONG ItemType;
        DWORD ui32;
        
        hr = wiasGetItemType(pWiasContext, &ItemType);
        REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiasGetItemType");

        if ((ItemType & WiaItemTypeFolder) ||
            (ItemType & WiaItemTypeRoot))
        {
            //
            // Folders and the root don't really need format info, but some apps may fail
            // without it. Create a fake list just in case.
            //
            pItemCtx->pFormatInfo = new WIA_FORMAT_INFO[2];
            REQUIRE_ALLOC(pItemCtx->pFormatInfo, hr, "drvGetWiaFormatInfo");

            pItemCtx->lNumFormatInfo = 2;
            pItemCtx->pFormatInfo[0].lTymed = TYMED_FILE;
            pItemCtx->pFormatInfo[0].guidFormatID = FMT_NOTHING;
            pItemCtx->pFormatInfo[1].lTymed = TYMED_CALLBACK;
            pItemCtx->pFormatInfo[1].guidFormatID = FMT_NOTHING;
        }
        
        else if (ItemType & WiaItemTypeFile)
        {
            //
            // Create the supported format for the item, based on the format stored in the
            // ObjectInfo structure.
            //
            if (!pItemCtx->pItemInfo)
            {
                wiauDbgError("drvGetWiaFormatInfo", "Item info pointer in context is null");
                hr = E_FAIL;
                goto Cleanup;
            }

            pguidFormat = pItemCtx->pItemInfo->pguidFormat;

            //
            // If the format of the item is supported by the converter utility, add the
            // BMP types to the format array, since this driver can convert those to BMP
            //
            bAddBmp = m_Converter.IsFormatSupported(pguidFormat);

            ULONG NumWfi = bAddBmp ? 2 : 1;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            WIA_FORMAT_INFO *pwfi = new WIA_FORMAT_INFO[2 * NumWfi];
            REQUIRE_ALLOC(pwfi, hr, "drvGetWiaFormatInfo");

            pwfi[0].guidFormatID = *pguidFormat;
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].guidFormatID = *pguidFormat;
            pwfi[1].lTymed = TYMED_CALLBACK;

            //
            // Add the BMP entries when appropriate
            //
            if (bAddBmp)
            {
                pwfi[2].guidFormatID = WiaImgFmt_BMP;
                pwfi[2].lTymed = TYMED_FILE;
                pwfi[3].guidFormatID = WiaImgFmt_MEMORYBMP;
                pwfi[3].lTymed = TYMED_CALLBACK;
            }

            pItemCtx->lNumFormatInfo = 2 * NumWfi;
            pItemCtx->pFormatInfo = pwfi;
        }
    }

    *pcelt = pItemCtx->lNumFormatInfo;
    *ppwfi = pItemCtx->pFormatInfo;

Cleanup:    
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
***************************************************************************/

HRESULT CWiaCameraDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvValidateItemProperties");

    if (!pWiasContext || !pPropSpec || !plDevErrVal)
    {
        wiauDbgError("drvValidateItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Locals
    //
    LONG lItemType  = 0;
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pItemInfo = NULL;
    BOOL bFormatUpdated = FALSE;
    LONG lRights = 0;
    BOOL bReadOnly = 0;

    //
    // Have the service validate against the valid values for each property
    //
    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
    REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasValidateItemProperties failed");

    //
    // Get the item type
    //
    hr = wiasGetItemType(pWiasContext, &lItemType);
    REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasGetItemType");

    //
    // Validate root item properties
    //
    if (lItemType & WiaItemTypeRoot) {

        //
        // None yet
        //
    }
    
    //
    // Validate child item properties
    //
    else {

        //
        // Get the driver item context and item info pointer
        //
        hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
        REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiauGetDrvItemContext failed");

        pItemInfo = pItemCtx->pItemInfo;

        //
        // See if access rights were changed
        //
        if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_ACCESS_RIGHTS))
        {
            hr = wiasReadPropLong(pWiasContext, WIA_IPA_ACCESS_RIGHTS, &lRights, NULL, TRUE);
            REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasReadPropLong failed");

            bReadOnly = (lRights == WIA_ITEM_READ);
            hr = m_pDevice->SetItemProt(m_pDeviceInfo, pItemInfo, bReadOnly);
            REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "SetItemProt failed");
            pItemInfo->bReadOnly = bReadOnly;
        }

        //
        // If tymed property was changed, update format and item size
        //
        if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_TYMED)) {

            //
            // Create a property context needed by some WIA Service
            // functions used below.
            //
            WIA_PROPERTY_CONTEXT Context;
            hr = wiasCreatePropContext(nPropSpec, (PROPSPEC*)pPropSpec, 0,
                                       NULL, &Context);
            REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasCreatePropContext failed");

            //
            // Use the WIA Service to update the valid values
            // for format. It will pull the values from the
            // structure returned by drvGetWiaFormatInfo, using the
            // new value for tymed.
            //
            hr = wiasUpdateValidFormat(pWiasContext, &Context, (IWiaMiniDrv*) this);
            REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiasUpdateValidFormat failed");

            //
            // Free the property context
            //
            hr = wiasFreePropContext(&Context);
            REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiasFreePropContext failed");

            //
            // The format may have changed, so update the properties
            // dependent on format
            //
            bFormatUpdated = TRUE;
        }

        //
        // If the format was changed, just update the item size
        //
        if (bFormatUpdated || wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_FORMAT))
        {
            //
            //  Update the affected item properties
            //
            hr = wiauSetImageItemSize(pWiasContext, pItemInfo->lWidth, pItemInfo->lHeight,
                                      pItemInfo->lDepth, pItemInfo->lSize, pItemInfo->wszExt);
            REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiauSetImageItemSize failed");
        }
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeleteItem
*
*   Delete an item from the device.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvDeleteItem");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvDeleteItem", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Locals
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    IWiaDrvItem *pDrvItem = NULL;
    BSTR bstrFullName = NULL;

    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx, &pDrvItem);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "wiauGetDrvItemContext failed");
    
    hr = m_pDevice->DeleteItem(m_pDeviceInfo, pItemCtx->pItemInfo);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "DeleteItem failed");

    //
    // Get the item's full name
    //
    hr = pDrvItem->GetFullItemName(&bstrFullName);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "GetFullItemName failed");

    //
    // Queue an "item deleted" event
    //
    hr = wiasQueueEvent(m_bstrDeviceID, &WIA_EVENT_ITEM_DELETED, bstrFullName);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "wiasQueueEvent failed");

Cleanup:
    if (bstrFullName)
        SysFreeString(bstrFullName);

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    DBG_FN("CWiaCameraDevice::DrvNotifyPnpEvent");
    if (!pEventGUID)
    {
        wiauDbgError("drvNotifyPnpEvent", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvGetCapabilites");

    if (!pWiasContext)
    {
        //
        // The WIA service may pass in a NULL for the pWiasContext. This is expected
        // because there is a case where no item was created at the time the event was fired.
        //
    }

    if (!pcelt || !ppCapabilities || !plDevErrVal)
    {
        wiauDbgError("drvGetCapabilities", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    //
    //  Return values depend on the passed flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    if (ulFlags & (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS)) {

        //
        //  Return both events and commands
        //
        *pcelt          = m_lNumCapabilities;
        *ppCapabilities = m_pCapabilities;
    }
    else if (ulFlags & WIA_DEVICE_COMMANDS) {

        //
        //  Return commands only
        //
        *pcelt          = m_lNumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_lNumSupportedEvents];
    }
    else if (ulFlags & WIA_DEVICE_EVENTS) {

        //
        //  Return events only
        //
        *pcelt          = m_lNumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
    }

    return S_OK;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvDeviceCommand");

    if (!pWiasContext || !plCommand || !ppWiaDrvItem || !plDevErrVal)
    {
        wiauDbgError("drvDeviceCommand", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    //
    // Locals
    //
    MCAM_ITEM_INFO *pItem = NULL;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Re-build the item tree, if the device needs it.
        //
        if (m_pDeviceInfo->bSyncNeeded)
        {
            hr = m_pDevice->StopEvents(m_pDeviceInfo);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "StopEvents failed");

            hr = DeleteItemTree(WiaItemTypeDisconnected);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "DeleteItemTree failed");

            hr = m_pDevice->GetDeviceInfo(m_pDeviceInfo, &pItem);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "GetDeviceInfo failed");

            hr = BuildItemTree(pItem);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "BuildItemTree failed");
        }
    }
    
#if DEADCODE
    
    //
    // Not implemented yet
    //
    else if (*plCommand == WIA_CMD_TAKE_PICTURE) {

        //
        // TAKE_PICTURE - Command the camera to capture a new image.
        //
        hr = m_pDevice->TakePicture(&pItem);
        REQUIRE_SUCCESS(hr, "drvDeviceCommand", "TakePicture failed");

        hr = AddObject(pItem);
        REQUIRE_SUCCESS(hr, "drvDeviceCommand", "AddObject failed");

        hr = LinkToParent(pItem);
        REQUIRE_SUCCESS(hr, "drvDeviceCommand", "LinkToParent failed");
    }
#endif
    
    else {
        wiauDbgWarning("drvDeviceCommand", "Unknown command 0x%08x", *plCommand);
        hr = E_NOTIMPL;
        goto Cleanup;
    }

Cleanup:    
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvAnalyzeItem");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvAnalyzeItem", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    DBG_FN("CWiaCameraDevice::drvGetDeviceErrorStr");

    if (!ppszDevErrStr || !plDevErr)
    {
        wiauDbgError("drvGetDeviceErrorStr", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErr  = 0;

    //
    //  Map device errors to a string appropriate for showing to the user
    //

    switch (lDevErrVal) {
        case 0:
            *ppszDevErrStr = NULL;
            break;

        default:
            *ppszDevErrStr = NULL;
            hr = E_FAIL;
    }

    return hr;
}

/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* FreeResources
*
*   Cleans up all of the resources held by the driver.
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::FreeResources()
{
    DBG_FN("CWiaCameraDevice::FreeResources");

    HRESULT hr = S_OK;

    wiauDbgTrace("FreeResources", "Connected apps is now zero, freeing resources...");

    hr = m_pDevice->StopEvents(m_pDeviceInfo);
    if (FAILED(hr))
        wiauDbgErrorHr(hr, "FreeResources", "StopEvents failed");

    // Destroy the driver item tree
    hr = DeleteItemTree(WiaItemTypeDisconnected);
    if (FAILED(hr))
        wiauDbgErrorHr(hr, "FreeResources", "UnlinkItemTree failed");

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();

    //
    // For devices connected to ports that can be shared (e.g. USB),
    // close the device
    //
    if (m_pDeviceInfo && !m_pDeviceInfo->bExclusivePort) {
        hr = m_pDevice->Close(m_pDeviceInfo);
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "FreeResources", "Close failed");
    }

    // Free the storage for the device ID
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Free the storage for the root item name
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

/*
    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }


    //
    // WIA member destruction
    //

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

*/

    return hr;
}

/**************************************************************************\
* DeleteItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::DeleteItemTree(LONG lReason)
{
    DBG_FN("CWiaCameraDevice::DeleteItemTree");

    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pRootItem)
        goto Cleanup;

    //
    //  Call device manager to unlink the driver item tree.
    //
    hr = m_pRootItem->UnlinkItemTree(lReason);
    REQUIRE_SUCCESS(hr, "DeleteItemTree", "UnlinkItemTree failed");

    m_pRootItem->Release();
    m_pRootItem = NULL;

Cleanup:
    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildItemTree(MCAM_ITEM_INFO *pItem)
{
    DBG_FN("CWiaCameraDevice::BuildItemTree");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    BSTR bstrRoot = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pCurItem = NULL;

    //
    // Make sure the item tree doesn't already exist
    //
    if (m_pRootItem)
    {
        wiauDbgError("BuildItemTree", "Item tree already exists");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Create the root item name
    //
    bstrRoot = SysAllocString(L"Root");
    REQUIRE_ALLOC(bstrRoot, hr, "BuildItemTree");

    //
    //  Create the root item
    //
    hr = wiasCreateDrvItem(WiaItemTypeFolder | WiaItemTypeDevice | WiaItemTypeRoot,
                           bstrRoot,
                           m_bstrRootFullItemName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &m_pRootItem);
    REQUIRE_SUCCESS(hr, "BuildItemTree", "wiasCreateDrvItem failed");

    //
    // Initialize item context fields for the root
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));

    //
    // Create a driver item for each item on the camera
    //
    pCurItem = pItem;
    while (pCurItem) {

        hr = AddObject(pCurItem);
        REQUIRE_SUCCESS(hr, "BuildItemTree", "AddObject failed");

        pCurItem = pCurItem->pNext;
    }

    //
    // Link each item to its parent
    //
    pCurItem = pItem;
    while (pCurItem) {

        hr = LinkToParent(pCurItem);
        REQUIRE_SUCCESS(hr, "BuildItemTree", "LinkToParent failed");

        pCurItem = pCurItem->pNext;
    }

Cleanup:
    if (bstrRoot)
        SysFreeString(bstrRoot);

    return hr;
}

/**************************************************************************\
* AddObject
*
*   Helper function to add an item to the driver item tree
*
* Arguments:
*
*    pItemInfo - Pointer to the item info structure
*
\**************************************************************************/

HRESULT CWiaCameraDevice::AddObject(MCAM_ITEM_INFO *pItemInfo)
{
    DBG_FN("CWiaCameraDevice::AddObject");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG lItemType = 0;
    BSTR bstrItemFullName = NULL;
    BSTR bstrItemName = NULL;
    WCHAR wszTemp[MAX_PATH];
    IWiaDrvItem *pItem = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;

    REQUIRE_ARGS(!pItemInfo, hr, "AddObject");

    //
    // Create the item's full name
    //
    hr = ConstructFullName(pItemInfo, wszTemp, sizeof(wszTemp) / sizeof(wszTemp[0]));
    REQUIRE_SUCCESS(hr, "AddObject", "ConstructFullName failed");

    wiauDbgTrace("AddObject", "Adding item %S", wszTemp);

    bstrItemFullName = SysAllocString(wszTemp);
    REQUIRE_ALLOC(bstrItemFullName, hr, "AddObject");

    bstrItemName = SysAllocString(pItemInfo->pwszName);
    REQUIRE_ALLOC(bstrItemName, hr, "AddObject");

    //
    // Make sure there is no filename extension in the name
    //
    if (wcschr(bstrItemFullName, L'.'))
    {
        wiauDbgError("AddObject", "Item names must not contain filename extensions");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Set the item's type
    //
    switch (pItemInfo->iType) {
    case WiaMCamTypeFolder:
        lItemType = ITEMTYPE_FOLDER;
        break;
    case WiaMCamTypeImage:
        lItemType = ITEMTYPE_IMAGE;
        break;
    case WiaMCamTypeAudio:
        lItemType = ITEMTYPE_AUDIO;
        break;
    case WiaMCamTypeVideo:
        lItemType = ITEMTYPE_VIDEO;
        break;
    default:
        lItemType = ITEMTYPE_FILE;
        break;
    }

    //
    // See if the item has attachments
    //
    if (pItemInfo->bHasAttachments)
        lItemType |= WiaItemTypeHasAttachments;

    //
    // Create the driver item
    //
    hr = wiasCreateDrvItem(lItemType,
                           bstrItemName,
                           bstrItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &pItem);

    REQUIRE_SUCCESS(hr, "AddObject", "wiasCreateDrvItem failed");

    //
    // Fill in the driver item context. Wait until the thumbnail is requested before
    // reading it in.
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));
    pItemCtx->pItemInfo = pItemInfo;

    //
    // Put a pointer to the driver item in the item info structure
    //
    pItemInfo->pDrvItem = pItem;

Cleanup:
    if (bstrItemFullName)
        SysFreeString(bstrItemFullName);

    if (bstrItemName)
        SysFreeString(bstrItemName);

    return hr;
}

/**************************************************************************\
* ConstructFullName
*
*   Helper function for creating the item's full name
*
* Arguments:
*
*    pItemInfo       - Pointer to the item info structure
*    pwszFullName    - Pointer to area to construct name
*    cchFullNameSize - size (in characters) of buffer provided in pwszFullName 
*
\**************************************************************************/

HRESULT CWiaCameraDevice::ConstructFullName(MCAM_ITEM_INFO *pItemInfo, 
                                            WCHAR *pwszFullName, 
                                            INT cchFullNameSize)
{
    DBG_FN("CWiaCameraDevice::ConstructFullName");
    HRESULT hr = S_OK;

    if (!pItemInfo) 
    {
        wiauDbgError("ConstructFullName", "pItemInfo arg is NULL");
        return E_INVALIDARG;
    }

    if (pItemInfo->pParent) 
    {
        hr = ConstructFullName(pItemInfo->pParent, pwszFullName, cchFullNameSize);
    }
    else 
    {
        if (lstrlenW(m_bstrRootFullItemName) < cchFullNameSize)
        {
            lstrcpyW(pwszFullName, m_bstrRootFullItemName);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr) && pItemInfo->pwszName) 
    {
        //
        // Verify that buffer is big enough to accommodate both strings + "\" + terminating zero
        //
        if (lstrlenW(pwszFullName) + lstrlenW(pItemInfo->pwszName) + 2 <= cchFullNameSize)
        {
            lstrcatW(pwszFullName, L"\\");
            lstrcatW(pwszFullName, pItemInfo->pwszName);
        }
        else
        {
            hr = E_FAIL; // buffer is not big enough
        }
    }

    return hr;
}

/**************************************************************************\
* LinkToParent
*
*   Helper function to link an item to its parent in the item tree
*
* Arguments:
*
*    pItemInfo   - Pointer to the item info structure
*    bQueueEvent - Indicates whether to queue an WIA event
*
\**************************************************************************/

HRESULT CWiaCameraDevice::LinkToParent(MCAM_ITEM_INFO *pItemInfo, BOOL bQueueEvent)
{
    DBG_FN("CWiaCameraDevice::LinkToParent");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    IWiaDrvItem *pParentDrvItem = NULL;
    IWiaDrvItem *pItem = NULL;
    BSTR bstrItemFullName = NULL;

    REQUIRE_ARGS(!pItemInfo, hr, "LinkToParent");

    //
    // Retrieve the driver item and make sure it's not null
    //
    pItem = pItemInfo->pDrvItem;
    if (!pItem) {
        wiauDbgError("LinkToParent", "Driver item pointer is null");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Find the item's parent driver item object
    //
    if (pItemInfo->pParent) {
        pParentDrvItem = pItemInfo->pParent->pDrvItem;
    }
    else {
        //
        // If the parent pointer is null, use the root as the parent
        //
        pParentDrvItem = m_pRootItem;
    }

    //
    // The driver item should exist for the parent, but just make sure
    //
    if (!pParentDrvItem) {
        wiauDbgError("LinkToParent", "Parent driver item is null");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Place the item under it's parent
    //
    hr = pItem->AddItemToFolder(pParentDrvItem);
    REQUIRE_SUCCESS(hr, "LinkToParent", "AddItemToFolder failed");

    //
    // The minidriver doesn't need the driver item pointer any more, so release it.
    // The service will still keep a reference until the item is deleted.
    //
    pItem->Release();

    //
    // Post an item added event, if requested
    //
    if (bQueueEvent)
    {
        hr = pItem->GetFullItemName(&bstrItemFullName);
        REQUIRE_SUCCESS(hr, "LinkToParent", "GetFullItemName failed");
        
        hr = wiasQueueEvent(m_bstrDeviceID, &WIA_EVENT_ITEM_CREATED, bstrItemFullName);
        REQUIRE_SUCCESS(hr, "LinkToParent", "wiasQueueEvent failed");
    }

Cleanup:
    if (bstrItemFullName)
        SysFreeString(bstrItemFullName);

    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string with CoTaskMemFree)
*
* Return Value:
*
*    Status
*
\**************************************************************************/
HRESULT CWiaCameraDevice::GetOLESTRResourceString(LONG lResourceID, LPOLESTR *ppsz)
{
    DBG_FN("GetOLESTRResourceString");
    if (!ppsz)
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = S_OK;
    TCHAR tszStringValue[255];

    if (LoadString(g_hInst, lResourceID, tszStringValue, 255) == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

#ifdef UNICODE
    //
    // just allocate memory and copy string
    //
    *ppsz = NULL;
    *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(tszStringValue));
    if (*ppsz != NULL) 
    {
        wcscpy(*ppsz, tszStringValue);
    } 
    else 
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#else
    WCHAR wszStringValue[255];

    //
    // convert szStringValue from char* to unsigned short* (ANSI only)
    //
    if (!MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             tszStringValue,
                             lstrlenA(tszStringValue)+1,
                             wszStringValue,
                             (sizeof(wszStringValue)/sizeof(wszStringValue[0]))))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    *ppsz = NULL;
    *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
    if (*ppsz != NULL) 
    {
        wcscpy(*ppsz,wszStringValue);
    } 
    else 
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
#endif

Cleanup:
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildCapabilities()
{
    DBG_FN("BuildCapabilities");
    
    HRESULT hr = S_OK;

    if (m_pCapabilities != NULL) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_lNumSupportedCommands  = 1;
    m_lNumSupportedEvents    = 2;
    m_lNumCapabilities       = (m_lNumSupportedCommands + m_lNumSupportedEvents);


    m_pCapabilities = new WIA_DEV_CAP_DRV[m_lNumCapabilities];
    REQUIRE_ALLOC(m_pCapabilities, hr, "BuildCapabilities");

    //
    // Initialize EVENTS
    //

    //
    // WIA_EVENT_DEVICE_CONNECTED
    //
    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME, &m_pCapabilities[0].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC, &m_pCapabilities[0].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[0].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
    m_pCapabilities[0].ulFlags        = WIA_NOTIFICATION_EVENT;
    m_pCapabilities[0].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

    //
    // WIA_EVENT_DEVICE_DISCONNECTED
    //
    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME, &m_pCapabilities[1].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC, &m_pCapabilities[1].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[1].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
    m_pCapabilities[1].ulFlags        = WIA_NOTIFICATION_EVENT;
    m_pCapabilities[1].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

    //
    // Initialize COMMANDS
    //

    //
    // WIA_CMD_SYNCHRONIZE
    //
    hr = GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME, &m_pCapabilities[2].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC, &m_pCapabilities[2].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[2].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
    m_pCapabilities[2].ulFlags        = 0;
    m_pCapabilities[2].wszIcon        = WIA_ICON_SYNCHRONIZE;

Cleanup:
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::DeleteCapabilitiesArrayContents()
{
    DBG_FN("DeleteCapabilitiesArrayContents");
    
    HRESULT hr = S_OK;

    if (m_pCapabilities) {
        for (LONG i = 0; i < m_lNumCapabilities; i++) 
        {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }

        delete []m_pCapabilities;
        m_pCapabilities = NULL;
    }

    m_lNumSupportedCommands = 0;
    m_lNumSupportedEvents = 0;
    m_lNumCapabilities = 0;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\root.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       Root.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for the root item.
*
*******************************************************************************/

#include "pch.h"

/**************************************************************************\
* BuildRootItemProperties
*
*   Create the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildRootItemProperties(
    BYTE *pWiasContext
    )
{
    DBG_FN("CWiaCameraDevice::BuildRootItemProperties");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    BSTR bstrFirmwareVer = NULL;

    //
    // Create a WIA property list and allocate enough space for all
    // the properties created below
    //
    CWiauPropertyList RootProps;

    hr = RootProps.Init(50);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "Init property list failed");

    //
    // These are the WHQL required properties for cameras:
    //
    INT index;

    hr = RootProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, (LONG) WIA_ITEM_READ | WIA_ITEM_WRITE);

    if (m_pDeviceInfo->pwszFirmwareVer) {
        hr = RootProps.DefineProperty(&index, WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
        bstrFirmwareVer = SysAllocString(m_pDeviceInfo->pwszFirmwareVer);
        REQUIRE_ALLOC(bstrFirmwareVer, hr, "BuildRootItemProperties");
        RootProps.SetCurrentValue(index, bstrFirmwareVer);
    }

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, m_pDeviceInfo->lPicturesTaken);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, m_pDeviceInfo->lPicturesRemaining);

    //
    // These are WHQL optional properties
    //

    hr = RootProps.DefineProperty(&index, WIA_DPA_DEVICE_TIME, WIA_DPA_DEVICE_TIME_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, &m_pDeviceInfo->Time);


#if DEADCODE
    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_MODE, WIA_DPC_EXPOSURE_MODE_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureMode);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_COMP, WIA_DPC_EXPOSURE_COMP_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureComp);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_TIME, WIA_DPC_EXPOSURE_TIME_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureTime);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FNUMBER, WIA_DPC_FNUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FLASH_MODE, WIA_DPC_FLASH_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FlashMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_MODE, WIA_DPC_FOCUS_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocusMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PAN_POSITION, WIA_DPC_PAN_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PanPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TILT_POSITION, WIA_DPC_TILT_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TiltPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_MODE, WIA_DPC_TIMER_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TimerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_VALUE, WIA_DPC_TIMER_VALUE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TimerValue);

    hr = RootProps.DefineProperty(&index, WIA_DPC_POWER_MODE, WIA_DPC_POWER_MODE_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PowerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BATTERY_STATUS, WIA_DPC_BATTERY_STATUS_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.BatteryStatus);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_WIDTH, WIA_DPC_THUMB_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ThumbWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_HEIGHT, WIA_DPC_THUMB_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ThumbHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PictWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PictHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_COMPRESSION_SETTING, WIA_DPC_COMPRESSION_SETTING_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.CompressionSetting);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMELAPSE_INTERVAL, WIA_DPC_TIMELAPSE_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TimelapseInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_INTERVAL, WIA_DPC_BURST_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.BurstInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_NUMBER, WIA_DPC_BURST_NUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.BurstNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EFFECT_MODE, WIA_DPC_EFFECT_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.EffectMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_DIGITAL_ZOOM, WIA_DPC_DIGITAL_ZOOM_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.DigitalZoom);

    hr = RootProps.DefineProperty(&index, WIA_DPC_SHARPNESS, WIA_DPC_SHARPNESS_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.Sharpness);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CONTRAST, WIA_DPC_CONTRAST_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.Constrast);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_MODE, WIA_DPC_CAPTURE_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.CaptureMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_DELAY, WIA_DPC_CAPTURE_DELAY_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.CaptureDelay);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_INDEX, WIA_DPC_EXPOSURE_INDEX_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureIndex);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_METERING_MODE, WIA_DPC_EXPOSURE_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_METERING_MODE, WIA_DPC_FOCUS_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocusMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_DISTANCE, WIA_DPC_FOCUS_DISTANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocusDistance);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCAL_LENGTH, WIA_DPC_FOCAL_LENGTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocalLength);

    hr = RootProps.DefineProperty(&index, WIA_DPC_RGBGAIN, WIA_DPC_RGBGAIN_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.RGBGain);

    hr = RootProps.DefineProperty(&index, WIA_DPC_WHITE_BALANCE, WIA_DPC_WHITE_BALANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.WhiteBalance);

#endif // DEADCODE

    //
    // TODO: Add other optional properties that your device supports here
    //


    // Last step: send all the properties to WIA

    hr = RootProps.SendToWia(pWiasContext);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "SendToWia failed");

Cleanup:
    if (bstrFirmwareVer)
        SysFreeString(bstrFirmwareVer);
    return hr;
}

/**************************************************************************\
* ReadRootItemProperties
*
*   Update the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::ReadRootItemProperties(
    BYTE           *pWiasContext,
    LONG            NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaCameraDevice::ReadRootItemProperties");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!NumPropSpecs || !pPropSpecs, hr, "ReadRootItemProperties");

    //
    // Loop through all of the PropSpecs
    //
    for (int count = 0; count < NumPropSpecs; count++)
    {
        PROPID propId = pPropSpecs[count].propid;
        
        switch (propId)
        {
        case WIA_DPC_PICTURES_TAKEN:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, m_pDeviceInfo->lPicturesTaken);
            break;

        case WIA_DPC_PICTURES_REMAINING:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_REMAINING, m_pDeviceInfo->lPicturesRemaining);
            break;

        default:
            break;
        }
        
        REQUIRE_SUCCESS(hr, "ReadRootItemProperties", "wiasWritePropLong failed");
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\wiacam.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiacam.cpp
*
*  VERSION:     1.0
*
*  DATE:        16 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA Sample camera class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#ifndef INITGUID
#include <initguid.h>
#endif

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

HINSTANCE g_hInst;  // DLL module instance.

//
// This clsid will eventually be in uuid.lib, at which point it should be removed
// from here.
//
// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

//
// Class ID for this WIA minidriver. Change this GUID here and in the
// INF for your driver.
//
DEFINE_GUID(CLSID_SampleWIACameraDevice, 
            0x8e3f2bae, 0xc8ff, 0x4eff, 0xaa, 0xbd, 0xc, 0x58, 0x69, 0x53, 0x89, 0xe8);


/**************************************************************************\
* CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
{
    // Destructor logic
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::AddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::Release(void)
{
    ULONG ulRef = 0;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    HRESULT hr = S_OK;
    CWiaCameraDevice   *pDev = NULL;

    pDev = new CWiaCameraDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hr = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hr;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hr =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hr)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingRelease(void)
{
    ULONG ulRef = 0;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWiaCameraDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWiaCameraDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWiaCameraDevice::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            
            break;

        case DLL_PROCESS_DETACH:
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if (!IsEqualCLSID(rclsid, CLSID_SampleWIACameraDevice) ) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return E_NOINTERFACE;
    }

    if (IsEqualCLSID(rclsid, CLSID_SampleWIACameraDevice)) {
        CWiaCameraDeviceClassFactory *pcf = new CWiaCameraDeviceClassFactory;
        if (!pcf) {
            return E_OUTOFMEMORY;
        }
        *ppv = (LPVOID)pcf;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\child.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       Child.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for child items.
*
*******************************************************************************/

#include "pch.h"


/**************************************************************************\
* BuildChildItemProperties
*
*   This helper creates the properties for a child item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildChildItemProperties(
    BYTE *pWiasContext
    )
{
    DBG_FN("CWiaCameraDevice::BuildChildItemProperties");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pItemInfo = NULL;
    CWiauPropertyList ItemProps;
    const INT NUM_ITEM_PROPS = 20;  // Make sure this number is large
                                    // enough to hold all child properties
    INT index = 0;
    LONG lAccessRights = 0;
    BOOL bBitmap = FALSE;
    LONG pTymedArray[] = { TYMED_FILE, TYMED_CALLBACK };
    int iNumFormats = 0;
    GUID *pguidFormatArray = NULL;
    BSTR bstrExtension = NULL;
    LONG lMinBufSize = 0;

    //
    // Get the driver item context
    //
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "GetDrvItemContext failed");

    pItemInfo = pItemCtx->pItemInfo;

    //
    // Call the microdriver to fill in information about the item
    //
    hr = m_pDevice->GetItemInfo(m_pDeviceInfo, pItemInfo);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "GetItemInfo failed");

    //
    // Set up properties that are used for all item types
    //
    hr = ItemProps.Init(NUM_ITEM_PROPS);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "Init property list failed");

    //
    // WIA_IPA_ITEM_TIME
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

    ItemProps.SetCurrentValue(index, &pItemInfo->Time);

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_FLAG);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

    //
    // If device supports changing the read-only status, item access rights is r/w
    //
    lAccessRights = pItemInfo->bReadOnly ? WIA_ITEM_READ : WIA_ITEM_RD;

    if (pItemInfo->bCanSetReadOnly)
    {
        ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_FLAG);
        ItemProps.SetValidValues(index, lAccessRights, lAccessRights, WIA_ITEM_RD);
    }
    else
    {
        ItemProps.SetCurrentValue(index, lAccessRights);
    }

    if (pItemInfo->iType == WiaMCamTypeUndef) {
        wiauDbgWarning("BuildChildItemProperties", "Item's type is undefined");
    }
    
    //
    // Set up non-folder properties
    //
    else if (pItemInfo->iType != WiaMCamTypeFolder) {
    
        //
        // WIA_IPA_PREFERRED_FORMAT
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
        ItemProps.SetCurrentValue(index, (GUID *) pItemInfo->pguidFormat);

        bBitmap = IsEqualGUID(WiaImgFmt_BMP, *pItemInfo->pguidFormat);

        //
        // WIA_IPA_TYMED
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_TYMED, WIA_IPA_TYMED_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
        ItemProps.SetValidValues(index, TYMED_FILE, TYMED_FILE,
                                 sizeof(pTymedArray) / sizeof(pTymedArray[0]), pTymedArray);

        //
        // WIA_IPA_FORMAT
        //
        // First call drvGetWiaFormatInfo to get the valid formats
        //
        hr = wiauGetValidFormats(this, pWiasContext, TYMED_FILE, &iNumFormats, &pguidFormatArray);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "wiauGetValidFormats failed");

        if (iNumFormats == 0)
        {
            wiauDbgError("BuildChildItemProperties", "wiauGetValidFormats returned zero formats");
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = ItemProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
        ItemProps.SetValidValues(index, (GUID *) pItemInfo->pguidFormat, (GUID *) pItemInfo->pguidFormat,
                                 iNumFormats, &pguidFormatArray);

        //
        // WIA_IPA_FILENAME_EXTENSION
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

        bstrExtension = SysAllocString(pItemInfo->wszExt);
        REQUIRE_ALLOC(bstrExtension, hr, "BuildChildItemProperties");

        ItemProps.SetCurrentValue(index, bstrExtension);

        //
        // WIA_IPA_ITEM_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

        ItemProps.SetCurrentValue(index, pItemInfo->lSize);

        //
        // WIA_IPA_MIN_BUFFER_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");


        if (!bBitmap && pItemInfo->lSize > 0)
            lMinBufSize = min(MIN_BUFFER_SIZE, pItemInfo->lSize);
        else
            lMinBufSize = MIN_BUFFER_SIZE;
        ItemProps.SetCurrentValue(index, lMinBufSize);

        //
        // Set up the image-only properties
        //
        if (pItemInfo->iType == WiaMCamTypeImage)
        {
            //
            // WIA_IPA_DATATYPE
            //
            // This property is mainly used by scanners. Set to color since most camera
            // images will be color.
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_COLOR);
    
            //
            // WIA_IPA_DEPTH
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lDepth);
            
            //
            // WIA_IPA_CHANNELS_PER_PIXEL
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lChannels);
    
            //
            // WIA_IPA_BITS_PER_CHANNEL
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lBitsPerChannel);
    
            //
            // WIA_IPA_PLANAR
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (LONG) WIA_PACKED_PIXEL);
    
            //
            // WIA_IPA_PIXELS_PER_LINE
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lWidth);
    
            //
            // WIA_IPA_BYTES_PER_LINE
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
    
            if (bBitmap)
                ItemProps.SetCurrentValue(index, ((pItemInfo->lWidth * pItemInfo->lDepth + 31) & ~31) / 8);
            else
                ItemProps.SetCurrentValue(index, (LONG) 0);
    
            //
            // WIA_IPA_NUMBER_OF_LINES
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lHeight);
    
            //
            // WIA_IPC_THUMBNAIL
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);
    
            //
            // WIA_IPC_THUMB_WIDTH
            //
            // This field is probably zero until the thumbnail is read in, but set it anyway
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lThumbWidth);
    
            //
            // WIA_IPC_THUMB_HEIGHT
            //
            // This field is probably zero until the thumbnail is read in, but set it anyway
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lThumbHeight);
    
            //
            // WIA_IPC_SEQUENCE
            //
            if (pItemInfo->lSequenceNum > 0)
            {
                hr = ItemProps.DefineProperty(&index, WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR,
                                              WIA_PROP_READ, WIA_PROP_NONE);
                REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
                ItemProps.SetCurrentValue(index, pItemInfo->lSequenceNum);
            }
            
            //
            // WIA_IPA_COMPRESSION
            //
            // This property is mainly used by scanners. Set to no compression.
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (LONG) WIA_COMPRESSION_NONE);
        }
    }

    //
    // Last step: send all the properties to WIA
    //
    hr = ItemProps.SendToWia(pWiasContext);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "SendToWia failed");

Cleanup:
    if (pguidFormatArray)
        delete []pguidFormatArray;
    if (bstrExtension)
        SysFreeString(bstrExtension);

    return hr;
}


/**************************************************************************\
* ReadChildItemProperties
*
*   Update the properties for the child items.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::ReadChildItemProperties(
    BYTE *pWiasContext,
    LONG lNumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaCameraDevice::ReadChildItemProperties");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pItemInfo = NULL;
    LONG lAccessRights = 0;
    LONG lThumbWidth = 0;
    INT iNativeThumbSize = 0;
    BYTE *pbNativeThumb = NULL;
    INT iConvertedThumbSize = 0;
    BYTE *pbConvertedThumb = NULL;
    BMP_IMAGE_INFO BmpImageInfo;

    REQUIRE_ARGS(!lNumPropSpecs || !pPropSpecs, hr, "ReadChildItemProperties");

    //
    // Get the driver item context
    //
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
    REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiauGetDrvItemContext failed");

    pItemInfo = pItemCtx->pItemInfo;

    //
    // See if the item time is being read
    //
    if (wiauPropInPropSpec(lNumPropSpecs, pPropSpecs, WIA_IPA_ITEM_TIME))
    {
        PROPVARIANT propVar;
        PROPSPEC    propSpec;
        propVar.vt = VT_VECTOR | VT_UI2;
        propVar.caui.cElems = sizeof(SYSTEMTIME) / sizeof(WORD);
        propVar.caui.pElems = (WORD *) &pItemInfo->Time;
        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPA_ITEM_TIME;
        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);
        REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasWriteMultiple failed");
    }

    //
    // See if the access rights are being read
    //
    if (wiauPropInPropSpec(lNumPropSpecs, pPropSpecs, WIA_IPA_ACCESS_RIGHTS))
    {
        lAccessRights = pItemInfo->bReadOnly ? WIA_ITEM_READ : WIA_ITEM_RD;
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_ACCESS_RIGHTS, lAccessRights);
        REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasWritePropLong failed");
    }

    //
    // For images, update the thumbnail properties if requested
    //
    if (pItemInfo->iType == WiaMCamTypeImage)
    {
        //
        // Get the thumbnail if requested to update any of the thumbnail properties and
        // the thumbnail is not already cached.
        //
        PROPID propsToUpdate[] = {
            WIA_IPC_THUMB_WIDTH,
            WIA_IPC_THUMB_HEIGHT,
            WIA_IPC_THUMBNAIL
            };

        if (wiauPropsInPropSpec(lNumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {
            //
            // See if the thumbnail has already been read
            //
            wiasReadPropLong(pWiasContext, WIA_IPC_THUMB_WIDTH, &lThumbWidth, NULL, TRUE);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasReadPropLong for thumbnail width failed");

            //
            // Get the thumbnail from the camera in it's native format
            //
            hr = m_pDevice->GetThumbnail(m_pDeviceInfo, pItemInfo, &iNativeThumbSize, &pbNativeThumb);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "GetThumbnail failed");
            
            //
            // If the format isn't supported by GDI+, return an error
            //
            if (!m_Converter.IsFormatSupported(pItemInfo->pguidThumbFormat)) {
                wiauDbgError("ReadChildItemProperties", "Thumb format not supported");
                hr = E_FAIL;
                goto Cleanup;
            }

            //
            // Call the WIA driver helper to convert to BMP
            //
            hr = m_Converter.ConvertToBmp(pbNativeThumb, iNativeThumbSize,
                                          &pbConvertedThumb, &iConvertedThumbSize,
                                          &BmpImageInfo, SKIP_BOTHHDR);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "ConvertToBmp failed");

            //
            // Fill in the thumbnail information based on the information returned from the helper
            //
            pItemInfo->lThumbWidth = BmpImageInfo.Width;
            pItemInfo->lThumbHeight = BmpImageInfo.Height;
            
            //
            // Update the related thumbnail properties. Update the thumb width and height in case
            // the device didn't report them in the ObjectInfo structure (they are optional there).
            //
            PROPSPEC propSpecs[3];
            PROPVARIANT propVars[3];
            
            propSpecs[0].ulKind = PRSPEC_PROPID;
            propSpecs[0].propid = WIA_IPC_THUMB_WIDTH;
            propVars[0].vt = VT_I4;
            propVars[0].lVal = pItemInfo->lThumbWidth;
            
            propSpecs[1].ulKind = PRSPEC_PROPID;
            propSpecs[1].propid = WIA_IPC_THUMB_HEIGHT;
            propVars[1].vt = VT_I4;
            propVars[1].lVal = pItemInfo->lThumbHeight;
            
            propSpecs[2].ulKind = PRSPEC_PROPID;
            propSpecs[2].propid = WIA_IPC_THUMBNAIL;
            propVars[2].vt = VT_VECTOR | VT_UI1;
            propVars[2].caub.cElems = iConvertedThumbSize;
            propVars[2].caub.pElems = pbConvertedThumb;

            hr = wiasWriteMultiple(pWiasContext, 3, propSpecs, propVars);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasWriteMultiple failed");
        }
    }

Cleanup:
    if (pbNativeThumb) {
        delete []pbNativeThumb;
        pbNativeThumb = NULL;
    }

    if (pbConvertedThumb) {
        delete []pbConvertedThumb;
        pbConvertedThumb = NULL;
    }
    
    return hr;
}


/**************************************************************************\
* AcquireData
*
*   Transfers native data from the device.
*
* Arguments:
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::AcquireData(
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pBuf,
    LONG lBufSize,
    BOOL bConverting
    )
{
    DBG_FN("CWiaCameraDevice::AcquireData");
    
    HRESULT hr = S_OK;

    BYTE *pCur = NULL;
    UINT uiState = MCAM_STATE_FIRST;
    LONG lPercentComplete = 0;
    LONG lTotalToRead = pItemCtx->pItemInfo->lSize;
    LONG lOffset = 0;
    DWORD dwBytesToRead = 0;
    BOOL bFileTransfer = pmdtc->tymed & TYMED_FILE;
    LONG lMessage = 0;
    LONG lStatus = 0;

    //
    // If pBuf is non-null use that as the buffer, otherwise use the buffer
    // and size in pmdtc
    //
    if (pBuf)
    {
        pCur = pBuf;
        dwBytesToRead = lBufSize;
    }
    else
    {
        pCur = pmdtc->pTransferBuffer;
        dwBytesToRead = pmdtc->lBufferSize;
    }

    //
    // If the transfer size is the entire item, split it into approximately
    // 10 equal transfers in order to show progress to the app, but don't
    // make it smaller than 1k
    //
    if ((dwBytesToRead == (DWORD) lTotalToRead) &&
        (dwBytesToRead > 1024))
    {
        dwBytesToRead = (lTotalToRead / 10 + 3) & ~0x3;
    }

    //
    // Set up parameters for the callback function
    //
    if (bConverting)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_FROM_DEVICE;
    }
    else if (bFileTransfer)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }
    else  // e.g. memory transfer
    {
        lMessage = IT_MSG_DATA;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }

    //
    // Read data until finished
    //
    while (lOffset < lTotalToRead)
    {
        //
        // If this is the last read, adjust the amount of data to read
        // and the state
        //
        if (dwBytesToRead >= (DWORD) (lTotalToRead - lOffset))
        {
            dwBytesToRead = (lTotalToRead - lOffset);
            uiState |= MCAM_STATE_LAST;
        }
        
        //
        // Get the data from the camera
        //
        hr = m_pDevice->GetItemData(m_pDeviceInfo, pItemCtx->pItemInfo, uiState, pCur, dwBytesToRead);
        REQUIRE_SUCCESS(hr, "AcquireData", "GetItemData failed");

        //
        // Calculate the percent complete for the callback function. If converting,
        // report the percent complete as TRANSFER_PERCENT of the actual. From
        // TRANSFER_PERCENT to 100% will be reported during format conversion.
        //
        if (bConverting)
            lPercentComplete = (lOffset + dwBytesToRead) * TRANSFER_PERCENT / lTotalToRead;
        else
            lPercentComplete = (lOffset + dwBytesToRead) * 100 / lTotalToRead;


        //
        // Call the callback function to send status and/or data to the app
        //
        hr = pmdtc->pIWiaMiniDrvCallBack->
            MiniDrvCallback(lMessage, lStatus, lPercentComplete,
                            lOffset, dwBytesToRead, pmdtc, 0);
        REQUIRE_SUCCESS(hr, "AcquireData", "MiniDrvCallback failed");

        if (hr == S_FALSE)
        {
            //
            // Transfer is being cancelled by the app
            //
            wiauDbgWarning("AcquireData", "transfer cancelled");
            goto Cleanup;
        }

        //
        // Increment buffer pointer only if converting or this is a
        // file transfer
        //
        if (bConverting || bFileTransfer)
        {
            pCur += dwBytesToRead;
        }

        //
        // For a memory transfer not using a buffer allocated by the minidriver,
        // update the buffer pointer and size from the transfer context in case
        // of double buffering
        //
        else if (!pBuf)
        {
            pCur = pmdtc->pTransferBuffer;
            dwBytesToRead = pmdtc->lBufferSize;
        }
        
        //
        // Adjust variables for the next iteration
        //
        lOffset += dwBytesToRead;
        uiState &= ~MCAM_STATE_FIRST;
    }

    //
    // For file transfers, write the data to file
    //
    if (!pBuf && bFileTransfer)
    {
        //
        // Call WIA to write the data to the file
        //
        hr = wiasWriteBufToFile(0, pmdtc);
        REQUIRE_SUCCESS(hr, "AcquireData", "wiasWriteBufToFile failed");
    }

Cleanup:
    //
    // If the transfer wasn't completed, send cancel to the device
    //
    if (!(uiState & MCAM_STATE_LAST))
    {
        wiauDbgTrace("AcquireData", "Prematurely stopping transfer");

        uiState = MCAM_STATE_CANCEL;
        hr = m_pDevice->GetItemData(m_pDeviceInfo, pItemCtx->pItemInfo, uiState, NULL, 0);
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "AcquireData", "GetItemData last failed");
    }

    return hr;
}


/**************************************************************************\
* Convert
*
*   Translates native data to BMP and sends the data to the app.
*
* Arguments:
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::Convert(
    BYTE *pWiasContext,
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pNativeImage,
    LONG lNativeSize
    )
{
    DBG_FN("CWiaCameraDevice::Convert");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG  lMsg = 0;                 // Parameter to the callback function
    LONG  lPercentComplete = 0;     // Parameter to the callback function
    BOOL  bUseAppBuffer = FALSE;    // Indicates whether to transfer directly into the app's buffer
    BYTE *pBmpBuffer = NULL;        // Buffer used to hold converted image
    INT   iBmpBufferSize = 0;       // Size of the converted image buffer
    LONG  lBytesToCopy = 0;
    LONG  lOffset = 0;
    BYTE *pCurrent = NULL;
    BMP_IMAGE_INFO BmpImageInfo;
    SKIP_AMOUNT iSkipAmt = SKIP_OFF;

    //
    // Check arguments
    //
    REQUIRE_ARGS(!pNativeImage, hr, "Convert");
    
    //
    // The msg to send to the app via the callback depends on whether
    // this is a file or callback transfer
    //
    lMsg = ((pmdtc->tymed & TYMED_FILE) ? IT_MSG_STATUS : IT_MSG_DATA);

    //
    // If the class driver allocated a buffer and the buffer is large
    // enough, convert directly into that buffer. Otherwise, pass NULL
    // to the ConvertToBmp function so that it will allocate a buffer.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize >= pmdtc->lItemSize) {

        bUseAppBuffer = TRUE;
        pBmpBuffer = pmdtc->pTransferBuffer;
        iBmpBufferSize = pmdtc->lBufferSize;
    }

    //
    // Convert the image to BMP. Skip the BMP file header if the app asked
    // for a "memory bitmap" (aka DIB).
    //
    memset(&BmpImageInfo, 0, sizeof(BmpImageInfo));
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        iSkipAmt = SKIP_FILEHDR;
    }
    hr = m_Converter.ConvertToBmp(pNativeImage, lNativeSize, &pBmpBuffer,
                                  &iBmpBufferSize, &BmpImageInfo, iSkipAmt);
    REQUIRE_SUCCESS(hr, "Convert", "ConvertToBmp failed");

    //
    // Send the data to the app. If the class driver allocated the buffer,
    // but it was too small, send the data back one chunk at a time.
    // Otherwise send all the data back at once.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize < BmpImageInfo.Size) {

        pCurrent = pBmpBuffer;

        while (lOffset < BmpImageInfo.Size)
        {
            lBytesToCopy = BmpImageInfo.Size - lOffset;
            if (lBytesToCopy > pmdtc->lBufferSize) {

                lBytesToCopy = pmdtc->lBufferSize;

                //
                // Calculate how much of the data has been sent back so far. Report percentages to
                // the app between TRANSFER_PERCENT and 100 percent. Make sure it is never larger
                // than 99 until the end.
                //
                lPercentComplete = TRANSFER_PERCENT + ((100 - TRANSFER_PERCENT) * lOffset) / pmdtc->lItemSize;
                if (lPercentComplete > 99) {
                    lPercentComplete = 99;
                }
            }

            //
            // This will complete the transfer, so set the percentage to 100
            else {
                lPercentComplete = 100;
            }

            memcpy(pmdtc->pTransferBuffer, pCurrent, lBytesToCopy);
            
            //
            // Call the application's callback transfer to report status and/or transfer data
            //
            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                              lPercentComplete, lOffset, lBytesToCopy, pmdtc, 0);
            REQUIRE_SUCCESS(hr, "Convert", "MiniDrvCallback failed");
            if (hr == S_FALSE)
            {
                wiauDbgWarning("Convert", "transfer cancelled");
                hr = S_FALSE;
                goto Cleanup;
            }

            pCurrent += lBytesToCopy;
            lOffset += lBytesToCopy;
        }
    }

    else
    {
        //
        // Send the data to the app in one big chunk
        //
        pmdtc->pTransferBuffer = pBmpBuffer;
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, 0, BmpImageInfo.Size, pmdtc, 0);
        REQUIRE_SUCCESS(hr, "Convert", "MiniDrvCallback failed");
    }
    
Cleanup:
    if (!bUseAppBuffer) {
        if (pBmpBuffer) {
            delete []pBmpBuffer;
            pBmpBuffer = NULL;
            iBmpBufferSize = 0;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\microsft\wiacam\wiacam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiacam.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*
*
***************************************************************************/

#pragma once

//
// Globals
//
extern HINSTANCE  g_hInst;     // DLL module instance

//
// Driver item context
//
typedef struct _ITEM_CONTEXT{
    MCAM_ITEM_INFO     *pItemInfo;      // Handle to the camera item
    BOOL                bItemChanged;   // Indicates the item has changed on the device
    LONG                lNumFormatInfo; // Number of entries in format info array
    WIA_FORMAT_INFO    *pFormatInfo;    // Pointer to format info array 
} ITEM_CONTEXT, *PITEM_CONTEXT;

//
// Handy constants for common item types
//
const LONG ITEMTYPE_FILE   = WiaItemTypeFile;
const LONG ITEMTYPE_IMAGE  = WiaItemTypeFile | WiaItemTypeImage;
const LONG ITEMTYPE_AUDIO  = WiaItemTypeFile | WiaItemTypeAudio;
const LONG ITEMTYPE_VIDEO  = WiaItemTypeFile | WiaItemTypeVideo;
const LONG ITEMTYPE_FOLDER = WiaItemTypeFolder;
const LONG ITEMTYPE_BURST  = WiaItemTypeFolder | WiaItemTypeBurst;
const LONG ITEMTYPE_HPAN   = WiaItemTypeFolder | WiaItemTypeHPanorama;
const LONG ITEMTYPE_VPAN   = WiaItemTypeFolder | WiaItemTypeVPanorama;

//
// Minimum data call back transfer buffer size
//
const LONG MIN_BUFFER_SIZE   = 0x8000;

//
// When doing a transfer and convert to BMP, this value
// represents how much of the time is spent doing the
// transfer of data from the device.
//
const LONG TRANSFER_PERCENT = 90;

//
// Base structure for supporting non-delegating IUnknown for contained objects
//
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD (NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef) (THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease) (THIS) PURE;
};

//
// Class definition for sample WIA scanner object
//
class CWiaCameraDevice : public IStiUSD,               // STI USD interface
                         public IWiaMiniDrv,           // WIA Minidriver interface
                         public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWiaCameraDevice(LPUNKNOWN punkOuter);
    ~CWiaCameraDevice();

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHODIMP Initialize(PSTIDEVICECONTROL pHelDcb, DWORD dwStiVersion, HKEY hParametersKey);
    STDMETHODIMP GetCapabilities(PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus(PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPDIAG pBuffer);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE EscapeFunction, LPVOID lpInData, DWORD cbInDataSize,
                        LPVOID pOutData, DWORD dwOutDataSize, LPDWORD pdwActualData);
    STDMETHODIMP GetLastError(LPDWORD pdwLastDeviceError);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHODIMP drvInitializeWia(BYTE *pWiasContext, LONG lFlags, BSTR bstrDeviceID, BSTR bstrRootFullItemName,
                                  IUnknown *pStiDevice, IUnknown *pIUnknownOuter, IWiaDrvItem  **ppIDrvItemRoot,
                                  IUnknown **ppIUnknownInner, LONG *plDevErrVal);
    STDMETHODIMP drvUnInitializeWia(BYTE* pWiasContext);
    STDMETHODIMP drvDeviceCommand(BYTE *pWiasContext, LONG lFlags, const GUID *pGUIDCommand,
                                  IWiaDrvItem **ppMiniDrvItem, LONG *plDevErrVal);
    STDMETHODIMP drvDeleteItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetCapabilities(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                    WIA_DEV_CAP_DRV **ppCapabilities, LONG *plDevErrVal);
    STDMETHODIMP drvInitItemProperties(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvLockWiaDevice(BYTE  *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvUnLockWiaDevice(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvAnalyzeItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetWiaFormatInfo(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                     WIA_FORMAT_INFO **ppwfi, LONG *plDevErrVal);
    STDMETHODIMP drvNotifyPnpEvent(const GUID *pEventGUID, BSTR bstrDeviceID, ULONG ulReserved);
    STDMETHODIMP drvReadItemProperties(BYTE *pWiaItem, LONG lFlags, ULONG nPropSpec,
                                       const PROPSPEC *pPropSpec, LONG  *plDevErrVal);
    STDMETHODIMP drvWriteItemProperties(BYTE *pWiasContext, LONG lFLags,
                                        PMINIDRV_TRANSFER_CONTEXT pmdtc, LONG *plDevErrVal);
    STDMETHODIMP drvValidateItemProperties(BYTE *pWiasContext, LONG lFlags, ULONG nPropSpec,
                                           const PROPSPEC *pPropSpec, LONG *plDevErrVal);
    STDMETHODIMP drvAcquireItemData(BYTE *pWiasContext, LONG lFlags,
                                    PMINIDRV_TRANSFER_CONTEXT pDataContext, LONG *plDevErrVal);
    STDMETHODIMP drvGetDeviceErrorStr(LONG lFlags, LONG lDevErrVal, LPOLESTR *ppszDevErrStr, LONG *plDevErrVal);
    STDMETHODIMP drvFreeDrvItemContext(LONG lFlags, BYTE *pDevContext, LONG *plDevErrVal);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    VOID RunNotifications(VOID);

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////

    HRESULT FreeResources();
    HRESULT GetOLESTRResourceString(LONG lResourceID, LPOLESTR *ppsz);

    //
    // WIA Item Management Helpers
    //
    HRESULT BuildItemTree(MCAM_ITEM_INFO *pItem);
    HRESULT AddObject(MCAM_ITEM_INFO *pItem);
    HRESULT ConstructFullName(MCAM_ITEM_INFO *pItemInfo, WCHAR *pwszFullName, INT cchFullNameSize);
    HRESULT LinkToParent(MCAM_ITEM_INFO *pItem, BOOL bQueueEvent = FALSE);
    HRESULT DeleteItemTree(LONG lReason);

    //
    // WIA Property Management Helpers
    //
    HRESULT BuildRootItemProperties(BYTE *pWiasContext);
    HRESULT ReadRootItemProperties(BYTE *pWiasContext, LONG lNumPropSpecs, const PROPSPEC *pPropSpecs);
    
    HRESULT BuildChildItemProperties(BYTE *pWiasContext);
    HRESULT GetValidFormats(BYTE *pWiasContext, LONG lTymedValue, INT *piNumFormats, GUID **ppFormatArray);
    HRESULT ReadChildItemProperties(BYTE *pWiasContext, LONG lNumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT AcquireData(ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                        BYTE *pBuf, LONG lBufSize, BOOL bConverting);
    HRESULT Convert(BYTE *pWiasContext, ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                    BYTE *pNativeImage, LONG lNativeSize);

    //
    // WIA Capability Management Helpers
    //
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();

private:

    // COM object data
    ULONG                m_cRef;                  // Device object reference count
    LPUNKNOWN            m_punkOuter;             // Pointer to outer unknown

    // STI data
    PSTIDEVICECONTROL    m_pIStiDevControl;       // Device control interface
    IStiDevice          *m_pStiDevice;            // Sti object
    DWORD                m_dwLastOperationError;  // Last error
    WCHAR                m_wszPortName[MAX_PATH]; // Port name for accessing the device

    // WIA data
    BSTR                 m_bstrDeviceID;          // WIA unique device ID
    BSTR                 m_bstrRootFullItemName;  // Root item name
    IWiaDrvItem         *m_pRootItem;             // Root item

    LONG                 m_lNumSupportedCommands; // Number of supported commands
    LONG                 m_lNumSupportedEvents;   // Number of supported events
    LONG                 m_lNumCapabilities;      // Number of capabilities
    WIA_DEV_CAP_DRV     *m_pCapabilities;         // Capabilities array

    // Device data
    CCamMicro           *m_pDevice;               // Pointer to DLL wrapper class
    MCAM_DEVICE_INFO    *m_pDeviceInfo;           // Device information
    
    // Misc data
    INT                  m_iConnectedApps;        // Number of app connected to this driver
    CWiauFormatConverter m_Converter;
};

typedef CWiaCameraDevice *PWIACAMERADEVICE;

/***************************************************************************\
*
*  CWiaCameraDeviceClassFactory
*
\****************************************************************************/

class CWiaCameraDeviceClassFactory : public IClassFactory
{
public:
    CWiaCameraDeviceClassFactory();
    ~CWiaCameraDeviceClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP CreateInstance(IUnknown __RPC_FAR *pUnkOuter, REFIID riid,
                                void __RPC_FAR *__RPC_FAR *ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

private:
    ULONG   m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\tcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TCamProp.H
*
*  VERSION:     1.0
*
*  DATE:        16 May, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for test camera's private properties.
*
*******************************************************************************/

#ifndef __TCAMPROP_H__
#define __TCAMPROP_H__

#include  <guiddef.h>

//
// Path where test camera builds its item tree, BSTR & RW
//

#define  WIA_DPP_TCAM_ROOT_PATH         WIA_PRIVATE_DEVPROP
#define  WIA_DPP_TCAM_ROOT_PATH_STR     L"Test Camera Root Path"

//
// Private event after the Root Path is changed
//

const GUID WIA_EVENT_NAME_CHANGE =
{ /* 88f80f75-af08-11d2-a094-00c04f72dc3c */
    0x88f80f75,
    0xaf08,
    0x11d2,
    {0xa0, 0x94, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\camevent.cpp ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    camevent.cpp

Abstract:

    Enumerate disk images to emulate camera

Environment:

    user mode

Revision History:

--*/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "testusd.h"
#include "tcamprop.h"
#include "resource.h"

extern HINSTANCE g_hInst; // Global hInstance

CAM_EVENT gCamEvent[] = {

    {
        TEXT("Pathname Change"),
        &WIA_EVENT_NAME_CHANGE
    },
    {
        TEXT("Disconnect"),
        &WIA_EVENT_DEVICE_DISCONNECTED
    },
    {
        TEXT("Connect"),
        &WIA_EVENT_DEVICE_CONNECTED
    }
};

TCHAR   gpszPath[MAX_PATH];


/**************************************************************************\
* CameraEventDlgProc
*
*
* Arguments:
*
*   hDlg
*   message
*   wParam
*   lParam
*
* Return Value:
*
*    Status
*
* History:
*
*    1/11/1999 Original Version
*
\**************************************************************************/

BOOL  _stdcall
CameraEventDlgProc(
   HWND       hDlg,
   unsigned   message,
   DWORD      wParam,
   LONG       lParam
   )

/*++

Routine Description:

   Process message for about box, show a dialog box that says what the
   name of the program is.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    //
    // Setting pDevice to a LONG will not work on 64-bit. Since this dialog is going away soon, just
    // comment out this function for now.
    //
#if 0
    static TestUsdDevice *pDevice;

    switch (message) {
    case WM_INITDIALOG:
        {
            //
            // get event list from device
            //
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 0, (LPARAM)gCamEvent[0].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 1, (LPARAM)gCamEvent[1].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 2, (LPARAM)gCamEvent[2].pszEvent);

            SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, 0, 0);

            pDevice = (TestUsdDevice *)lParam;
            pDevice->m_hDlg = hDlg;

            SetDlgItemText(hDlg, IDC_EDIT1, gpszPath);

        }
        break;

    case WM_COMMAND:
        switch(wParam) {

            case IDCANCEL:
            case IDOK:
                {
                    //if (IDYES == MessageBox( hDlg, TEXT("Are you sure you want to close the event dialog?"), TEXT("Test Camera"), MB_ICONQUESTION|MB_YESNOCANCEL ))
                        EndDialog( hDlg, wParam );
                }
                break;

            case IDD_GEN_EVENT:
                {
                    //
                    // if event is not already set
                    //

                    //
                    // get selected
                    //

                    LRESULT i = SendDlgItemMessage(
                                hDlg,
                                IDC_COMBO1,
                                CB_GETCURSEL, 0, 0);

                    pDevice->m_guidLastEvent = *gCamEvent[i].pguid;

                    //
                    // private event
                    //

                    if (IsEqualIID(
                            pDevice->m_guidLastEvent, WIA_EVENT_NAME_CHANGE)) {

                        UINT ui = GetDlgItemText(
                                      hDlg, IDC_EDIT1, gpszPath, MAX_PATH);
                    }

                    wiasQueueEvent (pDevice->m_bstrDeviceID, &pDevice->m_guidLastEvent, NULL);
                    WIAS_TRACE((g_hInst,"TestUsdDevice::TestUsdDevice"));
                    return (TRUE);
                }
        }
        break;
    }

    return (FALSE);
#endif

    if (message == WM_COMMAND &&
        (wParam == IDCANCEL ||
         wParam == IDOK))
        EndDialog( hDlg, wParam );

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\camxfer.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       memcam.cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      Mark Enstrom [marke]
*               Indy Zhu     [indyz]
*
*  DATE:        2/4/1998
*               5/18/1998
*
*  DESCRIPTION:
*   Implementation of an ImageIn test camera device object.
*
*******************************************************************************/

#include <stdio.h>
#include <objbase.h>
#include <tchar.h>
#include <sti.h>

extern HINSTANCE g_hInst; // Global hInstance

#include "testusd.h"


VOID
VerticalFlip(
    PBYTE   pImageTop,
    LONG    iHeight,
    LONG    iWidthInBytes);

/**************************************************************************\
* CamLoadPicture
*
*    load a bmp from disk and copy it to application
*
* Arguments:
*
*   pCameraImage    - pointer to data structure with image info
*   pDataTransCtx   - pointer to minidriver transfer context
*
* Return Value:
*
*   status
*
* History:
*
*    2/10/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamLoadPicture(
    MEMCAM_IMAGE_CONTEXT       *pMCamContext,
    PMINIDRV_TRANSFER_CONTEXT   pDataTransCtx,
    PLONG                       plCamErrVal)
{
    LONG                  lScanLineWidth;
    HRESULT               hr = S_OK;
    LONG                  cbNeeded;
    IWiaMiniDrvCallBack  *pIProgressCB;

    WIAS_TRACE((g_hInst,"CamLoadPicture"));

    //
    // verify some params
    //

    if (! pMCamContext) {
      return (E_INVALIDARG);
    }

    if (pDataTransCtx->guidFormatID != WiaImgFmt_BMP && pDataTransCtx->guidFormatID != WiaAudFmt_WAV) {
        return (E_NOTIMPL);
    }

    pIProgressCB = pDataTransCtx->pIWiaMiniDrvCallBack;

    //
    // Simulate the download of data from the camera
    //

    if (pIProgressCB) {
        hr = pIProgressCB->MiniDrvCallback(
                               IT_MSG_STATUS,
                               IT_STATUS_TRANSFER_FROM_DEVICE,
                               (LONG)0,     // Percentage Complete,
                               0,
                               0,
                               pDataTransCtx,
                               0);
        if (hr != S_OK) {
            return (hr);   // Client want to cancel the transfer or error
        }
    }

    HANDLE hFile = CreateFile(
                       pMCamContext->pszCameraImagePath,
                       GENERIC_WRITE | GENERIC_READ  ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {

        hr = HRESULT_FROM_WIN32(::GetLastError());
        return (hr);
    }

    if (pIProgressCB) {
        hr = pIProgressCB->MiniDrvCallback(
                               IT_MSG_STATUS,
                               IT_STATUS_TRANSFER_FROM_DEVICE,
                               (LONG)25,     // Percentage Complete,
                               0,
                               0,
                               pDataTransCtx,
                               0);
    }
    if (hr != S_OK) {
        CloseHandle(hFile);
        return (hr);
    }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READWRITE,
                       0,
                       0,
                       NULL);

    if (hMap == NULL) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    } else {
        if (pIProgressCB) {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)50,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
        }
    }

    if (hr != S_OK) {
        CloseHandle(hFile);
        return (hr);
    }

    PBYTE pFile = (PBYTE)MapViewOfFileEx(
                             hMap,
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             0,
                             NULL);
    if (pFile == NULL) {

        hr = HRESULT_FROM_WIN32(::GetLastError());
    } else {
        if (pIProgressCB) {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)100,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
        }
    }

    if (hr != S_OK) {
        CloseHandle(hFile);
        CloseHandle(hMap);
        return(hr);
    }

    if (pDataTransCtx->guidFormatID == WiaImgFmt_BMP)
    {


        //
        // File contains BITMAPFILEHEADER + BITMAPINFO structure.
        //
        // DIB Data is located bfOffBits after start of file
        //

        PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
        PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile +
                                               sizeof(BITMAPFILEHEADER));

        //
        // validate bitmap
        //

        if (pbmFile->bfType != 'MB') {

            //
            // file is not a bitmap
            //

            UnmapViewOfFile(pFile);
            CloseHandle(hMap);
            CloseHandle(hFile);
            return(E_FAIL);
        }

        //
        // write image size
        //
        // make sure to align scanline to ULONG boundary
        //
        // calculate byte width
        //

        lScanLineWidth = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;

        //
        // round up to nearenst DWORD
        //

        lScanLineWidth = (lScanLineWidth + 31) >> 3;

        lScanLineWidth &= 0xfffffffc;

        cbNeeded = lScanLineWidth * pbmi->bmiHeader.biHeight;

        if (cbNeeded > ((LONG)pDataTransCtx->lItemSize - (LONG)pDataTransCtx->cbOffset)) {

            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);

        } else {

            //
            // copy only the bitmap bits (no headers)
            //

            memcpy(
                pDataTransCtx->pTransferBuffer + pDataTransCtx->cbOffset,
                pFile + pbmFile->bfOffBits,
                cbNeeded);
        }
    }
    else
    {
        memcpy (pDataTransCtx->pTransferBuffer,
                pFile,
                pDataTransCtx->lItemSize);
    }
    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return(S_OK);
}

/**************************************************************************\
* CamLoadPictureCB
*
*    return data by filling the data buffer and calling back to the client
*
* Arguments:
*
*    pCameraImage    -    image item
*    pTransCtx       -    mini driver transfer contect
*
* Return Value:
*
*   status
*
* History:
*
*    1/10/1999 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT TestUsdDevice::CamLoadPictureCB(
    MEMCAM_IMAGE_CONTEXT      *pMCamContext,
    MINIDRV_TRANSFER_CONTEXT  *pTransCtx,
    PLONG                      plCamErrVal)
{
    LONG                   lScanLineWidth;
    HRESULT                hr = E_FAIL;

    WIAS_TRACE((g_hInst,"CamLoadPictureCB"));

    //
    // verify parameters
    //

    if (!pMCamContext) {
      return (E_INVALIDARG);
    }

    if (pTransCtx == NULL) {
        return (E_INVALIDARG);
    }

    if ((pTransCtx->guidFormatID != WiaImgFmt_BMP) &&
        (pTransCtx->guidFormatID != WiaImgFmt_MEMORYBMP)) {
        return (E_NOTIMPL);
    }

    //
    // try to open disk file
    //

    HANDLE hFile = CreateFile(
                       pMCamContext->pszCameraImagePath,
                       GENERIC_WRITE | GENERIC_READ  ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE) {

        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READWRITE,
                       0,
                       0,
                       NULL);

    if (hMap == NULL) {
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    PBYTE pFile = (PBYTE)MapViewOfFileEx(
                             hMap,
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             0,
                             NULL);
    if (pFile == NULL) {

        CloseHandle(hFile);
        CloseHandle(hMap);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    //
    // File contains BITMAPFILEHEADER + BITMAPINFO structure.
    //
    // DIB Data is located bfOffBits after start of file
    //

    PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
    PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile +
                                               sizeof(BITMAPFILEHEADER));
    //
    // validate bitmap
    //

    if (pbmFile->bfType != 'MB') {

        //
        // file is not a bitmap
        //

        UnmapViewOfFile(pFile);
        CloseHandle(hMap);
        CloseHandle(hFile);
        return(E_FAIL);
    }

    //
    // get image size
    //
    // make sure to align scanline to ULONG boundary
    //
    // calculate byte width
    //

    lScanLineWidth = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;

    //
    // round up to nearenst DWORD
    //

    lScanLineWidth = (lScanLineWidth + 31) >> 3;

    lScanLineWidth &= 0xfffffffc;

    LONG lBytesRemaining = lScanLineWidth * pbmi->bmiHeader.biHeight;

    //
    // Flip the image vertically if WiaImgFmt_MEMORYBMP is requested
    //

    if (pTransCtx->guidFormatID == WiaImgFmt_MEMORYBMP) {
        VerticalFlip(
            (PBYTE)pFile + pbmFile->bfOffBits,
            pbmi->bmiHeader.biHeight,
            lScanLineWidth);
    }

    //
    // callback loop
    //

    PBYTE pSrc = (PBYTE)pFile + pbmFile->bfOffBits;

    LONG  lTransferSize;
    LONG  lPercentComplete;

    do {

        PBYTE pDst = pTransCtx->pTransferBuffer;

        //
        // transfer up to entire buffer size
        //

        lTransferSize = lBytesRemaining;

        if (lBytesRemaining > pTransCtx->lBufferSize) {
            lTransferSize = pTransCtx->lBufferSize;
        }

        //
        // copy data
        //

        memcpy(pDst, pSrc, lTransferSize);

        lPercentComplete = 100 * (pTransCtx->cbOffset + lTransferSize);
        lPercentComplete /= pTransCtx->lItemSize;

        //
        // make callback
        //

        hr = pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                     IT_MSG_DATA,
                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                     lPercentComplete,
                                     pTransCtx->cbOffset,
                                     lTransferSize,
                                     pTransCtx,
                                     0);
        //
        // inc pointers (redundant pointers here)
        //

        pSrc                += lTransferSize;
        pTransCtx->cbOffset += lTransferSize;
        lBytesRemaining     -= lTransferSize;

        if (hr != S_OK) {
            break;
        }

    } while (lBytesRemaining > 0);

    //
    // Flip the image back if WiaImgFmt_MEMORYBMP is requested
    //

    if (pTransCtx->guidFormatID == WiaImgFmt_MEMORYBMP) {
        VerticalFlip(
            (PBYTE)pFile + pbmFile->bfOffBits,
            pbmi->bmiHeader.biHeight,
            lScanLineWidth);
    }

    //
    // Garbage collection
    //

    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return(hr);
}



/**************************************************************************\
* CamGetPictureInfo
*
*    Load file, get information from image
*
* Arguments:
*
*    pCameraImage    -    image item
*    pPictInfo       -    fill out ino about image
*    ppBITMAPINFO    -    alloc and fill out BITMAPINFO
*    pBITMAPINFOSize -    size
*
* Return Value:
*
*    status
*
* History:
*
*    1/17/1999 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamGetPictureInfo(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext,
    PCAMERA_PICTURE_INFO   pPictInfo,
    PBYTE                 *ppBITMAPINFO,
    LONG                  *pBITMAPINFOSize)
{
    HRESULT                hr = S_OK;
    FILETIME               ftCreate;
    SYSTEMTIME             stCreate;

    WIAS_TRACE((g_hInst,"CamGetPictureInfo"));

    //
    // Try to open disk file
    //

    HANDLE hFile = CreateFile(
                       pMCamContext->pszCameraImagePath,
                       GENERIC_WRITE | GENERIC_READ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    //
    // Grab the creation time for this image
    //

    if (GetFileTime( hFile, &ftCreate, NULL, NULL)) {
        FileTimeToSystemTime( &ftCreate, &stCreate );
    } else {
        //
        // To return something, use the system time
        //

        GetLocalTime( &stCreate );
    }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READWRITE,
                       0,
                       0,
                       NULL
                       );
    if (hMap == NULL) {
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    PBYTE pFile = (PBYTE)MapViewOfFileEx(
                             hMap,
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             0,
                             NULL);
    if (pFile == NULL) {
        CloseHandle(hFile);
        CloseHandle(hMap);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    //
    // File contains BITMAPFILEHEADER + BITMAPINFO structure.
    //
    // DIB Data is located bfOffBits after start of file
    //

    PBITMAPFILEHEADER  pbmFile    = (PBITMAPFILEHEADER)pFile;
    PBITMAPINFOHEADER  pbmiHeader =
                           (PBITMAPINFOHEADER)(pFile +
                                               sizeof(BITMAPFILEHEADER));
    PBYTE              pDIBFile   = pFile + pbmFile->bfOffBits;

    //
    // validate bitmap.
    //

    if (pbmFile->bfType != 'MB') {
        //
        // file is not a bitmap
        //


        UnmapViewOfFile(pFile);
        CloseHandle(hFile);
        CloseHandle(hMap);
        return(E_FAIL);
    }

    //
    // fill out image information
    //

    pPictInfo->PictNumber       = 0;  // ??? Should support picture handle ???
    pPictInfo->ThumbWidth       = 80;
    pPictInfo->ThumbHeight      = 60;
    pPictInfo->PictWidth        = pbmiHeader->biWidth;
    pPictInfo->PictHeight       = pbmiHeader->biHeight;
    pPictInfo->PictCompSize     = 0;
    pPictInfo->PictFormat       = 0;
    pPictInfo->PictBitsPerPixel = pbmiHeader->biBitCount;

    {
        LONG lScanLineWidth = (pbmiHeader->biWidth *
                              pbmiHeader->biBitCount);

        //
        // round up to nearenst DWORD
        //

        lScanLineWidth = (lScanLineWidth + 31) >> 3;

        //
        // remove extra bytes
        //

        lScanLineWidth &= 0xfffffffc;

        pPictInfo->PictBytesPerRow  = lScanLineWidth;
    }

    //
    // is there a color table
    //

    LONG ColorMapSize = 0;
    LONG bmiSize;

    if (pbmiHeader->biBitCount == 1) {
        ColorMapSize = 2;
    } else if (pbmiHeader->biBitCount == 4) {
        ColorMapSize = 16;
    } else if (pbmiHeader->biBitCount == 8) {
        ColorMapSize = 256;
    }

    //
    // Changed by Indy on 5/18/98 to BITMAPINFOHEADER
    //

    bmiSize = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * ColorMapSize;

    *ppBITMAPINFO = (PBYTE)ALLOC(bmiSize);

    if (*ppBITMAPINFO != NULL) {
        memcpy(*ppBITMAPINFO, pbmiHeader, bmiSize);
        *pBITMAPINFOSize = bmiSize;
    } else {

        UnmapViewOfFile(pFile);
        CloseHandle(hFile);
        CloseHandle(hMap);
        return(E_OUTOFMEMORY);
    }

    //
    // Set the time for the image
    //

    memcpy(&pPictInfo->TimeStamp, &stCreate, sizeof(pPictInfo->TimeStamp));

    //
    // close up the file
    //

    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return(hr);
}


/**************************************************************************\
* CamLoadThumbnail
*
*   Load the thumbnail of the specified picture
*
* Arguments:
*
*   pCameraImage    - image item
*   pThumbnail      - buffer for thumbnail
*   pThumbSize      - size of thumbnail
*
* Return Value:
*
*   status
*
* History:
*
*    2/9/1998  Mark Enstrom [marke]
*    6/9/1998  Indy Zhu     [indyz]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamLoadThumbnail(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext ,
    PBYTE                 *pThumbnail,
    LONG                  *pThumbSize
    )
{
    TCHAR                  pszThumbName[MAX_PATH];
    HRESULT                hr;
    BOOL                   bCacheThumb  = TRUE;
    BOOL                   bThumbExists = TRUE;

    PBYTE                  pTmbPixels;
    HBITMAP                hbmThumb     = NULL;
    PBYTE                  pThumb       = NULL;
    HANDLE                 hTmbFile     = INVALID_HANDLE_VALUE;
    HANDLE                 hTmbMap      = NULL;
    PBYTE                  pTmbFile     = NULL;

    HANDLE                 hFile        = INVALID_HANDLE_VALUE;
    HANDLE                 hMap         = NULL;
    PBYTE                  pFile        = NULL;

    BITMAPINFO             bmiDIB;
    HDC                    hdc          = NULL;
    HDC                    hdcm1        = NULL;

    WIAS_TRACE((g_hInst,"CamLoadThumbnail"));

    //
    // Initialize the return values
    //

    *pThumbnail = NULL;
    *pThumbSize = 0;

    //
    // Fill in the size of the tumbnail pixel buffer
    //

    bmiDIB.bmiHeader.biSizeImage = 80*60*3;

    //
    // Build thumbnail filename Image.bmp.tmb
    //

    _tcscpy(pszThumbName, pMCamContext->pszCameraImagePath);
    _tcscat(pszThumbName, TEXT(".tmb"));

    __try {

        hTmbFile = CreateFile(
                       pszThumbName,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );

        //
        // See if cached thumbnail already exists
        //

        if (hTmbFile == INVALID_HANDLE_VALUE) {

            //
            // Try to create a new one
            //

            hTmbFile = CreateFile(
                           pszThumbName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           );

            //
            // Thumbnail need to be created
            //

            bThumbExists = FALSE;

        }

        //
        // thumbnail file exists
        //

        if (hTmbFile != INVALID_HANDLE_VALUE) {

            hTmbMap = CreateFileMapping(
                          hTmbFile,
                          NULL,
                          PAGE_READWRITE,
                          0,
                          80 * 60 * 3,
                          NULL);

            if (hTmbMap != NULL) {

                pTmbFile = (PBYTE)MapViewOfFileEx(
                                      hTmbMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE,
                                      0,
                                      0,
                                      0,
                                      NULL);

                if (pTmbFile) {

                    if (bThumbExists) {

                        //
                        // Alloca memory for thumbnail pixels
                        //

                        pTmbPixels = (PBYTE)ALLOC(bmiDIB.bmiHeader.biSizeImage);

                        if (! pTmbPixels) {
                            return(E_OUTOFMEMORY);
                        }

                        //
                        // Pull the thumbnail from the cached file
                        //

                        memcpy(pTmbPixels, pTmbFile,
                               bmiDIB.bmiHeader.biSizeImage);

                        //
                        // All the handles will be closed in __finally block
                        //

                        *pThumbnail = pTmbPixels;
                        *pThumbSize = bmiDIB.bmiHeader.biSizeImage;

                        return(S_OK);
                    }
                } else {

                    bCacheThumb  = FALSE;
                }
            } else {

                bCacheThumb  = FALSE;
            }
        } else {

            //
            // Can't cache thumbnail
            //

            bCacheThumb  = FALSE;
        }

        //
        // Try to create a thumbnail from the full-size image
        // and cache it if the thumbnail cache file is created
        //

        hFile = CreateFile(
                    pMCamContext->pszCameraImagePath,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
        if (hFile == INVALID_HANDLE_VALUE) {


            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }

        hMap = CreateFileMapping(
                   hFile,
                   NULL,
                   PAGE_READWRITE,
                   0,
                   0,
                   NULL
                   );
        if (hMap == NULL) {

          hr = HRESULT_FROM_WIN32(::GetLastError());
          return(hr);
        }

        pFile = (PBYTE)MapViewOfFileEx(
                           hMap,
                           FILE_MAP_READ | FILE_MAP_WRITE,
                           0,
                           0,
                           0,
                           NULL
                           );
        if (pFile == NULL) {

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }

        PBITMAPFILEHEADER pbmFile = (PBITMAPFILEHEADER)pFile;
        PBITMAPINFO       pbmi    = (PBITMAPINFO)(pFile +
                                                 sizeof(BITMAPFILEHEADER));
        PBYTE             pPixels = pFile + pbmFile->bfOffBits;

        //
        // Generate the thumbnail from the full-size image
        //

        hdc   = GetDC(NULL);
        hdcm1 = CreateCompatibleDC(hdc);
        SetStretchBltMode(hdcm1, COLORONCOLOR);



        //
        // Create a BITMAP for rendering the thumbnail
        //

        bmiDIB.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        bmiDIB.bmiHeader.biBitCount      = 24;
        bmiDIB.bmiHeader.biWidth         = 80;
        bmiDIB.bmiHeader.biHeight        = 60;
        bmiDIB.bmiHeader.biPlanes        = 1;
        bmiDIB.bmiHeader.biCompression   = BI_RGB;
        bmiDIB.bmiHeader.biXPelsPerMeter = 100;
        bmiDIB.bmiHeader.biYPelsPerMeter = 100;
        bmiDIB.bmiHeader.biClrUsed       = 0;
        bmiDIB.bmiHeader.biClrImportant  = 0;

        hbmThumb = CreateDIBSection(hdc, &bmiDIB, DIB_RGB_COLORS,
                                    (VOID **)&pThumb, NULL, 0);

        if (! hbmThumb) {

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return hr;
        }

        HBITMAP     hbmDef = (HBITMAP)SelectObject(hdcm1, hbmThumb);

        //
        // Init DIB
        //

        memset(pThumb, 0, bmiDIB.bmiHeader.biSizeImage);

        //
        // create 80x60 thumbnail while preserving image
        // aspect ratio
        //

        LONG        lThumbWidth;
        LONG        lThumbHeight;

        double      fImageWidth  = (double)pbmi->bmiHeader.biWidth;
        double      fImageHeight = (double)pbmi->bmiHeader.biHeight;
        double      fAspect      = fImageWidth / fImageHeight;
        double      fDefAspect   = 80.0 / 60.0;

        if (fAspect > fDefAspect) {

            lThumbWidth  = 80;
            lThumbHeight = (LONG)(80.0 / fAspect);
        } else {

            lThumbHeight = 60;
            lThumbWidth  = (LONG)(60.0 * fAspect);
        }

        int i = StretchDIBits(
                    hdcm1,
                    0,
                    0,
                    lThumbWidth,
                    lThumbHeight,
                    0,
                    0,
                    pbmi->bmiHeader.biWidth,
                    pbmi->bmiHeader.biHeight,
                    pPixels,
                    pbmi,
                    DIB_RGB_COLORS,
                    SRCCOPY
                    );

        SelectObject(hdcm1, hbmDef);

        //
        // Cache ?
        //

        if (bCacheThumb) {
            memcpy(pTmbFile, pThumb, bmiDIB.bmiHeader.biSizeImage);
        }

        //
        // Alloca memory for thumbnail pixels
        //
        pTmbPixels = (PBYTE)ALLOC(bmiDIB.bmiHeader.biSizeImage);
        if (! pTmbPixels) {
            return(E_OUTOFMEMORY);
        }

        //
        // Write out data
        //

        memcpy(pTmbPixels, pThumb, bmiDIB.bmiHeader.biSizeImage);
        *pThumbnail = pTmbPixels;
        *pThumbSize = bmiDIB.bmiHeader.biSizeImage;

        return(S_OK);

    } // End of __try { ... } block

    __finally {

        if (pTmbFile) {
            UnmapViewOfFile(pTmbFile);
        }
        if (hTmbMap) {
            CloseHandle(hTmbMap);
        }
        if (hTmbFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hTmbFile);
        }

        if (pFile) {
            UnmapViewOfFile(pFile);
        }
        if (hMap) {
            CloseHandle(hMap);
        }
        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
        }

        if (hbmThumb) {
            DeleteObject(hbmThumb);
        }

        if (hdcm1) {
            DeleteDC(hdcm1);
        }
        if (hdc) {
            ReleaseDC(NULL, hdc);
        }

    }

    return(E_FAIL);
}


/**************************************************************************\
* CamDeletePicture
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    6/3/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
CamDeletePicture(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext)
{
    return(E_NOTIMPL);
}


/**************************************************************************\
* CamTakePicture
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    6/3/1998 Mark Enstrom [marke]
*
\**************************************************************************/
HRESULT
CamTakePicture(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext ,
    ULONG                 *pHandle)
{
    return (E_NOTIMPL);
}

/**************************************************************************\
* VertivalFlip
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

VOID
VerticalFlip(
    PBYTE pImageTop,
    LONG  iHeight,
    LONG  iWidthInBytes)
{
    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,iWidthInBytes);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * iWidthInBytes;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,iWidthInBytes);
            memcpy(pImageTop,pImageBottom,iWidthInBytes);
            memcpy(pImageBottom,pBuffer,iWidthInBytes);

            pImageTop    += iWidthInBytes;
            pImageBottom -= iWidthInBytes;
        }

        LocalFree(pBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testusd.rc
//
#define IDD_EVENT_DLG                   101
#define IDD_GEN_EVENT                   1000
#define IDC_COMBO1                      1001
#define IDC_EDIT1                       1002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\defprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       DefProp.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 July, 1998
*
*  DESCRIPTION:
*   Default property Declarations and definitions for the
*   WIA test scanner.
*
*******************************************************************************/

#include  "tcamprop.h"


#define  NUM_CAP_ENTRIES            5
#define  NUM_EVENTS                 3

#define  PREFFERED_FORMAT_NOM       &WiaImgFmt_BMP
#define  FORMAT_NOM                 &WiaImgFmt_BMP

#define  NUM_CAM_ITEM_PROPS         (19)
#define  NUM_CAM_DEV_PROPS          (17)
#define  NUM_AUDIO_PROPS            (6)

#define  NUM_FORMAT                 2
#define  FORMAT_INDEX               10

#ifdef __GLOBALPROPVARS__

PROPID gAudioPropIDs[NUM_AUDIO_PROPS] =
{

    WIA_IPA_ITEM_TIME,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_ACCESS_RIGHTS,
};

LPOLESTR gAudioPropNames[NUM_AUDIO_PROPS] =
{

    WIA_IPA_ITEM_TIME_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
};

PROPID gItemPropIDs[NUM_CAM_ITEM_PROPS] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPC_THUMBNAIL,
    WIA_IPA_ITEM_TIME,
    WIA_IPC_THUMB_WIDTH,
    WIA_IPC_THUMB_HEIGHT,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_COMPRESSION,
    WIA_IPA_CHANNELS_PER_PIXEL,
    WIA_IPA_BITS_PER_CHANNEL,
    WIA_IPA_PLANAR,
    WIA_IPA_BYTES_PER_LINE,
    WIA_IPA_ACCESS_RIGHTS,
    WIA_IPA_MIN_BUFFER_SIZE
};

LPOLESTR gItemPropNames[NUM_CAM_ITEM_PROPS] =
{
    WIA_IPA_DATATYPE_STR,
    WIA_IPA_DEPTH_STR,
    WIA_IPA_PIXELS_PER_LINE_STR,
    WIA_IPA_NUMBER_OF_LINES_STR,
    WIA_IPC_THUMBNAIL_STR,
    WIA_IPA_ITEM_TIME_STR,
    WIA_IPC_THUMB_WIDTH_STR,
    WIA_IPC_THUMB_HEIGHT_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_COMPRESSION_STR,
    WIA_IPA_CHANNELS_PER_PIXEL_STR,
    WIA_IPA_BITS_PER_CHANNEL_STR,
    WIA_IPA_PLANAR_STR,
    WIA_IPA_BYTES_PER_LINE_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
    WIA_IPA_MIN_BUFFER_SIZE_STR
};

PROPID gItemCameraPropIDs[WIA_NUM_IPC] = {
    WIA_IPC_AUDIO_AVAILABLE,
    WIA_IPC_AUDIO_DATA
};

LPOLESTR gItemCameraPropNames[WIA_NUM_IPC] =
{
    WIA_IPC_AUDIO_AVAILABLE_STR,
    WIA_IPC_AUDIO_DATA_STR,
};

PROPID gDevicePropIDs[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_FIRMWARE_VERSION,
    WIA_DPA_CONNECT_STATUS,
    WIA_DPA_DEVICE_TIME,
    WIA_DPC_PICTURES_TAKEN,
    WIA_DPC_PICTURES_REMAINING,
    WIA_DPC_THUMB_WIDTH,
    WIA_DPC_THUMB_HEIGHT,
    WIA_DPC_PICT_WIDTH,
    WIA_DPC_PICT_HEIGHT,
    WIA_DPC_EXPOSURE_MODE,
    WIA_DPC_FLASH_MODE,
    WIA_DPC_FOCUS_MODE,
    WIA_DPC_ZOOM_POSITION,
    WIA_DPC_BATTERY_STATUS,
    WIA_DPC_TIMER_MODE,
    WIA_DPC_TIMER_VALUE,
    WIA_DPP_TCAM_ROOT_PATH
};

LPOLESTR gDevicePropNames[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_FIRMWARE_VERSION_STR,
    WIA_DPA_CONNECT_STATUS_STR,
    WIA_DPA_DEVICE_TIME_STR,
    WIA_DPC_PICTURES_TAKEN_STR,
    WIA_DPC_PICTURES_REMAINING_STR,
    WIA_DPC_THUMB_WIDTH_STR,
    WIA_DPC_THUMB_HEIGHT_STR,
    WIA_DPC_PICT_WIDTH_STR,
    WIA_DPC_PICT_HEIGHT_STR,
    WIA_DPC_EXPOSURE_MODE_STR,
    WIA_DPC_FLASH_MODE_STR,
    WIA_DPC_FOCUS_MODE_STR,
    WIA_DPC_ZOOM_POSITION_STR,
    WIA_DPC_BATTERY_STATUS_STR,
    WIA_DPC_TIMER_MODE_STR,
    WIA_DPC_TIMER_VALUE_STR,
    WIA_DPP_TCAM_ROOT_PATH_STR
};

PROPSPEC gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS] = {

    {PRSPEC_PROPID, WIA_DPA_FIRMWARE_VERSION},
    {PRSPEC_PROPID, WIA_DPA_CONNECT_STATUS},
    {PRSPEC_PROPID, WIA_DPA_DEVICE_TIME},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_REMAINING},
    {PRSPEC_PROPID, WIA_DPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_EXPOSURE_MODE},
    {PRSPEC_PROPID, WIA_DPC_FLASH_MODE},
    {PRSPEC_PROPID, WIA_DPC_FOCUS_MODE},
    {PRSPEC_PROPID, WIA_DPC_ZOOM_POSITION},
    {PRSPEC_PROPID, WIA_DPC_BATTERY_STATUS},
    {PRSPEC_PROPID, WIA_DPC_TIMER_MODE},
    {PRSPEC_PROPID, WIA_DPC_TIMER_VALUE},
    {PRSPEC_PROPID, WIA_DPP_TCAM_ROOT_PATH}
};

WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS] = {
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_FIRMWARE_VERSION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_CONNECT_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_DEVICE_TIME
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_TAKEN
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_REMAINING
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_EXPOSURE_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FLASH_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FOCUS_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_ZOOM_POSITION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_BATTERY_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_VALUE
    {WIA_PROP_RW   | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}  // WIA_DPP_ROOT_PATH
};

PROPSPEC gPropSpecDefaults[NUM_CAM_ITEM_PROPS] = {
   {PRSPEC_PROPID, WIA_IPA_DATATYPE},
   {PRSPEC_PROPID, WIA_IPA_DEPTH},
   {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
   {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
   {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
   {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
   {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
   {PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
   {PRSPEC_PROPID, WIA_IPA_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_TYMED},
   {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
   {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
   {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL},
   {PRSPEC_PROPID, WIA_IPA_PLANAR},
   {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
   {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
};

#ifdef _WIN64
#define FPTR(x) (LONG_PTR)NULL
#else
#define FPTR(x) x
#endif

PROPSPEC gAudioPropDefaults[NUM_AUDIO_PROPS] =
{

    {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
    {PRSPEC_PROPID,WIA_IPA_PREFERRED_FORMAT},
    {PRSPEC_PROPID,WIA_IPA_ITEM_SIZE},
    {PRSPEC_PROPID,WIA_IPA_FORMAT},
    {PRSPEC_PROPID,WIA_IPA_TYMED},
    {PRSPEC_PROPID,WIA_IPA_ACCESS_RIGHTS},
};

LONG gAudioDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_AUDIO_PROPS)] =
{
    VT_VECTOR | VT_I4, 0, 0, 0,
    VT_CLSID, 0, (LONG)(LONG_PTR)FPTR(&WiaAudFmt_WAV), 0,
    VT_I4, 0, 0, 0,
    VT_CLSID, 0, (LONG)(LONG_PTR)FPTR(&WiaAudFmt_WAV), 0,
    VT_I4, 0, TYMED_FILE, 0,
    VT_I4, 0, WIA_ITEM_RD, 0
};


LONG  gPropVarDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_CAM_ITEM_PROPS)] = {
   // VARTYPE                 reserved    val               pad/array ptr
   (LONG)VT_I4,               0x00000000, WIA_DATA_GRAYSCALE,0x00000000,            // WIA_IPA_DATATYPE
   (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_DEPTH

   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_PIXELS_PER_LINE
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_NUMBER_OF_LINES

   (LONG)VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMBNAIL
   (LONG)VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_TIME
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_WIDTH
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_HEIGHT
   (LONG)VT_CLSID,            0x00000000, (LONG)(LONG_PTR)FPTR(PREFFERED_FORMAT_NOM),0x00000000,    // WIA_IPA_PREFERRED_FORMAT
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_SIZE
   (LONG)VT_CLSID,            0x00000000, (LONG)(LONG_PTR)FPTR(FORMAT_NOM),  0x00000000,            // WIA_IPA_FORMAT
   (LONG)VT_I4,               0x00000000, TYMED_FILE,        0x00000000,            // WIA_IPA_TYMED
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_COMPRESSION
   (LONG)VT_I4,               0x00000000, 3,                 0x00000000,            // WIA_IPA_CHANNELS PER PIXEL
   (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_BITS PER CHANNEL
   (LONG)VT_I4,               0x00000000, WIA_PACKED_PIXEL,  0x00000000,            // WIA_IPA_PLANAR
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_WIDTH IN BYTES
   (LONG)VT_I4,               0x00000000, WIA_ITEM_RD,       0x00000000,             // WIA_IPA_ACCESS_RIGHTS

   (LONG)VT_I4,               0x00000000, 65535,             0x00000000,            // WIA_IPA_MIN_BUFFER_SIZE
};


// Default device extended properties.

#define NUM_DATATYPE 3
LONG lDataTypes[NUM_DATATYPE] = {
    WIA_DATA_THRESHOLD,
    WIA_DATA_GRAYSCALE,
    WIA_DATA_COLOR
};

#define NUM_DEPTH 3
LONG lDepths[NUM_DEPTH] = {
    1,
    8,
    24
};


GUID gGuidFormats[NUM_FORMAT];   // FormatID's specified in pguidFormats are copied to gGuidFormats
                                  // during SetFormatAttribs

//
//  This is an array of WIA_FORMAT_INFOs, describing the different formats
//  and their corresponding media types.  Initialized in minidrvr.cpp
//

WIA_FORMAT_INFO  *g_wfiTable = NULL;

//
//  Different media types supported
//

#define NUM_TYMED  2
LONG lTymeds [NUM_TYMED]= {
    TYMED_FILE,
    TYMED_CALLBACK,
};

//
// Extended information for each property
//

WIA_PROPERTY_INFO  gItemPropInfos[NUM_CAM_ITEM_PROPS] = {

    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DATATYPE, WIA_DATA_GRAYSCALE, (LONG)FPTR( lDataTypes), 0}, // WIA_IPA_DATATYPE
    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DEPTH,    8,                  (LONG)FPTR( lDepths),    0}, // WIA_IPA_DEPTH

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PIXELS_PER_LINE
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_NUMBER_OF_LINES
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMBNAIL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_TIME
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_PREFERRED_FORMAT, set later
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_SIZE

    {WIA_PROP_RW   | WIA_PROP_LIST, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_FORMAT, set later
    {WIA_PROP_RW   | WIA_PROP_LIST, VT_I4,    NUM_TYMED,    TYMED_FILE, (LONG)FPTR(lTymeds),     0}, // WIA_IPA_TYMED
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_COMPRESSION
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_CHANNELS
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BITS_PER_CHANNEL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PLANAR
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BYTES_PER_LINE
    {WIA_PROP_RW   | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ACCESS_RIGHTS

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_MIN_BUFFER_SIZE

};

//
// Device capabilities.  Events are listed before commands to simplify the
// implementation of drvGetCapabilities(...)
//

#define N   WIA_NOTIFICATION_EVENT
#define A   WIA_ACTION_EVENT
#define NA  (WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT)

WIA_DEV_CAP_DRV gCapabilities[NUM_CAP_ENTRIES] =
{
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,    NA, L"Device connected",    L"Device connected",    WIA_ICON_DEVICE_CONNECTED},
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED, N,  L"Device disconnected", L"Device disconnected", WIA_ICON_DEVICE_DISCONNECTED},
    {(GUID *)&WIA_EVENT_NAME_CHANGE,         NA, L"Root path changed",   L"Root path changed",   WIA_ICON_ITEM_CREATED},
    {(GUID *)&WIA_CMD_SYNCHRONIZE,           0,  L"Synchronize",         L"Synchronize",         WIA_ICON_SYNCHRONIZE},
    {(GUID *)&WIA_CMD_TAKE_PICTURE,          0,  L"Take a new picture",  L"Take a new picture",  WIA_ICON_TAKE_PICTURE}
};

#else

extern PROPID               gItemPropIDs[NUM_CAM_ITEM_PROPS];
extern LPOLESTR             gItemPropNames[NUM_CAM_ITEM_PROPS];
extern PROPID               gItemCameraPropIDs[WIA_NUM_IPC];
extern LPOLESTR             gItemCameraPropNames[WIA_NUM_IPC];
extern PROPID               gDevicePropIDs[NUM_CAM_DEV_PROPS];
extern LPOLESTR             gDevicePropNames[NUM_CAM_DEV_PROPS];
extern PROPSPEC             gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS];
extern WIA_PROPERTY_INFO    gDevPropInfoDefaults[NUM_CAM_DEV_PROPS];
extern PROPSPEC             gPropSpecDefaults[NUM_CAM_ITEM_PROPS];
extern LONG                 gPropVarDefaults[];
extern WIA_PROPERTY_INFO    gItemPropInfos[NUM_CAM_ITEM_PROPS];
extern WIA_DEV_CAP_DRV      gCapabilities[];
extern GUID                 gGuidFormats[NUM_FORMAT];
extern PROPID               gAudioPropIDs[NUM_AUDIO_PROPS];
extern LPOLESTR             gAudioPropNames[NUM_AUDIO_PROPS];
extern PROPSPEC             gAudioPropDefaults [];
extern LONG                 gAudioDefaults [];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\camopen.cpp ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    camopen.cpp

Abstract:

    Enumerate disk images to emulate camera

Author:

    Mark Enstrom (marke) 1/13/1999


Environment:

    user mode

Revision History:

--*/

#include <stdio.h>
#include <objbase.h>
#include <tchar.h>
#include "sti.h"
#include "testusd.h"

extern HINSTANCE g_hInst; // Global hInstance

#define  __GLOBALPROPVARS__

#include "defprop.h"

/**************************************************************************\
* CamOpenCamera
*
*   Load the camera driver
*
* Arguments:
*
*   pGenericStatus    -    camera status
*
* Return Value:
*
*   status
*
* History:
*
*    2/5/1998        Mark Enstrom [marke]
*
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamOpenCamera(
    CAMERA_STATUS *pGenericStatus
    )
{
    HRESULT  hr = S_OK;

    WIAS_TRACE((g_hInst,"CamOpenCamera"));

    //
    // init memory camera
    //

    pGenericStatus->FirmwareVersion            = 0x00000001;
    pGenericStatus->NumPictTaken               = 20;
    pGenericStatus->NumPictRemaining           = 0;
    pGenericStatus->ThumbWidth                 = 80;
    pGenericStatus->ThumbHeight                = 60;
    pGenericStatus->PictWidth                  = 300;
    pGenericStatus->PictHeight                 = 300;
    pGenericStatus->CameraTime.wSecond         = 30;
    pGenericStatus->CameraTime.wMinute         = 20;
    pGenericStatus->CameraTime.wHour           = 13;
    pGenericStatus->CameraTime.wDay            = 13;
    pGenericStatus->CameraTime.wMonth          = 2;
    pGenericStatus->CameraTime.wYear           = 98;
    pGenericStatus->CameraTime.wDayOfWeek      = 6;
    pGenericStatus->CameraTime.wMilliseconds   = 1;

    return(hr);
}


/**************************************************************************\
* CamBuildImageTree
*
*    Build the tree of camera images by enumerating a disk directory
*
* Arguments:
*
*    pCamStatus  -    device status
*    ppRootItem  -    return new root of item tree
*
* Return Value:
*
*    status
*
* History:
*
*    6/26/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamBuildImageTree(
    CAMERA_STATUS   *pCamStatus,
    IWiaDrvItem    **ppRootItem)
{
    HRESULT          hr = S_OK;

    WIAS_TRACE((g_hInst,"CamBuildImageTree"));

    //
    // Create the new root
    //

    BSTR bstrRoot = SysAllocString(L"Root");

    if (bstrRoot == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // Call Wia service library to create new root item
    //

    hr = wiasCreateDrvItem(
             WiaItemTypeFolder | WiaItemTypeRoot | WiaItemTypeDevice,
             bstrRoot,
             m_bstrRootFullItemName,
             (IWiaMiniDrv *)this,
             sizeof(MEMCAM_IMAGE_CONTEXT),
             NULL,
             ppRootItem);

    SysFreeString(bstrRoot);

    if (FAILED(hr)) {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, CreateDeviceItem failed"));
        return hr;
    }

    //
    // Enumerate throught the root directory
    //

    hr = EnumDiskImages(*ppRootItem, gpszPath);

    return (hr);
}

/**************************************************************************\

   FindExtension

**************************************************************************/

LPTSTR
FindExtension (LPTSTR pszPath)
{

    LPTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = CharNext(pszPath))
        {
            switch (*pszPath)
            {
                case TEXT('.'):
                    pszDot = pszPath;   // remember the last dot
                    break;

                case '\\':
                case TEXT(' '):         // extensions can't have spaces
                    pszDot = NULL;      // forget last dot, it was in a directory
                    break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension)
    return pszDot ? pszDot : pszPath;
}

/**************************************************************************\
* EnumDiskImages
*
*   Walk through disk looking for BMP and WAV files to use as camera images
*
* Arguments:
*
*   pRootItem
*   pwszDirName
*
* Return Value:
*
*   status
*
* History:
*
*    2/17/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::EnumDiskImages(
    IWiaDrvItem     *pRootItem,
    LPTSTR           pszDirName)
{
    HRESULT          hr = E_FAIL;
    WIN32_FIND_DATA  FindData;
    PTCHAR           pTempName = (PTCHAR)ALLOC(MAX_PATH);

    WIAS_TRACE((g_hInst,"EnumDiskImages"));

    if (pTempName != NULL) {

        HANDLE hFile;
        _tcscpy(pTempName, pszDirName);
        _tcscat(pTempName, TEXT("\\*.*"));

        //
        // look for image,audio files and directories at this level
        //

        hFile = FindFirstFile(pTempName, &FindData);

        if (hFile != INVALID_HANDLE_VALUE) {
            BOOL bStatus;
            do
            {

                _tcscpy(pTempName, pszDirName);
                _tcscat(pTempName, TEXT("\\"));
                _tcscat(pTempName, FindData.cFileName);

                if ( (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    && lstrcmp(FindData.cFileName, TEXT("."))
                     && lstrcmp(FindData.cFileName, TEXT("..")))

                {
                    //
                    // create a new folder for the sub-directory
                    //
                    IWiaDrvItem *pNewFolder;

                    hr = CreateItemFromFileName(
                        WiaItemTypeFolder,
                        pTempName,
                        FindData.cFileName,
                        &pNewFolder);

                    if (SUCCEEDED(hr)) {

                        hr = pNewFolder->AddItemToFolder(pRootItem);


                        if (hr == S_OK) {
                            //
                            // enumerate sub-folder
                            //

                            EnumDiskImages(pNewFolder, pTempName);
                        }
                        pNewFolder->Release();
                    }
                }
                else
                {
                    LONG lType = WiaItemTypeFile;
                    //
                    // add an image to this folder
                    //
                    // generate file name
                    //
                    //
                    // Create a new DrvItem for this image and add it to the
                    // DrvItem tree.
                    //
                    LPTSTR pExt = FindExtension (FindData.cFileName);
                    if (!lstrcmpi(pExt, TEXT(".bmp")))
                    {
                        lType |= WiaItemTypeImage;
                    }
                    else if (!lstrcmpi(pExt,TEXT(".wav")))
                    {
                        lType |= WiaItemTypeAudio;
                    }
                    else
                    {
                        lType = 0;
                    }
                    if (lType)
                    {

                        IWiaDrvItem *pNewFolder;

                        hr = CreateItemFromFileName(
                            lType,
                            pTempName,
                            FindData.cFileName,
                            &pNewFolder);


                        if (SUCCEEDED(hr)) {
                            pNewFolder->AddItemToFolder(pRootItem);

                            pNewFolder->Release();
                        }
                    }
                }

                bStatus = FindNextFile(hFile,&FindData);

            } while (bStatus);

            FindClose(hFile);
        }
        FREE(pTempName);
    }

    return (S_OK);
}


/**************************************************************************\
* CreateItemFromFileName
*
*    helper funtion to create dev items and names
*
* Arguments:
*
*    FolderType    -    type of item to create
*    pszPath        -    complete path name
*    pszName        -    file name
*    ppNewFolder    -    return new item
*
* Return Value:
*
*   status
*
* History:
*
*    1/17/1999 Mark Enstrom [marke]
*
\**************************************************************************/


HRESULT
TestUsdDevice::CreateItemFromFileName(
    LONG             FolderType,
    PTCHAR           pszPath,
    PTCHAR           pszName,
    IWiaDrvItem    **ppNewFolder
    )
{
    HRESULT          hr = S_OK;
    IWiaDrvItem     *pNewFolder;
    WCHAR            szFullItemName[MAX_PATH];
    WCHAR            szTemp[MAX_PATH];
    BSTR             bstrItemName;
    BSTR             bstrFullItemName;

    WIAS_TRACE((g_hInst,"CreateItemFromFileName"));

    *ppNewFolder = NULL;

    //
    // convert path to wide char
    //

#ifndef UNICODE
    MultiByteToWideChar(
        CP_ACP,
        0,
        pszPath + strlen(gpszPath),
        -1,
        szTemp, MAX_PATH);

#else
    wcscpy(szTemp, pszPath + wcslen(gpszPath));
#endif
    if (FolderType & ~WiaItemTypeFolder) {
        szTemp[_tcslen(pszPath) - _tcslen(gpszPath) - 4] = 0;
    }

    wcscpy(szFullItemName, m_bstrRootFullItemName);
    wcscat(szFullItemName, szTemp);

    //
    // convert item name to wide char
    //

#ifndef UNICODE
    MultiByteToWideChar(
        CP_ACP, 0, pszName, -1,  szTemp, MAX_PATH);
#else
    wcscpy(szTemp, pszName);
#endif
    if (FolderType & ~WiaItemTypeFolder) {
        szTemp[_tcslen(pszName)-4] = 0;
    }

    bstrItemName = SysAllocString(szTemp);

    if (bstrItemName) {

        bstrFullItemName = SysAllocString(szFullItemName);

        if (bstrFullItemName) {

            //
            // call Wia to create new DrvItem
            //

            PMEMCAM_IMAGE_CONTEXT pContext;

            hr = wiasCreateDrvItem(
                     FolderType,
                     bstrItemName,
                     bstrFullItemName,
                     (IWiaMiniDrv *)this,
                     sizeof(MEMCAM_IMAGE_CONTEXT),
                     (BYTE **)&pContext,
                     &pNewFolder);

            if (hr == S_OK) {

                //
                // init device specific context (image path)
                //

                pContext->pszCameraImagePath = _tcsdup(pszPath);

            } else {
                WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, wiasCreateDrvItem failed"));
            }

            SysFreeString(bstrFullItemName);
        }
        else {
            WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate full item name"));
            hr = E_OUTOFMEMORY;
        }

        SysFreeString(bstrItemName);
    }
    else {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate item name"));
        hr = E_OUTOFMEMORY;
    }

    //
    // assign output value or cleanup
    //

    if (hr == S_OK) {
        *ppNewFolder = pNewFolder;
    } else {
        //
        // delete item
        //
    }

    return hr;
}

/**************************************************************************\
* GetItemSize
*
*   call wias to calc new item size
*
* Arguments:
*
*   pWiasContext       - item
*   pItemSize   - return size of item
*
* Return Value:
*
*    Status
*
* History:
*
*    4/21/1999 Original Version
*
\**************************************************************************/

HRESULT
SetItemSize(BYTE*   pWiasContext)
{
    HRESULT                    hr;
    MINIDRV_TRANSFER_CONTEXT   drvTranCtx;

    memset(&drvTranCtx, 0, sizeof(MINIDRV_TRANSFER_CONTEXT));

    GUID guidFormatID;

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, (GUID*)&drvTranCtx.guidFormatID, NULL, FALSE);
    if (FAILED(hr)) {
        return hr;
    }

    hr = wiasReadPropLong(pWiasContext, WIA_IPA_TYMED, (LONG*)&drvTranCtx.tymed, NULL, false);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // wias works for DIB,TIFF formats
    //
    // driver doesn't support JPEG
    //

    hr = wiasGetImageInformation(pWiasContext,
                                 WIAS_INIT_CONTEXT,
                                 &drvTranCtx);

    if (hr == S_OK) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, drvTranCtx.lItemSize);
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_BYTES_PER_LINE, drvTranCtx.cbWidthInBytes);
    }

    return hr;
}

/**************************************************************************\
* InitImageInformation
*
*    Init image properties
*
* Arguments:
*
*    pFile                 MINI_DEV_OBJECT to support item
*    pszCameraImagePath    path and name of bmp file
*
* Return Value:
*
*   Status
*
* History:
*
*    2/12/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::InitImageInformation(
    BYTE                   *pWiasContext,
    PMEMCAM_IMAGE_CONTEXT   pContext,
    LONG                   *plDevErrVal)
{
    HRESULT                  hr = S_OK;
    CAMERA_PICTURE_INFO      camInfo;
    PBITMAPINFO              pBitmapinfo   = NULL;
    LONG                     szBitmapInfo  = 0;
    int                      i;
    PROPVARIANT              propVar;

    WIAS_TRACE((g_hInst,"InitImageInformation"));

    //
    // GET image info
    //

    hr = CamGetPictureInfo(
             pContext, &camInfo, (PBYTE*)&pBitmapinfo, &szBitmapInfo);

    if (hr != S_OK) {

        if (pBitmapinfo != NULL) {
            FREE(pBitmapinfo);
        }

        return (hr);
    }


    //
    // Use WIA services to write image properties.
    //

    wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_WIDTH, camInfo.ThumbWidth);
    wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_HEIGHT, camInfo.ThumbHeight);

    wiasWritePropLong(
        pWiasContext, WIA_IPA_PIXELS_PER_LINE, pBitmapinfo->bmiHeader.biWidth);
    wiasWritePropLong(
        pWiasContext, WIA_IPA_NUMBER_OF_LINES, pBitmapinfo->bmiHeader.biHeight);



    wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, WiaImgFmt_BMP);

    wiasWritePropLong(
        pWiasContext, WIA_IPA_DEPTH, pBitmapinfo->bmiHeader.biBitCount);

    wiasWritePropBin(
        pWiasContext, WIA_IPA_ITEM_TIME,
        sizeof(SYSTEMTIME), (PBYTE)&camInfo.TimeStamp);

    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);

    //
    // Free the BITMAPINFO
    //

    FREE(pBitmapinfo);

    //
    // calc item size
    //

    hr = SetItemSize(pWiasContext);

    //
    // load thumbnail
    //

    PBYTE pThumb;
    LONG  lSize;

    hr = CamLoadThumbnail(pContext, &pThumb, &lSize);

    if (hr == S_OK) {

        //
        // write thumb property
        //

        PROPSPEC    propSpec;
        PROPVARIANT propVar;

        propVar.vt          = VT_VECTOR | VT_UI1;
        propVar.caub.cElems = lSize;
        propVar.caub.pElems = pThumb;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPC_THUMBNAIL;

        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);

        FREE(pThumb);
    }

    hr = SetFormatAttribs();
    if (FAILED(hr)) {
        return (hr);
    }

    //
    // Use WIA services to set the extended property access and
    // valid value information from gItemPropInfos.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_ITEM_PROPS,
                                 gPropSpecDefaults,
                                 gItemPropInfos);
    return (hr);
}

HRESULT
TestUsdDevice::InitAudioInformation(
    BYTE                   *pWiasContext,
    PMEMCAM_IMAGE_CONTEXT   pContext,
    LONG                   *plDevErrVal)
{
    HRESULT                  hr = E_FAIL;
    WIN32_FILE_ATTRIBUTE_DATA wfd;

    if (GetFileAttributesEx (pContext->pszCameraImagePath, GetFileExInfoStandard, &wfd))
    {
        SYSTEMTIME st;
        FileTimeToSystemTime (&wfd.ftLastWriteTime, &st);
        wiasWritePropLong (pWiasContext, WIA_IPA_ITEM_SIZE, wfd.nFileSizeLow);
        wiasWritePropBin (pWiasContext, WIA_IPA_ITEM_TIME, sizeof(SYSTEMTIME),
                          (PBYTE)&st);
        hr = S_OK;

    }
    return hr;

}

/**************************************************************************\
* SetFormatAttribs
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/5/2000 Original Version
*
\**************************************************************************/

HRESULT
SetFormatAttribs()
{
    gItemPropInfos[FORMAT_INDEX].lAccessFlags = WIA_PROP_RW | WIA_PROP_LIST;
    gItemPropInfos[FORMAT_INDEX].vt           = VT_CLSID;

    gItemPropInfos[FORMAT_INDEX].ValidVal.ListGuid.cNumList = NUM_FORMAT;
    gItemPropInfos[FORMAT_INDEX].ValidVal.ListGuid.pList    = gGuidFormats;

    //
    // Set the norm
    //

    gItemPropInfos[FORMAT_INDEX].ValidVal.ListGuid.Nom      = WiaImgFmt_BMP;

    //
    // Set up the format clsid list
    //

    gGuidFormats[0] = WiaImgFmt_BMP;
    gGuidFormats[1] = WiaImgFmt_MEMORYBMP;

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\testusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TestUsd.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        5 Jan, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#define INITGUID

#include "testusd.h"
#include "resource.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.

// Can we use UNICODE APIs
//BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

// Debugging interface, has TestUsdClassFactory lifetime.
WIA_DECLARE_DEBUGGER();

/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  TestUsdClassFactory
*
\****************************************************************************/

class TestUsdClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    TestUsdClassFactory();
    ~TestUsdClassFactory();
};

/**************************************************************************\
* TestUsdClassFactory::TestUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdClassFactory::TestUsdClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_TRACE((g_hInst,"Creating TestUsdClassFactory"));
}

/**************************************************************************\
* TestUsdClassFactory::~TestUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdClassFactory::~TestUsdClassFactory(void)
{
    // Destructor logic
    WIAS_TRACE((g_hInst,"Destroying TestUsdClassFactory"));
}

/**************************************************************************\
* TestUsdClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR  *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* TestUsdClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* TestUsdClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* TestUsdClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                       riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{

    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IWiaItem) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    TestUsdDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new TestUsdDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* TestUsdClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::NonDelegatingQueryInterface(
    REFIID   riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* TestUsdDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* TestUsdDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* TestUsdDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C"
BOOL APIENTRY
DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {
                OutputDebugStringA("TestUsd: Unloaded before all objects releaseed!\n");
            }
            
            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_TestUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_TestUsd)) {
        TestUsdClassFactory *pcf = new TestUsdClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\miniitem.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       MiniItem.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      marke
*
*  DATE:        30 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of the WIA test camera item methods.
*
*******************************************************************************/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#ifdef TEST_PER_USER_DATA
#ifdef UNICODE
#include <userenv.h>
#endif
#endif

#include "testusd.h"

#include "defprop.h"

extern HINSTANCE g_hInst; // Global hInstance

/*******************************************************************************
*
*  ValidateDataTransferContext
*
*  DESCRIPTION:
*    Validate the data transfer context.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT
ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext)
{
   if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
      WIAS_ERROR((g_hInst,"ValidateDataTransferContext, invalid data transfer context"));
      return E_INVALIDARG;;
   }

   //
   // for tymed file or hglobal, only WiaImgFmt_MEMORYBMP is allowed
   //

   if ((pDataTransferContext->tymed == TYMED_FILE) ||
       (pDataTransferContext->tymed == TYMED_HGLOBAL)) {

       if (pDataTransferContext->guidFormatID != WiaImgFmt_BMP && pDataTransferContext->guidFormatID != WiaAudFmt_WAV) {
          WIAS_ERROR((g_hInst,"ValidateDataTransferContext, invalid format"));
          return E_INVALIDARG;;
       }

   }

   //
   // for tymed CALLBACK, only WiaImgFmt_MEMORYBMP is allowed
   //

   if (pDataTransferContext->tymed == TYMED_CALLBACK) {

       if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
           (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP)) {
          WIAS_ERROR((g_hInst,"AcquireDeviceData, invalid format"));
          return E_INVALIDARG;;
       }
   }


   //
   // callback is always double buffered, non-callback never is
   //

   if (pDataTransferContext->pTransferBuffer == NULL) {
       WIAS_ERROR((g_hInst, "AcquireDeviceData, invalid transfer buffer"));
       return E_INVALIDARG;
   }

   return S_OK;
}


/**************************************************************************\
* SendBitmapHeader
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT SendBitmapHeader(
    IWiaDrvItem                *pDrvItem,
    PMINIDRV_TRANSFER_CONTEXT   pTranCtx)
{
    HRESULT hr;

    WIAS_ASSERT(g_hInst, pDrvItem != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx->tymed == TYMED_CALLBACK);

    //
    // driver is sending TOPDOWN data, must swap biHeight
    //
    // this routine assumes pTranCtx->pHeader points to a
    // BITMAPINFO header (TYMED_FILE doesn't use this path
    // and DIB is the only format supported now)
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pTranCtx->pTransferBuffer;

    if (pTranCtx->guidFormatID == WiaImgFmt_MEMORYBMP) {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
    }

    hr = pTranCtx->
            pIWiaMiniDrvCallBack->
                MiniDrvCallback(
                    IT_MSG_DATA,
                    IT_STATUS_TRANSFER_TO_CLIENT,
                    0,
                    0,
                    pTranCtx->lHeaderSize,
                    pTranCtx,
                    0);

    if (hr == S_OK) {

        //
        // advance offset for destination copy
        //

        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvDeleteItem
*
*   Try to delete a device item. Device items for the test scanner may
*   not be modified.
*
* Arguments:
*
*   pWiasContext    -   The context of the item to delete
*   lFlags          -   unused
*   plDevErrVal     -   unused
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvDeleteItem(
    BYTE*       pWiasContext,
    LONG        lFlags,
    LONG*       plDevErrVal)
{
    *plDevErrVal = 0;
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* TestUsdDevice::drvAcquireItemData
*
*   Scan data into buffer. This routine scans the entire contents into
*   the destination buffer in one call. Status will be sent back if
*   the callback routine is provided
*
* Arguments:
*
*   pWiasContext    - identifies ITEM context
*   lFlags          - unused
*   pTranCtx        - buffer and callback information
*   plDevErrVal     - error value
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pTranCtx,
    LONG                        *plDevErrVal)
{
    HRESULT                     hr;
// #define TEST_PER_USER_DATA 1
#ifdef TEST_PER_USER_DATA
#ifdef UNICODE
    BOOL                        bRet;
    TCHAR                       tszUserName[MAX_PATH];
    DWORD                       dwBufSize;
    HANDLE                      hToken;
    PROFILEINFO                 profileInfo;
    LONG                        lRet;
    HKEY                        hKeyCurUser;
#endif
#endif

    *plDevErrVal = 0;

    //
    // How to access per user setting in the USD
    //

#ifdef TEST_PER_USER_DATA
#ifdef UNICODE
#ifdef DEBUG

    dwBufSize = MAX_PATH;
    bRet = GetUserName(tszUserName, &dwBufSize);
#endif
#endif
#endif

#ifdef TEST_PER_USER_DATA
#ifdef UNICODE

    hToken = NULL;

    __try {

        hr = CoImpersonateClient();
        if (FAILED(hr)) {
            __leave;
        }

#ifdef NEED_USER_PROFILE

        bRet = OpenThreadToken(
                   GetCurrentThread(),
                   TOKEN_ALL_ACCESS,
                   TRUE,
                   &hToken);

        if (! bRet) {

            __leave;
        }

        //
        // Get the client's user name
        //

        dwBufSize = MAX_PATH;
        bRet = GetUserName(tszUserName, &dwBufSize);

        //
        // Revert to system account
        //

        hr = CoRevertToSelf();
        if (FAILED(hr)) {
            __leave;
        }
        hr = S_FALSE;

        //
        // Load the user profile
        //

        ZeroMemory(&profileInfo, sizeof(profileInfo));
        profileInfo.dwSize     = sizeof(profileInfo);
        profileInfo.dwFlags    = PI_NOUI;
        profileInfo.lpUserName = tszUserName;

        bRet = LoadUserProfile(hToken, &profileInfo);
        if (! bRet) {
            __leave;
        }

        //
        // Access user portion of the registry
        //
        // Use profileInfo.hProfile instead of HKEY_CURRENT_USER
        //
        //

        hKeyCurUser = (HKEY)profileInfo.hProfile;
#else

        lRet = RegOpenCurrentUser(KEY_ALL_ACCESS, &hKeyCurUser);
        if (lRet != ERROR_SUCCESS) {
            __leave;
        }

#endif

        HKEY  hKeyEnv;

        lRet = RegOpenKey(
                   hKeyCurUser,
                   TEXT("Environment"),
                   &hKeyEnv);
        if (lRet == ERROR_SUCCESS) {
            RegCloseKey(hKeyEnv);
        }
    }
    __finally {

        if (hr == S_OK) {

            CoRevertToSelf();
        }

#ifdef NEED_USER_PROFILE

        if (bRet) {

            UnloadUserProfile(hToken, profileInfo.hProfile);
        }

        if (hToken) {

            CloseHandle(hToken);
        }
#else

        if (hKeyCurUser) {

            RegCloseKey(hKeyCurUser);
        }
#endif
    }

#endif
#endif

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pTranCtx);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // get item specific driver data
    //

    MEMCAM_IMAGE_CONTEXT  *pMCamContext;

    pDrvItem->GetDeviceSpecContext((BYTE **)&pMCamContext);

    if (!pMCamContext) {
        WIAS_ERROR((g_hInst,"drvAcquireItemData, NULL item context"));
        return E_POINTER;
    }

    //
    // Use WIA services to fetch format specific info.
    //

    if (!IsEqualGUID (pTranCtx->guidFormatID, WiaAudFmt_WAV) )
    {
        hr = wiasGetImageInformation(pWiasContext,
                                 0,
                                 pTranCtx);
    }
    else
    {

        WIN32_FILE_ATTRIBUTE_DATA wfd;
        GetFileAttributesEx (pMCamContext->pszCameraImagePath,GetFileExInfoStandard, &wfd);
        pTranCtx->lItemSize = (LONG)wfd.nFileSizeLow;
    }


    if (hr != S_OK) {
        return hr;
    }

    //
    // determine if this is a callback or buffered transfer
    //

    if (pTranCtx->tymed == TYMED_CALLBACK) {

        //
        // For formats that have a data header, send it to the client
        //

        if (pTranCtx->lHeaderSize > 0) {

            hr = SendBitmapHeader(
                     pDrvItem,
                     pTranCtx);
        }

        if (hr == S_OK) {
            hr = CamLoadPictureCB(
                     pMCamContext,
                     pTranCtx,
                     plDevErrVal);
        }

    } else {

        //
        // inc past header
        //

        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

        hr = CamLoadPicture(
                 pMCamContext,
                 pTranCtx,
                 plDevErrVal);

    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvInitItemProperties
*
*   Initialize the device item properties.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item context.
*   lFLags          - unused
*   plDevErrVal     - pointer to hardware error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvInitItemProperties(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    HRESULT                  hr;
    LONG                     lItemType;
    PMEMCAM_IMAGE_CONTEXT    pContext;

    //
    // This device doesn't touch hardware to initialize the
    // device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if (!pWiasContext) {
        WIAS_ERROR((g_hInst,"drvInitItemProperties, invalid input pointers"));
        return (E_INVALIDARG);
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Root item has the all the device properties
    //

    hr = pDrvItem->GetItemFlags(&lItemType);
    if (FAILED(hr)) {
        return (hr);
    }

    if (lItemType & WiaItemTypeRoot) {

        // Root item property init finishes here
        return (InitDeviceProperties(pWiasContext,
                                     plDevErrVal));
    }

    //
    // If this is a file, init the properties
    //

    if (lItemType & WiaItemTypeImage) {

        //
        // Add the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_CAM_ITEM_PROPS,
                                  gItemPropIDs,
                                  gItemPropNames);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, wiasSetItemPropNames() failed"));
            return (hr);
        }

        //
        // Use WIA services to set the defaul item properties.
        //


        hr = wiasWriteMultiple(pWiasContext,
                               NUM_CAM_ITEM_PROPS,
                               gPropSpecDefaults,
                               (PROPVARIANT*)gPropVarDefaults);

        if (FAILED(hr)) {
            return (hr);
        }

        hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, GetDeviceSpecContext failed"));
            return (hr);
        }

        hr = InitImageInformation(pWiasContext,
                                  pContext,
                                  plDevErrVal);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties InitImageInformation() failed"));
            return (hr);
        }

    }
    else if (lItemType & WiaItemTypeAudio)
    {
        //
        // Add the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_AUDIO_PROPS,
                                  gAudioPropIDs,
                                  gAudioPropNames);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, wiasSetItemPropNames() failed"));
            return (hr);
        }

        //
        // Use WIA services to set the defaul item properties.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               NUM_AUDIO_PROPS,
                               gAudioPropDefaults,
                               (PROPVARIANT*)gAudioDefaults);

        if (FAILED(hr)) {
            return (hr);
        }

        hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, GetDeviceSpecContext failed"));
            return (hr);
        }
        hr = InitAudioInformation (pWiasContext,
                                   pContext,
                                   plDevErrVal);
    }


    return (S_OK);
}

/**************************************************************************\
* TestUsdDevice::drvValidateItemProperties
*
*   Validate the device item properties.
*
* Arguments:
*
*   pWiasContext    - wia item context
*   lFlags          - unused
*   nPropSpec       -
*   pPropSpec       -
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvValidateItemProperties(
    BYTE                *pWiasContext,
    LONG                lFlags,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec,
    LONG                *plDevErrVal)
{
    //
    // This device doesn't touch hardware to validate the device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if (!pWiasContext || !pPropSpec) {
        WIAS_ERROR((g_hInst,"drvValidateItemProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // validate size
    //

    HRESULT hr = S_OK;

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    LONG lItemType;

    hr = pDrvItem->GetItemFlags(&lItemType);

    if (hr == S_OK) {

        if (lItemType & WiaItemTypeImage) {

            //
            // calc item size
            //

            hr = SetItemSize(pWiasContext);

            //
            //  Change MinBufferSize property.  Need to get Tymed and
            //  ItemSize first, since MinBufferSize in dependant on these
            //  properties.
            //

            LONG        lTymed;
            LONG        lItemSize;
            LONG        lMinBufSize = 0;
            HRESULT     hr = S_OK;

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_TYMED, &lTymed, NULL, TRUE);
            if (FAILED(hr)) {
                WIAS_ERROR((g_hInst,"drvValidateItemProperties, could not read TYMED property"));
                return hr;
            }

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_ITEM_SIZE, &lItemSize, NULL, TRUE);
            if (SUCCEEDED(hr)) {

                //
                //  Update the MinBufferSize property.
                //

                switch (lTymed) {
                    case TYMED_CALLBACK:
                        lMinBufSize = 65535;
                        break;

                    default:
                        lMinBufSize = lItemSize;
                }
                if (lMinBufSize) {
                    hr = wiasWritePropLong(pWiasContext, WIA_IPA_MIN_BUFFER_SIZE, lMinBufSize);
                    if (FAILED(hr)) {
                        WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not write value for WIA_IPA_MIN_BUFFER_SIZE"));
                    }
                }
            } else {
                WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not read value for ItemSize"));
            }

        } else if (lItemType & WiaItemTypeRoot) {

            //
            // Find out whether the Root Path property is changed
            //

            for (ULONG i = 0; i < nPropSpec; i++) {

                if (((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                          (pPropSpec[i].propid == WIA_DPP_TCAM_ROOT_PATH)) ||
                    ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) &&
                          (wcscmp(pPropSpec[i].lpwstr, WIA_DPP_TCAM_ROOT_PATH_STR) == 0))) {

                    BSTR   bstrRootPath;

                    //
                    // Retrieve the new value for Root Path property
                    //

                    hr = wiasReadPropStr(
                             pWiasContext,
                             WIA_DPP_TCAM_ROOT_PATH,
                             &bstrRootPath,
                             NULL,
                             TRUE);
                    if (FAILED(hr)) {
                        return (hr);
                    }

#ifdef UNICODE
                    wcscpy(gpszPath, bstrRootPath);
#else
                    wcstombs(gpszPath, bstrRootPath, MAX_PATH);
#endif
                    //
                    // Release the Root Path bstr
                    //

                    SysFreeString(bstrRootPath);

                    //
                    // Rebuild the item tree and send event notification
                    //

                    hr = DeleteDeviceItemTree(plDevErrVal);
                    if (FAILED(hr)) {
                        break;
                    }

                    hr = BuildDeviceItemTree(plDevErrVal);
                    if (FAILED(hr)) {
                        break;
                    }

                    m_guidLastEvent = WIA_EVENT_DEVICE_CONNECTED;
                    SetEvent(m_hSignalEvent);

                    break;
                }
            }
        }
    }

    return (hr);
}

/**************************************************************************\
* TestUsdDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.
*
* Arguments:
*
*   pWiasContext    - the corresponding wia item context
*   pmdtc           - pointer to mini driver context
*   pFlags          - unused
*   plDevErrVal     - the device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvWriteItemProperties(
    BYTE                       *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                       *plDevErrVal)
{
    //
    // Assume no device hardware errors.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if ((! pWiasContext) || (! pmdtc)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    HRESULT hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    PMEMCAM_IMAGE_CONTEXT pItemContext;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, NULL item context"));
        return E_POINTER;
    }

    //
    // Write the device item properties to the hardware here.
    //

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvReadItemProperties
*
*   Read the device item properties from the hardware.
*
* Arguments:
*
*   pWiasContext    - wia item context
*   lFlags          - unused
*   nPropSpec       -
*   pPropSpec       -
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvReadItemProperties(
    BYTE            *pWiasContext,
    LONG                lFlags,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec,
    LONG                *plDevErrVal)
{
    // For most scanner devices, item properties are stored in the driver
    // and written out at acquire image time. Some devices support properties
    // which should be updated on every property read. This can be done here.


    *plDevErrVal = 0;

    return S_OK;
}


/**************************************************************************\
* TestUsdDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused,
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::drvLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    *plDevErrVal = 0;
    if (m_pStiDevice)
    {
        return m_pStiDevice->LockDevice(100);
    }
    return S_OK;

}

/**************************************************************************\
* TestUsdDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::drvUnLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* TestUsdDevice::drvAnalyzeItem
*
*   The test camera does not support imag analysis.
*
* Arguments:
*
*   pWiasContext    - Pointer to the device item context to be analyzed.
*   lFlags          - Operation flags.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvAnalyzeItem(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *plDevErrVal)
{
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* TestUsdDevice::drvFreeDrvItemContext
*
*   The test scanner does not support imag analysis.
*
* Arguments:
*
*   lFlags          - unused
*   pSpecContext    - Pointer to item specific context.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvFreeDrvItemContext(
    LONG                lFlags,
    BYTE                *pSpecContext,
    LONG                *plDevErrVal)
{
    PMEMCAM_IMAGE_CONTEXT pContext = (PMEMCAM_IMAGE_CONTEXT)pSpecContext;

    if (pContext != NULL) {
        if (pContext->pszCameraImagePath != NULL) {

            free(pContext->pszCameraImagePath);
            pContext->pszCameraImagePath = NULL;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\device.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       Device.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        5 Jan, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner device methods. This sample WIA USD
*   supports push events by detecting when %windir%\temp\TESTUSD.BMP file has
*   been modified. This file becomes the new source of scanning data. An
*   event is generated the first time the device is loaded.
*
*******************************************************************************/

#include <windows.h>
#include <tchar.h>

#include "testusd.h"
#include "resource.h"
#include "tcamprop.h"

extern HINSTANCE g_hInst;

//
// Function prototypes, implemented in this file:
//

VOID FileChangeThread(LPVOID  lpParameter);

/**************************************************************************\
* TestUsdDevice::TestUsdDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdDevice::TestUsdDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    m_fValid(FALSE),
    m_pIStiDevControl(NULL),
    m_hShutdownEvent(INVALID_HANDLE_VALUE),
    m_hSignalEvent(INVALID_HANDLE_VALUE),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_pIWiaEventCallback(NULL),
    m_pStiDevice(NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pIDrvItemRoot(NULL)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::TestUsdDevice"));

    *m_szSrcDataName = L'\0';

    //
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    //

    if (punkOuter) {
        m_punkOuter = punkOuter;
    }
    else {

        //
        // Cast below is needed in order to point to right virtual table
        //

        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

    //
    // init camera search path
    //

    LPTSTR lpwszEnvString = TEXT("%CAMERA_ROOT%");

    DWORD dwRet = ExpandEnvironmentStrings(lpwszEnvString,
                                           gpszPath, MAX_PATH);

    if ((dwRet == 0) || (dwRet == (ULONG)_tcslen(lpwszEnvString)+1)) {

        _tcscpy(gpszPath, TEXT("C:\\Image"));
    }

}

/**************************************************************************\
* TestUsdDevice::PrivateInitialize
*
*   Device class private initialization
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
\**************************************************************************/
HRESULT TestUsdDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"TestUsdDevice::PrivateInitialize init CritSect failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {
        //
        // Create event for syncronization of notifications shutdown.
        //

        m_hShutdownEvent =  CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        }
        else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"TestUsdDevice::PrivateInitialize, create shutdown event failed"));
        }
    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::~TestUsdDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdDevice::~TestUsdDevice(void)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::~TestUsdDevice"));


    //
    // Kill notification thread if it exists.
    //

    SetNotificationHandle(NULL);

    //
    // Close event for syncronization of notifications shutdown.
    //

    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
    }

    //
    // Release the device control interface.
    //

    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //
    // Cleanup the WIA event sink.
    //

    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
    }

    //
    // Free the storage for the device ID.
    //

    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
    }

    //
    // Release the objects supporting device property storage.
    //

    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
    }

    //
    // Free the critical section.
    //

    DeleteCriticalSection(&m_csShutdown);
}

/**************************************************************************\
* TestUsdDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    //
    // We do support device notifications, but do not requiring polling.
    //

    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetStatus"));

    //
    // Validate parameters.
    //

    if (!pDevStatus) {
        WIAS_ERROR((g_hInst,"TestUsdDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    //
    // If we are asked, verify whether device is online.
    //

    pDevStatus->dwOnlineState = 0L;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {

        //
        // The test device is always on-line.
        //

        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
    }

    //
    // If we are asked, verify state of event.
    //

    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        //
        // Generate an event the first time we load.
        //

        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_bUsdLoadEvent = FALSE;
        }

        //
        // event pending ???
        //

    }

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::DeviceReset(void)
{
    WIAS_TRACE((g_hInst,"DeviceReset"));

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::Diagnostic"));

    //
    // Initialize response buffer
    //

    pBuffer->dwStatusMask = 0;

    ZeroMemory(&pBuffer->sErrorInfo,sizeof(pBuffer->sErrorInfo));

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::SetNotificationHandle(HANDLE hEvent)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::SetNotificationHandle"));

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csShutdown);

    //
    // Are we starting or stopping the notification thread?
    //

    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {

        m_hSignalEvent = hEvent;

        //
        // Initialize to no event.
        //

        m_guidLastEvent = GUID_NULL;

        //
        // Create the notification thread.
        //

        if (!m_hEventNotifyThread) {

            DWORD   dwThread;

            m_hEventNotifyThread = CreateThread(NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE)FileChangeThread,
                                                (LPVOID)this,
                                                0,
                                                &dwThread);

            if (m_hEventNotifyThread) {
                WIAS_TRACE((g_hInst,"TestUsdDevice::SetNotificationHandle, Enabling event notification"));
            }
            else {
                WIAS_ERROR((g_hInst,"TestUsdDevice::SetNotificationHandle, unable to create notification thread"));
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
        }
        else {
            WIAS_ERROR((g_hInst,"TestUsdDevice::SetNotificationHandle, spurious notification thread"));
            hr = STIERR_UNSUPPORTED;
        }
    }
    else {

        //
        // Disable event notifications.
        //

        SetEvent(m_hShutdownEvent);
        if (m_hEventNotifyThread) {
            WIAS_TRACE((g_hInst,"Disabling event notification"));
            WaitForSingleObject(m_hEventNotifyThread, 400);
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
            m_guidLastEvent = GUID_NULL;

            //
            // close dlg
            //

            if (m_hDlg != NULL) {
                SendMessage(m_hDlg,WM_COMMAND,IDOK,0);
                m_hDlg = NULL;
            }

        }
    }
    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* TestUsdDevice::GetNotificationData
*
*   Provides data on n event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetNotificationData"));

    //
    // If we have notification ready - return it's guid
    //

    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {

        pBuffer->guidNotificationCode  = m_guidLastEvent;

        m_guidLastEvent = GUID_NULL;

        pBuffer->dwSize = sizeof(STINOTIFY);

        ZeroMemory(&pBuffer->abNotificationData, sizeof(pBuffer->abNotificationData));

        //
        // private event
        //


        if (IsEqualIID(m_guidLastEvent, WIA_EVENT_NAME_CHANGE)) {

        }
    }
    else {
        return STIERR_NOEVENTS;
    }

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::Escape, unsupported"));

    //
    // Write command to device if needed.
    //

    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetLastError"));

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetLastErrorInfo"));

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::LockDevice(void)
{
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::UnLockDevice(void)
{
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawReadData"));

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawWriteData"));

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawReadCommand, unsupported"));

    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawWriteCommand, unsupported"));

    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT         hr = STI_OK;
    UINT            uiNameLen = 0;
    CAMERA_STATUS   camStatus;

    WIAS_TRACE((g_hInst,"TestUsdDevice::Initialize"));

    if (!pIStiDevControl) {
        WIAS_ERROR((g_hInst,"TestUsdDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    //
    // Cache the device control interface.
    //

    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Try to open the camera only once here during Initialize
    //

    hr = CamOpenCamera(&camStatus);

    return (hr);
}

/**************************************************************************\
* TestUsdDevice::RunNotifications
*
*   Monitor changes to the source data file parent directory.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

VOID TestUsdDevice::RunNotifications(void)
{
    //
    // start up camera event dlg
    //

    WIAS_TRACE((g_hInst,"TestUsdDevice::RunNotifications: start up event dlg"));

    HWND hWnd = GetDesktopWindow();

    int iret = (int)DialogBoxParam(
        g_hInst,
        MAKEINTRESOURCE(IDD_EVENT_DLG),
        hWnd,
        (DLGPROC)CameraEventDlgProc,
        (LPARAM)this
        );

    WIAS_TRACE((g_hInst,"TestUsdDevice::RunNotifications, iret = 0x%lx",iret));

    if (iret == -1) {
        int err = ::GetLastError();
        WIAS_TRACE((g_hInst,"TestUsdDevice::RunNotifications, dlg error = 0x%lx",err));
    }
}

/**************************************************************************\
* FileChangeThread
*
*   Calls RunNotifications to detect changing source data file.
*
* Arguments:
*
*    lpParameter    - Pointer to device object.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

VOID FileChangeThread(LPVOID  lpParameter)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::"));

    TestUsdDevice   *pThisDevice = (TestUsdDevice *)lpParameter;

    pThisDevice->RunNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\version.h ===
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Windows Image Acquisition Demo"
#define VER_INTERNALNAME_STR            "imgtest"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "imgtest.exe"

#include <ntverp.h>
#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\wiadev.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaDev.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner mini driver
*   device methods.
*
*******************************************************************************/

#define __FORMATS_AND_MEDIA_TYPES__

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "testusd.h"
#include "defprop.h"


extern HINSTANCE g_hInst; // Global hInstance
extern WIA_FORMAT_INFO* g_wfiTable;
/**************************************************************************\
* TestUsdDevice::InitializWia
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvInitializeWia(
    BYTE                            *pWiasContext,
    LONG                            lFlags,
    BSTR                            bstrDeviceID,
    BSTR                            bstrRootFullItemName,
    IUnknown                        *pStiDevice,
    IUnknown                        *pIUnknownOuter,
    IWiaDrvItem                     **ppIDrvItemRoot,
    IUnknown                        **ppIUnknownInner,
    LONG                            *plDevErrVal)
{
    HRESULT              hr;
    LONG                 lDevErrVal;

    WIAS_TRACE((g_hInst,"drvInitializeWia, device ID: %ws", bstrDeviceID));

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;
    *plDevErrVal = 0;

    //
    // Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device inteface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);
        if (! m_bstrDeviceID) {
            return (E_OUTOFMEMORY);
        }

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (! m_bstrRootFullItemName) {
            return (E_OUTOFMEMORY);
        }
    }

    //
    // Build the device item tree
    //

    hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);

    if (SUCCEEDED(hr)) {
        *ppIDrvItemRoot = m_pIDrvItemRoot;
    }

    return (hr);
}

/**************************************************************************\
* TestUsdDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   30/12/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}

/**************************************************************************\
*
*   Mini Driver Device Services
*
\**************************************************************************/



/**************************************************************************\
* drvGetDeviceErrorStr
*
*     Map a device error value to a string.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetDeviceErrorStr(
    LONG        lFlags,
    LONG        lDevErrVal,
    LPOLESTR    *ppszDevErrStr,
    LONG        *plDevErr)
{
    *plDevErr = 0;
    if (!ppszDevErrStr) {
        WIAS_ERROR((g_hInst,"drvGetDeviceErrorStr, NULL ppszDevErrStr"));
        return E_POINTER;
    }

    // Map device errors to a string to be placed in the event log.
    switch (lDevErrVal) {

        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            return E_FAIL;
    }
    return S_OK;
}

/**************************************************************************\
* DeleteDeviceItemTree
*
*   Recursive device item tree delete routine. Deletes the whole tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::DeleteDeviceItemTree(
    LONG                       *plDevErrVal)
{
    HRESULT hr;

    //
    // does tree exist
    //

    if (m_pIDrvItemRoot == NULL) {
        return S_OK;
    }

    //
    // Unlink and release the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    m_pIDrvItemRoot = NULL;

    return hr;
}

/**************************************************************************\
* BuildDeviceItemTree
*
*   The device uses the IWiaDrvServices methods to build up a tree of
*   device items.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::BuildDeviceItemTree(
    LONG                       *plDevErrVal)
{
    HRESULT hr = S_OK;

    //
    // This device doesn't touch hardware to build the tree.
    //

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    CAMERA_STATUS camStatus;

    if (! m_pIDrvItemRoot) {
        hr = CamBuildImageTree(&camStatus, &m_pIDrvItemRoot);
    }

    return hr;
}

/**************************************************************************\
* InitDeviceProperties
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::InitDeviceProperties(
    BYTE                    *pWiasContext,
    LONG                    *plDevErrVal)
{
    HRESULT                  hr;
    BSTR                     bstrFirmwreVer;
    SYSTEMTIME               camTime;
    int                      i;
    PROPVARIANT              propVar;

    //
    // This device doesn't touch hardware to initialize the device properties.
    //

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    //
    // Parameter validation.
    //

    if (! pWiasContext) {
        WIAS_ERROR((g_hInst,"InitDeviceProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // Write standard property names
    //

    hr = wiasSetItemPropNames(pWiasContext,
                              sizeof(gDevicePropIDs)/sizeof(PROPID),
                              gDevicePropIDs,
                              gDevicePropNames);
    if (FAILED(hr)) {
        WIAS_TRACE((g_hInst,"InitDeviceProperties() WritePropertyNames() failed"));
        return (hr);
    }

    //
    // Write the properties supported by all WIA devices
    //

    bstrFirmwreVer = SysAllocString(L"02161999");
    if (bstrFirmwreVer) {
        wiasWritePropStr(
            pWiasContext, WIA_DPA_FIRMWARE_VERSION, bstrFirmwreVer);
        SysFreeString(bstrFirmwreVer);
    }

    wiasWritePropLong(
        pWiasContext, WIA_DPA_CONNECT_STATUS, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICTURES_TAKEN, 0);
    GetSystemTime(&camTime);
    wiasWritePropBin(
        pWiasContext, WIA_DPA_DEVICE_TIME,
        sizeof(SYSTEMTIME), (PBYTE)&camTime);

    //
    // Write the camera properties, just default values, it may vary with items
    //

    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICTURES_REMAINING, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_WIDTH, 80);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_HEIGHT, 60);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_WIDTH, 1024);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_HEIGHT, 768);

    // Give WIA_DPC_EXPOSURE_MODE to WIA_DPC_TIMER_VALUE some default.

    wiasWritePropLong(
        pWiasContext, WIA_DPC_EXPOSURE_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FLASH_MODE, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FOCUS_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_ZOOM_POSITION, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_BATTERY_STATUS, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_VALUE, 0);

    //
    // Write the WIA_DPP_TCAM_ROOT_PATH property
    //

    BSTR   bstrRootPath;

#ifdef UNICODE
    bstrRootPath = SysAllocString(gpszPath);
#else
    WCHAR   wszPath[MAX_PATH];

    mbstowcs(wszPath, gpszPath, strlen(gpszPath)+1);
    bstrRootPath = SysAllocString(wszPath);
#endif

    if (! bstrRootPath) {
        return (E_OUTOFMEMORY);
    }

    wiasWritePropStr(pWiasContext, WIA_DPP_TCAM_ROOT_PATH, bstrRootPath);

    //
    // Use WIA services to set the property access and
    // valid value information from gDevPropInfoDefaults.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_DEV_PROPS,
                                 gDevicePropSpecDefaults,
                                 gDevPropInfoDefaults);
    return (S_OK);
}

/**************************************************************************\
* drvDeviceCommand
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvDeviceCommand(
   BYTE                         *pWiasContext,
   LONG                         lFlags,
   const GUID                   *plCommand,
   IWiaDrvItem                  **ppWiaDrvItem,
   LONG                         *plErr)
{
    HRESULT hr;

    //
    // init return value
    //

    if (ppWiaDrvItem != NULL) {
        *ppWiaDrvItem = NULL;
    }

    //
    // dispatch command
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        hr = drvLockWiaDevice(pWiasContext, lFlags, plErr);
        if (FAILED(hr)) {
            return (hr);
        }

        //
        // SYNCHRONIZE - make sure tree is up to date with device
        //
        // The driver's responsibility is to make sure the tree is accurate.
        //

        hr = BuildDeviceItemTree(plErr);

        drvUnLockWiaDevice(pWiasContext, lFlags, plErr);

        return (hr);

    } else {

        WIAS_TRACE((g_hInst,"drvDeviceCommand: Unsupported command"));

        hr = E_NOTIMPL;

    }

    return hr;
}

/**************************************************************************\
* drvGetCapabilities
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    17/3/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetCapabilities(
    BYTE                *pWiasContext,
    LONG                ulFlags,
    LONG                *pCelt,
    WIA_DEV_CAP_DRV     **ppCapabilities,
    LONG                *plDevErrVal)
{
    *plDevErrVal = 0;

    //
    // Return Commmand &| Events depending on flags
    //

    switch (ulFlags) {
        case WIA_DEVICE_COMMANDS:

            //
            //  Only commands
            //

            *pCelt = NUM_CAP_ENTRIES - NUM_EVENTS;
            *ppCapabilities = &gCapabilities[NUM_EVENTS];
            break;

        case WIA_DEVICE_EVENTS:

            //
            //  Only events
            //

            *pCelt = NUM_EVENTS;
            *ppCapabilities = gCapabilities;
            break;

        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

            //
            //  Both events and commands
            //

            *pCelt = NUM_CAP_ENTRIES;
            *ppCapabilities = gCapabilities;
            break;

        default:

            //
            // Flags is invalid
            //

            WIAS_ERROR((g_hInst, "drvGetCapabilities, flags was invalid"));
            return (E_INVALIDARG);
    }

    return (S_OK);
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of formats and media types supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WiaFormatInfo array.
*   ppfe            - Pointer to returned WiaFormatInfo array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*    A pointer to an array of FORMATETC.  These are the formats and media
*    types supported.
*
*    Status
*
* History:
*
*   16/03/1999 Original Version
*
\**************************************************************************/

#define NUM_WIA_FORMAT_INFO 3

HRESULT _stdcall TestUsdDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{

    //
    //  If it hasn't been done already, set up the g_wfiTable table
    //

    if (! g_wfiTable) {

        g_wfiTable = (WIA_FORMAT_INFO*)
            CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * NUM_WIA_FORMAT_INFO);

        if (! g_wfiTable) {
            WIAS_ERROR((g_hInst, "drvGetWiaFormatInfo, out of memory"));
            return (E_OUTOFMEMORY);
        }

        //
        //  Set up the format/tymed pairs
        //

        g_wfiTable[0].guidFormatID = WiaImgFmt_MEMORYBMP;
        g_wfiTable[0].lTymed = TYMED_CALLBACK;
        g_wfiTable[1].guidFormatID = WiaImgFmt_BMP;
        g_wfiTable[1].lTymed = TYMED_FILE;
        g_wfiTable[2].guidFormatID = WiaAudFmt_WAV;
        g_wfiTable[2].lTymed = TYMED_FILE;
    }

    *plDevErrVal = 0;

    *pcelt = NUM_WIA_FORMAT_INFO;
    *ppwfi = g_wfiTable;
    return S_OK;
}



/**************************************************************************\
* drvNotifyPnpEvent
*
*    Notify Pnp Event received by device manager
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    Aug/3rd/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvNotifyPnpEvent(
    const GUID          *pEventGUID,
    BSTR                 bstrDeviceID,
    ULONG                ulReserved)
{
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\testcam\testusd.h ===
/****************************************************************************
 *
 *  TESTUSD.H
 *
 *  Copyright (c) Microsoft Corporation 1996-1997
 *  All rights reserved
 *
 ***************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"

#include "wiamindr.h"

#define DATA_SRC_NAME L"TESTUSD.BMP"   // Data source file name.


// GUID's

#if defined( _WIN32 ) && !defined( _NO_COM)


// {ACBF6AF6-51C9-46a9-87D8-A93F352BCB3E}
DEFINE_GUID(CLSID_TestUsd,
0xacbf6af6, 0x51c9, 0x46a9, 0x87, 0xd8, 0xa9, 0x3f, 0x35, 0x2b, 0xcb, 0x3e);


// {61127F40-E1A5-11D0-B454-00A02438AD48}
DEFINE_GUID(guidEventTimeChanged, 0x61127F40L, 0xE1A5, 0x11D0, 0xB4, 0x54, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventSizeChanged, 0x052ED270L, 0x28A3, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventFirstLoaded, 0x052ED270L, 0x28A3, 0x11D3, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

#endif


#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//
// Module ref counting
//
extern UINT g_cRefThisDll;
extern UINT g_cLocks;

extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);

extern void DllAddRef(void);
extern void DllRelease(void);

typedef struct _MEMCAM_IMAGE_CONTEXT
{
    PTCHAR  pszCameraImagePath;
}MEMCAM_IMAGE_CONTEXT,*PMEMCAM_IMAGE_CONTEXT;

typedef struct _CAMERA_PICTURE_INFO
{
    LONG    PictNumber       ;
    LONG    ThumbWidth       ;
    LONG    ThumbHeight      ;
    LONG    PictWidth        ;
    LONG    PictHeight       ;
    LONG    PictCompSize     ;
    LONG    PictFormat       ;
    LONG    PictBitsPerPixel ;
    LONG    PictBytesPerRow  ;
    SYSTEMTIME TimeStamp;
}CAMERA_PICTURE_INFO,*PCAMERA_PICTURE_INFO;


typedef struct _CAMERA_STATUS
{
    LONG    FirmwareVersion            ;
    LONG    NumPictTaken               ;
    LONG    NumPictRemaining           ;
    LONG    ThumbWidth                 ;
    LONG    ThumbHeight                ;
    LONG    PictWidth                  ;
    LONG    PictHeight                 ;
    SYSTEMTIME CameraTime;
} CAMERA_STATUS,*PCAMERA_STATUS;

#define ALLOC(s) LocalAlloc(0,s)
#define FREE(s)  LocalFree(s)


//
// Base class for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};


//
// Class definition for object
//

class TestUsdDevice : public IStiUSD,
                      public IWiaMiniDrv,
                      public INonDelegatingUnknown
{

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.

    // Data source file information.
    TCHAR               m_szSrcDataName[MAX_PATH];  // Path of data source file.
    FILETIME            m_ftLastWriteTime;          // Last time of source data file.
    LARGE_INTEGER       m_dwLastHugeSize;           // Last size of source data file.

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.

    // WIA information, one time initialization.
    IStiDevice         *m_pStiDevice;               // Sti object.

    BSTR                m_bstrRootFullItemName;    // Device name for prop streams.
    IWiaEventCallback     *m_pIWiaEventCallback;          // WIA event sink.
    IWiaDrvItem        *m_pIDrvItemRoot;            // root item

    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

    //
    // make public until dlg proc is a member
    //

public:
    BSTR                m_bstrDeviceID;             // WIA unique device ID.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HWND                m_hDlg;
    GUID                m_guidLastEvent;        // Last event ID.

public:
    // *** IUnknown-like methods ***
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey)  ;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps)  ;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus)  ;
    STDMETHOD(DeviceReset)(THIS )  ;
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer)  ;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError)  ;
    STDMETHOD(LockDevice) (THIS )  ;
    STDMETHOD(UnLockDevice) (THIS )  ;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent)  ;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify)  ;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo);

    //
    // MiniDrv methods
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE*                       pWiasContext,
        LONG                        lFlags,
        BSTR                        bstrDeviceID,
        BSTR                        bstrRootFullItemName,
        IUnknown                   *pStiDevice,
        IUnknown                   *pIUnknownOuter,
        IWiaDrvItem               **ppIDrvItemRoot,
        IUnknown                  **ppIUnknownInner,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG                        lFlags,
        LONG                        lDevErrVal,
        LPOLESTR                   *ppszDevErrStr,
        LONG                       *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        const GUID                 *pGUIDCommand,
        IWiaDrvItem               **ppMiniDrvItem,
        LONG                       *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        PMINIDRV_TRANSFER_CONTEXT   pDataContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFLags,
        PMINIDRV_TRANSFER_CONTEXT   pmdtc,
        LONG                       *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE                       *pWiaItem,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal );

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG                        lFlags,
        BYTE                       *pDevContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_DEV_CAP_DRV           **ppCapabilities,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_FORMAT_INFO            **ppwfi,
        LONG                       *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID                 *pEventGUID,
        BSTR                        bstrDeviceID,
        ULONG                       ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);

    /*** Private helper methods ***/
private:

    HRESULT InitImageInformation(
        BYTE                       *pWiasContext,
        MEMCAM_IMAGE_CONTEXT       *pContext,
        LONG                       *plDevErrVal);

    HRESULT InitAudioInformation(
        BYTE                       *pWiasContext,
        MEMCAM_IMAGE_CONTEXT       *pContext,
        LONG                       *plDevErrVal);

    HRESULT EnumDiskImages(
        IWiaDrvItem                *pRootItem,
        LPTSTR                      pszDirName);

    HRESULT CreateItemFromFileName(
        LONG                        lFolderType,
        PTCHAR                      pszPath,
        PTCHAR                      pszName,
        IWiaDrvItem               **ppNewFolder);

    HRESULT CamLoadPicture(
        PMEMCAM_IMAGE_CONTEXT       pMCamContext,
        PMINIDRV_TRANSFER_CONTEXT   pDataTransCtx,
        PLONG                       plDevErrVal);

    HRESULT CamLoadPictureCB(
        PMEMCAM_IMAGE_CONTEXT       pMCamContext,
        MINIDRV_TRANSFER_CONTEXT   *pDataTransCtx,
        PLONG                       plDevErrVal);

    HRESULT CamGetPictureInfo(
        PMEMCAM_IMAGE_CONTEXT       pMCamContext,
        PCAMERA_PICTURE_INFO        pPictInfo,
        PBYTE                      *ppBITMAPINFO,
        LONG                       *pBITMAPINFOSize);

    HRESULT CamLoadThumbnail(PMEMCAM_IMAGE_CONTEXT, PBYTE *,LONG *);

    HRESULT CamBuildImageTree(CAMERA_STATUS *,IWiaDrvItem **);

    HRESULT CamOpenCamera(CAMERA_STATUS *);

    HRESULT BuildDeviceItemTree(LONG *plDevErrVal);
    HRESULT DeleteDeviceItemTree(LONG *plDevErrVal);
    HRESULT InitDeviceProperties(BYTE *, LONG *plDevErrVal);

public:
    TestUsdDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~TestUsdDevice();

    VOID RunNotifications(VOID);
};

typedef TestUsdDevice *PTestUsdDevice;


HRESULT SetItemSize(BYTE*);

//
// Utility function to set up the attributes for format property
//

HRESULT SetFormatAttribs();

//
// Syncronization mechanisms
//
#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);


// Device constants:
const LEN_INQUIRE_BUTTON = 8;
const BYTE INQUIRE_BUTTON[LEN_INQUIRE_BUTTON + 1] = "INQUIREB";

const LEN_INQUIRE_BUTTON_READ = 10;

const LEN_CLEAR_BUTTON = 5;
const BYTE CLEAR_BUTTON[LEN_CLEAR_BUTTON + 1] = "CLRBT";

const LEN_CURRENT_ERROR = 7;
const BYTE CURRENT_ERROR[LEN_CURRENT_ERROR + 1] = "CURERR";

const LEN_DIAGS = 5;
const BYTE TURN_ON_LAMP[LEN_DIAGS + 1] = "LAMPO";
const BYTE TURN_OFF_LAMP[LEN_DIAGS + 1] = "LAMPF";
const BYTE SELF_TEST[LEN_DIAGS + 1] = "SELFT";
const BYTE STATUS_STRING[LEN_DIAGS + 1] = "STATS";


BOOL
_stdcall CameraEventDlgProc(
   HWND     hDlg,
   unsigned message,
   DWORD    wParam,
   LONG     lParam
   );

typedef struct _CAM_EVENT
{
    PTCHAR       pszEvent;
    const GUID  *pguid;
}CAM_EVENT,*PCAM_EVENT;

extern TCHAR gpszPath[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\inc\wiatempl.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    typeutil.h

Abstract:

    This module declares useful types such as CWiaArray and CWiaMap.
    These were lifted from the ATL library (atlbase.h).

Author:

    DavePar
    
Revision History:


--*/

#ifndef TYPEUTIL__H_
#define TYPEUTIL__H_

#ifndef ASSERT
#define ASSERT(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CWiaArray & CWiaMap

template <class T>
class CWiaArray
{
public:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

// Construction/destruction
    CWiaArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CWiaArray()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL GrowTo(int size)
    {
        if (size > m_nAllocSize)
        {
            T* aT;
            aT = (T*) realloc(m_aT, size * sizeof(T));
            if (aT == NULL)
                return FALSE;
            m_nAllocSize = size;
            m_aT = aT;
        }
        return TRUE;
    }
    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
            if (!GrowTo(nNewAllocSize))
                return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    int AddN(T& t) // Adds the new item and returns its index
    {
        if (Add(t))
            return m_nSize - 1;
        else
            return -1;
    }
    BOOL Push(T& t)
    {
        return Add(t);
    }
    BOOL Pop(T& t)
    {
        if (m_nSize == 0)
            return FALSE;
        t = m_aT[m_nSize - 1];
        return RemoveAt(m_nSize - 1);
    }
    BOOL Remove(const T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {

        if(nIndex >= m_nSize)
            return FALSE;
        
        //---- always call the dtr ----
#if _MSC_VER >= 1200
        m_aT[nIndex].~T();
#else
        T* MyT;
        MyT = &m_aT[nIndex];
        MyT->~T();
#endif

        //---- if target entry is not at end, compact the array ----
        if(nIndex != (m_nSize - 1))
        {
            
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
        }

        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aT != NULL)
        {
            for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
                m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
            free(m_aT);
            m_aT = NULL;
        }
        m_nSize = 0;
        m_nAllocSize = 0;
    }
    T& operator[] (int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

// Implementation
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <class _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, T& t)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aT + nIndex) Wrapper(t);
    }
    int Find(const T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
    BOOL Parse(BYTE **ppRaw, int NumSize = 4)
    {
        if (!ppRaw || !*ppRaw)
            return FALSE;
    
        RemoveAll();
    
        // Get the number of elements from the raw data
        ULONG NumElems;
        switch (NumSize)
        {
        case 4:
            NumElems = MAKELONG(MAKEWORD((*ppRaw)[0], (*ppRaw)[1]), MAKEWORD((*ppRaw)[2], (*ppRaw)[3]));
            break;
        case 2:
            NumElems = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
            break;
        case 1:
            NumElems = **ppRaw;
            break;
        default:
            return FALSE;
        }

        *ppRaw += NumSize;
    
        // Allocate space for the array
        if (!GrowTo(NumElems))
            return FALSE;
    
        // Copy in the elements
        memcpy(m_aT, *ppRaw, NumElems * sizeof(T));
        m_nSize = NumElems;
    
        // Advance the raw pointer past the array and number of elements field
        *ppRaw += NumElems * sizeof(T);
    
        return TRUE;
    }
};

// for arrays of simple types
template <class T>
class CWiaValArray : public CWiaArray< T >
{
public:
    BOOL Add(T t)
    {
        return CWiaArray< T >::Add(t);
    }
    BOOL Remove(T t)
    {
        return CWiaArray< T >::Remove(t);
    }
    T operator[] (int nIndex) const
    {
        return CWiaArray< T >::operator[](nIndex);
    }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CWiaMap
{
public:
    TKey* m_aKey;
    TVal* m_aVal;
    int m_nSize;

// Construction/destruction
    CWiaMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
    { }

    ~CWiaMap()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Add(TKey key, TVal val)
    {
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
        if(pKey == NULL)
            return FALSE;
        m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
        if(pVal == NULL)
            return FALSE;
        m_aVal = pVal;
        m_nSize++;
        SetAtIndex(m_nSize - 1, key, val);
        return TRUE;
    }
    BOOL Remove(TKey key)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        if(nIndex != (m_nSize - 1))
        {
#if 0
            // This code seems to be causing problems. Since it's not
            // needed, ifdef it out for now.

            m_aKey[nIndex].~TKey();
#if _MSC_VER >= 1200
            m_aVal[nIndex].~TVal();
#else
            TVal * t1;
            t1 = &m_aVal[nIndex];
            t1->~TVal();
#endif
#endif
            memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
            memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
        }
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
        if(pKey != NULL || m_nSize == 1)
            m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
        if(pVal != NULL || m_nSize == 1)
            m_aVal = pVal;
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aKey != NULL)
        {
            for(int i = 0; i < m_nSize; i++)
            {
                m_aKey[i].~TKey();
#if _MSC_VER >= 1200
                m_aVal[i].~TVal();
#else
                TVal * t1;
                t1 = &m_aVal[i];
                t1->~TVal();
#endif
            }
            free(m_aKey);
            m_aKey = NULL;
        }
        if(m_aVal != NULL)
        {
            free(m_aVal);
            m_aVal = NULL;
        }

        m_nSize = 0;
    }
    BOOL SetAt(TKey key, TVal val)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        SetAtIndex(nIndex, key, val);
        return TRUE;
    }
    TVal Lookup(TKey key) const
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetValueAt(nIndex);
    }
    TKey ReverseLookup(TVal val) const
    {
        int nIndex = FindVal(val);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetKeyAt(nIndex);
    }
    TKey& GetKeyAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aKey[nIndex];
    }
    TVal& GetValueAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aVal[nIndex];
    }

// Implementation

    template <typename T>
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <typename _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, TKey& key, TVal& val)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aKey + nIndex) Wrapper<TKey>(key);
        new(m_aVal + nIndex) Wrapper<TVal>(val);
    }
    int FindKey(TKey& key) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aKey[i] == key)
                return i;
        }
        return -1;  // not found
    }
    int FindVal(TVal& val) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aVal[i] == val)
                return i;
        }
        return -1;  // not found
    }
};

#endif // TYPEUTIL__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\microdrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testmcro.rc
//

#define IDS_SCAN_BUTTON_NAME  700
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        701
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           701
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\microdrv\testmcro.h ===
#ifndef TESTMCRO
#define TESTMCRO

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define INITGUID
#include <windows.h>

//
// Button GUIDS
//

DEFINE_GUID( guidScanButton, 0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);

// copy any known formats defined in wiadef.h to this location for use in your driver.

DEFINE_GUID(WiaImgFmt_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

// define your custom-defined supported formats here
// {3B5DE639-B2C6-4952-98A9-1DC06F3703BD}
DEFINE_GUID(WiaImgFmt_MYNEWFORMAT, 0x3b5de639, 0xb2c6, 0x4952, 0x98, 0xa9, 0x1d, 0xc0, 0x6f, 0x37, 0x3, 0xbd);

#undef INITGUID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\microdrv\testmcro.cpp ===
#include "testmcro.h"
#include "wiamicro.h"
#include "resource.h"

#include <STI.H>
#include <math.h>
#include <winioctl.h>
#include <usbscan.h>

#ifdef DEBUG
#include <stdio.h>
#endif


// #define BUTTON_SUPPORT // (uncomment this to allow BUTTON SUPPORT)
                          // button support is not functional in the test device

#define MAX_BUTTONS 1
#define MAX_BUTTON_NAME 255

HINSTANCE g_hInst; // instance of this MicroDriver (used for loading from a resource)


// note: MEMORYBMP, and BMP file will be added by wiafbdrv host driver.
//       do not include them in your extended list.
//

// #define _USE_EXTENDED_FORMAT_LIST (uncomment this to allow Extented file and memory formats)

#define NUM_SUPPORTED_FILEFORMATS 1
GUID g_SupportedFileFormats[NUM_SUPPORTED_FILEFORMATS];

#define NUM_SUPPORTED_MEMORYFORMATS 2
GUID g_SupportedMemoryFormats[NUM_SUPPORTED_MEMORYFORMATS];

//
// Button GUID array used in Capability negotiation.
// Set your BUTTON guids here.  These must match the GUIDS specified in
// your INF.  The Scan Button GUID is public to all scanners with a
// scan button.
//

GUID g_Buttons[MAX_BUTTONS] ={{0xa6c5a715, 0x8c6e, 0x11d2,{ 0x97, 0x7a,  0x0,  0x0, 0xf8, 0x7a, 0x92, 0x6f}}};
BOOL g_bButtonNamesCreated = FALSE;
WCHAR* g_ButtonNames[MAX_BUTTONS];

INT g_PalIndex = 0;     // simple palette index counter (test driver specific)
BOOL g_bDown = FALSE;   // simple band direction bool   (test drvier specific)

BOOL    InitializeScanner(PSCANINFO pScanInfo);
VOID    InitScannerDefaults(PSCANINFO pScanInfo);
BOOL    SetScannerSettings(PSCANINFO pScanInfo);
VOID    CheckButtonStatus(PVAL pValue);
VOID    GetButtonPress(LONG *pButtonValue);
HRESULT GetInterruptEvent(PVAL pValue);
LONG    GetButtonCount();
HRESULT GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal);
VOID    ReadRegistryInformation(PVAL pValue);

BOOL APIENTRY DllMain( HANDLE hModule,DWORD  dwreason, LPVOID lpReserved)
{
    g_hInst = (HINSTANCE)hModule;
    switch(dwreason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

/**************************************************************************\
* MicroEntry (MicroDriver Entry point)
*
*   Called by the WIA driver to communicate with the MicroDriver.
*
* Arguments:
*
*   lCommand     - MicroDriver Command, sent from the WIA driver
*   pValue       - VAL structure used for settings
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

WIAMICRO_API HRESULT MicroEntry(LONG lCommand, PVAL pValue)
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwBytesWritten = 0;
    INT index = 0;

//#define _DEBUG_COMMANDS

#ifdef _DEBUG_COMMANDS
    if(lCommand != CMD_STI_GETSTATUS)
        Trace(TEXT("Command Value (%d)"),lCommand);
#endif

    if(pValue->pScanInfo == NULL) {
        return E_INVALIDARG;
    }

    switch(lCommand) {
    case CMD_INITIALIZE:
        hr = S_OK;

        //
        // create any DeviceIO handles needed, use index (1 - MAX_IO_HANDLES) to store these handles.
        // Index '0' is reserved by the WIA flatbed driver. The CreateFile Name is stored in the szVal
        // member of the VAL structure.
        //

        // pValue->pScanInfo->DeviceIOHandles[1] = CreateFileA( pValue->szVal,
        //                                   GENERIC_READ | GENERIC_WRITE, // Access mask
        //                                   0,                            // Share mode
        //                                   NULL,                         // SA
        //                                   OPEN_EXISTING,                // Create disposition
        //                                   FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED,        // Attributes
        //                                   NULL );

        //
        // if your device supports buttons, create the BUTTON name information here..
        //

        if(!g_bButtonNamesCreated) {
            for(index = 0; index < MAX_BUTTONS; index++){
                g_ButtonNames[index] = (WCHAR*)CoTaskMemAlloc(MAX_BUTTON_NAME);
            }

            hr = GetOLESTRResourceString(IDS_SCAN_BUTTON_NAME,&g_ButtonNames[0],TRUE);
            if(SUCCEEDED(hr)){
                g_bButtonNamesCreated = TRUE;
            }
        }

        //
        // Initialize the scanner's default settings
        //

        InitScannerDefaults(pValue->pScanInfo);

        break;
    case CMD_UNINITIALIZE:

        //
        // close any open handles created by the Micro driver
        //

        if(pValue->pScanInfo->DeviceIOHandles[1] != NULL){
            CloseHandle(pValue->pScanInfo->DeviceIOHandles[1]);
        }


        //
        // if your device supports buttons, free/destroy the BUTTON name information here..
        //

        if(g_bButtonNamesCreated) {
            for(index = 0; index < MAX_BUTTONS; index++){
                CoTaskMemFree(g_ButtonNames[index]);
            }
        }

        //
        // close/unload libraries
        //

        hr = S_OK;
        break;
    case CMD_RESETSCANNER:

        //
        // reset scanner
        //

        hr = S_OK;
        break;
    case CMD_STI_DIAGNOSTIC:
    case CMD_STI_DEVICERESET:

        //
        // reset device
        //

        hr = S_OK;
        break;
    case CMD_STI_GETSTATUS:

        //
        // set status flag to ON-LINE
        //

        pValue->lVal = MCRO_STATUS_OK;
        pValue->pGuid = (GUID*) &GUID_NULL;

        //
        // button polling support
        //

#ifdef BUTTON_SUPPORT
        CheckButtonStatus(pValue);
#endif

        hr = S_OK;
        break;
    case CMD_SETXRESOLUTION:
        pValue->pScanInfo->Xresolution = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETYRESOLUTION:
        pValue->pScanInfo->Yresolution = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETCONTRAST:
        pValue->pScanInfo->Contrast    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETINTENSITY:
        pValue->pScanInfo->Intensity   = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETDATATYPE:
        pValue->pScanInfo->DataType    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETNEGATIVE:
        pValue->pScanInfo->Negative    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_GETADFSTATUS:
    case CMD_GETADFHASPAPER:
        // pValue->lVal = MCRO_ERROR_PAPER_EMPTY;
        // hr = S_OK;
        break;
    case CMD_GET_INTERRUPT_EVENT:
        hr = GetInterruptEvent(pValue);
        break;
    case CMD_GETCAPABILITIES:
        pValue->lVal = 0;
        pValue->pGuid = NULL;
        pValue->ppButtonNames = NULL;
        hr = S_OK;
        break;

    case CMD_SETSCANMODE:
        hr = S_OK;
        switch(pValue->lVal){
        case SCANMODE_FINALSCAN:
            Trace(TEXT("Final Scan"));
            break;
        case SCANMODE_PREVIEWSCAN:
            Trace(TEXT("Preview Scan"));
            break;
        default:
            Trace(TEXT("Unknown Scan Mode (%d)"),pValue->lVal);
            hr = E_FAIL;
            break;
        }
        break;
    case CMD_SETSTIDEVICEHKEY:
        ReadRegistryInformation(pValue);
        break;

#ifdef _USE_EXTENDED_FORMAT_LIST

    // note: MEMORYBMP, and BMP file will be added by wiafbdrv host driver.
    //       do not include them in your extended list.
    //

    case CMD_GETSUPPORTEDFILEFORMATS:
        g_SupportedFileFormats[0] = WiaImgFmt_JPEG;
        pValue->lVal = NUM_SUPPORTED_FILEFORMATS;
        pValue->pGuid = g_SupportedFileFormats;
        hr = S_OK;
        break;

    case CMD_GETSUPPORTEDMEMORYFORMATS:
        g_SupportedMemoryFormats[0] = WiaImgFmt_TIFF;
        g_SupportedMemoryFormats[1] = WiaImgFmt_MYNEWFORMAT;
        pValue->lVal = NUM_SUPPORTED_MEMORYFORMATS;
        pValue->pGuid = g_SupportedMemoryFormats;
        hr = S_OK;
        break;
#endif

    default:
        Trace(TEXT("Unknown Command (%d)"),lCommand);
        break;
    }

    return hr;
}

/**************************************************************************\
* Scan (MicroDriver Entry point)
*
*   Called by the WIA driver to acquire data from the MicroDriver.
*
* Arguments:
*
*   pScanInfo    - SCANINFO structure used for settings
*   lPhase       - Current Scan phase, SCAN_FIRST, SCAN_NEXT, SCAN_FINISH...
*   pBuffer      - data buffer to be filled with scanned data
*   lLength      - Maximum length of pBuffer
*   plReceived   - Number of actual bytes written to pBuffer.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

WIAMICRO_API HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived)
{
    if(pScanInfo == NULL) {
        return E_INVALIDARG;
    }

    INT i = 0;

    Trace(TEXT("------ Scan Requesting %d ------"),lLength);
    switch (lPhase) {
    case SCAN_FIRST:
        if (!SetScannerSettings(pScanInfo)) {
            return E_FAIL;
        }

        Trace(TEXT("SCAN_FIRST"));

        g_PalIndex = 0;
        g_bDown = FALSE;

        //
        // first phase
        //

        Trace(TEXT("Start Scan.."));

    case SCAN_NEXT: // SCAN_FIRST will fall through to SCAN_NEXT (because it is expecting data)

        //
        // next phase
        //

        if(lPhase == SCAN_NEXT)
            Trace(TEXT("SCAN_NEXT"));

        //
        // get data from the scanner and set plReceived value
        //

        //
        // read data
        //

        switch(pScanInfo->DataType) {
        case WIA_DATA_THRESHOLD:

            //
            // make buffer alternate black/White, for sample 1-bit data
            //

            memset(pBuffer,0,lLength);
            memset(pBuffer,255,lLength/2);
            break;
        case WIA_DATA_GRAYSCALE:

            //
            // make buffer grayscale data, for sample 8-bit data
            //

            if(!g_bDown){
                g_PalIndex+=10;
                if(g_PalIndex > 255){
                    g_PalIndex = 255;
                    g_bDown = TRUE;
                }
            }
            else {
                g_PalIndex-=10;
                if(g_PalIndex < 0){
                    g_PalIndex = 0;
                    g_bDown = FALSE;
                }
            }
            memset(pBuffer,g_PalIndex,lLength);
            break;
        case WIA_DATA_COLOR:

            //
            // make buffer red, for sample color data
            //

            for (i = 0;i+2<lLength;i+=3) {
                memset(pBuffer+i,255,1);
                memset(pBuffer+(i+1),0,1);
                memset(pBuffer+(i+2),0,1);
            }
            break;
        default:
            break;
        }

        //
        // test device always returns the exact amount of scanned data
        //

        *plReceived = lLength;
        break;
    case SCAN_FINISHED:
    default:
        Trace(TEXT("SCAN_FINISHED"));

        //
        // stop scanner, do not set lRecieved, or write any data to pBuffer.  Those values
        // will be NULL.  This lPhase is only to allow you to stop scanning, and return the
        // scan head to the HOME position. SCAN_FINISHED will be called always for regular scans, and
        // for cancelled scans.
        //

        break;
    }

    return S_OK;
}

/**************************************************************************\
* SetPixelWindow (MicroDriver Entry point)
*
*   Called by the WIA driver to set the scan selection area to the MicroDriver.
*
* Arguments:
*
*   pScanInfo    - SCANINFO structure used for settings
*   pValue       - VAL structure used for settings
*   x            - X Position of scan rect (upper left x coordinate)
*   y            - Y Position of scan rect (upper left y coordinate)
*   xExtent      - Width of scan rect  (in pixels)
*   yExtent      - Height of scan rect (in pixels)
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

WIAMICRO_API HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent)
{
    if(pScanInfo == NULL) {
        return E_INVALIDARG;
    }

    pScanInfo->Window.xPos = x;
    pScanInfo->Window.yPos = y;
    pScanInfo->Window.xExtent = xExtent;
    pScanInfo->Window.yExtent = yExtent;
    return S_OK;
}


/**************************************************************************\
* ReadRegistryInformation (helper)
*
*   Called by the MicroDriver to Read registry information from the device's
*   installed device section. The HKEY passed in will be closed by the host
*   driver after CMD_INITIALIZE is completed.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    void
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/
VOID ReadRegistryInformation(PVAL pValue)
{
    HKEY hKey = NULL;
    if(NULL != pValue->pHandle){
        hKey = (HKEY)*pValue->pHandle;

        //
        // Open DeviceData section to read driver specific information
        //

        HKEY hOpenKey = NULL;
        if (RegOpenKeyEx(hKey,                     // handle to open key
                         TEXT("DeviceData"),       // address of name of subkey to open
                         0,                        // options (must be NULL)
                         KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                         &hOpenKey                 // address of handle to open key
                        ) == ERROR_SUCCESS) {

            DWORD dwWritten = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            LONG lSampleEntry = 0;
            RegQueryValueEx(hOpenKey,
                            TEXT("Sample Entry"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lSampleEntry,
                            &dwWritten);
            Trace(TEXT("lSampleEntry Value = %d"),lSampleEntry);
        } else {
            Trace(TEXT("Could not open DeviceData section"));
        }
    }
}

/**************************************************************************\
* InitScannerDefaults (helper)
*
*   Called by the MicroDriver to Initialize the SCANINFO structure
*
* Arguments:
*
*    none
*
* Return Value:
*
*    void
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

VOID InitScannerDefaults(PSCANINFO pScanInfo)
{

    pScanInfo->ADF                    = 0; // set to no ADF in Test device
    pScanInfo->RawDataFormat          = WIA_PACKED_PIXEL;
    pScanInfo->RawPixelOrder          = WIA_ORDER_BGR;
    pScanInfo->bNeedDataAlignment     = TRUE;

    pScanInfo->SupportedCompressionType = 0;
    pScanInfo->SupportedDataTypes     = SUPPORT_BW|SUPPORT_GRAYSCALE|SUPPORT_COLOR;

    pScanInfo->BedWidth               = 8500;  // 1000's of an inch (WIA compatible unit)
    pScanInfo->BedHeight              = 11000; // 1000's of an inch (WIA compatible unit)

    pScanInfo->OpticalXResolution     = 300;
    pScanInfo->OpticalYResolution     = 300;

    pScanInfo->IntensityRange.lMin    = -127;
    pScanInfo->IntensityRange.lMax    =  127;
    pScanInfo->IntensityRange.lStep   = 1;

    pScanInfo->ContrastRange.lMin     = -127;
    pScanInfo->ContrastRange.lMax     = 127;
    pScanInfo->ContrastRange.lStep    = 1;

    // Scanner settings
    pScanInfo->Intensity              = 0;
    pScanInfo->Contrast               = 0;

    pScanInfo->Xresolution            = 150;
    pScanInfo->Yresolution            = 150;

    pScanInfo->Window.xPos            = 0;
    pScanInfo->Window.yPos            = 0;
    pScanInfo->Window.xExtent         = (pScanInfo->Xresolution * pScanInfo->BedWidth)/1000;
    pScanInfo->Window.yExtent         = (pScanInfo->Yresolution * pScanInfo->BedHeight)/1000;

    // Scanner options
    pScanInfo->DitherPattern          = 0;
    pScanInfo->Negative               = 0;
    pScanInfo->Mirror                 = 0;
    pScanInfo->AutoBack               = 0;
    pScanInfo->ColorDitherPattern     = 0;
    pScanInfo->ToneMap                = 0;
    pScanInfo->Compression            = 0;

        // Image Info
    pScanInfo->DataType               = WIA_DATA_GRAYSCALE;
    pScanInfo->WidthPixels            = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos);

    switch(pScanInfo->DataType) {
    case WIA_DATA_THRESHOLD:
        pScanInfo->PixelBits = 1;
        break;
    case WIA_DATA_COLOR:
        pScanInfo->PixelBits = 24;
        break;
    case WIA_DATA_GRAYSCALE:
    default:
        pScanInfo->PixelBits = 8;
        break;
    }

    pScanInfo->WidthBytes = pScanInfo->Window.xExtent * (pScanInfo->PixelBits/8);
    pScanInfo->Lines      = pScanInfo->Window.yExtent;
}

/**************************************************************************\
* SetScannerSettings (helper)
*
*   Called by the MicroDriver to set the values stored in the SCANINFO structure
*   to the actual device.
*
* Arguments:
*
*     none
*
*
* Return Value:
*
*    TRUE - Success, FALSE - Failure
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

BOOL SetScannerSettings(PSCANINFO pScanInfo)
{
    if(pScanInfo->DataType == WIA_DATA_THRESHOLD) {
        pScanInfo->PixelBits = 1;
        pScanInfo->WidthBytes         = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos) * (pScanInfo->PixelBits/7);

        //
        // Set data type to device
        //

        // if the set fails..
        // return FALSE;
    }
    else if(pScanInfo->DataType == WIA_DATA_GRAYSCALE) {
        pScanInfo->PixelBits = 8;
        pScanInfo->WidthBytes         = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos) * (pScanInfo->PixelBits/8);

        //
        // Set data type to device
        //

        // if the set fails..
        // return FALSE;

    }
    else {
        pScanInfo->PixelBits = 24;
        pScanInfo->WidthBytes         = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos) * (pScanInfo->PixelBits/8);

        //
        // Set data type to device
        //

        // if the set fails..
        // return FALSE;

    }

#ifdef DEBUG
    Trace(TEXT("ScanInfo"));
    Trace(TEXT("x res = %d"),pScanInfo->Xresolution);
    Trace(TEXT("y res = %d"),pScanInfo->Yresolution);
    Trace(TEXT("bpp   = %d"),pScanInfo->PixelBits);
    Trace(TEXT("xpos  = %d"),pScanInfo->Window.xPos);
    Trace(TEXT("ypos  = %d"),pScanInfo->Window.yPos);
    Trace(TEXT("xext  = %d"),pScanInfo->Window.xExtent);
    Trace(TEXT("yext  = %d"),pScanInfo->Window.yExtent);
#endif

    //
    // send other values to device, use the values set in pScanInfo to set them to your
    // device.
    //

    return TRUE;
}

/**************************************************************************\
* InitializeScanner (helper)
*
*   Called by the MicroDriver to Iniitialize any device specific operations
*
* Arguments:
*
*    none
*
* Return Value:
*
*    TRUE - Success, FALSE - Failure
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

BOOL InitializeScanner(PSCANINFO pScanInfo)
{
    HRESULT hr = S_OK;

    //
    // Do any device initialization here...
    // The test device does not need any.
    //

    if (SUCCEEDED(hr)) {
        return TRUE;
    }
    return FALSE;
}

/**************************************************************************\
* CheckButtonStatus (helper)
*
*   Called by the MicroDriver to Set the current Button pressed value.
*
* Arguments:
*
*   pValue       - VAL structure used for settings
*
*
* Return Value:
*
*    VOID
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/


VOID CheckButtonStatus(PVAL pValue)
{
    //
    // Button Polling is done here...
    //

    //
    // Check your device for button presses
    //

    LONG lButtonValue = 0;

    GetButtonPress(&lButtonValue);
    switch (lButtonValue) {
    case 1:
        pValue->pGuid = (GUID*) &guidScanButton;
        Trace(TEXT("Scan Button Pressed!"));
        break;
    default:
        pValue->pGuid = (GUID*) &GUID_NULL;
        break;
    }
}
/**************************************************************************\
* GetInterruptEvent (helper)
*
*   Called by the MicroDriver to handle USB interrupt events.
*
* Arguments:
*
*   pValue       - VAL structure used for settings
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

HRESULT GetInterruptEvent(PVAL pValue)
{
    //
    // Below is a simple example of how DeviceIOControl() can be used to
    // determine interrupts with a USB device.
    //
    // The test device does not support events,
    // So this should not be called.
    //

    BYTE    InterruptData;
    DWORD   dwIndex;
    DWORD   dwError;

    OVERLAPPED Overlapped;
    ZeroMemory( &Overlapped, sizeof( Overlapped ));
    Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    HANDLE  hEventArray[2] = {pValue->handle, Overlapped.hEvent};
    BOOL    fLooping = TRUE;
    BOOL    bRet = TRUE;

    //
    // use the Handle created in CMD_INITIALIZE.
    //

    HANDLE  InterruptHandle = pValue->pScanInfo->DeviceIOHandles[1];

    while (fLooping) {

        //
        // Set the wait event, for the interrupt
        //

        bRet = DeviceIoControl( InterruptHandle,
                                IOCTL_WAIT_ON_DEVICE_EVENT,
                                NULL,
                                0,
                                &InterruptData,
                                sizeof(InterruptData),
                                &dwError,
                                &Overlapped );

        if ( bRet || ( !bRet && ( ::GetLastError() == ERROR_IO_PENDING ))) {

            //
            // Wait for the event to happen
            //

            dwIndex = WaitForMultipleObjects( 2,
                                              hEventArray,
                                              FALSE,
                                              INFINITE );

            //
            // Trap the result of the event
            //

            switch ( dwIndex ) {
                case WAIT_OBJECT_0+1:
                    DWORD dwBytesRet;
                    bRet = GetOverlappedResult( InterruptHandle, &Overlapped, &dwBytesRet, FALSE );

                    if ( dwBytesRet ) {

                        //
                        // assign the corresponding button GUID to the *pValue->pGuid
                        // member., and Set the event.
                        //

                        // Change detected - signal
                        if (*pValue->pHandle != INVALID_HANDLE_VALUE) {
                            switch ( InterruptData ) {
                            case 1:
                                *pValue->pGuid = guidScanButton;
                                Trace(TEXT("Scan Button Pressed!"));
                                break;
                            default:
                                *pValue->pGuid = GUID_NULL;
                                break;
                            }
                            Trace(TEXT("Setting This Event by Handle %d"),*pValue->pHandle);

                            //
                            // signal the event, after a button GUID was assigned.
                            //

                            SetEvent(*pValue->pHandle);
                        }
                        break;
                    }

                    //
                    // reset the overlapped event
                    //

                    ResetEvent( Overlapped.hEvent );
                    break;

                case WAIT_OBJECT_0:
                    // Fall through
                default:
                    fLooping = FALSE;
            }
        }
        else {
            dwError = ::GetLastError();
            break;
        }
    }
    return S_OK;
}

/**************************************************************************\
* GetButtonPress (helper)
*
*   Called by the MicroDriver to set the actual button value pressed
*
* Arguments:
*
*   pButtonValue       - actual button pressed
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

VOID GetButtonPress(LONG *pButtonValue)
{

    //
    // This where you can set your button value
    //

    pButtonValue = 0;
}

/**************************************************************************\
* GetButtonCount (helper)
*
*   Called by the MicroDriver to get the number of buttons a device supports
*
* Arguments:
*
*    none
*
* Return Value:
*
*    LONG - number of supported buttons
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

LONG GetButtonCount()
{
    LONG ButtonCount  = 0;

    //
    // Since the test device does not have a button,
    // set this value to 0.  For a real device with a button,
    // set (LONG ButtonCount  = 1;)
    //

    //
    // determine the button count of your device
    //

    return ButtonCount;
}

/**************************************************************************\
* GetOLDSTRResourceString (helper)
*
*   Called by the MicroDriver to Load a resource string in OLESTR format
*
* Arguments:
*
*   lResourceID  - String resource ID
*   ppsz         - Pointer to a OLESTR to be filled with the loaded string
*                  value
*   bLocal       - Possible, other source for loading a resource string.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

HRESULT GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        INT NumTCHARs = LoadString(g_hInst,lResourceID,szStringValue,sizeof(szStringValue));
        DWORD dwError = GetLastError();

        if (NumTCHARs <= 0) {

#ifdef UNICODE
            Trace(TEXT("NumTCHARs = %d dwError = %d Resource ID = %d (UNICODE)szString = %ws"),
                  NumTCHARs,
                  dwError,
                  lResourceID,
                  szStringValue);
#else
            Trace(TEXT("NumTCHARs = %d dwError = %d Resource ID = %d (ANSI)szString = %s"),
                  NumTCHARs,
                  dwError,
                  lResourceID,
                  szStringValue);
#endif

            return E_FAIL;
        }

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];
       ZeroMemory(wszStringValue,sizeof(wszStringValue));

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // looking another place for resources??
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* Trace
*
*   Called by the MicroDriver to output strings to a debugger
*
* Arguments:
*
*   format       - formatted string to output
*
*
* Return Value:
*
*    VOID
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

VOID Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanapi\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include "resource.h"
#include "wiamindr.h"
#include "fscanapi.h"
#include "scanapi.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scanapi.rc
//

#define IDS_SYSTRAY_TOOL_TIP    100
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\inc\fscanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       fscanapi.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _FSCANAPI_H
#define _FSCANAPI_H

//
// ID mappings to events
//

#define ID_FAKE_NOEVENT             0
#define ID_FAKE_SCANBUTTON          100
#define ID_FAKE_COPYBUTTON          200
#define ID_FAKE_FAXBUTTON           300
#define ID_FAKE_ADFEVENT            400

//
// Scanner library modes
//

#define FLATBED_SCANNER_MODE        100
#define SCROLLFED_SCANNER_MODE      200
#define MULTIFUNCTION_DEVICE_MODE   300

//
// Scanning states
//

#define SCAN_START                  0
#define SCAN_CONTINUE               1
#define SCAN_END                    3

//
// Root Item information (for property initialization)
//

typedef struct _ROOT_ITEM_INFORMATION {
    LONG ScanBedWidth;          // 1/1000ths of an inch
    LONG ScanBedHeight;         // 1/1000ths of an inch
    LONG OpticalXResolution;    // Optical X Resolution of device
    LONG OpticalYResolution;    // Optical X Resolution of device
    LONG MaxScanTime;           // Milliseconds (total scan time)

    LONG DocumentFeederWidth;   // 1/1000ths of an inch
    LONG DocumentFeederHeight;  // 1/1000ths of an inch
    LONG DocumentFeederCaps;    // Capabilites of the device with feeder
    LONG DocumentFeederStatus;  // Status of document feeder
    LONG MaxPageCapacity;       // Maximum page capacity of feeder
    LONG DocumentFeederReg;     // document feeder alignment
    LONG DocumentFeederHReg;    // document feeder justification alignment (HORIZONTAL)
    LONG DocumentFeederVReg;    // document feeder justification alignment (VERTICAL)
    WCHAR FirmwareVersion[25];  // Firmware version of device
}ROOT_ITEM_INFORMATION, *PROOT_ITEM_INFORMATION;

//
// Range data type helper structure (used below)
//

typedef struct _RANGEPROPERTY {
    LONG lMin;  // minimum value
    LONG lMax;  // maximum value
    LONG lNom;  // numinal value
    LONG lInc;  // increment/step value
} RANGEPROPERTY,*PRANGEPROPERTY;

//
// Top Item information (for property initialization)
//

typedef struct _TOP_ITEM_INFORMATION {
    BOOL          bUseResolutionList;   // TRUE - use default Resolution list,
                                        // FALSE - use RANGEPROPERTY values
    RANGEPROPERTY Contrast;             // valid values for contrast
    RANGEPROPERTY Brightness;           // valid values for brightness
    RANGEPROPERTY Threshold;            // valid values for threshold
    RANGEPROPERTY XResolution;          // valid values for x resolution
    RANGEPROPERTY YResolution;          // valid values for y resolution
    LONG          lMinimumBufferSize;   // minimum buffer size
    LONG          lMaxLampWarmupTime;   // maximum lamp warmup time
} TOP_ITEM_INFORMATION, *PTOP_ITEM_INFORMATION;

class CFakeScanAPI {
public:

    //
    // constructor/destructor
    //

    CFakeScanAPI()
    {

    }
    ~CFakeScanAPI()
    {

    }
    
    //
    // device initialization function
    //

    virtual HRESULT FakeScanner_Initialize() = 0;

    //
    // device setting functions
    //

    virtual HRESULT FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo) = 0;
    virtual HRESULT FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo)    = 0;
    virtual HRESULT FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)         = 0;

    //
    // device event functions
    //

    virtual HRESULT FakeScanner_GetDeviceEvent(LONG *pEvent)           = 0;
    virtual VOID    FakeScanner_SetInterruptEventHandle(HANDLE hEvent) = 0;
    virtual HRESULT DoEventProcessing()                                = 0;

    //
    // data acquisition functions
    //

    virtual HRESULT FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten) = 0;
    virtual HRESULT FakeScanner_SetDataType(LONG lDataType)   = 0;
    virtual HRESULT FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution) = 0;
    virtual HRESULT FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt) = 0;
    virtual HRESULT FakeScanner_SetContrast(LONG lContrast)   = 0;
    virtual HRESULT FakeScanner_SetIntensity(LONG lIntensity) = 0;

    //
    // standard device operations
    //

    virtual HRESULT FakeScanner_ResetDevice()   = 0;
    virtual HRESULT FakeScanner_SetEmulationMode(LONG lDeviceMode) = 0;
    virtual HRESULT FakeScanner_DisableDevice() = 0;
    virtual HRESULT FakeScanner_EnableDevice()  = 0;
    virtual HRESULT FakeScanner_DeviceOnline()  = 0;
    virtual HRESULT FakeScanner_Diagnostic()    = 0;

    //
    // Automatic document feeder functions
    //

    virtual HRESULT FakeScanner_ADFAttached()   = 0;
    virtual HRESULT FakeScanner_ADFHasPaper()   = 0;
    virtual HRESULT FakeScanner_ADFAvailable()  = 0;
    virtual HRESULT FakeScanner_ADFFeedPage()   = 0;
    virtual HRESULT FakeScanner_ADFUnFeedPage() = 0;
    virtual HRESULT FakeScanner_ADFStatus()     = 0;    
};

HRESULT CreateInstance(CFakeScanAPI **ppFakeScanAPI, LONG lMode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microdrv\inc\cio.h ===
#ifndef _CIO
#define _CIO

#include <STI.H>
#include <DEVIOCTL.H>
#include <SCSISCAN.H>

//
// These BUS_TYPE defines must match the ones in wiamicro.h
// I don't include wiamicro.h in this file, because
// the IO layer shouldn't know anything about the Micro driver
// except BUS_TYPE, and it makes a clean / non-circular include system
//

#define IO_BUS_TYPE_SCSI         200
#define IO_BUS_TYPE_USB          201
#define IO_BUS_TYPE_PARALLEL     202
#define IO_BUS_TYPE_FIREWIRE     203

//
// SCSI 
//

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16

//
// SRB Status
//

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23

#define SCSI_DIR_NONE                          0
#define SCSI_DIR_IN                         0x08
#define SCSI_DIR_OUT                        0x10
#define MAX_CDB_LENGTH                        12
#define MAX_SENSE_LENGTH                      16
#define SCSIREQLEN                            16

typedef struct {
        BYTE   SRB_Cmd;
        BYTE   SRB_HaId;
        BYTE   SRB_Target;
        BYTE   SRB_HaStat;
        BYTE   SRB_TargStat;
        BYTE   SRB_Status;
        BYTE   SRB_CDBLen;
        BYTE   CDBByte[MAX_CDB_LENGTH];
        BYTE   SRB_SenseLen;
        DWORD  SRB_BufLen;
        BYTE   SRB_Flags;
        BYTE   bReserved;
        LPBYTE SRB_BufPointer;
        BYTE   SenseArea[MAX_SENSE_LENGTH];
        LPVOID lpUserArea;
} CFM_SRB_ExecSCSICmd, *PCFM_SRB_ExecSCSICmd;

#define    SENSE_LENGTH    18

class CIO {

public:
     CIO(HANDLE hIO = NULL);
    ~CIO();
    VOID   SetBusType(LONG lBusType);
    VOID   SetIOHandle(HANDLE hIO);
    VOID   IO_INIT_EXT6SCANNERCMD( BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer );
    VOID   IO_INIT_6SCANNERCMD(BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer);
    VOID   IO_INIT_10SCANNERCMD(BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer);
    VOID   IO_INIT_12SCANNERCMD(BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer);
    VOID   IO_SET_SCANNERCMDINDEX( USHORT usIndex, BYTE bNewValue );
    BYTE   IO_GET_DATAINDEX( USHORT usRequestedIndex );
    BOOL   IO_COMMAND_NOT_OK( VOID );
    BYTE   IO_GET_SENSEKEY( VOID );
    BYTE   IO_GET_SENSECODE( VOID );
    BYTE   IO_GET_SENSECODEQUALIFIER( VOID );
    USHORT IO_GET_FULLSENSE( VOID );
    BOOL   IO_BUFFER_TO_BIG( VOID );
    BOOL   IO_IS_EOM( VOID );
    BOOL   IO_IS_ILI( VOID );
    DWORD  IO_GET_MISSINGDATA( VOID );
    DWORD  IO_GET_VALIDDATA( VOID );
    VOID   IO_GETCOMMAND(CFM_SRB_ExecSCSICmd* psrb);
    VOID   IO_SENDCOMMAND();
    VOID   CreateScsiReadCommand(SCSISCAN_CMD *pScsiScan, BYTE bCommandLength, DWORD dwBufferLength);
    HRESULT SendCommand(STI_RAW_CONTROL_CODE    EscapeFunction,
                        LPVOID                  pInData,
                        DWORD                   cbInDataSize,
                        LPVOID                  pOutData,
                        DWORD                   cbOutDataSize,
                        LPDWORD                 pcbActualData);
    USHORT MOTOROLA_USHORT(USHORT us);
    ULONG MOTOROLA_ULONG(ULONG ul);
private:
    UCHAR  m_ucSrbStatus;
    BYTE   m_abSenseArea[SENSE_LENGTH + 1];
    HANDLE m_hIO;
    LONG   m_lBusType;      

protected:
    CFM_SRB_ExecSCSICmd m_srb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanapi\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   29-Aug-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#       WIA Sample Scanner Library (fake scanner device library)
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=scanapi
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

PASS1_PUBLISH= \
    {$(O)\scanapi.lib=$(DDK_LIB_PATH)\scanapi.lib}


COFFBASE=usermode

INCLUDES= $(INCLUDES); \
          $(DDK_INC_PATH)


TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\iprop.lib  \
            $(SDK_LIB_PATH)\wiaguid.lib
            
SOURCES= \
        ..\scanapi.cpp \
        ..\scanapi.rc
    
PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanapi\scanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _SCANAPI_H
#define _SCANAPI_H

#include "fscanapi.h"

//
// helpful utils.
//

#ifdef UNICODE
    #define TSTRSTR wcsstr
    #define TSSCANF swscanf
#else
    #define TSTRSTR strstr
    #define TSSCANF sscanf
#endif

//
// Event Thread
//

VOID FakeScannerEventThread( LPVOID  lpParameter );

//
// event file names
//

#define SCANBUTTON_FILE TEXT("ScanButton.wia")
#define COPYBUTTON_FILE TEXT("CopyButton.wia")
#define FAXBUTTON_FILE  TEXT("FaxButton.wia")
#define ADF_FILE        TEXT("ADF.wia")

//
// event headers
//

#define LOADPAGES_HEADER  TEXT("[Load Pages]")
#define LOADPAGES_PAGES   TEXT("Pages=")
#define ADFERRORS_HEADER  TEXT("[ADF Error]")
#define ADFERRORS_ERROR   TEXT("Error=")
#define ADFERRORS_JAM     TEXT("jam")
#define ADFERRORS_EMPTY   TEXT("empty")
#define ADFERRORS_PROBLEM TEXT("problem")
#define ADFERRORS_GENERAL TEXT("general")
#define ADFERRORS_OFFLINE TEXT("offline")

//
// Scanner device constants
//

#define MAX_SCANNING_TIME    40000  // 40 seconds
#define MAX_LAMP_WARMUP_TIME 10000  // 10 seconds
#define MAX_PAGE_CAPACITY    25     // 25 pages

typedef struct _RAW_DATA_INFORMATION {
    LONG bpp;           // bits per pixel;
    LONG lWidthPixels;  // width of image in pixels
    LONG lHeightPixels; // height of image in pixels
    LONG lOffset;       // raw copy offset from top of raw buffer;
    LONG lXRes;         // x resolution
    LONG lYRes;         // y resolution
} RAW_DATA_INFORMATION,*PRAW_DATA_INFORMATION;

class CFScanAPI :public CFakeScanAPI {
public:

    //
    // constructor/destructor
    //

    CFScanAPI();
    ~CFScanAPI();
    
    //
    // device initialization function
    //

    HRESULT FakeScanner_Initialize();

    //
    // device setting functions
    //

    HRESULT FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo);
    HRESULT FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo);
    HRESULT FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);

    //
    // device event functions
    //

    HRESULT FakeScanner_GetDeviceEvent(LONG *pEvent);
    VOID    FakeScanner_SetInterruptEventHandle(HANDLE hEvent);
    HRESULT DoEventProcessing();

    //
    // data acquisition functions
    //

    HRESULT FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT FakeScanner_SetDataType(LONG lDataType);
    HRESULT FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT FakeScanner_SetContrast(LONG lContrast);
    HRESULT FakeScanner_SetIntensity(LONG lIntensity);

    //
    // standard device operations
    //

    HRESULT FakeScanner_ResetDevice();
    HRESULT FakeScanner_SetEmulationMode(LONG lDeviceMode);
    HRESULT FakeScanner_DisableDevice();
    HRESULT FakeScanner_EnableDevice();
    HRESULT FakeScanner_DeviceOnline();
    HRESULT FakeScanner_Diagnostic();

    //
    // Automatic document feeder functions
    //

    HRESULT FakeScanner_ADFAttached();
    HRESULT FakeScanner_ADFHasPaper();
    HRESULT FakeScanner_ADFAvailable();
    HRESULT FakeScanner_ADFFeedPage();
    HRESULT FakeScanner_ADFUnFeedPage();
    HRESULT FakeScanner_ADFStatus();
           
private:

#ifdef _USE_BITMAP_DATA

    HANDLE  m_hSrcFileHandle;       // Source bitmap data file handle
    HANDLE  m_hSrcMappingHandle;    // Source file mapping handle
    BYTE*   m_pSrcData;             // Source DIB pointer (24-bit only)
    HANDLE  m_hRawDataFileHandle;   // RAW data file handle
    HANDLE  m_hRawDataMappingHandle;// RAW data file mapping handle
    BYTE*   m_pRawData;             // RAW data pointer

#endif

    HANDLE  m_hEventHandle;         // Event to signal for Interrupt events
    HANDLE  m_hKillEventThread;     // Event to signal for shutdown of internal Event thread
    HANDLE  m_hEventNotifyThread;   // Event Thread handle
    LONG    m_lLastEvent;           // Last Event ID
    LONG    m_lMode;                // Fake scanner library mode
    LONG    m_PagesInADF;           // Current number of pages in the ADF
    BOOL    m_ADFIsAvailable;       // ADF available TRUE/FALSE
    HRESULT m_hrLastADFError;       // ADF errors
    FILETIME m_ftScanButton;        // Last Scan button file time
    FILETIME m_ftCopyButton;        // Last Copy button file time
    FILETIME m_ftFaxButton;         // Last Fax  button file time
    BOOL    m_bGreen;               // Are We Green?
    LONG    m_dwBytesWrittenSoFAR;  // How much data have we read so far?
    LONG    m_TotalDataInDevice;    // How much will we read total?
    
protected:
    
    //
    // RAW and SRC data information members
    //

    RAW_DATA_INFORMATION m_RawDataInfo; // Information about RAW data
    RAW_DATA_INFORMATION m_SrcDataInfo; // Information about SRC data
       
    //
    // RAW data conversion functions
    //

    HRESULT Load24bitScanData(LPTSTR szBitmapFileName);
    HRESULT Raw24bitToRawXbitData(LONG DestDepth, BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    HRESULT Raw24bitToRaw1bitBW(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    HRESULT Raw24bitToRaw8bitGray(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    HRESULT Raw24bitToRaw24bitColor(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    BOOL    SrcToRAW();
    VOID    CloseRAW();

    //
    // RAW data calculation helper functions
    //

    LONG    WidthToDIBWidth(LONG lWidth);
    LONG    CalcTotalImageSize();
    LONG    CalcRawByteWidth();
    LONG    CalcSrcByteWidth();
    LONG    CalcRandomDeviceDataTotalBytes();
    
    //
    // Byron's Rock'n Scaling routine (handles UP and DOWN samples)
    //
    
    HRESULT BQADScale(BYTE* pSrcBuffer, LONG  lSrcWidth, LONG  lSrcHeight,LONG  lSrcDepth,
                      BYTE* pDestBuffer,LONG  lDestWidth,LONG  lDestHeight);
        
    //
    // event helper functions
    //

    HRESULT CreateButtonEventFiles();
    BOOL IsValidDeviceEvent();
    HRESULT ProcessADFEvent();

    //
    // event file names w/ path information
    //

    TCHAR m_ScanButtonFile[MAX_PATH];
    TCHAR m_CopyButtonFile[MAX_PATH];
    TCHAR m_FaxButtonFile[MAX_PATH];
    TCHAR m_ADFEventFile[MAX_PATH];

    //
    // debugger trace helper function
    //

    VOID Trace(LPCTSTR format,...);
    
};

//
// FAKE SCANNER API Class pointer (used for Event Thread)
//

typedef CFakeScanAPI *PSCANNERDEVICE;

HRESULT CreateInstance(CFakeScanAPI **ppFakeScanAPI, LONG lMode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanpanl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scanpnl.rc
//

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif

#define IDC_STATIC                 (-1) // all static controls

#define IDD_SCANPANEL_DIALOG       1000
#define IDC_SCAN_BUTTON            1001
#define IDC_COPY_BUTTON            1002
#define IDC_FAX_BUTTON             1003

#define IDS_FIRE_FAKE_EVENT_FAILED 2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanpanl\scanpnl.cpp ===
// scanpnl.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
// application globals

HINSTANCE g_hInst;    // current instance of main application
HKEY g_hFakeEventKey; // event trigger key

///////////////////////////////////////////////////////////////////////////////
// main application

int WINAPI wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow )
{
    if (!hInstance) {
        return 0;
    }

    g_hInst = hInstance;

    //
    // open registry HKEY
    //

    DWORD dwDisposition = 0;
    if (RegCreateKeyEx(HKEY_USERS,
                       HKEY_WIASCANR_FAKE_EVENTS,
                       0,
                       NULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &g_hFakeEventKey,
                       &dwDisposition) == ERROR_SUCCESS) {
    }

    //
    // display front panel dialog
    //

    DialogBox(hInstance,(LPCTSTR)IDD_SCANPANEL_DIALOG,NULL,(DLGPROC)MainWindowProc);

    //
    // close registry HKEY
    //

    if (g_hFakeEventKey) {
        RegCloseKey(g_hFakeEventKey);
        g_hFakeEventKey = NULL;
    }

    return 0;
}

LRESULT CALLBACK MainWindowProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_SCAN_BUTTON:
            FireFakeEvent(hDlg,ID_FAKE_SCANBUTTON);
            break;
        case IDC_COPY_BUTTON:
            FireFakeEvent(hDlg,ID_FAKE_COPYBUTTON);
            break;
        case IDC_FAX_BUTTON:
            FireFakeEvent(hDlg,ID_FAKE_FAXBUTTON);
            break;
        default:
            break;
        }
        return TRUE;

    case WM_CLOSE:
        EndDialog(hDlg, LOWORD(wParam));
        return TRUE;

    default:
        break;
    }
    return FALSE;
}

VOID FireFakeEvent(HWND hDlg, DWORD dwEventCode)
{
    BOOL bEventSuccess = FALSE;
    if (g_hFakeEventKey) {

        //
        // write a clearing entry, to reset the previous event code
        //

        DWORD dwClearEventCode = 0;
        if (RegSetValueEx(g_hFakeEventKey,
                          WIASCANR_DWORD_FAKE_EVENT_CODE,
                          0,
                          REG_DWORD,
                          (BYTE*)&dwClearEventCode,
                          sizeof(dwClearEventCode)) == ERROR_SUCCESS) {

            //
            // event is cleared
            //

            if (RegSetValueEx(g_hFakeEventKey,
                              WIASCANR_DWORD_FAKE_EVENT_CODE,
                              0,
                              REG_DWORD,
                              (BYTE*)&dwEventCode,
                              sizeof(dwEventCode)) == ERROR_SUCCESS) {

                //
                // value was set
                //

                bEventSuccess = TRUE;
            }
        }
    }

    //
    // display an error message box, when the application can not fire the fake event
    //

    if(!bEventSuccess){
        TCHAR szErrorString[MAX_PATH];
        memset(szErrorString,0,sizeof(szErrorString));
        if(LoadString(g_hInst,IDS_FIRE_FAKE_EVENT_FAILED,szErrorString,(sizeof(szErrorString)/sizeof(szErrorString[0]))) > 0){

            //
            // display error message box
            //

            MessageBox(hDlg,szErrorString,NULL,MB_OK|MB_ICONEXCLAMATION);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanapi\scanapi.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#include "pch.h"
#include "scanapi.h"    // private header for SCANAPI
#include "time.h"

#define THREAD_TERMINATION_TIMEOUT 10000

CFScanAPI::CFScanAPI()
{

#ifdef _USE_BITMAP_DATA

    m_hSrcFileHandle        = NULL;
    m_hSrcMappingHandle     = NULL;
    m_pSrcData              = NULL; // 24-bit only
    m_pRawData              = NULL;
    m_hRawDataFileHandle    = NULL;
    m_hRawDataMappingHandle = NULL;

#endif

    m_hEventHandle          = NULL;
    m_hKillEventThread      = NULL;
    m_hEventNotifyThread    = NULL;
    m_lLastEvent            = ID_FAKE_NOEVENT;
    m_hrLastADFError        = S_OK;
    m_bGreen                = TRUE;
    m_dwBytesWrittenSoFAR   = 0;
    m_TotalDataInDevice     = 0;

    memset(&m_ftScanButton,0,sizeof(FILETIME));
    memset(&m_ftCopyButton,0,sizeof(FILETIME));
    memset(&m_ftFaxButton, 0,sizeof(FILETIME));
    memset(&m_RawDataInfo, 0,sizeof(RAW_DATA_INFORMATION));
    memset(&m_SrcDataInfo, 0,sizeof(RAW_DATA_INFORMATION));

}

CFScanAPI::~CFScanAPI()
{

#ifdef _USE_BITMAP_DATA

    if(m_hSrcMappingHandle){
        CloseHandle(m_hSrcMappingHandle);
        m_hSrcMappingHandle = NULL;
    }

    if(m_hSrcFileHandle){
        CloseHandle(m_hSrcFileHandle);
        m_hSrcFileHandle = NULL;
    }

    CloseRAW();

#endif

}

HRESULT CFScanAPI::FakeScanner_Initialize()
{
    HRESULT hr = E_FAIL;
    if (NULL == m_hEventNotifyThread) {

        //
        // create KILL event to signal, for device
        // shutdown of the fake scanner's events
        //

        m_hKillEventThread = CreateEvent(NULL,FALSE,FALSE,NULL);
        ::ResetEvent(m_hKillEventThread);
        if(NULL != m_hKillEventThread){

            //
            // create event thread, for file change status to fake scanner events
            //

            DWORD dwThread = 0;
            m_hEventNotifyThread = ::CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)FakeScannerEventThread,
                                                 (LPVOID)this,0,&dwThread);
            if(NULL != m_hEventNotifyThread){
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CFScanAPI::Load24bitScanData(LPTSTR szBitmapFileName)
{
    HRESULT hr = S_OK;

#ifdef _USE_BITMAP_DATA

    m_hSrcFileHandle = NULL;
    m_hSrcFileHandle = CreateFile(szBitmapFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
                OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

    if(NULL != m_hSrcFileHandle && INVALID_HANDLE_VALUE != m_hSrcFileHandle){

        m_hSrcMappingHandle = CreateFileMapping(m_hSrcFileHandle, NULL, PAGE_READONLY, 0, 0, NULL);
        m_pSrcData = (PBYTE)MapViewOfFileEx(m_hSrcMappingHandle, FILE_MAP_READ, 0, 0, 0,NULL);

        DWORD dwBytesRead = 0;
        m_pSrcData = m_pSrcData + sizeof(BITMAPFILEHEADER);
        if(m_pSrcData){

            //
            // check bitmap info
            //

            BITMAPINFOHEADER *pbmih;
            pbmih = (BITMAPINFOHEADER*)m_pSrcData;
            if(pbmih->biBitCount != 24){
                hr = E_INVALIDARG;
            } else {
                m_SrcDataInfo.bpp           = pbmih->biBitCount;
                m_SrcDataInfo.lHeightPixels = pbmih->biHeight;
                m_SrcDataInfo.lWidthPixels  = pbmih->biWidth;
                m_SrcDataInfo.lOffset       = 0;
            }
        }

    } else {
        hr = E_FAIL;
    }

    if(FAILED(hr)){
        CloseHandle(m_hSrcMappingHandle);
        m_hSrcMappingHandle = NULL;
        CloseHandle(m_hSrcFileHandle);
        m_hSrcFileHandle = NULL;
    }

#endif

    return hr;
}

HRESULT CFScanAPI::FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo)
{
    HRESULT hr = S_OK;

    //
    // Fill in Root item property defaults
    //

    if(m_lMode == SCROLLFED_SCANNER_MODE){
        pRootItemInfo->DocumentFeederCaps   = FEEDER;
        pRootItemInfo->DocumentFeederStatus = FEED_READY;
        pRootItemInfo->DocumentFeederHReg   = CENTERED;
        pRootItemInfo->DocumentFeederReg    = CENTERED;
    } else {
        pRootItemInfo->DocumentFeederCaps   = FEEDER|FLATBED;
        pRootItemInfo->DocumentFeederStatus = FLAT_READY;
        pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
        pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    }

    pRootItemInfo->DocumentFeederWidth  = 8500;
    pRootItemInfo->DocumentFeederHeight = 11000;
    pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederVReg   = TOP_JUSTIFIED;
    pRootItemInfo->MaxPageCapacity      = MAX_PAGE_CAPACITY;
    pRootItemInfo->MaxScanTime          = MAX_SCANNING_TIME;
    pRootItemInfo->OpticalXResolution   = 300;
    pRootItemInfo->OpticalYResolution   = 300;
    pRootItemInfo->ScanBedWidth         = 8500;
    pRootItemInfo->ScanBedHeight        = 11000;

    //
    // copy firmware version in string form to WCHAR array
    //

    lstrcpy(pRootItemInfo->FirmwareVersion,L"1.0a");

    return hr;
}
HRESULT CFScanAPI::FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo)
{
    HRESULT hr = S_OK;
    pTopItemInfo->bUseResolutionList    = TRUE; // use default resolution list

    pTopItemInfo->Brightness.lInc       = 1;
    pTopItemInfo->Brightness.lMax       = 200;
    pTopItemInfo->Brightness.lMin       = -200;
    pTopItemInfo->Brightness.lNom       = 10;

    pTopItemInfo->Contrast.lInc         = 1;
    pTopItemInfo->Contrast.lMax         = 200;
    pTopItemInfo->Contrast.lMin         = -200;
    pTopItemInfo->Contrast.lNom         = 10;

    pTopItemInfo->Threshold.lInc        = 1;
    pTopItemInfo->Threshold.lMax        = 200;
    pTopItemInfo->Threshold.lMin        = -200;
    pTopItemInfo->Threshold.lNom        = 10;

    pTopItemInfo->lMaxLampWarmupTime    = MAX_LAMP_WARMUP_TIME;
    pTopItemInfo->lMinimumBufferSize    = 262140;

    pTopItemInfo->XResolution.lInc      = 1;
    pTopItemInfo->XResolution.lMax      = 600;
    pTopItemInfo->XResolution.lMin      = 75;
    pTopItemInfo->XResolution.lNom      = 150;

    pTopItemInfo->YResolution.lInc      = 1;
    pTopItemInfo->YResolution.lMax      = 600;
    pTopItemInfo->YResolution.lMin      = 75;
    pTopItemInfo->YResolution.lNom      = 150;

    return hr;
}

HRESULT CFScanAPI::FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    HRESULT hr = S_OK;

    switch (lState) {
    case SCAN_START:
        m_dwBytesWrittenSoFAR = 0;
        m_TotalDataInDevice   = CalcRandomDeviceDataTotalBytes();
        break;
    case SCAN_CONTINUE:
        break;
    case SCAN_END:
        m_bGreen = TRUE; // set back to green
        return S_OK;
    default:
        break;
    }

    //Trace(TEXT("Requesting %d, of %d Total Image bytes"),dwBytesToRead,m_TotalDataInDevice);

    if (NULL != pData) {
        switch (m_RawDataInfo.bpp) {
        case 24:
            {
                //
                // write green data for color
                //

                BYTE *pTempData = pData;
                for (DWORD dwBytes = 0; dwBytes < dwBytesToRead; dwBytes+=3) {
                    if(m_bGreen){
                        pTempData[0] = 0;
                        pTempData[1] = 128;  // green
                        pTempData[2] = 0;
                    } else {
                        pTempData[0] = 0;
                        pTempData[1] = 0;
                        pTempData[2] = 128;  // blue
                    }
                    pTempData += 3;
                }
            }
            break;
        case 1:
        case 8:
        default:

            //
            // write simple gray for grayscale,
            // write vertical B/W stripes for threshold
            //

            if(m_bGreen){
                memset(pData,128,dwBytesToRead);
            } else {
                memset(pData,200,dwBytesToRead);
            }
            break;
        }
    }

    //
    // fill out bytes written
    //

    if(NULL != pdwBytesWritten){
        *pdwBytesWritten = dwBytesToRead;
    }

    if (m_bGreen) {
        m_bGreen = FALSE;
    } else {
        m_bGreen = TRUE;
    }

    if(m_lMode == SCROLLFED_SCANNER_MODE){

        //
        // keep track of bytes written so far
        //

        if(m_TotalDataInDevice == 0){

            //
            // no data left in device
            //

            *pdwBytesWritten = 0;
            Trace(TEXT("Device is out of Data..."));
            return hr;
        }

        if((LONG)dwBytesToRead > m_TotalDataInDevice){

            //
            // only give what is left in device
            //

            *pdwBytesWritten = dwBytesToRead;
            //*pdwBytesWritten    = m_TotalDataInDevice;
            //Trace(TEXT("Device only has %d left..."),m_TotalDataInDevice);
            m_TotalDataInDevice = 0;
        } else {

            //
            // give full amount requested
            //

            m_TotalDataInDevice -= dwBytesToRead;
            if(m_TotalDataInDevice < 0){
                m_TotalDataInDevice = 0;
            }
        }

    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetDataType(LONG lDataType)
{
    HRESULT hr = S_OK;
    switch(lDataType){
    case WIA_DATA_COLOR:
        m_RawDataInfo.bpp = 24;
        break;
    case WIA_DATA_THRESHOLD:
        m_RawDataInfo.bpp = 1;
        break;
    case WIA_DATA_GRAYSCALE:
        m_RawDataInfo.bpp = 8;
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    HRESULT hr = S_OK;
    m_RawDataInfo.lXRes = lXResolution;
    m_RawDataInfo.lYRes = lYResolution;
    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    HRESULT hr = S_OK;

    //
    // record RAW data width and height
    //

    m_RawDataInfo.lWidthPixels  = lXExt;
    m_RawDataInfo.lHeightPixels = lYExt;
    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetContrast(LONG lContrast)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Contrast
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetIntensity(LONG lIntensity)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Intensity
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_DisableDevice()
{
    HRESULT hr = S_OK;

    if (m_hKillEventThread) {

        //
        // signal event thread to shutdown
        //

        //::SetEvent(m_hKillEventThread);

        if (!SetEvent(m_hKillEventThread)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        } else {

            if (NULL != m_hEventNotifyThread) {

                //
                // WAIT for thread to terminate, if one exists
                //

                DWORD dwResult = WaitForSingleObject(m_hEventNotifyThread,THREAD_TERMINATION_TIMEOUT);
                switch (dwResult) {
                case WAIT_TIMEOUT:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                case WAIT_OBJECT_0:
                    hr = S_OK;
                    break;
                case WAIT_ABANDONED:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                case WAIT_FAILED:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                default:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                }
            }

            //
            // Close event for syncronization of notifications shutdown.
            //

            CloseHandle(m_hKillEventThread);
            m_hKillEventThread = NULL;
        }
    }

    //
    // terminate thread
    //

    if (NULL != m_hEventNotifyThread) {
        CloseHandle(m_hEventNotifyThread);
        m_hEventNotifyThread = NULL;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_EnableDevice()
{
    HRESULT hr = S_OK;

    //
    // do nothing.. (unused at this time)
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_DeviceOnline()
{
    HRESULT hr = S_OK;

    //
    // Fake device is always on-line
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_Diagnostic()
{
    HRESULT hr = S_OK;

    //
    // Fake device is always healthy
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    HRESULT hr = E_FAIL;

    //
    // get our Root item settings, so we can use the width and height values
    //

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if(SUCCEEDED(hr)) {
        *pWidth  = RootItemInfo.ScanBedWidth;
        *pHeight = RootItemInfo.ScanBedHeight;
    }
    return hr;
}

HRESULT CFScanAPI::FakeScanner_GetDeviceEvent(LONG *pEvent)
{
    HRESULT hr = S_OK;
    if(pEvent){

        //
        // assign event ID
        //

        *pEvent      = m_lLastEvent;

        //Trace(TEXT("FakeScanner_GetDeviceEvent() ,m_lLastEvent = %d"),m_lLastEvent);

        //
        // reset event ID
        //

        m_lLastEvent = ID_FAKE_NOEVENT;

    } else {
        hr = E_INVALIDARG;
    }
    return hr;
}

VOID CFScanAPI::FakeScanner_SetInterruptEventHandle(HANDLE hEvent)
{

    //
    // save event handle, created by main driver, so we can signal it
    // when we have a "hardware" event (like button presses)
    //

    m_hEventHandle = hEvent;
    //Trace(TEXT("Interrupt Handle Set in Fake Device = %d"),m_hEventHandle);
}

//
// standard device operations
//

HRESULT CFScanAPI::FakeScanner_ResetDevice()
{
    HRESULT hr = S_OK;

    //
    // do nothing..
    //

    return hr;
}
HRESULT CFScanAPI::FakeScanner_SetEmulationMode(LONG lDeviceMode)
{
    HRESULT hr = S_OK;

    switch(lDeviceMode){
    case SCROLLFED_SCANNER_MODE:
        {

            //
            // set any library restrictions for scroll fed scanners
            //

            m_lMode = SCROLLFED_SCANNER_MODE;
        }
        break;
    case MULTIFUNCTION_DEVICE_MODE:
        {

            //
            // set any library restrictions for multi-function devices
            //

            m_lMode = SCROLLFED_SCANNER_MODE;
        }
        break;
    default:
        {

            //
            // set any library restrictions for scroll flatbed scanners
            //

            m_lMode = FLATBED_SCANNER_MODE;
        }
        break;
    }

    return hr;
}

//
// Automatic document feeder functions
//

HRESULT CFScanAPI::FakeScanner_ADFHasPaper()
{
    HRESULT hr = S_OK;

    //
    // check paper count
    //

    if(m_PagesInADF <= 0){
         hr = S_FALSE;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFAvailable()
{
    HRESULT hr = S_OK;

    //
    // check ADF on-line
    //

    if(!m_ADFIsAvailable){
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFFeedPage()
{
    HRESULT hr = S_OK;

    if(S_OK != FakeScanner_ADFHasPaper()){

        //
        // set paper empty error code
        //

        hr = WIA_ERROR_PAPER_EMPTY;
    }

    //
    // update paper count for ADF
    //

    m_PagesInADF--;

    if(m_PagesInADF <0){
        m_PagesInADF = 0;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFUnFeedPage()
{
    HRESULT hr = S_OK;

    //
    // do nothing.. paper will always eject
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFStatus()
{
    return m_hrLastADFError;
}

HRESULT CFScanAPI::FakeScanner_ADFAttached()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRawXbitData(LONG DestDepth, BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr = E_INVALIDARG;
    switch(DestDepth){
    case 1:
        hr = Raw24bitToRaw1bitBW(pDestBuffer, pSrcBuffer, lSrcWidth, lSrcHeight);
        break;
    case 8:
        hr = Raw24bitToRaw8bitGray(pDestBuffer, pSrcBuffer, lSrcWidth, lSrcHeight);
        break;
    case 24:
        hr = Raw24bitToRaw24bitColor(pDestBuffer, pSrcBuffer, lSrcWidth, lSrcHeight);
        break;
    default:
        break;
    }
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRaw1bitBW(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr = S_OK;
    BYTE* ptDest = NULL;
    BYTE* ptSrc  = NULL;

    int BitIdx    = 0;
    BYTE Bits     = 0;
    BYTE GrayByte = 0;

    for (LONG lHeight =0; lHeight < lSrcHeight; lHeight++) {
        ptDest = pDestBuffer + (lHeight*((lSrcWidth+7)/8));
        ptSrc  = pSrcBuffer + lHeight*lSrcWidth*3;
        BitIdx = 0;
        Bits   = 0;
        for (LONG lWidth =0; lWidth < lSrcWidth; lWidth++) {
            GrayByte = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
            Bits *= 2;
            if (GrayByte > 128) Bits +=  1;
            BitIdx++;
            if (BitIdx >= 8) {
                BitIdx = 0;
                *ptDest++ = Bits;
            }
            ptSrc += 3;
        }
        // Write out the last byte if matters
        if (BitIdx)
            *ptDest = Bits;
    }
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRaw8bitGray(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr   = S_OK;
    BYTE* ptDest = NULL;
    BYTE* ptSrc  = NULL;

    for (LONG lHeight=0; lHeight < lSrcHeight; lHeight++) {
        ptDest = pDestBuffer + (lHeight*lSrcWidth);
        ptSrc  = pSrcBuffer  + lHeight*lSrcWidth*3;
        for (LONG lWidth =0; lWidth < lSrcWidth; lWidth++) {
            *ptDest++ = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
            ptSrc += 3;
        }
    }
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRaw24bitColor(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr = S_OK;
    BYTE* ptDest = NULL;
    BYTE* ptSrc  = NULL;

    for (LONG lHeight=0; lHeight < lSrcHeight; lHeight++) {
        ptDest = pDestBuffer + lHeight*lSrcWidth*3;
        ptSrc  = pSrcBuffer  + lHeight*lSrcWidth*3;
        for (LONG lWidth =0; lWidth < lSrcWidth; lWidth++) {
            ptDest[0] = ptSrc[2];
            ptDest[1] = ptSrc[1];
            ptDest[2] = ptSrc[0];
            ptDest+=3;
            ptSrc+=3;
        }
    }
    return hr;
}

LONG CFScanAPI::WidthToDIBWidth(LONG lWidth)
{
    return(lWidth+3)&0xfffffffc;
}

VOID CFScanAPI::CloseRAW()
{
#ifdef _USE_BITMAP_DATA

    CloseHandle(m_hRawDataMappingHandle);
    m_hRawDataMappingHandle = NULL;
    CloseHandle(m_hRawDataFileHandle);
    m_hRawDataFileHandle = NULL;
    m_pRawData = NULL;
#endif
}

BOOL CFScanAPI::SrcToRAW()
{
#ifdef _USE_BITMAP_DATA
    CloseRAW();
    UNALIGNED BITMAPINFOHEADER *pbmih;
    pbmih = (BITMAPINFOHEADER*)m_pSrcData;
    if(pbmih){
        BYTE* pSrc = m_pSrcData + sizeof(BITMAPINFOHEADER);
        if(pSrc){

            //
            // allocate buffer large enough for entire RAW data set
            //

            LONG lTotalImageSize = CalcTotalImageSize();
            m_hRawDataFileHandle = CreateFile(TEXT("Raw.RAW"), GENERIC_WRITE | GENERIC_READ,
                                              FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                              NULL);

            DWORD   dwHighSize = 0;
            DWORD   dwLowSize  = 0;

            dwLowSize  = lTotalImageSize;


            m_hRawDataMappingHandle = CreateFileMapping(m_hRawDataFileHandle,NULL,
                                           PAGE_READWRITE,dwHighSize, dwLowSize, NULL);

            m_pRawData = (PBYTE)MapViewOfFileEx(m_hRawDataMappingHandle, FILE_MAP_WRITE,
                                         0,0, dwLowSize, NULL);

            if (m_pRawData) {

                memset(m_pRawData,255,lTotalImageSize);

                //
                // copy SRC to RAW buffer
                //

                LONG lRawWidthBytes    = CalcRawByteWidth();
                LONG lPadPerLineBytes  = pbmih->biWidth % 4;
                LONG lSrcWidthBytes    = ((pbmih->biWidth *3) + lPadPerLineBytes);
                LONG lPixPerPixCount   = (LONG)((m_RawDataInfo.lWidthPixels / pbmih->biWidth));
                LONG lLinePerLineCount = (LONG)((m_RawDataInfo.lHeightPixels / pbmih->biHeight));

                BYTE *pDst     = m_pRawData;
                BYTE *pCurDst  = pDst;
                BYTE *pCurSrc  = pSrc;
                BYTE *pTempSrc = pSrc;

                DWORD dwBytesWritten = 0;
                DWORD dwBytesRead    = 0;
                DWORD dwRawWidthBytes = 0;

                for (LONG lHeight = 0; lHeight < pbmih->biHeight; lHeight++){

                    // up sample data..
                    for (LONG lRawHeight = 0; lRawHeight < lLinePerLineCount; lRawHeight++) {
                        pTempSrc = pCurSrc;
                        for (LONG lWidth = 0; lWidth < pbmih->biWidth; lWidth++) {
                            for (LONG lPixCount = 0; lPixCount < lPixPerPixCount; lPixCount++) {
                                memcpy(pCurDst,pTempSrc,3);
                                pCurDst         += 3;
                                dwBytesWritten  += 3;
                            }
                            pTempSrc    += 3;
                            dwBytesRead += 3;
                        }
                        pTempSrc    += lPadPerLineBytes;
                        dwBytesRead += lPadPerLineBytes;
                        dwRawWidthBytes = 0;
                    }
                    pCurSrc = pTempSrc;

                    // same data to same data...
                    /*
                    memcpy(pCurDst,pCurSrc,lSrcWidthBytes - lPadPerLineBytes);
                    pCurSrc         += lSrcWidthBytes;
                    dwBytesRead     += lSrcWidthBytes;
                    pCurDst         += lRawWidthBytes;
                    dwBytesWritten  += lRawWidthBytes;
                    */
                }
                m_RawDataInfo.lOffset = 0;
                return TRUE;
            }
        }
    }
#endif
    return FALSE;
}

LONG CFScanAPI::CalcTotalImageSize()
{
    LONG lTotalSize = 0;
    switch(m_RawDataInfo.bpp){
    case 1:
        lTotalSize = ((m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lTotalSize = m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lTotalSize = (m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lTotalSize;
}

LONG CFScanAPI::CalcRawByteWidth()
{
    LONG lRawWidthBytes = 0;
    switch(m_RawDataInfo.bpp){
    case 1:
        lRawWidthBytes = ((m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lRawWidthBytes = m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lRawWidthBytes = (m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lRawWidthBytes;
}

LONG CFScanAPI::CalcSrcByteWidth()
{
    LONG lSrcWidthBytes = 0;
    switch(m_SrcDataInfo.bpp){
    case 1:
        lSrcWidthBytes = ((m_SrcDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lSrcWidthBytes = m_SrcDataInfo.lWidthPixels;
        break;
    case 24:
        lSrcWidthBytes = (m_SrcDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lSrcWidthBytes;
}

HRESULT CFScanAPI::BQADScale(BYTE* pSrcBuffer, LONG  lSrcWidth, LONG  lSrcHeight, LONG  lSrcDepth,
                                BYTE* pDestBuffer,LONG  lDestWidth,LONG  lDestHeight)
{
    //
    //  We only deal with 1, 8 and 24 bit data
    //

    if ((lSrcDepth != 8) && (lSrcDepth != 1) && (lSrcDepth != 24)) {
        return E_INVALIDARG;
    }

    //
    // Make adjustments so we also work in all supported bit depths.  We can get a performance increase
    // by having separate implementations of all of these, but for now, we stick to a single generic
    // implementation.
    //

    LONG    lBytesPerPixel = (lSrcDepth + 7) / 8;
    ULONG   lSrcRawWidth = ((lSrcWidth * lSrcDepth) + 7) / 8;     // This is the width in pixels
    ULONG   lSrcWidthInBytes;                                     // This is the DWORD-aligned width in bytes
    ULONG   lDestWidthInBytes;                                    // This is the DWORD-aligned width in bytes

    //
    // We need to work out the DWORD aligned width in bytes.  Normally we would do this in one step
    // using the supplied lSrcDepth, but we avoid arithmetic overflow conditions that happen
    // in 24bit if we do it in 2 steps like this instead.
    //

    if (lSrcDepth == 1) {
        lSrcWidthInBytes    = (lSrcWidth + 7) / 8;
        lDestWidthInBytes   = (lDestWidth + 7) / 8;
    } else {
        lSrcWidthInBytes    = (lSrcWidth * lBytesPerPixel);
        lDestWidthInBytes   = (lDestWidth * lBytesPerPixel);
    }
    lSrcWidthInBytes    += (lSrcWidthInBytes % 4) ? (4 - (lSrcWidthInBytes % 4)) : 0;

    //
    // uncomment to work with ALIGNED data
    // lDestWidthInBytes   += (lDestWidthInBytes % 4) ? (4 - (lDestWidthInBytes % 4)) : 0;
    //

    //
    //  Define local variables and do the initial calculations needed for
    //  the scaling algorithm
    //

    BYTE    *pDestPixel     = NULL;
    BYTE    *pSrcPixel      = NULL;
    BYTE    *pEnd           = NULL;
    BYTE    *pDestLine      = NULL;
    BYTE    *pSrcLine       = NULL;
    BYTE    *pEndLine       = NULL;

    LONG    lXEndSize = lBytesPerPixel * lDestWidth;

    LONG    lXNum = lSrcWidth;      // Numerator in X direction
    LONG    lXDen = lDestWidth;     // Denomiator in X direction
    LONG    lXInc = (lXNum / lXDen) * lBytesPerPixel;  // Increment in X direction

    LONG    lXDeltaInc = lXNum % lXDen;     // DeltaIncrement in X direction
    LONG    lXRem = 0;              // Remainder in X direction

    LONG    lYNum = lSrcHeight;     // Numerator in Y direction
    LONG    lYDen = lDestHeight;    // Denomiator in Y direction
    LONG    lYInc = (lYNum / lYDen) * lSrcWidthInBytes; // Increment in Y direction
    LONG    lYDeltaInc = lYNum % lYDen;     // DeltaIncrement in Y direction
    LONG    lYDestInc = lDestWidthInBytes;
    LONG    lYRem = 0;              // Remainder in Y direction

    pSrcLine    = pSrcBuffer;       // This is where we start in the source
    pDestLine   = pDestBuffer;      // This is the start of the destination buffer
                                    // This is where we end overall
    pEndLine    = pDestBuffer + ((lDestWidthInBytes - 1) * lDestHeight);

    while (pDestLine < pEndLine) {  // Start LoopY (Decides where the src and dest lines start)

        pSrcPixel   = pSrcLine;     // We're starting at the beginning of a new line
        pDestPixel  = pDestLine;
                                    // Calc. where we end the line
        pEnd = pDestPixel + lXEndSize;
        lXRem = 0;                  // Reset the remainder for the horizontal direction

        while (pDestPixel < pEnd) {     // Start LoopX (puts pixels in the destination line)

                                        // Put the pixel
            if (lBytesPerPixel > 1) {
                pDestPixel[0] = pSrcPixel[0];
                pDestPixel[1] = pSrcPixel[1];
                pDestPixel[2] = pSrcPixel[2];
            } else {
                *pDestPixel = *pSrcPixel;
            }
                                        // Move the destination pointer to the next pixel
            pDestPixel += lBytesPerPixel;
            pSrcPixel += lXInc;         // Move the source pointer over by the horizontal increment
            lXRem += lXDeltaInc;        // Increase the horizontal remainder - this decides when we "overflow"

            if (lXRem >= lXDen) {       // This is our "overflow" condition.  It means we're now one
                                        // pixel off.
                pSrcPixel += lBytesPerPixel;                // In Overflow case, we need to shift one pixel over
                lXRem -= lXDen;         // Decrease the remainder by the X denominator.  This is essentially
                                        // lXRem MOD lXDen.
            }
        }                               // End LoopX   (puts pixels in the destination line)

        pSrcLine += lYInc;          // We've finished a horizontal line, time to move to the next one
        lYRem += lYDeltaInc;        // Increase our vertical remainder.  This decides when we "overflow"

        if (lYRem > lYDen) {        // This is our vertical overflow condition.
                                    // We need to move to the next line down
            pSrcLine += lSrcWidthInBytes;
            lYRem -= lYDen;         // Decrease the remainder by the Y denominator.    This is essentially
                                    // lYRem MOD lYDen.
        }
        pDestLine += lYDestInc;     // Move the destination pointer to the start of the next line in the
                                    // destination buffer
    }                               // End LoopY   (Decides where the src and dest lines start)
    return S_OK;
}

LONG CFScanAPI::CalcRandomDeviceDataTotalBytes()
{
    LONG lTotalBytes = 0;
    srand((unsigned)time(NULL));
    LONG lPageLengthInches = ((rand()%17) + 5);// max 22 inches, and min of 5 inches
    Trace(TEXT("Random Page Length is %d inches"),lPageLengthInches);

    LONG lImageHeight = m_RawDataInfo.lYRes * lPageLengthInches;
    Trace(TEXT("Random Page Length is %d pixels"),lImageHeight);

    lTotalBytes = (CalcRawByteWidth() * lImageHeight);
    Trace(TEXT("Random Page Total Data Size = %d"),lTotalBytes);
    return lTotalBytes;
}

HRESULT CFScanAPI::CreateButtonEventFiles()
{
    HRESULT hr = E_FAIL;
    HANDLE hFileHandle = NULL;
    TCHAR   szSystemDirectory[MAX_PATH];    // system directory
    UINT    uiSystemPathLen      = 0;       // length of system path
    uiSystemPathLen = GetSystemDirectory(szSystemDirectory,MAX_PATH);
    if (uiSystemPathLen <= 0) {
        return E_FAIL;
    }

    memset(m_ScanButtonFile,0,(sizeof(TCHAR) * MAX_PATH));
    lstrcpy(m_ScanButtonFile,szSystemDirectory);
    lstrcat(m_ScanButtonFile,TEXT("\\"));
    lstrcat(m_ScanButtonFile,SCANBUTTON_FILE);

    //
    // create Scan button event file
    //

    hFileHandle = CreateFile(m_ScanButtonFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,NULL);
    if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {
        CloseHandle(hFileHandle);
        hFileHandle = NULL;
        memset(m_CopyButtonFile,0,(sizeof(TCHAR) * MAX_PATH));
        lstrcpy(m_CopyButtonFile,szSystemDirectory);
        lstrcat(m_CopyButtonFile,TEXT("\\"));
        lstrcat(m_CopyButtonFile,COPYBUTTON_FILE);

        //
        // create Copy button event file
        //

        hFileHandle = CreateFile(m_CopyButtonFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,NULL);
        if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {
            CloseHandle(hFileHandle);
            hFileHandle = NULL;
            memset(m_FaxButtonFile,0,(sizeof(TCHAR) * MAX_PATH));
            lstrcpy(m_FaxButtonFile,szSystemDirectory);
            lstrcat(m_FaxButtonFile,TEXT("\\"));
            lstrcat(m_FaxButtonFile,FAXBUTTON_FILE);

            //
            // create Fax button event file
            //

            hFileHandle = CreateFile(m_FaxButtonFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,NULL);
            if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {
                CloseHandle(hFileHandle);
                hFileHandle = NULL;
                memset(m_ADFEventFile,0,(sizeof(TCHAR) * MAX_PATH));
                lstrcpy(m_ADFEventFile,szSystemDirectory);
                lstrcat(m_ADFEventFile,TEXT("\\"));
                lstrcat(m_ADFEventFile,ADF_FILE);

                //
                // create ADF load event file
                //

                hFileHandle = CreateFile(m_ADFEventFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,NULL);
                if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {

                    //
                    // write default headers to ADF event file
                    //

                    SetEndOfFile(hFileHandle);

                    TCHAR szBuffer[1024];
                    memset(szBuffer,0,sizeof(szBuffer));
                    _stprintf(szBuffer,TEXT("%s\r\n%s10\r\n%s\r\n%s\r\n"),LOADPAGES_HEADER,
                                                                        LOADPAGES_PAGES,
                                                                        ADFERRORS_HEADER,
                                                                        ADFERRORS_ERROR);

                    DWORD dwBytesWritten = 0;
                    WriteFile(hFileHandle,szBuffer,(lstrlen(szBuffer)*sizeof(TCHAR)),&dwBytesWritten,NULL);
                    CloseHandle(hFileHandle);
                    hFileHandle = NULL;
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

HRESULT CFScanAPI::DoEventProcessing()
{
    HRESULT hr = E_FAIL;

    //
    // loop checking for file change messages
    //

    if(FAILED(CreateButtonEventFiles())){
        return E_FAIL;
    }

    //
    // call IsValidDeviceEvent() once, to set internal variables
    //

    IsValidDeviceEvent();

    HANDLE  hNotifyFileSysChange = NULL;    // handle to file change object
    DWORD   dwErr                = 0;       // error return value
    TCHAR   szSystemDirectory[MAX_PATH];    // system directory
    UINT    uiSystemPathLen      = 0;       // length of system path
    uiSystemPathLen = GetSystemDirectory(szSystemDirectory,MAX_PATH);
    if(uiSystemPathLen <= 0){
        return E_FAIL;
    }

    hNotifyFileSysChange = FindFirstChangeNotification(szSystemDirectory,
                                                       FALSE,
                                                       FILE_NOTIFY_CHANGE_SIZE |
                                                       FILE_NOTIFY_CHANGE_LAST_WRITE |
                                                       FILE_NOTIFY_CHANGE_FILE_NAME |
                                                       FILE_NOTIFY_CHANGE_DIR_NAME);

    if (hNotifyFileSysChange == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    //
    // set up event handle array. (Kill Thread handle, and File change handle)
    //

    HANDLE  hEvents[2] = {m_hKillEventThread,hNotifyFileSysChange};

    //
    // set looping to TRUE
    //

    BOOL    bLooping = TRUE;

    //
    // Wait for file system change or kill event thread event.
    //

    while (bLooping) {

        //
        // Wait
        //

        dwErr = ::WaitForMultipleObjects(2,hEvents,FALSE,INFINITE);

        //
        // process signal
        //

        switch (dwErr) {
        case WAIT_OBJECT_0+1:   // FILE CHANGED EVENT

            //
            // check to see if it was one of our "known" files that
            // changed
            //

            if(IsValidDeviceEvent()){

                //
                // signal the interrupt handle if it exists
                //

                if(NULL != m_hEventHandle){

                    //
                    // set the event
                    //
                    //Trace(TEXT("signaling Event Handle (%d)"),m_hEventHandle);
                    ::SetEvent(m_hEventHandle);
                } else {
                    //Trace(TEXT("No Event Handle to signal"));
                }
            }

            //
            // Wait again.. for next file system event
            //

            FindNextChangeNotification(hNotifyFileSysChange);
            break;
        case WAIT_OBJECT_0:     // SHUTDOWN EVENT

            //
            // set looping boolean to FALSE, so we exit out thread
            //

            bLooping = FALSE;
            break;
        default:

            //
            // do nothing...we don't know
            //

            break;
        }
    }

    //
    // close file system event handle
    //

    FindCloseChangeNotification(hNotifyFileSysChange);
    return S_OK;
}

BOOL CFScanAPI::IsValidDeviceEvent()
{
    BOOL bValidEvent = FALSE;

    LARGE_INTEGER   liNewHugeSize;
    FILETIME        ftLastWriteTime;
    WIN32_FIND_DATA sNewFileAttributes;

    HANDLE          hFind   = INVALID_HANDLE_VALUE;
    DWORD           dwError = NOERROR;

    ////////////////////////////////////////////////////////////
    // Scan Button file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_ScanButtonFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftScanButton,&ftLastWriteTime) == -1) {

            //
            // we have a Button event...so set the event flag to TRUE
            // and set the BUTTON ID to the correct event.
            //
            //Trace(TEXT("Scan button pressed on fake Hardware"));
            bValidEvent  = TRUE;
            m_lLastEvent = ID_FAKE_SCANBUTTON;
        }
        m_ftScanButton = ftLastWriteTime;

    }

    ////////////////////////////////////////////////////////////
    // Copy Button file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_CopyButtonFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftCopyButton,&ftLastWriteTime) == -1) {

            //
            // we have a Button event...so set the event flag to TRUE
            // and set the BUTTON ID to the correct event.
            //

            bValidEvent  = TRUE;
            m_lLastEvent = ID_FAKE_COPYBUTTON;
        }
        m_ftCopyButton = ftLastWriteTime;
    }

    ////////////////////////////////////////////////////////////
    // Fax Button file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_FaxButtonFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftFaxButton,&ftLastWriteTime) == -1) {

            //
            // we have a Button event...so set the event flag to TRUE
            // and set the BUTTON ID to the correct event.
            //

            bValidEvent  = TRUE;
            m_lLastEvent = ID_FAKE_FAXBUTTON;
        }
        m_ftFaxButton = ftLastWriteTime;
    }

    ////////////////////////////////////////////////////////////
    // ADF Event file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_ADFEventFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftFaxButton,&ftLastWriteTime) == -1) {

            //
            // we have an ADF event...so set the event flag to TRUE
            // and set the ID to the correct event.
            //

            //bValidEvent  = TRUE;
            //m_lLastEvent = ID_FAKE_ADFEVENT;
            ProcessADFEvent();
        }
        m_ftFaxButton = ftLastWriteTime;
    }

    return bValidEvent;
}

HRESULT CFScanAPI::ProcessADFEvent()
{
    HRESULT hr = S_OK;

    m_PagesInADF = GetPrivateProfileInt(TEXT("Load Pages"),
                                  TEXT("Pages"),
                                  10,
                                  m_ADFEventFile);

    Trace(TEXT("ADF has %d pages loaded"),m_PagesInADF);

    DWORD dwReturn = 0;
    TCHAR szError[MAX_PATH];
    memset(szError,0,sizeof(szError));

    dwReturn = GetPrivateProfileString(TEXT("ADF Error"),
                                       TEXT("Error"),
                                       TEXT(""),
                                       szError,
                                       (sizeof(szError)/sizeof(TCHAR)),
                                       m_ADFEventFile);

    if (lstrlen(szError) > 0) {
        if (lstrcmpi(szError,ADFERRORS_JAM) == 0) {
            m_hrLastADFError = WIA_ERROR_PAPER_JAM;
            Trace(TEXT("ADF has a paper JAM"));
        } else if (lstrcmpi(szError,ADFERRORS_EMPTY) == 0) {
            m_hrLastADFError = WIA_ERROR_PAPER_EMPTY;
            Trace(TEXT("ADF has no paper"));
        } else if (lstrcmpi(szError,ADFERRORS_PROBLEM) == 0) {
            m_hrLastADFError = WIA_ERROR_PAPER_PROBLEM;
            Trace(TEXT("ADF has a paper problem"));
        } else if (lstrcmpi(szError,ADFERRORS_GENERAL) == 0) {
            m_hrLastADFError = WIA_ERROR_GENERAL_ERROR;
            Trace(TEXT("ADF encountered a general error"));
        } else if (lstrcmpi(szError,ADFERRORS_OFFLINE) == 0) {
            m_hrLastADFError = WIA_ERROR_OFFLINE;
            Trace(TEXT("ADF is off-line"));
        } else {
            Trace(TEXT("ADF is READY"));
            m_hrLastADFError = S_OK;
        }
    } else {
        Trace(TEXT("ADF is READY"));
        m_hrLastADFError = S_OK;
    }

    return hr;
}

VOID CFScanAPI::Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}

HRESULT CreateInstance(CFakeScanAPI **ppFakeScanAPI, LONG lMode)
{
    HRESULT hr = S_OK;
    if(ppFakeScanAPI){
        *ppFakeScanAPI = NULL;
        *ppFakeScanAPI = new CFScanAPI;
        if(NULL == *ppFakeScanAPI){
            hr = E_OUTOFMEMORY;
        }
        CFScanAPI* pScanAPI = (CFScanAPI*)*ppFakeScanAPI;
        pScanAPI->FakeScanner_SetEmulationMode(lMode);
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// THREADS SECTION                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

VOID FakeScannerEventThread( LPVOID  lpParameter )
{
    PSCANNERDEVICE pThisDevice = (PSCANNERDEVICE)lpParameter;
    pThisDevice->DoEventProcessing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanpanl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanpanl\scanpnl.h ===
#pragma once

#include "resource.h"   // resource IDs

///////////////////////////////////////////////////////////////////////////////
// wia scanner sample defines

#define ID_FAKE_NOEVENT    0
#define ID_FAKE_SCANBUTTON 100
#define ID_FAKE_COPYBUTTON 200
#define ID_FAKE_FAXBUTTON  300

///////////////////////////////////////////////////////////////////////////////
// registry settings

#define HKEY_WIASCANR_FAKE_EVENTS TEXT(".DEFAULT\\Software\\Microsoft\\WIASCANR")
#define WIASCANR_DWORD_FAKE_EVENT_CODE TEXT("EventCode")

///////////////////////////////////////////////////////////////////////////////
// main application

LRESULT CALLBACK MainWindowProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
VOID FireFakeEvent(HWND hDlg, DWORD dwEventCode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\scanpanl\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#endif
// Windows Header Files:
#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// SCANPANL headers
#include "scanpnl.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\minidrv.cpp ===
/***************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       MiniDrv.Cpp
*
*  VERSION:     3.0
*
*  DATE:        18 Nov, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner methods.
*
****************************************************************************/

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>

#include "resource.h"
#include "testusd.h"
#include "defprop.h"


//
//  Defines for scan phase.  Used in data transfers
//

#define START       0
#define CONTINUE    1
#define END         2

//
//  Handle to the module used for WIAS_ERROR and WIAS_TRACE
//

extern HINSTANCE g_hInst;

//
//  Pointer to WIA Logging Interface used for WIAS_LERROR and WIAS_LTRACE
//

extern IWiaLog *g_pIWiaLog;

//
//  Prototypes for private functions implemented in MiniDrv.Cpp
//

HRESULT _stdcall GetBmiSize(PBITMAPINFO pbmi, LONG *plBmiSize);

UINT AlignInPlace(
    PBYTE   pBuffer,
    LONG    cbWritten,
    LONG    lBytesPerScanLine,
    LONG    lBytesPerScanLineRaw);

/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT ValidateDataTransferContext(
                             PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");
    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;;
    }

    //
    //  for tymed file, only WiaImgFmt_BMP is allowed by this driver
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        if (pDataTransferContext->guidFormatID != WiaImgFmt_BMP) {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireDeviceData, invalid format"));
            return E_INVALIDARG;;
        }

    }

    //
    //  for tymed CALLBACK, only WiaImgFmt_MEMORYBMP is allowed by this driver
    //

    if (pDataTransferContext->tymed == TYMED_CALLBACK) {

        if (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP) {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireDeviceData, invalid format"));
            return E_INVALIDARG;;
        }
    }

    //
    //  callback is always double buffered, non-callback never is
    //

    if (pDataTransferContext->pTransferBuffer == NULL) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireDeviceData, invalid transfer buffer"));
        return E_INVALIDARG;
    }

    return S_OK;
}

/**************************************************************************\
* TestUsdDevice::drvDeleteItem
*
*   Try to delete a device item. Device items for the test scanner may
*   not be modified, so simply return access denied.
*
* Arguments:
*
*   pWiasContext    - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    plDevErrVal = 0;
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvDeleteItem");
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* SendBitmapHeader
*
*   Send the bitmap header info to the callback routine.  This is a helper
*   function used in TYMED_CALLBACK transfers.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT SendBitmapHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::SendBitmapHeader");
    HRESULT hr;

    WIAS_ASSERT( g_hInst, pmdtc != NULL);
    WIAS_ASSERT( g_hInst, pmdtc->tymed == TYMED_CALLBACK);
    WIAS_ASSERT( g_hInst, pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP);

    //
    //  Driver is sending TOPDOWN data, must swap biHeight
    //
    //  This routine assumes pMiniTranCtx->pHeader points to a
    //  BITMAPINFO header (TYMED_FILE doesn't use this path
    //  and DIB is the only format supported).
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pmdtc->pTransferBuffer;

    pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;

    //
    //  Send to class driver.  WIA Class driver will pass
    //  data through to client.
    //

    hr = pmdtc->
            pIWiaMiniDrvCallBack->
                MiniDrvCallback(IT_MSG_DATA,
                                IT_STATUS_TRANSFER_TO_CLIENT,
                                0,
                                0,
                                pmdtc->lHeaderSize,
                                pmdtc,
                                0);

    if (hr == S_OK) {

        //
        //  If the transfer was successfull, advance offset for
        //  destination copy by the size of the data just sent.
        //

        pmdtc->cbOffset += pmdtc->lHeaderSize;
    }

    return hr;
}

/**************************************************************************\
* ScanItem
*
*   Copy data from scanner into buffer. This routine must fill the
*   complete buffer. Status is sent back to the client if a callback
*   routine is provided.
*
*   Data must be copied to the buffer from the bottom up to compensate
*   for WiaImgFmt_BMP that defines DIB data as "BOTTOM-UP" :(
*
* Arguments:
*
*   pItemContext        - private item data
*   pMiniTranCtx        - mini dirver supplied transfer info
*   plDevErrVal         - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::ScanItem(
    PTESTMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::ScanItem");
    HRESULT hr = S_OK;

    //
    //  Init buffer info
    //

    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,(""));
    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("ScanItem:"));

    LONG  cbWritten    = 0;
    LONG  cbSize;
    LONG  cbRemaining  = pmdtc->lBufferSize - pmdtc->lHeaderSize;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lPhase       = START;

    //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  pmdtc->lBufferSize:         %d", pmdtc->lBufferSize));
    //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  pmdtc->lHeaderSize:         %d",pmdtc ->lHeaderSize));

    if (pItemContext->lBytesPerScanLine == 0) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, lBytesPerScanLine == 0"));
        return E_FAIL;
    }


    //
    //  Scan until buffer runs out or scanner completes transfer
    //

    while ((lPhase == START) || (cbWritten)) {


        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbRemaining:                         %d", cbRemaining));
        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  pItemContext->lBytesPerScanLine:     %d", pItemContext->lBytesPerScanLine));
        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  pItemContext->lBytesPerScanLineRaw:  %d", pItemContext->lBytesPerScanLineRaw));

        //
        //  Limit requests to 64K or less.  Capping requests is driver specific.
        //

        cbSize = (cbRemaining > 0x10000) ? 0x10000 : cbRemaining;

        //
        //  Request size to scanner must be modula the raw bytes per scan row.
        //  Enough space for the alignment padding must be reserved.
        //  These are requirements for the helper AlignInPlace().
        //

        cbSize = (cbSize / pItemContext->lBytesPerScanLine) *
                 pItemContext->lBytesPerScanLineRaw;

        //
        //  Check if the scan is finished.  If cbSize == 0 then we've transfered
        //  all the necessary data, so break from the scan loop.
        //

        if (cbSize == 0) {
            break;
        }

        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  lPhase:               %d", lPhase));
        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  pBuf:                 %08X", pBuf));
        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbSize:               %d", cbSize));
        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbRemaining:          %d", cbRemaining));

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  cbSize is the requested number of bytes to retrieve
        //  from the scanner, and cbWritten will be set to the actual number
        //  of bytes that were returned.
        //

        hr = Scan(pmdtc->guidFormatID,
                  lPhase,
                  pBuf,
                  cbSize,
                  &cbWritten,
                  pItemContext,
                  pmdtc);

        //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbWritten:            %d", cbWritten));

        //
        //  Change scan phase from START to CONTINUE, so that next call to
        //  Scan(...) will be in the correct phase.
        //

        if (lPhase == START) {
            lPhase = CONTINUE;
        }

        if (hr == S_OK) {

            if (cbWritten) {

                //
                //  Align the data on DWORD boundries.
                //

                cbWritten = AlignInPlace(pBuf,
                                         cbWritten,
                                         pItemContext->lBytesPerScanLine,
                                         pItemContext->lBytesPerScanLineRaw);

                //
                //  Advance the buffer
                //

                pBuf        += cbWritten;
                cbRemaining -= cbWritten;

                //
                //  If a status callback was specified, then callback the class
                //  driver.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    //
                    //  Calculate the percent complete for status.
                    //

                    FLOAT FractionComplete;
                    LONG  PercentComplete;

                    if (pmdtc->lBufferSize) {
                        FractionComplete = (FLOAT)(pmdtc->lBufferSize - cbRemaining) / (FLOAT)pmdtc->lBufferSize;
                    } else {
                        FractionComplete = 0.0f;
                        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, pmdtc->lBufferSize = 0!"));
                    }

                    PercentComplete = (LONG)(100 * FractionComplete);

                    //
                    //  Send status to class driver.  WIA Class driver will
                    //  pass status to client.
                    //

                    hr = pmdtc->
                            pIWiaMiniDrvCallBack->
                                MiniDrvCallback(IT_MSG_STATUS,
                                                IT_STATUS_TRANSFER_TO_CLIENT,
                                                PercentComplete,
                                                0,
                                                0,
                                                pmdtc,
                                                0);

                    //
                    //  If user cancels scan, S_FALSE will be returned by
                    //  callback.  Also check for error, and abort scan
                    //  if one occurred.
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("ScanItem, Transfer canceled by client"));
                        break;

                    } else if (FAILED(hr)) {

                        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, MiniDrvCallback failed"));
                        WIAS_LHRESULT(g_pIWiaLog, hr);
                        break;
                    }
                }
            }
        } else {
            hr = E_FAIL;
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, data transfer failed"));
            GetLastError((PULONG)plDevErrVal);
            break;
        }
    }

    //
    //  Let the scanner know we are done.
    //

    Scan(GUID_NULL, END, NULL, 0, NULL, pItemContext, pmdtc);

    return hr;
}

/**************************************************************************\
* ScanItemCB
*
*   Use client data callbacks to transfer banded data into app transfer
*   buffer and callback client
*
* Arguments:
*
*   pItemContext    - private item data
*   pmdtc           - buffer and callback information
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::ScanItemCB(
    PTESTMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::ScanItemCB");
    HRESULT hr = S_OK;

    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,(""));
    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("ScanItemCB:"));

    //
    //  There must be a callback supplied, else fail the transfer.
    //

    if ((pmdtc->pIWiaMiniDrvCallBack == NULL) ||
        (!pmdtc->bTransferDataCB)) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, invalid callback params"));
        return E_INVALIDARG;
    }

    //
    //  Send Bitmap header.
    //

    hr = SendBitmapHeader(pmdtc);

    //
    //  Transfer may have failed or been canceled.  Only continue if S_OK.
    //

    if (hr != S_OK) {
        return hr;
    }

    //WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("ScanItemCB, lBufferSize: 0x%lx\n", pmdtc->lBufferSize));

    if (pItemContext->lBytesPerScanLine == 0) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, lBytesPerScanLine == 0"));
        return E_FAIL;
    }

    //
    //  Init buffer variables
    //

    LONG  cbWritten;
    LONG  cbSize;
    LONG  cbRemaining  = pmdtc->lBufferSize;
    LONG  lPhase       = START;

    //
    //  Scan until buffer runs out or scanner completes transfer
    //

    while ((lPhase == START) || (cbWritten)) {

        PBYTE pBuf         = pmdtc->pTransferBuffer;

        //
        //  Limit requests to 64K or less.  Capping requests is driver
        //  specific.  The smaller the limit, the more frequent the
        //  status messages.
        //

        cbSize = (cbRemaining > 0x10000) ? 0x10000 : cbRemaining;

        //
        //  Request size to scanner must be modula the raw bytes per scan row.
        //  Enough space for the alignment padding must be reserved.
        //  These are requirements for the helper AlignInPlace().
        //

        cbSize = (cbSize / pItemContext->lBytesPerScanLine) *
                 pItemContext->lBytesPerScanLineRaw;

        //
        //  Check if the scan is finished.  If cbSize == 0 then we've transfered
        //  all the necessary data, so break from the scan loop.
        //

        if (cbSize == 0) {
            break;
        }

        // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  lPhase:               %d",   lPhase));
        // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  pBuf:                 %08X", pBuf));
        // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbSize:               %d",   cbSize));
        // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbRemaining:          %d",   cbRemaining));

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  cbSize is the requested number of bytes to retrieve
        //  from the scanner, and cbWritten will be set to the actual number
        //  of bytes that were returned.
        //

        hr = Scan(pmdtc->guidFormatID,
                  lPhase,
                  pBuf,
                  cbSize,
                  &cbWritten,
                  pItemContext,
                  pmdtc);

        // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  cbWritten:            %d", cbWritten));

        //
        //  Change scan phase from START to CONTINUE, so that next call to
        //  Scan(...) will be in the correct phase.
        //

        if (lPhase == START) {
            lPhase = CONTINUE;
        }

        if (hr == S_OK) {

            if (cbWritten) {

                //
                //  Align the data on DWORD boundries.
                //

                cbWritten = AlignInPlace(pBuf,
                                         cbWritten,
                                         pItemContext->lBytesPerScanLine,
                                         pItemContext->lBytesPerScanLineRaw);

                //
                //  Calculate the percent complete for status.
                //

                FLOAT FractionComplete;
                LONG  PercentComplete;

                if ((pmdtc->lImageSize + pmdtc->lHeaderSize)) {
                    FractionComplete = (FLOAT) (pmdtc->cbOffset + cbWritten) /
                                       (FLOAT) (pmdtc->lImageSize + pmdtc->lHeaderSize);
                } else {
                    FractionComplete = 0.0f;
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, pmdtc->lImageSize + pmdtc->lHeaderSize= 0!"));
                }

                PercentComplete = (LONG)(100 * FractionComplete);

                //
                //  Send data to class driver.  WIA Class driver will
                //  pass data to client.
                //

                hr = pmdtc->
                     pIWiaMiniDrvCallBack->
                     MiniDrvCallback(IT_MSG_DATA,
                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                     PercentComplete,
                                     pmdtc->cbOffset,
                                     cbWritten,
                                     pmdtc,
                                     0);

                //
                //  If user cancels scan, S_FALSE will be returned by
                //  callback.  Also check for error, and abort scan
                //  if one occurred.
                //

                if (hr == S_FALSE) {
                    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("ScanItemCB, MiniDrvCallback canceled by client"));
                    break;
                }
                else if (FAILED(hr)) {
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, MiniDrvCallback failed"));
                    WIAS_LHRESULT(g_pIWiaLog, hr);
                    DebugBreak();
                    break;
                }

                pmdtc->cbOffset += cbWritten;
            }
        }
        else {
            hr = E_FAIL;
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, data transfer failed"));
            GetLastError((PULONG)plDevErrVal);
            break;
        }
    }

    // Let the hardware know we are done scanning.
    Scan(GUID_NULL, END, NULL, 0, NULL, pItemContext, pmdtc);
    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvAcquireItemData
*
*   Transfer data from mini driver item to device manger.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvAcquireItemData");
    HRESULT hr;

    plDevErrVal = 0;

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pmdtc);

    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Get item specific driver data
    //

    PTESTMINIDRIVERITEMCONTEXT  pItemContext;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

     if (FAILED(hr)) {
         WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, NULL item context"));
         return hr;
     }

    //
    //  Set data source file name.  This is where the test scanner
    //  gets it's data from.
    //

    hr = SetSrcBmp((BYTE*)pWiasContext);

    if (hr != S_OK) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, SetSrcBmp failed"));
        return hr;
    }

    //
    //  Use WIA services to fetch format specific info.  This information
    //  is based on the property settings.
    //

    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);

    if (hr != S_OK) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, GetImageInformation failed"));
        return hr;
    }

    //
    //  Determine if this is a callback or buffered transfer.
    //

    if (pmdtc->tymed == TYMED_CALLBACK) {

        hr = ScanItemCB(pItemContext,
                        pmdtc,
                        plDevErrVal);

    } else {

        hr = ScanItem(pItemContext,
                      pmdtc,
                      plDevErrVal);
    }

    if (!pmdtc->bClassDrvAllocBuf) {
        CoTaskMemFree(pmdtc->pTransferBuffer);
    }

    return hr;
}

/**************************************************************************\
* SetItemSize
*
*   Call wias to calc new item size
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    4/21/1999 Original Version
*
\**************************************************************************/

HRESULT SetItemSize(
    BYTE                        *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::SetItemSize");
#define NUM_PROPS_TO_SET 3
    LONG        lWidthInBytes = 0;
    LONG        lMinBufSize   = 0;
    PROPSPEC    ps[NUM_PROPS_TO_SET] = {
                    {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                    {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                    {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE}};
    PROPVARIANT pv[NUM_PROPS_TO_SET];
    HRESULT     hr = S_OK;

    MINIDRV_TRANSFER_CONTEXT mdtc;

    //
    //  Clear the MiniDrvTransferContext
    //

    memset(&mdtc,0,sizeof(MINIDRV_TRANSFER_CONTEXT));

    //
    //  Read format and tymed
    //

    GUID guidFormatID;

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }
    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED, (LONG*)&mdtc.tymed, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_TYMED error"));
        return hr;
    }

    //
    // wias works for DIB,TIFF formats
    //

    hr = wiasGetImageInformation(pWiasContext, WIAS_INIT_CONTEXT, &mdtc);
    if (FAILED(hr)) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, could not get image information"));
        return hr;
    }

    //
    //  Set the MinBufferSize property.  MinBufferSize is the minimum buffer
    //  that a client can request for a data transfer.
    //

    switch (mdtc.tymed) {
        case TYMED_CALLBACK:
            lMinBufSize = 65535;
            break;

        case TYMED_FILE:
            lMinBufSize = mdtc.lImageSize + mdtc.lHeaderSize;
            break;

        default:
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, unknown tymed: 0x%08X", mdtc.tymed));
            return E_INVALIDARG;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < NUM_PROPS_TO_SET; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = mdtc.lItemSize;
    pv[1].lVal = mdtc.cbWidthInBytes;
    pv[2].lVal = lMinBufSize;

    hr = wiasWriteMultiple(pWiasContext, NUM_PROPS_TO_SET, ps, pv);
    if (SUCCEEDED(hr)) {

        //
        // Get a pointer to the associated driver item.
        //

        IWiaDrvItem* pDrvItem;

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        if (FAILED(hr)) {
            return hr;
        }

        PTESTMINIDRIVERITEMCONTEXT pItemContext;

        hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

        if (SUCCEEDED(hr)) {

            //
            // Calculate how many scan lines will fit in the buffer.
            //

            pItemContext->lBytesPerScanLineRaw = ((mdtc.lWidthInPixels * mdtc.lDepth) + 7)  / 8;
            pItemContext->lBytesPerScanLine    = (((mdtc.lWidthInPixels * mdtc.lDepth) + 31) / 8) & 0xfffffffc;
            pItemContext->lTotalRequested      = pItemContext->lBytesPerScanLineRaw * mdtc.lLines;
        } else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvWriteItemProperties, NULL item context"));
        }
    } else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, WriteMultiple failed"));
    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    *plDevErrVal = 0;

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if(FAILED(hr)) {
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_ROOTITEMDEFAULTS,
                                  g_piRootItemDefaults,
                                  g_pszRootItemDefaults);
        if (FAILED(hr)) {
           return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               NUM_ROOTITEMDEFAULTS,
                               g_psRootItemDefaults,
                               g_pvRootItemDefaults);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        FreePropVariantArray(NUM_ROOTITEMDEFAULTS,g_pvRootItemDefaults);


        if (FAILED(hr)) {
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from g_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     NUM_ROOTITEMDEFAULTS,
                                     g_psRootItemDefaults,
                                     g_wpiRootItemDefaults);
    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildTopItemProperties();

        if(FAILED(hr)) {
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_ITEMDEFAULTS,
                                  g_piItemDefaults,
                                  g_pszItemDefaults);
        if (FAILED(hr)) {
           return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               NUM_ITEMDEFAULTS,
                               g_psItemDefaults,
                               (PROPVARIANT*)g_pvItemDefaults);
        if (FAILED(hr)) {
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from g_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     NUM_ITEMDEFAULTS,
                                     g_psItemDefaults,
                                     g_wpiItemDefaults);
        if (FAILED(hr)) {
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
    }
    return hr;
}


/**************************************************************************\
* TestUsdDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
***************************************************************************/

HRESULT _stdcall TestUsdDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvValidateItemProperties");
    WIA_PROPERTY_CONTEXT    Context;
    HRESULT                 hr = S_OK;
    LONG                    lItemType;

    //
    //  This device doesn't touch hardware to validate the device item
    //  properties, so set device error to 0.
    //

    *plDevErrVal = 0;

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Insert root item validation here
            //

        } else {


            //
            //  Validate the child item properties here. Start with
            //  dependent property validation, followed by a general
            //  property validation against their valid values with
            //  wiasValidateItemProperties.
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        //  Use the WIA service to update the scan rect
                        //  properties and valid values.
                        //

                        hr = wiasUpdateScanRect(pWiasContext,
                                                &Context,
                                                HORIZONTAL_BED_SIZE,
                                                VERTICAL_BED_SIZE);
                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                            }
                        }
                    }
                }
                wiasFreePropContext(&Context);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
            }

            //
            //  If all necessary changes have been made
            //  successfully, validate the properties against
            //  their new valid values.
            //

            if (SUCCEEDED(hr)) {
                hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
            }
        }
    } else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, could not get item type"));
    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext       - Pointer to WIA item.
*   lFlags      - Operation flags, unused.
*   pmdtc       - Pointer to mini driver context. On entry, only the
*                 portion of the mini driver context which is derived
*                 from the item properties is filled in.
*   plDevErrVal - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;
    // No device hardware errors.
    *plDevErrVal = 0;

    //
    //  The Test Scanner has no hardware, so there is nothing to do here.
    //

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext       - wia item
*   lFlags      - Operation flags, unused.
*   nPropSpec   - Number of elements in pPropSpec.
*   pPropSpec   - Pointer to property specification, showing which properties
*                 the application wants to read.
*   plDevErrVal - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvReadItemProperties");

    //
    //  For most scanner devices, item properties are stored in the driver
    //  and written out at acquire image time. Some devices support properties
    //  which should be updated on every property read e.g. say there was
    //  a property representing the device's internal clock.
    //  The updating of such properties should be done here.
    //

    *plDevErrVal = 0;
    return S_OK;
}

/**************************************************************************\
* TestUsdDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext   - unused, can be NULL
*   lFlags      - Operation flags, unused.
*   plDevErrVal - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(100);
}

/**************************************************************************\
* TestUsdDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvUnLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* TestUsdDevice::drvAnalyzeItem
*
*   This scanner does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext       - Pointer to the device item to be analyzed.
*   lFlags      - Operation flags.
*   plDevErrVal - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvAnalyzeItem");
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* TestUsdDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvFreeDrvItemContext");
    PTESTMINIDRIVERITEMCONTEXT pContext;

    *plDevErrVal = 0;

    pContext = (PTESTMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext) {

        // Free any driver item specific context here.
    }

    return S_OK;
}

/**************************************************************************\
* TestUsdDevice::drvInitializeWia
*
*   Initialize the WIA mini driver.  This will build up the driver item tree
*   and perform any other initialization code that's needed for WIA.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvInitializeWia");
    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("drvInitializeWia, device ID: %ws", bstrDeviceID));

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device inteface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID.
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root property stream name.
        //

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate prop stream name"));
            return E_OUTOFMEMORY;
        }
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        return hr;
    }

    //
    //  Build the device item tree, if it hasn't been built yet.
    //

    if (!m_pIDrvItemRoot) {

        LONG    lDevErrVal;

        //
        //  The WIA_CMD_SYNCHRONIZE command will build the item tree.
        //

        hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);
    }
    *ppIDrvItemRoot = m_pIDrvItemRoot;

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   30/12/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


/**************************************************************************\
* drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvGetDeviceErrorStr");
    *plDevErr = 0;

    //
    //  Map device errors to a string to be placed in the event log.
    //

    switch (lDevErrVal) {

        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            return E_FAIL;
    }
    return S_OK;
}

/**************************************************************************\
* drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvDeviceCommand");
    //
    //  This device doesn't touch hardware, so set device error value to 0.
    //

    *plDevErrVal = 0;

    HRESULT hr;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Build the minidriver representation of
        //               the current item list, if it doesn't exist.
        //

        if (!m_pIDrvItemRoot) {
            hr = BuildItemTree();
        }
        else {
            hr = S_OK;
        }
    }
    else if (*plCommand == WIA_CMD_BUILD_DEVICE_TREE) {

        //
        // BUILD_DEVICE_TREE - Build the minidriver representation of
        //                     the current item list, if it doesn't exist.
        //

        if (!m_pIDrvItemRoot) {
            hr = BuildItemTree();
        }
        else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, WIA_CMD_BUILD_DEVICE_TREE, device tree allready exists"));
            hr = E_INVALIDARG;
        }
    }
    else if (*plCommand == WIA_CMD_DELETE_DEVICE_TREE) {

        //
        // DELETE_DEVICE_TREE - Delete the minidriver representation of
        //                      the current item list, if it exists.
        //

        if (m_pIDrvItemRoot) {
            hr = DeleteItemTree();
        }
        else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, WIA_CMD_DELETE_DEVICE_TREE, device tree doesn't exist"));
            hr = E_INVALIDARG;
        }
    }
    else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command"));
        hr = E_NOTIMPL;
    }
    return hr;
}


/**************************************************************************\
* TestUsdDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    17/3/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvGetCapabilites");
    *plDevErrVal = 0;

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
        case WIA_DEVICE_COMMANDS:

                //
                //  Only commands
                //

                *pcelt = NUM_CAPABILITIES - NUM_EVENTS;
                *ppCapabilities = &g_Capabilities[NUM_EVENTS];
                break;
        case WIA_DEVICE_EVENTS:

                //
                //  Only events
                //

                *pcelt = NUM_EVENTS;
                *ppCapabilities = g_Capabilities;
                break;
        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

                //
                //  Both events and commands
                //

                *pcelt = NUM_CAPABILITIES;
                *ppCapabilities = g_Capabilities;
                break;
        default:

                //
                //  Flags is invalid
                //

                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, flags was invalid"));
                return E_INVALIDARG;
    }
    return S_OK;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   11/18/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::drvGetWiaFormatInfo");

    //
    //  If it hasn't been done already, set up the g_wfiTable table
    //

    if (!g_wfiTable) {
        g_wfiTable = (WIA_FORMAT_INFO*) CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * NUM_WIA_FORMAT_INFO);
        if (!g_wfiTable) {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetWiaFormatInfo, out of memory"));
            return E_OUTOFMEMORY;
        }

        //
        //  Set up the GUID Format / TYMED pairs
        //

        g_wfiTable[0].guidFormatID = WiaImgFmt_MEMORYBMP;
        g_wfiTable[0].lTymed       = TYMED_CALLBACK;
        g_wfiTable[1].guidFormatID = WiaImgFmt_BMP;
        g_wfiTable[1].lTymed       = TYMED_FILE;
    }

    *plDevErrVal = 0;

    *pcelt = NUM_WIA_FORMAT_INFO;
    *ppwfi = g_wfiTable;
    return S_OK;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    Aug/3rd/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "TestUsdDevice::DrvNotifyPnpEvent");

    //
    //  Do nothing, since device is not Plug-and-play.
    //

    return (S_OK);
}


/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

UINT AlignInPlace(
   PBYTE pBuffer,
   LONG  cbWritten,
   LONG  lBytesPerScanLine,
   LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");
    if (lBytesPerScanLineRaw % 4) {

      UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
      UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

      PBYTE pSrc = pBuffer + cbWritten - 1;
      PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

      while (pSrc >= pBuffer) {
         pDst -= uiPadBytes;

         for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
            *pDst-- = *pSrc--;
         }
      }
      return uiDevLinesWritten * lBytesPerScanLine;
   }
   return cbWritten;
}

/**************************************************************************\
* TestUsdDevice::FillBufferFromFile
*
*   Get the image data from the data source file.
*
* Arguments:
*
*   pBuffer         - Pointer to the data buffer.
*   lLength         - Size of the data buffer in bytes.
*   pReceived       - Number of bytes written to the buffer.
*   pdic            - Pointer to the item context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::FillBufferFromFile(
    PBYTE                       pBuffer,
    LONG                        lLength,
    PLONG                       pReceived,
    PTESTMINIDRIVERITEMCONTEXT  pdic)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::FillBufferFromFile");
    HRESULT  hr = S_OK;

    PBYTE pbSrc = pdic->pTestBmpBits;

    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("    FillBufferFromFile"));
    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      pBuffer:      %X", pBuffer));
    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lLength:      %d", lLength));
    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      pReceived:    %X", pReceived));

    while (((*pReceived) < lLength) &&
           (pdic->lTotalWritten < pdic->lTotalRequested)){

        // Return a scan line
        for (LONG i = 0; i < pdic->lBytesPerScanLineRaw; i++) {

            if ((pdic->lTestBmpLine < pdic->lTestBmpHeight) &&
                (pdic->lTestBmpLine >= 0) &&
                (i < pdic->lTestBmpBytesPerScanLine)) {

                // If the source bitmap still has data copy it.
                *pBuffer++ =  *pbSrc++;
                *pReceived += 1;
                pdic->lTotalWritten++;

            } else {
                // If the source bitmap is out of line data,
                // pad out line with zero data.
                *pBuffer++ =  0;
                *pReceived += 1;
                pdic->lTotalWritten++;
            }
        }
        if (pdic->lTestBmpDir == 1) {
            pbSrc+= pdic->lTestBmpLinePad;
            pdic->lTestBmpLine++;
        }
        else {
            pbSrc -= (pdic->lTestBmpBytesPerScanLine * 2);
            pbSrc -= pdic->lTestBmpLinePad;
            pdic->lTestBmpLine--;
        }
    }
    pdic->pTestBmpBits = pbSrc;
    return hr;
}

/**************************************************************************\
* TestUsdDevice::FillBufferWithTestPattern
*
*   Generate the image data from a test pattern.
*
* Arguments:
*
*   pBuffer         - Pointer to the data buffer.
*   lLength         - Size of the data buffer in bytes.
*   pReceived       - Number of bytes written to the buffer.
*   pItemContext - Pointer to the item context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::FillBufferWithTestPattern(
    PBYTE                           pBuffer,
    LONG                            lLength,
    PLONG                           pReceived,
    PTESTMINIDRIVERITEMCONTEXT      pdic,
    PMINIDRV_TRANSFER_CONTEXT       pmtc)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::FillBufferWithTestPattern");
    HRESULT  hr = S_OK;
    BYTE     bColor;

    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("    FillBufferWithTestPattern"));
    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      pBuffer:      %X", pBuffer));
    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lLength:      %d", lLength));
    // WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      pReceived:    %X", pReceived));


    while (((*pReceived) < lLength) &&
           (pdic->lTotalWritten < pdic->lTotalRequested)) {

        switch (pmtc->lDepth) {
            case 1:
                if ((!pdic->lTotalWritten) ||
                    ((pdic->lTotalWritten % pdic->lBytesPerScanLineRaw) == 0)) {
                    bColor = 0x55;
                }
                else {
                    bColor = 0xAA;
                }
                *pBuffer++ = bColor;
                (*pReceived)++;
                pdic->lTotalWritten++;
                break;

            case 8:
                if ((!pdic->lTotalWritten) ||
                    ((pdic->lTotalWritten % pdic->lBytesPerScanLineRaw) == 0)) {
                    bColor = 0x55;
                }
                else {
                    if (LOBYTE(pBuffer) & 1) {
                        bColor = 0xC0;
                    }
                    else {
                        bColor = 0x00;
                    }
                }
                *pBuffer++ = bColor;
                (*pReceived)++;
                pdic->lTotalWritten++;
                break;

            case 24:
                if ((!pdic->lTotalWritten) ||
                    ((pdic->lTotalWritten % pdic->lBytesPerScanLineRaw) == 0)) {
                    bColor = 0x55;
                }
                else {
                    bColor = 0xC0;
                }
                if (LOBYTE(pBuffer) & 1) {
                    *pBuffer++ = bColor;
                    *pBuffer++ = 0x00;
                    *pBuffer++ = bColor;
                }
                else {
                    *pBuffer++ = 0x00;
                    *pBuffer++ = 0x00;
                    *pBuffer++ = 0x00;
                }
                (*pReceived)+= 3;
                pdic->lTotalWritten += 3;
                break;

            default:
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::FillBufferWithTestPattern, unknown depth"));
                hr = E_FAIL;
                break;
        }
    }
    return hr;
}

/**************************************************************************\
* SetSrcBmp
*
*   Set the correct source bitmap file associated with the current
*   bitdepth setting.
*
* Arguments:
*
*   pWiasContext       - wia item
*
* Return Value:
*
*    Status
*
* History:
*
*    6/28/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::SetSrcBmp(BYTE  *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::SetSrcBmp");
    HRESULT hr     = S_OK;
    LONG lbitdepth = 0;

    //
    // Read WIA_IPA_DEPTH property, to get current setting
    //

    hr = wiasReadPropLong(pWiasContext, WIA_IPA_DEPTH, (LONG*)&lbitdepth, NULL, true);
    if (SUCCEEDED(hr)) {

        //
        // Build the path name of the data source file.
        //

        DWORD dwRet = GetTempPath(MAX_PATH, m_szSrcDataName);
        if (dwRet != 0) {
            switch(lbitdepth)
            {
            case 1: //  1-bit data requested
                _tcscat(m_szSrcDataName, DATA_1BIT_SRC_NAME);
                break;
            case 24:// 24-bit data requested
                _tcscat(m_szSrcDataName, DATA_24BIT_SRC_NAME);
                break;
            case 8: //  8-bit data requested
            default:
                WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("Defaulting to 8-bit"));
                _tcscat(m_szSrcDataName, DATA_8BIT_SRC_NAME);
                break;
            }
        } else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::SetSrcBmp, unable to get data source file name"));
            return STIERR_NOT_INITIALIZED;
        }

        // Make sure we can open the data source file.
        HANDLE hTestBmp = CreateFile(m_szSrcDataName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_SYSTEM,
                                     NULL);

        // obtain last error information
        m_dwLastOperationError = ::GetLastError();

        if (hTestBmp == INVALID_HANDLE_VALUE) {
            hr = HRESULT_FROM_WIN32(m_dwLastOperationError);
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::SetSrcBmp, unable to open data source file:"));
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("  %s", m_szSrcDataName));
            WIAS_LHRESULT(g_pIWiaLog, hr);
        } else {
            WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  Source data: %s", m_szSrcDataName));
            CloseHandle(hTestBmp);
        }
    }
    return hr;
}

/**************************************************************************\
* OpenTestBmp
*
*   Open the test bitmap data file as a memory mapped file and retrieve
*   image size/format data.
*
* Arguments:
*
*   pItemContext - Pointer to the item context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::OpenTestBmp(
    GUID                        guidFormatID,
    PTESTMINIDRIVERITEMCONTEXT  pdic)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::OpenTestBmp");
    HRESULT  hr = S_OK;

    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("    OpenTestBmp"));

    // Data source file should be closed.
    if (pdic->hTestBmp != INVALID_HANDLE_VALUE) {
        CloseHandle(pdic->hTestBmp);
        pdic->hTestBmp = NULL;
    }

    // Open the data source file.
    pdic->hTestBmp = CreateFile(m_szSrcDataName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_SYSTEM,
                                NULL);

    // obtain last error information
    m_dwLastOperationError = ::GetLastError();

    if (pdic->hTestBmp != INVALID_HANDLE_VALUE) {

        // Create a file mapping to the test bitmap.
        pdic->hTestBmpMap = NULL;
        pdic->hTestBmpMap = CreateFileMapping(pdic->hTestBmp,
                                              NULL,
                                              PAGE_READWRITE,
                                              0,
                                              0,
                                              NULL);

        if (pdic->hTestBmpMap != NULL) {

            // Map a view of the test bitmap.
            pdic->pTestBmp = NULL;
            pdic->pTestBmp = (PBYTE)MapViewOfFileEx(pdic->hTestBmpMap,
                                                    FILE_MAP_READ | FILE_MAP_WRITE,
                                                    0,
                                                    0,
                                                    0,
                                                    NULL);
            if (pdic->pTestBmp != NULL) {

                // Retrieve image size/format data.
                PBYTE             pb      = pdic->pTestBmp;
                PBITMAPFILEHEADER pbmFile = (PBITMAPFILEHEADER)pb;
                PBITMAPINFO       pbmi    = (PBITMAPINFO)(pb + sizeof(BITMAPFILEHEADER));

                // Validate bitmap.
                if (pbmFile->bfType == 'MB') {

                    // get BMP size
                    LONG lBmiSize = 0;
                    hr = GetBmiSize(pbmi, &lBmiSize);

                    if (SUCCEEDED(hr)) {
                        // Reset total bytes written.
                        pdic->lTotalWritten = 0;

                        // Fill in test bitmap parameters.
                        pdic->lTestBmpDepth  = pbmi->bmiHeader.biBitCount;
                        pdic->lTestBmpWidth  = pbmi->bmiHeader.biWidth;
                        pdic->lTestBmpHeight = pbmi->bmiHeader.biHeight;

                        // Calculate data bytes per line in test bitmap.
                        pdic->lTestBmpBytesPerScanLine = ((pdic->lTestBmpWidth *
                                                          pdic->lTestBmpDepth) + 7) / 8;

                        // Calculate pad bytes per line in test bitmap.
                        pdic->lTestBmpLinePad = pdic->lTestBmpBytesPerScanLine % 4;
                        if (pdic->lTestBmpLinePad) {
                            pdic->lTestBmpLinePad = 4 - pdic->lTestBmpLinePad;
                        }

                        // Point to test bitmap image bits.
                        pdic->pTestBmpBits =  pb;
                        pdic->pTestBmpBits += sizeof(BITMAPFILEHEADER);
                        pdic->pTestBmpBits += lBmiSize;

                        if (guidFormatID == WiaImgFmt_MEMORYBMP) {
                            // Test bitmap is stored bottom up. If they want top
                            // up, start at the last line in the file.
                            pdic->lTestBmpDir  =  -1;
                            pdic->lTestBmpLine =  pdic->lTestBmpHeight - 1;
                            pdic->pTestBmpBits += pdic->lTestBmpHeight *
                                                 (pdic->lTestBmpBytesPerScanLine + pdic->lTestBmpLinePad);
                        }
                        else {
                            // Test bitmap is stored bottom up. If they want bottom
                            // up, start at the first line in the file.
                            pdic->lTestBmpDir  =  1;
                            pdic->lTestBmpLine =  0;
                        }

                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("-- TestBmp Information --"));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lTestBmpDepth:            %d", pdic->lTestBmpDepth));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lTestBmpWidth:            %d", pdic->lTestBmpWidth));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lTestBmpHeight:           %d", pdic->lTestBmpHeight));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      pTestBmpBits:             %X", pdic->pTestBmpBits));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lTestBmpBytesPerScanLine: %d", pdic->lTestBmpBytesPerScanLine));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lTestBmpLinePad:          %d", pdic->lTestBmpLinePad));
                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("      lTestBmpDir:              %d", pdic->lTestBmpDir));
                        return hr;
                    }
                    else {
                        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::OpenTestBmp, invalid BMI"));
                    }
                }
                else {
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::OpenTestBmp, not a valid bitmap"));
                }
            }
            else {
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::OpenTestBmp, MapViewOfFileEx failed"));
            }
        }
        else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::OpenTestBmp, CreateFilemapping failed"));
        }
    }
    else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::OpenTestBmp, unable to open data source file:"));
    }
    if (SUCCEEDED(hr)) {
        hr = HRESULT_FROM_WIN32(m_dwLastOperationError);
    }
    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("  %s", m_szSrcDataName));
    WIAS_LHRESULT(g_pIWiaLog, hr);
    CloseTestBmp(pdic);
    return hr;
}

/**************************************************************************\
* CloseTestBmp
*
*   Close the test bitmap data file and clear the image size/format data.
*
* Arguments:
*
*   pItemContext - Pointer to the item context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::CloseTestBmp(
    PTESTMINIDRIVERITEMCONTEXT  pItemContext)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::CloseTestBmp");

    pItemContext->lTestBmpDepth  = 0;
    pItemContext->lTestBmpWidth  = 0;
    pItemContext->lTestBmpHeight = 0;
    pItemContext->pTestBmpBits   = NULL;
    pItemContext->lTestBmpLine   = 0;

    // Unmap data source file.
    if (pItemContext->pTestBmp != NULL) {
        UnmapViewOfFile(pItemContext->pTestBmp);
        pItemContext->pTestBmp = NULL;
    }

    // Close data source file mapping.
    if (pItemContext->hTestBmpMap != NULL) {
        CloseHandle(pItemContext->hTestBmpMap);
        pItemContext->hTestBmpMap = NULL;
    }

    // Close data source file handle.
    if (pItemContext->hTestBmp != INVALID_HANDLE_VALUE) {
        CloseHandle(pItemContext->hTestBmp);
        pItemContext->hTestBmp = INVALID_HANDLE_VALUE;
    }

    return S_OK;
}

/**************************************************************************\
* Scan
*
*   Get the image data from the device hardware.
*
* Arguments:
*
*   iPhase          - Phase of the scan (START, CONTINUE, END).
*   pBuffer         - Pointer to the data buffer.
*   lLength         - Size of the data buffer in bytes.
*   pReceived       - Number of bytes written to the buffer.
*   pItemContext - Pointer to the item context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::Scan(
    GUID                        guidFormatID,
    LONG                        iPhase,
    PBYTE                       pBuffer,
    LONG                        lLength,
    PLONG                       pReceived,
    PTESTMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmtc)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::Scan");
    HRESULT  hr = S_OK;
    static HRESULT hrOpen = S_FALSE;

    if (!pItemContext) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::Scan, NULL pItemContext"));
        DebugBreak();
        return E_INVALIDARG;
    }

    switch (iPhase) {
        case START:
            hrOpen = OpenTestBmp(guidFormatID, pItemContext);
            if (FAILED(hr)) {
                return hrOpen;
            }

        case CONTINUE:
            if (pReceived && pBuffer) {
                *pReceived = 0;

                if ((pmtc->lDepth == pItemContext->lTestBmpDepth) &&
                    (hrOpen == S_OK)) {

                    // If we have a scan request for the same format
                    // as the test bitmap, fill the buffer from the
                    // test bitmap.

                    hr = FillBufferFromFile(pBuffer,
                                            lLength,
                                            pReceived,
                                            pItemContext);
                } else {

                    // The test bitmap doesn't match the request,
                    // fill the buffer with a test pattern.

                    hr = FillBufferWithTestPattern(pBuffer,
                                                   lLength,
                                                   pReceived,
                                                   pItemContext,
                                                   pmtc);
                }
            } else {
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::Scan, null parameter"));
                hr = E_INVALIDARG;
            }
            break;
        case END:
            hr = CloseTestBmp(pItemContext);
            hrOpen = S_FALSE;
            break;

        default:
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::Scan, unknown phase"));
            hr = E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::DeleteItemTree");
    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    HRESULT hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items. The test scanner supports only a single scanning item so
*   build a device item tree with only one child off the root.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::BuildItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::BuildItemTree");
    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("TestUsdDevice::BuildItemTree"));

    //
    //  The device item tree must not exist.
    //

    WIAS_ASSERT( (g_hInst), (m_pIDrvItemRoot == NULL));

    //
    //  Call the class driver to create the root item.
    //

    HRESULT hr = E_FAIL;

    //
    //  Name the root.
    //

    BSTR bstrRoot = NULL;
    hr = GetBSTRResourceString(IDS_FULLROOTITEM_NAME,&bstrRoot,TRUE);

    if (bstrRoot) {
        hr = wiasCreateDrvItem(WiaItemTypeFolder |
                               WiaItemTypeDevice |
                               WiaItemTypeRoot,
                               bstrRoot,
                               bstrRoot,
                               (IWiaMiniDrv *)this,
                               sizeof(TESTMINIDRIVERITEMCONTEXT),
                               NULL,
                               &m_pIDrvItemRoot);

        SysFreeString(bstrRoot);

        if (FAILED(hr)) {
            return hr;
        }
    } else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate item name"));
        return E_OUTOFMEMORY;
    }

    //
    //  Create and add the Top/Front and Bottom/Back device items.
    //

    for (INT i = 0; i < NUM_DEVICE_ITEM; i++) {

        //
        //  Build the item names.
        //

        BSTR    bstrItemName = NULL;
        BSTR    bstrFullItemName = NULL;

        bstrItemName = NULL;
        hr = GetBSTRResourceString(IDS_TOPITEM_NAME,&bstrItemName,TRUE);
        if (SUCCEEDED(hr)) {
            hr = GetBSTRResourceString(IDS_FULLTOPITEM_NAME,&bstrFullItemName,TRUE);
            if (SUCCEEDED(hr)) {

                //
                //  Call the class driver to create another driver item.
                //  This will be inserted as the child item.
                //

                PTESTMINIDRIVERITEMCONTEXT pItemContext;
                IWiaDrvItem                *pItem = NULL;

                hr = wiasCreateDrvItem(WiaItemTypeFile  |
                                       WiaItemTypeImage |
                                       WiaItemTypeDevice,
                                       bstrItemName,
                                       bstrFullItemName,
                                       (IWiaMiniDrv *)this,
                                       sizeof(TESTMINIDRIVERITEMCONTEXT),
                                       (PBYTE*) &pItemContext,
                                       &pItem);

                if (SUCCEEDED(hr)) {

                    //
                    // Initialize device specific context.
                    //

                    memset(pItemContext, 0, sizeof(TESTMINIDRIVERITEMCONTEXT));
                    pItemContext->lSize = sizeof(TESTMINIDRIVERITEMCONTEXT);

                    //
                    //  Call the class driver to add pItem to the folder
                    //  m_pIDrvItemRoot (i.e. make pItem a child of
                    //  m_pIDrvItemRoot).
                    //

                    hr = pItem->AddItemToFolder(m_pIDrvItemRoot);

                    if (FAILED(hr)) {
                        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddItemToFolder failed"));
                    }
                } else {
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
                }

                //
                // free the BSTR allocated by the BSTRResourceString helper
                //

                SysFreeString(bstrFullItemName);
            } else {
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate full item name"));
                hr = E_OUTOFMEMORY;
            }

            //
            // free the BSTR allocated by the BSTRResourceString helper
            //

            SysFreeString(bstrItemName);
        } else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate item name"));
            hr = E_OUTOFMEMORY;
        }

        break;  // Error if here, quit iterating.
    }

    if (FAILED(hr)) {
        DeleteItemTree();
    }
    return hr;
}

/**************************************************************************\
* GetBmiSize
*
*   Get the size of the BMI structure. We should never see biCompression
*   set to BI_RLE.
*
* Arguments:
*
*   pbmi      - Pointer to input BITMAPINFO structure.
*   plBmiSize - Pointer output BMI size.
*
* Return Value:
*
*    Size of
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall GetBmiSize(PBITMAPINFO pbmi, LONG *plBmiSize)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::GetBmiSize");

    // check plBmiSize pointer to see if it can be written to properly
    if (IsBadWritePtr(plBmiSize, sizeof(LONG))) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetBmiSize, bad plBmiSize"));
        return E_POINTER;
    }

    LONG lSize = pbmi->bmiHeader.biSize;

    if ((pbmi->bmiHeader.biCompression == BI_RLE8) ||
        (pbmi->bmiHeader.biCompression == BI_RLE4)) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetBmiSize, BI_RLE not allowed"));
        return E_INVALIDARG;
    }

    // determine the size of bits and palette data

    if ((pbmi->bmiHeader.biBitCount == 24) ||
        ((pbmi->bmiHeader.biBitCount == 32) &&
        (pbmi->bmiHeader.biCompression == BI_RGB))) {
        // no color table case, no colors unless stated

        lSize += sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed;

    } else if (((pbmi->bmiHeader.biBitCount == 32) &&
         (pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
         (pbmi->bmiHeader.biBitCount == 16)) {
        // bitfields case
        lSize += 3 * sizeof(RGBQUAD);

    } else if (pbmi->bmiHeader.biBitCount == 1) {
        // palette cases
        LONG lPal = pbmi->bmiHeader.biClrUsed;
        if ((lPal == 0) || (lPal > 2)) {
            lPal = 2;
        }
        lSize += lPal * sizeof(RGBQUAD);

    } else if (pbmi->bmiHeader.biBitCount == 4) {
        // palette case
        LONG lPal = pbmi->bmiHeader.biClrUsed;
        if ((lPal == 0) || (lPal > 16)) {
            lPal = 16;
        }
        lSize += lPal * sizeof(RGBQUAD);

    } else if (pbmi->bmiHeader.biBitCount == 8){
        // palette case
        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 256)){
             lPal = 256;
        }
        lSize += lPal * sizeof(RGBQUAD);
    }
    // assign calculated size to returned value
    *plBmiSize = lSize;
    return S_OK;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    11/16/1999 Original Version
*
\**************************************************************************/
HRESULT TestUsdDevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,sizeof(szStringValue));

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           sizeof(wszStringValue));

       *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    11/16/1999 Original Version
*
\**************************************************************************/
HRESULT TestUsdDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,sizeof(szStringValue));

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           sizeof(wszStringValue));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper initialize the global arrays used for Property intialization.
*   note: These globals are defined in ( DEFPROP.H )
*
*       [Array Name]            [Description]          [Array Type]
*
*   g_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   g_piRootItemDefaults  - Property ID array             (PROPID)
*   g_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   g_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   g_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    11/16/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::BuildRootItemProperties()
{
    HRESULT hr = S_OK;
    // start index after initial properties
    INT iPropArrayIndex = NUM_ROOTITEMDEFAULTS;

    // Intialize WIA_DPS_HORIZONTAL_BED_SIZE
    g_pszRootItemDefaults[0]              = WIA_DPS_HORIZONTAL_BED_SIZE_STR;
    g_piRootItemDefaults [0]              = WIA_DPS_HORIZONTAL_BED_SIZE;
    g_pvRootItemDefaults [0].lVal         = HORIZONTAL_BED_SIZE;
    g_pvRootItemDefaults [0].vt           = VT_I4;
    g_psRootItemDefaults [0].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [0].propid       = g_piRootItemDefaults [0];
    g_wpiRootItemDefaults[0].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiRootItemDefaults[0].vt           = g_pvRootItemDefaults [0].vt;

    // Intialize WIA_DPS_VERTICAL_BED_SIZE
    g_pszRootItemDefaults[1]              = WIA_DPS_VERTICAL_BED_SIZE_STR;
    g_piRootItemDefaults [1]              = WIA_DPS_VERTICAL_BED_SIZE;
    g_pvRootItemDefaults [1].lVal         = VERTICAL_BED_SIZE;
    g_pvRootItemDefaults [1].vt           = VT_I4;
    g_psRootItemDefaults [1].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [1].propid       = g_piRootItemDefaults [1];
    g_wpiRootItemDefaults[1].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiRootItemDefaults[1].vt           = g_pvRootItemDefaults [1].vt;

    // Intialize WIA_IPA_ACCESS_RIGHTS
    g_pszRootItemDefaults[2]              = WIA_IPA_ACCESS_RIGHTS_STR;
    g_piRootItemDefaults [2]              = WIA_IPA_ACCESS_RIGHTS;
    g_pvRootItemDefaults [2].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    g_pvRootItemDefaults [2].vt           = VT_UI4;
    g_psRootItemDefaults [2].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [2].propid       = g_piRootItemDefaults [2];
    g_wpiRootItemDefaults[2].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiRootItemDefaults[2].vt           = g_pvRootItemDefaults [2].vt;

    // Intialize WIA_DPS_OPTICAL_XRES
    g_pszRootItemDefaults[3]              = WIA_DPS_OPTICAL_XRES_STR;
    g_piRootItemDefaults [3]              = WIA_DPS_OPTICAL_XRES;
    g_pvRootItemDefaults [3].lVal         = OPTICAL_XRESOLUTION;
    g_pvRootItemDefaults [3].vt           = VT_I4;
    g_psRootItemDefaults [3].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [3].propid       = g_piRootItemDefaults [3];
    g_wpiRootItemDefaults[3].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiRootItemDefaults[3].vt           = g_pvRootItemDefaults [3].vt;

    // Intialize WIA_DPS_OPTICAL_YRES
    g_pszRootItemDefaults[4]              = WIA_DPS_OPTICAL_YRES_STR;
    g_piRootItemDefaults [4]              = WIA_DPS_OPTICAL_YRES;
    g_pvRootItemDefaults [4].lVal         = OPTICAL_YRESOLUTION;
    g_pvRootItemDefaults [4].vt           = VT_I4;
    g_psRootItemDefaults [4].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [4].propid       = g_piRootItemDefaults [4];
    g_wpiRootItemDefaults[4].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiRootItemDefaults[4].vt           = g_pvRootItemDefaults [4].vt;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    g_pszRootItemDefaults[5]              = WIA_DPA_FIRMWARE_VERSION_STR;
    g_piRootItemDefaults [5]              = WIA_DPA_FIRMWARE_VERSION;
    g_pvRootItemDefaults [5].bstrVal      = SysAllocString(WIATSCAN_FIRMWARE_VERSION);
    g_pvRootItemDefaults [5].vt           = VT_BSTR;
    g_psRootItemDefaults [5].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [5].propid       = g_piRootItemDefaults [5];
    g_wpiRootItemDefaults[5].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiRootItemDefaults[5].vt           = g_pvRootItemDefaults [5].vt;

    // Initialize WIA_IPA_ITEM_FLAGS
    g_pszRootItemDefaults[6]              = WIA_IPA_ITEM_FLAGS_STR;
    g_piRootItemDefaults [6]              = WIA_IPA_ITEM_FLAGS;
    g_pvRootItemDefaults [6].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    g_pvRootItemDefaults [6].vt           = VT_I4;
    g_psRootItemDefaults [6].ulKind       = PRSPEC_PROPID;
    g_psRootItemDefaults [6].propid       = g_piRootItemDefaults [6];
    g_wpiRootItemDefaults[6].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    g_wpiRootItemDefaults[6].vt           = g_pvRootItemDefaults [6].vt;
    g_wpiRootItemDefaults[6].ValidVal.Flag.Nom  = g_pvRootItemDefaults [6].lVal;
    g_wpiRootItemDefaults[6].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    if(g_bHasADF) {

        //
        // Initialize Automatic Document Feeder properties
        //

    }

    if(g_bHasTPA) {

        //
        // Initialize Transparant Adapter properties
        //
    }

    return hr;
}

/**************************************************************************\
* BuildTopItemProperties
*
*   This helper initialize the global arrays used for Property intialization.
*   note: These globals are defined in ( DEFPROP.H )
*
*       [Array Name]        [Description]           [Array Type]
*
*   g_pszItemDefaults - Property name  array         (LPOLESTR)
*   g_piItemDefaults  - Property ID array             (PROPID)
*   g_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   g_psItemDefaults  - Property Spec array          (PROPSPEC)
*   g_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    11/16/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::BuildTopItemProperties()
{
    HRESULT hr = S_OK;

    // Intialize WIA_IPS_XRES (RANGE)
    g_pszItemDefaults[0]                    = WIA_IPS_XRES_STR;
    g_piItemDefaults [0]                    = WIA_IPS_XRES;
    g_pvItemDefaults [0].lVal               = INITIAL_XRESOLUTION;
    g_pvItemDefaults [0].vt                 = VT_I4;
    g_psItemDefaults [0].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [0].propid             = g_piItemDefaults [0];
    g_wpiItemDefaults[0].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[0].vt                 = g_pvItemDefaults [0].vt;
    g_wpiItemDefaults[0].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[0].ValidVal.Range.Min = 12;
    g_wpiItemDefaults[0].ValidVal.Range.Max = 1600;
    g_wpiItemDefaults[0].ValidVal.Range.Nom = g_pvItemDefaults [0].lVal;

    // Intialize WIA_IPS_YRES (RANGE)
    g_pszItemDefaults[1]                    = WIA_IPS_YRES_STR;
    g_piItemDefaults [1]                    = WIA_IPS_YRES;
    g_pvItemDefaults [1].lVal               = INITIAL_YRESOLUTION;
    g_pvItemDefaults [1].vt                 = VT_I4;
    g_psItemDefaults [1].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [1].propid             = g_piItemDefaults [1];
    g_wpiItemDefaults[1].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[1].vt                 = g_pvItemDefaults [1].vt;
    g_wpiItemDefaults[1].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[1].ValidVal.Range.Min = 12;
    g_wpiItemDefaults[1].ValidVal.Range.Max = 1600;
    g_wpiItemDefaults[1].ValidVal.Range.Nom = g_pvItemDefaults [1].lVal;

    // Intialize WIA_IPS_XEXTENT (RANGE)
    g_pszItemDefaults[2]                    = WIA_IPS_XEXTENT_STR;
    g_piItemDefaults [2]                    = WIA_IPS_XEXTENT;
    g_pvItemDefaults [2].lVal               = (INITIAL_XRESOLUTION * HORIZONTAL_BED_SIZE)/1000;
    g_pvItemDefaults [2].vt                 = VT_I4;
    g_psItemDefaults [2].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [2].propid             = g_piItemDefaults [2];
    g_wpiItemDefaults[2].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[2].vt                 = g_pvItemDefaults [2].vt;
    g_wpiItemDefaults[2].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[2].ValidVal.Range.Min = 1;
    g_wpiItemDefaults[2].ValidVal.Range.Max = g_pvItemDefaults [2].lVal;
    g_wpiItemDefaults[2].ValidVal.Range.Nom = g_pvItemDefaults [2].lVal;

    // Intialize WIA_IPS_YEXTENT (RANGE)
    g_pszItemDefaults[3]                    = WIA_IPS_YEXTENT_STR;
    g_piItemDefaults [3]                    = WIA_IPS_YEXTENT;
    g_pvItemDefaults [3].lVal               = (INITIAL_YRESOLUTION * VERTICAL_BED_SIZE)/1000;;
    g_pvItemDefaults [3].vt                 = VT_I4;
    g_psItemDefaults [3].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [3].propid             = g_piItemDefaults [3];
    g_wpiItemDefaults[3].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[3].vt                 = g_pvItemDefaults [3].vt;
    g_wpiItemDefaults[3].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[3].ValidVal.Range.Min = 1;
    g_wpiItemDefaults[3].ValidVal.Range.Max = g_pvItemDefaults [3].lVal;
    g_wpiItemDefaults[3].ValidVal.Range.Nom = g_pvItemDefaults [3].lVal;

    // Intialize WIA_IPS_XPOS (RANGE)
    g_pszItemDefaults[4]                    = WIA_IPS_XPOS_STR;
    g_piItemDefaults [4]                    = WIA_IPS_XPOS;
    g_pvItemDefaults [4].lVal               = 0;
    g_pvItemDefaults [4].vt                 = VT_I4;
    g_psItemDefaults [4].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [4].propid             = g_piItemDefaults [4];
    g_wpiItemDefaults[4].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[4].vt                 = g_pvItemDefaults [4].vt;
    g_wpiItemDefaults[4].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[4].ValidVal.Range.Min = 0;
    g_wpiItemDefaults[4].ValidVal.Range.Max = (g_wpiItemDefaults[2].ValidVal.Range.Max - 1);
    g_wpiItemDefaults[4].ValidVal.Range.Nom = g_pvItemDefaults [4].lVal;

    // Intialize WIA_IPS_YPOS (RANGE)
    g_pszItemDefaults[5]                    = WIA_IPS_YPOS_STR;
    g_piItemDefaults [5]                    = WIA_IPS_YPOS;
    g_pvItemDefaults [5].lVal               = 0;
    g_pvItemDefaults [5].vt                 = VT_I4;
    g_psItemDefaults [5].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [5].propid             = g_piItemDefaults [5];
    g_wpiItemDefaults[5].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[5].vt                 = g_pvItemDefaults [5].vt;
    g_wpiItemDefaults[5].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[5].ValidVal.Range.Min = 0;
    g_wpiItemDefaults[5].ValidVal.Range.Max = (g_wpiItemDefaults[3].ValidVal.Range.Max - 1);
    g_wpiItemDefaults[5].ValidVal.Range.Nom = g_pvItemDefaults [5].lVal;

    // Intialize WIA_IPA_DATATYPE (LIST)
    g_pszItemDefaults[6]                    = WIA_IPA_DATATYPE_STR;
    g_piItemDefaults [6]                    = WIA_IPA_DATATYPE;
    g_pvItemDefaults [6].lVal               = INITIAL_DATATYPE;
    g_pvItemDefaults [6].vt                 = VT_I4;
    g_psItemDefaults [6].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [6].propid             = g_piItemDefaults [6];
    g_wpiItemDefaults[6].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    g_wpiItemDefaults[6].vt                 = g_pvItemDefaults [6].vt;

    g_wpiItemDefaults[6].ValidVal.List.pList    = (BYTE*)g_DataTypeArray;
    g_wpiItemDefaults[6].ValidVal.List.Nom      = g_pvItemDefaults [6].lVal;
    g_wpiItemDefaults[6].ValidVal.List.cNumList = NUM_DATATYPES;

    // Intialize WIA_IPA_DEPTH (LIST)
    g_pszItemDefaults[7]                    = WIA_IPA_DEPTH_STR;
    g_piItemDefaults [7]                    = WIA_IPA_DEPTH;
    g_pvItemDefaults [7].lVal               = INITIAL_BITDEPTH;
    g_pvItemDefaults [7].vt                 = VT_I4;
    g_psItemDefaults [7].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [7].propid             = g_piItemDefaults [7];
    g_wpiItemDefaults[7].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[7].vt                 = g_pvItemDefaults [7].vt;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    g_pszItemDefaults[8]                    = WIA_IPS_BRIGHTNESS_STR;
    g_piItemDefaults [8]                    = WIA_IPS_BRIGHTNESS;
    g_pvItemDefaults [8].lVal               = INITIAL_BRIGHTNESS;
    g_pvItemDefaults [8].vt                 = VT_I4;
    g_psItemDefaults [8].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [8].propid             = g_piItemDefaults [8];
    g_wpiItemDefaults[8].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[8].vt                 = g_pvItemDefaults [8].vt;
    g_wpiItemDefaults[8].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[8].ValidVal.Range.Min = -127;
    g_wpiItemDefaults[8].ValidVal.Range.Max = 128;
    g_wpiItemDefaults[8].ValidVal.Range.Nom = g_pvItemDefaults [8].lVal;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    g_pszItemDefaults[9]                    = WIA_IPS_CONTRAST_STR;
    g_piItemDefaults [9]                    = WIA_IPS_CONTRAST;
    g_pvItemDefaults [9].lVal               = INITIAL_CONTRAST;
    g_pvItemDefaults [9].vt                 = VT_I4;
    g_psItemDefaults [9].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [9].propid             = g_piItemDefaults [9];
    g_wpiItemDefaults[9].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[9].vt                 = g_pvItemDefaults [9].vt;
    g_wpiItemDefaults[9].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[9].ValidVal.Range.Min = -127;
    g_wpiItemDefaults[9].ValidVal.Range.Max = 128;
    g_wpiItemDefaults[9].ValidVal.Range.Nom = g_pvItemDefaults [9].lVal;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    g_pszItemDefaults[10]                    = WIA_IPS_CUR_INTENT_STR;
    g_piItemDefaults [10]                    = WIA_IPS_CUR_INTENT;
    g_pvItemDefaults [10].lVal               = WIA_INTENT_NONE;
    g_pvItemDefaults [10].vt                 = VT_I4;
    g_psItemDefaults [10].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [10].propid             = g_piItemDefaults [10];
    g_wpiItemDefaults[10].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    g_wpiItemDefaults[10].vt                 = g_pvItemDefaults [10].vt;
    g_wpiItemDefaults[10].ValidVal.Flag.Nom  = g_pvItemDefaults [10].lVal;
    g_wpiItemDefaults[10].ValidVal.Flag.ValidBits = WIA_INTENT_SIZE_MASK | WIA_INTENT_IMAGE_TYPE_MASK;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    g_pszItemDefaults[11]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    g_piItemDefaults [11]                    = WIA_IPA_PIXELS_PER_LINE;
    g_pvItemDefaults [11].lVal               = (INITIAL_XRESOLUTION * HORIZONTAL_BED_SIZE)/1000;
    g_pvItemDefaults [11].vt                 = VT_I4;
    g_psItemDefaults [11].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [11].propid             = g_piItemDefaults [11];
    g_wpiItemDefaults[11].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[11].vt                 = g_pvItemDefaults [11].vt;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    g_pszItemDefaults[12]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    g_piItemDefaults [12]                    = WIA_IPA_NUMBER_OF_LINES;
    g_pvItemDefaults [12].lVal               = (INITIAL_YRESOLUTION * VERTICAL_BED_SIZE)/1000;
    g_pvItemDefaults [12].vt                 = VT_I4;
    g_psItemDefaults [12].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [12].propid             = g_piItemDefaults [12];
    g_wpiItemDefaults[12].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[12].vt                 = g_pvItemDefaults [12].vt;

    // Intialize WIA_IPA_ITEM_TIME (NONE)
    g_pszItemDefaults[13]                    = WIA_IPA_ITEM_TIME_STR;
    g_piItemDefaults [13]                    = WIA_IPA_ITEM_TIME;
    g_pvItemDefaults [13].lVal               = 0;
    g_pvItemDefaults [13].vt                 = VT_VECTOR|VT_I4;
    g_psItemDefaults [13].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [13].propid             = g_piItemDefaults [13];
    g_wpiItemDefaults[13].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[13].vt                 = g_pvItemDefaults [13].vt;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    g_pszItemDefaults[14]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    g_piItemDefaults [14]                    = WIA_IPA_PREFERRED_FORMAT;
    g_pvItemDefaults [14].puuid              = INITIAL_FORMAT;
    g_pvItemDefaults [14].vt                 = VT_CLSID;
    g_psItemDefaults [14].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [14].propid             = g_piItemDefaults [14];
    g_wpiItemDefaults[14].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[14].vt                 = g_pvItemDefaults [14].vt;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    g_pszItemDefaults[15]                    = WIA_IPA_ITEM_SIZE_STR;
    g_piItemDefaults [15]                    = WIA_IPA_ITEM_SIZE;
    g_pvItemDefaults [15].lVal               = 0;
    g_pvItemDefaults [15].vt                 = VT_I4;
    g_psItemDefaults [15].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [15].propid             = g_piItemDefaults [15];
    g_wpiItemDefaults[15].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[15].vt                 = g_pvItemDefaults [15].vt;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    g_pszItemDefaults[16]                    = WIA_IPS_THRESHOLD_STR;
    g_piItemDefaults [16]                    = WIA_IPS_THRESHOLD;
    g_pvItemDefaults [16].lVal               = 0;
    g_pvItemDefaults [16].vt                 = VT_I4;
    g_psItemDefaults [16].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [16].propid             = g_piItemDefaults [16];
    g_wpiItemDefaults[16].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[16].vt                 = g_pvItemDefaults [16].vt;
    g_wpiItemDefaults[16].ValidVal.Range.Inc = 1;
    g_wpiItemDefaults[16].ValidVal.Range.Min = -127;
    g_wpiItemDefaults[16].ValidVal.Range.Max = 128;
    g_wpiItemDefaults[16].ValidVal.Range.Nom = g_pvItemDefaults [16].lVal;

    // Intialize WIA_IPA_FORMAT (LIST)
    g_pszItemDefaults[17]                    = WIA_IPA_FORMAT_STR;
    g_piItemDefaults [17]                    = WIA_IPA_FORMAT;
    g_pvItemDefaults [17].puuid              = INITIAL_FORMAT;
    g_pvItemDefaults [17].vt                 = VT_CLSID;
    g_psItemDefaults [17].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [17].propid             = g_piItemDefaults [17];
    g_wpiItemDefaults[17].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    g_wpiItemDefaults[17].vt                 = g_pvItemDefaults [17].vt;

    g_wpiItemDefaults[17].ValidVal.ListGuid.pList    = (GUID*)g_pInitialFormatArray;
    g_wpiItemDefaults[17].ValidVal.ListGuid.Nom      = *g_pvItemDefaults [17].puuid;
    g_wpiItemDefaults[17].ValidVal.ListGuid.cNumList = NUM_INITIALFORMATS;

    // Intialize WIA_IPA_TYMED (LIST)
    g_pszItemDefaults[18]                    = WIA_IPA_TYMED_STR;
    g_piItemDefaults [18]                    = WIA_IPA_TYMED;
    g_pvItemDefaults [18].lVal               = INITIAL_TYMED;
    g_pvItemDefaults [18].vt                 = VT_I4;
    g_psItemDefaults [18].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [18].propid             = g_piItemDefaults [18];
    g_wpiItemDefaults[18].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    g_wpiItemDefaults[18].vt                 = g_pvItemDefaults [18].vt;

    g_wpiItemDefaults[18].ValidVal.List.pList    = (BYTE*)g_TYMEDArray;
    g_wpiItemDefaults[18].ValidVal.List.Nom      = g_pvItemDefaults [18].lVal;
    g_wpiItemDefaults[18].ValidVal.List.cNumList = NUM_TYMEDS;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    g_pszItemDefaults[19]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    g_piItemDefaults [19]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    g_pvItemDefaults [19].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    g_pvItemDefaults [19].vt                 = VT_I4;
    g_psItemDefaults [19].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [19].propid             = g_piItemDefaults [19];
    g_wpiItemDefaults[19].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[19].vt                 = g_pvItemDefaults [19].vt;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    g_pszItemDefaults[20]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    g_piItemDefaults [20]                    = WIA_IPA_BITS_PER_CHANNEL;
    g_pvItemDefaults [20].lVal               = INITIAL_BITS_PER_CHANNEL;
    g_pvItemDefaults [20].vt                 = VT_I4;
    g_psItemDefaults [20].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [20].propid             = g_piItemDefaults [20];
    g_wpiItemDefaults[20].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[20].vt                 = g_pvItemDefaults [20].vt;

    // Intialize WIA_IPA_PLANAR (NONE)
    g_pszItemDefaults[21]                    = WIA_IPA_PLANAR_STR;
    g_piItemDefaults [21]                    = WIA_IPA_PLANAR;
    g_pvItemDefaults [21].lVal               = INITIAL_PLANAR;
    g_pvItemDefaults [21].vt                 = VT_I4;
    g_psItemDefaults [21].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [21].propid             = g_piItemDefaults [21];
    g_wpiItemDefaults[21].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[21].vt                 = g_pvItemDefaults [21].vt;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    g_pszItemDefaults[22]                    = WIA_IPA_BYTES_PER_LINE_STR;
    g_piItemDefaults [22]                    = WIA_IPA_BYTES_PER_LINE;
    g_pvItemDefaults [22].lVal               = 0;
    g_pvItemDefaults [22].vt                 = VT_I4;
    g_psItemDefaults [22].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [22].propid             = g_piItemDefaults [22];
    g_wpiItemDefaults[22].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[22].vt                 = g_pvItemDefaults [22].vt;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    g_pszItemDefaults[23]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    g_piItemDefaults [23]                    = WIA_IPA_MIN_BUFFER_SIZE;
    g_pvItemDefaults [23].lVal               = MIN_BUFFER_SIZE;
    g_pvItemDefaults [23].vt                 = VT_I4;
    g_psItemDefaults [23].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [23].propid             = g_piItemDefaults [23];
    g_wpiItemDefaults[23].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[23].vt                 = g_pvItemDefaults [23].vt;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    g_pszItemDefaults[24]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    g_piItemDefaults [24]                    = WIA_IPA_ACCESS_RIGHTS;
    g_pvItemDefaults [24].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    g_pvItemDefaults [24].vt                 = VT_UI4;
    g_psItemDefaults [24].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [24].propid             = g_piItemDefaults [24];
    g_wpiItemDefaults[24].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[24].vt                 = g_pvItemDefaults [24].vt;

    // Intialize WIA_IPA_SENSITIVITY (RANGE)
    g_pszItemDefaults[25]                    = WIA_IPA_SENSITIVITY_STR;
    g_piItemDefaults [25]                    = WIA_IPA_SENSITIVITY;
    g_pvItemDefaults [25].fltVal             = INITIAL_SENSITIVITY;
    g_pvItemDefaults [25].vt                 = VT_R4;
    g_psItemDefaults [25].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [25].propid             = g_piItemDefaults [25];
    g_wpiItemDefaults[25].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[25].vt                 = g_pvItemDefaults [25].vt;
    g_wpiItemDefaults[25].ValidVal.RangeFloat.Inc = 1.0f;
    g_wpiItemDefaults[25].ValidVal.RangeFloat.Min = -10.0f;
    g_wpiItemDefaults[25].ValidVal.RangeFloat.Max = 10.0f;
    g_wpiItemDefaults[25].ValidVal.RangeFloat.Nom = g_pvItemDefaults [25].fltVal;

    // Intialize WIA_IPA_CORRECTION (RANGE)
    g_pszItemDefaults[26]                    = WIA_IPA_CORRECTION_STR;
    g_piItemDefaults [26]                    = WIA_IPA_CORRECTION;
    g_pvItemDefaults [26].fltVal             = INITIAL_CORRECTION;
    g_pvItemDefaults [26].vt                 = VT_R4;
    g_psItemDefaults [26].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [26].propid             = g_piItemDefaults [26];
    g_wpiItemDefaults[26].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    g_wpiItemDefaults[26].vt                 = g_pvItemDefaults [26].vt;
    g_wpiItemDefaults[26].ValidVal.RangeFloat.Inc = 1.0f;
    g_wpiItemDefaults[26].ValidVal.RangeFloat.Min = -500.0f;
    g_wpiItemDefaults[26].ValidVal.RangeFloat.Max = 500.0f;
    g_wpiItemDefaults[26].ValidVal.RangeFloat.Nom = g_pvItemDefaults [26].fltVal;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    g_pszItemDefaults[27]                    = WIA_IPA_COMPRESSION_STR;
    g_piItemDefaults [27]                    = WIA_IPA_COMPRESSION;
    g_pvItemDefaults [27].lVal               = INITIAL_COMPRESSION;
    g_pvItemDefaults [27].vt                 = VT_I4;
    g_psItemDefaults [27].ulKind             = PRSPEC_PROPID;
    g_psItemDefaults [27].propid             = g_piItemDefaults [27];
    g_wpiItemDefaults[27].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    g_wpiItemDefaults[27].vt                 = g_pvItemDefaults [27].vt;

    g_wpiItemDefaults[27].ValidVal.List.pList    = (BYTE*)g_CompressionArray;
    g_wpiItemDefaults[27].ValidVal.List.Nom      = g_pvItemDefaults [27].lVal;
    g_wpiItemDefaults[27].ValidVal.List.cNumList = NUM_COMPRESSIONS;

    // Initialize WIA_IPA_ITEM_FLAGS
    g_pszItemDefaults[28]              = WIA_IPA_ITEM_FLAGS_STR;
    g_piItemDefaults [28]              = WIA_IPA_ITEM_FLAGS;
    g_pvItemDefaults [28].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    g_pvItemDefaults [28].vt           = VT_I4;
    g_psItemDefaults [28].ulKind       = PRSPEC_PROPID;
    g_psItemDefaults [28].propid       = g_piItemDefaults [28];
    g_wpiItemDefaults[28].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    g_wpiItemDefaults[28].vt           = g_pvItemDefaults [28].vt;
    g_wpiItemDefaults[28].ValidVal.Flag.Nom  = g_pvItemDefaults [28].lVal;
    g_wpiItemDefaults[28].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    g_pszItemDefaults[29]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    g_piItemDefaults [29]              = WIA_IPS_PHOTOMETRIC_INTERP;
    g_pvItemDefaults [29].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    g_pvItemDefaults [29].vt           = VT_I4;
    g_psItemDefaults [29].ulKind       = PRSPEC_PROPID;
    g_psItemDefaults [29].propid       = g_piItemDefaults [29];
    g_wpiItemDefaults[29].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    g_wpiItemDefaults[29].vt           = g_pvItemDefaults [29].vt;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initialize the global capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    11/16/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if(g_bCapabilitiesInitialized) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    //
    // Initialize EVENTS
    //

    // WIA_EVENT_DEVICE_CONNECTED
    GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(g_Capabilities[0].wszName),TRUE);
    GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(g_Capabilities[0].wszDescription),TRUE);
    g_Capabilities[0].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
    g_Capabilities[0].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
    g_Capabilities[0].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

    // WIA_EVENT_DEVICE_DISCONNECTED
    GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(g_Capabilities[1].wszName),TRUE);
    GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(g_Capabilities[1].wszDescription),TRUE);
    g_Capabilities[1].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
    g_Capabilities[1].ulFlags        = WIA_NOTIFICATION_EVENT;
    g_Capabilities[1].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

    //
    // Initialize COMMANDS
    //

    // WIA_CMD_SYNCHRONIZE
    GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(g_Capabilities[2].wszName),TRUE);
    GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(g_Capabilities[2].wszDescription),TRUE);
    g_Capabilities[2].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
    g_Capabilities[2].ulFlags        = 0;
    g_Capabilities[2].wszIcon        = WIA_ICON_SYNCHRONIZE;

    // WIA_CMD_DELETE_ALL_ITEMS
    GetOLESTRResourceString(IDS_CMD_DELETE_ALL_ITEMS_NAME,&(g_Capabilities[3].wszName),TRUE);
    GetOLESTRResourceString(IDS_CMD_DELETE_ALL_ITEMS_DESC,&(g_Capabilities[3].wszDescription),TRUE);
    g_Capabilities[3].guid           = (GUID*)&WIA_CMD_DELETE_ALL_ITEMS;
    g_Capabilities[3].ulFlags        = 0;
    g_Capabilities[3].wszIcon        = WIA_ICON_DELETE_ALL_ITEMS;

    // WIA_CMD_DELETE_DEVICE_TREE
    GetOLESTRResourceString(IDS_CMD_DELETE_DEVICE_TREE_NAME,&(g_Capabilities[4].wszName),TRUE);
    GetOLESTRResourceString(IDS_CMD_DELETE_DEVICE_TREE_DESC,&(g_Capabilities[4].wszDescription),TRUE);
    g_Capabilities[4].guid           = (GUID*)&WIA_CMD_DELETE_DEVICE_TREE;
    g_Capabilities[4].ulFlags        = 0;
    g_Capabilities[4].wszIcon        = WIA_ICON_DELETE_DEVICE_TREE;

    // WIA_CMD_BUILD_DEVICE_TREE
    GetOLESTRResourceString(IDS_CMD_BUILD_DEVICE_TREE_NAME,&(g_Capabilities[5].wszName),TRUE);
    GetOLESTRResourceString(IDS_CMD_BUILD_DEVICE_TREE_DESC,&(g_Capabilities[5].wszDescription),TRUE);
    g_Capabilities[5].guid           = (GUID*)&WIA_CMD_BUILD_DEVICE_TREE;
    g_Capabilities[5].ulFlags        = 0;
    g_Capabilities[5].wszIcon        = WIA_ICON_BUILD_DEVICE_TREE;

    g_bCapabilitiesInitialized = TRUE;
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper cleans up allocated strings used in the global capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    11/16/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::DeleteCapabilitiesArrayContents()
{
    HRESULT hr = S_OK;
    if(g_bCapabilitiesInitialized) {
        g_bCapabilitiesInitialized = FALSE;

        for (INT i = 0; i < NUM_CAPABILITIES;i++) {
            CoTaskMemFree(g_Capabilities[i].wszName);
            CoTaskMemFree(g_Capabilities[i].wszDescription);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testusd.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117 

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       Validate.cpp
*
*  VERSION:     2.0
*
*  DATE:        16 November, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA Test Scanner mini driver helper methods for
*   validation.
*
*******************************************************************************/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "testusd.h"

#define SKIP_PROP

#include "defprop.h"

extern HINSTANCE        g_hInst;     // Instance of this DLL
extern IWiaLog         *g_pIWiaLog;  // Logging Interface

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    04/04/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::UpdateValidDepth");
    HRESULT hr = S_OK;
    LONG    pValidDepth[1];

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            pValidDepth[0] = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            pValidDepth[0] = 8;
            break;
        case WIA_DATA_COLOR:
            pValidDepth[0] = 24;
            break;
        default:
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    if (lDepth) {
        *lDepth = pValidDepth[0];
    }
    
    return hr;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE 
*   property is changed.  When this property changes, other dependant 
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have 
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    04/29/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::CheckDataType");
    WIAS_CHANGED_VALUE_INFO cviDataType, cviDepth;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be 
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed 
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid 
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext, 
                                 FALSE,
                                 WIA_IPA_DATATYPE, 
                                 &cviDataType);
    if (FAILED(hr)) {
        return hr;
    } 
        
    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of 
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for 
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed 
    //  so that dependant properties will know whether the Depth is being 
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid 
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext, 
                                 cviDataType.bChanged, 
                                 WIA_IPA_DEPTH, 
                                 &cviDepth);
    if (FAILED(hr)) {
        return hr;
    } 

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);

        if (SUCCEEDED(hr)) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (SUCCEEDED(hr)) {
            #define NUM_PROPS_TO_SET 2
            PROPSPEC    ps[NUM_PROPS_TO_SET] = {
                            {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                            {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL}};
            PROPVARIANT pv[NUM_PROPS_TO_SET];
        
            for (LONG index = 0; index < NUM_PROPS_TO_SET; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }
    
            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;
    
                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
    
                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;
    
                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, NUM_PROPS_TO_SET, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have 
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    04/04/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::CheckIntent");
    HRESULT                 hr;
    WIAS_CHANGED_VALUE_INFO cviIntent;

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in 
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be 
    //  skipped (since valid values for CurrentIntent never change). The 
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties 
    //  will know whether the YResolution is being changed or not.  This is 
    //  important since dependant properties will need their valid values 
    //  updated and may need to be folded to new valid values.
    //

    hr = wiasGetChangedValueLong(pWiasContext, 
                                 pContext, 
                                 FALSE, 
                                 WIA_IPS_CUR_INTENT, 
                                 &cviIntent);
    if (SUCCEEDED(hr)) {
        if (cviIntent.bChanged) {

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);
            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);

            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    return S_OK;
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_GRAYSCALE);
                    UpdateValidDepth (pWiasContext, WIA_DATA_GRAYSCALE, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 8);
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_THRESHOLD);
                    UpdateValidDepth (pWiasContext, WIA_DATA_THRESHOLD, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 1);
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);
                    UpdateValidDepth(pWiasContext, WIA_DATA_COLOR, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 24);
                    break;

                default:
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent"));
                    return E_INVALIDARG;

            }
            
            //
            // Set the X and Y Resolutions.
            // Note: This should be done independantly for each INTENT type, if needed. The Test Scanner
            //       uses the same resolution pairs for all intents.
            //

            wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
            wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);

            //
            //  The Resolutions and DataType were set, so update the property
            //  context to indicate that they have changed.
            //
        
            wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
            wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
            wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);
            
            //
            // Reset any device item properties which may have changed due to validation.
            //
            
            //
            // update IPA_NUMBER_OF_LINES property
            //
            
            LONG lLength = 0;

            hr = wiasReadPropLong(pWiasContext, WIA_IPS_YEXTENT, &lLength, NULL, TRUE);
            if (SUCCEEDED(hr)) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, lLength);
                if (FAILED(hr)) {
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_NUMBER_OF_LINES"));
                    return hr;
                }
            } else {
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_YEXTENT"));
                return hr;
            }

            //
            // update IPA_PIXEL_PER_LINE property
            //

            LONG lWidth = 0;

            hr = wiasReadPropLong(pWiasContext, WIA_IPS_XEXTENT, &lWidth, NULL, TRUE);
            if (SUCCEEDED(hr)) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lWidth);
                if (FAILED(hr)) {
                    WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_PIXELS_PER_LINE"));
                    return hr;
                }
            } else {
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_XEXTENT"));
                return hr;
            }
        }
    } else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have 
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1999 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    HRESULT hr = S_OK;

    //
    // update WIA_IPA_PREFERRED_FORMAT property
    //
    
    GUID FormatGUID;
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
        if (FAILED(hr)) {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
            return hr;
        }
    } else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\device.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       Device.Cpp
*
*  VERSION:     2.0
*
*  DATE:        5 Jan, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner device methods. This sample WIA USD
*   supports push events by detecting when %windir%\temp\TESTUSD.BMP file has
*   been modified. This file becomes the new source of scanning data. An
*   event is generated the first time the device is loaded.
*
*******************************************************************************/

#include <tchar.h>
#include "testusd.h"

extern HINSTANCE g_hInst;
extern IWiaLog *g_pIWiaLog;

// Function prototypes, implemented in this file:
void FileChangeThread(LPVOID  lpParameter);

/**************************************************************************\
* TestUsdDevice::TestUsdDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdDevice::TestUsdDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    m_fValid(FALSE),
    m_pIStiDevControl(NULL),
    m_hShutdownEvent(INVALID_HANDLE_VALUE),
    m_hSignalEvent(INVALID_HANDLE_VALUE),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_pIWiaEventCallback(NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pStiDevice(NULL),
    m_pIDrvItemRoot(NULL)
{
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("TestUsdDevice::TestUsdDevice (create)"));

    *m_szSrcDataName = L'\0';

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    }
    else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }
}

/**************************************************************************\
* TestUsdDevice::PrivateInitialize
*
*   Device class private initialization
*
* Arguments:
*
*    None
*
* Return Value:
*
*    HRESULT
*
\**************************************************************************/

HRESULT TestUsdDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;
    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {
        // Create event for syncronization of notifications shutdown.
        m_hShutdownEvent =  CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        }
        else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::TestUsdDevice, create shutdown event failed"));
        }
    }
    
    return hr;
}

/**************************************************************************\
* TestUsdDevice::~TestUsdDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdDevice::~TestUsdDevice(void)
{
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("TestUsdDevice::~TestUsdDevice (destroy)"));

    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

    // Free the storage for the device ID.
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Release the objects supporting device property storage.
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

    // Delete allocated strings used in the Capabilites array
    DeleteCapabilitiesArrayContents();
    
    // Free the critical section.
    DeleteCriticalSection(&m_csShutdown);
}

/**************************************************************************\
* TestUsdDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::GetCapabilities");
    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    // We do support device notifications, but do not requiring polling.
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::GetStatus");
    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If we are asked, verify whether device is online.
    pDevStatus->dwOnlineState = 0L;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {

        // The test device is always on-line.
        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
    }

    // If we are asked, verify state of event.
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        // Generate an event the first time we load.
        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_bUsdLoadEvent = FALSE;
        }

        // Has there been a change in the source data file?
        if (IsChangeDetected(NULL)) {
            pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
        }
    }
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::DeviceReset");

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::Diagnostic");

    // Initialize response buffer
    pBuffer->dwStatusMask = 0;

    ZeroMemory(&pBuffer->sErrorInfo,sizeof(pBuffer->sErrorInfo));

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::SetNotificationHandle");
    HRESULT hr;

    EnterCriticalSection(&m_csShutdown);

    // Are we starting or stopping the notification thread?
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {

        m_hSignalEvent = hEvent;

        // Initialize to no event.
        m_guidLastEvent = GUID_NULL;

        // Create the notification thread.
        if (!m_hEventNotifyThread) {

            DWORD   dwThread;

            m_hEventNotifyThread = CreateThread(NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE)FileChangeThread,
                                                (LPVOID)this,
                                                0,
                                                &dwThread);

            if (!m_hEventNotifyThread) {
                WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::SetNotificationHandle, unable to create notification thread"));
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
        }
        else {
            WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::SetNotificationHandle, spurious notification thread"));
            hr = STIERR_UNSUPPORTED;
        }
    }
    else {

        // Disable event notifications.
        SetEvent(m_hShutdownEvent);
        if (m_hEventNotifyThread) {
            WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("Disabling event notification"));
            WaitForSingleObject(m_hEventNotifyThread, 400);
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
            m_guidLastEvent = GUID_NULL;
        }
    }
    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* TestUsdDevice::GetNotificationData
*
*   Provides data on n event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::GetNotificationData");
    // If we have notification ready - return it's guid
    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {
        pBuffer->guidNotificationCode  = m_guidLastEvent;
        m_guidLastEvent = GUID_NULL;
        pBuffer->dwSize = sizeof(STINOTIFY);
        ZeroMemory(&pBuffer->abNotificationData, sizeof(pBuffer->abNotificationData));
    }
    else {
        return STIERR_NOEVENTS;
    }

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::Escape");

    // Write command to device if needed.
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::GetLastError");

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::GetLastErrorInfo");    

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::LockDevice");
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::UnLockDevice");
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::RawReadData");
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::RawWriteData");
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::RawReadCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::RawWriteCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::Initialize");

    HRESULT hr = STI_OK;
    UINT    uiNameLen = 0;

    if (!pIStiDevControl) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    // Cache the device control interface.
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    // Build the path name of the data source file.
    DWORD dwRet = GetTempPath(MAX_PATH, m_szSrcDataName);
    if (dwRet != 0) {
        _tcscat(m_szSrcDataName, DATA_8BIT_SRC_NAME);
    }
    else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::Initialize, unable to get device name"));
        return STIERR_NOT_INITIALIZED;
    }

    // Make sure we can open the data source file.
    HANDLE hTestBmp = CreateFile(m_szSrcDataName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_SYSTEM,
                                 NULL);

    m_dwLastOperationError = ::GetLastError();

    if (hTestBmp == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(m_dwLastOperationError);
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::Initialize, unable to open data source file:"));
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("  %ls", m_szSrcDataName));
        WIAS_LHRESULT(g_pIWiaLog, hr);
    }
    else {
        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("  Source data: %ls", m_szSrcDataName));
        CloseHandle(hTestBmp);
    }
    return hr;
}

/**************************************************************************\
* TestUsdDevice::RunNotifications
*
*   Monitor changes to the source data file parent directory.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

VOID TestUsdDevice::RunNotifications(void)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::RunNotifications");
    HANDLE  hNotifyFileSysChange;
    DWORD   dwErr;

    TCHAR    szDirPath[MAX_PATH];
    TCHAR    *pszLastSlash;

    WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("TestUsdDevice::RunNotifications"));

    // Find name of the parent directory for the data source file and
    // set up waiting on any changes in it.

    _tcscpy(szDirPath, m_szSrcDataName);
    pszLastSlash = _tcschr(szDirPath,TEXT('\\'));
    if (pszLastSlash) {
        *pszLastSlash = '\0';
    }

    hNotifyFileSysChange = FindFirstChangeNotification(szDirPath,
                                                       FALSE,
                                                       FILE_NOTIFY_CHANGE_SIZE |
                                                       FILE_NOTIFY_CHANGE_LAST_WRITE |
                                                       FILE_NOTIFY_CHANGE_FILE_NAME |
                                                       FILE_NOTIFY_CHANGE_DIR_NAME);

    if (hNotifyFileSysChange == INVALID_HANDLE_VALUE) {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::RunNotifications, FindFirstChangeNotification failed: 0x%08X", ::GetLastError()));
        return;
    }

    // Set initial values for time and size
    IsChangeDetected(NULL);

    //
    HANDLE  hEvents[2] = {m_hShutdownEvent, hNotifyFileSysChange};
    BOOL    fLooping = TRUE;

    // Wait for file system change or shutdown event.
    while (fLooping) {
        dwErr = ::WaitForMultipleObjects(2,
                                         hEvents,
                                         FALSE,
                                         INFINITE);
        switch(dwErr) {
            case WAIT_OBJECT_0+1:

                // Change detected - signal
                if (m_hSignalEvent !=INVALID_HANDLE_VALUE) {

                    // Which change ?
                    if (IsChangeDetected(&m_guidLastEvent)) {

                        WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,("Data source file change detected"));

                        ::SetEvent(m_hSignalEvent);
                    }
                }

                // Go back to waiting for next file system event
                FindNextChangeNotification(hNotifyFileSysChange);
                break;

            case WAIT_OBJECT_0:
                // Fall through
            default:
                fLooping = FALSE;
        }
    }

    FindCloseChangeNotification(hNotifyFileSysChange);
}

/**************************************************************************\
* TestUsdDevice::IsChangeDetected
*
*   Detects changes to the source data file.
*
* Arguments:
*
*    pguidEvent - Pointer to event ID.
*
* Return Value:
*
*    True if change detected/
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL TestUsdDevice::IsChangeDetected(GUID *pguidEvent)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "TestUsdDevice::IsChangeDetected");
    BOOL                        bRet = FALSE;
    LARGE_INTEGER               liNewHugeSize;
    FILETIME                    ftLastWriteTime;
    DWORD                       dwError = NOERROR;
    WIN32_FIND_DATA             sNewFileAttributes;
    HANDLE                      hFind = INVALID_HANDLE_VALUE;

    // Get the source data file attributes.
    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));

    hFind = FindFirstFile( m_szSrcDataName, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE)
    {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    }
    else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        // First check file size.
        if (m_dwLastHugeSize.QuadPart != liNewHugeSize.QuadPart) {
            if (pguidEvent) {
                *pguidEvent = guidEventSizeChanged;
            }
            bRet = TRUE;
        }
        else {
            // Now check file date/time.
            if (CompareFileTime(&m_ftLastWriteTime,&ftLastWriteTime) == -1) {
                if (pguidEvent) {
                    *pguidEvent = guidEventTimeChanged;
                }
                bRet = TRUE;
            }
        }

        m_ftLastWriteTime = ftLastWriteTime;
        m_dwLastHugeSize  = liNewHugeSize;
    }
    else {
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("TestUsdDevice::IsChangeDetected, Unable to get file attributes: 0x%08X", ::GetLastError()));
    }
    return bRet;
}

/**************************************************************************\
* FileChangeThread
*
*   Calls RunNotifications to detect changing source data file.
*
* Arguments:
*
*    lpParameter    - Pointer to device object.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

VOID FileChangeThread(LPVOID  lpParameter)
{
    CWiaLogProc WIAS_LOGPROC(g_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::FileChangeThread");
    TestUsdDevice   *pThisDevice = (TestUsdDevice *)lpParameter;

    pThisDevice->RunNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\defprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       DefProp.h
*
*  VERSION:     3.0
*
*  DATE:        16 November, 1999
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   WIA test scanner.
*
***************************************************************************/

#ifndef SKIP_PROP

#define NUM_TYMEDS  2
LONG g_TYMEDArray [NUM_TYMEDS]= { TYMED_CALLBACK,TYMED_FILE };

#define NUM_WIA_FORMAT_INFO 2
WIA_FORMAT_INFO* g_wfiTable = NULL;

/***************************************************************************
*                       Device Capabilties / Events
****************************************************************************/

#define NUM_CAPABILITIES 6 // Events + Commands
#define NUM_EVENTS       2 // Events only

WIA_DEV_CAP_DRV g_Capabilities[NUM_CAPABILITIES];
BOOL g_bCapabilitiesInitialized = FALSE;

/***************************************************************************
*                       Properties for root items
****************************************************************************/

//
// Number of device specific root item properties.
//

#define NUM_ROOTITEMDEFAULTS    7

LPOLESTR          g_pszRootItemDefaults[NUM_ROOTITEMDEFAULTS];
PROPID            g_piRootItemDefaults [NUM_ROOTITEMDEFAULTS];
PROPVARIANT       g_pvRootItemDefaults [NUM_ROOTITEMDEFAULTS];
PROPSPEC          g_psRootItemDefaults [NUM_ROOTITEMDEFAULTS];
WIA_PROPERTY_INFO g_wpiRootItemDefaults[NUM_ROOTITEMDEFAULTS];

BOOL g_bHasADF = FALSE;
BOOL g_bHasTPA = FALSE;

//
// Initial values
//

#define WIATSCAN_FIRMWARE_VERSION L"6.26.74"
#define OPTICAL_XRESOLUTION       300
#define OPTICAL_YRESOLUTION       300
#define HORIZONTAL_BED_SIZE       8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE         11000  // in one thousandth's of an inch

/***************************************************************************
*                       Properties for non-root items
****************************************************************************/

//
// Number of TOP item properties
//

#define NUM_ITEMDEFAULTS        30

LPOLESTR          g_pszItemDefaults[NUM_ITEMDEFAULTS];
PROPID            g_piItemDefaults [NUM_ITEMDEFAULTS];
PROPVARIANT       g_pvItemDefaults [NUM_ITEMDEFAULTS];
PROPSPEC          g_psItemDefaults [NUM_ITEMDEFAULTS];
WIA_PROPERTY_INFO g_wpiItemDefaults[NUM_ITEMDEFAULTS];

#define NUM_COMPRESSIONS 1
LONG g_CompressionArray[NUM_COMPRESSIONS] = { WIA_COMPRESSION_NONE };

#define NUM_DATATYPES 3
LONG g_DataTypeArray[NUM_DATATYPES] = { WIA_DATA_THRESHOLD,
                                        WIA_DATA_GRAYSCALE,
                                        WIA_DATA_COLOR };

#define NUM_INTENTS 6
LONG g_IntentArray[NUM_INTENTS] = { WIA_INTENT_NONE,
                                    WIA_INTENT_IMAGE_TYPE_COLOR,
                                    WIA_INTENT_IMAGE_TYPE_GRAYSCALE,
                                    WIA_INTENT_IMAGE_TYPE_TEXT,
                                    WIA_INTENT_MINIMIZE_SIZE,
                                    WIA_INTENT_MAXIMIZE_QUALITY };
//
// Initial values
//

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

//
//  See the drvGetWiaFormatInfo() in (minidrv.cpp) for the complete
//  list of TYMED/FORMAT pairs.
//

#define NUM_INITIALFORMATS 1
GUID* g_pInitialFormatArray [NUM_INITIALFORMATS] = {(GUID*) &WiaImgFmt_MEMORYBMP };

#define MIN_BUFFER_SIZE 65535

//
// Custom defined properties
//

#define INITIAL_SENSITIVITY 5.0f
#define INITIAL_CORRECTION  122.0f

// Property names should be hardcoded here, not in a resource.
// Property names should not be locallized to different languages.

#define WIA_IPA_SENSITIVITY               101
#define WIA_IPA_SENSITIVITY_STR           L"Sensitivity"
#define WIA_IPA_CORRECTION                102
#define WIA_IPA_CORRECTION_STR            L"Correction"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\testusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TestUsd.Cpp
*
*  VERSION:     2.0
*
*  DATE:        5 Jan, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#define INITGUID

#include "testusd.h"
#include "resource.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.
IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  TestUsdClassFactory
*
\****************************************************************************/

class TestUsdClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    TestUsdClassFactory();
    ~TestUsdClassFactory();
};

/**************************************************************************\
* TestUsdClassFactory::TestUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdClassFactory::TestUsdClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("TestUsdClassFactory::TestUsdClassFactory, (creating)"));
}

/**************************************************************************\
* TestUsdClassFactory::~TestUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdClassFactory::~TestUsdClassFactory(void)
{
    // Destructor logic
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("TestUsdClassFactory::TestUsdClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* TestUsdClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* TestUsdClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* TestUsdClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* TestUsdClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    TestUsdDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new TestUsdDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* TestUsdClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* TestUsdDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* TestUsdDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* TestUsdDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }

            //
            //  Start logging from here.  Mark that DLL was loaded.
            //  This way, we can tell whether the DLL was loaded/unloaded 
            //  without running under a debugger.
            //

            //
            // Create COM Logging Object
            //
            
            hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IWiaLog,(void**)&g_pIWiaLog);
           
            if (SUCCEEDED(hr)) {
//                g_pIWiaLog->InitializeLog((LONG)g_hInst);
                WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("driver Loaded successfully"));                
            } else {
                #ifdef DEBUG
                    OutputDebugString(TEXT("Failed to CoCreateInstance on Logging COM object for wiatscan.dll\n"));
                #endif
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {
                // OutputDebugStringA("TestUsd: Unloaded before all objects releaseed!\n");
            }

            //
            //  Mark that DLL was unloaded, and release logging interface.
            //
            
            if (g_pIWiaLog != NULL) {
                WIAS_LTRACE(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("driver Unloaded successfully"));
                g_pIWiaLog->Release();
            }

            DeleteCriticalSection(&g_csCOM);

            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_TestUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_TestUsd)) {
        TestUsdClassFactory *pcf = new TestUsdClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\testdev\testusd.h ===
/***************************************************************************
 *
 *  TESTUSD.H
 *
 *  Copyright (c) Microsoft Corporation 1996-1999
 *  All rights reserved
 *
 ***************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>
#include <sti.h>
#include <stierr.h>
#include <stiusd.h>

#include "wiamindr.h"

#define DATA_1BIT_SRC_NAME  TEXT("TEST1BT.BMP")   // Data source file name.
#define DATA_8BIT_SRC_NAME  TEXT("TEST8BT.BMP")   // Data source file name.
#define DATA_24BIT_SRC_NAME TEXT("TEST24BT.BMP")  // Data source file name.

// GUID's

#if defined( _WIN32 ) && !defined( _NO_COM)

//  {E9FA3320-7F3F-11D0-90EA-00AA0060F86C}
DEFINE_GUID(CLSID_TestUsd, 0xC3A80960L, 0x28B1, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {61127F40-E1A5-11D0-B454-00A02438AD48}
DEFINE_GUID(guidEventTimeChanged, 0x61127F40L, 0xE1A5, 0x11D0, 0xB4, 0x54, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventSizeChanged, 0x052ED270L, 0x28A3, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventFirstLoaded, 0x052ED270L, 0x28A3, 0x11D3, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

#endif

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//
// Module ref counting
//
extern UINT g_cRefThisDll;
extern UINT g_cLocks;

extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);

extern void DllAddRef(void);
extern void DllRelease(void);

//
// Base class for supporting non-delegating IUnknown for contained objects
//
struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// The the test scanner supports a single scanning context.
#define NUM_DEVICE_ITEM     1

// Device item specific context.
typedef struct _TESTMINIDRIVERITEMCONTEXT{
   LONG     lSize;
   HANDLE   hTestBmp;                           // Handle to data source file.
   HANDLE   hTestBmpMap;                        // Handle to data source file mapping.
   PBYTE    pTestBmp;                           // Pointer to data source file.

   PBYTE    pTestBmpBits;                       // Pointer to image data.
   LONG     lTotalWritten;                      // Total image bytes written.
   LONG     lTestBmpLine;                       // Current test bitmap line.

   // Test image parameters: (Test BMP images)
   LONG     lTestBmpDepth;                      // image data bit depth
   LONG     lTestBmpWidth;                      // image data width (pixels)
   LONG     lTestBmpHeight;                     // image data height (pixels)
   LONG     lTestBmpDir;                        // image data direction (-1 = topdown, 1 = bottomup)
   LONG     lTestBmpBytesPerScanLine;           // image data bytes per scan line
   LONG     lTestBmpLinePad;                    // image data byte per line padding(if out of image data)

   // Scan parameters:
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
} TESTMINIDRIVERITEMCONTEXT, *PTESTMINIDRIVERITEMCONTEXT;

//
// Class definition for object
//

class TestUsdDevice : public IStiUSD,
                      public IWiaMiniDrv,
                      public INonDelegatingUnknown
{
private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.

    // Data source file information.
    TCHAR               m_szSrcDataName[MAX_PATH];  // Path of data source file.
    FILETIME            m_ftLastWriteTime;          // Last time of source data file.
    LARGE_INTEGER       m_dwLastHugeSize;           // Last size of source data file.

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information, one time initialization.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback   *m_pIWiaEventCallback;  // WIA event sink.
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.

    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown 
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //
    //  COM IUnknown Methods
    //

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey);
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps);
    STDMETHOD(GetStatus)(THIS_ PSTI_DEVICE_STATUS pDevStatus);
    STDMETHOD(DeviceReset)(THIS);
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer);
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE EscapeFunction,LPVOID lpInData,DWORD cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError)(THIS_ LPDWORD pdwLastDeviceError);
    STDMETHOD(LockDevice)(THIS);
    STDMETHOD(UnLockDevice)(THIS);
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped);
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped);
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped);
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped);
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent);
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY lpNotify);
    STDMETHOD(GetLastErrorInfo)(THIS_ STI_ERROR_INFO *pLastErrorInfo);

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,       
        LONG        lFlags,              
        BSTR        bstrDeviceID,        
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,         
        IUnknown    *pIUnknownOuter,     
        IWiaDrvItem **ppIDrvItemRoot,    
        IUnknown    **ppIUnknownInner,   
        LONG        *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG        lFlags,        
        LONG        lDevErrVal,    
        LPOLESTR    *ppszDevErrStr,
        LONG        *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext, 
        LONG        lFlags,        
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,       
        PMINIDRV_TRANSFER_CONTEXT pmdtc,        
        LONG                      *plDevErrVal); 

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,       
        LONG        *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,       
        ULONG          nPropSpec,    
        const PROPSPEC *pPropSpec,   
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,       
        PMINIDRV_TRANSFER_CONTEXT pmdtc,        
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,       
        ULONG          nPropSpec,    
        const PROPSPEC *pPropSpec,   
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,       
        LONG        *plDevErrVal); 

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,       
        LONG        *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,       
        LONG        *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,       
        LONG        *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG        lFlags,       
        BYTE        *pSpecContext,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,   
        LONG            ulFlags,         
        LONG            *pcelt,          
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,       
        LONG            *pcelt,       
        WIA_FORMAT_INFO **ppwfi,      
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID  *pEventGUID,     
        BSTR        bstrDeviceID,
        ULONG       ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);

private:

    //
    // Private helper methods
    //

    HRESULT _stdcall BuildItemTree(void);
    HRESULT _stdcall DeleteItemTree(void);

    HRESULT _stdcall ScanItem(PTESTMINIDRIVERITEMCONTEXT,PMINIDRV_TRANSFER_CONTEXT,LONG*);
    HRESULT _stdcall ScanItemCB(PTESTMINIDRIVERITEMCONTEXT,PMINIDRV_TRANSFER_CONTEXT,LONG*);

    HRESULT FillBufferFromFile(
        PBYTE                       pBuffer,
        LONG                        lLength,
        PLONG                       pReceived,
        PTESTMINIDRIVERITEMCONTEXT  pItemContext);

    HRESULT FillBufferWithTestPattern(
        PBYTE                       pBuffer,
        LONG                        lLength,
        PLONG                       pReceived,
        PTESTMINIDRIVERITEMCONTEXT  pItemContext,
        PMINIDRV_TRANSFER_CONTEXT   pmtc);

    HRESULT SetSrcBmp(BYTE *pWiasContext);
    HRESULT OpenTestBmp(GUID guidFormatID, PTESTMINIDRIVERITEMCONTEXT pItemContext);
    HRESULT CloseTestBmp(PTESTMINIDRIVERITEMCONTEXT pItemContext);

    HRESULT Scan(
        GUID                        guidFormatID,
        LONG                        iPhase,
        PBYTE                       pBuffer,
        LONG                        Length,
        PLONG                       pReceived,
        PTESTMINIDRIVERITEMCONTEXT  pItemContext,
        PMINIDRV_TRANSFER_CONTEXT   pmtc);

    LONG ReadFromScanner(BYTE* pBuffer, DWORD Length, LONG TermChar);
    LONG WriteToScanner (BYTE* pBuffer, DWORD Length);    

    // Validation helpers found in validate.cpp
    HRESULT CheckDataType(BYTE *pWiasContext, WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckIntent  (BYTE *pWiasContext, WIA_PROPERTY_CONTEXT *pContext);
    //HRESULT CheckTymed   (BYTE *pWiasContext, WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckPreferredFormat (BYTE *pWiasContext, WIA_PROPERTY_CONTEXT *pContext);
    
    HRESULT UpdateValidDepth(BYTE *pWiasContext, LONG lDataType, LONG *lDepth);
    HRESULT GetBSTRResourceString(LONG lLocalResourceID, BSTR *pBSTR, BOOL bLocal);
    HRESULT GetOLESTRResourceString(LONG lLocalResourceID, LPOLESTR *ppsz, BOOL bLocal);
    HRESULT BuildRootItemProperties();
    HRESULT BuildTopItemProperties();
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();

public:
    TestUsdDevice(LPUNKNOWN punkOuter);
    ~TestUsdDevice();

    VOID RunNotifications(VOID);
    BOOL IsChangeDetected(GUID *pguidEvent);
};

typedef TestUsdDevice *PTestUsdDevice;

//
// Syncronization mechanisms
//

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\unimcro\mcromgr.cpp ===
#include "mcromgr.h"

extern VOID Trace(LPCTSTR format,...);

CMicroDriver::CMicroDriver(HANDLE hDevice, PSCANINFO pScanInfo)
{
    m_hDevice     = hDevice;
    m_pScanInfo   = pScanInfo;
    m_DeviceState = STARTUP_STATE;
}

CMicroDriver::~CMicroDriver()
{

}

HRESULT CMicroDriver::_Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived)
{
    return E_FAIL;
}

HRESULT CMicroDriver::InitializeScanner()
{
    HRESULT hr = E_FAIL;
    return hr;
}

HRESULT CMicroDriver::InitScannerDefaults(PSCANINFO pScanInfo)
{
    HRESULT hr = E_FAIL;

    pScanInfo->ADF                    = 0;
    pScanInfo->TPA                    = 0;
    pScanInfo->Endorser               = 0;
    pScanInfo->RawDataFormat          = WIA_PACKED_PIXEL;
    pScanInfo->RawPixelOrder          = WIA_ORDER_BGR;
    pScanInfo->bNeedDataAlignment     = TRUE;
    pScanInfo->SupportedCompressionType = 0;
    pScanInfo->SupportedDataTypes     = SUPPORT_BW|SUPPORT_GRAYSCALE|SUPPORT_COLOR;

    LONG WidthPixels        = 0;
    LONG HeightPixels       = 0;
    LONG CurrentXResolution = 300;
    LONG CurrentYResolution = 300;

    //InquireNumber(SL_PIXELS_PER_LINE, SL_HI, &WidthPixels);
    //InquireNumber(SL_LINES_PER_SCAN, SL_HI, &HeightPixels);
    //InquireNumber(SL_X_RESOLUTION, SL_NOM, &XRes);
    //InquireNumber(SL_Y_RESOLUTION, SL_NOM, &YRes);

    pScanInfo->BedWidth               = 8500;  //(WidthPixels  * 1000) / CurrentXResolution;  // 1000's of an inch (WIA compatible unit)
    pScanInfo->BedHeight              = 11693; //(HeightPixels * 1000) / CurrentYResolution;  // 1000's of an inch (WIA compatible unit)

    pScanInfo->OpticalXResolution     = 300;
    pScanInfo->OpticalYResolution     = 300;

    pScanInfo->IntensityRange.lMin    = -127;
    pScanInfo->IntensityRange.lMax    =  127;
    pScanInfo->IntensityRange.lStep   = 1;

    pScanInfo->ContrastRange.lMin     = -127;
    pScanInfo->ContrastRange.lMax     = 127;
    pScanInfo->ContrastRange.lStep    = 1;

    /*pScanInfo->ResolutionRange.lMin   = 12;
    pScanInfo->ResolutionRange.lMax   = 1200;
    pScanInfo->ResolutionRange.lStep  = 1;
    */

    // Scanner settings
    pScanInfo->Intensity              = 32;
    pScanInfo->Contrast               = 12;

    pScanInfo->Xresolution            = CurrentXResolution;
    pScanInfo->Yresolution            = CurrentYResolution;

    pScanInfo->Window.xPos            = 0;
    pScanInfo->Window.yPos            = 0;
    pScanInfo->Window.xExtent         = (pScanInfo->Xresolution * pScanInfo->BedWidth)/1000;
    pScanInfo->Window.yExtent         = (pScanInfo->Yresolution * pScanInfo->BedHeight)/1000;

    // Scanner options
    pScanInfo->DitherPattern          = 0;
    pScanInfo->Negative               = 0;
    pScanInfo->Mirror                 = 0;
    pScanInfo->AutoBack               = 0;
    pScanInfo->ColorDitherPattern     = 0;
    pScanInfo->ToneMap                = 0;
    pScanInfo->Compression            = 0;

        // Image Info
    pScanInfo->DataType               = WIA_DATA_GRAYSCALE;
    pScanInfo->WidthPixels            = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos);

    switch(pScanInfo->DataType) {
    case WIA_DATA_THRESHOLD:
        pScanInfo->PixelBits = 1;
        break;
    case WIA_DATA_COLOR:
        pScanInfo->PixelBits = 24;
        break;
    case WIA_DATA_GRAYSCALE:
    default:
        pScanInfo->PixelBits = 8;
        break;
    }

    pScanInfo->WidthBytes = pScanInfo->Window.xExtent * (pScanInfo->PixelBits/8);
    pScanInfo->Lines      = pScanInfo->Window.yExtent;

    hr = S_OK;

    return hr;
}

HRESULT CMicroDriver::SetScannerSettings(PSCANINFO pScanInfo)
{
    HRESULT hr = E_FAIL;

    if(pScanInfo->DataType == WIA_DATA_THRESHOLD) {
        pScanInfo->PixelBits  = 1;
        pScanInfo->WidthBytes = (pScanInfo->Window.xExtent) * (pScanInfo->PixelBits/7);
    }
    else if(pScanInfo->DataType == WIA_DATA_GRAYSCALE) {
        pScanInfo->PixelBits  = 8;
        pScanInfo->WidthBytes = (pScanInfo->Window.xExtent) * (pScanInfo->PixelBits/7);
    }
    else {
        pScanInfo->PixelBits  = 24;
        pScanInfo->WidthBytes = (pScanInfo->Window.xExtent) * (pScanInfo->PixelBits/7);
    }

#ifdef DEBUG
    Trace(TEXT("ScanInfo"));
    Trace(TEXT("x res = %d"),pScanInfo->Xresolution);
    Trace(TEXT("y res = %d"),pScanInfo->Yresolution);
    Trace(TEXT("bpp   = %d"),pScanInfo->PixelBits);
    Trace(TEXT("xpos  = %d"),pScanInfo->Window.xPos);
    Trace(TEXT("ypos  = %d"),pScanInfo->Window.yPos);
    Trace(TEXT("xext  = %d"),pScanInfo->Window.xExtent);
    Trace(TEXT("yext  = %d"),pScanInfo->Window.yExtent);
#endif

    //
    // send values to scanner
    //

    return hr;
}

HRESULT CMicroDriver::CheckButtonStatus(PVAL pValue)
{
    HRESULT hr = E_FAIL;

    /*
    BYTE    ReadBuffer[100];
    ZeroMemory( ReadBuffer, sizeof( ReadBuffer ));

    GetButtonPress(ReadBuffer);

    switch (ReadBuffer[8]) {
    case '1':
        pValue->pGuid = (GUID*) &guidScanButton;
        Trace(TEXT("Scan Button Pressed!"));
        break;
    default:
        pValue->pGuid = (GUID*) &GUID_NULL;
        break;
    }
    */

    return hr;
}

HRESULT CMicroDriver::GetInterruptEvent(PVAL pValue)
{
    HRESULT hr = E_FAIL;
    return hr;
}

HRESULT CMicroDriver::GetButtonCount()
{
    HRESULT hr = E_FAIL;
    return hr;
}

HRESULT CMicroDriver::ErrorToMicroError(LONG lError)
{
    HRESULT hr = E_FAIL;

    switch (lError) {
    case 0:
    default:
        break;
    }
    return E_FAIL;


    return hr;
}

HANDLE CMicroDriver::GetID()
{
    return m_hDevice;
}

LONG CMicroDriver::CurState()
{
    return m_DeviceState;
}

LONG CMicroDriver::NextState()
{
    switch (m_DeviceState) {
    case STARTUP_STATE:
        m_DeviceState = DEVICE_INIT_STATE;
        break;
    case DEVICE_INIT_STATE:
        m_DeviceState = WRITE_STATE;
        break;
    case WRITE_STATE:
        m_DeviceState = VERIFY_STATE;
        break;
    case VERIFY_STATE:
    case ACQUIRE_STATE:
    default:
        m_DeviceState = ACQUIRE_STATE;
        break;
    }
    return m_DeviceState;
}

LONG CMicroDriver::PrevState()
{
    switch (m_DeviceState) {
    case STARTUP_STATE:
    case DEVICE_INIT_STATE:
        m_DeviceState = STARTUP_STATE;
        break;
    case WRITE_STATE:
        m_DeviceState = DEVICE_INIT_STATE;
        break;
    case VERIFY_STATE:
        m_DeviceState = WRITE_STATE;
        break;
    case ACQUIRE_STATE:
    default:
        m_DeviceState = VERIFY_STATE;
        break;
    }
    return m_DeviceState;
}

LONG CMicroDriver::SetState(LONG NewDeviceState)
{
    if(NewDeviceState < STARTUP_STATE)
        m_DeviceState = STARTUP_STATE;

    else if (NewDeviceState > ACQUIRE_STATE)
        m_DeviceState = ACQUIRE_STATE;
    else
        m_DeviceState = NewDeviceState;

    return m_DeviceState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\unimcro\unimcro.h ===
#ifndef UNIMCRO
#define UNIMCRO

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include "wiamicro.h"
#include <sti.h>
#include <math.h>
#include <usbscan.h>
//#include <winioctl.h>

#ifdef DEBUG
#include <stdio.h>
#endif

HRESULT GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal);
HRESULT ParseGSD(LPSTR szGSDName, void *pIOBlock);

#define INITGUID

//
// Button GUIDS
//

DEFINE_GUID( guidScanButton, 0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID( guidCopyButton, 0xb38e1061, 0x65ab, 0x11d1, 0xa4, 0x3b, 0x8, 0x0, 0x9,  0xee, 0xbd, 0xf6);
DEFINE_GUID( guidEMailButton,0x8efdf2c0, 0x7260, 0x11d2, 0xa7, 0xc5, 0x8, 0x0, 0x9,  0xc0, 0x94, 0x24);
DEFINE_GUID( guidFaxButton,  0x8efdf2c1, 0x7260, 0x11d2, 0xa7, 0xc5, 0x8, 0x0, 0x9,  0xc0, 0x94, 0x24);
DEFINE_GUID( guidDocMgmtButton, 0x8efdf2c2, 0x7260, 0x11d2, 0xa7, 0xc5, 0x8, 0x0, 0x9,  0xc0, 0x94, 0x24);

#undef INITGUID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\unimcro\unimcro.cpp ===
#include "unimcro.h"
#include "mcromgr.h"
#include "resource.h"

//#define BUTTON_SUPPORT // (enable/disable button support)

#ifdef DEBUG
    #define _DEBUG_POLL
#endif

#define MAX_BUTTONS 1
#define MAX_BUTTON_NAME 255

HINSTANCE g_hInst;
CGSDList  g_GSDList;

BOOL APIENTRY DllEntryPoint(HMODULE hModule, DWORD dwreason, LPVOID lpReserved)
{
    g_hInst = (HINSTANCE)hModule;
    switch(dwreason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

WIAMICRO_API HRESULT MicroEntry(LONG lCommand, PVAL pValue)
{
    HRESULT hr           = E_NOTIMPL;
    PGSD    pGSD         = NULL;

    if(NULL == pValue->pScanInfo) {
        return E_INVALIDARG;
    }

    switch(lCommand) {
    case CMD_SETGSDNAME:
        Trace(TEXT("Command: CMD_SETGSDNAME"));
        hr = E_FAIL;

        Trace(TEXT("GSD name:             %s"),pValue->szVal);
        Trace(TEXT("GSD Device Handle ID: %d"),pValue->handle);

        GSD NewGSD;

        //
        // create new MicroDriver Object
        //

        NewGSD.pMicroDriver = new CMicroDriver(pValue->handle ,pValue->pScanInfo);

        if (NULL != NewGSD.pMicroDriver) {

            //
            // Initialize MicroDriver object with I/O Block Info
            //

            hr = ParseGSD(pValue->szVal,NewGSD.pMicroDriver->pIOBlock);
            if (SUCCEEDED(hr)) {

                // NewGSD.pMicroDriver->...?

                //
                // insert GSD into list
                //

                g_GSDList.Insert(&NewGSD);

            } else {
                Trace(TEXT("Parsing of GSD File: %s failed..."),pValue->szVal);
            }

            //
            // delete unneeded pointers
            //

            delete NewGSD.pMicroDriver;
            NewGSD.pMicroDriver = NULL;

        } else {
            Trace(TEXT("Failed to Allocate memory for CMicroDriver pointer!!!"));
        }
        break;
    case CMD_INITIALIZE:
        Trace(TEXT("Command: CMD_INITIALIZE"));
        Trace(TEXT("Raw       Data Channel Handle  = %d"),pValue->pScanInfo->DeviceIOHandles[0]);
        Trace(TEXT("Settings  Data Channel Handle  = %d"),pValue->pScanInfo->DeviceIOHandles[1]);
        Trace(TEXT("Status    Data Channel Handle  = %d"),pValue->pScanInfo->DeviceIOHandles[2]);
        Trace(TEXT("Pollng    Data Channel Handle  = %d"),pValue->pScanInfo->DeviceIOHandles[3]);
        Trace(TEXT("Interrupt Data Channel Handle  = %d"),pValue->pScanInfo->DeviceIOHandles[4]);

        pGSD = g_GSDList.GetGSDPtr(pValue->pScanInfo->DeviceIOHandles[0]);
        if(NULL != pGSD) {
            hr = pGSD->pMicroDriver->InitScannerDefaults(pValue->pScanInfo);
        } else {
            hr = E_FAIL;
        }

        break;
    case CMD_UNINITIALIZE:
        Trace(TEXT("Command: CMD_UNINITIALIZE"));

        g_GSDList.RemoveGSD(pValue->pScanInfo->DeviceIOHandles[0]);

        //
        // close/unload libraries
        //

        hr = S_OK;
        break;
    case CMD_RESETSCANNER:
        Trace(TEXT("Command: CMD_RESETSCANNER"));

        //
        // reset scanner
        //

        pGSD = g_GSDList.GetGSDPtr(pValue->pScanInfo->DeviceIOHandles[0]);
        if(NULL != pGSD) {
            hr = pGSD->pMicroDriver->InitScannerDefaults(pValue->pScanInfo);
        } else {
            hr = E_FAIL;
        }

        hr = S_OK;
        break;
    case CMD_STI_DIAGNOSTIC:
        Trace(TEXT("Command: CMD_STI_DIAGNOSTIC"));
        hr = S_OK;
        break;
    case CMD_STI_DEVICERESET:
        Trace(TEXT("Command: CMD_STI_DEVICERESET"));
        hr = S_OK;
        break;
    case CMD_STI_GETSTATUS:
#ifdef _DEBUG_POLL
        Trace(TEXT("Command: CMD_STI_GETSTATUS"));
#endif

        //
        // set status flag to ON-LINE
        //

        pValue->lVal  = MCRO_STATUS_OK;
        pValue->pGuid = (GUID*) &GUID_NULL;

        //
        // button polling
        //

#ifdef BUTTON_SUPPORT
        pGSD = g_GSDList.GetGSDPtr(pValue->pScanInfo->DeviceIOHandles[0]);
        if(NULL != pGSD) {
            hr = pGSD->pMicroDriver->CheckButtonStatus(pValue);
        } else {
            hr = E_FAIL;
        }
#endif
        hr = S_OK;
        break;
    case CMD_SETXRESOLUTION:
        Trace(TEXT("Command: CMD_SETXRESOLUTION"));
        pValue->pScanInfo->Xresolution = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETYRESOLUTION:
        Trace(TEXT("Command: CMD_SETYRESOLUTION"));
        pValue->pScanInfo->Yresolution = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETCONTRAST:
        Trace(TEXT("Command: CMD_SETCONTRAST"));
        pValue->pScanInfo->Contrast    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETINTENSITY:
        Trace(TEXT("Command: CMD_SETINTENSITY"));
        pValue->pScanInfo->Intensity   = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETDATATYPE:
        Trace(TEXT("Command: CMD_SETDATATYPE"));
        pValue->pScanInfo->DataType    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETMIRROR:
        Trace(TEXT("Command: CMD_SETMIRROR"));
        pValue->pScanInfo->Mirror      = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETNEGATIVE:
        Trace(TEXT("Command: CMD_SETNEGATIVE"));
        pValue->pScanInfo->Negative    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_GETADFAVAILABLE:
        Trace(TEXT("Command: CMD_GETADFAVAILABLE"));
        break;
    case CMD_GETADFSTATUS:
        Trace(TEXT("Command: CMD_GETADFSTATUS"));
        break;
    case CMD_GETADFREADY:
        Trace(TEXT("Command: CMD_GETADFREADY"));
        break;
    case CMD_GETADFHASPAPER:
        Trace(TEXT("Command: CMD_GETADFHASPAPER"));
        break;
    case CMD_GET_INTERRUPT_EVENT:
        Trace(TEXT("Command: CMD_GET_INTERRUPT_EVENT"));
        break;
    case CMD_GETCAPABILITIES:
        Trace(TEXT("Command: CMD_GETCAPABILITIES"));

#ifdef BUTTON_SUPPORT

        Trace(TEXT("*** THIS SHOULD NOT BE CALLED AT THIS TIME!!! ***"));

        //
        // old globals pasted from above
        //
        // GUID      g_Buttons[MAX_BUTTONS] ={{0xa6c5a715, 0x8c6e, 0x11d2,{ 0x97, 0x7a,  0x0,  0x0, 0xf8, 0x7a, 0x92, 0x6f}}};
        // BOOL      g_bButtonNamesCreated = FALSE;
        // WCHAR*    g_ButtonNames[MAX_BUTTONS];


        //
        // return Number of buttons supported, and
        // array pointer to Button GUID array
        //

        pValue->lVal          = GetButtonCount(pValue->pScanInfo);
        pValue->pGuid         = g_Buttons;
        pValue->ppButtonNames = g_ButtonNames;

        hr = S_OK;
#endif

        break;
    default:
        Trace(TEXT("Command: UNKNOWN (%d)"),lCommand);
        break;
    }
    return hr;
}

WIAMICRO_API HRESULT GetScanInfo(PSCANINFO pScanInfo)
{
    Trace(TEXT("Export: GetScanInfo(pScanInfo = %p)"),pScanInfo);

    //
    // clean Scan info structure
    //

    ZeroMemory(pScanInfo,sizeof(SCANINFO));
    CopyMemory(pScanInfo,pScanInfo,sizeof(SCANINFO));

    return S_OK;
}

WIAMICRO_API HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived)
{

    PGSD pGSD  = NULL;
    HRESULT hr = E_FAIL;

    if(NULL == pScanInfo) {
        return E_INVALIDARG;
    }

    switch (lPhase) {
    case SCAN_FIRST:

        pGSD = g_GSDList.GetGSDPtr(pScanInfo->DeviceIOHandles[0]);
        if(NULL != pGSD) {
            hr = pGSD->pMicroDriver->SetScannerSettings(pScanInfo);
        } else {
            hr = E_FAIL;
        }

        Trace(TEXT("SCAN_FIRST, Requesting %d ------"),lLength);

    case SCAN_NEXT: // SCAN_FIRST will fall through to SCAN_NEXT (because it is expecting data)

        if(lPhase == SCAN_NEXT)
            Trace(TEXT("SCAN_NEXT, Requesting %d ------"),lLength);
        break;
    case SCAN_FINISHED:
    default:
        Trace(TEXT("SCAN_FINISHED"));
        break;
    }
    return hr;
}

WIAMICRO_API HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent)
{
    Trace(TEXT("Export: SetPixelWindow(pScanInfo = %p, x = %d, y = %d, xExtent = %d, yExtent = %d)"),
          pScanInfo,
          x,
          y,
          xExtent,
          yExtent);

    if(pScanInfo != NULL) {
        pScanInfo = pScanInfo;
    } else {
        return E_INVALIDARG;
    }

    pScanInfo->Window.xPos    = x;
    pScanInfo->Window.yPos    = y;
    pScanInfo->Window.xExtent = xExtent;
    pScanInfo->Window.yExtent = yExtent;
    return S_OK;
}

HRESULT ParseGSD(LPSTR szGSDName, void *pIOBlock)
{
    Trace(TEXT("unimcro helper: ParseGSD(szGSDName = %s, pIOBlock = %p)"),szGSDName, pIOBlock);
    return E_FAIL;
}

VOID Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}

HRESULT GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        HINSTANCE hInst = NULL;
        INT NumTCHARs = LoadString(g_hInst,lResourceID,szStringValue,sizeof(szStringValue));
        DWORD dwError = GetLastError();

#ifdef UNICODE
        Trace(TEXT("NumTCHARs = %d dwError = %d Resource ID = %d (UNICODE)szString = %ws"),
              NumTCHARs,
              dwError,
              lResourceID,
              szStringValue);
#else
        Trace(TEXT("NumTCHARs = %d dwError = %d Resource ID = %d (ANSI)szString = %s"),
              NumTCHARs,
              dwError,
              lResourceID,
              szStringValue);
#endif

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           sizeof(wszStringValue));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\unimcro\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by unimcro.rc
//

#define IDS_SCAN_BUTTON_NAME  700
#define IDS_COPY_BUTTON_NAME  701
#define IDS_FAX_BUTTON_NAME   702
#define IDS_EMAIL_BUTTON_NAME 703
#define IDS_DOC_BUTTON_NAME   704

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        705
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           705
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\unimcro\sources.inc ===
# ############################################################
#
#Copyright (c) 1999  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   3-Mar-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#       Epson Micro Driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=unimcro
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

DLLDEF = ..\unimcro.def
DLLENTRY=_DllMainCRTStartup
COFFBASE=usermode

INCLUDES= $(INCLUDES)           \
          $(PROJECT_ROOT)\wia\drivers\scanner\microdrv\inc;

TARGETLIBS= $(TARGETLIBS)


SOURCES= \
    ..\unimcro.cpp \
    ..\mcromgr.cpp \
    ..\unimcro.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\cdibutil.h ===
#ifndef _CDIBUTIL
#define _CDIBUTIL

class CDIBUtil {
public:        
    CDIBUtil();
    ~CDIBUtil();

    BOOL SetupBmpHeader(BITMAPINFOHEADER *pbiHeader, int width, int height, int bits, BOOL TopDown, int Resolution)
    {
        BOOL bSuccess = TRUE;
        int WidthBytes              = 0;        
        pbiHeader->biSize           = sizeof(BITMAPINFOHEADER);
        pbiHeader->biWidth          = width;
        pbiHeader->biHeight         = height * ((TopDown==TRUE)?-1:1);
        pbiHeader->biPlanes         = 1;
        pbiHeader->biBitCount       = (BYTE)bits;
        pbiHeader->biCompression    = 0;
        pbiHeader->biXPelsPerMeter  = int(Resolution * 39.37);
        pbiHeader->biYPelsPerMeter  = int(Resolution * 39.37);
        pbiHeader->biClrUsed        = 0;
        pbiHeader->biClrImportant   = 0;
        switch (bits) {
        case 1:
            WidthBytes = (width+7)/8;
            pbiHeader->biClrUsed    = 2;
            break;
        case 8:
            WidthBytes = width;
            pbiHeader->biClrUsed    = 256;
            break;
        case 24:
            WidthBytes = width*3;
            pbiHeader->biClrUsed    = 0;
            break;
        default:
            WidthBytes = 0;
            bSuccess = FALSE;
            break;
        }
    
        pbiHeader->biSizeImage = WidthToDIBWidth(WidthBytes)*height; // not used for compression
        return bSuccess;
    }

    void FillPalette (int NumPaletteEntries, tagRGBQUAD* pPal)
    {        
        if (NumPaletteEntries>1) {
            for (int i=0; i<NumPaletteEntries; i++) {
                int Val             = i*255/(NumPaletteEntries-1);
                pPal->rgbRed        = (BYTE)Val;
                pPal->rgbGreen      = (BYTE)Val;
                pPal->rgbBlue       = (BYTE)Val;
                pPal->rgbReserved   = 0;
                pPal++;
            }
        }
    }

    void FillLogPalette (int NumPaletteEntries, LOGPALETTE* pPal)
    {
        if (NumPaletteEntries>2) {
            for (int i=0; i<NumPaletteEntries; i++) {    
                pPal->palPalEntry[i].peRed   = (BYTE)i;
                pPal->palPalEntry[i].peGreen = (BYTE)i;
                pPal->palPalEntry[i].peBlue  = (BYTE)i;
                pPal->palPalEntry[i].peFlags = 0;
            }
        } else { // B/W Palette
            pPal->palPalEntry[0].peRed   = (BYTE)255;
            pPal->palPalEntry[0].peGreen = (BYTE)255;
            pPal->palPalEntry[0].peBlue  = (BYTE)255;
            pPal->palPalEntry[0].peFlags = 0;
            pPal->palPalEntry[1].peRed   = (BYTE)0;
            pPal->palPalEntry[1].peGreen = (BYTE)0;
            pPal->palPalEntry[1].peBlue  = (BYTE)0;
            pPal->palPalEntry[1].peFlags = 0;
        }
    }

    BOOL RawColorToDIB(int BitsPerPixel, BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = FALSE;
        switch (BitsPerPixel) {
        case 1:
            bSuccess = RawColorToBinaryDIB (pDest, pSrc, Width, Height);
            break;
        case 8:
            bSuccess = RawColorToGrayDIB (pDest, pSrc, Width, Height);
            break;
        case 24:
            bSuccess = RawColorToColorDIB(pDest, pSrc, Width, Height);
            break;
        default:
            break;
        }
        return bSuccess;
    }

    BOOL RawColorToBinaryDIB(BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = TRUE;
        BYTE* ptDest = NULL;
        BYTE* ptSrc  = NULL;
        
        int BitIdx    = 0;    
        BYTE Bits     = 0;
        BYTE GrayByte = 0;
    
        for (int i=0; i < Height; i++) {
            ptDest = pDest + (i*WidthToDIBWidth((Width+7)/8));
            ptSrc  = pSrc + i*Width*3;
            BitIdx = 0;
            Bits   = 0;
            for (int j=0; j < Width; j++) {
                GrayByte = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
                Bits *= 2;
                if (GrayByte > 128) Bits +=  1;
                BitIdx++;
                if (BitIdx >= 8) {
                    BitIdx = 0;
                    *ptDest++ = Bits;
                }
                ptSrc += 3;
            }
            // Write out the last byte if matters
            if (BitIdx)
                *ptDest = Bits;
        }
        return bSuccess;
    }

    BOOL RawColorToGrayDIB(BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = TRUE;
        BYTE* ptDest = NULL;
        BYTE* ptSrc  = NULL;
        
        for (int i=0; i<Height; i++) {
            ptDest = pDest + (i*WidthToDIBWidth(Width));
            ptSrc = pSrc + i*Width*3;
            for (int j=0; j<Width; j++) {
                *ptDest++ = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
                ptSrc += 3;
            }
        }
        return bSuccess;
    }

    BOOL RawColorToColorDIB(BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = TRUE;
        BYTE* ptDest = NULL;
        BYTE* ptSrc  = NULL;
        
        for (int i=0; i<Height; i++) {
            ptDest = pDest + (i*WidthToDIBWidth(Width*3));
            ptSrc = pSrc + i*Width*3;
            memcpy (ptDest, ptSrc, Width*3);
        }
        return bSuccess;
    }

    int  WidthToDIBWidth(int Width)
    {
        return (Width+3)&0xfffffffc;
    }
    
    BOOL WriteDIBToBMP(LPTSTR strFileName, HANDLE hDIB, int nNumPaletteEntries)
    {
        return FALSE;   // force exit for now.
        BOOL bSuccess = FALSE;
    
        // lock memory
        BYTE* pDIB = (BYTE*)GlobalLock(hDIB);
        if (pDIB) {
            LPBITMAPINFO pBitmap = (LPBITMAPINFO)pDIB;
            
            // write BMP file header
            BITMAPFILEHEADER bmfHeader;
            bmfHeader.bfType      = 0x4d42;
            bmfHeader.bfReserved1 = bmfHeader.bfReserved2 = 0;
            bmfHeader.bfSize      = pBitmap->bmiHeader.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*nNumPaletteEntries;
            bmfHeader.bfOffBits   = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*nNumPaletteEntries;
    
            
            // write to disk
            // Write(&bmfHeader,sizeof(BITMAPFILEHEADER));
            // Write(pDIB,sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*nNumPaletteEntries+pBitmap->bmiHeader.biSizeImage);
            
            // unlock memory
            GlobalUnlock(hDIB);
            bSuccess = TRUE;
        }
    
        return bSuccess;
    }

    void GrayTo24bitColorDIB(BYTE* pSrc,  int WidthPixels, int Height)
    {
        BYTE* pTemp = NULL;
        DWORD dwSizeBits = (WidthPixels * Height);
        pTemp = (BYTE*)GlobalAlloc(GPTR,dwSizeBits + 1024);
        if (pTemp) {    
            CopyMemory(pTemp,pSrc,dwSizeBits);                
            DWORD MemIndex = 0;
            DWORD SrcIndex = 0;
            while (MemIndex <= dwSizeBits) {
                for (int i = 0;i<=2;i++) {
                    pSrc[SrcIndex] = pTemp[MemIndex];
                    SrcIndex++;
                }
                MemIndex++;
            }    
            GlobalFree(pTemp);
        }
    }
    
private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\cmicro.cpp ===
#include "pch.h"

CMICRO::CMICRO(TCHAR *pszMicroDriver)
{
    m_hModule         = NULL;
    m_pMicroEntry     = NULL;
    m_pScan           = NULL;
    m_pSetPixelWindow = NULL;
    m_bDisabled       = FALSE;

    //
    // Load Micro driver
    //

    m_hModule = LoadLibrary(pszMicroDriver);
    if (m_hModule != NULL) {

        //
        // Get entry point
        //

        m_pMicroEntry = (FPMICROENTRY)GetProcAddress(m_hModule,"MicroEntry");

        if (m_pMicroEntry != NULL) {

            //
            // Get Scan entry point
            //

            m_pScan = (FPSCANENTRY)GetProcAddress(m_hModule,"Scan");

            if (m_pScan != NULL) {

                //
                // Get SetPixelWindow entry point
                //

                m_pSetPixelWindow = (FPSETPIXELWINDOWENTRY)GetProcAddress(m_hModule,"SetPixelWindow");

                if (m_pSetPixelWindow != NULL) {

                    //
                    // we are GO!
                    //

                }

            }

        }

    }
}

CMICRO::~CMICRO()
{
    if (m_hModule != NULL) {
        FreeLibrary(m_hModule);
    }
}

HRESULT CMICRO::MicroEntry(LONG lCommand, PVAL pValue)
{
    HRESULT hr = E_FAIL;
    if (m_pMicroEntry != NULL) {

        //
        // call Micro driver's entry point
        //

        hr =  m_pMicroEntry(lCommand, pValue);
    }
    return hr;
}

HRESULT CMICRO::Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, PLONG plRecieved)
{
    HRESULT hr = E_FAIL;
    if (m_pMicroEntry != NULL) {

        if (!m_bDisabled) {
            //
            // call Micro driver's scan entry point
            //

            hr =  m_pScan(pScanInfo, lPhase, pBuffer, lLength, plRecieved);
        } else {
            UnInitialize(pScanInfo);
        }
    }
    return hr;
}

HRESULT CMICRO::SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent)
{
    HRESULT hr = E_FAIL;
    if (m_pSetPixelWindow != NULL) {

        //
        // call Micro driver's SetPixelWindow entry point
        //

        hr =  m_pSetPixelWindow(pScanInfo,x,y,xExtent,yExtent);
    }
    return hr;
}

HRESULT CMICRO::Disable()
{
    HRESULT hr = S_OK;

    m_bDisabled = TRUE;
    return hr;
}

HRESULT CMICRO::UnInitialize(PSCANINFO pScanInfo)
{
    HRESULT hr = E_FAIL;

    if ((m_pMicroEntry != NULL)) {
        //
        // call Micro driver's entry point to UnInitalize
        //

        VAL Val;

        memset(&Val, 0, sizeof(Val));
        Val.pScanInfo = pScanInfo;
        hr = m_pMicroEntry(CMD_UNINITIALIZE,&Val);
        m_pMicroEntry = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\unimcro\mcromgr.h ===
#ifndef _MCROMGR
#define _MCROMGR

#include <windows.h>
#include "wiamicro.h"

#define STARTUP_STATE      1 // pre startup state (uninitialized)
#define DEVICE_INIT_STATE  2 // initialization state
#define WRITE_STATE        3 // write settings state
#define VERIFY_STATE       4 // verify settings state
#define ACQUIRE_STATE      5 // data acquire state

#define DEVICE_STATE LONG;

class CMicroDriver {
public:
    CMicroDriver(HANDLE hDevice, PSCANINFO pScanInfo);
    ~CMicroDriver();
    HRESULT _Scan(PSCANINFO pScanInfo,
                 LONG  lPhase,
                 PBYTE pBuffer,
                 LONG  lLength,
                 LONG *plReceived);

    HRESULT InitializeScanner();
    HRESULT InitScannerDefaults(PSCANINFO pScanInfo);
    HRESULT SetScannerSettings(PSCANINFO pScanInfo);
    HRESULT CheckButtonStatus(PVAL pValue);
    HRESULT GetInterruptEvent(PVAL pValue);
    HRESULT GetButtonCount();
    HRESULT ErrorToMicroError(LONG lError);
    HANDLE  GetID();
    LONG    CurState();
    LONG    NextState();
    LONG    PrevState();
    LONG    SetState(LONG NewDeviceState);

    void *pIOBlock;

private:
    HANDLE       m_hDevice;
    PSCANINFO    m_pScanInfo;
    LONG         m_DeviceState;

protected:

};

typedef struct _GSD {
    CMicroDriver *pMicroDriver;
    _GSD         *pNext;
} GSD, *PGSD;


#define GSD_LIST_INSERT_FRONT   100
#define GSD_LIST_INSERT_REAR    101

class CGSDList {
public:

    CGSDList() {
        m_pHead  = NULL;
    }

    ~CGSDList() {
        KillList();
    }

    VOID KillList() {
        PGSD pCur  = m_pHead;
        PGSD pTemp = NULL;
        while(pCur != NULL){
            pTemp = pCur;
            pCur  = pCur->pNext;
            if(pTemp){
                if(pTemp->pMicroDriver){
                    delete pTemp->pMicroDriver;
                    pTemp->pMicroDriver = NULL;
                }
                delete pTemp;
                pTemp = NULL;
            }
        }
        m_pHead = NULL;
    }

    VOID Insert(PGSD pGSD, LONG lFlag = GSD_LIST_INSERT_FRONT) {
        pGSD->pNext  = NULL;
        PGSD pNewGSD = new GSD;
        memcpy(pNewGSD, pGSD, sizeof(GSD));

        switch(lFlag) {
        case GSD_LIST_INSERT_FRONT:
        default:
            {
                if(NULL == m_pHead){
                    m_pHead        = pNewGSD;
                    m_pHead->pNext = NULL;
                    break;
                } else {
                    pNewGSD->pNext = m_pHead;
                    m_pHead        = pNewGSD;
                }
            }
            break;
        }
    }

    PGSD GetGSDPtr(HANDLE hDevice) {
        PGSD pCur     = m_pHead;

        while(pCur != NULL) {
            if(hDevice != pCur->pMicroDriver->GetID()){
                pCur = pCur->pNext;
            } else {
                return pCur;
            }
        }
        return NULL;
    }

    VOID RemoveGSD(HANDLE hDevice) {
        PGSD pDeadGSD = NULL;
        PGSD pCur     = m_pHead->pNext;
        PGSD pTrailer = m_pHead;

        // check the trailer, and move 'em out..
        if(hDevice == pTrailer->pMicroDriver->GetID()){
            pDeadGSD = pTrailer;
            m_pHead  = pTrailer->pNext;
            delete pDeadGSD;
        }

        // check current, and continue
        while(pCur != NULL) {
            if(hDevice != pCur->pMicroDriver->GetID()){
                pCur     = pCur->pNext;
                pTrailer = pTrailer->pNext;
            } else {
                pDeadGSD = pCur;
                pTrailer->pNext = pCur->pNext;
                delete pDeadGSD;
                pCur = NULL;
            }
        }
    }

private:
    GSD    *m_pHead;    // dummy node for head
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\cmicro.h ===
#ifndef _CMICRO
#define _CMICRO

#include "objidl.h"
#include "wiamicro.h"

typedef HRESULT (CALLBACK *FPMICROENTRY)(LONG, PVAL);
typedef HRESULT (CALLBACK *FPSCANENTRY)(PSCANINFO, LONG, PBYTE, LONG, PLONG );
typedef HRESULT (CALLBACK *FPSETPIXELWINDOWENTRY)(PSCANINFO, LONG, LONG, LONG, LONG);

class CMICRO {

public:
     CMICRO(TCHAR *pszMicroDriver);
    ~CMICRO();
    HRESULT MicroEntry(LONG lCommand, PVAL pValue);
    HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, PLONG plRecieved);
    HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent);
    HRESULT Disable();
    HRESULT UnInitialize(PSCANINFO pScanInfo);
private:
    FPMICROENTRY m_pMicroEntry;
    FPSCANENTRY  m_pScan;
    FPSETPIXELWINDOWENTRY m_pSetPixelWindow;
    HMODULE m_hModule;
    SCSISCAN_CMD m_ScsiScan;
    BOOL         m_bDisabled;

protected:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devaction.cpp ===
// devaction.cpp : Implementation of CDeviceAction
#include "pch.h"
#include "wiafb.h"
#include "devaction.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceAction

STDMETHODIMP CDeviceAction::get_Value(VARIANT* pvValue)
{
    pvValue->vt = VT_I4;
    pvValue->lVal = m_lValue;
    return S_OK;
}

STDMETHODIMP CDeviceAction::put_Value(VARIANT* pvValue)
{
    return S_OK;
}

STDMETHODIMP CDeviceAction::Action(LONG *plActionID)
{
    if(NULL == plActionID){
        return E_INVALIDARG;
    }

    *plActionID = m_DeviceActionID;
    return S_OK;
}

STDMETHODIMP CDeviceAction::ValueID(LONG *plValueID)
{
    if(NULL == plValueID){
        return E_INVALIDARG;
    }

    *plValueID = m_DeviceValueID;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devctrl.cpp ===
// devctrl.cpp : Implementation of CDeviceControl
#include "pch.h"
#include "wiafb.h"
#include "devctrl.h"

#define IOCTL_EPP_WRITE         0x85 // remove at a later data.. Visioneer specific ( this is for
                                     // proof of concept.)
#define IOCTL_EPP_READ          0x84

/////////////////////////////////////////////////////////////////////////////
// CDeviceControl

STDMETHODIMP CDeviceControl::RawWrite(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG lTimeout)
{

    HRESULT hr = S_OK;
    UINT uiBufferLen = 0;
    CHAR *pData = NULL;
    DWORD dwBytesWritten = 0;

    switch (pvbuffer->vt) {
    case VT_BSTR:
        {
            if(NULL != pvbuffer->bstrVal){

                uiBufferLen = WideCharToMultiByte(CP_ACP, 0, pvbuffer->bstrVal, -1, NULL, NULL, 0, 0);
                if (!uiBufferLen) {

                    // SetLastErrorCode
                }

                pData = new CHAR[uiBufferLen+1];
                if (!pData) {

                    // SetLastErrorCode
                    return E_OUTOFMEMORY;
                }

                WideCharToMultiByte(CP_ACP, 0, pvbuffer->bstrVal, -1, pData, uiBufferLen, 0, 0);

                //
                // send data to device
                //

                // DeviceIOControl(....)

                if(!WriteFile(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                          pData,
                          lbuffersize,
                          &dwBytesWritten,NULL)){

                    // SetLastErrorCode
                }

                //
                // delete any allocated memory
                //

                delete pData;


            } else {

                // SetLastErrorCode
            }
        }
        break;
    default:
        hr = E_FAIL;
        break;
    }
    return hr;
}

STDMETHODIMP CDeviceControl::RawRead(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout)
{
    HRESULT hr = S_OK;
    WCHAR wszBuffer[255];
    CHAR *pBuffer = NULL;
    DWORD dwBytesRead = 0;

    VariantClear(pvbuffer);

    //
    // clean out buffer
    //

    memset(wszBuffer,0,sizeof(wszBuffer));

    //
    // alloc/clean in buffer
    //

    pBuffer = new CHAR[(lbuffersize+1)];
    
    if(NULL == pBuffer){
        return E_OUTOFMEMORY;
    }

    memset(pBuffer,0,lbuffersize+1);

    //
    // read from device
    //

    if(!ReadFile(m_pScannerSettings->DeviceIOHandles[lPipeNum],pBuffer,lbuffersize,&dwBytesRead,NULL)) {
        return E_FAIL;
    }

    pBuffer[dwBytesRead] = '\0';

    //
    // set number of bytes read
    //

    *plbytesread = dwBytesRead;

    //
    // construct VARIANT properly, for out buffer
    //

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        pBuffer,
                        lstrlenA(pBuffer)+1,
                        wszBuffer,
                        (sizeof(wszBuffer)/sizeof(WCHAR)));

    pvbuffer->vt = VT_BSTR;
    pvbuffer->bstrVal = SysAllocString(wszBuffer);

    delete pBuffer;

    return hr;
}

STDMETHODIMP CDeviceControl::ScanRead(LONG lPipeNum,LONG lBytesToRead, LONG *plBytesRead, LONG lTimeout)
{

    if(!ReadFile(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                 m_pBuffer,
                 m_lBufferSize,
                 &m_dwBytesRead,NULL)) {

        //
        // SetLastErrorCode
        //

    }

    return S_OK;
}

STDMETHODIMP CDeviceControl::RegisterWrite(LONG lPipeNum,VARIANT *pvbuffer,LONG lTimeout)
{
    HRESULT hr           = S_OK;
    PBYTE pData          = NULL;
    DWORD dwBytesWritten = 0;
    IO_BLOCK IoBlock;
    memset(&IoBlock,0,sizeof(IO_BLOCK));
    VARIANT *pVariant    = NULL;
    VARIANTARG *pVariantArg = pvbuffer->pvarVal;
    LONG lUBound         = 0;
    LONG lNumItems       = 0;

    if(SafeArrayGetDim(pVariantArg->parray)!=1){
        return E_INVALIDARG;
    }

    //
    // get upper bounds
    //

    hr = SafeArrayGetUBound(pVariantArg->parray,1,(LONG*)&lUBound);
    if (SUCCEEDED(hr)) {
        hr = SafeArrayAccessData(pVariantArg->parray,(void**)&pVariant);
        if (SUCCEEDED(hr)) {
            lNumItems = (lUBound + 1);
            pData     = (PBYTE)LocalAlloc(LPTR,sizeof(BYTE) * lNumItems);
            if(NULL != pData){

                //
                // copy contents of VARIANT into BYTE array, for writing to
                // the device.
                //

                for(INT index = 0;index <lUBound;index++){
                    pData[index] = pVariant[index].bVal;
                }

                IoBlock.uOffset = (BYTE)IOCTL_EPP_WRITE;
                IoBlock.uLength = (BYTE)(sizeof(BYTE) * lNumItems);
                IoBlock.pbyData = pData;

                DeviceIoControl(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                                           (DWORD) IOCTL_WRITE_REGISTERS,
                                           &IoBlock,
                                           sizeof(IO_BLOCK),
                                           NULL,
                                           0,
                                           &dwBytesWritten,
                                           NULL);

                //
                // free array block, after operation is complete
                //

                LocalFree(pData);
                pData = NULL;
            }
        }
    }

    return hr;
}

STDMETHODIMP CDeviceControl::RegisterRead(LONG lPipeNum,LONG lRegNumber, VARIANT *pvbuffer,LONG lTimeout)
{
    HRESULT hr = S_OK;
    DWORD dwBytesRead = 0;

    pvbuffer->vt = VT_UI1;

    //
    // read from device
    //

    IO_BLOCK IoBlock;

    IoBlock.uOffset = MAKEWORD(IOCTL_EPP_READ, (BYTE)lRegNumber);
    IoBlock.uLength = 1;
    IoBlock.pbyData = &pvbuffer->bVal;

    if (!DeviceIoControl(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                         (DWORD) IOCTL_READ_REGISTERS,
                         (PVOID)&IoBlock,
                         (DWORD)sizeof(IO_BLOCK),
                         (PVOID)&pvbuffer->bVal,
                         (DWORD)sizeof(BYTE),
                         &dwBytesRead,
                         NULL)){
        return E_FAIL;
    };
    return hr;
}

STDMETHODIMP CDeviceControl::SetBitsInByte(BYTE bMask, BYTE bValue, BYTE *pbyte)
{
    LONG lBitIndex = 0;

    if(((BITS*)&bMask)->b0 == 1)
        lBitIndex = 0;
    else if(((BITS*)&bMask)->b1 == 1)
        lBitIndex = 1;
    else if(((BITS*)&bMask)->b2 == 1)
        lBitIndex = 2;
    else if(((BITS*)&bMask)->b3 == 1)
        lBitIndex = 3;
    else if(((BITS*)&bMask)->b4 == 1)
        lBitIndex = 4;
    else if(((BITS*)&bMask)->b5 == 1)
        lBitIndex = 5;
    else if(((BITS*)&bMask)->b6 == 1)
        lBitIndex = 6;
    else if(((BITS*)&bMask)->b7 == 1)
        lBitIndex = 7;

        *pbyte  = (*pbyte & ~bMask) | ((bValue << lBitIndex) & bMask);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devprop.h ===
// DeviceProperty.h : Declaration of the CDeviceProperty

#ifndef __DEVICEPROPERTY_H_
#define __DEVICEPROPERTY_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceProperty
class ATL_NO_VTABLE CDeviceProperty :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceProperty, &CLSID_DeviceProperty>,
    public IDispatchImpl<IDeviceProperty, &IID_IDeviceProperty, &LIBID_WIAFBLib>,
    public IObjectSafetyImpl<CDeviceProperty, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;

    CDeviceProperty()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEPROPERTY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceProperty)
    COM_INTERFACE_ENTRY(IDeviceProperty)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDeviceProperty
public:
    STDMETHOD(SetCurrentValue)(LONG lValueID, VARIANT Value);
    STDMETHOD(GetCurrentValue)(LONG lValueID, VARIANT *pvValue);
    STDMETHOD(SetValidRange)(LONG lValueID, LONG lMin, LONG lMax, LONG lNom, LONG lInc);
    STDMETHOD(SetValidList)(LONG lValueID, VARIANT Value);
    STDMETHOD(TestCall)();
};

#endif //__DEVICEPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devprop.cpp ===
// devprop.cpp : Implementation of CDeviceProperty
#include "pch.h"
#include "wiafb.h"
#include "devprop.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceProperty

STDMETHODIMP CDeviceProperty::SetCurrentValue(LONG lValueID, VARIANT Value)
{
    switch(lValueID){
    case XRESOLUTION_ID:
        m_pScannerSettings->CurrentXResolution = Value.lVal;
        break;
    case YRESOLUTION_ID:
        m_pScannerSettings->CurrentYResolution = Value.lVal;
        break;
    case XPOS_ID:
        m_pScannerSettings->CurrentXPos = Value.lVal;
        break;
    case YPOS_ID:
        m_pScannerSettings->CurrentYPos = Value.lVal;
        break;
    case XEXT_ID:
        m_pScannerSettings->CurrentXExtent = Value.lVal;
        break;
    case YEXT_ID:
        m_pScannerSettings->CurrentYExtent = Value.lVal;
        break;
    case BRIGHTNESS_ID:
        m_pScannerSettings->CurrentBrightness = Value.lVal;
        break;
    case CONTRAST_ID:
        m_pScannerSettings->CurrentContrast = Value.lVal;
        break;
    case DATA_TYPE_ID:
        m_pScannerSettings->CurrentDataType = (LONG)Value.iVal;
        break;
    case BIT_DEPTH_ID:
        m_pScannerSettings->CurrentBitDepth = (LONG)Value.iVal;
        break;
    case NEGATIVE_ID:
        m_pScannerSettings->bNegative = (BOOL)Value.boolVal;
        break;
    case PIXEL_PACKING_ID:
        m_pScannerSettings->RawPixelPackingOrder = (LONG)Value.iVal;
        break;
    case PIXEL_FORMAT_ID:
        m_pScannerSettings->RawPixelFormat = (LONG)Value.iVal;
        break;
    case DATA_ALIGN_ID:
        m_pScannerSettings->RawDataAlignment = (LONG)Value.iVal;
        break;
    case BED_WIDTH_ID:
        m_pScannerSettings->BedWidth = Value.lVal;
        break;
    case BED_HEIGHT_ID:
        m_pScannerSettings->BedHeight = Value.lVal;
        break;
    case XOPTICAL_ID:
        m_pScannerSettings->XOpticalResolution = Value.lVal;
        break;
    case YOPTICAL_ID:
        m_pScannerSettings->YOpticalResolution = Value.lVal;
        break;
    case ADF_ID:
        m_pScannerSettings->ADFSupport = Value.lVal;
        break;
    case TPA_ID:
        m_pScannerSettings->TPASupport = Value.lVal;
        break;
    case ADF_WIDTH_ID:
        m_pScannerSettings->FeederWidth = Value.lVal;
        break;
    case ADF_HEIGHT_ID:
        m_pScannerSettings->FeederHeight = Value.lVal;
        break;
    case ADF_VJUSTIFY_ID:
        m_pScannerSettings->VFeederJustification = Value.lVal;
        break;
    case ADF_HJUSTIFY_ID:
        m_pScannerSettings->HFeederJustification = Value.lVal;
        break;
    case ADF_MAX_PAGES_ID:
        m_pScannerSettings->MaxADFPageCapacity = Value.lVal;
        break;
    case FIRMWARE_VER_ID:
        //lstrcpy(m_pScannerSettings->FirmwareVersion,Value.cVal);
        break;
    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CDeviceProperty::GetCurrentValue(LONG lValueID, VARIANT *pvValue)
{
    // default to LONG type
    pvValue->vt = VT_I4;

    switch(lValueID){
    case XRESOLUTION_ID:
        pvValue->lVal = m_pScannerSettings->CurrentXResolution;
        break;
    case YRESOLUTION_ID:
        pvValue->lVal = m_pScannerSettings->CurrentYResolution;
        break;
    case XPOS_ID:
        pvValue->lVal = m_pScannerSettings->CurrentXPos;
        break;
    case YPOS_ID:
        pvValue->lVal = m_pScannerSettings->CurrentYPos;
        break;
    case XEXT_ID:
        pvValue->lVal = m_pScannerSettings->CurrentXExtent;
        break;
    case YEXT_ID:
        pvValue->lVal = m_pScannerSettings->CurrentYExtent;
        break;
    case BRIGHTNESS_ID:
        pvValue->lVal = m_pScannerSettings->CurrentBrightness;
        break;
    case CONTRAST_ID:
        pvValue->lVal = m_pScannerSettings->CurrentContrast;
        break;
    case DATA_TYPE_ID:
        pvValue->vt = VT_I2;
        pvValue->iVal = (INT)m_pScannerSettings->CurrentDataType;
        break;
    case BIT_DEPTH_ID:
        pvValue->vt = VT_I2;
        pvValue->iVal = (INT)m_pScannerSettings->CurrentBitDepth;
        break;
    case NEGATIVE_ID:
        pvValue->lVal = (LONG)m_pScannerSettings->bNegative;
        break;
    case PIXEL_PACKING_ID:
        pvValue->lVal = m_pScannerSettings->RawPixelPackingOrder;
        break;
    case PIXEL_FORMAT_ID:
        pvValue->lVal = m_pScannerSettings->RawPixelFormat;
        break;
    case DATA_ALIGN_ID:
        pvValue->lVal = m_pScannerSettings->RawDataAlignment;
        break;
    case BED_WIDTH_ID:
        pvValue->lVal = m_pScannerSettings->BedWidth;
        break;
    case BED_HEIGHT_ID:
        pvValue->lVal = m_pScannerSettings->BedHeight;
        break;
    case XOPTICAL_ID:
        pvValue->lVal = m_pScannerSettings->XOpticalResolution;
        break;
    case YOPTICAL_ID:
        pvValue->lVal = m_pScannerSettings->YOpticalResolution;
        break;
    case ADF_ID:
        pvValue->lVal = m_pScannerSettings->ADFSupport;
        break;
    case TPA_ID:
        pvValue->lVal = m_pScannerSettings->TPASupport;
        break;
    case ADF_WIDTH_ID:
        pvValue->lVal = m_pScannerSettings->FeederWidth;
        break;
    case ADF_HEIGHT_ID:
        pvValue->lVal = m_pScannerSettings->FeederHeight;
        break;
    case ADF_VJUSTIFY_ID:
        pvValue->lVal = m_pScannerSettings->VFeederJustification;
        break;
    case ADF_HJUSTIFY_ID:
        pvValue->lVal = m_pScannerSettings->HFeederJustification;
        break;
    case ADF_MAX_PAGES_ID:
        pvValue->lVal = m_pScannerSettings->MaxADFPageCapacity;
        break;
    case FIRMWARE_VER_ID:
        //lstrcpy(m_pScannerSettings->FirmwareVersion,Value.cVal);
        break;
    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CDeviceProperty::SetValidRange(LONG lValueID, LONG lMin, LONG lMax, LONG lNom, LONG lInc)
{

    switch(lValueID){
    case XRESOLUTION_ID:
        m_pScannerSettings->XSupportedResolutionsRange.lMax  = lMax;
        m_pScannerSettings->XSupportedResolutionsRange.lMin  = lMin;
        m_pScannerSettings->XSupportedResolutionsRange.lNom  = lNom;
        m_pScannerSettings->XSupportedResolutionsRange.lStep = lInc;
        break;
    case YRESOLUTION_ID:
        m_pScannerSettings->YSupportedResolutionsRange.lMax  = lMax;
        m_pScannerSettings->YSupportedResolutionsRange.lMin  = lMin;
        m_pScannerSettings->YSupportedResolutionsRange.lNom  = lNom;
        m_pScannerSettings->YSupportedResolutionsRange.lStep = lInc;
        break;
    case XPOS_ID:
        m_pScannerSettings->XPosRange.lMax = lMax;
        m_pScannerSettings->XPosRange.lMin = lMin;
        m_pScannerSettings->XPosRange.lNom = lNom;
        m_pScannerSettings->XPosRange.lStep = lInc;
        break;
    case YPOS_ID:
        m_pScannerSettings->YPosRange.lMax = lMax;
        m_pScannerSettings->YPosRange.lMin = lMin;
        m_pScannerSettings->YPosRange.lNom = lNom;
        m_pScannerSettings->YPosRange.lStep = lInc;
        break;
    case XEXT_ID:
        m_pScannerSettings->XExtentsRange.lMax = lMax;
        m_pScannerSettings->XExtentsRange.lMin = lMin;
        m_pScannerSettings->XExtentsRange.lNom = lNom;
        m_pScannerSettings->XExtentsRange.lStep = lInc;
        break;
    case YEXT_ID:
        m_pScannerSettings->YExtentsRange.lMax  = lMax;
        m_pScannerSettings->YExtentsRange.lMin  = lMin;
        m_pScannerSettings->YExtentsRange.lNom  = lNom;
        m_pScannerSettings->YExtentsRange.lStep = lInc;
        break;
    case BRIGHTNESS_ID:
        m_pScannerSettings->BrightnessRange.lMax = lMax;
        m_pScannerSettings->BrightnessRange.lMin = lMin;
        m_pScannerSettings->BrightnessRange.lNom = lNom;
        m_pScannerSettings->BrightnessRange.lStep = lInc;
        break;
    case CONTRAST_ID:
        m_pScannerSettings->ContrastRange.lMax = lMax;
        m_pScannerSettings->ContrastRange.lMin = lMin;
        m_pScannerSettings->ContrastRange.lNom = lNom;
        m_pScannerSettings->ContrastRange.lStep = lInc;
        break;
    default:
        return E_FAIL;
    }
    return S_OK;
}

STDMETHODIMP CDeviceProperty::SetValidList(LONG lValueID, VARIANT Value)
{
    HRESULT hr     = S_OK;
    INT iNumValues = 0;
    INT index      = 1;
    LONG lLBound   = 0;
    LONG lUBound   = 0;
    VARIANT *pVariant = NULL;

    //
    // incoming, array of VARIANTS:
    // use Value to get actual VARIANT Array
    //

    VARIANTARG *pVariantArg = Value.pvarVal;

    if(SafeArrayGetDim(pVariantArg->parray) != 1){
        return E_INVALIDARG;
    }

    //
    // get upper bounds of array
    //

    hr = SafeArrayGetUBound(pVariantArg->parray, 1, (long *)&lUBound);
    hr = SafeArrayAccessData(pVariantArg->parray, (void**)&pVariant);
    if (SUCCEEDED(hr)) {
        iNumValues = lUBound + 1;
        switch (lValueID) {
        case XRESOLUTION_ID:
            m_pScannerSettings->XSupportedResolutionsList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
            if (m_pScannerSettings->XSupportedResolutionsList) {
                m_pScannerSettings->XSupportedResolutionsList[0] = iNumValues;
                for (index = 0; index < iNumValues; index++) {
                    m_pScannerSettings->XSupportedResolutionsList[index+1] = pVariant[index].iVal;
                }
            }
            break;
        case YRESOLUTION_ID:
            m_pScannerSettings->YSupportedResolutionsList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
            if (m_pScannerSettings->YSupportedResolutionsList) {
                m_pScannerSettings->YSupportedResolutionsList[0] = iNumValues;
                for (index = 0; index < iNumValues; index++) {
                    m_pScannerSettings->YSupportedResolutionsList[index+1] = pVariant[index].iVal;
                }
            }
            break;
        case DATA_TYPE_ID:
            m_pScannerSettings->SupportedDataTypesList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
            if (m_pScannerSettings->SupportedDataTypesList) {
                m_pScannerSettings->SupportedDataTypesList[0] = iNumValues;
                for (index = 0; index < iNumValues; index++) {
                    m_pScannerSettings->SupportedDataTypesList[index+1] = pVariant[index].iVal;
                }
            }
            break;
        default:
            hr =  E_FAIL;
            break;
        }
        SafeArrayUnaccessData(pVariantArg->parray);
    }
    return hr;
}

STDMETHODIMP CDeviceProperty::TestCall()
{
    ::MessageBox(NULL,TEXT("Test CALL"),TEXT("Test CALL"),MB_OK);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devaction.h ===
// DeviceAction.h : Declaration of the CDeviceAction

#ifndef __DEVICEACTION_H_
#define __DEVICEACTION_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

template <class T>
class CProxy_IDeviceActionEvent : public IConnectionPointImpl<T, &DIID__IDeviceActionEvent, CComDynamicUnkArray>
{
public:
    HRESULT Fire_DeviceActionEvent()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;

    }
};

/////////////////////////////////////////////////////////////////////////////
// CDeviceAction
class ATL_NO_VTABLE CDeviceAction :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceAction, &CLSID_DeviceAction>,
    public IConnectionPointContainerImpl<CDeviceAction>,
    public IDispatchImpl<IDeviceAction, &IID_IDeviceAction, &LIBID_WIAFBLib>,
    public CProxy_IDeviceActionEvent< CDeviceAction >,
    public IObjectSafetyImpl<CDeviceAction, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;
    LONG m_DeviceActionID;
    LONG m_DeviceValueID;
    LONG m_lValue;

    CDeviceAction()
    {
        m_DeviceActionID    = 0;
        m_DeviceValueID     = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEACTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceAction)
    COM_INTERFACE_ENTRY(IDeviceAction)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CDeviceAction)
CONNECTION_POINT_ENTRY(DIID__IDeviceActionEvent)
END_CONNECTION_POINT_MAP()


// IDeviceAction
public:
    STDMETHOD(get_Value)(VARIANT* pvValue);
    STDMETHOD(put_Value)(VARIANT* pvValue);
    STDMETHOD(Action)(LONG *plActionID);
    STDMETHOD(ValueID)(LONG *plValueID);
};

#endif //__DEVICEACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devctrl.h ===
// DeviceControl.h : Declaration of the CDeviceControl

#ifndef __DEVICECONTROL_H_
#define __DEVICECONTROL_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

//////////////////////////////////////////
// Taken from NTDDK.H                   //
//////////////////////////////////////////

#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//////////////////////////////////////////
// Taken from USBSCAN.H                 //
//////////////////////////////////////////

#define FILE_DEVICE_USB_SCAN    0x8000
#define IOCTL_INDEX             0x0800

#define IOCTL_GET_VERSION               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX,   METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CANCEL_IO                 CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+1, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WAIT_ON_DEVICE_EVENT      CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+2, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_REGISTERS            CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+3, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WRITE_REGISTERS           CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+4, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CHANNEL_ALIGN_RQST    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+5, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE_DESCRIPTOR     CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+6, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RESET_PIPE                CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+7, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_USB_DESCRIPTOR        CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+8, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SEND_USB_REQUEST          CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+9, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_PIPE_CONFIGURATION    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+10,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _IO_BLOCK {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;
} IO_BLOCK, *PIO_BLOCK;

///////////////////////////////////////////

#define IOCTL_GET_DEVICE_INFO   0x0
#define IOCTL_GET_DEVICE_STATUS 0x1
#define IOCTL_READ_WRITE_DATA   0x82
#define IOCTL_EPP_ADDR          0x83
#define IOCTL_EPP_READ          0x84
#define IOCTL_EPP_WRITE         0x85
#define IOCTL_SPP_STATUS        0x86
#define IOCTL_SPP_CONTROL       0x87
#define IOCTL_SPP_DATA_BUS      0x88
#define IOCTL_GPIO_OE           0x89
#define IOCTL_GPIO_READ         0x8A
#define IOCTL_GPIO_WRITE        0x8B

////////////////////////////////////////////////
// Custom BITS structure for bit manipulation //
////////////////////////////////////////////////

typedef struct _BITS{
    BYTE b0 :1;
    BYTE b1 :1;
    BYTE b2 :1;
    BYTE b3 :1;
    BYTE b4 :1;
    BYTE b5 :1;
    BYTE b6 :1;
    BYTE b7 :1;
}BITS;

/////////////////////////////////////////////////////////////////////////////
// CDeviceControl
class ATL_NO_VTABLE CDeviceControl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceControl, &CLSID_DeviceControl>,
    public IDispatchImpl<IDeviceControl, &IID_IDeviceControl, &LIBID_WIAFBLib>,
    public IObjectSafetyImpl<CDeviceControl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;
    BYTE *m_pBuffer;
    LONG  m_lBufferSize;
    DWORD m_dwBytesRead;

    CDeviceControl()
    {
        m_pBuffer = NULL;
        m_lBufferSize = 0;
        m_dwBytesRead = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICECONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceControl)
    COM_INTERFACE_ENTRY(IDeviceControl)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDeviceControl
public:
    STDMETHOD(RawWrite)(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG lTimeout);
    STDMETHOD(RawRead)(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout);
    STDMETHOD(ScanRead)(LONG lPipeNum,LONG lBytesToRead, LONG *plBytesRead, LONG lTimeout);
    STDMETHOD(RegisterWrite)(LONG lPipeNum,VARIANT *pvbuffer,LONG lTimeout);
    STDMETHOD(RegisterRead)(LONG lPipeNum,LONG lRegNumber, VARIANT *pvbuffer,LONG lTimeout);
    STDMETHOD(SetBitsInByte)(BYTE bMask, BYTE bValue, BYTE *pbyte);
};

#endif //__DEVICECONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devscriptsite.h ===
#include <windows.h>
#include <activscp.h>

class CDeviceScriptSite : public IActiveScriptSite {
private:
    ULONG m_dwRef;
public:
    IUnknown *m_pUnkScriptObject;
    ITypeInfo *m_pTypeInfo;

    IUnknown *m_pUnkScriptObjectDeviceAction;
    ITypeInfo *m_pTypeInfoDeviceAction;

    IUnknown *m_pUnkScriptObjectDeviceControl;
    ITypeInfo *m_pTypeInfoDeviceControl;

    IUnknown *m_pUnkScriptObjectLastError;
    ITypeInfo *m_pTypeInfoLastError;

    CDeviceScriptSite::CDeviceScriptSite() {
        m_pUnkScriptObject = 0;
        m_pTypeInfo = 0;

        m_pUnkScriptObjectDeviceAction = 0;
        m_pTypeInfoDeviceAction = 0;

        m_pUnkScriptObjectDeviceControl = 0;
        m_pTypeInfoDeviceControl = 0;

        m_pUnkScriptObjectLastError = 0;
        m_pTypeInfoLastError = 0;

        m_dwRef = 1;
    }

    // IUnknown methods...
    virtual HRESULT __stdcall QueryInterface(REFIID riid,
        void **ppvObject) {
        *ppvObject = NULL;
        return E_NOTIMPL;
    }
    virtual ULONG _stdcall AddRef(void) {
        return ++m_dwRef;
    }
    virtual ULONG _stdcall Release(void) {
        if(--m_dwRef == 0) return 0;
        return m_dwRef;
    }

    // IActiveScriptSite methods...
    virtual HRESULT __stdcall GetLCID(LCID *plcid) {
        return S_OK;
    }

    virtual HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName,
        DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppti) {
        // Is it expecting an ITypeInfo?
        if(ppti) {
            // Default to NULL.
            *ppti = NULL;

            // See if asking about ITypeInfo...

            //
            // Note: This needs to be done in a more efficient
            //       way.
            //

            if(dwReturnMask & SCRIPTINFO_ITYPEINFO) {
                if (!_wcsicmp(L"DeviceProperty", pstrName)) {
                    *ppti = m_pTypeInfo;
                } else if (!_wcsicmp(L"DeviceAction", pstrName)) {
                    *ppti = m_pTypeInfoDeviceAction;
                } else if (!_wcsicmp(L"DeviceControl", pstrName)) {
                    *ppti = m_pTypeInfoDeviceControl;
                } else if (!_wcsicmp(L"LastError", pstrName)) {
                    *ppti = m_pTypeInfoLastError;
                }
            }
        }

        // Is the engine passing an IUnknown buffer?
        if(ppunkItem) {
            // Default to NULL.
            *ppunkItem = NULL;

            // Is Script Engine looking for an IUnknown for our object?

            //
            // Note: This needs to be done in a more efficient
            //       way.
            //

            if(dwReturnMask & SCRIPTINFO_IUNKNOWN) {
                if (!_wcsicmp(L"DeviceProperty", pstrName)) {
                    *ppunkItem = m_pUnkScriptObject;
                    m_pUnkScriptObject->AddRef();
                } else if (!_wcsicmp(L"DeviceAction", pstrName)) {
                    *ppunkItem = m_pUnkScriptObjectDeviceAction;
                    m_pUnkScriptObjectDeviceAction->AddRef();
                } else if (!_wcsicmp(L"DeviceControl", pstrName)) {
                    *ppunkItem = m_pUnkScriptObjectDeviceControl;
                    m_pUnkScriptObjectDeviceControl->AddRef();
                } else if (!_wcsicmp(L"LastError", pstrName)) {
                    *ppunkItem = m_pUnkScriptObjectLastError;
                    m_pUnkScriptObjectLastError->AddRef();
                }
            }
        }
        return S_OK;
    }

    virtual HRESULT __stdcall GetDocVersionString(BSTR *pbstrVersion) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnScriptTerminate(
        const VARIANT *pvarResult, const EXCEPINFO *pexcepInfo) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnStateChange(SCRIPTSTATE ssScriptState) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnScriptError(
        IActiveScriptError *pscriptError) {
        BSTR bstrSourceLine;
        DWORD dwSourceContext = 0;
        ULONG ulLineNumber    = 0;
        LONG  lchPosition     = 0;
        HRESULT hr = S_OK;
        hr = pscriptError->GetSourceLineText(&bstrSourceLine);
        hr = pscriptError->GetSourcePosition(&dwSourceContext,&ulLineNumber,&lchPosition);

        TCHAR szErrorDescription[1024];
        memset(szErrorDescription,0,sizeof(szErrorDescription));
#ifdef UNICODE
        swprintf(szErrorDescription,TEXT("SOURCE: %ws\nLINE: %d\nCHARACTER POS: %d"),
                bstrSourceLine,
                ulLineNumber,
                lchPosition);
#else
        sprintf(szErrorDescription,TEXT("SOURCE: %ws\nLINE: %d\nCHARACTER POS: %d"),
                bstrSourceLine,
                ulLineNumber,
                lchPosition);
#endif

#ifdef DEBUG
        ::MessageBox(NULL, szErrorDescription, TEXT("WIA Driver Script Error"), MB_SETFOREGROUND);
#endif
        return S_OK;
    }

    virtual HRESULT __stdcall OnEnterScript(void) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnLeaveScript(void) {
        return S_OK;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\ioblock.h ===
#ifndef __IOBLOCK
#define __IOBLOCK

#include "ioblockdefs.h"
#include "devscriptsite.h"
#include "devprop.h"
#include "devaction.h"
#include "devctrl.h"
#include "lasterr.h"

class CIOBlock {
public:
    CIOBlock();
    ~CIOBlock();

    void    Initialize(PGSD_INFO pGSDInfo);
    HRESULT DebugDumpScannerSettings();
    HRESULT StartScriptEngine();
    HRESULT StopScriptEngine();
    HRESULT LoadScript();
    HRESULT ProcessScript();
    HRESULT InitializeProperties();

    // operations
    HRESULT ReadValue(LONG ValueID, PLONG plValue);
    HRESULT WriteValue(LONG ValueID, LONG lValue);
    HRESULT Scan(LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived);
    BOOL    GetEventStatus(PGSD_EVENT_INFO pGSDEventInfo);
    BOOL    DeviceOnLine();
    HRESULT ResetDevice();
    HRESULT EventInterrupt(PGSD_EVENT_INFO pGSDEventInfo);

    SCANSETTINGS m_ScannerSettings; // scanner model settings
private:

    // helpers
    LONG InsertINTIntoByteBuffer(PBYTE szDest, PBYTE szSrc, BYTE cPlaceHolder, INT iValueToInsert);
    LONG ExtractINTFromByteBuffer(PINT iDest, PBYTE szSrc, BYTE cTerminatorByte, INT iOffset);

protected:
    TCHAR        m_szFileName[255]; // main product line file name

    CDeviceScriptSite           *m_pDeviceScriptSite;   // scripting site
    CComObject<CDeviceProperty> *m_pDeviceProperty;     // IDeviceProperty Interface
    CComObject<CDeviceAction>   *m_pDeviceAction;       // IDeviceAction Interface
    CComObject<CDeviceControl>  *m_pDeviceControl;      // IDeviceControl Interface
    CComObject<CLastError>      *m_pLastError;          // ILastError Interface
    IActiveScript               *m_pActiveScript;       // IActiveScript Interface
    IActiveScriptParse          *m_pActiveScriptParser; // IActiveScriptParse Interface
    WCHAR                       *m_wszScriptText;         // scriptlet
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

#define THREAD_TERMINATION_TIMEOUT  10000
VOID EventThread( LPVOID  lpParameter ); // event thread

/**************************************************************************\
* CWIAScannerDevice::CWIAScannerDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::CWIAScannerDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_fValid(FALSE),
    m_punkOuter(NULL),
    m_pIStiDevControl(NULL),
    m_bUsdLoadEvent(FALSE),
    m_dwLastOperationError(0),
    m_dwLockTimeout(100),
    m_hSignalEvent(NULL),
    m_hShutdownEvent(NULL),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pIWiaEventCallback(NULL),
    m_pIDrvItemRoot(NULL),
    m_pStiDevice(NULL),
    m_hInstance(NULL),
    m_pIWiaLog(NULL),
    m_NumSupportedFormats(0),
    m_NumCapabilities(0),
    m_NumSupportedTYMED(0),
    m_NumInitialFormats(0),
    m_NumSupportedDataTypes(0),
    m_NumSupportedIntents(0),
    m_NumSupportedCompressionTypes(0),
    m_NumSupportedResolutions(0),
    m_pSupportedFormats(NULL),
    m_pInitialFormats(NULL),
    m_pCapabilities(NULL),
    m_pSupportedTYMED(NULL),
    m_pSupportedDataTypes(NULL),
    m_pSupportedIntents(NULL),
    m_pSupportedCompressionTypes(NULL),
    m_pSupportedResolutions(NULL),
    m_pSupportedPreviewModes(NULL),
    m_pszRootItemDefaults(NULL),
    m_piRootItemDefaults(NULL),
    m_pvRootItemDefaults(NULL),
    m_psRootItemDefaults(NULL),
    m_wpiRootItemDefaults(NULL),
    m_pszItemDefaults(NULL),
    m_piItemDefaults(NULL),
    m_pvItemDefaults(NULL),
    m_psItemDefaults(NULL),
    m_wpiItemDefaults(NULL),
    m_NumRootItemProperties(0),
    m_NumItemProperties(0),
    m_MaxBufferSize(65535),
    m_MinBufferSize(65535),
    m_bDeviceLocked(FALSE),
    m_DeviceDefaultDataHandle(NULL),
    m_bLegacyBWRestriction(FALSE),
    m_pszDeviceNameA(NULL),
    m_pScanAPI(NULL)
{

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

}

/**************************************************************************\
* CWIAScannerDevice::PrivateInitialize
*
*   Device class private initialization code
*
* Arguments:
*
*    None
*
* Return Value:
*
*    HRESULT
*
\**************************************************************************/
HRESULT CWIAScannerDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;

#ifdef USE_SERVICE_LOG_CREATION
    hr = wiasCreateLogInstance(g_hInst, &m_pIWiaLog);
#else

    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWiaLog,(void**)&m_pIWiaLog);

    if (SUCCEEDED(hr)) {
        m_pIWiaLog->InitializeLog((LONG)(LONG_PTR)g_hInst);
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object created successfully for wiafbdrv.dll"));
    } else {
#ifdef DEBUG
        OutputDebugString(TEXT("Could not CoCreateInstance on Logging COM object for wiafbdrv.dll, because we are STI only\n"));
        OutputDebugString(TEXT("********* (Device must have been created for STI only) *********\n"));
#endif
    hr = S_OK;
    }

#endif

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown critsect failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {

        // Create event for syncronization of notifications shutdown.
        m_hShutdownEvent =  CreateEvent(NULL,FALSE,FALSE,NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        } else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown event failed"));
        }
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::~CWIAScannerDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::~CWIAScannerDevice(void)
{

    if(m_pScanAPI)
        m_pScanAPI->UnInitialize();

    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Deleting Device Item Tree (this is OK)"));
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // free any IO handles opened
    if(m_DeviceDefaultDataHandle){
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Closing DefaultDeviceDataHandle"));
        CloseHandle(m_DeviceDefaultDataHandle);
        m_DeviceDefaultDataHandle = NULL;
    }

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

    // Free the storage for the device ID.
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Release the objects supporting device property storage.
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();
    DeleteSupportedIntentsArrayContents();

    // Free the critical section.
    DeleteCriticalSection(&m_csShutdown);
    if(m_pIWiaLog)
        m_pIWiaLog->Release();

    if(m_pScanAPI)
        delete m_pScanAPI;
}

/**************************************************************************\
* CWIAScannerDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetCapabilities");
    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT|
                              STI_GENCAP_NOTIFICATIONS |
                              STI_GENCAP_POLLING_NEEDED;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetStatus");
    HRESULT hr = S_OK;

    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If we are asked, verify the device is online.
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, WIA is asking the device if we are ONLINE"));
        pDevStatus->dwOnlineState = 0L;
        hr = m_pScanAPI->DeviceOnline();
        if(SUCCEEDED(hr)){
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Device is ONLINE"));
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Device is OFFLINE"));
        }
    }

    // If we are asked, verify state of event.
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        // Generate an event the first time we load.
        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;
            m_guidLastEvent                  = guidEventFirstLoaded;
            m_bUsdLoadEvent                  = FALSE;
        }

        // check for device events
        hr = m_pScanAPI->GetDeviceEvent(&m_guidLastEvent);
        if(SUCCEEDED(hr)){
            if(m_guidLastEvent != GUID_NULL){
                pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
            }
        }
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::DeviceReset
*
*   Reset device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeviceReset");

    return m_pScanAPI->ResetDevice();
}

/**************************************************************************\
* CWIAScannerDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Diagnostic");

    // Initialize response buffer
    memset(&pBuffer->sErrorInfo,0,sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return m_pScanAPI->Diagnostic();
}

/**************************************************************************\
* CWIAScannerDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetNotificationHandle");
    HRESULT hr = STI_OK;

    EnterCriticalSection(&m_csShutdown);

    // Are we starting or stopping the notification thread?
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, hEvent = %d",hEvent));
        m_hSignalEvent  = hEvent;
        m_guidLastEvent = GUID_NULL;

        if (NULL == m_hEventNotifyThread) {
            DWORD dwThread = 0;
            m_hEventNotifyThread = ::CreateThread(NULL,
                                                  0,
                                                  (LPTHREAD_START_ROUTINE)EventThread,
                                                  (LPVOID)this,
                                                  0,
                                                  &dwThread);
            if (!m_hEventNotifyThread) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FlatbedScannerUsdDevice::SetNotificationHandle, CreateThread failed"));
                hr = STIERR_UNSUPPORTED;
            }
        }
    } else {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Disabling event Notifications"));
        // Disable event notifications.
        if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
            if (!SetEvent(m_hShutdownEvent)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Setting Shutdown event failed.."));
            } else {

                //
                // WAIT for thread to terminate, only if the m_hEventNotifyThread is not NULL
                //

                if (NULL != m_hEventNotifyThread) {
                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Waiting for Event Thread to terminate (%d ms timeout)",THREAD_TERMINATION_TIMEOUT));
                    DWORD dwResult = WaitForSingleObject(m_hEventNotifyThread,THREAD_TERMINATION_TIMEOUT);
                    switch (dwResult) {
                    case WAIT_TIMEOUT:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread termination TIMED OUT!"));
                        break;
                    case WAIT_OBJECT_0:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, We are signaled...YAY!"));
                        break;
                    case WAIT_ABANDONED:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread was abandoned.."));
                        break;
                    default:
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Unknown signal (%d) received from WaitForSingleObject() call",dwResult));
                        break;
                    }
                }

                //
                // Close event for syncronization of notifications shutdown.
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Closing m_hShutdownEvent handle (it has been signaled)"));
                CloseHandle(m_hShutdownEvent);
                m_hShutdownEvent = NULL;
            }
        }

        //
        // terminate thread
        //

        if (NULL != m_hEventNotifyThread) {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, closing event Notifications thread handle"));
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
        }

        m_guidLastEvent      = GUID_NULL;
    }

    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::GetNotificationData
*
*   Provides data on an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetNotificationData");
    // If we have notification ready - return it's guid
    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {
        memset(&pBuffer->abNotificationData,0,sizeof(pBuffer->abNotificationData));
        pBuffer->dwSize               = sizeof(STINOTIFY);
        pBuffer->guidNotificationCode = m_guidLastEvent;
        m_guidLastEvent               = GUID_NULL;
    } else {
        return STIERR_NOEVENTS;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Escape");

    // Write command to device if needed.
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastError");

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastErrorInfo");

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::LockDevice");
    HRESULT hr = STI_OK;
    if(m_bDeviceLocked){
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("LockDevice, Device is already locked!!"));
        hr = STIERR_DEVICE_LOCKED;
    } else {
        m_bDeviceLocked = TRUE;
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("LockDevice, Locking Device successful"));
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UnLockDevice");
    HRESULT hr = STI_OK;
    if(!m_bDeviceLocked)
        hr = STIERR_NEEDS_LOCK;
    else {
        m_bDeviceLocked = FALSE;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadData");
    HRESULT hr = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = ReadFile( m_DeviceDefaultDataHandle,
                         lpBuffer,
                         *lpdwNumberOfBytes,
                         &dwBytesReturned,
                         lpOverlapped );

        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);

        *lpdwNumberOfBytes = (fRet) ? dwBytesReturned : 0;
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    dwNumberOfBytes    - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteData");
    HRESULT hr   = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = WriteFile(m_DeviceDefaultDataHandle,lpBuffer,dwNumberOfBytes,&dwBytesReturned,lpOverlapped);
        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    nNumberOfBytes     - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    - device interface
*    dwStiVersion           - STI version
*    hParametersKey         - HKEY for registry reading/writing
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Initialize");

    HRESULT hr = STI_OK;
    WCHAR szDeviceNameW[255];
    TCHAR szGSDName[255];
    TCHAR szMICRO[255];
    TCHAR szResolutions[255];
    UINT uiNameLen = 0;
    INITINFO InitInfo;

    memset(&InitInfo,0,sizeof(InitInfo));

    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    // Cache the device control interface.
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Get the name of the device port
    //

    hr = m_pIStiDevControl->GetMyDevicePortName(szDeviceNameW,sizeof(szDeviceNameW)/sizeof(WCHAR));
    if (!SUCCEEDED(hr) || !*szDeviceNameW) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't get device port"));
        return hr;
    }

    uiNameLen = WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, NULL, NULL, 0, 0);
    if (!uiNameLen) {
        return STIERR_INVALID_PARAM;
    }

    m_pszDeviceNameA = new CHAR[uiNameLen+1];
    if (!m_pszDeviceNameA) {
        return STIERR_INVALID_PARAM;
    }

    WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, m_pszDeviceNameA, uiNameLen, 0, 0);

    //
    // Open kernel mode device driver.
    //

    m_DeviceDefaultDataHandle = CreateFileA(m_pszDeviceNameA,
                                     GENERIC_READ | GENERIC_WRITE, // Access mask
                                     0,                            // Share mode
                                     NULL,                         // SA
                                     OPEN_EXISTING,                // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                     NULL );

    m_dwLastOperationError = ::GetLastError();

    hr = (m_DeviceDefaultDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    if (FAILED(hr)) {
        return hr;
    }

    InitInfo.hDeviceDataHandle = m_DeviceDefaultDataHandle;
    InitInfo.szCreateFileName  = m_pszDeviceNameA;

    //
    // Open DeviceData section to read driver specific information
    //

    HKEY hKey = hParametersKey;
    HKEY hOpenKey = NULL;
    if (RegOpenKeyEx(hKey,                     // handle to open key
                     TEXT("DeviceData"),       // address of name of subkey to open
                     0,                        // options (must be NULL)
                     KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                     &hOpenKey                 // address of handle to open key
                    ) == ERROR_SUCCESS) {

        DWORD dwWritten = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        /////////////////////////////////////////////////////////////////////////////
        // legacy MicroDriver registry entries, for BW scanners                    //
        /////////////////////////////////////////////////////////////////////////////

        LONG lNoColor = 0;
        RegQueryValueEx(hOpenKey,
                        TEXT("NoColor"),
                        NULL,
                        &dwType,
                        (LPBYTE)&lNoColor,
                        &dwWritten);
        if (lNoColor == 1) {
            m_bLegacyBWRestriction = TRUE;
        }

        /////////////////////////////////////////////////////////////////////////////
        // script driver registry entries, for script loading                      //
        /////////////////////////////////////////////////////////////////////////////

        dwWritten = sizeof(szGSDName);
        dwType = REG_SZ;
        ZeroMemory(szGSDName,sizeof(szGSDName));

        if (RegQueryValueEx(hOpenKey,
                            TEXT("GSD"),
                            NULL,
                            &dwType,
                            (LPBYTE)szGSDName,
                            &dwWritten) == ERROR_SUCCESS) {
            m_pScanAPI = new CScriptDriverAPI;
            InitInfo.szModuleFileName  = szGSDName;
        }

        /////////////////////////////////////////////////////////////////////////////
        // Micro driver registry entries, for ***mcro.dll loading                  //
        /////////////////////////////////////////////////////////////////////////////

        dwWritten = sizeof(szMICRO);
        dwType = REG_SZ;
        ZeroMemory(szMICRO,sizeof(szMICRO));

        //
        // Read Micro driver name
        //

        if (RegQueryValueEx(hOpenKey,
                            TEXT("MicroDriver"),
                            NULL,
                            &dwType,
                            (LPBYTE)szMICRO,
                            &dwWritten) == ERROR_SUCCESS) {

            m_pScanAPI = new CMicroDriverAPI;
            InitInfo.szModuleFileName  = szMICRO;
        }

        /////////////////////////////////////////////////////////////////////////////
        // resolution registry entries, for micro driver resolution restrictions   //
        /////////////////////////////////////////////////////////////////////////////

        dwWritten = sizeof(szResolutions);
        dwType = REG_SZ;
        ZeroMemory(szGSDName,sizeof(szResolutions));

        if (RegQueryValueEx(hOpenKey,
                            TEXT("Resolutions"),
                            NULL,
                            &dwType,
                            (LPBYTE)szResolutions,
                            &dwWritten) == ERROR_SUCCESS) {
            if(m_pScanAPI){
                m_pScanAPI->SetResolutionRestrictionString(szResolutions);
            }
        }

        RegCloseKey(hOpenKey);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't open DeviceData KEY"));
        return E_FAIL;
    }

    //
    // give logging interface to SCANAPI object
    // so it can log too! (shouldn't leave the little guys out. ;) )
    //

    m_pScanAPI->SetLoggingInterface(m_pIWiaLog);

    // set the HKEY for micro driver's device section
    InitInfo.hKEY = hParametersKey;

    // initialize the micro driver
    hr = m_pScanAPI->Initialize(&InitInfo);

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::DoEventProcessing
*
*   Process device events
*
* Arguments:
*
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DoEventProcessing()
{
    HRESULT hr = S_OK;

    INTERRUPTEVENTINFO EventInfo;

    EventInfo.phSignalEvent  = &m_hSignalEvent;
    EventInfo.hShutdownEvent = m_hShutdownEvent;
    EventInfo.pguidEvent     = &m_guidLastEvent;
    EventInfo.szDeviceName   = m_pszDeviceNameA;

    hr = m_pScanAPI->DoInterruptEventThread(&EventInfo);

    // close the thread handle, when the thread exits
    CloseHandle(m_hEventNotifyThread);
    m_hEventNotifyThread = NULL;
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// THREADS SECTION                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

VOID EventThread( LPVOID  lpParameter )
{
    PWIASCANNERDEVICE pThisDevice = (PWIASCANNERDEVICE)lpParameter;
    pThisDevice->DoEventProcessing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\lasterr.cpp ===
// lasterr.cpp : Implementation of CLastError
#include "pch.h"
#include "wiafb.h"
#include "lasterr.h"

/////////////////////////////////////////////////////////////////////////////
// CLastError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\dlihook.cpp ===
#include "pch.h"
#include <delayimp.h>

FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{    
#ifdef DEBUG
    switch (dliNotify) {
    case dliStartProcessing:             // used to bypass or note helper only
        OutputDebugString(TEXT("dliStartProcessing reported from DliHook"));
        break;
    case dliNotePreLoadLibrary:          // called just before LoadLibrary, can
        OutputDebugString(TEXT("dliNotePreLoadLibrary reported from DliHook"));                   //  override w/ new HMODULE return val
        break;                           
    case dliNotePreGetProcAddress:       // called just before GetProcAddress, can
        OutputDebugString(TEXT("dliNotePreGetProcAddress reported from DliHook"));                   //  override w/ new FARPROC return value
        break;                           
    case dliFailLoadLib:                 // failed to load library, fix it by
        OutputDebugString(TEXT("dliFailLoadLib reported from DliHook"));                   //  returning a valid HMODULE
        break;                           
    case dliFailGetProc:                 // failed to get proc address, fix it by                                         
        OutputDebugString(TEXT("dliFailGetProc reported from DliHook"));                   //  returning a valid FARPROC
        break;                           
    case dliNoteEndProcessing:           // called after all processing is done, no
        OutputDebugString(TEXT("dliNoteEndProcessing reported from DliHook"));                   //  no bypass possible at this point except
                                         //  by longjmp()/throw()/RaiseException.
        break;
    default:
        break;
    }
#endif
    return 0;
}

PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IWiaMiniDrv methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;           // used for WIAS_LOGPROC macro
#define _64BIT_ALIGNMENT          // the real 64-bit alignment fix
#define _SERVICE_EXTENT_VALIDATION  // let the WIA service validate the extent settings
//#define _OOB_DATA                   // Out Of Band data support (File Transfers only)

#define BUFFER_PAD 1024 // buffer padding

/**************************************************************************\
* CWIAScannerDevice::drvDeleteItem
*
*   This helper is called to delete a device item.
*   Note: Device items for this device may not be modified.
*         Return access denied.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeleteItem");
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* SendBitmapHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_CALLBACK transfers.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendBitmapHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendBitmapHeader");

    HRESULT hr = S_OK;

    BITMAPINFO UNALIGNED *pbmi = (LPBITMAPINFO)pmdtc->pTransferBuffer;

#ifdef _64BIT_ALIGNMENT
    BITMAPINFOHEADER UNALIGNED *pbmih = &pbmi->bmiHeader;
    pbmih->biHeight = -pbmih->biHeight;
#else
    pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
#endif

    //
    //  Send to class driver.  WIA Class driver will pass
    //  data through to client.
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                                     0,
                                                     0,
                                                     pmdtc->lHeaderSize,
                                                     pmdtc,
                                                     0);

    if (hr == S_OK) {

        //
        //  If the transfer was successfull, advance offset for
        //  destination copy by the size of the data just sent.
        //

        pmdtc->cbOffset += pmdtc->lHeaderSize;
    }
    return hr;
}

/**************************************************************************\
* SendFilePreviewBitmapHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_FILE transfers with
*         (out of band data) enabled.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendFilePreviewBitmapHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendBitmapHeader");

    HRESULT hr = S_OK;

#ifdef _OOB_DATA

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
    DownSampleInfo.ulOriginalHeight     = pmdtc->lLines;
    DownSampleInfo.ulDownSampledHeight  = 0;
    DownSampleInfo.ulDownSampledWidth   = 0;
    DownSampleInfo.ulXRes               = pmdtc->lXRes;
    DownSampleInfo.ulYRes               = pmdtc->lYRes;

    hr = wiasDownSampleBuffer(WIAS_GET_DOWNSAMPLED_SIZE_ONLY,
                              &DownSampleInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SendFilePreviewBitmapHeader, wiasDownSampleBuffer Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    } else {

        //
        // acquire BITMAPHEADER pointer from pmdtc
        //

        LPBITMAPINFO UNALIGNED pbmi = (LPBITMAPINFO)pmdtc->pBaseBuffer;

#ifdef _64BIT_ALIGNMENT
        BITMAPINFOHEADER UNALIGNED *pbmih = &pbmi->bmiHeader;
        pbmih->biHeight = 0;                                 // set height to zero (0)
        pbmih->biWidth  = DownSampleInfo.ulDownSampledWidth; // set down sampled width
#else
        pmdtc->pBaseBuffer          = pmdtc->pTransferBuffer + sizeof(BITMAPFILEHEADER);
#endif



        //
        // adjust width and height
        //

        pbmi->bmiHeader.biHeight    = 0;                                 // set height to zero (0)
        pbmi->bmiHeader.biWidth     = DownSampleInfo.ulDownSampledWidth; // set down sampled width

        //
        //  Send to class driver.  WIA Class driver will pass
        //  data through to client.
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          0,
                                                          0,
                                                          pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER),
                                                          pmdtc,
                                                          0);
    }

#endif

    return hr;
}

/**************************************************************************\
* ScanItem
*
*   This helper is called to do a FILE transfer.
*   Note: This routine must fill the complete buffer, and return percent
*         complete status back to the client if a callback routine is
*         provided.
*
* Arguments:
*
*   pItemContext        - private item data
*   pMiniTranCtx        - minidriver supplied transfer info
*   plDevErrVal         - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItem(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItem");
    HRESULT hr = S_OK;


    //
    // init buffer info
    //

    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    LONG  cbRemaining  = pmdtc->lBufferSize - pmdtc->lHeaderSize;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BOOL  bSwapBGRData = TRUE;
    BOOL  bDWORDAlign  = TRUE;
    BOOL  bVerticalFlip= TRUE;
    LONG  lScanPhase   = SCAN_START;
    ULONG ulDestDataOffset = 0;
    BOOL bBitmapData   = ((pmdtc->guidFormatID == WiaImgFmt_BMP) || (pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP));
    LONG PercentComplete = 0;

#ifdef _OOB_DATA

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    //
    //  SEND BITMAPHEADER to client
    //

    hr = SendFilePreviewBitmapHeader(pmdtc);
    if(hr == S_OK){

        //
        // move offset past file header
        //

        ulDestDataOffset += (pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER));
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, SendFilePreviewBitmapHeader Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }


#endif

    if (bBitmapData) {

        //
        // check to see if the color data needs to be swapped
        //

        hr = m_pScanAPI->IsColorDataBGR(&bSwapBGRData);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, IsColorDataBGR() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        //
        // check to see if data needs to be aligned
        //

        hr = m_pScanAPI->IsAlignmentNeeded(&bDWORDAlign);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, IsAlignmentNeeded() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        //
        // default transfer size is m_MaxBufferSize
        //

        cbSize = m_MaxBufferSize;

        if (bBitmapData) {

            //
            // Limit requests to max buffer size or less.
            //

            cbSize = (cbRemaining > m_MaxBufferSize) ? m_MaxBufferSize : cbRemaining;

            //
            // Request size to scanner must be modula the raw bytes per scan row.
            // Enough space for the alignment padding must be reserved.
            // These are requirements for AlignInPlace
            //

            cbSize = (cbSize / pItemContext->lBytesPerScanLine) *
                     pItemContext->lBytesPerScanLineRaw;

            //
            // check if finished
            //

            if (cbSize == 0) {
                break;
            }
        }

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {

            if (cbWritten) {

                if (bBitmapData) {

                    //
                    // Place the scan data in correct byte order for 3 bytes ber pixel data.
                    //

                    if ((pmdtc->lDepth == 24)) {

                        //
                        // swap data if needed
                        //

                        if (bSwapBGRData) {
                            SwapBuffer24(pBuf, cbWritten);
                        }
                    }

                    //
                    // Align the data on DWORD boundries.
                    //

                    if (bDWORDAlign) {
                        cbWritten = AlignInPlace(pBuf,
                                                 cbWritten,
                                                 pItemContext->lBytesPerScanLine,
                                                 pItemContext->lBytesPerScanLineRaw);
                    }
                }

                //
                // advance buffer
                //

                lItemSize   += cbWritten;
                pBuf        += cbWritten;
                cbRemaining -= cbWritten;

                //
                // If a status callback was specified callback the class driver.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;

                    if (pmdtc->lBufferSize) {
                        if(bBitmapData){
                            PercentComplete  = 0;
                            FractionComplete = (FLOAT)(pmdtc->lBufferSize - cbRemaining) / (FLOAT)pmdtc->lBufferSize;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, pmdtc->lBufferSize = 0!"));
                    }

                    //
                    // calculate percent complete
                    //

                    if(bBitmapData){
                        PercentComplete = (LONG)(100 * FractionComplete);
                    } else {
                        PercentComplete  += 25;
                        if(PercentComplete >= 100){
                            PercentComplete = 90;
                        }
                    }

                    //
                    // call back client with status on the transfer
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      0,
                                                                      0,
                                                                      NULL,
                                                                      0);
                    //
                    // check for user cancel (from IT_MSG_STATUS callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_STATUS callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_STATUS callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }

#ifdef _OOB_DATA
                    DownSampleInfo.pDestBuffer          = NULL; // allocate this for me?
                    DownSampleInfo.pSrcBuffer           = pBuf - cbWritten;
                    DownSampleInfo.ulActualSize         = 0;    // Actual of what? data written?
                    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
                    DownSampleInfo.ulDestBufSize        = 0;
                    DownSampleInfo.ulDownSampledHeight  = 0;
                    DownSampleInfo.ulDownSampledWidth   = 0;
                    DownSampleInfo.ulOriginalHeight     = (cbWritten / pItemContext->lBytesPerScanLine);
                    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
                    DownSampleInfo.ulSrcBufSize         = cbWritten;
                    DownSampleInfo.ulXRes               = pmdtc->lXRes;
                    DownSampleInfo.ulYRes               = pmdtc->lYRes;

                    hr = wiasDownSampleBuffer(0, &DownSampleInfo);
                    if(FAILED(hr)){
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, wiasDownSampleBuffer Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    } else {

                        pmdtc->pBaseBuffer = DownSampleInfo.pDestBuffer;

                        //
                        // call back client with down sampled buffer
                        //

                        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                                          PercentComplete,
                                                                          ulDestDataOffset,
                                                                          DownSampleInfo.ulActualSize,
                                                                          pmdtc,
                                                                          0);
                        //
                        // update offset
                        //

                        ulDestDataOffset += DownSampleInfo.ulActualSize;
                    }


                    //
                    // check for user cancel (from IT_MSG_FILE_PREVIEW_DATA callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
#endif
                }

                //
                // write the band of data here
                //

                if (!bBitmapData) {
                    if (hr == S_OK) {
                        if (!pmdtc->bClassDrvAllocBuf) {
                            pmdtc->lItemSize = cbWritten;
                            hr = wiasWritePageBufToFile(pmdtc);
                            if (FAILED(hr)) {
                                WIAS_LERROR(m_pIWiaLog,
                                            WIALOG_NO_RESOURCE_ID,
                                            ("ScanItem, WritePageBufToFile failed"));
                            }
                        }
                        pBuf = pmdtc->pTransferBuffer;
                    }
                }
            }

        } else {

            //
            //  Get the device error
            //
            if (plDevErrVal) {
                *plDevErrVal = (LONG) hr;
                WIAS_LERROR(m_pIWiaLog,
                            WIALOG_NO_RESOURCE_ID,
                            ("ScanItem, data transfer failed, status: 0x%X", hr));
            }
            break;
        }
    }

    if (hr == S_OK) {

        //
        // On success, flip the buffer about the vertical access if
        // we have a DIB header and data.
        //

        if (pmdtc->guidFormatID == WiaImgFmt_BMP) {
            if(bVerticalFlip){
                VerticalFlip(pItemContext, pmdtc);
            }
        }

        if (bBitmapData) {

            //
            //  If the mini driver allocated a page buffer, we need to write the
            //  buffer to the open file handle (opened by class driver).
            //

            if (!pmdtc->bClassDrvAllocBuf) {

                //
                //  Now that we know the true item size, update the mini driver
                //  context.
                //

                pmdtc->lItemSize = lItemSize;

                hr = wiasWritePageBufToFile(pmdtc);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,
                                WIALOG_NO_RESOURCE_ID,
                                ("ScanItem, WritePageBufToFile failed"));
                }
            }
        }
    }

    HRESULT Temphr = m_pScanAPI->Scan(SCAN_END, NULL, 0, NULL);
    if(FAILED(Temphr)){
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItem, Ending a scanning session failed"));
        hr = Temphr;
    }

#ifdef _OOB_DATA

    //
    // free down sampled, temporary buffer
    //

    if(DownSampleInfo.pDestBuffer){
        CoTaskMemFree(DownSampleInfo.pDestBuffer);
        DownSampleInfo.pDestBuffer = NULL;
    }

#endif

    if (!bBitmapData) {

        //
        // call back client with status on the transfer with 100% complete
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100,
                                                          0,
                                                          0,
                                                          NULL,
                                                          0);
    }

    return hr;
}

/**************************************************************************\
* ScanItemCB
*
*   This helper is called to do a MEMORY transfer.
*   Note: This routine must fill buffers, adjust the buffer offset and
*         return percent complete status back to the client via a callback
*         routine. (a callback interface must be supplied by the caller for
*         this routine to function).
*
* Arguments:
*
*   pItemContext    - private item data
*   pmdtc           - buffer and callback information
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItemCB(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItemCB");
    HRESULT hr = S_OK;

    //
    // init buffer info
    //

    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    LONG  cbRemaining  = pmdtc->lImageSize; //pmdtc->lBufferSize - pmdtc->lHeaderSize;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BOOL  bSwapBGRData = TRUE;
    BOOL  bDWORDAlign  = TRUE;
    BOOL  bVerticalFlip= TRUE;
    LONG  lScanPhase   = SCAN_START;
    pmdtc->cbOffset    = 0;
    BOOL bBitmapData   = ((pmdtc->guidFormatID == WiaImgFmt_BMP) || (pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP));
    LONG PercentComplete = 0;

    //
    //  This must be a callback transfer request
    //

    if ((pmdtc->pIWiaMiniDrvCallBack == NULL) ||
        (!pmdtc->bTransferDataCB)) {
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItemCB, invalid callback params"));
        return E_INVALIDARG;
    }

    if (bBitmapData) {

        //
        //  SEND BITMAPHEADER to client
        //

        hr = SendBitmapHeader(pmdtc);
        if (hr != S_OK) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, SendBitmapHeader failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        //
        // check to see if the color data needs to be swapped
        //

        hr = m_pScanAPI->IsColorDataBGR(&bSwapBGRData);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, IsColorDataBGR() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        //
        // check to see if data needs to be aligned
        //

        hr = m_pScanAPI->IsAlignmentNeeded(&bDWORDAlign);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, IsAlignmentNeeded() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        //
        // assign the pointer to the transfer buffer
        //

        pBuf = pmdtc->pTransferBuffer;

        cbSize = m_MaxBufferSize; // default

        if (bBitmapData) {

            //
            // Limit requests to requested buffer size or less.
            //

            cbSize = (cbRemaining > pmdtc->lBufferSize) ? pmdtc->lBufferSize : cbRemaining;

            //
            // Request size to scanner must be modula the raw bytes per scan row.
            // Enough space for the alignment padding must be reserved.
            // These are requirements for AlignInPlace
            //

            cbSize = (cbSize / pItemContext->lBytesPerScanLine) *
                     pItemContext->lBytesPerScanLineRaw;

            //
            // check if finished
            //

            if (cbSize == 0) {
                break;
            }
        }

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {

            if (cbWritten) {

                if (bBitmapData) {

                    //
                    // Place the scan data in correct byte order for 3 bytes ber pixel data.
                    //

                    if ((pmdtc->lDepth == 24)) {

                        //
                        // swap data if needed
                        //

                        if (bSwapBGRData) {
                            SwapBuffer24(pBuf, cbWritten);
                        }
                    }

                    //
                    // Align the data on DWORD boundries.
                    //

                    if (bDWORDAlign) {
                        cbWritten = AlignInPlace(pBuf,
                                                 cbWritten,
                                                 pItemContext->lBytesPerScanLine,
                                                 pItemContext->lBytesPerScanLineRaw);
                    }
                }

                //
                // advance buffer
                //

                cbRemaining -= cbWritten;

                //
                // If a status callback was specified callback the class driver.
                // There has to be a callback provided, this is the callback
                // transfer.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;

                    if ((pmdtc->lImageSize + pmdtc->lHeaderSize)) {
                        if (bBitmapData) {
                            PercentComplete  = 0;
                            FractionComplete = (FLOAT) (pmdtc->cbOffset + cbWritten) /
                                               (FLOAT) (pmdtc->lImageSize + pmdtc->lHeaderSize);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, pmdtc->lBufferSize = 0!"));
                    }

                    //
                    // calculate percent complete
                    //

                    if (bBitmapData) {
                        PercentComplete = (LONG)(100 * FractionComplete);
                    } else {
                        PercentComplete += 25;
                        if (PercentComplete >= 100) {
                            PercentComplete = 90;
                        }
                    }

                    //
                    // call back client with status on the transfer and data offset
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      pmdtc->cbOffset,
                                                                      cbWritten,
                                                                      pmdtc,
                                                                      0);

                    //
                    // check for user cancel
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItemCB, Transfer canceled by client (IT_MSG_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, MiniDrvCallback failed (IT_MSG_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
                }

                //
                // move offset
                //

                pmdtc->cbOffset += cbWritten;
            }

        } else {

            //
            //  Get the device error
            //

            if (plDevErrVa