
     glnoopGetFloatv              ,
     glnoopGetIntegerv            ,
     glnoopGetLightfv             ,
     glnoopGetLightiv             ,
     glnoopGetMapdv               ,
     glnoopGetMapfv               ,
     glnoopGetMapiv               ,
     glnoopGetMaterialfv          ,
     glnoopGetMaterialiv          ,
     glnoopGetPixelMapfv          ,
     glnoopGetPixelMapuiv         ,
     glnoopGetPixelMapusv         ,
     glnoopGetPolygonStipple      ,
     glnoopGetString              ,
     glnoopGetTexEnvfv            ,
     glnoopGetTexEnviv            ,
     glnoopGetTexGendv            ,
     glnoopGetTexGenfv            ,
     glnoopGetTexGeniv            ,
     glnoopGetTexImage            ,
     glnoopGetTexParameterfv      ,
     glnoopGetTexParameteriv      ,
     glnoopGetTexLevelParameterfv ,
     glnoopGetTexLevelParameteriv ,
     glnoopIsEnabled              ,
     glnoopIsList                 ,
     glnoopDepthRange             ,
     glnoopFrustum                ,
     glnoopLoadIdentity           ,
     glnoopLoadMatrixf            ,
     glnoopLoadMatrixd            ,
     glnoopMatrixMode             ,
     glnoopMultMatrixf            ,
     glnoopMultMatrixd            ,
     glnoopOrtho                  ,
     glnoopPopMatrix              ,
     glnoopPushMatrix             ,
     glnoopRotated                ,
     glnoopRotatef                ,
     glnoopScaled                 ,
     glnoopScalef                 ,
     glnoopTranslated             ,
     glnoopTranslatef             ,
     glnoopViewport               ,
     glnoopArrayElement           ,
     glnoopBindTexture            ,
     glnoopColorPointer           ,
     glnoopDisableClientState     ,
     glnoopDrawArrays             ,
     glnoopDrawElements           ,
     glnoopEdgeFlagPointer        ,
     glnoopEnableClientState      ,
     glnoopIndexPointer           ,
     glnoopIndexub                ,
     glnoopIndexubv               ,
     glnoopInterleavedArrays      ,
     glnoopNormalPointer          ,
     glnoopPolygonOffset          ,
     glnoopTexCoordPointer        ,
     glnoopVertexPointer          ,
     glnoopAreTexturesResident    ,
     glnoopCopyTexImage1D         ,
     glnoopCopyTexImage2D         ,
     glnoopCopyTexSubImage1D      ,
     glnoopCopyTexSubImage2D      ,
     glnoopDeleteTextures         ,
     glnoopGenTextures            ,
     glnoopGetPointerv            ,
     glnoopIsTexture              ,
     glnoopPrioritizeTextures     ,
     glnoopTexSubImage1D          ,
     glnoopTexSubImage2D          ,
     glnoopPopClientAttrib        ,
     glnoopPushClientAttrib       ,
  }

};

void APIENTRY
glnoopDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
    WARNING_NOOP("GL Noop:glDrawRangeElementsWIN\n");
}

void glnoopColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data)
{
    WARNING_NOOP("GL Noop:glColorTableEXT\n");
}

void glnoopColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    WARNING_NOOP("GL Noop:glColorSubTableEXT\n");
}

void glnoopGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data)
{
    WARNING_NOOP("GL Noop:glGetColorTableEXT\n");
}

void glnoopGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params)
{
    WARNING_NOOP("GL Noop:glGetColorTableParameterivEXT\n");
}

void glnoopGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params)
{
    WARNING_NOOP("GL Noop:glGetColorTableParameterfvEXT\n");
}

#ifdef GL_WIN_multiple_textures
void glnoopCurrentTextureIndexWIN
    (GLuint index)
{
    WARNING_NOOP("GL Noop:glCurrentTextureIndexWIN\n");
}

void glnoopMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1dWIN\n");
}

void glnoopMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1dvWIN\n");
}

void glnoopMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1fWIN\n");
}

void glnoopMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1fvWIN\n");
}

void glnoopMultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1iWIN\n");
}

void glnoopMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1ivWIN\n");
}

void glnoopMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1sWIN\n");
}

void glnoopMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord1svWIN\n");
}

void glnoopMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2dWIN\n");
}

void glnoopMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2dvWIN\n");
}

void glnoopMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2fWIN\n");
}

void glnoopMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2fvWIN\n");
}

void glnoopMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2iWIN\n");
}

void glnoopMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2ivWIN\n");
}

void glnoopMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2sWIN\n");
}

void glnoopMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord2svWIN\n");
}

void glnoopMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3dWIN\n");
}

void glnoopMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3dvWIN\n");
}

void glnoopMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3fWIN\n");
}

void glnoopMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3fvWIN\n");
}

void glnoopMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3iWIN\n");
}

void glnoopMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3ivWIN\n");
}

void glnoopMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3sWIN\n");
}

void glnoopMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord3svWIN\n");
}

void glnoopMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4dWIN\n");
}

void glnoopMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4dvWIN\n");
}

void glnoopMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4fWIN\n");
}

void glnoopMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4fvWIN\n");
}

void glnoopMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4iWIN\n");
}

void glnoopMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4ivWIN\n");
}

void glnoopMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4sWIN\n");
}

void glnoopMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
    WARNING_NOOP("GL Noop:glMultiTexCoord4svWIN\n");
}

void glnoopBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    WARNING_NOOP("GL Noop:glBindNthTextureWIN\n");
}

void glnoopNthTexCombineFuncWIN
    (GLuint index
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    WARNING_NOOP("GL Noop:glNthTexCombineFuncWIN\n");
}
#endif // GL_WIN_multiple_textures

GLEXTPROCTABLE glNullExtProcTable =
{
    /* Number of function entries in the table */
     sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* EXT Entry points */
    {
        glnoopDrawRangeElementsWIN,
        glnoopColorTableEXT,
        glnoopColorSubTableEXT,
        glnoopGetColorTableEXT,
        glnoopGetColorTableParameterivEXT,
        glnoopGetColorTableParameterfvEXT,
#ifdef GL_WIN_multiple_textures
        glnoopCurrentTextureIndexWIN,
        glnoopMultiTexCoord1dWIN,
        glnoopMultiTexCoord1dvWIN,
        glnoopMultiTexCoord1fWIN,
        glnoopMultiTexCoord1fvWIN,
        glnoopMultiTexCoord1iWIN,
        glnoopMultiTexCoord1ivWIN,
        glnoopMultiTexCoord1sWIN,
        glnoopMultiTexCoord1svWIN,
        glnoopMultiTexCoord2dWIN,
        glnoopMultiTexCoord2dvWIN,
        glnoopMultiTexCoord2fWIN,
        glnoopMultiTexCoord2fvWIN,
        glnoopMultiTexCoord2iWIN,
        glnoopMultiTexCoord2ivWIN,
        glnoopMultiTexCoord2sWIN,
        glnoopMultiTexCoord2svWIN,
        glnoopMultiTexCoord3dWIN,
        glnoopMultiTexCoord3dvWIN,
        glnoopMultiTexCoord3fWIN,
        glnoopMultiTexCoord3fvWIN,
        glnoopMultiTexCoord3iWIN,
        glnoopMultiTexCoord3ivWIN,
        glnoopMultiTexCoord3sWIN,
        glnoopMultiTexCoord3svWIN,
        glnoopMultiTexCoord4dWIN,
        glnoopMultiTexCoord4dvWIN,
        glnoopMultiTexCoord4fWIN,
        glnoopMultiTexCoord4fvWIN,
        glnoopMultiTexCoord4iWIN,
        glnoopMultiTexCoord4ivWIN,
        glnoopMultiTexCoord4sWIN,
        glnoopMultiTexCoord4svWIN,
        glnoopBindNthTextureWIN,
        glnoopNthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\subutil.c ===
/***************************************************************************\
* Module Name: subutil.c
*
* Section initialization code for client/server batching.
*
* Copyright (c) 1993-1996 Microsoft Corporation
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsbmsg.h"
#include "glgdimsg.h"
#include "batchinf.h"
#include "glsbcltu.h"
#include "wgldef.h"
#include "compsize.h"
#include "context.h"
#include "global.h"
#include "parray.h"
#include "lighting.h"

/******************************Public*Routine******************************\ 
* glsbAttentionAlt
*
* Calls glsbAttention() from the GLCLIENT_BEGIN macro.
* It puts a null proc at the end of the current batch and flushes the batch.
*
* Returns the new message offset and updates pMsgBatchInfo->NextOffset.
* This code is dependent on the GLCLIENT_BEGIN macro!
*
* History:
*  Thu Nov 11 18:02:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

#ifdef CHECK_HEAP
PVOID AttnLastCaller = 0, AttnLastCallersCaller = 0;
DWORD AttnCallThread = 0;
#endif

ULONG APIENTRY glsbAttentionAlt(ULONG Offset)
{
    GLMSGBATCHINFO *pMsgBatchInfo;
    ULONG  MsgSize;
    PULONG pNullProcOffset;
    POLYARRAY *pa;
    POLYMATERIAL *pm;

#ifdef PRIMITIVE_TRACK
    DbgPrint("*** glsbAttentionAlt\n");
#endif

    pa = GLTEB_CLTPOLYARRAY();
    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

#ifdef CHECK_HEAP
    AttnCallThread = GetCurrentThreadId();
    RtlValidateHeap(RtlProcessHeap(), 0, 0);
    RtlGetCallersAddress(&AttnLastCaller, &AttnLastCallersCaller);
#endif

    if (Offset == pMsgBatchInfo->FirstOffset)
        return(pMsgBatchInfo->FirstOffset);     // No messages, return

    MsgSize = pMsgBatchInfo->NextOffset - Offset;

// If we are in the begin/end bracket, remove the invalid commands issued
// since the last Begin call.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        // DrawElements should not cause a flush while building polydata's.
        // pa->aIndices can be reset by VA_DrawElementsBegin, so allow
        // this value as well.
        ASSERTOPENGL( (!pa->aIndices || 
                       (pa->aIndices == PA_aIndices_INITIAL_VALUE)),
                      "unexpected flush in DrawElements\n");
        if (Offset == pa->nextMsgOffset)
            return(Offset);
        GLSETERROR(GL_INVALID_OPERATION);
        pMsgBatchInfo->NextOffset = pa->nextMsgOffset + MsgSize;
        return(pa->nextMsgOffset);
    }

#ifdef PRIMITIVE_TRACK
    DbgPrint("! Reset on attention\n");
#endif
    
    pa->pdBufferNext = pa->pdBuffer0;       // reset vertex buffer pointer
    pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE;
    if (pm = GLTEB_CLTPOLYMATERIAL())
    pm->iMat = 0;                       // reset material pointer

    pNullProcOffset  = (ULONG *)((BYTE *)pMsgBatchInfo + Offset);
    *pNullProcOffset = 0;

// #define POLYARRAY_CHECK_COLOR_POINTERS 1
#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttentionAlt: pd 0x%x has modified color pointer\n", pd);
    }
}
#endif

    (void) __wglAttention();

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttentionAlt: pd 0x%x has BAD color pointer\n", pd);
    }
}
#endif

    pMsgBatchInfo->NextOffset = pMsgBatchInfo->FirstOffset + MsgSize;
    return(pMsgBatchInfo->FirstOffset);
}

/******************************Public*Routine******************************\
* glsbAttention
*
* Let the server know that the section needs attention
*
* History:
*  15-Oct-1993 -by- Gilman Wong [gilmanw]
* Added bCheckRC flag.
\**************************************************************************/

BOOL APIENTRY
glsbAttention ( void )
{
    BOOL bRet = FALSE;
    GLMSGBATCHINFO *pMsgBatchInfo;
    PULONG pNullProcOffset;
    POLYARRAY *pa;
    POLYMATERIAL *pm;
    DWORD flags;
    __GL_SETUP();

    pa = GLTEB_CLTPOLYARRAY();
    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;

#ifdef CHECK_HEAP
    AttnCallThread = GetCurrentThreadId();
    RtlValidateHeap(RtlProcessHeap(), 0, 0);
    RtlGetCallersAddress(&AttnLastCaller, &AttnLastCallersCaller);
#endif

    if (pMsgBatchInfo->NextOffset == pMsgBatchInfo->FirstOffset)
        return(TRUE);   // No messages, return

// If we are in the begin/end bracket, remove the invalid commands issued
// since the last Begin call.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
        // DrawElements should not cause a flush while building polydata's.
        // pa->aIndices can be reset by VA_DrawElementsBegin, so allow
        // the reset value as well.
        ASSERTOPENGL( (!pa->aIndices || 
                       (pa->aIndices == PA_aIndices_INITIAL_VALUE)),
                      "unexpected flush in DrawElements\n");
        if (pMsgBatchInfo->NextOffset == pa->nextMsgOffset)
            return(TRUE);
        GLSETERROR(GL_INVALID_OPERATION);
        pMsgBatchInfo->NextOffset = pa->nextMsgOffset;
        return(TRUE);
    }

#ifdef PRIMITIVE_TRACK
    DbgPrint("! Reset on attention\n");
#endif
    
    pa->pdBufferNext = pa->pdBuffer0;       // reset vertex buffer pointer
    pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE; // reset next DPA message offset
    if (pm = GLTEB_CLTPOLYMATERIAL())
        pm->iMat = 0;                       // reset material pointer

    pNullProcOffset  = (ULONG *)((BYTE *)pMsgBatchInfo + pMsgBatchInfo->NextOffset);
    *pNullProcOffset = 0;

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttention: pd 0x%x has modified color pointer\n", pd);
    }
}
#endif

    bRet = __wglAttention();

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbAttention: pd 0x%x has BAD color pointer\n", pd);
    }
}
#endif

    // Clear the Evaluator state flags
    flags = GET_EVALSTATE (gc);
    flags = flags & ~(__EVALS_AFFECTS_1D_EVAL|
                      __EVALS_AFFECTS_2D_EVAL|
                      __EVALS_AFFECTS_ALL_EVAL|
                      __EVALS_PUSH_EVAL_ATTRIB|
                      __EVALS_POP_EVAL_ATTRIB);
    SET_EVALSTATE (gc, flags);

    pMsgBatchInfo->NextOffset = pMsgBatchInfo->FirstOffset;
    return(bRet);
}

/******************************Public*Routine******************************\
* glsbResetBuffers
*
* Reset the command buffer, the poly array buffer, and the poly material
* buffer.
*
* History:
*  Tue Jan 09 17:38:22 1996     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID APIENTRY glsbResetBuffers(BOOL bRestoreColorPointer)
{
    GLMSGBATCHINFO *pMsgBatchInfo;
    POLYARRAY *pa;
    POLYMATERIAL *pm;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray;

    pa = GLTEB_CLTPOLYARRAY();

    // Reset command buffer
    pMsgBatchInfo = (GLMSGBATCHINFO *) pa->pMsgBatchInfo;
    pMsgBatchInfo->NextOffset = pMsgBatchInfo->FirstOffset;

#ifdef PRIMITIVE_TRACK
    DbgPrint("! Reset on ResetBuffers\n");
#endif

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbResetBuffers: pd 0x%x has modified color pointer\n",pd);
    }
}
#endif

    // In COMPILE mode, restore color pointer in the vertex buffer that
    // may have been overwritten by the POLYARRAY structure.  In normal
    // and COMPILE_AND_EXECUTE modes, the server takes care of this.
    // In addition, there can be no more than one DrawPolyArray command
    // in the batch in COMPILE mode.
    if (bRestoreColorPointer)
    {
        POLYARRAY *paCmd;
        POLYDATA  *pd, *pdLast;
        
        // See also PolyArrayRestoreColorPointer
#if DBG
        __GL_SETUP();
        ASSERTOPENGL(gc->dlist.mode == GL_COMPILE, "not in compile mode\n");
#endif
        pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *)
          ((BYTE *) pMsgBatchInfo + pa->nextMsgOffset -
           GLMSG_ALIGN(sizeof(GLMSG_DRAWPOLYARRAY)));
        paCmd = (POLYARRAY *) pMsgDrawPolyArray->paLast;

        ASSERTOPENGL(pMsgDrawPolyArray->pa0 == pMsgDrawPolyArray->paLast &&
                     paCmd->paNext == NULL,
                     "DrawPolyArray chain unexpected in COMPILE mode\n");
        
        // Reset color pointer in output index array
        if (paCmd->aIndices && (paCmd->aIndices != PA_aIndices_INITIAL_VALUE))
        {
            pdLast = (POLYDATA *) (paCmd->aIndices + paCmd->nIndices);
            for (pd = (POLYDATA *) paCmd->aIndices; pd < pdLast; pd++)
                pd->color = &pd->colors[__GL_FRONTFACE];

            ASSERTOPENGL(pd >= pa->pdBuffer0 &&
                         pd <= pa->pdBufferMax + 1,
                         "bad polyarray pointer\n");
        }

        // Reset color pointer in the POLYARRAY structure last!
        ASSERTOPENGL((POLYDATA *) paCmd >= pa->pdBuffer0 &&
                     (POLYDATA *) paCmd <= pa->pdBufferMax,
                     "bad polyarray pointer\n");
        ((POLYDATA *) paCmd)->color =
          &((POLYDATA *) paCmd)->colors[__GL_FRONTFACE];
    }

    // Reset material pointer
    if (pm = GLTEB_CLTPOLYMATERIAL())
        pm->iMat = 0;

    // Reset vertex buffer pointer
    pa->pdBufferNext = pa->pdBuffer0; 

    // Reset next DPA message offset
    pa->nextMsgOffset = PA_nextMsgOffset_RESET_VALUE;

#if POLYARRAY_CHECK_COLOR_POINTERS
{
    POLYDATA *pd;
    for (pd = pa->pdBuffer0; pd < pa->pdBufferMax; pd++)
    {
        if (pd->color != &pd->colors[__GL_FRONTFACE])
            DbgPrint("glsbResetBuffers: pd 0x%x has BAD color pointer\n", pd);
    }
}
#endif
}

#if 0
// REWRITE THIS IF NEEDED

/******************************Public*Routine******************************\
* glsbMsgStats
*
* Batch area statistics.
*
*
* History:
\**************************************************************************/

BOOL APIENTRY
glsbMsgStats ( LONG Action, GLMSGBATCHSTATS *BatchStats )
{
#ifdef DOGLMSGBATCHSTATS

    ULONG Result;
    GLMSGBATCHINFO *pMsgBatchInfo;

    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();

    if ( GLMSGBATCHSTATS_GETSTATS == Action )
    {
        BatchStats->ClientCalls  = pMsgBatchInfo->BatchStats.ClientCalls;
    }
    else
    {
        pMsgBatchInfo->BatchStats.ClientCalls = 0;
    }

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    BEGINMSG( MSG_GLMSGBATCHSTATS, GLSBMSGSTATS )
        pmsg->Action = Action;

        Result = CALLSERVER();

        if ( TRUE == Result )
        {
            if ( GLMSGBATCHSTATS_GETSTATS == Action )
            {
                BatchStats->ServerTrips = pmsg->BatchStats.ServerTrips;
                BatchStats->ServerCalls = pmsg->BatchStats.ServerCalls;
            }
        }
        else
        {
            DBGERROR("glsbMsgStats(): Server returned FALSE\n");
        }

    ENDMSG
MSGERROR:
    return((BOOL)Result);

#else

    return(FALSE);

#endif /* DOGLMSGBATCHSTATS */
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\varray.c ===
/****************************************************************************\
*
* Client side vertex array
*
* History
*   16-Jan-1995 mikeke    Created
*
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>

#include "compsize.h"
#include "glsize.h"

/****************************************************************************/

#if DBG
// The WARNING_NOOP macro will output the debug message once only.
// If we have output a warning before, the new warnings are ignored.

static int cWarningNoop = 0;

#define WARNING_NOOP(str)                                       \
        {                                                       \
            if (!cWarningNoop++)                                \
                DbgPrint("%s(%d): " str,__FILE__,__LINE__);     \
        }
#else
#define WARNING_NOOP(str)
#endif // DBG

/****************************************************************************/

PFNCLTVECTOR ppfnvTexCoord[32] = {
    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord1sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord1iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord1fv,
    (PFNCLTVECTOR)glTexCoord1dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord2sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord2iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord2fv,
    (PFNCLTVECTOR)glTexCoord2dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord3sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord3iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord3fv,
    (PFNCLTVECTOR)glTexCoord3dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glTexCoord4sv,
    NULL,
    (PFNCLTVECTOR)glTexCoord4iv,
    NULL,
    (PFNCLTVECTOR)glTexCoord4fv,
    (PFNCLTVECTOR)glTexCoord4dv,
};

PFNCLTVECTOR ppfnvVertex[32] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    (PFNCLTVECTOR)glVertex2sv,
    NULL,
    (PFNCLTVECTOR)glVertex2iv,
    NULL,
    (PFNCLTVECTOR)glVertex2fv,
    (PFNCLTVECTOR)glVertex2dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glVertex3sv,
    NULL,
    (PFNCLTVECTOR)glVertex3iv,
    NULL,
    (PFNCLTVECTOR)glVertex3fv,
    (PFNCLTVECTOR)glVertex3dv,

    NULL,
    NULL,
    (PFNCLTVECTOR)glVertex4sv,
    NULL,
    (PFNCLTVECTOR)glVertex4iv,
    NULL,
    (PFNCLTVECTOR)glVertex4fv,
    (PFNCLTVECTOR)glVertex4dv,
};

PFNCLTVECTOR ppfnvIndex[32] = {
    NULL,
    NULL,
    (PFNCLTVECTOR)glIndexsv,
    NULL,
    (PFNCLTVECTOR)glIndexiv,
    NULL,
    (PFNCLTVECTOR)glIndexfv,
    (PFNCLTVECTOR)glIndexdv,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

PFNCLTVECTOR ppfnvEdgeFlag[32] = {
    NULL,
    (PFNCLTVECTOR)glEdgeFlagv,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

PFNCLTVECTOR ppfnvColor[32] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    (PFNCLTVECTOR)glColor3bv,
    (PFNCLTVECTOR)glColor3ubv,
    (PFNCLTVECTOR)glColor3sv,
    (PFNCLTVECTOR)glColor3usv,
    (PFNCLTVECTOR)glColor3iv,
    (PFNCLTVECTOR)glColor3uiv,
    (PFNCLTVECTOR)glColor3fv,
    (PFNCLTVECTOR)glColor3dv,

    (PFNCLTVECTOR)glColor4bv,
    (PFNCLTVECTOR)glColor4ubv,
    (PFNCLTVECTOR)glColor4sv,
    (PFNCLTVECTOR)glColor4usv,
    (PFNCLTVECTOR)glColor4iv,
    (PFNCLTVECTOR)glColor4uiv,
    (PFNCLTVECTOR)glColor4fv,
    (PFNCLTVECTOR)glColor4dv,
};

PFNCLTVECTOR ppfnvNormal[32] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    (PFNCLTVECTOR)glNormal3bv,
    NULL,
    (PFNCLTVECTOR)glNormal3sv,
    NULL,
    (PFNCLTVECTOR)glNormal3iv,
    NULL,
    (PFNCLTVECTOR)glNormal3fv,
    (PFNCLTVECTOR)glNormal3dv,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

/****************************************************************************/

static void cltSetupArrayPointer(
    PCLTARRAYPOINTER pap,
    PFNCLTVECTOR* ppfnVector)
{
    GLint itype;

    switch (pap->type) {
        case GL_BYTE:           itype = 0; break;
        case GL_UNSIGNED_BYTE:  itype = 1; break;
        case GL_SHORT:          itype = 2; break;
        case GL_UNSIGNED_SHORT: itype = 3; break;
        case GL_INT:            itype = 4; break;
        case GL_UNSIGNED_INT:   itype = 5; break;
        case GL_FLOAT:          itype = 6; break;
        case GL_DOUBLE_EXT:     itype = 7; break;
    }

    if (pap->stride != 0) {
        pap->ibytes = pap->stride;
    } else {
        pap->ibytes = __GLTYPESIZE(pap->type) * pap->size;
    }

    pap->pfn = ppfnVector[itype + (pap->size - 1) * 8];
}

/****************************************************************************/

void APIENTRY glsimVertexPointerEXT(
    GLint size,
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glVertexPointerEXT\n");
        return;
    }

    if (size < 2 || size > 4 || stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apVertex.size    = size   ;
    plrc->apVertex.type    = type   ;
    plrc->apVertex.stride  = stride ;
    plrc->apVertex.count   = count  ;
    plrc->apVertex.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apVertex), ppfnvVertex);
}

void APIENTRY glsimColorPointerEXT(
    GLint size,
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glColorPointerEXT\n");
        return;
    }

    if (size < 3 || size > 4 || stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_BYTE:           break;
        case GL_UNSIGNED_BYTE:  break;
        case GL_SHORT:          break;
        case GL_UNSIGNED_SHORT: break;
        case GL_INT:            break;
        case GL_UNSIGNED_INT:   break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apColor.size    = size   ;
    plrc->apColor.type    = type   ;
    plrc->apColor.stride  = stride ;
    plrc->apColor.count   = count  ;
    plrc->apColor.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apColor), ppfnvColor);
}

void APIENTRY glsimTexCoordPointerEXT(
    GLint size,
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glTexCoordPointerEXT\n");
        return;
    }

    if (size < 1 || size > 4 || stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apTexCoord.size    = size   ;
    plrc->apTexCoord.type    = type   ;
    plrc->apTexCoord.stride  = stride ;
    plrc->apTexCoord.count   = count  ;
    plrc->apTexCoord.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apTexCoord), ppfnvTexCoord);
}

void APIENTRY glsimNormalPointerEXT(
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glNormalPointerEXT\n");
        return;
    }

    if (stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_BYTE:           break;
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apNormal.size    = 3      ;
    plrc->apNormal.type    = type   ;
    plrc->apNormal.stride  = stride ;
    plrc->apNormal.count   = count  ;
    plrc->apNormal.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apNormal), ppfnvNormal);
}

void APIENTRY glsimIndexPointerEXT(
    GLenum type,
    GLsizei stride,
    GLsizei count,
    const GLvoid* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glIndexPointerEXT\n");
        return;
    }

    if (stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    switch (type) {
        case GL_SHORT:          break;
        case GL_INT:            break;
        case GL_FLOAT:          break;
        case GL_DOUBLE_EXT:     break;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }

    plrc->apIndex.size    = 1      ;
    plrc->apIndex.type    = type   ;
    plrc->apIndex.stride  = stride ;
    plrc->apIndex.count   = count  ;
    plrc->apIndex.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apIndex), ppfnvIndex);
}

void APIENTRY glsimEdgeFlagPointerEXT(
    GLsizei stride,
    GLsizei count,
    const GLboolean* pointer)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glEdgeFlagPointerEXT\n");
        return;
    }

    if (stride < 0 || count < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    } 

    plrc->apEdgeFlag.size    = 1;
    plrc->apEdgeFlag.type    = GL_UNSIGNED_BYTE;
    plrc->apEdgeFlag.stride  = stride ;
    plrc->apEdgeFlag.count   = count  ;
    plrc->apEdgeFlag.pointer = (GLbyte*)pointer;

    cltSetupArrayPointer(&(plrc->apEdgeFlag), ppfnvEdgeFlag);
}

/****************************************************************************/

#define CALLARRAYPOINTER(ap) \
    if ((ap).fEnabled) \
        (((ap).pfn)((ap).pointer + i * (ap).ibytes))

void APIENTRY glsimArrayElementEXT(
    GLint i)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glArrayElementEXT\n");
        return;
    }

    CALLARRAYPOINTER(plrc->apNormal);
    CALLARRAYPOINTER(plrc->apColor);
    CALLARRAYPOINTER(plrc->apIndex);
    CALLARRAYPOINTER(plrc->apTexCoord);
    CALLARRAYPOINTER(plrc->apEdgeFlag);
    CALLARRAYPOINTER(plrc->apVertex);
}

/****************************************************************************/

void APIENTRY glsimArrayElementArrayEXT(
    GLenum mode,
    GLsizei count,
    const GLvoid* pi)
{
    int i;

    switch(mode) {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_LINE_LOOP:
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_TRIANGLE_FAN:
      case GL_TRIANGLES:
      case GL_QUAD_STRIP:
      case GL_QUADS:
      case GL_POLYGON:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (count < 0) {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    glBegin(mode);

    for (i = 0; i < count; i++) {
        glsimArrayElementEXT(((GLint *)pi)[i]);
    }

    glEnd();
}

/****************************************************************************/

void APIENTRY glsimDrawArraysEXT(
    GLenum mode,
    GLint first,
    GLsizei count)
{
    int i;
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glDrawArrayEXT\n");
        return;
    }

    switch(mode) {
      case GL_POINTS:
      case GL_LINE_STRIP:
      case GL_LINE_LOOP:
      case GL_LINES:
      case GL_TRIANGLE_STRIP:
      case GL_TRIANGLE_FAN:
      case GL_TRIANGLES:
      case GL_QUAD_STRIP:
      case GL_QUADS:
      case GL_POLYGON:
	break;
      default:
        GLSETERROR(GL_INVALID_ENUM);
        return;
    }

    if (count < 0) {
        GLSETERROR(GL_INVALID_VALUE);
        return;
    }

    glBegin(mode);

    for (i = 0; i < count; i++) {
        glsimArrayElementEXT(first + i);
    }

    glEnd();
}

/****************************************************************************/

void APIENTRY glsimGetPointervEXT(
    GLenum pname,
    void** params)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetPointerEXT\n");
        return;
    }

    switch (pname) {
	case GL_VERTEX_ARRAY_POINTER_EXT:        *params = plrc->apVertex.pointer  ; return;
	case GL_NORMAL_ARRAY_POINTER_EXT:        *params = plrc->apNormal.pointer  ; return;
	case GL_COLOR_ARRAY_POINTER_EXT:         *params = plrc->apColor.pointer   ; return;
	case GL_INDEX_ARRAY_POINTER_EXT:         *params = plrc->apIndex.pointer   ; return;
	case GL_TEXTURE_COORD_ARRAY_POINTER_EXT: *params = plrc->apTexCoord.pointer; return;
	case GL_EDGE_FLAG_ARRAY_POINTER_EXT:     *params = plrc->apEdgeFlag.pointer; return;
        default:
            GLSETERROR(GL_INVALID_ENUM);
            return;
    }
}

/****************************************************************************/

GLubyte* EXTENSIONSTRING = "GL_EXT_vertex_array";

const GLubyte * APIENTRY VArrayGetString( IN GLenum name )
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLubyte *psz;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetString\n");
        return 0;
    }

    psz = (GLubyte*)plrc->pfnGetString(name);

    if (name == GL_EXTENSIONS) {

// The vertex array extension string is already in the generic GetString.
        if (!plrc->dhrc)
	    return psz;

        if (psz == NULL) {
            return EXTENSIONSTRING;
        }

        if (plrc->pszExtensions == NULL) {
            plrc->pszExtensions = (GLubyte*)LOCALALLOC(LPTR, strlen(psz) + strlen(EXTENSIONSTRING) + 2);
            sprintf(plrc->pszExtensions, "%s %s", EXTENSIONSTRING, psz);
        }

        return plrc->pszExtensions;
    }
    return psz;
}

/****************************************************************************/

void APIENTRY VArrayEnable(
    IN GLenum cap)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glEnable\n");
        return;
    }

    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:        plrc->apNormal.fEnabled = TRUE;   return;
        case GL_COLOR_ARRAY_EXT:         plrc->apColor.fEnabled = TRUE;    return;
        case GL_INDEX_ARRAY_EXT:         plrc->apIndex.fEnabled = TRUE;    return;
        case GL_TEXTURE_COORD_ARRAY_EXT: plrc->apTexCoord.fEnabled = TRUE; return;
        case GL_EDGE_FLAG_ARRAY_EXT:     plrc->apEdgeFlag.fEnabled = TRUE; return;
        case GL_VERTEX_ARRAY_EXT:        plrc->apVertex.fEnabled = TRUE;   return;
    }

    plrc->pfnEnable(cap);
}

/****************************************************************************/

void APIENTRY VArrayDisable(
    IN GLenum cap)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glDisable\n");
        return;
    }

    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:        plrc->apNormal.fEnabled = FALSE;   return;
        case GL_COLOR_ARRAY_EXT:         plrc->apColor.fEnabled = FALSE;    return;
        case GL_INDEX_ARRAY_EXT:         plrc->apIndex.fEnabled = FALSE;    return;
        case GL_TEXTURE_COORD_ARRAY_EXT: plrc->apTexCoord.fEnabled = FALSE; return;
        case GL_EDGE_FLAG_ARRAY_EXT:     plrc->apEdgeFlag.fEnabled = FALSE; return;
        case GL_VERTEX_ARRAY_EXT:        plrc->apVertex.fEnabled = FALSE;   return;
    }

    plrc->pfnDisable(cap);
}

/****************************************************************************/

GLboolean APIENTRY VArrayIsEnabled(
    IN GLenum cap)
{
    PLRC plrc = GLTEB_CLTCURRENTRC();

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glIsEnabled\n");
        return 0;
    }

    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:        return plrc->apNormal.fEnabled;
        case GL_COLOR_ARRAY_EXT:         return plrc->apColor.fEnabled;
        case GL_INDEX_ARRAY_EXT:         return plrc->apIndex.fEnabled;
        case GL_TEXTURE_COORD_ARRAY_EXT: return plrc->apTexCoord.fEnabled;
        case GL_EDGE_FLAG_ARRAY_EXT:     return plrc->apEdgeFlag.fEnabled;
        case GL_VERTEX_ARRAY_EXT:        return plrc->apVertex.fEnabled;
    }

    return plrc->pfnIsEnabled(cap);
}

/****************************************************************************/

BOOL VArrayGetIntegerInternal(
    PLRC plrc,
    GLenum cap,
    GLint *pi)
{
    switch (cap) {
        case GL_NORMAL_ARRAY_EXT:               *pi = plrc->apNormal.fEnabled;   return TRUE;
        case GL_COLOR_ARRAY_EXT:                *pi = plrc->apColor.fEnabled;    return TRUE;
        case GL_INDEX_ARRAY_EXT:                *pi = plrc->apIndex.fEnabled;    return TRUE;
        case GL_TEXTURE_COORD_ARRAY_EXT:        *pi = plrc->apTexCoord.fEnabled; return TRUE;
        case GL_EDGE_FLAG_ARRAY_EXT:            *pi = plrc->apEdgeFlag.fEnabled; return TRUE;
        case GL_VERTEX_ARRAY_EXT:               *pi = plrc->apVertex.fEnabled;   return TRUE;

	case GL_VERTEX_ARRAY_SIZE_EXT:          *pi = plrc->apVertex.size  ;     return TRUE;
	case GL_VERTEX_ARRAY_TYPE_EXT:          *pi = plrc->apVertex.type  ;     return TRUE;
	case GL_VERTEX_ARRAY_STRIDE_EXT:        *pi = plrc->apVertex.stride;     return TRUE;
	case GL_VERTEX_ARRAY_COUNT_EXT:         *pi = plrc->apVertex.count ;     return TRUE;

	case GL_NORMAL_ARRAY_TYPE_EXT:          *pi = plrc->apNormal.type  ;     return TRUE;
	case GL_NORMAL_ARRAY_STRIDE_EXT:        *pi = plrc->apNormal.stride;     return TRUE;
	case GL_NORMAL_ARRAY_COUNT_EXT:         *pi = plrc->apNormal.count ;     return TRUE;

	case GL_COLOR_ARRAY_SIZE_EXT:           *pi = plrc->apColor.size  ;      return TRUE;
	case GL_COLOR_ARRAY_TYPE_EXT:           *pi = plrc->apColor.type  ;      return TRUE;
	case GL_COLOR_ARRAY_STRIDE_EXT:         *pi = plrc->apColor.stride;      return TRUE;
	case GL_COLOR_ARRAY_COUNT_EXT:          *pi = plrc->apColor.count ;      return TRUE;

	case GL_INDEX_ARRAY_TYPE_EXT:           *pi = plrc->apIndex.type  ;      return TRUE;
	case GL_INDEX_ARRAY_STRIDE_EXT:         *pi = plrc->apIndex.stride;      return TRUE;
	case GL_INDEX_ARRAY_COUNT_EXT:          *pi = plrc->apIndex.count ;      return TRUE;

	case GL_TEXTURE_COORD_ARRAY_SIZE_EXT:   *pi = plrc->apTexCoord.size  ;   return TRUE;
	case GL_TEXTURE_COORD_ARRAY_TYPE_EXT:   *pi = plrc->apTexCoord.type  ;   return TRUE;
	case GL_TEXTURE_COORD_ARRAY_STRIDE_EXT: *pi = plrc->apTexCoord.stride;   return TRUE;
	case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:  *pi = plrc->apTexCoord.count ;   return TRUE;

	case GL_EDGE_FLAG_ARRAY_STRIDE_EXT:     *pi = plrc->apEdgeFlag.stride;   return TRUE;
	case GL_EDGE_FLAG_ARRAY_COUNT_EXT:      *pi = plrc->apEdgeFlag.count ;   return TRUE;
    }
    return FALSE;
}

/****************************************************************************/

void APIENTRY VArrayGetBooleanv(
    IN GLenum pname,
    OUT GLboolean params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetBooleanv\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = glint ? 1 : 0;
        return;
    }

    plrc->pfnGetBooleanv(pname, params);
}
/****************************************************************************/

void APIENTRY VArrayGetDoublev(
    IN GLenum pname,
    OUT GLdouble params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetDoublev\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = (GLdouble)glint;
        return;
    }

    plrc->pfnGetDoublev(pname, params);
}
/****************************************************************************/

void APIENTRY VArrayGetFloatv(
    IN GLenum pname,
    OUT GLfloat params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetFloatv\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = (GLfloat)glint;
        return;
    }

    plrc->pfnGetFloatv(pname, params);
}
/****************************************************************************/

void APIENTRY VArrayGetIntegerv(
    IN GLenum pname,
    OUT GLint params[])
{
    PLRC plrc = GLTEB_CLTCURRENTRC();
    GLint glint;

    if (plrc == NULL) {
        WARNING_NOOP("GL Noop:glGetIntegerv\n");
        return;
    }

    if (VArrayGetIntegerInternal(plrc, pname, &glint)) {
        params[0] = glint;
        return;
    }

    plrc->pfnGetIntegerv(pname, params);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\swapmult.c ===
/******************************Module*Header*******************************\
* Module Name: swapmult.c
*
* wglSwapMultiple implementation
*
* Created: 02-10-1997
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1993-1997 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <gencx.h>
#include <mcdcx.h>

/******************************Public*Routine******************************\
*
* BufferSwapperType
*
* Determines what basic type of swapper is responsible for the given
* swap info.
*
* History:
*  Mon Oct 14 18:46:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define BSWP_ICD        0
#define BSWP_MCD        1
#define BSWP_GENERIC    2

int BufferSwapperType(GENMCDSWAP *pgms)
{
    // The buffer can be for an ICD, an MCD or generic
    // 1.  ICD buffers have an ICD pixel format
    // 2.  MCD buffers have MCD state
    
    if (pgms->pwnd->ipfd <= pgms->pwnd->ipfdDevMax)
    {
        return BSWP_ICD;
    }
    else
    {
        if (pgms->pwnd->buffers != NULL)
        {
            if (pgms->pwnd->buffers->pMcdSurf != NULL)
            {
                return BSWP_MCD;
            }
        }
    }

    return BSWP_GENERIC;
}

/******************************Public*Routine******************************\
*
* SameSwapper
*
* Checks whether the two swapinfos are swapped by the same swapping
* agency.
*
* History:
*  Mon Oct 14 18:49:26 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL SameSwapper(int iSwapperTypeA, GENMCDSWAP *pgmsA, GENMCDSWAP *pgmsB)
{
    switch(iSwapperTypeA)
    {
    case BSWP_ICD:
        // Must be the same ICD
        if (BufferSwapperType(pgmsB) != BSWP_ICD ||
            pgmsA->pwnd->pvDriver != pgmsB->pwnd->pvDriver)
        {
            return FALSE;
        }
        return TRUE;
        
    case BSWP_MCD:
    case BSWP_GENERIC:
        // No way to refine the comparison any more
        return BufferSwapperType(pgmsB) == iSwapperTypeA;

    default:
        ASSERTOPENGL(FALSE, "SameSwapper UNREACHED\n");
        return FALSE;
    }
}

/******************************Public*Routine******************************\
*
* wglSwapMultipleBuffers
*
* Swaps as many of the given buffers as possible.
* Returns a bitmask of the buffers that were swapped.
*
* History:
*  Mon Oct 14 17:19:09 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

// #define VERBOSE_MULTI

DWORD WINAPI wglSwapMultipleBuffers(UINT cBuffers, CONST WGLSWAP *pwswapAll)
{
    GENMCDSWAP agmsAll[WGL_SWAPMULTIPLE_MAX];
    GENMCDSWAP *pgmsFirst;
    GENMCDSWAP *pgmsEnd;
    GENMCDSWAP *pgms;
    GENMCDSWAP *apgmsGroup[WGL_SWAPMULTIPLE_MAX];
    GENMCDSWAP **ppgmsGroup;
    WGLSWAP *pwswap;
    DWORD dwMask;
    UINT uiCur;
    UINT uiIdx;
    GLWINDOWID gwid;
    GLGENwindow *pwnd;
    DWORD dwBit;
    DWORD dwCallMask;
    DWORD adwCallIndex[WGL_SWAPMULTIPLE_MAX];
    DWORD *pdwCallIndex;
    DWORD cGroup;
    DWORD cDone;
    int iSwapperType;
    BOOL bCall;

    ASSERTOPENGL(WGL_SWAPMULTIPLE_MAX <= 16,
                 "WGL_SWAPMULTIPLE_MAX too large\n");
    ASSERTOPENGL(WGL_SWAPMULTIPLE_MAX == OPENGLCMD_MAXMULTI &&
                 WGL_SWAPMULTIPLE_MAX == MCDESC_MAX_EXTRA_WNDOBJ,
                 "WGL_SWAPMULTIPLE_MAX mismatch\n");

    if (cBuffers > WGL_SWAPMULTIPLE_MAX)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return 0;
    }
    
    dwMask = 0;
    
    // Validate all input buffers and do one-time information gathering for
    // them.
    pgms = agmsAll;
    pwswap = (WGLSWAP *)pwswapAll;
    for (uiCur = 0; uiCur < cBuffers; uiCur++, pwswap++)
    {
        // Validate DC
        if (IsDirectDrawDevice(pwswap->hdc))
        {
            continue;
        }
    
        switch(GetObjectType(pwswap->hdc))
        {
        case OBJ_DC:
            break;
            
        case OBJ_MEMDC:
            // Nothing to do for memdc
            dwMask |= 1 << uiCur;
            
            // Fall through
            
        default:
            continue;
        }

        // Look up pwnd
        WindowIdFromHdc(pwswap->hdc, &gwid);
        pwnd = pwndGetFromID(&gwid);
        if (pwnd == NULL)
        {
            continue;
        }

        if (pwnd->ipfd == 0)
        {
            pwndRelease(pwnd);
            continue;
        }

        // We have a valid candidate for swapping.  Remember it.
        pgms->pwswap = pwswap;
        pgms->pwnd = pwnd;
        pgms++;
    }

#ifdef VERBOSE_MULTI
    DbgPrint("%d cand\n", pgms-agmsAll);
#endif
    
    // Walk list of candidates and gather by swapper
    pgmsEnd = pgms;
    pgmsFirst = agmsAll;
    while (pgmsFirst < pgmsEnd)
    {
        // Skip over any candidates that have already been swapped
        if (pgmsFirst->pwswap == NULL)
        {
            pgmsFirst++;
            continue;
        }

        iSwapperType = BufferSwapperType(pgmsFirst);

#ifdef VERBOSE_MULTI
        DbgPrint("  Gathering for %d, type %d\n", pgmsFirst-agmsAll,
                 iSwapperType);
#endif
        
        ppgmsGroup = apgmsGroup;
        *ppgmsGroup++ = pgmsFirst;
        pgmsFirst++;

        pgms = pgmsFirst;
        while (pgms < pgmsEnd)
        {
            if (pgms->pwswap != NULL)
            {
                if (SameSwapper(iSwapperType, apgmsGroup[0], pgms))
                {
#ifdef VERBOSE_MULTI
                    DbgPrint("  Match with %d\n", pgms-agmsAll);
#endif
                    
                    *ppgmsGroup++ = pgms;
                }
            }

            pgms++;
        }

        // Dispatch group to swapper for swapping.  This may require
        // multiple attempts because the same swapper may be responsible
        // for multiple devices and only one device can be handled at
        // a time.
        
        cGroup = (DWORD)((ULONG_PTR)(ppgmsGroup-apgmsGroup));

#ifdef VERBOSE_MULTI
        DbgPrint("  Group of %d\n", cGroup);
#endif
        
        cDone = 0;
        while (cDone < cGroup)
        {
            WGLSWAP awswapIcdCall[WGL_SWAPMULTIPLE_MAX];
            PGLDRIVER pgldrv;
            GENMCDSWAP agmsMcdCall[WGL_SWAPMULTIPLE_MAX];
            GENMCDSWAP *pgmsCall;
            
            // Collect any remaining swaps into calling format
            pdwCallIndex = adwCallIndex;
            pgms = NULL;

            // After each case, uiCur must be set to the number of
            // swaps attempted and dwMask must be set to the
            // attempted/succeeded mask.
            
            switch(iSwapperType)
            {
            case BSWP_ICD:
                pwswap = awswapIcdCall;
                for (uiCur = 0; uiCur < cGroup; uiCur++)
                {
                    if (apgmsGroup[uiCur] != NULL)
                    {
                        pgms = apgmsGroup[uiCur];
                        *pwswap++ = *pgms->pwswap;
                        *pdwCallIndex++ = uiCur;
                    }
                }

                uiCur = (UINT)((ULONG_PTR)(pwswap-awswapIcdCall));
                
                // Quit if nothing remaining
                if (uiCur == 0)
                {
                    dwCallMask = 0;
                }
                else
                {
                    pgldrv = (PGLDRIVER)pgms->pwnd->pvDriver;
                    ASSERTOPENGL(pgldrv != NULL,
                                 "ICD not loaded\n");
                    
                    // Ask for swap

                    // If the ICD supports SwapMultiple, pass the call on
                    if (pgldrv->pfnDrvSwapMultipleBuffers != NULL)
                    {
                        dwCallMask = pgldrv->
                            pfnDrvSwapMultipleBuffers(uiCur, awswapIcdCall);
                    }
                    else if (pgldrv->pfnDrvSwapLayerBuffers != NULL)
                    {
                        // The ICD doesn't support multiple swap but
                        // it does support layer swaps so iterate
                        // through all the separate swaps.
                        
                        dwCallMask = 0;
                        dwBit = 1 << (uiCur-1);
                        while (--pwswap >= awswapIcdCall)
                        {
                            // Every swap is attempted
                            dwCallMask |= dwBit << (32-WGL_SWAPMULTIPLE_MAX);

                            if (pgldrv->
                                pfnDrvSwapLayerBuffers(pwswap->hdc,
                                                       pwswap->uiFlags))
                            {
                                dwCallMask |= dwBit;
                            }

                            dwBit >>= 1;
                        }
                    }
                    else
                    {
                        // The ICD only supports SwapBuffers so
                        // iterate and swap all main plane requests.
                        // Any overlay plane swaps are ignored and
                        // reported as successful.
                        
                        dwCallMask = 0;
                        dwBit = 1 << (uiCur-1);
                        while (--pwswap >= awswapIcdCall)
                        {
                            // Every swap is attempted
                            dwCallMask |= dwBit << (32-WGL_SWAPMULTIPLE_MAX);

                            if (pwswap->uiFlags & WGL_SWAP_MAIN_PLANE)
                            {
                                bCall = __DrvSwapBuffers(pwswap->hdc, FALSE);
                            }
                            else
                            {
                                bCall = TRUE;
                            }

                            if (bCall)
                            {
                                dwCallMask |= dwBit;
                            }

                            dwBit >>= 1;
                        }
                    }
                }
                break;
            
            case BSWP_MCD:
                pgmsCall = agmsMcdCall;
                for (uiCur = 0; uiCur < cGroup; uiCur++)
                {
                    if (apgmsGroup[uiCur] != NULL)
                    {
                        pgms = apgmsGroup[uiCur];
                        *pgmsCall++ = *pgms;
                        *pdwCallIndex++ = uiCur;
                    }
                }

                uiCur = (UINT)((ULONG_PTR)(pgmsCall-agmsMcdCall));
                
                // Quit if nothing remaining
                if (uiCur == 0)
                {
                    dwCallMask = 0;
                }
                else
                {
                    // Ask for swap
                    dwCallMask = GenMcdSwapMultiple(uiCur, agmsMcdCall);
                }
                break;

            case BSWP_GENERIC:
                // No accleration exists so just iterate and swap
                dwCallMask = 0;
                dwBit = 1;
                for (uiCur = 0; uiCur < cGroup; uiCur++)
                {
                    pgms = apgmsGroup[uiCur];
                    *pdwCallIndex++ = uiCur;

                    // Every swap is attempted
                    dwCallMask |= dwBit << (32-WGL_SWAPMULTIPLE_MAX);

                    // Since this is a generic swap we only swap the
                    // main plane.  Overlay planes are ignored and
                    // reported as successful.
                    if (pgms->pwswap->uiFlags & WGL_SWAP_MAIN_PLANE)
                    {
                        ENTER_WINCRIT(pgms->pwnd);

                        bCall = glsrvSwapBuffers(pgms->pwswap->hdc,
                                                 pgms->pwnd);
                        
                        LEAVE_WINCRIT(pgms->pwnd);
                    }
                    else
                    {
                        bCall = TRUE;
                    }

                    if (bCall)
                    {
                        dwCallMask |= dwBit;
                    }
                    
                    dwBit <<= 1; 
                }
                break;
            }

#ifdef VERBOSE_MULTI
            DbgPrint("  Attempted %d, mask %X\n", uiCur, dwCallMask);
#endif
            
            // Quit if nothing was swapped.
            if (dwCallMask == 0)
            {
                break;
            }
        
            // Determine which buffers were really swapped and
            // clear any buffers for which a swap was attempted.
            dwBit = 1 << (uiCur-1);
            while (uiCur-- > 0)
            {
                uiIdx = adwCallIndex[uiCur];
                pgms = apgmsGroup[uiIdx];
                
                if (dwCallMask & dwBit)
                {
                    dwMask |= 1 << (pgms->pwswap-pwswapAll);
                }
                if ((dwCallMask >> (32-WGL_SWAPMULTIPLE_MAX)) & dwBit)
                {
                    // Take out of overall list
                    pgms->pwswap = NULL;
                    
                    // Take out of group list
                    apgmsGroup[uiIdx] = NULL;

                    cDone++;
                }
                
                dwBit >>= 1;
            }

#ifdef VERBOSE_MULTI
            DbgPrint("  Done with %d, mask %X\n", cDone, dwMask);
#endif
        }
    }

    // Release all the pwnds
    pgms = agmsAll;
    while (pgms < pgmsEnd)
    {
        pwndRelease(pgms->pwnd);
        pgms++;
    }

#ifdef VERBOSE_MULTI
    DbgPrint("Final mask %X\n", dwMask);
#endif
    
    return dwMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\wgldef.h ===
/******************************Module*Header*******************************\
* Module Name: wgldef.h                                                    *
*                                                                          *
* Local declarations.                                                      *
*                                                                          *
* Created: 01-17-1995                                                      * 
* Author: Hock San Lee [hockl]                                             *
*                                                                          *
* Copyright (c) 1995 Microsoft Corporation                                 *
\**************************************************************************/

HANDLE __wglCreateContext(GLWINDOWID *pgwid, GLSURF *pgsurf);
BOOL   __wglDeleteContext(HANDLE hrcSrv);
BOOL   __wglMakeCurrent(GLWINDOWID *pgwid, HANDLE hrcSrv, BOOL bMeta);
BOOL   __wglShareLists(HANDLE hrcSrvShare, HANDLE hrcSrvSource);
BOOL   __wglAttention();
BOOL   __wglCopyContext(HANDLE hrcSrvSrc, HANDLE hrcSrvDest, UINT fuFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\wcreate.c ===
/******************************Module*Header*******************************\
* Module Name: wcreate.c
*
* wgl Context creation routines
*
* Created: 08-27-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ddrawpr.h>

#include <glscreen.h>
#include <glgenwin.h>

#include <gencx.h>

#include "metasup.h"
#include "wgldef.h"

// List of loaded GL drivers for the process.
// A driver is loaded only once per process.  Once it is loaded,
// it will not be freed until the process quits.

static PGLDRIVER pGLDriverList = (PGLDRIVER) NULL;

/******************************Public*Routine******************************\
* iAllocLRC
*
* Allocates a LRC and a handle.  Initializes the LDC to have the default
* attributes.  Returns the handle index.  On error returns INVALID_INDEX.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

static LRC lrcDefault =
{
    0,                    // dhrc
    0,                    // hrc
    0,                    // iPixelFormat
    LRC_IDENTIFIER,       // ident
    INVALID_THREAD_ID,    // tidCurrent
    NULL,                 // pGLDriver
    GLWID_ERROR, NULL, NULL, NULL, // gwidCurrent
    GLWID_ERROR, NULL, NULL, NULL, // gwidCreate
#ifdef GL_METAFILE
    0,                    // uiGlsCaptureContext
    0,                    // uiGlsPlaybackContext
    FALSE,                // fCapturing
    0, 0, 0, 0, 0,        // Metafile scaling constants
    0, 0, 0, 0.0f, 0.0f,
#endif

    NULL,  // GLubyte *pszExtensions

#ifdef GL_METAFILE
    {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}, // XFORM xformMeta
    NULL,                                 // LPRECTL prclGlsBounds
#endif

    NULL, 0,                    // DDraw texture formats
};

static ULONG iAllocLRC(int iPixelFormat)
{
    ULONG  irc = INVALID_INDEX;
    PLRC   plrc;

// Allocate a local RC.

    plrc = (PLRC) ALLOC(sizeof(LRC));
    if (plrc == (PLRC) NULL)
    {
        DBGERROR("Alloc failed\n");
        return(irc);
    }

// Initialize the local RC.

    *plrc = lrcDefault;
    plrc->iPixelFormat = iPixelFormat;

// Allocate a local handle.

    irc = iAllocHandle(LO_RC, 0, (PVOID) plrc);
    if (irc == INVALID_INDEX)
    {
        vFreeLRC(plrc);
        return(irc);
    }
    return(irc);
}

/******************************Public*Routine******************************\
* vFreeLRC
*
* Free a local side RC.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Copied from gdi client.
\**************************************************************************/

VOID vFreeLRC(PLRC plrc)
{
// The driver will not be unloaded here.  It is loaded for the process forever.
// Some assertions.

    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER,
                 "vFreeLRC: Bad plrc\n");
    ASSERTOPENGL(plrc->dhrc == (DHGLRC) 0,
                 "vFreeLRC: Driver RC is not freed!\n");
    ASSERTOPENGL(plrc->tidCurrent == INVALID_THREAD_ID,
                 "vFreeLRC: RC is current!\n");
    ASSERTOPENGL(plrc->gwidCurrent.iType == GLWID_ERROR,
                 "vFreeLRC: Current surface is not NULL!\n");
#ifdef GL_METAFILE
    ASSERTOPENGL(plrc->uiGlsCaptureContext == 0,
                 "vFreeLRC: GLS capture context not freed");
    ASSERTOPENGL(plrc->uiGlsPlaybackContext == 0,
                 "vFreeLRC: GLS playback context not freed");
    ASSERTOPENGL(plrc->fCapturing == FALSE,
                 "vFreeLRC: GLS still capturing");
#endif

// Smash the identifier.

    plrc->ident = 0;

// Free the memory.

    if (plrc->pszExtensions)
        FREE(plrc->pszExtensions);

    if (plrc->pddsdTexFormats != NULL)
    {
        FREE(plrc->pddsdTexFormats);
    }

    FREE(plrc);
}

/******************************Public*Routine******************************\
* vCleanupAllLRC
*
* Process cleanup -- make sure all HGLRCs are deleted.  This is done by
* scanning the local handle table for all currently allocated objects
* of type LO_RC and deleting them.
*
* Called *ONLY* during DLL process detach.
*
* History:
*  24-Jul-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vCleanupAllLRC()
{
    UINT ii;

    if ( pLocalTable )
    {
        ENTERCRITICALSECTION(&semLocal);

        // Scan handle table for handles of type LO_RC.  Make sure to always
        // read the commit value since we need to periodically release the
        // semaphore.

        for (ii = 0; ii < *((volatile ULONG *)&cLheCommitted); ii++)
        {
            if ( pLocalTable[ii].iType == LO_RC )
            {
                if ( !wglDeleteContext((HGLRC) ULongToPtr(LHANDLE(ii))) )
                {
                    WARNING1("bCleanupAllLRC: failed to remove hrc = 0x%lx\n",
                             LHANDLE(ii));
                }
            }
        }

        LEAVECRITICALSECTION(&semLocal);
    }
}

/******************************Public*Routine******************************\
*
* GetDrvRegInfo
*
* Looks up driver registry information by name.
* An old-style ICD registry entry has a REG_SZ value under the given name.
* A new-style ICD registry entry has a key of the given name with
* various values.
*
* This routine checks first for a key and then will optionally
* try the value.  If a key is not found then extended driver information
* is filled out with the defaults.
*
* History:
*  Tue Apr 01 17:33:12 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

typedef struct _GLDRVINFO
{
    DWORD dwFlags;
    TCHAR tszDllName[MAX_GLDRIVER_NAME+1];
    DWORD dwVersion;
    DWORD dwDriverVersion;
} GLDRVINFO;

#ifdef _WIN95_
#define STR_OPENGL_DRIVER_LIST (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\OpenGLDrivers"
#else
#define STR_OPENGL_DRIVER_LIST (PCWSTR)L"Software\\Microsoft\\Windows NT\\CurrentVersion\\OpenGLDrivers"
#endif

BOOL GetDrvRegInfo(PTCHAR ptszName, GLDRVINFO *pgdi)
{
    HKEY hkDriverList = NULL;
    HKEY hkDriverInfo;
    DWORD dwDataType;
    DWORD cjSize;
    BOOL bRet;

    bRet = FALSE;

    // Open the registry key for the list of OpenGL drivers.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, STR_OPENGL_DRIVER_LIST,
                     0, KEY_READ, &hkDriverList) != ERROR_SUCCESS)
    {
        WARNING("RegOpenKeyEx failed\n");
        return bRet;
    }

    // Force a terminator on the DLL name so that we can check for
    // valid DLL name data.
    pgdi->tszDllName[MAX_GLDRIVER_NAME] = 0;

    cjSize = sizeof(TCHAR) * MAX_GLDRIVER_NAME;

    // Attempt to open a key under the driver's name.
    if (RegOpenKeyEx(hkDriverList, ptszName, 0, KEY_READ,
                     &hkDriverInfo) == ERROR_SUCCESS)
    {
        // New-style driver entry.  Fetch information from values.

        bRet = TRUE;

        if (RegQueryValueEx(hkDriverInfo, __TEXT("DLL"), NULL, &dwDataType,
                            (LPBYTE)pgdi->tszDllName,
                            &cjSize) != ERROR_SUCCESS ||
            dwDataType != REG_SZ)
        {
            WARNING("Invalid DLL value in ICD key\n");
            bRet = FALSE;
        }

        cjSize = sizeof(DWORD);

        if (bRet &&
            (RegQueryValueEx(hkDriverInfo, __TEXT("Flags"), NULL, &dwDataType,
                             (LPBYTE)&pgdi->dwFlags,
                             &cjSize) != ERROR_SUCCESS ||
             dwDataType != REG_DWORD))
        {
            WARNING("Invalid Flags value in ICD key\n");
            bRet = FALSE;
        }

        if (bRet &&
            (RegQueryValueEx(hkDriverInfo, __TEXT("Version"), NULL,
                             &dwDataType, (LPBYTE)&pgdi->dwVersion,
                             &cjSize) != ERROR_SUCCESS ||
             dwDataType != REG_DWORD))
        {
            WARNING("Invalid Version value in ICD key\n");
            bRet = FALSE;
        }

        if (bRet &&
            (RegQueryValueEx(hkDriverInfo, __TEXT("DriverVersion"), NULL,
                             &dwDataType, (LPBYTE)&pgdi->dwDriverVersion,
                             &cjSize) != ERROR_SUCCESS ||
             dwDataType != REG_DWORD))
        {
            WARNING("Invalid DriverVersion value in ICD key\n");
            bRet = FALSE;
        }

        // Mark as having full information.
        pgdi->dwFlags |= GLDRIVER_FULL_REGISTRY;

        RegCloseKey(hkDriverInfo);
    }
    else
    {
        // Attempt to fetch value under driver's name.

        if (RegQueryValueEx(hkDriverList, ptszName, NULL, &dwDataType,
                            (LPBYTE)pgdi->tszDllName,
                            &cjSize) != ERROR_SUCCESS ||
            dwDataType != REG_SZ)
        {
            WARNING1("RegQueryValueEx failed, %d\n", GetLastError());
        }
        else
        {
            // We found old-style information which only provides the
            // DLL name.  Fill in the rest with defaults.
            //
            // Version and DriverVersion are not set here under the
            // assumption that the display driver set them in the
            // OPENGL_GETINFO escape since the old-style path requires
            // the escape to occur before getting here.

            pgdi->dwFlags = 0;

            bRet = TRUE;
        }
    }

    RegCloseKey(hkDriverList);

    // Validate the driver name.  It must have some characters and
    // it must be terminated.
    if (bRet &&
        (pgdi->tszDllName[0] == 0 ||
         pgdi->tszDllName[MAX_GLDRIVER_NAME] != 0))
    {
        WARNING("Invalid DLL name information for ICD\n");
        bRet = FALSE;
    }

#ifdef _WIN95_
    // Force client-side buffer calls for Win95.
    pgdi->dwFlags |= GLDRIVER_CLIENT_BUFFER_CALLS;
#endif

    return bRet;
}

/******************************Public*Routine******************************\
* bGetDriverInfo
*
* The HDC is used to determine the display driver name.  This name in turn
* is used as a subkey to search the registry for a corresponding OpenGL
* driver name.
*
* The OpenGL driver name is returned in the buffer pointed to by pwszDriver.
* If the name is not found or does not fit in the buffer, an error is
* returned.
*
* Returns:
*   TRUE if sucessful.
*   FALSE if the driver name does not fit in the buffer or if an error occurs.
*
* History:
*  16-Jan-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bGetDriverInfo(HDC hdc, GLDRVINFO *pgdi)
{
    GLDRVNAME    dn;
    GLDRVNAMERET dnRet;

// Get display driver name.

    dn.oglget.ulSubEsc = OPENGL_GETINFO_DRVNAME;
    if ( ExtEscape(hdc, OPENGL_GETINFO, sizeof(GLDRVNAME), (LPCSTR) &dn,
                      sizeof(GLDRVNAMERET), (LPSTR) &dnRet) <= 0 )
    {
        WARNING("ExtEscape(OPENGL_GETINFO, "
                "OPENGL_GETINFO_DRVNAME) failed\n");
        return FALSE;
    }

    pgdi->dwVersion = dnRet.ulVersion;
    pgdi->dwDriverVersion = dnRet.ulDriverVersion;

    if (GetDrvRegInfo((PTCHAR)dnRet.awch, pgdi))
    {
        // Verify that the client-side driver version information
        // matches the information returned from the display driver.
        // Is this too restrictive?  Old scheme used
        // DrvValidateVersion to allow the client-side DLL to validate
        // the display driver's version however it felt like.
        // In the new scheme DrvValidateVersion is mostly useless because
        // of the below code.
        return pgdi->dwVersion == dnRet.ulVersion &&
            pgdi->dwDriverVersion == dnRet.ulDriverVersion;
    }
    else
    {
        return FALSE;
    }
}

/*****************************Private*Routine******************************\
*
* wglCbSetCurrentValue
*
* Sets a thread-local value for a client-side driver
*
* History:
*  Wed Dec 21 15:10:40 1994     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY wglCbSetCurrentValue(VOID *pv)
{
    GLTEB_SET_CLTDRIVERSLOT(pv);
}

/*****************************Private*Routine******************************\
*
* wglCbGetCurrentValue
*
* Gets a thread-local value for a client-side driver
*
* History:
*  Wed Dec 21 15:11:32 1994     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PVOID APIENTRY wglCbGetCurrentValue(void)
{
    return GLTEB_CLTDRIVERSLOT();
}

/******************************Public*Routine******************************\
*
* wglCbGetDhglrc
*
* Translates an HGLRC to a DHGLRC for a client-side driver
*
* History:
*  Mon Jan 16 17:03:38 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DHGLRC APIENTRY wglCbGetDhglrc(HGLRC hrc)
{
    PLRC plrc;
    ULONG irc;
    PLHE plheRC;

    irc = MASKINDEX(hrc);
    plheRC = pLocalTable + irc;
    if ((irc >= cLheCommitted) ||
        (!MATCHUNIQ(plheRC, hrc)) ||
        ((plheRC->iType != LO_RC))
       )
    {
        DBGLEVEL1(LEVEL_ERROR, "wglCbGetDhglrc: invalid hrc 0x%lx\n", hrc);
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }

    plrc = (PLRC)plheRC->pv;
    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER,
                 "wglCbGetDhglrc: Bad plrc\n");

    return plrc->dhrc;
}

/******************************Public*Routine******************************\
*
* wglCbGetDdHandle
*
* Callback to allow ICDs to extract kernel-mode handles for DDraw surfaces
*
* History:
*  Tue Feb 25 17:14:29 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HANDLE APIENTRY wglCbGetDdHandle(LPDIRECTDRAWSURFACE pdds)
{
    return (HANDLE)(((LPDDRAWI_DDRAWSURFACE_INT)pdds)->lpLcl)->hDDSurface;
}

// wgl's default callback procedures
#define CALLBACK_PROC_COUNT 4

static PROC __wglCallbackProcs[CALLBACK_PROC_COUNT] =
{
    (PROC)wglCbSetCurrentValue,
    (PROC)wglCbGetCurrentValue,
    (PROC)wglCbGetDhglrc,
    (PROC)wglCbGetDdHandle
};

static char *pszDriverEntryPoints[] =
{
    "DrvCreateContext",
    "DrvDeleteContext",
    "DrvSetContext",
    "DrvReleaseContext",
    "DrvCopyContext",
    "DrvCreateLayerContext",
    "DrvShareLists",
    "DrvGetProcAddress",
    "DrvDescribeLayerPlane",
    "DrvSetLayerPaletteEntries",
    "DrvGetLayerPaletteEntries",
    "DrvRealizeLayerPalette",
    "DrvSwapLayerBuffers",
    "DrvCreateDirectDrawContext",
    "DrvEnumTextureFormats",
    "DrvBindDirectDrawTexture",
    "DrvSwapMultipleBuffers",
    "DrvDescribePixelFormat",
    "DrvSetPixelFormat",
    "DrvSwapBuffers"
};
#define DRIVER_ENTRY_POINTS (sizeof(pszDriverEntryPoints)/sizeof(char *))

/******************************Public*Routine******************************\
* pgldrvLoadInstalledDriver
*
* Loads the opengl driver for the given device.  Once the driver is loaded,
* it will not be freed until the process goes away!  It is loaded only once
* for each process that references it.
*
* Returns the GLDRIVER structure if the driver is loaded.
* Returns NULL if no driver is found or an error occurs.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

PGLDRIVER APIENTRY pgldrvLoadInstalledDriver(HDC hdc)
{
    GLDRVINFO gdi;
    PGLDRIVER pGLDriverNext;
    PGLDRIVER pGLDriver = (PGLDRIVER) NULL;     // needed by clean up
    PGLDRIVER pGLDriverRet = (PGLDRIVER) NULL;  // return value, assume error
    PFN_DRVVALIDATEVERSION pfnDrvValidateVersion = (PFN_DRVVALIDATEVERSION) NULL;
    PFN_DRVSETCALLBACKPROCS pfnDrvSetCallbackProcs;
    DWORD        dwEscape;
    int          i;
    PROC        *pproc;
    GLGENwindow *pwnd;
    GLWINDOWID   gwid;

    DBGENTRY("pgldrvLoadInstalledDriver\n");

// Try to grab the cached pgldrv from the GLGENwindow if it exists.
// This only works for DCs that have a window with a device pixel format.

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        ULONG ulFlags;

        ulFlags = pwnd->ulFlags;
        pGLDriverRet = (PGLDRIVER) pwnd->pvDriver;

        pwndRelease(pwnd);

        if ( ulFlags & GLGENWIN_DRIVERSET )
        {
            return pGLDriverRet;
        }
    }

// Do a quick check and see if this driver even understands OpenGL

    dwEscape = OPENGL_GETINFO;
    if (ExtEscape(hdc, QUERYESCSUPPORT, sizeof(dwEscape), (LPCSTR)&dwEscape,
                  0, NULL) <= 0)
    {
        // Don't output a message since this code path is traversed often
        // for the pixel format routines.

#ifdef CHECK_DEFAULT_ICD
        // The display driver doesn't support a specific ICD.  Check
        // for a default ICD.  It must have full registry information.
        if (!GetDrvRegInfo(__TEXT("Default"), &gdi) ||
            (gdi.dwFlags & GLDRIVER_FULL_REGISTRY) == 0)
        {
            return NULL;
        }
#else
        return NULL;
#endif
    }

// Determine driver info from hdc

    else if ( !bGetDriverInfo(hdc, &gdi) )
    {
        WARNING("bGetDriverInfo failed\n");
        return NULL;
    }

// Load the driver only once per process.

    ENTERCRITICALSECTION(&semLocal);

// Look for the OpenGL driver in the previously loaded driver list.

    for (pGLDriverNext = pGLDriverList;
         pGLDriverNext != (PGLDRIVER) NULL;
         pGLDriverNext = pGLDriverNext->pGLDriver)
    {
        PTCHAR ptszDllName1 = pGLDriverNext->tszDllName;
        PTCHAR ptszDllName2 = gdi.tszDllName;

        while (*ptszDllName1 == *ptszDllName2)
        {
// If we find one, return that driver.

            if (*ptszDllName1 == 0)
            {
                DBGINFO("pgldrvLoadInstalledDriver: "
                        "return previously loaded driver\n");
                pGLDriverRet = pGLDriverNext;       // found one
                goto pgldrvLoadInstalledDriver_crit_exit;
            }

            ptszDllName1++;
            ptszDllName2++;
        }
    }

// Load the driver for the first time.
// Allocate the driver data.

    pGLDriver = (PGLDRIVER) ALLOC(sizeof(GLDRIVER));
    if (pGLDriver == (PGLDRIVER) NULL)
    {
        WARNING("Alloc failed\n");
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Load the driver.

    pGLDriver->hModule = LoadLibrary(gdi.tszDllName);
    if (pGLDriver->hModule == (HINSTANCE) NULL)
    {
        WARNING("pgldrvLoadInstalledDriver: LoadLibrary failed\n");
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Copy the driver info.

    memcpy
    (
        pGLDriver->tszDllName,
        gdi.tszDllName,
        (MAX_GLDRIVER_NAME + 1) * sizeof(TCHAR)
    );
    pGLDriver->dwFlags = gdi.dwFlags;

// Get the proc addresses.
// DrvGetProcAddress is optional.  It must be provided if a driver supports
// extensions.

    pfnDrvValidateVersion = (PFN_DRVVALIDATEVERSION)
        GetProcAddress(pGLDriver->hModule, "DrvValidateVersion");
    pfnDrvSetCallbackProcs = (PFN_DRVSETCALLBACKPROCS)
        GetProcAddress(pGLDriver->hModule, "DrvSetCallbackProcs");

    pproc = (PROC *)&pGLDriver->pfnDrvCreateContext;
    for (i = 0; i < DRIVER_ENTRY_POINTS; i++)
    {
        *pproc++ =
            GetProcAddress(pGLDriver->hModule, pszDriverEntryPoints[i]);
    }

    if ((pGLDriver->pfnDrvCreateContext == NULL &&
          pGLDriver->pfnDrvCreateLayerContext == NULL) ||
        pGLDriver->pfnDrvDeleteContext == NULL ||
        pGLDriver->pfnDrvSetContext == NULL ||
        pGLDriver->pfnDrvReleaseContext == NULL ||
        ((gdi.dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS) &&
         (pGLDriver->pfnDrvDescribePixelFormat == NULL ||
          pGLDriver->pfnDrvSetPixelFormat == NULL ||
          pGLDriver->pfnDrvSwapBuffers == NULL)) ||
        pfnDrvValidateVersion == NULL)
    {
        WARNING("pgldrvLoadInstalledDriver: GetProcAddress failed\n");
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Validate the driver.

    //!!!XXX -- Need to define a manifest constant for the ulVersion number
    //          in this release.  Where should it go?
    if ( gdi.dwVersion != 2 || !pfnDrvValidateVersion(gdi.dwDriverVersion) )
    {
        WARNING2("pgldrvLoadInstalledDriver: bad driver version "
                 "(0x%lx, 0x%lx)\n", gdi.dwVersion, gdi.dwDriverVersion);
        goto pgldrvLoadInstalledDriver_crit_exit;   // error
    }

// Everything is golden.
// Add it to the driver list.

    pGLDriver->pGLDriver = pGLDriverList;
    pGLDriverList = pGLDriver;
    pGLDriverRet = pGLDriver;       // set return value
    DBGINFO("pgldrvLoadInstalledDriver: Loaded an OpenGL driver\n");

    // Set the callback procs for the driver if the driver supports doing so
    if (pfnDrvSetCallbackProcs != NULL)
    {
        pfnDrvSetCallbackProcs(CALLBACK_PROC_COUNT, __wglCallbackProcs);
    }

// Error clean up in the critical section.

pgldrvLoadInstalledDriver_crit_exit:
    if (pGLDriverRet == (PGLDRIVER) NULL)
    {
        if (pGLDriver != (PGLDRIVER) NULL)
        {
            if (pGLDriver->hModule != (HINSTANCE) NULL)
                if (!FreeLibrary(pGLDriver->hModule))
                    RIP("FreeLibrary failed\n");

            FREE(pGLDriver);
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    return(pGLDriverRet);
}

/******************************Public*Routine******************************\
*
* CreateAnyContext
*
* Base worker function for creating all kinds of contexts
*
* History:
*  Mon Aug 26 14:41:31 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HGLRC CreateAnyContext(GLSURF *pgsurf)
{
    PLHE  plheRC;
    ULONG irc;
    HGLRC hrc;
    PLRC  plrc;

#ifndef _WIN95_
    // _OPENGL_NT_
    // On NT, client-side drivers can use special fast TEB access macros
    // which rely on glContext being at a fixed offset into the
    // TEB.  Assert that the offset is where we think it is
    // to catch any TEB changes which could break client-side
    // drivers
    // This assert is here in wglCreateContext to ensure that it
    // is checked very early in OpenGL operation
    ASSERTOPENGL(FIELD_OFFSET(TEB, glContext) == TeglContext,
                 "TEB.glContext at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glDispatchTable) == TeglDispatchTable,
                 "TEB.glDispatchTable at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glReserved1) == TeglReserved1,
                 "TEB.glReserved1 at wrong offset\n");
#if !defined(_WIN64)
    ASSERTOPENGL(FIELD_OFFSET(TEB, glReserved1)+(18 * sizeof(ULONG_PTR)) == TeglPaTeb,
                 "TEB.glPaTeb at wrong offset\n");
#endif
    ASSERTOPENGL(FIELD_OFFSET(TEB, glReserved2) == TeglReserved2,
                 "TEB.glReserved2 at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glSectionInfo) == TeglSectionInfo,
                 "TEB.glSectionInfo at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glSection) == TeglSection,
                 "TEB.glSection at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glTable) == TeglTable,
                 "TEB.glTable at wrong offset\n");
    ASSERTOPENGL(FIELD_OFFSET(TEB, glCurrentRC) == TeglCurrentRC,
                 "TEB.glCurrentRC at wrong offset\n");
#endif

// Create the local RC.

    ENTERCRITICALSECTION(&semLocal);
    irc = iAllocLRC(pgsurf->ipfd);
    if (irc == INVALID_INDEX ||
        cLockHandle((ULONG_PTR)(hrc = (HGLRC) ULongToPtr(LHANDLE(irc)))) <= 0)
    {
        // cLockHandle should never fail or we will need to free the handle.
        ASSERTOPENGL(irc == INVALID_INDEX, "cLockHandle should not fail!\n");
        LEAVECRITICALSECTION(&semLocal);
        return((HGLRC) 0);
    }
    LEAVECRITICALSECTION(&semLocal);

    plheRC = &pLocalTable[irc];
    plrc = (PLRC) plheRC->pv;

    // Remember the creation DC.  This needs to be done early because
    // it is referenced in some code paths.

    plrc->gwidCreate.hdc = pgsurf->hdc;
    if (pgsurf->dwFlags & GLSURF_HDC)
    {
        plrc->gwidCreate.hwnd = pgsurf->hwnd;
        if (plrc->gwidCreate.hwnd == NULL)
        {
            plrc->gwidCreate.iType = GLWID_HDC;
        }
        else
        {
            plrc->gwidCreate.iType = GLWID_HWND;
        }
        plrc->gwidCreate.pdds = NULL;
    }
    else
    {
        plrc->gwidCreate.iType = GLWID_DDRAW;
        plrc->gwidCreate.pdds = pgsurf->dd.gddsFront.pdds;
        plrc->gwidCreate.hwnd = NULL;
    }

    if (!(pgsurf->pfd.dwFlags & PFD_GENERIC_FORMAT) &&
        !(pgsurf->pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
    // If it is a device format, load the installable OpenGL driver.
    // Find and load the OpenGL driver referenced by this DC.

        if (!(plrc->pGLDriver = pgldrvLoadInstalledDriver(pgsurf->hdc)))
            goto wglCreateContext_error;

    // Create a driver context.

        // If the surface is a DirectDraw surface use the DirectDraw
        // entry point
        if (pgsurf->dwFlags & GLSURF_DIRECTDRAW)
        {
            if (plrc->pGLDriver->pfnDrvCreateDirectDrawContext == NULL)
            {
                SetLastError(ERROR_INVALID_FUNCTION);
                goto wglCreateContext_error;
            }

            plrc->dhrc = plrc->pGLDriver->pfnDrvCreateDirectDrawContext(
                    pgsurf->hdc, pgsurf->dd.gddsFront.pdds, pgsurf->ipfd);
            if (plrc->dhrc == 0)
            {
                WARNING("wglCreateContext: "
                        "pfnDrvCreateDirectDrawContext failed\n");
                goto wglCreateContext_error;
            }
        }
        // If the driver supports layers then create a context for the
        // given layer.  Otherwise reject all layers except for the
        // main plane and call the layer-less create
        else if (plrc->pGLDriver->pfnDrvCreateLayerContext != NULL)
        {
            if (!(plrc->dhrc =
                  plrc->pGLDriver->pfnDrvCreateLayerContext(pgsurf->hdc,
                                                            pgsurf->iLayer)))
            {
                WARNING("wglCreateContext: pfnDrvCreateLayerContext failed\n");
                goto wglCreateContext_error;
            }
        }
        else if (pgsurf->iLayer != 0)
        {
            WARNING("wglCreateContext: "
                    "Layer given for driver without layer support\n");
            SetLastError(ERROR_INVALID_FUNCTION);
            goto wglCreateContext_error;
        }
        else if (!(plrc->dhrc =
                   plrc->pGLDriver->pfnDrvCreateContext(pgsurf->hdc)))
        {
            WARNING("wglCreateContext: pfnDrvCreateContext failed\n");
            goto wglCreateContext_error;
        }
    }
    else
    {
        GLCLTPROCTABLE *pgcpt;
        GLEXTPROCTABLE *pgept;
        __GLcontext *gc;

        // Unless supported by MCD, the generic implementation doesn't
        // support layers
        if ((pgsurf->iLayer != 0) &&
            !(pgsurf->pfd.dwFlags & PFD_GENERIC_ACCELERATED))
        {
            WARNING("wglCreateContext: Layer given to generic\n");
            goto wglCreateContext_error;
        }

#ifdef GL_METAFILE
        // Create a metafile context if necessary
        if (pgsurf->dwFlags & GLSURF_METAFILE)
        {
            if (!CreateMetaRc(pgsurf->hdc, plrc))
            {
                WARNING("wglCreateContext: CreateMetaRc failed\n");
                goto wglCreateContext_error;
            }
        }
#endif

    // If it is a generic format, call the generic OpenGL server.
    // Create a server RC.

        plheRC->hgre = (ULONG_PTR) __wglCreateContext(&plrc->gwidCreate, pgsurf);
        if (plheRC->hgre == 0)
            goto wglCreateContext_error;

        // Set up the default dispatch tables for display list playback
        gc = (__GLcontext *)plheRC->hgre;
        if (gc->modes.colorIndexMode)
            pgcpt = &glCltCIProcTable;
        else
            pgcpt = &glCltRGBAProcTable;
        pgept = &glExtProcTable;
        memcpy(&gc->savedCltProcTable.glDispatchTable, &pgcpt->glDispatchTable,
               pgcpt->cEntries*sizeof(PROC));
        memcpy(&gc->savedExtProcTable.glDispatchTable, &pgept->glDispatchTable,
               pgept->cEntries*sizeof(PROC));
    }

    DBGLEVEL3(LEVEL_INFO,
        "wglCreateContext: plrc = 0x%lx, pGLDriver = 0x%lx, hgre = 0x%lx\n",
        plrc, plrc->pGLDriver, plheRC->hgre);

// Success, return the result.

    plrc->hrc = hrc;

    vUnlockHandle((ULONG_PTR)hrc);

    return hrc;

wglCreateContext_error:

// Fail, clean up and return 0.

#ifdef GL_METAFILE
    // Clean up metafile context if necessary
    if (plrc->uiGlsCaptureContext != 0)
    {
        DeleteMetaRc(plrc);
    }
#endif

    DBGERROR("wglCreateContext failed\n");
    ASSERTOPENGL(plrc->dhrc == (DHGLRC) 0, "wglCreateContext: dhrc != 0\n");
    vFreeLRC(plrc);
    vFreeHandle(irc);           // it unlocks handle too
    return NULL;
}

/******************************Public*Routine******************************\
*
* CreateMetafileSurf
*
* Fills out a GLSURF for a metafile DC
*
* History:
*  Tue Aug 27 11:41:35 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef GL_METAFILE
void CreateMetafileSurf(HDC hdc, int iLayer, GLSURF *pgsurf)
{
    pgsurf->dwFlags = GLSURF_HDC | GLSURF_METAFILE;
    pgsurf->iLayer = iLayer;

    // Metafile surfaces don't have a real pixel format
    pgsurf->ipfd = 0;

    // Create a fake format of 24-bit DIB with BGR
    memset(&pgsurf->pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));
    pgsurf->pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pgsurf->pfd.nVersion = 1;
    pgsurf->pfd.dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL |
        PFD_GENERIC_FORMAT;
    pgsurf->pfd.iPixelType = PFD_TYPE_RGBA;
    pgsurf->pfd.cColorBits = 24;
    pgsurf->pfd.cStencilBits = 8;
    pgsurf->pfd.cRedBits = 8;
    pgsurf->pfd.cRedShift = 16;
    pgsurf->pfd.cGreenBits = 8;
    pgsurf->pfd.cGreenShift = 8;
    pgsurf->pfd.cBlueBits = 8;
    pgsurf->pfd.cBlueShift = 0;
    pgsurf->pfd.cDepthBits = 16;
    pgsurf->pfd.iLayerType = PFD_MAIN_PLANE;

    pgsurf->hdc = hdc;
}
#endif

/******************************Public*Routine******************************\
* wglSurfacePixelFormat
*
* wglDescribePixelFormat doesn't describe the format of the surface we want
* to render into.  Some fields need to be fixed up if the surface is RGB,
* BGR, or BITFIELDS.
*
* Expects a Describe'd pixel format as input
*
\**************************************************************************/

VOID APIENTRY wglSurfacePixelFormat(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd)
{
    HBITMAP hbm;
    BITMAP bm;
    ULONG cBitmapColorBits;

    hbm = CreateCompatibleBitmap(hdc, 1, 1);
    if ( hbm )
    {
        if ( GetObject(hbm, sizeof(bm), &bm) )
        {
            cBitmapColorBits = bm.bmPlanes * bm.bmBitsPixel;

#if DBG
            // If dynamic color depth caused depth mismatch one of two
            // things will happen: 1) bitmap creation will fail because
            // we failed to fill in color format, or 2) drawing will
            // be incorrect.  We will not crash.

            if (cBitmapColorBits != ppfd->cColorBits)
                WARNING("pixel format/surface color depth mismatch\n");
#endif

            if ( cBitmapColorBits >= 16 )
                __wglGetBitfieldColorFormat(hdc, cBitmapColorBits, ppfd,
                                            TRUE);
        }
        else
        {
            WARNING("wglSurfacePixelFormat: GetObject failed\n");
        }

        DeleteObject(hbm);
    }
    else
    {
        WARNING("wglSurfacePixelFormat: Unable to create cbm\n");
    }
}

/******************************Public*Routine******************************\
* bLayerPixelFormat
*
* Fake up a pixel format using the layer descriptor format.
*
* We use this to describe the layer plane in a format that the generic
* context can understand.
*
* Expects a Describe'd pixel format as input for the flags
*
\**************************************************************************/

BOOL FASTCALL bLayerPixelFormat(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd,
                                int ipfd, LONG iLayer)
{
    LAYERPLANEDESCRIPTOR lpd;

    if (!wglDescribeLayerPlane(hdc, ipfd, iLayer, sizeof(lpd), &lpd))
        return FALSE;

    ppfd->nSize    = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion = 1;
    ppfd->dwFlags  = (ppfd->dwFlags & (PFD_GENERIC_FORMAT |
                                       PFD_GENERIC_ACCELERATED)) |
                     (lpd.dwFlags & ~(LPD_SHARE_DEPTH | LPD_SHARE_STENCIL |
                                      LPD_SHARE_ACCUM | LPD_TRANSPARENT));
    ppfd->iPixelType  = lpd.iPixelType;
    ppfd->cColorBits  = lpd.cColorBits;
    ppfd->cRedBits    = lpd.cRedBits   ;
    ppfd->cRedShift   = lpd.cRedShift  ;
    ppfd->cGreenBits  = lpd.cGreenBits ;
    ppfd->cGreenShift = lpd.cGreenShift;
    ppfd->cBlueBits   = lpd.cBlueBits  ;
    ppfd->cBlueShift  = lpd.cBlueShift ;
    ppfd->cAlphaBits  = lpd.cAlphaBits ;
    ppfd->cAlphaShift = lpd.cAlphaShift;
    if (!(lpd.dwFlags & LPD_SHARE_ACCUM))
    {
        ppfd->cAccumBits      = 0;
        ppfd->cAccumRedBits   = 0;
        ppfd->cAccumGreenBits = 0;
        ppfd->cAccumBlueBits  = 0;
        ppfd->cAccumAlphaBits = 0;
    }
    if (!(lpd.dwFlags & LPD_SHARE_DEPTH))
    {
        ppfd->cDepthBits = 0;
    }
    if (!(lpd.dwFlags & LPD_SHARE_STENCIL))
    {
        ppfd->cStencilBits = 0;
    }
    ppfd->cAuxBuffers = 0;

    return TRUE;
}

/******************************Public*Routine******************************\
*
* IsDirectDrawDevice
*
* Returns surface associated with HDC if such an association exists
*
* History:
*  Wed Sep 25 13:18:02 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY IsDirectDrawDevice(HDC hdc)
{
    LPDIRECTDRAWSURFACE pdds;
    HDC hdcDevice;

    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDevice) == DD_OK)
    {
        // The call gave us a reference on the surface so release it.
        pdds->lpVtbl->Release(pdds);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************Public*Routine******************************\
*
* DdPixelDepth
*
* Determines the number of bits per pixel for a surface.
*
* History:
*  Wed Nov 20 16:57:07 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BYTE APIENTRY DdPixelDepth(DDSURFACEDESC *pddsd)
{
    if (pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4)
    {
        return 4;
    }
    else if (pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
    {
        return 8;
    }
    else
    {
        return (BYTE)DdPixDepthToCount(pddsd->ddpfPixelFormat.dwRGBBitCount);
    }
}

/******************************Public*Routine******************************\
*
* wglIsDirectDevice
*
* Checks to see whether the given DC is a screen DC on the
* surface for which we have direct screen access
*
* History:
*  Fri Apr 19 15:17:30 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY wglIsDirectDevice(HDC hdc)
{
    if (wglObjectType(hdc) != OBJ_DC)
    {
        return FALSE;
    }

    // What about multiple displays?
    return GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY;
}

/******************************Public*Routine******************************\
*
* InitDeviceSurface
*
* Fills out a GLSURF for an HDC-based surface
*
* History:
*  Tue Aug 27 19:22:38 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY InitDeviceSurface(HDC hdc, int ipfd, int iLayer,
                                DWORD dwObjectType, BOOL bUpdatePfd,
                                GLSURF *pgsurf)
{
    pgsurf->dwFlags = GLSURF_HDC;
    pgsurf->iLayer = iLayer;
    pgsurf->ipfd = ipfd;
    pgsurf->hdc = hdc;
    pgsurf->hwnd = NULL;

    // Determine whether direct memory access is available for this surface
    // or not.  The two cases are:
    //   It's a screen surface and we have direct screen access
    //   It's a DIBSECTION memory surface
    if (dwObjectType == OBJ_DC)
    {
        pgsurf->dwFlags |= GLSURF_DIRECTDC;

        if (wglIsDirectDevice(hdc))
        {
            pgsurf->dwFlags |= GLSURF_SCREEN | GLSURF_VIDEO_MEMORY;
            pgsurf->hwnd = WindowFromDC(hdc);

            if (GLDIRECTSCREEN)
            {
                pgsurf->dwFlags |= GLSURF_DIRECT_ACCESS;
            }
        }
    }
    else if (dwObjectType == OBJ_MEMDC)
    {
        DIBSECTION ds;

        if (GetObject(GetCurrentObject(hdc, OBJ_BITMAP), sizeof(ds), &ds) ==
            sizeof(ds) && ds.dsBm.bmBits != NULL)
        {
            pgsurf->dwFlags |= GLSURF_DIRECT_ACCESS;
        }

        if (bUpdatePfd)
        {
            // Update pixel format with true surface information rather
            // than device information
            wglSurfacePixelFormat(hdc, &pgsurf->pfd);
        }
    }

    if (bUpdatePfd &&
        iLayer > 0 &&
        !bLayerPixelFormat(hdc, &pgsurf->pfd, ipfd, iLayer))
    {
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* InitDdSurface
*
* Completes a GLSURF for a DirectDraw-based surface.
* Pixel format information should already be filled in.
*
* History:
*  Mon Aug 26 13:50:04 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL InitDdSurface(LPDIRECTDRAWSURFACE pdds, HDC hdcDevice, GLSURF *pgsurf)
{
    DDSCAPS ddscaps;
    LPDIRECTDRAWSURFACE pddsZ;
    DDSURFACEDESC *pddsd;

    pgsurf->hdc = hdcDevice;

    pgsurf->dd.gddsFront.ddsd.dwSize = sizeof(DDSURFACEDESC);
    pgsurf->dd.gddsZ.ddsd.dwSize = sizeof(DDSURFACEDESC);

    pddsd = &pgsurf->dd.gddsFront.ddsd;
    if (pdds->lpVtbl->GetSurfaceDesc(pdds, pddsd) != DD_OK)
    {
        return FALSE;
    }

    pgsurf->dwFlags = GLSURF_DIRECTDRAW | GLSURF_DIRECT_ACCESS;
    pgsurf->iLayer = 0;

    // Check for an attached Z buffer
    memset(&ddscaps, 0, sizeof(ddscaps));
    ddscaps.dwCaps = DDSCAPS_ZBUFFER;
    pddsd = &pgsurf->dd.gddsZ.ddsd;
    if (pdds->lpVtbl->GetAttachedSurface(pdds, &ddscaps, &pddsZ) == DD_OK)
    {
        if (pddsZ->lpVtbl->GetSurfaceDesc(pddsZ, pddsd) != DD_OK)
        {
            pddsZ->lpVtbl->Release(pddsZ);
            return FALSE;
        }
    }
    else
    {
        memset(&pgsurf->dd.gddsZ, 0, sizeof(pgsurf->dd.gddsZ));
    }

    // If both the color buffer and the Z buffer are in video memory
    // then hardware acceleration is possible
    if ((pgsurf->dd.gddsFront.ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
        (pddsZ == NULL ||
         (pgsurf->dd.gddsZ.ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)))
    {
        pgsurf->dwFlags |= GLSURF_VIDEO_MEMORY;
    }

    pgsurf->dd.gddsFront.pdds = pdds;
    pgsurf->dd.gddsFront.dwBitDepth =
        DdPixDepthToCount(pgsurf->dd.gddsFront.
                          ddsd.ddpfPixelFormat.dwRGBBitCount);
    // GetAttachedSurface gave us a reference to the Z buffer
    pgsurf->dd.gddsZ.pdds = pddsZ;
    pgsurf->dd.gddsZ.dwBitDepth =
        DdPixDepthToCount(pgsurf->dd.gddsZ.
                          ddsd.ddpfPixelFormat.dwZBufferBitDepth);

    return TRUE;
}

/******************************Public*Routine******************************\
* wglCreateLayerContext(HDC hdc, int iLayer)
*
* Create a rendering context for a specific layer
*
* Arguments:
*   hdc        - Device context.
*   iLayer     - Layer
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

HGLRC WINAPI wglCreateLayerContext(HDC hdc, int iLayer)
{
    DWORD dwObjectType;
    GLSURF gsurf;
    LPDIRECTDRAWSURFACE pdds;
    HDC hdcDevice;
    HGLRC hrc;

    DBGENTRY("wglCreateLayerContext\n");

// Flush OpenGL calls.

    GLFLUSH();

// Validate the DC.

    dwObjectType = wglObjectType(hdc);
    switch (dwObjectType)
    {
    case OBJ_DC:
    case OBJ_MEMDC:
        break;

    case OBJ_ENHMETADC:
#ifdef GL_METAFILE
        if (pfnGdiAddGlsRecord == NULL)
        {
            DBGLEVEL1(LEVEL_ERROR, "wglCreateContext: metafile hdc: 0x%lx\n",
                      hdc);
            SetLastError(ERROR_INVALID_HANDLE);
            return((HGLRC) 0);
        }
        break;
#else
        DBGLEVEL1(LEVEL_ERROR, "wglCreateContext: metafile hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return((HGLRC) 0);
#endif

    case OBJ_METADC:
    default:
        // 16-bit metafiles are not supported
        DBGLEVEL1(LEVEL_ERROR, "wglCreateContext: bad hdc: 0x%lx\n", hdc);
        SetLastError(ERROR_INVALID_HANDLE);
        return((HGLRC) 0);
    }

    pdds = NULL;
    hrc = NULL;

    memset(&gsurf, 0, sizeof(gsurf));
    gsurf.ipfd = GetPixelFormat(hdc);

#ifdef GL_METAFILE
    // Skip pixel format checks for metafiles
    if (dwObjectType == OBJ_ENHMETADC)
    {
        CreateMetafileSurf(hdc, iLayer, &gsurf);
        goto NoPixelFormat;
    }
#endif

// Get the current pixel format of the window or surface.
// If no pixel format has been set, return error.

    if (gsurf.ipfd == 0)
    {
        WARNING("wglCreateContext: No pixel format set in hdc\n");
        SetLastError(ERROR_INVALID_PIXEL_FORMAT);
        return ((HGLRC) 0);
    }

    if (!DescribePixelFormat(hdc, gsurf.ipfd, sizeof(gsurf.pfd), &gsurf.pfd))
    {
        DBGERROR("wglCreateContext: DescribePixelFormat failed\n");
        return ((HGLRC) 0);
    }

    // Check for a DirectDraw surface
    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDevice) == DD_OK)
    {
        // Don't allow layers for DirectDraw surfaces since
        // layering is done through DirectDraw itself.
        if (iLayer != 0 ||
            !InitDdSurface(pdds, hdcDevice, &gsurf))
        {
            goto Exit;
        }
    }
    else if (!InitDeviceSurface(hdc, gsurf.ipfd, iLayer, dwObjectType,
                                TRUE, &gsurf))
    {
        goto Exit;
    }

#ifdef GL_METAFILE
 NoPixelFormat:
#endif

    hrc = CreateAnyContext(&gsurf);

 Exit:
    if (hrc == NULL)
    {
        if (pdds != NULL)
        {
            pdds->lpVtbl->Release(pdds);

            // Release reference on Z buffer if necessary
            if (gsurf.dd.gddsZ.pdds != NULL)
            {
                gsurf.dd.gddsZ.pdds->lpVtbl->Release(gsurf.dd.gddsZ.pdds);
            }
        }
    }

    return hrc;
}

/******************************Public*Routine******************************\
* wglCreateContext(HDC hdc)
*
* Create a rendering context.
*
* Arguments:
*   hdc        - Device context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

HGLRC WINAPI wglCreateContext(HDC hdc)
{
    return wglCreateLayerContext(hdc, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\wgl.c ===
/******************************Module*Header*******************************\
* Module Name: wgl.c
*
* Routines to integrate Windows NT and OpenGL.
*
* Created: 10-26-1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrdll.h>
#include <ntpsapi.h>

#include <wingdip.h>

#include <glscreen.h>
#include <glgenwin.h>

#include "batchinf.h"
#include "glapi.h"
#include "glsbcltu.h"
#include "wgldef.h"
#include "metasup.h"
#include "glclt.h"
#include "gencx.h"
#include "context.h"
#include "global.h"
#include "mcdcx.h"

// Static functions prototypes

static PROC      pfnGenGlExtProc(LPCSTR lpszProc);
static PROC      pfnSimGlExtProc(LPCSTR lpszProc);

/******************************Public*Routine******************************\
*
* wglObjectType
*
* Returns GetObjectType result with the exception that
* metafile-spooled printer DC's come back as metafile objects
*
* History:
*  Fri Jun 16 12:10:07 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY wglObjectType(HDC hdc)
{
    DWORD dwObjectType;

    dwObjectType = GetObjectType(hdc);

#ifdef GL_METAFILE
    if (dwObjectType == OBJ_DC &&
        pfnGdiIsMetaPrintDC != NULL &&
        GlGdiIsMetaPrintDC(hdc))
    {
        dwObjectType = OBJ_ENHMETADC;
    }
#endif

    // OBJ_DDRAW is reserved as a special identifier.  Make sure
    // we aren't returning it from here.
    ASSERTOPENGL(dwObjectType != OBJ_DDRAW,
                 "Unexpected object type\n");
    
    return dwObjectType;
}

/******************************Public*Routine******************************\
* wglDeleteContext(HGLRC hrc)
*
* Delete the rendering context
*
* Arguments:
*   hrc        - Rendering context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
\**************************************************************************/

BOOL WINAPI wglDeleteContext(HGLRC hrc)
{
    PLHE  plheRC;
    ULONG irc;
    PLRC  plrc;
    BOOL  bRet = FALSE;

    DBGENTRY("wglDeleteContext\n");

// Flush OpenGL calls.

    GLFLUSH();

// Validate the RC.

    if (cLockHandle((ULONG_PTR)hrc) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglDeleteContext: can't lock hrc 0x%lx\n", hrc);
        return(bRet);
    }
    irc = MASKINDEX(hrc);
    plheRC = pLocalTable + irc;
    plrc = (PLRC) plheRC->pv;
    ASSERTOPENGL(plrc->ident == LRC_IDENTIFIER, "wglDeleteContext: Bad plrc\n");
    DBGLEVEL2(LEVEL_INFO, "wglDeleteContext: hrc: 0x%lx, plrc: 0x%lx\n", hrc, plrc);

    if (plrc->tidCurrent != INVALID_THREAD_ID)
    {
// The RC must be current to this thread because makecurrent locks
// down the handle.

        ASSERTOPENGL(plrc->tidCurrent == GetCurrentThreadId(),
            "wglDeleteCurrent: hrc is current to another thread\n");

// Make the RC inactive first.

        if (!bMakeNoCurrent())
        {
            DBGERROR("wglDeleteCurrent: bMakeNoCurrent failed\n");
        }
    }

    if (plrc->dhrc)
    {
// If it is a device format, call the driver to delete its context.

        bRet = plrc->pGLDriver->pfnDrvDeleteContext(plrc->dhrc);
        plrc->dhrc = (DHGLRC) 0;
    }
    else
    {
#ifdef GL_METAFILE
        // If we have metafile state, clean it up
        if (plrc->uiGlsCaptureContext != 0 ||
            plrc->uiGlsPlaybackContext != 0)
        {
            DeleteMetaRc(plrc);
        }
#endif
        
// If it is a generic format, call the server to delete its context.

        bRet = __wglDeleteContext((HANDLE) plheRC->hgre);
    }

// Always clean up local objects.

    vFreeLRC(plrc);
    vFreeHandle(irc);           // it unlocks handle too
    if (!bRet)
        DBGERROR("wglDeleteContext failed\n");
    return(bRet);
}

/******************************Public*Routine******************************\
* wglGetCurrentContext(VOID)
*
* Return the current rendering context
*
* Arguments:
*   None
*
* Returns:
*   hrc        - Rendering context.
*
* History:
*  Tue Oct 26 10:25:26 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HGLRC WINAPI wglGetCurrentContext(VOID)
{
    DBGENTRY("wglGetCurrentContext\n");

    if (GLTEB_CLTCURRENTRC())
        return(GLTEB_CLTCURRENTRC()->hrc);
    else
        return((HGLRC) 0);
}

/******************************Public*Routine******************************\
* wglGetCurrentDC(VOID)
*
* Return the device context that is associated with the current rendering
* context
*
* Arguments:
*   None
*
* Returns:
*   hdc        - device context.
*
* History:
*  Mon Jan 31 12:15:12 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HDC WINAPI wglGetCurrentDC(VOID)
{
    PLRC plrc;
    
    DBGENTRY("wglGetCurrentDC\n");

    plrc = GLTEB_CLTCURRENTRC();
    if (plrc != NULL)
    {
        return plrc->gwidCurrent.hdc;
    }
    else
    {
        return((HDC) 0);
    }
}

/******************************Public*Routine******************************\
* wglUseFontBitmapsA
* wglUseFontBitmapsW
*
* Stubs that call wglUseFontBitmapsAW with the bUnicode flag set
* appropriately.
*
* History:
*  11-Mar-1994 gilmanw
* Changed to call wglUseFontBitmapsAW.
*
*  17-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL WINAPI wglUseFontBitmapsAW(HDC hdc, DWORD first, DWORD count,
                                DWORD listBase, BOOL bUnicode);

BOOL WINAPI
wglUseFontBitmapsA(HDC hdc, DWORD first, DWORD count, DWORD listBase)
{
    return wglUseFontBitmapsAW(hdc, first, count, listBase, FALSE);
}

BOOL WINAPI
wglUseFontBitmapsW(HDC hdc, DWORD first, DWORD count, DWORD listBase)
{
    return wglUseFontBitmapsAW(hdc, first, count, listBase, TRUE);
}

/******************************Public*Routine******************************\
* wglUseFontBitmapsAW
*
* Uses the current font in the specified DC to generate a series of OpenGL
* display lists, each of which consists of a glyph bitmap.
*
* Each glyph bitmap is generated by calling ExtTextOut to draw the glyph
* into a memory DC.  The contents of the memory DC are then copied into
* a buffer by GetDIBits and then put into the OpenGL display list.
*
* ABC spacing is used (if GetCharABCWidth() is supported by the font) to
* determine proper placement of the glyph origin and character advance width.
* Otherwise, A = C = 0 spacing is assumed and GetCharWidth() is used for the
* advance widths.
*
* Returns:
*
*   TRUE if successful, FALSE otherwise.
*
* History:
*  17-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL WINAPI
wglUseFontBitmapsAW(
    HDC   hdc,          // use HFONT from this DC
    DWORD first,        // generate glyphs starting with this Unicode codepoint
    DWORD count,        // range is this long [first, first+count-1]
    DWORD listBase,     // starting display list number
    BOOL  bUnicode      // TRUE for if in Unicode mode, FALSE if in Ansi mode
    )
{
    BOOL        bRet = FALSE;               // return value
    HDC         hdcMem;                     // render glyphs to this memory DC
    HBITMAP     hbm;                        // monochrome bitmap for memory DC
    LPABC       pabc, pabcTmp, pabcEnd;     // array of ABC spacing
    LPINT       piWidth, piTmp, piWidthEnd; // array of char adv. widths
    WCHAR       wc;                         // current Unicode char to render
    RECT        rc;                         // background rectangle to clear
    TEXTMETRICA tm;                         // metrics of the font
    BOOL        bTrueType;                  // TrueType supports ABC spacing
    int         iMaxWidth = 1;              // maximum glyph width
    int         iBitmapWidth;               // DWORD aligned bitmap width
    BYTE        ajBmi[sizeof(BITMAPINFO) + sizeof(RGBQUAD)];
    BITMAPINFO  *pbmi = (BITMAPINFO *)ajBmi;// bitmap info for GetDIBits
    GLint       iUnpackRowLength;           // save GL_UNPACK_ROW_LENGTH
    GLint       iUnpackAlign;               // save GL_UNPACK_ALIGNMENT
    PVOID       pv;                         // pointer to glyph bitmap buffer

// Return error if there is no current RC.

    if (!GLTEB_CLTCURRENTRC())
    {
        WARNING("wglUseFontBitmapsAW: no current RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        return bRet;
    }

// Get TEXTMETRIC.  The only fields used are those that are invariant with
// respect to Unicode vs. ANSI.  Therefore, we can call GetTextMetricsA for
// both cases.

    if ( !GetTextMetricsA(hdc, &tm) )
    {
        WARNING("wglUseFontBitmapsAW: GetTextMetricsA failed\n");
        return bRet;
    }

// If its a TrueType font, we can get ABC spacing.

    if ( bTrueType = (tm.tmPitchAndFamily & TMPF_TRUETYPE) )
    {
    // Allocate memory for array of ABC data.

        if ( (pabc = (LPABC) ALLOC(sizeof(ABC) * count)) == (LPABC) NULL )
        {
            WARNING("wglUseFontBitmapsAW: Alloc of pabc failed\n");
            return bRet;
        }

    // Get ABC metrics.

        if ( bUnicode )
        {
            if ( !GetCharABCWidthsW(hdc, first, first + count - 1, pabc) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharABCWidthsW failed\n");
                FREE(pabc);
                return bRet;
            }
        }
        else
        {
            if ( !GetCharABCWidthsA(hdc, first, first + count - 1, pabc) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharABCWidthsA failed\n");
                FREE(pabc);
                return bRet;
            }
        }

    // Find max glyph width.

        for (pabcTmp = pabc, pabcEnd = pabc + count;
             pabcTmp < pabcEnd;
             pabcTmp++)
        {
            if (iMaxWidth < (int) pabcTmp->abcB)
                iMaxWidth = pabcTmp->abcB;
        }
    }

// Otherwise we will have to use just the advance width and assume
// A = C = 0.

    else
    {
    // Allocate memory for array of ABC data.

        if ( (piWidth = (LPINT) ALLOC(sizeof(INT) * count)) == (LPINT) NULL )
        {
            WARNING("wglUseFontBitmapsAW: Alloc of pabc failed\n");
            return bRet;
        }

    // Get char widths.

        if ( bUnicode )
        {
            if ( !GetCharWidthW(hdc, first, first + count - 1, piWidth) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharWidthW failed\n");
                FREE(piWidth);
                return bRet;
            }
        }
        else
        {
            if ( !GetCharWidthA(hdc, first, first + count - 1, piWidth) )
            {
                WARNING("wglUseFontBitmapsAW: GetCharWidthA failed\n");
                FREE(piWidth);
                return bRet;
            }
        }

    // Find max glyph width.

        for (piTmp = piWidth, piWidthEnd = piWidth + count;
             piTmp < piWidthEnd;
             piTmp++)
        {
            if (iMaxWidth < *piTmp)
                iMaxWidth = *piTmp;
        }
    }

// Compute the dword aligned width.  Bitmap scanlines must be aligned.

    iBitmapWidth = (iMaxWidth + 31) & -32;

// Allocate memory for the DIB.

    if ( (pv = (PVOID)
          ALLOC((iBitmapWidth / 8) * tm.tmHeight)) == (PVOID) NULL )
    {
        WARNING("wglUseFontBitmapsAW: Alloc of pv failed\n");
        (bTrueType) ? FREE(pabc) : FREE(piWidth);
        return bRet;
    }

// Create compatible DC/bitmap big enough to accomodate the biggest glyph
// in the range requested.

    //!!!XXX -- Future optimization: use CreateDIBSection so that we
    //!!!XXX    don't need to do a GetDIBits for each glyph.  Saves
    //!!!XXX    lots of CSR overhead.

    hdcMem = CreateCompatibleDC(hdc);
    if ( (hbm = CreateBitmap(iBitmapWidth, tm.tmHeight, 1, 1, (VOID *) NULL)) == (HBITMAP) NULL )
    {
        WARNING("wglUseFontBitmapsAW: CreateBitmap failed\n");
        (bTrueType) ? FREE(pabc) : FREE(piWidth);
        FREE(pv);
        DeleteDC(hdcMem);
        return bRet;
    }
    SelectObject(hdcMem, hbm);
    SelectObject(hdcMem, GetCurrentObject(hdc, OBJ_FONT));
    SetMapMode(hdcMem, MM_TEXT);
    SetTextAlign(hdcMem, TA_TOP | TA_LEFT);
    SetBkColor(hdcMem, RGB(0, 0, 0));
    SetBkMode(hdcMem, OPAQUE);
    SetTextColor(hdcMem, RGB(255, 255, 255));

// Setup bitmap info header to retrieve a DIB from the compatible bitmap.

    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = iBitmapWidth;
    pbmi->bmiHeader.biHeight        = tm.tmHeight;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 1;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;
    pbmi->bmiColors[0].rgbRed   = 0;
    pbmi->bmiColors[0].rgbGreen = 0;
    pbmi->bmiColors[0].rgbBlue  = 0;
    pbmi->bmiColors[1].rgbRed   = 0xff;
    pbmi->bmiColors[1].rgbGreen = 0xff;
    pbmi->bmiColors[1].rgbBlue  = 0xff;

// Setup OpenGL to accept our bitmap format.

    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &iUnpackRowLength);
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &iUnpackAlign);

    if (glGetError() != GL_NO_ERROR)
    {
        //XXX too noisy on debug builds running stress with mode changes
        //WARNING("wglUseFontBitmapsAW: failed to get GL state\n");
        goto wglUseFontBitmapsAW_exit;
    }

    glPixelStorei(GL_UNPACK_ROW_LENGTH, iBitmapWidth);
    if (glGetError() != GL_NO_ERROR)
    {
        //XXX too noisy on debug builds running stress with mode changes
        //WARNING("wglUseFontBitmapsAW: failed to set GL state, row length\n");
        goto wglUseFontBitmapsAW_restore_state;
    }
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    if (glGetError() != GL_NO_ERROR)
    {
        //XXX too noisy on debug builds running stress with mode changes
        //WARNING("wglUseFontBitmapsAW: failed to set GL state, alignment\n");
        goto wglUseFontBitmapsAW_restore_state;
    }

// Get the glyphs.  Each glyph is rendered one at a time into the the
// memory DC with ExtTextOutW (notice that the optional rectangle is
// used to clear the background).  Each glyph is then copied out of the
// memory DC's bitmap with GetDIBits into a buffer.  This buffer is passed
// to glBitmap as each display list is created.

    rc.left = 0;
    rc.top = 0;
    rc.right = iBitmapWidth;
    rc.bottom = tm.tmHeight;

    pabcTmp = pabc;
    piTmp = piWidth;
    
    for (wc = (WCHAR) first; wc < (WCHAR) (first + count); wc++, listBase++)
    {
        //!!!XXX -- Future optimization: grab all the glyphs with a single
        //!!!XXX    call to ExtTextOutA and GetDIBits into a large bitmap.
        //!!!XXX    This would save a lot of per glyph CSR and call overhead.
        //!!!XXX    A tall, thin bitmap with the glyphs arranged vertically
        //!!!XXX    would be convenient because then we wouldn't have to change
        //!!!XXX    the OpenGL pixel store row length for each glyph (which
        //!!!XXX    we would need to do if the glyphs were printed horizontal).

        if ( bUnicode )
        {
            if ( !ExtTextOutW(hdcMem, bTrueType ? -pabcTmp->abcA : 0, 0, ETO_OPAQUE, &rc, &wc, 1, (INT *) NULL) ||
                 !GetDIBits(hdcMem, hbm, 0, tm.tmHeight, pv, pbmi, DIB_RGB_COLORS) )
            {
                WARNING("wglUseFontBitmapsAW: failed to render glyph\n");
                goto wglUseFontBitmapsAW_restore_state;
            }
        }
        else
        {
            if ( !ExtTextOutA(hdcMem, bTrueType ? -pabcTmp->abcA : 0, 0, ETO_OPAQUE, &rc, (LPCSTR) &wc, 1, (INT *) NULL) ||
                 !GetDIBits(hdcMem, hbm, 0, tm.tmHeight, pv, pbmi, DIB_RGB_COLORS) )
            {
                WARNING("wglUseFontBitmapsAW: failed to render glyph\n");
                goto wglUseFontBitmapsAW_restore_state;
            }
        }

        glNewList(listBase, GL_COMPILE);
        glBitmap((GLsizei) iBitmapWidth,
                 (GLsizei) tm.tmHeight,
                 (GLfloat) (bTrueType ? -pabcTmp->abcA : 0),
                 (GLfloat) tm.tmDescent,
                 (GLfloat) (bTrueType ? (pabcTmp->abcA + pabcTmp->abcB + pabcTmp->abcC) : *piTmp),
                 (GLfloat) 0.0,
                 (GLubyte *) pv);
        glEndList();

        if (bTrueType)
            pabcTmp++;
        else
            piTmp++;
    }

// We can finally return success.

    bRet = TRUE;

// Free resources.

wglUseFontBitmapsAW_restore_state:
    glPixelStorei(GL_UNPACK_ROW_LENGTH, iUnpackRowLength);
    glPixelStorei(GL_UNPACK_ALIGNMENT, iUnpackAlign);
wglUseFontBitmapsAW_exit:
    (bTrueType) ? FREE(pabc) : FREE(piWidth);
    FREE(pv);
    DeleteDC(hdcMem);
    DeleteObject(hbm);

    return bRet;
}

/******************************Public*Routine******************************\
*
* wglShareLists
*
* Allows a rendering context to share the display lists of another RC
*
* Returns:
*  TRUE if successful, FALSE otherwise
*
* History:
*  Tue Dec 13 14:57:17 1994     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI
wglShareLists(HGLRC hrcSource, HGLRC hrcShare)
{
    BOOL fRet;
    PLRC plrcSource, plrcShare;
    ULONG irc;
    PLHE plheRC;
    HANDLE hrcSrvSource, hrcSrvShare;

    GLFLUSH();
    
    fRet = FALSE;

    // Validate the contexts

    if (cLockHandle((ULONG_PTR)hrcSource) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglShareLists: can't lock hrcSource 0x%lx\n",
                  hrcSource);
        goto wglShareListsEnd_nolock;
    }
    irc = MASKINDEX(hrcSource);
    plheRC = pLocalTable + irc;
    plrcSource = (PLRC)plheRC->pv;
    hrcSrvSource = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcSource->ident == LRC_IDENTIFIER,
                 "wglShareLists: Bad plrc\n");
    
    if (cLockHandle((ULONG_PTR)hrcShare) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglShareLists: can't lock hrcShare 0x%lx\n",
                  hrcShare);
        goto wglShareListsEnd_onelock;
    }
    irc = MASKINDEX(hrcShare);
    plheRC = pLocalTable + irc;
    plrcShare = (PLRC)plheRC->pv;
    hrcSrvShare = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcShare->ident == LRC_IDENTIFIER,
                 "wglShareLists: Bad plrc\n");

#ifdef GL_METAFILE
    // Metafile RC's can't share lists to ensure that metafiles are
    // completely self-sufficient
    if (plrcSource->uiGlsCaptureContext != 0 ||
        plrcShare->uiGlsCaptureContext != 0 ||
        plrcSource->uiGlsPlaybackContext != 0 ||
        plrcShare->uiGlsPlaybackContext != 0)
    {
        DBGLEVEL(LEVEL_ERROR,
                 "wglShareLists: Attempt to share metafile RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        goto wglShareListsEnd;
    }
#endif
    
    // Lists can only be shared between like implementations so make
    // sure that both contexts are either driver contexts or generic
    // contexts
    if ((plrcSource->dhrc != 0) != (plrcShare->dhrc != 0))
    {
        DBGLEVEL(LEVEL_ERROR, "wglShareLists: mismatched implementations\n");
        SetLastError(ERROR_INVALID_FUNCTION);
        goto wglShareListsEnd;
    }

    if (plrcSource->dhrc == 0)
    {
        PIXELFORMATDESCRIPTOR *ppfdShare, *ppfdSource;
        
        // Fail sharing unless color parameters match for the two contexts
        ppfdShare = &((__GLGENcontext *)hrcSrvShare)->gsurf.pfd;
        ppfdSource = &((__GLGENcontext *)hrcSrvSource)->gsurf.pfd;

        if (ppfdShare->iPixelType != ppfdSource->iPixelType ||
            ppfdShare->cColorBits != ppfdSource->cColorBits ||
            ppfdShare->cRedBits != ppfdSource->cRedBits ||
            ppfdShare->cRedShift != ppfdSource->cRedShift ||
            ppfdShare->cGreenBits != ppfdSource->cGreenBits ||
            ppfdShare->cGreenShift != ppfdSource->cGreenShift ||
            ppfdShare->cBlueBits != ppfdSource->cBlueBits ||
            ppfdShare->cBlueShift != ppfdSource->cBlueShift ||
            ppfdShare->cAlphaBits != ppfdSource->cAlphaBits ||
            ppfdShare->cAlphaShift != ppfdSource->cAlphaShift ||
	    (ppfdShare->dwFlags & PFD_GENERIC_ACCELERATED) !=
	    (ppfdSource->dwFlags & PFD_GENERIC_ACCELERATED))
        {
            SetLastError(ERROR_INVALID_PIXEL_FORMAT);
            goto wglShareListsEnd;
        }
        
        // For generic contexts, tell the server to share the lists
        
        fRet = __wglShareLists(hrcSrvShare, hrcSrvSource);
        if (!fRet)
        {
            DBGERROR("wglShareLists: server call failed\n");
        }
    }
    else
    {
        // For device contexts tell the server to share the lists
        
        // Ensure that both implementations are the same
        if (plrcSource->pGLDriver != plrcShare->pGLDriver)
        {
            DBGLEVEL(LEVEL_ERROR, "wglShareLists: mismatched "
                     "implementations\n");
            SetLastError(ERROR_INVALID_FUNCTION);
            goto wglShareListsEnd;
        }
        
        ASSERTOPENGL(plrcSource->pGLDriver != NULL,
                     "wglShareLists: No GLDriver\n");

        // Older drivers may not support this entry point, so
        // fail the call if they don't

        if (plrcSource->pGLDriver->pfnDrvShareLists == NULL)
        {
            WARNING("wglShareLists called on driver context "
                    "without driver support\n");
            SetLastError(ERROR_NOT_SUPPORTED);
        }
        else
        {
            fRet = plrcSource->pGLDriver->pfnDrvShareLists(plrcSource->dhrc,
                                                           plrcShare->dhrc);
        }
    }

wglShareListsEnd:
    vUnlockHandle((ULONG_PTR)hrcShare);
wglShareListsEnd_onelock:
    vUnlockHandle((ULONG_PTR)hrcSource);
wglShareListsEnd_nolock:
    return fRet;
}

/******************************Public*Routine******************************\
*
* wglGetDefaultProcAddress
*
* Returns generic extension functions for metafiling
*
* History:
*  Tue Nov 28 16:40:35 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PROC WINAPI wglGetDefaultProcAddress(LPCSTR lpszProc)
{
    return pfnGenGlExtProc(lpszProc);
}

/******************************Public*Routine******************************\
* wglGetProcAddress
*
* The wglGetProcAddress function returns the address of an OpenGL extension
* function to be used with the current OpenGL rendering context.
*
* Arguments:
*   lpszProc   - Points to a null-terminated string containing the function
*                name.  The function must be an extension supported by the
*                implementation.
*
* Returns:
*   If the function succeeds, the return value is the address of the extension
*   function.  If no current context exists or the function fails, the return
*   value is NULL. To get extended error information, call GetLastError. 
*
* History:
*  Thu Dec 01 13:50:22 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PROC WINAPI wglGetProcAddress(LPCSTR lpszProc)
{
    PLRC  plrc = GLTEB_CLTCURRENTRC();

    DBGENTRY("wglGetProcAddress\n");

// Flush OpenGL calls.

    GLFLUSH();

// Return error if there is no current RC.

    if (!plrc)
    {
        WARNING("wglGetProcAddress: no current RC\n");
        SetLastError(ERROR_INVALID_HANDLE);
        return((PROC) NULL);
    }

// Handle generic RC.
// Return the generic extension function entry point

    if (!plrc->dhrc)
        return(pfnGenGlExtProc(lpszProc));

// Handle driver RC.
// There are 3 cases:
//   1. New drivers that support DrvGetProcAddress.
//   2. Old drivers that don't support DrvGetProcAddress but export the function
//   3. If we fail to obtain a function address in 1 and 2, it may still be
//      simulated by the generic implemenation for the driver
//      (e.g. glDrawArraysEXT).  Return the simulated entry point if found.

    if (plrc->pGLDriver->pfnDrvGetProcAddress)
    {
// Case 1
        PROC pfn = plrc->pGLDriver->pfnDrvGetProcAddress(lpszProc);
        if (pfn)
            return(pfn);
    }
#ifdef OBSOLETE
    else
    {
// Case 2
        PROC pfn = GetProcAddress(plrc->pGLDriver->hModule, lpszProc);
        if (pfn)
            return(pfn);
    }
#endif

// Case 3
    return (pfnSimGlExtProc(lpszProc));
}

/******************************Public*Routine******************************\
* pfnGenGlExtProc
*
* Return the generic implementation extension function address.
*
* Returns NULL if the function is not found.
*
* History:
*  Thu Dec 01 13:50:22 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

typedef struct _GLEXTPROC {
    LPCSTR szProc;      // extension function name
    PROC   Proc;        // extension function address
} GLEXTPROC, *PGLEXTPROC;

// Extension functions supported by the generic implementation
// See also genglExtProcsSim for simulations.
// NOTE: remember to update GL_EXTENSIONS in glGetString.

GLEXTPROC genglExtProcs[] =
{
    { "glAddSwapHintRectWIN"   , (PROC) glAddSwapHintRectWIN      },
    { "glColorTableEXT"        , (PROC) glColorTableEXT           },
    { "glColorSubTableEXT"     , (PROC) glColorSubTableEXT        },
    { "glGetColorTableEXT"     , (PROC) glGetColorTableEXT        },
    { "glGetColorTableParameterivEXT", (PROC) glGetColorTableParameterivEXT},
    { "glGetColorTableParameterfvEXT", (PROC) glGetColorTableParameterfvEXT},
    { "glDrawRangeElementsWIN", (PROC) glDrawRangeElementsWIN},
#ifdef GL_EXT_flat_paletted_lighting
    { "glColorTableParameterivEXT", (PROC) glColorTableParameterivEXT},
    { "glColorTableParameterfvEXT", (PROC) glColorTableParameterfvEXT},
#endif // GL_EXT_flat_paletted_lighting
#ifdef GL_WIN_multiple_textures
    { "glCurrentTextureIndexWIN", (PROC) glCurrentTextureIndexWIN },
    { "glMultiTexCoord1dWIN", (PROC) glMultiTexCoord1dWIN },
    { "glMultiTexCoord1dvWIN", (PROC) glMultiTexCoord1dvWIN },
    { "glMultiTexCoord1fWIN", (PROC) glMultiTexCoord1fWIN },
    { "glMultiTexCoord1fvWIN", (PROC) glMultiTexCoord1fvWIN },
    { "glMultiTexCoord1iWIN", (PROC) glMultiTexCoord1iWIN },
    { "glMultiTexCoord1ivWIN", (PROC) glMultiTexCoord1ivWIN },
    { "glMultiTexCoord1sWIN", (PROC) glMultiTexCoord1sWIN },
    { "glMultiTexCoord1svWIN", (PROC) glMultiTexCoord1svWIN },
    { "glMultiTexCoord2dWIN", (PROC) glMultiTexCoord2dWIN },
    { "glMultiTexCoord2dvWIN", (PROC) glMultiTexCoord2dvWIN },
    { "glMultiTexCoord2fWIN", (PROC) glMultiTexCoord2fWIN },
    { "glMultiTexCoord2fvWIN", (PROC) glMultiTexCoord2fvWIN },
    { "glMultiTexCoord2iWIN", (PROC) glMultiTexCoord2iWIN },
    { "glMultiTexCoord2ivWIN", (PROC) glMultiTexCoord2ivWIN },
    { "glMultiTexCoord2sWIN", (PROC) glMultiTexCoord2sWIN },
    { "glMultiTexCoord2svWIN", (PROC) glMultiTexCoord2svWIN },
    { "glMultiTexCoord3dWIN", (PROC) glMultiTexCoord3dWIN },
    { "glMultiTexCoord3dvWIN", (PROC) glMultiTexCoord3dvWIN },
    { "glMultiTexCoord3fWIN", (PROC) glMultiTexCoord3fWIN },
    { "glMultiTexCoord3fvWIN", (PROC) glMultiTexCoord3fvWIN },
    { "glMultiTexCoord3iWIN", (PROC) glMultiTexCoord3iWIN },
    { "glMultiTexCoord3ivWIN", (PROC) glMultiTexCoord3ivWIN },
    { "glMultiTexCoord3sWIN", (PROC) glMultiTexCoord3sWIN },
    { "glMultiTexCoord3svWIN", (PROC) glMultiTexCoord3svWIN },
    { "glMultiTexCoord4dWIN", (PROC) glMultiTexCoord4dWIN },
    { "glMultiTexCoord4dvWIN", (PROC) glMultiTexCoord4dvWIN },
    { "glMultiTexCoord4fWIN", (PROC) glMultiTexCoord4fWIN },
    { "glMultiTexCoord4fvWIN", (PROC) glMultiTexCoord4fvWIN },
    { "glMultiTexCoord4iWIN", (PROC) glMultiTexCoord4iWIN },
    { "glMultiTexCoord4ivWIN", (PROC) glMultiTexCoord4ivWIN },
    { "glMultiTexCoord4sWIN", (PROC) glMultiTexCoord4sWIN },
    { "glMultiTexCoord4svWIN", (PROC) glMultiTexCoord4svWIN },
    { "glBindNthTextureWIN", (PROC) glBindNthTextureWIN },
    { "glNthTexCombineFuncWIN", (PROC) glNthTexCombineFuncWIN },
#endif // GL_WIN_multiple_textures
};

static PROC pfnGenGlExtProc(LPCSTR lpszProc)
{
    CONST CHAR *pch1, *pch2;
    int  i;

    DBGENTRY("pfnGenGlExtProc\n");

// Return extension function address if it is found.

    for (i = 0; i < sizeof(genglExtProcs) / sizeof(genglExtProcs[0]); i++)
    {
        // Compare names.
        for (pch1 = lpszProc, pch2 = genglExtProcs[i].szProc;
             *pch1 == *pch2 && *pch1;
             pch1++, pch2++)
            ;

        // If found, return the address.
        if (*pch1 == *pch2 && !*pch1)
            return genglExtProcs[i].Proc;
    }

// Extension is not supported by the generic implementation, return NULL.

    SetLastError(ERROR_PROC_NOT_FOUND);
    return((PROC) NULL);
}

/******************************Public*Routine******************************\
* pfnSimGlExtProc
*
* Return the extension function address that is the generic implemenation's
* simulation for the client drivers.  The simulation is used only if the
* driver does not support an extension that is desirable to apps.
*
* Returns NULL if the function is not found.
*
* History:
*  Thu Dec 01 13:50:22 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

// Extension functions simulated by the generic implementation for the client
// drivers
// NOTE: remember to update GL_EXTENSIONS in glGetString.

static PROC pfnSimGlExtProc(LPCSTR lpszProc)
{
// Extension is not supported by the generic implementation, return NULL.

    SetLastError(ERROR_PROC_NOT_FOUND);
    return((PROC) NULL);
}

/******************************Public*Routine******************************\
*
* wglCopyContext
*
* Copies all of one context's state to another one
*
* Returns:
*  TRUE if successful, FALSE otherwise
*
* History:
*  Fri May 26 14:57:17 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI
wglCopyContext(HGLRC hrcSource, HGLRC hrcDest, UINT fuMask)
{
    BOOL fRet;
    PLRC plrcSource, plrcDest;
    ULONG irc;
    PLHE plheRC;
    HANDLE hrcSrvSource, hrcSrvDest;

    GLFLUSH();
    
    fRet = FALSE;

    // Validate the contexts

    if (cLockHandle((ULONG_PTR)hrcSource) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglCopyContext: can't lock hrcSource 0x%lx\n",
                  hrcSource);
        goto wglCopyContextEnd_nolock;
    }
    irc = MASKINDEX(hrcSource);
    plheRC = pLocalTable + irc;
    plrcSource = (PLRC)plheRC->pv;
    hrcSrvSource = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcSource->ident == LRC_IDENTIFIER,
                 "wglCopyContext: Bad plrc\n");
    
    if (cLockHandle((ULONG_PTR)hrcDest) <= 0)
    {
        DBGLEVEL1(LEVEL_ERROR, "wglCopyContext: can't lock hrcDest 0x%lx\n",
                  hrcDest);
        goto wglCopyContextEnd_onelock;
    }
    irc = MASKINDEX(hrcDest);
    plheRC = pLocalTable + irc;
    plrcDest = (PLRC)plheRC->pv;
    hrcSrvDest = (HANDLE) plheRC->hgre;
    ASSERTOPENGL(plrcDest->ident == LRC_IDENTIFIER,
                 "wglCopyContext: Bad plrc\n");

    // Context can only be copied between like implementations so make
    // sure that both contexts are either driver contexts or generic
    // contexts
    if ((plrcSource->dhrc != 0) != (plrcDest->dhrc != 0))
    {
        DBGLEVEL(LEVEL_ERROR, "wglCopyContext: mismatched implementations\n");
        SetLastError(ERROR_INVALID_FUNCTION);
        goto wglCopyContextEnd;
    }

    // The destination context cannot be current to a thread
    if (plrcDest->tidCurrent != INVALID_THREAD_ID)
    {
        DBGLEVEL(LEVEL_ERROR, "wglCopyContext: destination has tidCurrent\n");
        SetLastError(ERROR_INVALID_HANDLE);
        goto wglCopyContextEnd;
    }
    
    if (plrcSource->dhrc == 0)
    {
        // For generic contexts, tell the server to share the lists
        
        fRet = __wglCopyContext(hrcSrvSource, hrcSrvDest, fuMask);
        if (!fRet)
        {
            DBGERROR("wglCopyContext: server call failed\n");
        }
    }
    else
    {
        // For device contexts tell the driver to copy the context
        
        // Ensure that both implementations are the same
        if (plrcSource->pGLDriver != plrcDest->pGLDriver)
        {
            DBGLEVEL(LEVEL_ERROR, "wglCopyContext: mismatched "
                     "implementations\n");
            SetLastError(ERROR_INVALID_FUNCTION);
            goto wglCopyContextEnd;
        }
        
        ASSERTOPENGL(plrcSource->pGLDriver != NULL,
                     "wglCopyContext: No GLDriver\n");

        // Older drivers may not support this entry point, so
        // fail the call if they don't

        if (plrcSource->pGLDriver->pfnDrvCopyContext == NULL)
        {
            WARNING("wglCopyContext called on driver context "
                    "without driver support\n");
            SetLastError(ERROR_NOT_SUPPORTED);
        }
        else
        {
            fRet = plrcSource->pGLDriver->pfnDrvCopyContext(plrcSource->dhrc,
                                                            plrcDest->dhrc,
                                                            fuMask);
        }
    }

wglCopyContextEnd:
    vUnlockHandle((ULONG_PTR)hrcDest);
wglCopyContextEnd_onelock:
    vUnlockHandle((ULONG_PTR)hrcSource);
wglCopyContextEnd_nolock:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\wglcli.c ===
/******************************Module*Header*******************************\
* Module Name: wglcli.c
*
* Routines to support OpenGL client implementation.
*
* Created: 01-17-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef _CLIENTSIDE_

#include <wingdip.h>

#include <glp.h>
#include <glscreen.h>
#include <glgenwin.h>

#include "wgldef.h"

PGLDRIVER pgldrvLoadInstalledDriver(HDC hdc);

// Mirror code from gre\rcobj.cxx
// Need DC and RC validation similar to those of DCOBJ and RCOBJ!!!

HANDLE __wglCreateContext(GLWINDOWID *pgwid, GLSURF *pgsurf)
{
    HANDLE hrcSrv;

    if (hrcSrv = (HANDLE) glsrvCreateContext(pgwid, pgsurf))
    {
        return(hrcSrv);
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return((HANDLE) 0);
}

BOOL __wglDeleteContext(HANDLE hrcSrv)
{
    wglValidateWindows();
    return(glsrvDeleteContext((PVOID) hrcSrv));
}

BOOL __wglMakeCurrent(GLWINDOWID *pgwid, HANDLE hrcSrv, BOOL bMeta)
{
    BOOL  bRet = FALSE;
    ULONG iError = ERROR_INVALID_HANDLE;    // Default error code
    GLGENwindow *pwnd;

    wglValidateWindows();
    
    if (!hrcSrv)
    {
        glsrvLoseCurrent(GLTEB_SRVCONTEXT());
        return(TRUE);
    }

    pwnd = pwndGetFromID(pgwid);

    // Metafiles are allowed to not have pixel formats and therefore
    // to not have GLGENwindows.  Other types must have a genwin.
    if (pwnd != NULL || bMeta)
    {
        iError = ERROR_NOT_ENOUGH_MEMORY;
        bRet = glsrvMakeCurrent(pgwid, (PVOID) hrcSrv, pwnd);
    }
    else
    {
        WARNING("__wglMakeCurrent: No pixel genwin\n");
        iError = ERROR_INVALID_PIXEL_FORMAT;
    }
        
    if (pwnd != NULL)
    {
        pwndRelease(pwnd);
    }

    if (!bRet)
    {
        SetLastError(iError);
    }

    return(bRet);
}

BOOL __wglShareLists(HANDLE hrcSrvShare, HANDLE hrcSrvSource)
{
    ULONG iError;

    iError = glsrvShareLists((VOID *) hrcSrvShare, (VOID *) hrcSrvSource);

    if (iError == ERROR_SUCCESS)
    {
        return(TRUE);
    }
    else
    {
        SetLastError(iError);
        return(FALSE);
    }
}

BOOL __wglAttention()
{
    return
    (
        glsrvAttention((VOID *) NULL, (VOID *) GLTEB_SRVCONTEXT(),
                       (VOID *) NULL, (VOID *) NULL)
    );
}

int WINAPI __DrvDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                    LPPIXELFORMATDESCRIPTOR ppfd)
{
    int iRet = 0;
    PGLDRIVER pglDriver;

    if ((pglDriver = pgldrvLoadInstalledDriver(hdc)) &&
        (pglDriver->dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS))
    {
	ASSERTOPENGL(pglDriver->pfnDrvDescribePixelFormat != NULL,
                     "Missing DrvDescribePixelFormat\n");
	iRet = pglDriver->pfnDrvDescribePixelFormat(hdc, ipfd, cjpfd, ppfd);
    }
#ifndef _WIN95_
    else
    {
        iRet = GdiDescribePixelFormat(hdc, ipfd, cjpfd, ppfd);
    }
#endif
    return iRet;
}

BOOL WINAPI __DrvSetPixelFormat(HDC hdc, int ipfd, PVOID *pwnd)
{
    BOOL bRet = FALSE;
    PGLDRIVER pglDriver;
    
    if ((pglDriver = pgldrvLoadInstalledDriver(hdc)) &&
        (pglDriver->dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS))
    {
	ASSERTOPENGL(pglDriver->pfnDrvSetPixelFormat != NULL,
                     "Missing DrvSetPixelFormat\n");
	bRet = pglDriver->pfnDrvSetPixelFormat(hdc, ipfd);
    }
#ifndef _WIN95_
    else
    {
        bRet = GdiSetPixelFormat(hdc, ipfd);
    }
#endif
    
    if ( bRet && pwnd )
    {
        ((GLGENwindow *) pwnd)->pvDriver = (PVOID) pglDriver;
        ((GLGENwindow *) pwnd)->ulFlags |= GLGENWIN_DRIVERSET;
    }

    return bRet;
}

BOOL WINAPI __DrvSwapBuffers(HDC hdc, BOOL bFinish)
{
    BOOL bRet = FALSE;
    PGLDRIVER pglDriver;

    if ((pglDriver = pgldrvLoadInstalledDriver(hdc)) &&
        (pglDriver->dwFlags & GLDRIVER_CLIENT_BUFFER_CALLS))
    {
	ASSERTOPENGL(pglDriver->pfnDrvSwapBuffers != NULL,
                     "Missing DrvSwapBuffers\n");

        // If the driver has not indicated that it doesn't
        // need glFinish synchronization on swap then call
        // glFinish to sync things.
        if (bFinish && !(pglDriver->dwFlags & GLDRIVER_NO_FINISH_ON_SWAP))
        {
            glFinish();
        }
            
	bRet = pglDriver->pfnDrvSwapBuffers(hdc);
    }
#ifndef _WIN95_
    else
    {
        if (bFinish)
        {
            // In this case we always call glFinish for compatibility
            // with previous version's behavior.
            glFinish();
        }
        
        bRet = GdiSwapBuffers(hdc);
    }
#endif
    return bRet;
}

BOOL __wglCopyContext(HANDLE hrcSrvSrc, HANDLE hrcSrvDest, UINT fuFlags)
{
    return glsrvCopyContext((VOID *) hrcSrvSrc, (VOID *) hrcSrvDest, fuFlags);
}

#endif // _CLIENTSIDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\wglsrv.c ===
/******************************Module*Header*******************************\
* Module Name: wglsrv.c
*
* Routines to support OpenGL client-server implementation on Windows NT.
*
* Created: 01-17-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "wgldef.h"

#ifndef _CLIENTSIDE_

HANDLE __wglCreateContext(HDC hdc, HDC hdcSrvIn, LONG iLayerPlane)
{
    HDC    hdcSrv;
    HANDLE hrcSrv = (HANDLE) 0;

// Get the server-side DC handle.

    if (hdcSrvIn != NULL)
    {
        hdcSrv = hdcSrvIn;
    }
    else
    {
        hdcSrv = GdiConvertDC(hdc);
    }
    
    if (hdcSrv == (HDC) 0)
    {
        WARNING1("__wglCreateContext: unexpected bad hdc: 0x%lx\n", hdc);
        return(hrcSrv);
    }

    BEGINMSG(MSG_WGLCREATECONTEXT,WGLCREATECONTEXT)
        pmsg->hdc = hdcSrv;
        hrcSrv = (HANDLE) CALLSERVER();
    ENDMSG
MSGERROR:
    return(hrcSrv);
}

BOOL __wglDeleteContext(HANDLE hrcSrv)
{
    BOOL bRet = FALSE;

    BEGINMSG(MSG_WGLDELETECONTEXT,WGLDELETECONTEXT)
        pmsg->hrc = (HGLRC) hrcSrv;
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglMakeCurrent(HDC hdc, HANDLE hrcSrv, HDC hdcSrvIn)
{
    HDC  hdcSrv = (HDC) 0;
    BOOL bRet = FALSE;

// Get the server-side DC handle.

    if (hdc)
    {
        if (hdcSrvIn != NULL)
        {
            hdcSrv = hdcSrvIn;
        }
        else
        {
            hdcSrv = GdiConvertDC(hdc);
        }
        
        if (hdcSrv == (HDC) 0)
        {
            WARNING1("__wglMakeCurrent: unexpected bad hdc: 0x%lx\n", hdc);
            return(bRet);
        }
    }

    BEGINMSG(MSG_WGLMAKECURRENT,WGLMAKECURRENT)
        pmsg->hdc = hdcSrv;
        pmsg->hrc = hrcSrv;
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglShareLists(HANDLE hrcSrvShare, HANDLE hrcSrvSource)
{
    BOOL bRet = FALSE;

    BEGINMSG(MSG_WGLSHARELISTS, WGLSHARELISTS)
        pmsg->hrcSource = hrcSrvSource;
        pmsg->hrcShare = hrcSrvShare;
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglAttention()
{
    BOOL bRet = FALSE;

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    BEGINMSG(MSG_GLSBATTENTION, GLSBATTENTION)
        bRet = CALLSERVER();
    ENDMSG
MSGERROR:
    return(bRet);
}

BOOL __wglCopyContext(HANDLE hrcSrvSrc, HANDLE hrcSrvDest, UINT fuFlags)
{
    // Server implementation doesn't support this call
    return FALSE;
}

#endif // !_CLIENTSIDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\i386\gliapi.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: glapi.asm
;
; OpenGL API function entries for i386.
;
; Created: 11/16/1993
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1993 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include ks386.inc
        include glapi.inc
        .list

;#ifdef _CLIENTSIDE_
        .data
_DATA   SEGMENT DWORD PUBLIC 'DATA'
        extrn dwTlsOffset:DWORD
_DATA   ENDS
;#endif

; Macro for creating aligned public OpenGL API function
; This is modified from stdcall.inc.
;
; Do an indirect jump through the OpenGL function dispatch table in the TEB.
;
; Here is the previous code before we put the dispatch table in the TEB.
; It still works.
;       ;mov    eax,fs:TbglTable        ; get gl function table
;       ;jmp    DWORD PTR [eax+(offset glDispatchTable)+INDEX_&Func*4]

; NT - This macro must leave the TEB pointer in eax
; Win95 - This macro must leave the GLTEBINFO pointer in edx
MAKEOPENGLAPI   macro Func,N
        align   4
        ifb    <N>
            public      &Func&@0
            &Func&@0:
        else
            public      &Func&@&N
            &Func&@&N:
        endif
        ; Grab TEB pointer
        mov      eax, fs:[PcTeb]

        ; Add offset to reserved TLS storage slot
	mov      edx, eax
        add      edx, dword ptr dwTlsOffset

        ; Get GLTEBINFO pointer
        mov      edx, dword ptr [edx]

        ; Jump via dispatch table in GLTEBINFO
        jmp      dword ptr [edx+(INDEX_&Func*4)]
endm

; NT - This macro must leave the TEB pointer in eax
; Win95 - This macro must leave the GLTEBINFO pointer in edx
FASTOPENGLAPI   macro Func,N
        align   4
        ifb    <N>
            public      &Func&@0
            &Func&@0:
        else
            public      &Func&@&N
            &Func&@&N:
        endif
ifdef _WIN95_
        ; Grab TEB pointer
        mov      eax, fs:[PcTeb]

        ; Add offset to reserved TLS storage slot
	mov      edx, eax
        add      edx, dword ptr dwTlsOffset

        ; Get GLTEBINFO pointer
        mov      edx, dword ptr [edx]

        ; Jump via dispatch table in GLTEBINFO
        jmp      dword ptr [edx+(INDEX_&Func*4)]
else
        mov      eax, fs:[PcTeb]
        jmp      DWORD PTR [eax+TbglDispatchTable+(FASTINDEX_&Func*4)]
endif
endm

        .code
        align   4

; OpenGL API function entries
; The indices below are generated from the .cod file compiled from glapi.c

FASTOPENGLAPI   glCallList,4
FASTOPENGLAPI   glCallLists,12
FASTOPENGLAPI   glBegin,4
FASTOPENGLAPI   glColor3b,12
FASTOPENGLAPI   glColor3bv,4
FASTOPENGLAPI   glColor3d,24
FASTOPENGLAPI   glColor3dv,4
FASTOPENGLAPI   glColor3f,12
FASTOPENGLAPI   glColor3fv,4
FASTOPENGLAPI   glColor3i,12
FASTOPENGLAPI   glColor3iv,4
FASTOPENGLAPI   glColor3s,12
FASTOPENGLAPI   glColor3sv,4
FASTOPENGLAPI   glColor3ub,12
FASTOPENGLAPI   glColor3ubv,4
FASTOPENGLAPI   glColor3ui,12
FASTOPENGLAPI   glColor3uiv,4
FASTOPENGLAPI   glColor3us,12
FASTOPENGLAPI   glColor3usv,4
FASTOPENGLAPI   glColor4b,16
FASTOPENGLAPI   glColor4bv,4
FASTOPENGLAPI   glColor4d,32
FASTOPENGLAPI   glColor4dv,4
FASTOPENGLAPI   glColor4f,16
FASTOPENGLAPI   glColor4fv,4
FASTOPENGLAPI   glColor4i,16
FASTOPENGLAPI   glColor4iv,4
FASTOPENGLAPI   glColor4s,16
FASTOPENGLAPI   glColor4sv,4
FASTOPENGLAPI   glColor4ub,16
FASTOPENGLAPI   glColor4ubv,4
FASTOPENGLAPI   glColor4ui,16
FASTOPENGLAPI   glColor4uiv,4
FASTOPENGLAPI   glColor4us,16
FASTOPENGLAPI   glColor4usv,4
FASTOPENGLAPI   glEdgeFlag,4
FASTOPENGLAPI   glEdgeFlagv,4
FASTOPENGLAPI   glEnd,0
FASTOPENGLAPI   glIndexd,8
FASTOPENGLAPI   glIndexdv,4
FASTOPENGLAPI   glIndexf,4
FASTOPENGLAPI   glIndexfv,4
FASTOPENGLAPI   glIndexi,4
FASTOPENGLAPI   glIndexiv,4
FASTOPENGLAPI   glIndexs,4
FASTOPENGLAPI   glIndexsv,4
FASTOPENGLAPI   glNormal3b,12
FASTOPENGLAPI   glNormal3bv,4
FASTOPENGLAPI   glNormal3d,24
FASTOPENGLAPI   glNormal3dv,4
FASTOPENGLAPI   glNormal3f,12
FASTOPENGLAPI   glNormal3fv,4
FASTOPENGLAPI   glNormal3i,12
FASTOPENGLAPI   glNormal3iv,4
FASTOPENGLAPI   glNormal3s,12
FASTOPENGLAPI   glNormal3sv,4
FASTOPENGLAPI   glTexCoord1d,8
FASTOPENGLAPI   glTexCoord1dv,4
FASTOPENGLAPI   glTexCoord1f,4
FASTOPENGLAPI   glTexCoord1fv,4
FASTOPENGLAPI   glTexCoord1i,4
FASTOPENGLAPI   glTexCoord1iv,4
FASTOPENGLAPI   glTexCoord1s,4
FASTOPENGLAPI   glTexCoord1sv,4
FASTOPENGLAPI   glTexCoord2d,16
FASTOPENGLAPI   glTexCoord2dv,4
FASTOPENGLAPI   glTexCoord2f,8
FASTOPENGLAPI   glTexCoord2fv,4
FASTOPENGLAPI   glTexCoord2i,8
FASTOPENGLAPI   glTexCoord2iv,4
FASTOPENGLAPI   glTexCoord2s,8
FASTOPENGLAPI   glTexCoord2sv,4
FASTOPENGLAPI   glTexCoord3d,24
FASTOPENGLAPI   glTexCoord3dv,4
FASTOPENGLAPI   glTexCoord3f,12
FASTOPENGLAPI   glTexCoord3fv,4
FASTOPENGLAPI   glTexCoord3i,12
FASTOPENGLAPI   glTexCoord3iv,4
FASTOPENGLAPI   glTexCoord3s,12
FASTOPENGLAPI   glTexCoord3sv,4
FASTOPENGLAPI   glTexCoord4d,32
FASTOPENGLAPI   glTexCoord4dv,4
FASTOPENGLAPI   glTexCoord4f,16
FASTOPENGLAPI   glTexCoord4fv,4
FASTOPENGLAPI   glTexCoord4i,16
FASTOPENGLAPI   glTexCoord4iv,4
FASTOPENGLAPI   glTexCoord4s,16
FASTOPENGLAPI   glTexCoord4sv,4
FASTOPENGLAPI   glVertex2d,16
FASTOPENGLAPI   glVertex2dv,4
FASTOPENGLAPI   glVertex2f,8
FASTOPENGLAPI   glVertex2fv,4
FASTOPENGLAPI   glVertex2i,8
FASTOPENGLAPI   glVertex2iv,4
FASTOPENGLAPI   glVertex2s,8
FASTOPENGLAPI   glVertex2sv,4
FASTOPENGLAPI   glVertex3d,24
FASTOPENGLAPI   glVertex3dv,4
FASTOPENGLAPI   glVertex3f,12
FASTOPENGLAPI   glVertex3fv,4
FASTOPENGLAPI   glVertex3i,12
FASTOPENGLAPI   glVertex3iv,4
FASTOPENGLAPI   glVertex3s,12
FASTOPENGLAPI   glVertex3sv,4
FASTOPENGLAPI   glVertex4d,32
FASTOPENGLAPI   glVertex4dv,4
FASTOPENGLAPI   glVertex4f,16
FASTOPENGLAPI   glVertex4fv,4
FASTOPENGLAPI   glVertex4i,16
FASTOPENGLAPI   glVertex4iv,4
FASTOPENGLAPI   glVertex4s,16
FASTOPENGLAPI   glVertex4sv,4
FASTOPENGLAPI   glMaterialf,12
FASTOPENGLAPI   glMaterialfv,12
FASTOPENGLAPI   glMateriali,12
FASTOPENGLAPI   glMaterialiv,12
FASTOPENGLAPI   glDisable,4
FASTOPENGLAPI   glEnable,4
FASTOPENGLAPI   glPopAttrib,0
FASTOPENGLAPI   glPushAttrib,4
FASTOPENGLAPI   glEvalCoord1d,8
FASTOPENGLAPI   glEvalCoord1dv,4
FASTOPENGLAPI   glEvalCoord1f,4
FASTOPENGLAPI   glEvalCoord1fv,4
FASTOPENGLAPI   glEvalCoord2d,16
FASTOPENGLAPI   glEvalCoord2dv,4
FASTOPENGLAPI   glEvalCoord2f,8
FASTOPENGLAPI   glEvalCoord2fv,4
FASTOPENGLAPI   glEvalPoint1,4
FASTOPENGLAPI   glEvalPoint2,8
FASTOPENGLAPI   glLoadIdentity,0
FASTOPENGLAPI   glLoadMatrixf,4
FASTOPENGLAPI   glLoadMatrixd,4
FASTOPENGLAPI   glMatrixMode,4
FASTOPENGLAPI   glMultMatrixf,4
FASTOPENGLAPI   glMultMatrixd,4
FASTOPENGLAPI   glPopMatrix,0
FASTOPENGLAPI   glPushMatrix,0
FASTOPENGLAPI   glRotated,32
FASTOPENGLAPI   glRotatef,16
FASTOPENGLAPI   glScaled,24
FASTOPENGLAPI   glScalef,12
FASTOPENGLAPI   glTranslated,24
FASTOPENGLAPI   glTranslatef,12
FASTOPENGLAPI   glArrayElement,4
FASTOPENGLAPI   glBindTexture,8
FASTOPENGLAPI   glColorPointer,16
FASTOPENGLAPI   glDisableClientState,4
FASTOPENGLAPI   glDrawArrays,12
FASTOPENGLAPI   glDrawElements,16
FASTOPENGLAPI   glEdgeFlagPointer,8
FASTOPENGLAPI   glEnableClientState,4
FASTOPENGLAPI   glIndexPointer,12
FASTOPENGLAPI   glIndexub,4
FASTOPENGLAPI   glIndexubv,4
FASTOPENGLAPI   glInterleavedArrays,12
FASTOPENGLAPI   glNormalPointer,12
FASTOPENGLAPI   glPolygonOffset,8
FASTOPENGLAPI   glTexCoordPointer,16
FASTOPENGLAPI   glVertexPointer,16
FASTOPENGLAPI   glGetPointerv,8
FASTOPENGLAPI   glPopClientAttrib,0
FASTOPENGLAPI   glPushClientAttrib,4
FASTOPENGLAPI   glDrawRangeElementsWIN,24
FASTOPENGLAPI   glColorTableEXT,24
FASTOPENGLAPI   glColorSubTableEXT,24
FASTOPENGLAPI   glCurrentTextureIndexWIN,4
FASTOPENGLAPI   glBindNthTextureWIN,12
FASTOPENGLAPI   glNthTexCombineFuncWIN,28
FASTOPENGLAPI   glMultiTexCoord1fWIN,8
FASTOPENGLAPI   glMultiTexCoord1fvWIN,8
FASTOPENGLAPI   glMultiTexCoord1iWIN,8
FASTOPENGLAPI   glMultiTexCoord1ivWIN,8
FASTOPENGLAPI   glMultiTexCoord2fWIN,12
FASTOPENGLAPI   glMultiTexCoord2fvWIN,8
FASTOPENGLAPI   glMultiTexCoord2iWIN,12
FASTOPENGLAPI   glMultiTexCoord2ivWIN,8

MAKEOPENGLAPI   glClear,4
MAKEOPENGLAPI   glClearAccum,16
MAKEOPENGLAPI   glClearIndex,4
MAKEOPENGLAPI   glClearColor,16
MAKEOPENGLAPI   glClearStencil,4
MAKEOPENGLAPI   glClearDepth,8
MAKEOPENGLAPI   glBitmap,28
MAKEOPENGLAPI   glTexImage1D,32
MAKEOPENGLAPI   glTexImage2D,36
MAKEOPENGLAPI   glCopyPixels,20
MAKEOPENGLAPI   glReadPixels,28
MAKEOPENGLAPI   glDrawPixels,20
MAKEOPENGLAPI   glRectd,32
MAKEOPENGLAPI   glRectdv,8
MAKEOPENGLAPI   glRectf,16
MAKEOPENGLAPI   glRectfv,8
MAKEOPENGLAPI   glRecti,16
MAKEOPENGLAPI   glRectiv,8
MAKEOPENGLAPI   glRects,16
MAKEOPENGLAPI   glRectsv,8
MAKEOPENGLAPI   glNewList,8
MAKEOPENGLAPI   glEndList,0
MAKEOPENGLAPI   glDeleteLists,8
MAKEOPENGLAPI   glGenLists,4
MAKEOPENGLAPI   glListBase,4
MAKEOPENGLAPI   glRasterPos2d,16
MAKEOPENGLAPI   glRasterPos2dv,4
MAKEOPENGLAPI   glRasterPos2f,8
MAKEOPENGLAPI   glRasterPos2fv,4
MAKEOPENGLAPI   glRasterPos2i,8
MAKEOPENGLAPI   glRasterPos2iv,4
MAKEOPENGLAPI   glRasterPos2s,8
MAKEOPENGLAPI   glRasterPos2sv,4
MAKEOPENGLAPI   glRasterPos3d,24
MAKEOPENGLAPI   glRasterPos3dv,4
MAKEOPENGLAPI   glRasterPos3f,12
MAKEOPENGLAPI   glRasterPos3fv,4
MAKEOPENGLAPI   glRasterPos3i,12
MAKEOPENGLAPI   glRasterPos3iv,4
MAKEOPENGLAPI   glRasterPos3s,12
MAKEOPENGLAPI   glRasterPos3sv,4
MAKEOPENGLAPI   glRasterPos4d,32
MAKEOPENGLAPI   glRasterPos4dv,4
MAKEOPENGLAPI   glRasterPos4f,16
MAKEOPENGLAPI   glRasterPos4fv,4
MAKEOPENGLAPI   glRasterPos4i,16
MAKEOPENGLAPI   glRasterPos4iv,4
MAKEOPENGLAPI   glRasterPos4s,16
MAKEOPENGLAPI   glRasterPos4sv,4
MAKEOPENGLAPI   glClipPlane,8
MAKEOPENGLAPI   glColorMaterial,8
MAKEOPENGLAPI   glCullFace,4
MAKEOPENGLAPI   glFogf,8
MAKEOPENGLAPI   glFogfv,8
MAKEOPENGLAPI   glFogi,8
MAKEOPENGLAPI   glFogiv,8
MAKEOPENGLAPI   glFrontFace,4
MAKEOPENGLAPI   glHint,8
MAKEOPENGLAPI   glLightf,12
MAKEOPENGLAPI   glLightfv,12
MAKEOPENGLAPI   glLighti,12
MAKEOPENGLAPI   glLightiv,12
MAKEOPENGLAPI   glLightModelf,8
MAKEOPENGLAPI   glLightModelfv,8
MAKEOPENGLAPI   glLightModeli,8
MAKEOPENGLAPI   glLightModeliv,8
MAKEOPENGLAPI   glLineStipple,8
MAKEOPENGLAPI   glLineWidth,4
MAKEOPENGLAPI   glPointSize,4
MAKEOPENGLAPI   glPolygonMode,8
MAKEOPENGLAPI   glPolygonStipple,4
MAKEOPENGLAPI   glScissor,16
MAKEOPENGLAPI   glFinish,0
MAKEOPENGLAPI   glShadeModel,4
MAKEOPENGLAPI   glTexParameterf,12
MAKEOPENGLAPI   glTexParameterfv,12
MAKEOPENGLAPI   glTexParameteri,12
MAKEOPENGLAPI   glTexParameteriv,12
MAKEOPENGLAPI   glTexEnvf,12
MAKEOPENGLAPI   glTexEnvfv,12
MAKEOPENGLAPI   glTexEnvi,12
MAKEOPENGLAPI   glTexEnviv,12
MAKEOPENGLAPI   glTexGend,16
MAKEOPENGLAPI   glTexGendv,12
MAKEOPENGLAPI   glTexGenf,12
MAKEOPENGLAPI   glTexGenfv,12
MAKEOPENGLAPI   glTexGeni,12
MAKEOPENGLAPI   glTexGeniv,12
MAKEOPENGLAPI   glFeedbackBuffer,12
MAKEOPENGLAPI   glSelectBuffer,8
MAKEOPENGLAPI   glRenderMode,4
MAKEOPENGLAPI   glInitNames,0
MAKEOPENGLAPI   glLoadName,4
MAKEOPENGLAPI   glPassThrough,4
MAKEOPENGLAPI   glPopName,0
MAKEOPENGLAPI   glPushName,4
MAKEOPENGLAPI   glDrawBuffer,4
MAKEOPENGLAPI   glStencilMask,4
MAKEOPENGLAPI   glColorMask,16
MAKEOPENGLAPI   glDepthMask,4
MAKEOPENGLAPI   glIndexMask,4
MAKEOPENGLAPI   glAccum,8
MAKEOPENGLAPI   glFlush,0
MAKEOPENGLAPI   glMap1d,32
MAKEOPENGLAPI   glMap1f,24
MAKEOPENGLAPI   glMap2d,56
MAKEOPENGLAPI   glMap2f,40
MAKEOPENGLAPI   glMapGrid1d,20
MAKEOPENGLAPI   glMapGrid1f,12
MAKEOPENGLAPI   glMapGrid2d,40
MAKEOPENGLAPI   glMapGrid2f,24
MAKEOPENGLAPI   glEvalMesh1,12
MAKEOPENGLAPI   glEvalMesh2,20
MAKEOPENGLAPI   glAlphaFunc,8
MAKEOPENGLAPI   glBlendFunc,8
MAKEOPENGLAPI   glLogicOp,4
MAKEOPENGLAPI   glStencilFunc,12
MAKEOPENGLAPI   glStencilOp,12
MAKEOPENGLAPI   glDepthFunc,4
MAKEOPENGLAPI   glPixelZoom,8
MAKEOPENGLAPI   glPixelTransferf,8
MAKEOPENGLAPI   glPixelTransferi,8
MAKEOPENGLAPI   glPixelStoref,8
MAKEOPENGLAPI   glPixelStorei,8
MAKEOPENGLAPI   glPixelMapfv,12
MAKEOPENGLAPI   glPixelMapuiv,12
MAKEOPENGLAPI   glPixelMapusv,12
MAKEOPENGLAPI   glReadBuffer,4
MAKEOPENGLAPI   glGetBooleanv,8
MAKEOPENGLAPI   glGetClipPlane,8
MAKEOPENGLAPI   glGetDoublev,8
MAKEOPENGLAPI   glGetError,0
MAKEOPENGLAPI   glGetFloatv,8
MAKEOPENGLAPI   glGetIntegerv,8
MAKEOPENGLAPI   glGetLightfv,12
MAKEOPENGLAPI   glGetLightiv,12
MAKEOPENGLAPI   glGetMapdv,12
MAKEOPENGLAPI   glGetMapfv,12
MAKEOPENGLAPI   glGetMapiv,12
MAKEOPENGLAPI   glGetMaterialfv,12
MAKEOPENGLAPI   glGetMaterialiv,12
MAKEOPENGLAPI   glGetPixelMapfv,8
MAKEOPENGLAPI   glGetPixelMapuiv,8
MAKEOPENGLAPI   glGetPixelMapusv,8
MAKEOPENGLAPI   glGetPolygonStipple,4
MAKEOPENGLAPI   glGetString,4
MAKEOPENGLAPI   glGetTexEnvfv,12
MAKEOPENGLAPI   glGetTexEnviv,12
MAKEOPENGLAPI   glGetTexGendv,12
MAKEOPENGLAPI   glGetTexGenfv,12
MAKEOPENGLAPI   glGetTexGeniv,12
MAKEOPENGLAPI   glGetTexImage,20
MAKEOPENGLAPI   glGetTexParameterfv,12
MAKEOPENGLAPI   glGetTexParameteriv,12
MAKEOPENGLAPI   glGetTexLevelParameterfv,16
MAKEOPENGLAPI   glGetTexLevelParameteriv,16
MAKEOPENGLAPI   glIsEnabled,4
MAKEOPENGLAPI   glIsList,4
MAKEOPENGLAPI   glDepthRange,16
MAKEOPENGLAPI   glFrustum,48
MAKEOPENGLAPI   glOrtho,48
MAKEOPENGLAPI   glViewport,16
MAKEOPENGLAPI   glAreTexturesResident,12
MAKEOPENGLAPI   glCopyTexImage1D,28
MAKEOPENGLAPI   glCopyTexImage2D,32
MAKEOPENGLAPI   glCopyTexSubImage1D,24
MAKEOPENGLAPI   glCopyTexSubImage2D,32
MAKEOPENGLAPI   glDeleteTextures,8
MAKEOPENGLAPI   glGenTextures,8
MAKEOPENGLAPI   glIsTexture,4
MAKEOPENGLAPI   glPrioritizeTextures,12
MAKEOPENGLAPI   glTexSubImage1D,28
MAKEOPENGLAPI   glTexSubImage2D,36
MAKEOPENGLAPI   glGetColorTableEXT,16
MAKEOPENGLAPI   glGetColorTableParameterivEXT,12
MAKEOPENGLAPI   glGetColorTableParameterfvEXT,12
MAKEOPENGLAPI   glMultiTexCoord1dWIN,12
MAKEOPENGLAPI   glMultiTexCoord1dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord1sWIN,8
MAKEOPENGLAPI   glMultiTexCoord1svWIN,8
MAKEOPENGLAPI   glMultiTexCoord2dWIN,20
MAKEOPENGLAPI   glMultiTexCoord2dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord2sWIN,12
MAKEOPENGLAPI   glMultiTexCoord2svWIN,8
MAKEOPENGLAPI   glMultiTexCoord3dWIN,28
MAKEOPENGLAPI   glMultiTexCoord3dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord3fWIN,16
MAKEOPENGLAPI   glMultiTexCoord3fvWIN,8
MAKEOPENGLAPI   glMultiTexCoord3iWIN,16
MAKEOPENGLAPI   glMultiTexCoord3ivWIN,8
MAKEOPENGLAPI   glMultiTexCoord3sWIN,16
MAKEOPENGLAPI   glMultiTexCoord3svWIN,8
MAKEOPENGLAPI   glMultiTexCoord4dWIN,36
MAKEOPENGLAPI   glMultiTexCoord4dvWIN,8
MAKEOPENGLAPI   glMultiTexCoord4fWIN,20
MAKEOPENGLAPI   glMultiTexCoord4fvWIN,8
MAKEOPENGLAPI   glMultiTexCoord4iWIN,20
MAKEOPENGLAPI   glMultiTexCoord4ivWIN,8
MAKEOPENGLAPI   glMultiTexCoord4sWIN,20
MAKEOPENGLAPI   glMultiTexCoord4svWIN,8

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\i386\glivtx.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: glivtx.asm
;
; OpenGL vertex API function entries for i386.
;
; Created: 04/16/1996
; Author: Drew Bliss [drewb]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include ks386.inc
        include gli386.inc
	PROFILE = 0
	include profile.inc
        .list

	OPTION PROLOGUE:NONE
	OPTION EPILOGUE:NONE

@PolyArrayFlushPartialPrimitive@0 PROTO SYSCALL
@glcltNormal3f_NotInBegin@16 PROTO SYSCALL
@glcltTexCoord4f_NotInBegin@24 PROTO SYSCALL
@glcltColor4f_InRGBA_NotInBegin@28 PROTO SYSCALL

	IF POLYARRAY_IN_BEGIN GT 255
	.ERR POLYARRAY_IN_BEGIN too large
	ENDIF
	IF POLYARRAY_VERTEX3 GT 255
	.ERR POLYARRAY_VERTEX3 too large
	ENDIF
	IF POLYDATA_VERTEX3 GT 255
	.ERR POLYDATA_VERTEX3 too large
	ENDIF
	IF POLYARRAY_VERTEX2 GT 255
	.ERR POLYARRAY_VERTEX2 too large
	ENDIF
	IF POLYDATA_VERTEX2 GT 255
	.ERR POLYDATA_VERTEX2 too large
	ENDIF
	IF POLYDATA_NORMAL_VALID GT 255
	.ERR POLYDATA_NORMAL_VALID too large
	ENDIF
		
        .data
	
        extrn dwTlsOffset:DWORD
 	
	.code

	; Gets the current POLYARRAY pointer in eax
	; These functions cannot rely on registers being set by
	; the dispatch functions because they are also called directly
	; in the display list code
IFDEF _WIN95_
GET_PATEB MACRO
	mov eax, fs:[PcTeb]
	add eax, DWORD PTR [dwTlsOffset]
	mov eax, [eax]
	add eax, GtiPaTeb
	ENDM
GL_SETUP MACRO
	mov eax, fs:[PcTeb]
	add eax, DWORD PTR [dwTlsOffset]
	mov eax, [eax]
	mov ebx, [eax+GtiSectionInfo]
	add eax, GtiPaTeb
	ENDM
ELSE
GET_PATEB MACRO
	mov eax, fs:[TeglPaTeb]
	ENDM
GL_SETUP MACRO
	mov eax, fs:[TeglPaTeb]
	mov ebx, fs:[TeglSectionInfo]
	ENDM
ENDIF
		
PA_VERTEX_STACK_USAGE	EQU	4

	; Handles two and three-element vertex calls
PA_VERTEX_23 MACRO base, offs, ret_n, pop_ebp, elts, pa_flag, pd_flag
	LOCAL NotInBegin, Flush
	
        GET_PATEB
        push esi
        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        lea edx, [esi+sizeof_POLYDATA]
        jz NotInBegin
        or ecx, pa_flag
        mov [eax+PA_pdNextVertex], edx
        mov [eax+PA_flags], ecx
        mov ecx, [esi+PD_flags]
        mov [edx+PD_flags], 0
        or ecx, pd_flag
        mov eax, [eax+PA_pdFlush]
        mov [esi+PD_flags], ecx
        cmp esi, eax
        mov edx, [base+offs]
        mov ecx, [base+offs+4]
	IF elts GT 2
        mov eax, [base+offs+8]
	ELSE
	; xor clears flags so don't use it here
	mov eax, 0
	ENDIF
        mov [esi+PD_obj], edx
        mov [esi+PD_obj+4], ecx
        mov [esi+PD_obj+8], eax
        mov DWORD PTR [esi+PD_obj+12], __FLOAT_ONE
        jge Flush
NotInBegin:
        pop esi
        IF pop_ebp
        pop ebp
	ENDIF
        ret ret_n
Flush:
	call @PolyArrayFlushPartialPrimitive@0
	pop esi
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM

glcltVertex2f@8 PROC PUBLIC
        PROF_ENTRY
	PA_VERTEX_23 esp, 4+PA_VERTEX_STACK_USAGE, 8, 0, 2, \
	    POLYARRAY_VERTEX2, POLYDATA_VERTEX2
glcltVertex2f@8 ENDP
	
glcltVertex2fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_VERTEX_23 ebp, 0, 4, 1, 2, \
	    POLYARRAY_VERTEX2, POLYDATA_VERTEX2
glcltVertex2fv@4 ENDP
	
glcltVertex3f@12 PROC PUBLIC
        PROF_ENTRY
	PA_VERTEX_23 esp, 4+PA_VERTEX_STACK_USAGE, 12, 0, 3, \
	    POLYARRAY_VERTEX3, POLYDATA_VERTEX3
glcltVertex3f@12 ENDP
	
glcltVertex3fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_VERTEX_23 ebp, 0, 4, 1, 3, \
	    POLYARRAY_VERTEX3, POLYDATA_VERTEX3
glcltVertex3fv@4 ENDP
	
PA_NORMAL_STACK_USAGE	EQU	4

	; Handles three-element normal calls
PA_NORMAL_3 MACRO base, offs, ret_n, pop_ebp
	LOCAL NotInBegin, Flush
	
        GET_PATEB
        push esi
        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        mov edx, [base+offs]	
        jz NotInBegin
        mov ecx, [esi+PD_flags]
	mov [eax+PA_pdCurNormal], esi
        or ecx, POLYDATA_NORMAL_VALID
        mov eax, [base+offs+4]
        mov [esi+PD_flags], ecx
        mov ecx, [base+offs+8]
        mov [esi+PD_normal], edx
        mov [esi+PD_normal+4], eax
        mov [esi+PD_normal+8], ecx
        pop esi
        IF pop_ebp
        pop ebp
	ENDIF
        ret ret_n
NotInBegin:
	mov ecx, eax
	lea edx, [base+offs]
	push [edx+8]
	push [edx+4]
	push [edx]
	call @glcltNormal3f_NotInBegin@16
	pop esi
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM
	
glcltNormal3f@12 PROC PUBLIC
        PROF_ENTRY
	PA_NORMAL_3 esp, 4+PA_NORMAL_STACK_USAGE, 12, 0
glcltNormal3f@12 ENDP
	
glcltNormal3fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_NORMAL_3 ebp, 0, 4, 1
glcltNormal3fv@4 ENDP

PA_TEXTURE_STACK_USAGE	EQU	4

	; Handles two and three-element texture calls
PA_TEXTURE_23 MACRO base, offs, ret_n, pop_ebp, elts, pa_flag, pd_flag
	LOCAL NotInBegin, Flush
	
        GET_PATEB
        push esi
        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        jz NotInBegin
	or ecx, pa_flag
	mov [eax+PA_pdCurTexture], esi
	mov [eax+PA_flags], ecx
        mov ecx, [esi+PD_flags]
        mov eax, [base+offs]
        or ecx, POLYDATA_TEXTURE_VALID OR pd_flag
        mov edx, [base+offs+4]
        mov [esi+PD_flags], ecx
        mov [esi+PD_texture], eax
	IF elts GT 2
        mov ecx, [base+offs+8]
	ELSE
	xor ecx, ecx
	ENDIF
        mov [esi+PD_texture+4], edx
        mov [esi+PD_texture+8], ecx
	mov DWORD PTR [esi+PD_texture+12], __FLOAT_ONE
        pop esi
        IF pop_ebp
        pop ebp
	ENDIF
        ret ret_n
NotInBegin:
	mov ecx, eax
	lea edx, [base+offs]
	push __FLOAT_ONE
	IF elts GT 2
	push [edx+8]
	ELSE
	push 0
	ENDIF
	push [edx+4]
	push [edx]
	mov edx, pa_flag
	call @glcltTexCoord4f_NotInBegin@24
	pop esi
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM
	
glcltTexCoord2f@8 PROC PUBLIC
        PROF_ENTRY
	PA_TEXTURE_23 esp, 4+PA_TEXTURE_STACK_USAGE, 8, 0, 2, \
	    POLYARRAY_TEXTURE2, POLYDATA_DLIST_TEXTURE2
glcltTexCoord2f@8 ENDP
	
glcltTexCoord2fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_TEXTURE_23 ebp, 0, 4, 1, 2, \
	    POLYARRAY_TEXTURE2, POLYDATA_DLIST_TEXTURE2
glcltTexCoord2fv@4 ENDP
	
glcltTexCoord3f@12 PROC PUBLIC
        PROF_ENTRY
	PA_TEXTURE_23 esp, 4+PA_TEXTURE_STACK_USAGE, 12, 0, 3, \
	    POLYARRAY_TEXTURE3, POLYDATA_DLIST_TEXTURE3
glcltTexCoord3f@12 ENDP
	
glcltTexCoord3fv@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_TEXTURE_23 ebp, 0, 4, 1, 3, \
	    POLYARRAY_TEXTURE3, POLYDATA_DLIST_TEXTURE3
glcltTexCoord3fv@4 ENDP

if POLYARRAY_CLAMP_COLOR NE 080000000h
.err <Color logic assumes POLYARRAY_CLAMP_COLOR is 080000000h>
endif


PA_COLOR_STACK_USAGE	EQU	12

	; Handles three and four-element color calls
PA_COLOR_34 MACRO base, offs, ret_n, pop_ebp, elts, pd_flag
	LOCAL NotInBegin, Flush
	
	push ebx
        GL_SETUP
        push esi
	push edi

        mov ecx, [eax+PA_flags]
        mov esi, [eax+PA_pdNextVertex]
        test ecx, POLYARRAY_IN_BEGIN
        jz NotInBegin
	IF elts GT 3
		fld DWORD PTR [base+offs+12]		
		fmul DWORD PTR [ebx+GC_alphaVertexScale]
	ENDIF
		fld DWORD PTR [base+offs]
	mov [eax+PA_pdCurColor], esi
		fmul DWORD PTR [ebx+GC_redVertexScale]
        mov ecx, [esi+PD_flags]
		fld DWORD PTR [base+offs+4]		
        or ecx, (POLYDATA_COLOR_VALID or pd_flag)
		fmul DWORD PTR [ebx+GC_greenVertexScale]
        mov [esi+PD_flags], ecx
		fld DWORD PTR [base+offs+8]		
		fmul DWORD PTR [ebx+GC_blueVertexScale] ;; b g r (a)
		fxch ST(2)		 		;; r g b (a)

        fstp    DWORD PTR [esi+PD_colors0+0]
        mov     eax, [ebx+GC_redVertexScale]
        fstp    DWORD PTR [esi+PD_colors0+4]
        mov     edx, [esi+PD_colors0+0]
        fstp    DWORD PTR [esi+PD_colors0+8]
        mov     ecx, [ebx+GC_greenVertexScale]
	IF elts GT 3
        fstp    DWORD PTR [esi+PD_colors0+12]
	ENDIF

        mov     edi, [esi+PD_colors0+4]
        sub     eax, edx
        sub     ecx, edi
        or      eax, edx
        or      ecx, edi
        mov     edx, [ebx+GC_blueVertexScale]
        or      eax, ecx
        mov     edi, [esi+PD_colors0+8]
	mov	ecx, [ebx+GC_paTeb]		;; we no longer have pa, so
        or      eax, edi			;; reload it
        sub     edx, edi
	mov	edi, [ebx+GC_alphaVertexScale]
	or	eax, edx
	IF elts GT 3
        mov	edx, [esi+PD_colors0+12]
	sub	edi, edx
        mov 	edx, [ecx+PA_flags]
	or	eax, edi
	ELSE
	mov	[esi+PD_colors0+12], edi
        mov 	edx, [ecx+PA_flags]
	ENDIF

	pop edi
	and eax, POLYARRAY_CLAMP_COLOR
	pop esi
	or eax, edx
        pop ebx

        IF pop_ebp
        pop ebp
	ENDIF

	mov [ecx+PA_flags], eax

        ret ret_n
NotInBegin:

	;; ecx = gc = ebx
	;; edx = pa = eax

	lea edi, [base+offs]
	mov ecx, ebx
	mov edx, eax

	IF elts GT 3
	push [edi+12]
	ELSE
	push __FLOAT_ONE
	ENDIF
	push [edi+8]
	push [edi+4]
	push [edi+0]
	push DWORD PTR POLYDATA_COLOR_VALID OR pd_flag
	call @glcltColor4f_InRGBA_NotInBegin@28
	pop edi
	pop esi
        pop ebx
        IF pop_ebp
        pop ebp
	ENDIF
	ret ret_n
	ENDM

glcltColor3f_InRGBA@12 PROC PUBLIC
        PROF_ENTRY
	PA_COLOR_34 esp, 4+PA_COLOR_STACK_USAGE, 12, 0, 3, 0
glcltColor3f_InRGBA@12 ENDP
	
glcltColor3fv_InRGBA@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_COLOR_34 ebp, 0, 4, 1, 3, 0
glcltColor3fv_InRGBA@4 ENDP
	
glcltColor4f_InRGBA@16 PROC PUBLIC
        PROF_ENTRY
	PA_COLOR_34 esp, 4+PA_COLOR_STACK_USAGE, 16, 0, 4, \
	    POLYDATA_DLIST_COLOR_4
glcltColor4f_InRGBA@16 ENDP
	
glcltColor4fv_InRGBA@4 PROC PUBLIC
        PROF_ENTRY
	push ebp
	mov ebp, [esp+8]
	PA_COLOR_34 ebp, 0, 4, 1, 4, \
	    POLYDATA_DLIST_COLOR_4
glcltColor4fv_InRGBA@4 ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\amd64\glapi.asm ===
title   "OpenGL Functions:
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;   glapi.asm
;
; Abstract:
;
;   OpenGL API function entries for AMD64.
;
; Author:
;
;   David N. Cutler (davec) 31-Dec-2000
;
; Environment:
;
;    User mode only.
;
;--

include ksamd64.inc
include glapi.inc

        extern  dwTlsOffset:dword

;
; Define macro for creating aligned public OpenGL API function.
;

MAKEOPENGLAPI macro Func

        LEAF_ENTRY Func, _TEXT$00

        mov     eax, dwTlsOffset        ; get TLS slot index
        add     rax, gs:[TeSelf]        ; get address of GLTEBINFO address
        mov     rax, [rax]              ; get GLTEBINFO address
        jmp     qword ptr (INDEX_&Func * 8)[rax] ; dispatch to function

        LEAF_END Func, _TEXT$00

        endm

;
; Define macro to jump through the OpenGL function dispatch table in the TEB.
;

FASTOPENGLAPI macro Func

        LEAF_ENTRY Func, _TEXT$00

        mov     rax, gs:[TeSelf]        ; get TEB address
        jmp     qword ptr TeglDispatchTable+ (FASTINDEX_&Func * 8)[rax] ;

        LEAF_END Func, _TEXT$00

        endm

FASTOPENGLAPI glCallList
FASTOPENGLAPI glCallLists
FASTOPENGLAPI glBegin
FASTOPENGLAPI glColor3b
FASTOPENGLAPI glColor3bv
FASTOPENGLAPI glColor3d
FASTOPENGLAPI glColor3dv
FASTOPENGLAPI glColor3f
FASTOPENGLAPI glColor3fv
FASTOPENGLAPI glColor3i
FASTOPENGLAPI glColor3iv
FASTOPENGLAPI glColor3s
FASTOPENGLAPI glColor3sv
FASTOPENGLAPI glColor3ub
FASTOPENGLAPI glColor3ubv
FASTOPENGLAPI glColor3ui
FASTOPENGLAPI glColor3uiv
FASTOPENGLAPI glColor3us
FASTOPENGLAPI glColor3usv
FASTOPENGLAPI glColor4b
FASTOPENGLAPI glColor4bv
FASTOPENGLAPI glColor4d
FASTOPENGLAPI glColor4dv
FASTOPENGLAPI glColor4f
FASTOPENGLAPI glColor4fv
FASTOPENGLAPI glColor4i
FASTOPENGLAPI glColor4iv
FASTOPENGLAPI glColor4s
FASTOPENGLAPI glColor4sv
FASTOPENGLAPI glColor4ub
FASTOPENGLAPI glColor4ubv
FASTOPENGLAPI glColor4ui
FASTOPENGLAPI glColor4uiv
FASTOPENGLAPI glColor4us
FASTOPENGLAPI glColor4usv
FASTOPENGLAPI glEdgeFlag
FASTOPENGLAPI glEdgeFlagv
FASTOPENGLAPI glEnd
FASTOPENGLAPI glIndexd
FASTOPENGLAPI glIndexdv
FASTOPENGLAPI glIndexf
FASTOPENGLAPI glIndexfv
FASTOPENGLAPI glIndexi
FASTOPENGLAPI glIndexiv
FASTOPENGLAPI glIndexs
FASTOPENGLAPI glIndexsv
FASTOPENGLAPI glNormal3b
FASTOPENGLAPI glNormal3bv
FASTOPENGLAPI glNormal3d
FASTOPENGLAPI glNormal3dv
FASTOPENGLAPI glNormal3f
FASTOPENGLAPI glNormal3fv
FASTOPENGLAPI glNormal3i
FASTOPENGLAPI glNormal3iv
FASTOPENGLAPI glNormal3s
FASTOPENGLAPI glNormal3sv
FASTOPENGLAPI glTexCoord1d
FASTOPENGLAPI glTexCoord1dv
FASTOPENGLAPI glTexCoord1f
FASTOPENGLAPI glTexCoord1fv
FASTOPENGLAPI glTexCoord1i
FASTOPENGLAPI glTexCoord1iv
FASTOPENGLAPI glTexCoord1s
FASTOPENGLAPI glTexCoord1sv
FASTOPENGLAPI glTexCoord2d
FASTOPENGLAPI glTexCoord2dv
FASTOPENGLAPI glTexCoord2f
FASTOPENGLAPI glTexCoord2fv
FASTOPENGLAPI glTexCoord2i
FASTOPENGLAPI glTexCoord2iv
FASTOPENGLAPI glTexCoord2s
FASTOPENGLAPI glTexCoord2sv
FASTOPENGLAPI glTexCoord3d
FASTOPENGLAPI glTexCoord3dv
FASTOPENGLAPI glTexCoord3f
FASTOPENGLAPI glTexCoord3fv
FASTOPENGLAPI glTexCoord3i
FASTOPENGLAPI glTexCoord3iv
FASTOPENGLAPI glTexCoord3s
FASTOPENGLAPI glTexCoord3sv
FASTOPENGLAPI glTexCoord4d
FASTOPENGLAPI glTexCoord4dv
FASTOPENGLAPI glTexCoord4f
FASTOPENGLAPI glTexCoord4fv
FASTOPENGLAPI glTexCoord4i
FASTOPENGLAPI glTexCoord4iv
FASTOPENGLAPI glTexCoord4s
FASTOPENGLAPI glTexCoord4sv
FASTOPENGLAPI glVertex2d
FASTOPENGLAPI glVertex2dv
FASTOPENGLAPI glVertex2f
FASTOPENGLAPI glVertex2fv
FASTOPENGLAPI glVertex2i
FASTOPENGLAPI glVertex2iv
FASTOPENGLAPI glVertex2s
FASTOPENGLAPI glVertex2sv
FASTOPENGLAPI glVertex3d
FASTOPENGLAPI glVertex3dv
FASTOPENGLAPI glVertex3f
FASTOPENGLAPI glVertex3fv
FASTOPENGLAPI glVertex3i
FASTOPENGLAPI glVertex3iv
FASTOPENGLAPI glVertex3s
FASTOPENGLAPI glVertex3sv
FASTOPENGLAPI glVertex4d
FASTOPENGLAPI glVertex4dv
FASTOPENGLAPI glVertex4f
FASTOPENGLAPI glVertex4fv
FASTOPENGLAPI glVertex4i
FASTOPENGLAPI glVertex4iv
FASTOPENGLAPI glVertex4s
FASTOPENGLAPI glVertex4sv
FASTOPENGLAPI glMaterialf
FASTOPENGLAPI glMaterialfv
FASTOPENGLAPI glMateriali
FASTOPENGLAPI glMaterialiv
FASTOPENGLAPI glDisable
FASTOPENGLAPI glEnable
FASTOPENGLAPI glPopAttrib
FASTOPENGLAPI glPushAttrib
FASTOPENGLAPI glEvalCoord1d
FASTOPENGLAPI glEvalCoord1dv
FASTOPENGLAPI glEvalCoord1f
FASTOPENGLAPI glEvalCoord1fv
FASTOPENGLAPI glEvalCoord2d
FASTOPENGLAPI glEvalCoord2dv
FASTOPENGLAPI glEvalCoord2f
FASTOPENGLAPI glEvalCoord2fv
FASTOPENGLAPI glEvalPoint1
FASTOPENGLAPI glEvalPoint2
FASTOPENGLAPI glLoadIdentity
FASTOPENGLAPI glLoadMatrixf
FASTOPENGLAPI glLoadMatrixd
FASTOPENGLAPI glMatrixMode
FASTOPENGLAPI glMultMatrixf
FASTOPENGLAPI glMultMatrixd
FASTOPENGLAPI glPopMatrix
FASTOPENGLAPI glPushMatrix
FASTOPENGLAPI glRotated
FASTOPENGLAPI glRotatef
FASTOPENGLAPI glScaled
FASTOPENGLAPI glScalef
FASTOPENGLAPI glTranslated
FASTOPENGLAPI glTranslatef
FASTOPENGLAPI glArrayElement
FASTOPENGLAPI glBindTexture
FASTOPENGLAPI glColorPointer
FASTOPENGLAPI glDisableClientState
FASTOPENGLAPI glDrawArrays
FASTOPENGLAPI glDrawElements
FASTOPENGLAPI glEdgeFlagPointer
FASTOPENGLAPI glEnableClientState
FASTOPENGLAPI glIndexPointer
FASTOPENGLAPI glIndexub
FASTOPENGLAPI glIndexubv
FASTOPENGLAPI glInterleavedArrays
FASTOPENGLAPI glNormalPointer
FASTOPENGLAPI glPolygonOffset
FASTOPENGLAPI glTexCoordPointer
FASTOPENGLAPI glVertexPointer
FASTOPENGLAPI glGetPointerv
FASTOPENGLAPI glPopClientAttrib
FASTOPENGLAPI glPushClientAttrib
FASTOPENGLAPI glDrawRangeElementsWIN
FASTOPENGLAPI glColorTableEXT
FASTOPENGLAPI glColorSubTableEXT
FASTOPENGLAPI glCurrentTextureIndexWIN	
FASTOPENGLAPI glBindNthTextureWIN	
FASTOPENGLAPI glNthTexCombineFuncWIN	
FASTOPENGLAPI glMultiTexCoord1fWIN	
FASTOPENGLAPI glMultiTexCoord1fvWIN	
FASTOPENGLAPI glMultiTexCoord1iWIN	
FASTOPENGLAPI glMultiTexCoord1ivWIN	
FASTOPENGLAPI glMultiTexCoord2fWIN	
FASTOPENGLAPI glMultiTexCoord2fvWIN	
FASTOPENGLAPI glMultiTexCoord2iWIN	
FASTOPENGLAPI glMultiTexCoord2ivWIN	

MAKEOPENGLAPI glClear	 		
MAKEOPENGLAPI glClearAccum
MAKEOPENGLAPI glClearIndex
MAKEOPENGLAPI glClearColor
MAKEOPENGLAPI glClearStencil
MAKEOPENGLAPI glClearDepth
MAKEOPENGLAPI glBitmap
MAKEOPENGLAPI glTexImage1D
MAKEOPENGLAPI glTexImage2D
MAKEOPENGLAPI glCopyPixels
MAKEOPENGLAPI glReadPixels
MAKEOPENGLAPI glDrawPixels
MAKEOPENGLAPI glRectd
MAKEOPENGLAPI glRectdv
MAKEOPENGLAPI glRectf
MAKEOPENGLAPI glRectfv
MAKEOPENGLAPI glRecti
MAKEOPENGLAPI glRectiv
MAKEOPENGLAPI glRects
MAKEOPENGLAPI glRectsv
MAKEOPENGLAPI glNewList
MAKEOPENGLAPI glEndList
MAKEOPENGLAPI glDeleteLists
MAKEOPENGLAPI glGenLists
MAKEOPENGLAPI glListBase
MAKEOPENGLAPI glRasterPos2d
MAKEOPENGLAPI glRasterPos2dv
MAKEOPENGLAPI glRasterPos2f
MAKEOPENGLAPI glRasterPos2fv
MAKEOPENGLAPI glRasterPos2i
MAKEOPENGLAPI glRasterPos2iv
MAKEOPENGLAPI glRasterPos2s
MAKEOPENGLAPI glRasterPos2sv
MAKEOPENGLAPI glRasterPos3d
MAKEOPENGLAPI glRasterPos3dv
MAKEOPENGLAPI glRasterPos3f
MAKEOPENGLAPI glRasterPos3fv
MAKEOPENGLAPI glRasterPos3i
MAKEOPENGLAPI glRasterPos3iv
MAKEOPENGLAPI glRasterPos3s
MAKEOPENGLAPI glRasterPos3sv
MAKEOPENGLAPI glRasterPos4d
MAKEOPENGLAPI glRasterPos4dv
MAKEOPENGLAPI glRasterPos4f
MAKEOPENGLAPI glRasterPos4fv
MAKEOPENGLAPI glRasterPos4i
MAKEOPENGLAPI glRasterPos4iv
MAKEOPENGLAPI glRasterPos4s
MAKEOPENGLAPI glRasterPos4sv
MAKEOPENGLAPI glClipPlane
MAKEOPENGLAPI glColorMaterial
MAKEOPENGLAPI glCullFace
MAKEOPENGLAPI glFogf
MAKEOPENGLAPI glFogfv
MAKEOPENGLAPI glFogi
MAKEOPENGLAPI glFogiv
MAKEOPENGLAPI glFrontFace
MAKEOPENGLAPI glHint
MAKEOPENGLAPI glLightf
MAKEOPENGLAPI glLightfv
MAKEOPENGLAPI glLighti
MAKEOPENGLAPI glLightiv
MAKEOPENGLAPI glLightModelf
MAKEOPENGLAPI glLightModelfv
MAKEOPENGLAPI glLightModeli
MAKEOPENGLAPI glLightModeliv
MAKEOPENGLAPI glLineStipple
MAKEOPENGLAPI glLineWidth
MAKEOPENGLAPI glPointSize
MAKEOPENGLAPI glPolygonMode
MAKEOPENGLAPI glPolygonStipple
MAKEOPENGLAPI glScissor
MAKEOPENGLAPI glFinish
MAKEOPENGLAPI glShadeModel
MAKEOPENGLAPI glTexParameterf
MAKEOPENGLAPI glTexParameterfv
MAKEOPENGLAPI glTexParameteri
MAKEOPENGLAPI glTexParameteriv
MAKEOPENGLAPI glTexEnvf
MAKEOPENGLAPI glTexEnvfv
MAKEOPENGLAPI glTexEnvi
MAKEOPENGLAPI glTexEnviv
MAKEOPENGLAPI glTexGend
MAKEOPENGLAPI glTexGendv
MAKEOPENGLAPI glTexGenf
MAKEOPENGLAPI glTexGenfv
MAKEOPENGLAPI glTexGeni
MAKEOPENGLAPI glTexGeniv
MAKEOPENGLAPI glFeedbackBuffer
MAKEOPENGLAPI glSelectBuffer
MAKEOPENGLAPI glRenderMode
MAKEOPENGLAPI glInitNames
MAKEOPENGLAPI glLoadName
MAKEOPENGLAPI glPassThrough
MAKEOPENGLAPI glPopName
MAKEOPENGLAPI glPushName
MAKEOPENGLAPI glDrawBuffer
MAKEOPENGLAPI glStencilMask
MAKEOPENGLAPI glColorMask
MAKEOPENGLAPI glDepthMask
MAKEOPENGLAPI glIndexMask
MAKEOPENGLAPI glAccum
MAKEOPENGLAPI glFlush
MAKEOPENGLAPI glMap1d
MAKEOPENGLAPI glMap1f
MAKEOPENGLAPI glMap2d
MAKEOPENGLAPI glMap2f
MAKEOPENGLAPI glMapGrid1d
MAKEOPENGLAPI glMapGrid1f
MAKEOPENGLAPI glMapGrid2d
MAKEOPENGLAPI glMapGrid2f
MAKEOPENGLAPI glEvalMesh1
MAKEOPENGLAPI glEvalMesh2
MAKEOPENGLAPI glAlphaFunc
MAKEOPENGLAPI glBlendFunc
MAKEOPENGLAPI glLogicOp
MAKEOPENGLAPI glStencilFunc
MAKEOPENGLAPI glStencilOp
MAKEOPENGLAPI glDepthFunc
MAKEOPENGLAPI glPixelZoom
MAKEOPENGLAPI glPixelTransferf
MAKEOPENGLAPI glPixelTransferi
MAKEOPENGLAPI glPixelStoref
MAKEOPENGLAPI glPixelStorei
MAKEOPENGLAPI glPixelMapfv
MAKEOPENGLAPI glPixelMapuiv
MAKEOPENGLAPI glPixelMapusv
MAKEOPENGLAPI glReadBuffer
MAKEOPENGLAPI glGetBooleanv
MAKEOPENGLAPI glGetClipPlane
MAKEOPENGLAPI glGetDoublev
MAKEOPENGLAPI glGetError
MAKEOPENGLAPI glGetFloatv
MAKEOPENGLAPI glGetIntegerv
MAKEOPENGLAPI glGetLightfv
MAKEOPENGLAPI glGetLightiv
MAKEOPENGLAPI glGetMapdv
MAKEOPENGLAPI glGetMapfv
MAKEOPENGLAPI glGetMapiv
MAKEOPENGLAPI glGetMaterialfv
MAKEOPENGLAPI glGetMaterialiv
MAKEOPENGLAPI glGetPixelMapfv
MAKEOPENGLAPI glGetPixelMapuiv
MAKEOPENGLAPI glGetPixelMapusv
MAKEOPENGLAPI glGetPolygonStipple
MAKEOPENGLAPI glGetString
MAKEOPENGLAPI glGetTexEnvfv
MAKEOPENGLAPI glGetTexEnviv
MAKEOPENGLAPI glGetTexGendv
MAKEOPENGLAPI glGetTexGenfv
MAKEOPENGLAPI glGetTexGeniv
MAKEOPENGLAPI glGetTexImage
MAKEOPENGLAPI glGetTexParameterfv
MAKEOPENGLAPI glGetTexParameteriv
MAKEOPENGLAPI glGetTexLevelParameterfv
MAKEOPENGLAPI glGetTexLevelParameteriv
MAKEOPENGLAPI glIsEnabled
MAKEOPENGLAPI glIsList
MAKEOPENGLAPI glDepthRange
MAKEOPENGLAPI glFrustum
MAKEOPENGLAPI glOrtho
MAKEOPENGLAPI glViewport
MAKEOPENGLAPI glAreTexturesResident
MAKEOPENGLAPI glCopyTexImage1D
MAKEOPENGLAPI glCopyTexImage2D
MAKEOPENGLAPI glCopyTexSubImage1D
MAKEOPENGLAPI glCopyTexSubImage2D
MAKEOPENGLAPI glDeleteTextures
MAKEOPENGLAPI glGenTextures
MAKEOPENGLAPI glIsTexture
MAKEOPENGLAPI glPrioritizeTextures
MAKEOPENGLAPI glTexSubImage1D
MAKEOPENGLAPI glTexSubImage2D
MAKEOPENGLAPI glGetColorTableEXT
MAKEOPENGLAPI glGetColorTableParameterivEXT
MAKEOPENGLAPI glGetColorTableParameterfvEXT
MAKEOPENGLAPI glMultiTexCoord1dWIN	
MAKEOPENGLAPI glMultiTexCoord1dvWIN	
MAKEOPENGLAPI glMultiTexCoord1sWIN	
MAKEOPENGLAPI glMultiTexCoord1svWIN	
MAKEOPENGLAPI glMultiTexCoord2dWIN	
MAKEOPENGLAPI glMultiTexCoord2dvWIN	
MAKEOPENGLAPI glMultiTexCoord2sWIN	
MAKEOPENGLAPI glMultiTexCoord2svWIN	
MAKEOPENGLAPI glMultiTexCoord3dWIN	
MAKEOPENGLAPI glMultiTexCoord3dvWIN	
MAKEOPENGLAPI glMultiTexCoord3fWIN	
MAKEOPENGLAPI glMultiTexCoord3fvWIN	
MAKEOPENGLAPI glMultiTexCoord3iWIN	
MAKEOPENGLAPI glMultiTexCoord3ivWIN	
MAKEOPENGLAPI glMultiTexCoord3sWIN	
MAKEOPENGLAPI glMultiTexCoord3svWIN	
MAKEOPENGLAPI glMultiTexCoord4dWIN	
MAKEOPENGLAPI glMultiTexCoord4dvWIN	
MAKEOPENGLAPI glMultiTexCoord4fWIN	
MAKEOPENGLAPI glMultiTexCoord4fvWIN	
MAKEOPENGLAPI glMultiTexCoord4iWIN	
MAKEOPENGLAPI glMultiTexCoord4ivWIN	
MAKEOPENGLAPI glMultiTexCoord4sWIN	
MAKEOPENGLAPI glMultiTexCoord4svWIN

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\ia64\gleapi.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
// Module Name:
//
//    glpapi.s
//
// Abstract:
//
//    OpenGL API function entries for IA64
//
// Author:
//
//
// Environment:
//
//    User mode only.
//
// Revision History:
//
//
//--

#include "ksia64.h"
#include "dispindx.h"

         .global  dwTlsOffset

// Macro for creating aligned public OpenGL API function
// Do an indirect jump through the OpenGL function dispatch table.
// This macro must leave the TEB in v0.

#define MAKEOPENGLAPI(Func)                                     \
    LEAF_ENTRY( Func );                                         \
    add         t3 = @gprel(dwTlsOffset), gp;                   \
    ;;                                                          \
    ld4         t2 = [t3];                                      \
    mov         v0 = teb;                                       \
    ;;                                                          \
    add         t0 = t2, v0;                                    \
    ;;                                                          \
    ld8         t6 = [t0];                                      \
    ;;                                                          \
    add         t1 = INDEX_##Func*SizeofPointer, t6;            \
    ;;                                                          \
    ld8         t4 = [t1];                                      \
    ;;                                                          \
    ld8         t5 = [t4], 8;                                   \
    ;;                                                          \
    ld8         gp = [t4];                                      \
    mov         b6 = t5;                                        \
    br##.##sptk b6;                                             \
    LEAF_EXIT( Func)


// Macro for creating aligned public OpenGL API function
// Do an indirect jump through the OpenGL function dispatch table in the TEB.


#define FASTOPENGLAPI(Func)                                     \
    LEAF_ENTRY( Func );                                         \
    add         t0 = TeglDispatchTable+(FASTINDEX_##Func*SizeofPointer), teb;   \
    ;;                                                          \
    ld8         t1 = [t0];                                      \
    ;;                                                          \
    ld8         t2 = [t1], 8;                                   \
    ;;                                                          \
    ld8         gp = [t1];                                      \
    mov         b6 = t2;                                        \
    br##.##sptk b6;                                             \
    LEAF_EXIT( Func)


FASTOPENGLAPI( glCallList                )
FASTOPENGLAPI( glCallLists               )
FASTOPENGLAPI( glBegin                   )
FASTOPENGLAPI( glColor3b                 )
FASTOPENGLAPI( glColor3bv                )
FASTOPENGLAPI( glColor3d                 )
FASTOPENGLAPI( glColor3dv                )
FASTOPENGLAPI( glColor3f                 )
FASTOPENGLAPI( glColor3fv                )
FASTOPENGLAPI( glColor3i                 )
FASTOPENGLAPI( glColor3iv                )
FASTOPENGLAPI( glColor3s                 )
FASTOPENGLAPI( glColor3sv                )
FASTOPENGLAPI( glColor3ub                )
FASTOPENGLAPI( glColor3ubv               )
FASTOPENGLAPI( glColor3ui                )
FASTOPENGLAPI( glColor3uiv               )
FASTOPENGLAPI( glColor3us                )
FASTOPENGLAPI( glColor3usv               )
FASTOPENGLAPI( glColor4b                 )
FASTOPENGLAPI( glColor4bv                )
FASTOPENGLAPI( glColor4d                 )
FASTOPENGLAPI( glColor4dv                )
FASTOPENGLAPI( glColor4f                 )
FASTOPENGLAPI( glColor4fv                )
FASTOPENGLAPI( glColor4i                 )
FASTOPENGLAPI( glColor4iv                )
FASTOPENGLAPI( glColor4s                 )
FASTOPENGLAPI( glColor4sv                )
FASTOPENGLAPI( glColor4ub                )
FASTOPENGLAPI( glColor4ubv               )
FASTOPENGLAPI( glColor4ui                )
FASTOPENGLAPI( glColor4uiv               )
FASTOPENGLAPI( glColor4us                )
FASTOPENGLAPI( glColor4usv               )
FASTOPENGLAPI( glEdgeFlag                )
FASTOPENGLAPI( glEdgeFlagv               )
FASTOPENGLAPI( glEnd                     )
FASTOPENGLAPI( glIndexd                  )
FASTOPENGLAPI( glIndexdv                 )
FASTOPENGLAPI( glIndexf                  )
FASTOPENGLAPI( glIndexfv                 )
FASTOPENGLAPI( glIndexi                  )
FASTOPENGLAPI( glIndexiv                 )
FASTOPENGLAPI( glIndexs                  )
FASTOPENGLAPI( glIndexsv                 )
FASTOPENGLAPI( glNormal3b                )
FASTOPENGLAPI( glNormal3bv               )
FASTOPENGLAPI( glNormal3d                )
FASTOPENGLAPI( glNormal3dv               )
FASTOPENGLAPI( glNormal3f                )
FASTOPENGLAPI( glNormal3fv               )
FASTOPENGLAPI( glNormal3i                )
FASTOPENGLAPI( glNormal3iv               )
FASTOPENGLAPI( glNormal3s                )
FASTOPENGLAPI( glNormal3sv               )
FASTOPENGLAPI( glTexCoord1d              )
FASTOPENGLAPI( glTexCoord1dv             )
FASTOPENGLAPI( glTexCoord1f              )
FASTOPENGLAPI( glTexCoord1fv             )
FASTOPENGLAPI( glTexCoord1i              )
FASTOPENGLAPI( glTexCoord1iv             )
FASTOPENGLAPI( glTexCoord1s              )
FASTOPENGLAPI( glTexCoord1sv             )
FASTOPENGLAPI( glTexCoord2d              )
FASTOPENGLAPI( glTexCoord2dv             )
FASTOPENGLAPI( glTexCoord2f              )
FASTOPENGLAPI( glTexCoord2fv             )
FASTOPENGLAPI( glTexCoord2i              )
FASTOPENGLAPI( glTexCoord2iv             )
FASTOPENGLAPI( glTexCoord2s              )
FASTOPENGLAPI( glTexCoord2sv             )
FASTOPENGLAPI( glTexCoord3d              )
FASTOPENGLAPI( glTexCoord3dv             )
FASTOPENGLAPI( glTexCoord3f              )
FASTOPENGLAPI( glTexCoord3fv             )
FASTOPENGLAPI( glTexCoord3i              )
FASTOPENGLAPI( glTexCoord3iv             )
FASTOPENGLAPI( glTexCoord3s              )
FASTOPENGLAPI( glTexCoord3sv             )
FASTOPENGLAPI( glTexCoord4d              )
FASTOPENGLAPI( glTexCoord4dv             )
FASTOPENGLAPI( glTexCoord4f              )
FASTOPENGLAPI( glTexCoord4fv             )
FASTOPENGLAPI( glTexCoord4i              )
FASTOPENGLAPI( glTexCoord4iv             )
FASTOPENGLAPI( glTexCoord4s              )
FASTOPENGLAPI( glTexCoord4sv             )
FASTOPENGLAPI( glVertex2d                )
FASTOPENGLAPI( glVertex2dv               )
FASTOPENGLAPI( glVertex2f                )
FASTOPENGLAPI( glVertex2fv               )
FASTOPENGLAPI( glVertex2i                )
FASTOPENGLAPI( glVertex2iv               )
FASTOPENGLAPI( glVertex2s                )
FASTOPENGLAPI( glVertex2sv               )
FASTOPENGLAPI( glVertex3d                )
FASTOPENGLAPI( glVertex3dv               )
FASTOPENGLAPI( glVertex3f                )
FASTOPENGLAPI( glVertex3fv               )
FASTOPENGLAPI( glVertex3i                )
FASTOPENGLAPI( glVertex3iv               )
FASTOPENGLAPI( glVertex3s                )
FASTOPENGLAPI( glVertex3sv               )
FASTOPENGLAPI( glVertex4d                )
FASTOPENGLAPI( glVertex4dv               )
FASTOPENGLAPI( glVertex4f                )
FASTOPENGLAPI( glVertex4fv               )
FASTOPENGLAPI( glVertex4i                )
FASTOPENGLAPI( glVertex4iv               )
FASTOPENGLAPI( glVertex4s                )
FASTOPENGLAPI( glVertex4sv               )
FASTOPENGLAPI( glMaterialf               )
FASTOPENGLAPI( glMaterialfv              )
FASTOPENGLAPI( glMateriali               )
FASTOPENGLAPI( glMaterialiv              )
FASTOPENGLAPI( glDisable                 )
FASTOPENGLAPI( glEnable                  )
FASTOPENGLAPI( glPopAttrib               )
FASTOPENGLAPI( glPushAttrib              )
FASTOPENGLAPI( glEvalCoord1d             )
FASTOPENGLAPI( glEvalCoord1dv            )
FASTOPENGLAPI( glEvalCoord1f             )
FASTOPENGLAPI( glEvalCoord1fv            )
FASTOPENGLAPI( glEvalCoord2d             )
FASTOPENGLAPI( glEvalCoord2dv            )
FASTOPENGLAPI( glEvalCoord2f             )
FASTOPENGLAPI( glEvalCoord2fv            )
FASTOPENGLAPI( glEvalPoint1              )
FASTOPENGLAPI( glEvalPoint2              )
FASTOPENGLAPI( glLoadIdentity            )
FASTOPENGLAPI( glLoadMatrixf             )
FASTOPENGLAPI( glLoadMatrixd             )
FASTOPENGLAPI( glMatrixMode              )
FASTOPENGLAPI( glMultMatrixf             )
FASTOPENGLAPI( glMultMatrixd             )
FASTOPENGLAPI( glPopMatrix               )
FASTOPENGLAPI( glPushMatrix              )
FASTOPENGLAPI( glRotated                 )
FASTOPENGLAPI( glRotatef                 )
FASTOPENGLAPI( glScaled                  )
FASTOPENGLAPI( glScalef                  )
FASTOPENGLAPI( glTranslated              )
FASTOPENGLAPI( glTranslatef              )
FASTOPENGLAPI( glArrayElement            )
FASTOPENGLAPI( glBindTexture             )
FASTOPENGLAPI( glColorPointer            )
FASTOPENGLAPI( glDisableClientState      )
FASTOPENGLAPI( glDrawArrays              )
FASTOPENGLAPI( glDrawElements            )
FASTOPENGLAPI( glEdgeFlagPointer         )
FASTOPENGLAPI( glEnableClientState       )
FASTOPENGLAPI( glIndexPointer            )
FASTOPENGLAPI( glIndexub                 )
FASTOPENGLAPI( glIndexubv                )
FASTOPENGLAPI( glInterleavedArrays       )
FASTOPENGLAPI( glNormalPointer           )
FASTOPENGLAPI( glPolygonOffset           )
FASTOPENGLAPI( glTexCoordPointer         )
FASTOPENGLAPI( glVertexPointer           )
FASTOPENGLAPI( glGetPointerv             )
FASTOPENGLAPI( glPopClientAttrib         )
FASTOPENGLAPI( glPushClientAttrib        )
FASTOPENGLAPI( glDrawRangeElementsWIN    )
FASTOPENGLAPI( glColorTableEXT           )
FASTOPENGLAPI( glColorSubTableEXT        )

MAKEOPENGLAPI( glClear	 		 )
MAKEOPENGLAPI( glClearAccum              )
MAKEOPENGLAPI( glClearIndex              )
MAKEOPENGLAPI( glClearColor              )
MAKEOPENGLAPI( glClearStencil            )
MAKEOPENGLAPI( glClearDepth              )
MAKEOPENGLAPI( glBitmap                  )
MAKEOPENGLAPI( glTexImage1D              )
MAKEOPENGLAPI( glTexImage2D              )
MAKEOPENGLAPI( glCopyPixels              )
MAKEOPENGLAPI( glReadPixels              )
MAKEOPENGLAPI( glDrawPixels              )
MAKEOPENGLAPI( glRectd                   )
MAKEOPENGLAPI( glRectdv                  )
MAKEOPENGLAPI( glRectf                   )
MAKEOPENGLAPI( glRectfv                  )
MAKEOPENGLAPI( glRecti                   )
MAKEOPENGLAPI( glRectiv                  )
MAKEOPENGLAPI( glRects                   )
MAKEOPENGLAPI( glRectsv                  )
MAKEOPENGLAPI( glNewList                 )
MAKEOPENGLAPI( glEndList                 )
MAKEOPENGLAPI( glDeleteLists             )
MAKEOPENGLAPI( glGenLists                )
MAKEOPENGLAPI( glListBase                )
MAKEOPENGLAPI( glRasterPos2d             )
MAKEOPENGLAPI( glRasterPos2dv            )
MAKEOPENGLAPI( glRasterPos2f             )
MAKEOPENGLAPI( glRasterPos2fv            )
MAKEOPENGLAPI( glRasterPos2i             )
MAKEOPENGLAPI( glRasterPos2iv            )
MAKEOPENGLAPI( glRasterPos2s             )
MAKEOPENGLAPI( glRasterPos2sv            )
MAKEOPENGLAPI( glRasterPos3d             )
MAKEOPENGLAPI( glRasterPos3dv            )
MAKEOPENGLAPI( glRasterPos3f             )
MAKEOPENGLAPI( glRasterPos3fv            )
MAKEOPENGLAPI( glRasterPos3i             )
MAKEOPENGLAPI( glRasterPos3iv            )
MAKEOPENGLAPI( glRasterPos3s             )
MAKEOPENGLAPI( glRasterPos3sv            )
MAKEOPENGLAPI( glRasterPos4d             )
MAKEOPENGLAPI( glRasterPos4dv            )
MAKEOPENGLAPI( glRasterPos4f             )
MAKEOPENGLAPI( glRasterPos4fv            )
MAKEOPENGLAPI( glRasterPos4i             )
MAKEOPENGLAPI( glRasterPos4iv            )
MAKEOPENGLAPI( glRasterPos4s             )
MAKEOPENGLAPI( glRasterPos4sv            )
MAKEOPENGLAPI( glClipPlane               )
MAKEOPENGLAPI( glColorMaterial           )
MAKEOPENGLAPI( glCullFace                )
MAKEOPENGLAPI( glFogf                    )
MAKEOPENGLAPI( glFogfv                   )
MAKEOPENGLAPI( glFogi                    )
MAKEOPENGLAPI( glFogiv                   )
MAKEOPENGLAPI( glFrontFace               )
MAKEOPENGLAPI( glHint                    )
MAKEOPENGLAPI( glLightf                  )
MAKEOPENGLAPI( glLightfv                 )
MAKEOPENGLAPI( glLighti                  )
MAKEOPENGLAPI( glLightiv                 )
MAKEOPENGLAPI( glLightModelf             )
MAKEOPENGLAPI( glLightModelfv            )
MAKEOPENGLAPI( glLightModeli             )
MAKEOPENGLAPI( glLightModeliv            )
MAKEOPENGLAPI( glLineStipple             )
MAKEOPENGLAPI( glLineWidth               )
MAKEOPENGLAPI( glPointSize               )
MAKEOPENGLAPI( glPolygonMode             )
MAKEOPENGLAPI( glPolygonStipple          )
MAKEOPENGLAPI( glScissor                 )
MAKEOPENGLAPI( glFinish                  )
MAKEOPENGLAPI( glShadeModel              )
MAKEOPENGLAPI( glTexParameterf           )
MAKEOPENGLAPI( glTexParameterfv          )
MAKEOPENGLAPI( glTexParameteri           )
MAKEOPENGLAPI( glTexParameteriv          )
MAKEOPENGLAPI( glTexEnvf                 )
MAKEOPENGLAPI( glTexEnvfv                )
MAKEOPENGLAPI( glTexEnvi                 )
MAKEOPENGLAPI( glTexEnviv                )
MAKEOPENGLAPI( glTexGend                 )
MAKEOPENGLAPI( glTexGendv                )
MAKEOPENGLAPI( glTexGenf                 )
MAKEOPENGLAPI( glTexGenfv                )
MAKEOPENGLAPI( glTexGeni                 )
MAKEOPENGLAPI( glTexGeniv                )
MAKEOPENGLAPI( glFeedbackBuffer          )
MAKEOPENGLAPI( glSelectBuffer            )
MAKEOPENGLAPI( glRenderMode              )
MAKEOPENGLAPI( glInitNames               )
MAKEOPENGLAPI( glLoadName                )
MAKEOPENGLAPI( glPassThrough             )
MAKEOPENGLAPI( glPopName                 )
MAKEOPENGLAPI( glPushName                )
MAKEOPENGLAPI( glDrawBuffer              )
MAKEOPENGLAPI( glStencilMask             )
MAKEOPENGLAPI( glColorMask               )
MAKEOPENGLAPI( glDepthMask               )
MAKEOPENGLAPI( glIndexMask               )
MAKEOPENGLAPI( glAccum                   )
MAKEOPENGLAPI( glFlush                   )
MAKEOPENGLAPI( glMap1d                   )
MAKEOPENGLAPI( glMap1f                   )
MAKEOPENGLAPI( glMap2d                   )
MAKEOPENGLAPI( glMap2f                   )
MAKEOPENGLAPI( glMapGrid1d               )
MAKEOPENGLAPI( glMapGrid1f               )
MAKEOPENGLAPI( glMapGrid2d               )
MAKEOPENGLAPI( glMapGrid2f               )
MAKEOPENGLAPI( glEvalMesh1               )
MAKEOPENGLAPI( glEvalMesh2               )
MAKEOPENGLAPI( glAlphaFunc               )
MAKEOPENGLAPI( glBlendFunc               )
MAKEOPENGLAPI( glLogicOp                 )
MAKEOPENGLAPI( glStencilFunc             )
MAKEOPENGLAPI( glStencilOp               )
MAKEOPENGLAPI( glDepthFunc               )
MAKEOPENGLAPI( glPixelZoom               )
MAKEOPENGLAPI( glPixelTransferf          )
MAKEOPENGLAPI( glPixelTransferi          )
MAKEOPENGLAPI( glPixelStoref             )
MAKEOPENGLAPI( glPixelStorei             )
MAKEOPENGLAPI( glPixelMapfv              )
MAKEOPENGLAPI( glPixelMapuiv             )
MAKEOPENGLAPI( glPixelMapusv             )
MAKEOPENGLAPI( glReadBuffer              )
MAKEOPENGLAPI( glGetBooleanv             )
MAKEOPENGLAPI( glGetClipPlane            )
MAKEOPENGLAPI( glGetDoublev              )
MAKEOPENGLAPI( glGetError                )
MAKEOPENGLAPI( glGetFloatv               )
MAKEOPENGLAPI( glGetIntegerv             )
MAKEOPENGLAPI( glGetLightfv              )
MAKEOPENGLAPI( glGetLightiv              )
MAKEOPENGLAPI( glGetMapdv                )
MAKEOPENGLAPI( glGetMapfv                )
MAKEOPENGLAPI( glGetMapiv                )
MAKEOPENGLAPI( glGetMaterialfv           )
MAKEOPENGLAPI( glGetMaterialiv           )
MAKEOPENGLAPI( glGetPixelMapfv           )
MAKEOPENGLAPI( glGetPixelMapuiv          )
MAKEOPENGLAPI( glGetPixelMapusv          )
MAKEOPENGLAPI( glGetPolygonStipple       )
MAKEOPENGLAPI( glGetString               )
MAKEOPENGLAPI( glGetTexEnvfv             )
MAKEOPENGLAPI( glGetTexEnviv             )
MAKEOPENGLAPI( glGetTexGendv             )
MAKEOPENGLAPI( glGetTexGenfv             )
MAKEOPENGLAPI( glGetTexGeniv             )
MAKEOPENGLAPI( glGetTexImage             )
MAKEOPENGLAPI( glGetTexParameterfv       )
MAKEOPENGLAPI( glGetTexParameteriv       )
MAKEOPENGLAPI( glGetTexLevelParameterfv  )
MAKEOPENGLAPI( glGetTexLevelParameteriv  )
MAKEOPENGLAPI( glIsEnabled               )
MAKEOPENGLAPI( glIsList                  )
MAKEOPENGLAPI( glDepthRange              )
MAKEOPENGLAPI( glFrustum                 )
MAKEOPENGLAPI( glOrtho                   )
MAKEOPENGLAPI( glViewport                )
MAKEOPENGLAPI( glAreTexturesResident     )
MAKEOPENGLAPI( glCopyTexImage1D          )
MAKEOPENGLAPI( glCopyTexImage2D          )
MAKEOPENGLAPI( glCopyTexSubImage1D       )
MAKEOPENGLAPI( glCopyTexSubImage2D       )
MAKEOPENGLAPI( glDeleteTextures          )
MAKEOPENGLAPI( glGenTextures             )
MAKEOPENGLAPI( glIsTexture               )
MAKEOPENGLAPI( glPrioritizeTextures      )
MAKEOPENGLAPI( glTexSubImage1D           )
MAKEOPENGLAPI( glTexSubImage2D           )
MAKEOPENGLAPI( glGetColorTableEXT        )
MAKEOPENGLAPI( glGetColorTableParameterivEXT )
MAKEOPENGLAPI( glGetColorTableParameterfvEXT )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dlistfn.h ===
/******************************Module*Header*******************************\
* Module Name: dlistfn.h
*
* Display list inline functions
* Cannot be in dlist.h because they require full definitions of structures
* defines in context.h
*
* Created: 23-Oct-1995 18:31:42
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-96 Microsoft Corporation
*
\**************************************************************************/

#ifndef __DLISTFN_H__
#define __DLISTFN_H__

extern const GLubyte * FASTCALL __glle_Nop(__GLcontext *gc, const GLubyte *PC);

// Allocate space in a display for a display list op and return
// a pointer to the data space for the record
// These functions are specially written to be small so that they
// can be inlined to remove call overhead
    
// Add an op which doesn't require QWORD alignment
__inline
void *__glDlistAddOpUnaligned(__GLcontext *gc,
                              GLuint size,
                              __GLlistExecFunc *fp)
{
    __GLdlist *dlist;
    GLubyte *data;
    
    dlist = gc->dlist.listData;
    
    if (dlist->size-dlist->used < size)
    {
        if ((dlist = __glDlistGrow(size)) == NULL)
        {
            return NULL;
        }
    }

    data = dlist->head+dlist->used;
    dlist->used += size;
    
    *((__GLlistExecFunc * UNALIGNED64 *) data) = fp;

    return data+sizeof(__GLlistExecFunc *);
}

// Add an op which does require QWORD alignment
__inline
void *__glDlistAddOpAligned(__GLcontext *gc,
                            GLuint size,
                            __GLlistExecFunc *fp)
{
    __GLdlist *dlist;
    GLubyte *data;
    GLboolean addPad;
    
    dlist = gc->dlist.listData;
    
    // dlist->head is always non-QWORD aligned, but make sure
    // We use this fact to simplify the alignment check below
#ifndef _IA64_
    ASSERTOPENGL((((char *) (&dlist->head) - (char *) (dlist)) & 7) == 4,
	"bad dlist->head alignment\n");
#endif

    // Add padding for aligned records
    // Since head is always non-QWORD aligned, dlist->head is guaranteed
    // to be at QWORD offset 4.  Since we stick a dispatch pointer at
    // the head of every record, this gets bumped up to an even QWORD
    // boundary as long as the current record would begin at a half
    // QWORD boundary.  That means as long as dlist->used is QWORD-even,
    // the record data will be QWORD aligned
    // Win95 note: LocalAlloc doesn't appear to return QWORD aligned
    // memory so we need to check the real pointer for alignment
#ifndef _IA64_
    if (((ULONG_PTR)(dlist->head+dlist->used) & 7) == 0)
    {
        size += sizeof(__GLlistExecFunc **);
        addPad = GL_TRUE;
    }
    else
#endif
    {
        addPad = GL_FALSE;
    }

    if (dlist->size-dlist->used < size)
    {
        // New dlist->head will be properly non-QWORD aligned - remove any 
        // padding
        if( addPad ) {
            size -= sizeof(__GLlistExecFunc **);
            addPad = GL_FALSE;
        }
        if ((dlist = __glDlistGrow(size)) == NULL)
        {
            return NULL;
        }
    }

    data = dlist->head+dlist->used;
    dlist->used += size;
    
    if (addPad)
    {
        *((__GLlistExecFunc **) data) = __glle_Nop;
        data += sizeof(__GLlistExecFunc **);
    }

    *((__GLlistExecFunc * UNALIGNED64 *) data) = fp;

    return data+sizeof(__GLlistExecFunc *);
}

/*
** Append the given op to the currently under construction list.
*/
__inline
void __glDlistAppendOp(__GLcontext *gc, void *data,
                       __GLlistExecFunc *fp)
{
    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
    {
        fp(gc, (GLubyte *)data);
    }
}

// Resize the current op to a smaller size.
__inline
void __glDlistResizeCurrentOp(__GLcontext *gc, GLuint oldSize, GLuint newSize)
{
    __GLdlist *dlist;
    
    ASSERTOPENGL(oldSize >= newSize, "new size > old size!\n");

    dlist = gc->dlist.listData;
    dlist->used -= oldSize - newSize;
    return;
}
#endif // __DLISTFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\i386\noopapi.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: noopapi.asm
;
; OpenGL API function entries for i386.
;
; Created: 11/16/1993
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1993 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        .list

; XXX We should create an asm include file for these constants.

GL_INVALID_OPERATION    equ         0502h

; Macro for creating OpenGL API noop function
; This is modified from stdcall.inc.
; The noop functions always return 0 since some functions have return values.
; The only exception is glnoopGetError which returns GL_INVALID_OPERATION.

MAKEOPENGLNOOPAPI       macro Func,nBytes,RetVal
        &Func&@&nBytes:
        if DBG
            cmp     cWarningNoop,0
            jne     @F              ; print debug message once
            push    offset OPENGL_NoCurrentRC
            call    DbgPrint
            add     esp,4
        @@: inc     cWarningNoop
        endif
        ifb    <RetVal>
            xor     eax,eax         ; set return value to 0
        else
            mov     eax,&RetVal     ; set return value
        endif
        ret     &nBytes             ; pop stack
endm

        .data
if DBG
        align   4
        public  cWarningNoop
cWarningNoop        dd     0
        align   4
OPENGL_NoCurrentRC  db     'OPENGL32: No current RC',10,0
endif; DBG

        .code

if DBG
extrn   DbgPrint:proc
endif; DBG

; OpenGL API noop function entries
; The gl indices below are generated from the .cod file compiled from glapi.c
; The wgl indices below are generated from the .cod file compiled from wglcltgs.c

        align   4
MAKEOPENGLNOOPAPI       noop,0
MAKEOPENGLNOOPAPI       noop,4
MAKEOPENGLNOOPAPI       noop,8
MAKEOPENGLNOOPAPI       noop,12
MAKEOPENGLNOOPAPI       noop,16
MAKEOPENGLNOOPAPI       noop,20
MAKEOPENGLNOOPAPI       noop,24
MAKEOPENGLNOOPAPI       noop,28
MAKEOPENGLNOOPAPI       noop,32
MAKEOPENGLNOOPAPI       noop,36
MAKEOPENGLNOOPAPI       noop,40
MAKEOPENGLNOOPAPI       noop,48
MAKEOPENGLNOOPAPI       noop,56
MAKEOPENGLNOOPAPI       noop_GetError,0,GL_INVALID_OPERATION

; Define labels for the noop function table below.

glnoopNewList                   equ     noop@8
glnoopEndList                   equ     noop@0
glnoopCallList                  equ     noop@4
glnoopCallLists                 equ     noop@12
glnoopDeleteLists               equ     noop@8
glnoopGenLists                  equ     noop@4
glnoopListBase                  equ     noop@4
glnoopBegin                     equ     noop@4
glnoopBitmap                    equ     noop@28
glnoopColor3b                   equ     noop@12
glnoopColor3bv                  equ     noop@4
glnoopColor3d                   equ     noop@24
glnoopColor3dv                  equ     noop@4
glnoopColor3f                   equ     noop@12
glnoopColor3fv                  equ     noop@4
glnoopColor3i                   equ     noop@12
glnoopColor3iv                  equ     noop@4
glnoopColor3s                   equ     noop@12
glnoopColor3sv                  equ     noop@4
glnoopColor3ub                  equ     noop@12
glnoopColor3ubv                 equ     noop@4
glnoopColor3ui                  equ     noop@12
glnoopColor3uiv                 equ     noop@4
glnoopColor3us                  equ     noop@12
glnoopColor3usv                 equ     noop@4
glnoopColor4b                   equ     noop@16
glnoopColor4bv                  equ     noop@4
glnoopColor4d                   equ     noop@32
glnoopColor4dv                  equ     noop@4
glnoopColor4f                   equ     noop@16
glnoopColor4fv                  equ     noop@4
glnoopColor4i                   equ     noop@16
glnoopColor4iv                  equ     noop@4
glnoopColor4s                   equ     noop@16
glnoopColor4sv                  equ     noop@4
glnoopColor4ub                  equ     noop@16
glnoopColor4ubv                 equ     noop@4
glnoopColor4ui                  equ     noop@16
glnoopColor4uiv                 equ     noop@4
glnoopColor4us                  equ     noop@16
glnoopColor4usv                 equ     noop@4
glnoopEdgeFlag                  equ     noop@4
glnoopEdgeFlagv                 equ     noop@4
glnoopEnd                       equ     noop@0
glnoopIndexd                    equ     noop@8
glnoopIndexdv                   equ     noop@4
glnoopIndexf                    equ     noop@4
glnoopIndexfv                   equ     noop@4
glnoopIndexi                    equ     noop@4
glnoopIndexiv                   equ     noop@4
glnoopIndexs                    equ     noop@4
glnoopIndexsv                   equ     noop@4
glnoopNormal3b                  equ     noop@12
glnoopNormal3bv                 equ     noop@4
glnoopNormal3d                  equ     noop@24
glnoopNormal3dv                 equ     noop@4
glnoopNormal3f                  equ     noop@12
glnoopNormal3fv                 equ     noop@4
glnoopNormal3i                  equ     noop@12
glnoopNormal3iv                 equ     noop@4
glnoopNormal3s                  equ     noop@12
glnoopNormal3sv                 equ     noop@4
glnoopRasterPos2d               equ     noop@16
glnoopRasterPos2dv              equ     noop@4
glnoopRasterPos2f               equ     noop@8
glnoopRasterPos2fv              equ     noop@4
glnoopRasterPos2i               equ     noop@8
glnoopRasterPos2iv              equ     noop@4
glnoopRasterPos2s               equ     noop@8
glnoopRasterPos2sv              equ     noop@4
glnoopRasterPos3d               equ     noop@24
glnoopRasterPos3dv              equ     noop@4
glnoopRasterPos3f               equ     noop@12
glnoopRasterPos3fv              equ     noop@4
glnoopRasterPos3i               equ     noop@12
glnoopRasterPos3iv              equ     noop@4
glnoopRasterPos3s               equ     noop@12
glnoopRasterPos3sv              equ     noop@4
glnoopRasterPos4d               equ     noop@32
glnoopRasterPos4dv              equ     noop@4
glnoopRasterPos4f               equ     noop@16
glnoopRasterPos4fv              equ     noop@4
glnoopRasterPos4i               equ     noop@16
glnoopRasterPos4iv              equ     noop@4
glnoopRasterPos4s               equ     noop@16
glnoopRasterPos4sv              equ     noop@4
glnoopRectd                     equ     noop@32
glnoopRectdv                    equ     noop@8
glnoopRectf                     equ     noop@16
glnoopRectfv                    equ     noop@8
glnoopRecti                     equ     noop@16
glnoopRectiv                    equ     noop@8
glnoopRects                     equ     noop@16
glnoopRectsv                    equ     noop@8
glnoopTexCoord1d                equ     noop@8
glnoopTexCoord1dv               equ     noop@4
glnoopTexCoord1f                equ     noop@4
glnoopTexCoord1fv               equ     noop@4
glnoopTexCoord1i                equ     noop@4
glnoopTexCoord1iv               equ     noop@4
glnoopTexCoord1s                equ     noop@4
glnoopTexCoord1sv               equ     noop@4
glnoopTexCoord2d                equ     noop@16
glnoopTexCoord2dv               equ     noop@4
glnoopTexCoord2f                equ     noop@8
glnoopTexCoord2fv               equ     noop@4
glnoopTexCoord2i                equ     noop@8
glnoopTexCoord2iv               equ     noop@4
glnoopTexCoord2s                equ     noop@8
glnoopTexCoord2sv               equ     noop@4
glnoopTexCoord3d                equ     noop@24
glnoopTexCoord3dv               equ     noop@4
glnoopTexCoord3f                equ     noop@12
glnoopTexCoord3fv               equ     noop@4
glnoopTexCoord3i                equ     noop@12
glnoopTexCoord3iv               equ     noop@4
glnoopTexCoord3s                equ     noop@12
glnoopTexCoord3sv               equ     noop@4
glnoopTexCoord4d                equ     noop@32
glnoopTexCoord4dv               equ     noop@4
glnoopTexCoord4f                equ     noop@16
glnoopTexCoord4fv               equ     noop@4
glnoopTexCoord4i                equ     noop@16
glnoopTexCoord4iv               equ     noop@4
glnoopTexCoord4s                equ     noop@16
glnoopTexCoord4sv               equ     noop@4
glnoopVertex2d                  equ     noop@16
glnoopVertex2dv                 equ     noop@4
glnoopVertex2f                  equ     noop@8
glnoopVertex2fv                 equ     noop@4
glnoopVertex2i                  equ     noop@8
glnoopVertex2iv                 equ     noop@4
glnoopVertex2s                  equ     noop@8
glnoopVertex2sv                 equ     noop@4
glnoopVertex3d                  equ     noop@24
glnoopVertex3dv                 equ     noop@4
glnoopVertex3f                  equ     noop@12
glnoopVertex3fv                 equ     noop@4
glnoopVertex3i                  equ     noop@12
glnoopVertex3iv                 equ     noop@4
glnoopVertex3s                  equ     noop@12
glnoopVertex3sv                 equ     noop@4
glnoopVertex4d                  equ     noop@32
glnoopVertex4dv                 equ     noop@4
glnoopVertex4f                  equ     noop@16
glnoopVertex4fv                 equ     noop@4
glnoopVertex4i                  equ     noop@16
glnoopVertex4iv                 equ     noop@4
glnoopVertex4s                  equ     noop@16
glnoopVertex4sv                 equ     noop@4
glnoopClipPlane                 equ     noop@8
glnoopColorMaterial             equ     noop@8
glnoopCullFace                  equ     noop@4
glnoopFogf                      equ     noop@8
glnoopFogfv                     equ     noop@8
glnoopFogi                      equ     noop@8
glnoopFogiv                     equ     noop@8
glnoopFrontFace                 equ     noop@4
glnoopHint                      equ     noop@8
glnoopLightf                    equ     noop@12
glnoopLightfv                   equ     noop@12
glnoopLighti                    equ     noop@12
glnoopLightiv                   equ     noop@12
glnoopLightModelf               equ     noop@8
glnoopLightModelfv              equ     noop@8
glnoopLightModeli               equ     noop@8
glnoopLightModeliv              equ     noop@8
glnoopLineStipple               equ     noop@8
glnoopLineWidth                 equ     noop@4
glnoopMaterialf                 equ     noop@12
glnoopMaterialfv                equ     noop@12
glnoopMateriali                 equ     noop@12
glnoopMaterialiv                equ     noop@12
glnoopPointSize                 equ     noop@4
glnoopPolygonMode               equ     noop@8
glnoopPolygonStipple            equ     noop@4
glnoopScissor                   equ     noop@16
glnoopShadeModel                equ     noop@4
glnoopTexParameterf             equ     noop@12
glnoopTexParameterfv            equ     noop@12
glnoopTexParameteri             equ     noop@12
glnoopTexParameteriv            equ     noop@12
glnoopTexImage1D                equ     noop@32
glnoopTexImage2D                equ     noop@36
glnoopTexEnvf                   equ     noop@12
glnoopTexEnvfv                  equ     noop@12
glnoopTexEnvi                   equ     noop@12
glnoopTexEnviv                  equ     noop@12
glnoopTexGend                   equ     noop@16
glnoopTexGendv                  equ     noop@12
glnoopTexGenf                   equ     noop@12
glnoopTexGenfv                  equ     noop@12
glnoopTexGeni                   equ     noop@12
glnoopTexGeniv                  equ     noop@12
glnoopFeedbackBuffer            equ     noop@12
glnoopSelectBuffer              equ     noop@8
glnoopRenderMode                equ     noop@4
glnoopInitNames                 equ     noop@0
glnoopLoadName                  equ     noop@4
glnoopPassThrough               equ     noop@4
glnoopPopName                   equ     noop@0
glnoopPushName                  equ     noop@4
glnoopDrawBuffer                equ     noop@4
glnoopClear                     equ     noop@4
glnoopClearAccum                equ     noop@16
glnoopClearIndex                equ     noop@4
glnoopClearColor                equ     noop@16
glnoopClearStencil              equ     noop@4
glnoopClearDepth                equ     noop@8
glnoopStencilMask               equ     noop@4
glnoopColorMask                 equ     noop@16
glnoopDepthMask                 equ     noop@4
glnoopIndexMask                 equ     noop@4
glnoopAccum                     equ     noop@8
glnoopDisable                   equ     noop@4
glnoopEnable                    equ     noop@4
glnoopFinish                    equ     noop@0
glnoopFlush                     equ     noop@0
glnoopPopAttrib                 equ     noop@0
glnoopPushAttrib                equ     noop@4
glnoopMap1d                     equ     noop@32
glnoopMap1f                     equ     noop@24
glnoopMap2d                     equ     noop@56
glnoopMap2f                     equ     noop@40
glnoopMapGrid1d                 equ     noop@20
glnoopMapGrid1f                 equ     noop@12
glnoopMapGrid2d                 equ     noop@40
glnoopMapGrid2f                 equ     noop@24
glnoopEvalCoord1d               equ     noop@8
glnoopEvalCoord1dv              equ     noop@4
glnoopEvalCoord1f               equ     noop@4
glnoopEvalCoord1fv              equ     noop@4
glnoopEvalCoord2d               equ     noop@16
glnoopEvalCoord2dv              equ     noop@4
glnoopEvalCoord2f               equ     noop@8
glnoopEvalCoord2fv              equ     noop@4
glnoopEvalMesh1                 equ     noop@12
glnoopEvalPoint1                equ     noop@4
glnoopEvalMesh2                 equ     noop@20
glnoopEvalPoint2                equ     noop@8
glnoopAlphaFunc                 equ     noop@8
glnoopBlendFunc                 equ     noop@8
glnoopLogicOp                   equ     noop@4
glnoopStencilFunc               equ     noop@12
glnoopStencilOp                 equ     noop@12
glnoopDepthFunc                 equ     noop@4
glnoopPixelZoom                 equ     noop@8
glnoopPixelTransferf            equ     noop@8
glnoopPixelTransferi            equ     noop@8
glnoopPixelStoref               equ     noop@8
glnoopPixelStorei               equ     noop@8
glnoopPixelMapfv                equ     noop@12
glnoopPixelMapuiv               equ     noop@12
glnoopPixelMapusv               equ     noop@12
glnoopReadBuffer                equ     noop@4
glnoopCopyPixels                equ     noop@20
glnoopReadPixels                equ     noop@28
glnoopDrawPixels                equ     noop@20
glnoopGetBooleanv               equ     noop@8
glnoopGetClipPlane              equ     noop@8
glnoopGetDoublev                equ     noop@8
glnoopGetError                  equ     noop_GetError@0
glnoopGetFloatv                 equ     noop@8
glnoopGetIntegerv               equ     noop@8
glnoopGetLightfv                equ     noop@12
glnoopGetLightiv                equ     noop@12
glnoopGetMapdv                  equ     noop@12
glnoopGetMapfv                  equ     noop@12
glnoopGetMapiv                  equ     noop@12
glnoopGetMaterialfv             equ     noop@12
glnoopGetMaterialiv             equ     noop@12
glnoopGetPixelMapfv             equ     noop@8
glnoopGetPixelMapuiv            equ     noop@8
glnoopGetPixelMapusv            equ     noop@8
glnoopGetPolygonStipple         equ     noop@4
glnoopGetString                 equ     noop@4
glnoopGetTexEnvfv               equ     noop@12
glnoopGetTexEnviv               equ     noop@12
glnoopGetTexGendv               equ     noop@12
glnoopGetTexGenfv               equ     noop@12
glnoopGetTexGeniv               equ     noop@12
glnoopGetTexImage               equ     noop@20
glnoopGetTexParameterfv         equ     noop@12
glnoopGetTexParameteriv         equ     noop@12
glnoopGetTexLevelParameterfv    equ     noop@16
glnoopGetTexLevelParameteriv    equ     noop@16
glnoopIsEnabled                 equ     noop@4
glnoopIsList                    equ     noop@4
glnoopDepthRange                equ     noop@16
glnoopFrustum                   equ     noop@48
glnoopLoadIdentity              equ     noop@0
glnoopLoadMatrixf               equ     noop@4
glnoopLoadMatrixd               equ     noop@4
glnoopMatrixMode                equ     noop@4
glnoopMultMatrixf               equ     noop@4
glnoopMultMatrixd               equ     noop@4
glnoopOrtho                     equ     noop@48
glnoopPopMatrix                 equ     noop@0
glnoopPushMatrix                equ     noop@0
glnoopRotated                   equ     noop@32
glnoopRotatef                   equ     noop@16
glnoopScaled                    equ     noop@24
glnoopScalef                    equ     noop@12
glnoopTranslated                equ     noop@24
glnoopTranslatef                equ     noop@12
glnoopViewport                  equ     noop@16
glnoopArrayElement		equ     noop@4
glnoopBindTexture		equ     noop@8
glnoopColorPointer		equ     noop@16
glnoopDisableClientState	equ     noop@4
glnoopDrawArrays		equ     noop@12
glnoopDrawElements		equ     noop@16
glnoopEdgeFlagPointer		equ     noop@8
glnoopEnableClientState		equ     noop@4
glnoopIndexPointer		equ     noop@12
glnoopIndexub			equ     noop@4
glnoopIndexubv			equ     noop@4
glnoopInterleavedArrays		equ     noop@12
glnoopNormalPointer		equ     noop@12
glnoopPolygonOffset		equ     noop@8
glnoopTexCoordPointer		equ     noop@16
glnoopVertexPointer		equ     noop@16
glnoopAreTexturesResident	equ     noop@12
glnoopCopyTexImage1D		equ     noop@28
glnoopCopyTexImage2D		equ     noop@32
glnoopCopyTexSubImage1D		equ     noop@24
glnoopCopyTexSubImage2D		equ     noop@32
glnoopDeleteTextures		equ     noop@8
glnoopGenTextures		equ     noop@8
glnoopGetPointerv		equ     noop@8
glnoopIsTexture			equ     noop@4
glnoopPrioritizeTextures	equ     noop@12
glnoopTexSubImage1D		equ     noop@28
glnoopTexSubImage2D		equ     noop@36
glnoopPopClientAttrib           equ     noop@0
glnoopPushClientAttrib          equ     noop@4

; OpenGL API noop function table.

        align   4
        public  glNullCltProcTable
glNullCltProcTable  label   dword
        dd      (glNullCltProcTableEnd-glNullCltProcTable-size(dword)) / size(dword)
        dd      glnoopNewList
        dd      glnoopEndList
        dd      glnoopCallList
        dd      glnoopCallLists
        dd      glnoopDeleteLists
        dd      glnoopGenLists
        dd      glnoopListBase
        dd      glnoopBegin
        dd      glnoopBitmap
        dd      glnoopColor3b
        dd      glnoopColor3bv
        dd      glnoopColor3d
        dd      glnoopColor3dv
        dd      glnoopColor3f
        dd      glnoopColor3fv
        dd      glnoopColor3i
        dd      glnoopColor3iv
        dd      glnoopColor3s
        dd      glnoopColor3sv
        dd      glnoopColor3ub
        dd      glnoopColor3ubv
        dd      glnoopColor3ui
        dd      glnoopColor3uiv
        dd      glnoopColor3us
        dd      glnoopColor3usv
        dd      glnoopColor4b
        dd      glnoopColor4bv
        dd      glnoopColor4d
        dd      glnoopColor4dv
        dd      glnoopColor4f
        dd      glnoopColor4fv
        dd      glnoopColor4i
        dd      glnoopColor4iv
        dd      glnoopColor4s
        dd      glnoopColor4sv
        dd      glnoopColor4ub
        dd      glnoopColor4ubv
        dd      glnoopColor4ui
        dd      glnoopColor4uiv
        dd      glnoopColor4us
        dd      glnoopColor4usv
        dd      glnoopEdgeFlag
        dd      glnoopEdgeFlagv
        dd      glnoopEnd
        dd      glnoopIndexd
        dd      glnoopIndexdv
        dd      glnoopIndexf
        dd      glnoopIndexfv
        dd      glnoopIndexi
        dd      glnoopIndexiv
        dd      glnoopIndexs
        dd      glnoopIndexsv
        dd      glnoopNormal3b
        dd      glnoopNormal3bv
        dd      glnoopNormal3d
        dd      glnoopNormal3dv
        dd      glnoopNormal3f
        dd      glnoopNormal3fv
        dd      glnoopNormal3i
        dd      glnoopNormal3iv
        dd      glnoopNormal3s
        dd      glnoopNormal3sv
        dd      glnoopRasterPos2d
        dd      glnoopRasterPos2dv
        dd      glnoopRasterPos2f
        dd      glnoopRasterPos2fv
        dd      glnoopRasterPos2i
        dd      glnoopRasterPos2iv
        dd      glnoopRasterPos2s
        dd      glnoopRasterPos2sv
        dd      glnoopRasterPos3d
        dd      glnoopRasterPos3dv
        dd      glnoopRasterPos3f
        dd      glnoopRasterPos3fv
        dd      glnoopRasterPos3i
        dd      glnoopRasterPos3iv
        dd      glnoopRasterPos3s
        dd      glnoopRasterPos3sv
        dd      glnoopRasterPos4d
        dd      glnoopRasterPos4dv
        dd      glnoopRasterPos4f
        dd      glnoopRasterPos4fv
        dd      glnoopRasterPos4i
        dd      glnoopRasterPos4iv
        dd      glnoopRasterPos4s
        dd      glnoopRasterPos4sv
        dd      glnoopRectd
        dd      glnoopRectdv
        dd      glnoopRectf
        dd      glnoopRectfv
        dd      glnoopRecti
        dd      glnoopRectiv
        dd      glnoopRects
        dd      glnoopRectsv
        dd      glnoopTexCoord1d
        dd      glnoopTexCoord1dv
        dd      glnoopTexCoord1f
        dd      glnoopTexCoord1fv
        dd      glnoopTexCoord1i
        dd      glnoopTexCoord1iv
        dd      glnoopTexCoord1s
        dd      glnoopTexCoord1sv
        dd      glnoopTexCoord2d
        dd      glnoopTexCoord2dv
        dd      glnoopTexCoord2f
        dd      glnoopTexCoord2fv
        dd      glnoopTexCoord2i
        dd      glnoopTexCoord2iv
        dd      glnoopTexCoord2s
        dd      glnoopTexCoord2sv
        dd      glnoopTexCoord3d
        dd      glnoopTexCoord3dv
        dd      glnoopTexCoord3f
        dd      glnoopTexCoord3fv
        dd      glnoopTexCoord3i
        dd      glnoopTexCoord3iv
        dd      glnoopTexCoord3s
        dd      glnoopTexCoord3sv
        dd      glnoopTexCoord4d
        dd      glnoopTexCoord4dv
        dd      glnoopTexCoord4f
        dd      glnoopTexCoord4fv
        dd      glnoopTexCoord4i
        dd      glnoopTexCoord4iv
        dd      glnoopTexCoord4s
        dd      glnoopTexCoord4sv
        dd      glnoopVertex2d
        dd      glnoopVertex2dv
        dd      glnoopVertex2f
        dd      glnoopVertex2fv
        dd      glnoopVertex2i
        dd      glnoopVertex2iv
        dd      glnoopVertex2s
        dd      glnoopVertex2sv
        dd      glnoopVertex3d
        dd      glnoopVertex3dv
        dd      glnoopVertex3f
        dd      glnoopVertex3fv
        dd      glnoopVertex3i
        dd      glnoopVertex3iv
        dd      glnoopVertex3s
        dd      glnoopVertex3sv
        dd      glnoopVertex4d
        dd      glnoopVertex4dv
        dd      glnoopVertex4f
        dd      glnoopVertex4fv
        dd      glnoopVertex4i
        dd      glnoopVertex4iv
        dd      glnoopVertex4s
        dd      glnoopVertex4sv
        dd      glnoopClipPlane
        dd      glnoopColorMaterial
        dd      glnoopCullFace
        dd      glnoopFogf
        dd      glnoopFogfv
        dd      glnoopFogi
        dd      glnoopFogiv
        dd      glnoopFrontFace
        dd      glnoopHint
        dd      glnoopLightf
        dd      glnoopLightfv
        dd      glnoopLighti
        dd      glnoopLightiv
        dd      glnoopLightModelf
        dd      glnoopLightModelfv
        dd      glnoopLightModeli
        dd      glnoopLightModeliv
        dd      glnoopLineStipple
        dd      glnoopLineWidth
        dd      glnoopMaterialf
        dd      glnoopMaterialfv
        dd      glnoopMateriali
        dd      glnoopMaterialiv
        dd      glnoopPointSize
        dd      glnoopPolygonMode
        dd      glnoopPolygonStipple
        dd      glnoopScissor
        dd      glnoopShadeModel
        dd      glnoopTexParameterf
        dd      glnoopTexParameterfv
        dd      glnoopTexParameteri
        dd      glnoopTexParameteriv
        dd      glnoopTexImage1D
        dd      glnoopTexImage2D
        dd      glnoopTexEnvf
        dd      glnoopTexEnvfv
        dd      glnoopTexEnvi
        dd      glnoopTexEnviv
        dd      glnoopTexGend
        dd      glnoopTexGendv
        dd      glnoopTexGenf
        dd      glnoopTexGenfv
        dd      glnoopTexGeni
        dd      glnoopTexGeniv
        dd      glnoopFeedbackBuffer
        dd      glnoopSelectBuffer
        dd      glnoopRenderMode
        dd      glnoopInitNames
        dd      glnoopLoadName
        dd      glnoopPassThrough
        dd      glnoopPopName
        dd      glnoopPushName
        dd      glnoopDrawBuffer
        dd      glnoopClear
        dd      glnoopClearAccum
        dd      glnoopClearIndex
        dd      glnoopClearColor
        dd      glnoopClearStencil
        dd      glnoopClearDepth
        dd      glnoopStencilMask
        dd      glnoopColorMask
        dd      glnoopDepthMask
        dd      glnoopIndexMask
        dd      glnoopAccum
        dd      glnoopDisable
        dd      glnoopEnable
        dd      glnoopFinish
        dd      glnoopFlush
        dd      glnoopPopAttrib
        dd      glnoopPushAttrib
        dd      glnoopMap1d
        dd      glnoopMap1f
        dd      glnoopMap2d
        dd      glnoopMap2f
        dd      glnoopMapGrid1d
        dd      glnoopMapGrid1f
        dd      glnoopMapGrid2d
        dd      glnoopMapGrid2f
        dd      glnoopEvalCoord1d
        dd      glnoopEvalCoord1dv
        dd      glnoopEvalCoord1f
        dd      glnoopEvalCoord1fv
        dd      glnoopEvalCoord2d
        dd      glnoopEvalCoord2dv
        dd      glnoopEvalCoord2f
        dd      glnoopEvalCoord2fv
        dd      glnoopEvalMesh1
        dd      glnoopEvalPoint1
        dd      glnoopEvalMesh2
        dd      glnoopEvalPoint2
        dd      glnoopAlphaFunc
        dd      glnoopBlendFunc
        dd      glnoopLogicOp
        dd      glnoopStencilFunc
        dd      glnoopStencilOp
        dd      glnoopDepthFunc
        dd      glnoopPixelZoom
        dd      glnoopPixelTransferf
        dd      glnoopPixelTransferi
        dd      glnoopPixelStoref
        dd      glnoopPixelStorei
        dd      glnoopPixelMapfv
        dd      glnoopPixelMapuiv
        dd      glnoopPixelMapusv
        dd      glnoopReadBuffer
        dd      glnoopCopyPixels
        dd      glnoopReadPixels
        dd      glnoopDrawPixels
        dd      glnoopGetBooleanv
        dd      glnoopGetClipPlane
        dd      glnoopGetDoublev
        dd      glnoopGetError
        dd      glnoopGetFloatv
        dd      glnoopGetIntegerv
        dd      glnoopGetLightfv
        dd      glnoopGetLightiv
        dd      glnoopGetMapdv
        dd      glnoopGetMapfv
        dd      glnoopGetMapiv
        dd      glnoopGetMaterialfv
        dd      glnoopGetMaterialiv
        dd      glnoopGetPixelMapfv
        dd      glnoopGetPixelMapuiv
        dd      glnoopGetPixelMapusv
        dd      glnoopGetPolygonStipple
        dd      glnoopGetString
        dd      glnoopGetTexEnvfv
        dd      glnoopGetTexEnviv
        dd      glnoopGetTexGendv
        dd      glnoopGetTexGenfv
        dd      glnoopGetTexGeniv
        dd      glnoopGetTexImage
        dd      glnoopGetTexParameterfv
        dd      glnoopGetTexParameteriv
        dd      glnoopGetTexLevelParameterfv
        dd      glnoopGetTexLevelParameteriv
        dd      glnoopIsEnabled
        dd      glnoopIsList
        dd      glnoopDepthRange
        dd      glnoopFrustum
        dd      glnoopLoadIdentity
        dd      glnoopLoadMatrixf
        dd      glnoopLoadMatrixd
        dd      glnoopMatrixMode
        dd      glnoopMultMatrixf
        dd      glnoopMultMatrixd
        dd      glnoopOrtho
        dd      glnoopPopMatrix
        dd      glnoopPushMatrix
        dd      glnoopRotated
        dd      glnoopRotatef
        dd      glnoopScaled
        dd      glnoopScalef
        dd      glnoopTranslated
        dd      glnoopTranslatef
        dd      glnoopViewport
        dd      glnoopArrayElement
        dd      glnoopBindTexture
        dd      glnoopColorPointer
        dd      glnoopDisableClientState
        dd      glnoopDrawArrays
        dd      glnoopDrawElements
        dd      glnoopEdgeFlagPointer
        dd      glnoopEnableClientState
        dd      glnoopIndexPointer
        dd      glnoopIndexub
        dd      glnoopIndexubv
        dd      glnoopInterleavedArrays
        dd      glnoopNormalPointer
        dd      glnoopPolygonOffset
        dd      glnoopTexCoordPointer
        dd      glnoopVertexPointer
        dd      glnoopAreTexturesResident
        dd      glnoopCopyTexImage1D
        dd      glnoopCopyTexImage2D
        dd      glnoopCopyTexSubImage1D
        dd      glnoopCopyTexSubImage2D
        dd      glnoopDeleteTextures
        dd      glnoopGenTextures
        dd      glnoopGetPointerv
        dd      glnoopIsTexture
        dd      glnoopPrioritizeTextures
        dd      glnoopTexSubImage1D
        dd      glnoopTexSubImage2D
        dd      glnoopPopClientAttrib
        dd      glnoopPushClientAttrib
glNullCltProcTableEnd    equ    $

glnoopDrawRangeElementsWIN	equ	noop@24
glnoopColorTableEXT		equ	noop@24
glnoopColorSubTableEXT		equ	noop@24
glnoopGetColorTableEXT		equ	noop@16
glnoopGetColorTableParameterivEXT equ	noop@12
glnoopGetColorTableParameterfvEXT equ	noop@12
glnoopCurrentTextureIndexWIN	equ	noop@4
glnoopMultiTexCoord1dWIN	equ	noop@12
glnoopMultiTexCoord1dvWIN	equ	noop@8
glnoopMultiTexCoord1fWIN	equ	noop@8
glnoopMultiTexCoord1fvWIN	equ	noop@8
glnoopMultiTexCoord1iWIN	equ	noop@8
glnoopMultiTexCoord1ivWIN	equ	noop@8
glnoopMultiTexCoord1sWIN	equ	noop@8
glnoopMultiTexCoord1svWIN	equ	noop@8
glnoopMultiTexCoord2dWIN	equ	noop@20
glnoopMultiTexCoord2dvWIN	equ	noop@8
glnoopMultiTexCoord2fWIN	equ	noop@12
glnoopMultiTexCoord2fvWIN	equ	noop@8
glnoopMultiTexCoord2iWIN	equ	noop@12
glnoopMultiTexCoord2ivWIN	equ	noop@8
glnoopMultiTexCoord2sWIN	equ	noop@12
glnoopMultiTexCoord2svWIN	equ	noop@8
glnoopMultiTexCoord3dWIN	equ	noop@28
glnoopMultiTexCoord3dvWIN	equ	noop@8
glnoopMultiTexCoord3fWIN	equ	noop@16
glnoopMultiTexCoord3fvWIN	equ	noop@8
glnoopMultiTexCoord3iWIN	equ	noop@16
glnoopMultiTexCoord3ivWIN	equ	noop@8
glnoopMultiTexCoord3sWIN	equ	noop@16
glnoopMultiTexCoord3svWIN	equ	noop@8
glnoopMultiTexCoord4dWIN	equ	noop@36
glnoopMultiTexCoord4dvWIN	equ	noop@8
glnoopMultiTexCoord4fWIN	equ	noop@20
glnoopMultiTexCoord4fvWIN	equ	noop@8
glnoopMultiTexCoord4iWIN	equ	noop@20
glnoopMultiTexCoord4ivWIN	equ	noop@8
glnoopMultiTexCoord4sWIN	equ	noop@20
glnoopMultiTexCoord4svWIN	equ	noop@8
glnoopBindNthTextureWIN		equ	noop@12
glnoopNthTexCombineFuncWIN	equ	noop@28
	
; OpenGL EXT API noop function table.

        align   4
        public  glNullExtProcTable
glNullExtProcTable  label   dword
        dd      (glNullExtProcTableEnd-glNullExtProcTable-size(dword)) / size(dword)
        dd glnoopDrawRangeElementsWIN
        dd glnoopColorTableEXT
        dd glnoopColorSubTableEXT
        dd glnoopGetColorTableEXT
        dd glnoopGetColorTableParameterivEXT
        dd glnoopGetColorTableParameterfvEXT
IFDEF GL_WIN_multiple_textures
        dd glnoopCurrentTextureIndexWIN
        dd glnoopMultiTexCoord1dWIN
        dd glnoopMultiTexCoord1dvWIN
        dd glnoopMultiTexCoord1fWIN
        dd glnoopMultiTexCoord1fvWIN
        dd glnoopMultiTexCoord1iWIN
        dd glnoopMultiTexCoord1ivWIN
        dd glnoopMultiTexCoord1sWIN
        dd glnoopMultiTexCoord1svWIN
        dd glnoopMultiTexCoord2dWIN
        dd glnoopMultiTexCoord2dvWIN
        dd glnoopMultiTexCoord2fWIN
        dd glnoopMultiTexCoord2fvWIN
        dd glnoopMultiTexCoord2iWIN
        dd glnoopMultiTexCoord2ivWIN
        dd glnoopMultiTexCoord2sWIN
        dd glnoopMultiTexCoord2svWIN
        dd glnoopMultiTexCoord3dWIN
	dd glnoopMultiTexCoord3dvWIN
	dd glnoopMultiTexCoord3fWIN
        dd glnoopMultiTexCoord3fvWIN
        dd glnoopMultiTexCoord3iWIN
        dd glnoopMultiTexCoord3ivWIN
        dd glnoopMultiTexCoord3sWIN
        dd glnoopMultiTexCoord3svWIN
        dd glnoopMultiTexCoord4dWIN
        dd glnoopMultiTexCoord4dvWIN
        dd glnoopMultiTexCoord4fWIN
        dd glnoopMultiTexCoord4fvWIN
        dd glnoopMultiTexCoord4iWIN
        dd glnoopMultiTexCoord4ivWIN
        dd glnoopMultiTexCoord4sWIN
        dd glnoopMultiTexCoord4svWIN
        dd glnoopBindNthTextureWIN
        dd glnoopNthTexCombineFuncWIN
ENDIF
glNullExtProcTableEnd    equ    $
	
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\client\i386\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IF PROFILE
EXTRN _penter:NEAR
	
PROF_ENTRY MACRO
	call _penter
	ENDM
ELSE
PROF_ENTRY MACRO
	ENDM
ENDIF
	
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dlistint.h ===
#ifndef __gldlistint_h
#define __gldlistint_h

/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list internal structure description.
**
** $Revision: 1.2 $
** $Date: 1993/09/29 00:45:06 $
*/
#include "dlist.h"

/*
** Minimum size of an allocated block of display lists.
** If the user uses a single display list in a reserved block,
** __GL_DLIST_MIN_ARRAY_BLOCK will be allocated at once.
**
** A block will not be grown any larger than __GL_DLIST_MAX_ARRAY_BLOCK.
** Large blocks are easier to use when display lists are being executed, but
** more difficult to manage when they are being created.
*/
#define __GL_DLIST_MIN_ARRAY_BLOCK      16
#define __GL_DLIST_MAX_ARRAY_BLOCK      1024

#ifndef NT
/*
** Display list group structure
*/
struct __GLdlistArrayRec {
    GLint refcount;            /* # contexts using this array */
};

/*
** Regardless of what __GLdlistArray looks like, the following api points
** must be provided, along with __glim_GenLists(), __glim_IsList(),
** __glim_ListBase(), and __glim_DeleteLists() (defined in dlist.h)
*/

/*
** Allocate and initialize a new array structure.
*/
extern __GLdlistArray *__glDlistNewArray(__GLcontext *gc);

/*
** Free the array structure.
*/
extern void FASTCALL __glDlistFreeArray(__GLcontext *gc, __GLdlistArray *array);
#endif

/*
** Clean up a display list,
** given to names management code
** Also called directly
*/
void WINAPIV __glDisposeDlist(__GLcontext *gc, void *pData);

#ifdef NT_SERVER_SHARE_LISTS
extern void DlReleaseLocks(__GLcontext *gc);
#endif

#endif /* __gldlistint_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dlistopt.h ===
#ifndef __gldlistopt_h_
#define __gldlistopt_h_

/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list state descriptions.
**
*/

#ifndef NT

/*
** Generic optimizer.  This optimizer simply uses all of the generic
** optimizations.
*/
void FASTCALL __glDlistOptimizer(__GLcontext *gc, __GLcompiledDlist *cdlist);

/*
** Optimizer for multiple consecutive material changes.  This routine 
** combines a bunch of material changes into one quick material change.
*/
void FASTCALL __glDlistOptimizeMaterial(__GLcontext *gc, __GLcompiledDlist *cdlist);


/*
** Generic flags used for optimization (during gllc routines).
*/
#define __GL_DLFLAG_HAS_VERTEX		0x00000001
#define __GL_DLFLAG_HAS_NORMAL		0x00000002
#define __GL_DLFLAG_HAS_COLOR		0x00000004
#define __GL_DLFLAG_HAS_TEXCOORDS	0x00000008
#define __GL_DLFLAG_HAS_INDEX		0x00000010
#define __GL_DLFLAG_HAS_RASTERPOS	0x00000020
#define __GL_DLFLAG_HAS_RECT		0x00000040
#define __GL_DLFLAG_HAS_BEGIN		0x00000080
#define __GL_DLFLAG_HAS_MATERIAL	0x00000100

/*
** Generic opcodes created during generic dlist optimizations.
*/
#define __GL_GENERIC_DLIST_OPCODE	1000
#define __glop_Begin_LineLoop		1000
#define __glop_Begin_LineStrip		1001
#define __glop_Begin_Lines		1002
#define __glop_Begin_Points		1003
#define __glop_Begin_Polygon		1004
#define __glop_Begin_TriangleStrip	1005
#define __glop_Begin_TriangleFan	1006
#define __glop_Begin_Triangles		1007
#define __glop_Begin_QuadStrip		1008
#define __glop_Begin_Quads		1009
#define __glop_InvalidValue		1010
#define __glop_InvalidEnum		1011
#define __glop_InvalidOperation		1012
#define __glop_FastMaterial		1013

/*
** List execution functions.
*/
extern __GLlistExecFunc *__gl_GenericDlOps[];
extern const GLubyte * FASTCALL __glle_Begin_LineLoop(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_LineStrip(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Lines(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Points(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Polygon(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_TriangleStrip(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_TriangleFan(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Triangles(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_QuadStrip(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_Begin_Quads(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_FastMaterial(__GLcontext *gc, const GLubyte *);
extern void __gllc_Error(GLenum error);
#endif // !NT

extern const GLubyte * FASTCALL __glle_InvalidValue(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_InvalidEnum(__GLcontext *gc, const GLubyte *);
extern const GLubyte * FASTCALL __glle_InvalidOperation(__GLcontext *gc, const GLubyte *);
extern void __gllc_InvalidValue();
extern void __gllc_InvalidEnum();
extern void __gllc_InvalidOperation();

#ifdef NT
extern const GLubyte * FASTCALL __glle_PolyData_C3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_C3F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_C4F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_C3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_C3F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData_T2F_C4F_N3F_V3F(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyMaterial(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_PolyData(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_Begin(__GLcontext *gc, const GLubyte *PC);
extern const GLubyte * FASTCALL __glle_End(__GLcontext *gc, const GLubyte *PC);

void APIENTRY __gllc_PolyMaterial(GLuint faceName, __GLmatChange *pdMat);
void APIENTRY __glDlistCompilePolyData(__GLcontext *gc, GLboolean bPartial);

#define DLIST_BEGIN_HAS_OTHER_COLOR	0x0001
#define DLIST_BEGIN_NO_MATCHING_END	0x0002
#define DLIST_BEGIN_HAS_CALLLIST	0x0004
#define DLIST_BEGIN_DRAWARRAYS  	0x0008
#define DLIST_BEGIN_DRAWELEMENTS	0x0010
#define DLIST_BEGIN_HAS_CLAMP_COLOR	0x0020
#endif // NT

#endif /* __gldlistopt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_init.c ===
/******************************Module*Header*******************************\
* Module Name: dl_init.c
*
* Display list initialization and sharing rountines.
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list init/destroy code.
**
** $Revision: 1.7 $
** $Date: 1993/09/29 00:44:06 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** Empty data structure for display lists.
*/
static  __GLdlist emptyDlist = {
	2,			/* refcount, two so that it can never die */
        0                       /* Everything else, some initialized later */
};

static __GLnamesArrayTypeInfo dlistTypeInfo =
{
    &emptyDlist,
    sizeof(__GLdlist),
    __glDisposeDlist,
    NULL
};

/*
** Used to share display lists between two different contexts.
*/
#ifdef NT_SERVER_SHARE_LISTS
GLboolean FASTCALL __glCanShareDlist(__GLcontext *gc, __GLcontext *shareMe)
{
    GLboolean canShare = GL_TRUE;
    
    if (gc->dlist.namesArray != NULL)
    {
        __glNamesLockArray(gc, gc->dlist.namesArray);
        
        // Make sure we're not trying to replace a shared list
        // The spec also says that it is illegal for the new context
        // to have any display lists
        canShare = gc->dlist.namesArray->refcount == 1 &&
            gc->dlist.namesArray->tree == NULL &&
            shareMe->dlist.namesArray != NULL;

        __glNamesUnlockArray(gc, gc->dlist.namesArray);
    }
    
    return canShare;
}
#endif

void FASTCALL __glShareDlist(__GLcontext *gc, __GLcontext *shareMe)
{
#ifdef NT_SERVER_SHARE_LISTS
    __glFreeDlistState(gc);
    __glNamesLockArray(gc, shareMe->dlist.namesArray);
#endif

    gc->dlist.namesArray = shareMe->dlist.namesArray;
    gc->dlist.namesArray->refcount++;
    
#ifdef NT_SERVER_SHARE_LISTS
    DBGLEVEL3(LEVEL_INFO, "Sharing dlists %p with %p, count %d\n", gc, shareMe,
              gc->dlist.namesArray->refcount);

    __glNamesUnlockArray(gc, shareMe->dlist.namesArray);
#endif
}

void FASTCALL __glInitDlistState(__GLcontext *gc)
{
    __GLdlistMachine *dlist;

    // This is required by the names management code
    ASSERTOPENGL(offsetof(__GLdlist, refcount) == 0,
                 "Dlist refcount not at offset zero\n");

    // Set empty dlist to contain no entries
    emptyDlist.end = emptyDlist.head;
    
    dlist = &gc->dlist;

    dlist->nesting = 0;
    dlist->currentList = 0;
    dlist->listData = NULL;
    dlist->beginRec = NULL;

    ASSERTOPENGL(dlist->namesArray == NULL, "Dlist namesArray not NULL\n");
    dlist->namesArray = __glNamesNewArray(gc, &dlistTypeInfo);
}

void FASTCALL __glFreeDlistState(__GLcontext *gc)
{
    __GLnamesArray *narray;

    narray = gc->dlist.namesArray;

    if (narray == NULL)
    {
        return;
    }
    
#ifdef NT_SERVER_SHARE_LISTS
    __glNamesLockArray(gc, narray);

    // Clean up any lists that this context may have locked
    DlReleaseLocks(gc);
#endif

    DBGLEVEL2(LEVEL_INFO, "Freeing dlists for %p, ref %d\n", gc,
              narray->refcount);

    narray->refcount--;
    if (narray->refcount == 0)
    {
        // NULL the array pointer first, preventing its reuse
        // after we unlock it.  We need to unlock before we free it
        // because the critical section will be cleaned up in the
        // free
        gc->dlist.namesArray = NULL;
	// Decrement dlist refcounts and free them if they reach 0
	__glNamesFreeArray(gc, narray);
    }
    else
    {
        __glNamesUnlockArray(gc, narray);
        gc->dlist.namesArray = NULL;
    }

    if (gc->dlist.listData != NULL)
    {
	// We were in the middle of compiling a display list when this
	// function is called!  Free the display list data.
        __glFreeDlist(gc, gc->dlist.listData);
        gc->dlist.listData = NULL;
        gc->dlist.currentList = 0;
    }
}

/******************************Public*Routine******************************\
*
* glsrvShareLists
*
* Server side implementation of wglShareLists
*
* History:
*  Tue Dec 13 17:14:18 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef NT_SERVER_SHARE_LISTS
ULONG APIENTRY glsrvShareLists(__GLcontext *gcShare, __GLcontext *gcSource)
{
    if (!__glCanShareDlist(gcShare, gcSource) ||
        !__glCanShareTextures(gcShare, gcSource))
    {
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        __glShareDlist(gcShare, gcSource);
        __glShareTextures(gcShare, gcSource);
        return ERROR_SUCCESS;
    }
}
#endif

/******************************Public*Routine******************************\
*
* __glDlistThreadCleanup
*
* Performs thread-exit cleanup for dlist state
*
* History:
*  Mon Dec 19 13:22:38 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef NT_SERVER_SHARE_LISTS

#if DBG
// Critical section check routine from usersrv
extern void APIENTRY CheckCritSectionOut(LPCRITICAL_SECTION pcs);
#endif

void __glDlistThreadCleanup(__GLcontext *gc)
{
#if DBG
    // Make sure we're not holding the display list critical section
    // We only hold this for short periods of time in our own code
    // so we should never be holding it unless we have bugs
    // In other words, it's ok to just assert this because no
    // client action can cause us to hold it
    CheckCritSectionOut(&gc->dlist.namesArray->critsec);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_list.c ===
/******************************Module*Header*******************************\
* Module Name: dl_list.c
*
* Display list management rountines.
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Basic display list routines.
**
*/
#include "precomp.h"
#pragma hdrstop

extern GLCLTPROCTABLE ListCompCltProcTable;
extern GLEXTPROCTABLE ListCompExtProcTable;

__GLdlist *__glShrinkDlist(__GLcontext *gc, __GLdlist *dlist);

// #define DL_HEAP_VERBOSE

#ifdef DL_HEAP_VERBOSE
int cbDlistTotal = 0;
extern ULONG glSize;

#ifdef DBG
#define GL_MSIZE(pv) _msize((BYTE *)(pv)-16)
#else
#define GL_MSIZE(pv) _msize(pv)
#endif
#endif

#if defined(DL_BLOCK_VERBOSE) || defined(DL_HEAP_VERBOSE)
#include "malloc.h"
#endif

/*
** Arbitrary limit for looking up multiple display lists at once 
** (with glCallLists()).  Any number from 128 to 1024 should work well.
** This value doesn't change the functionality of OpenGL at all, but
** will make minor variations to the performance characteristics.
*/
#define MAX_LISTS_CACHE 256

const GLubyte __GLdlsize_tab[] = {
      /* GL_BYTE		*/	1,
      /* GL_UNSIGNED_BYTE	*/	1,
      /* GL_SHORT		*/	2,
      /* GL_UNSIGNED_SHORT	*/	2,
      /* GL_INT			*/	4,
      /* GL_UNSIGNED_INT	*/	4,
      /* GL_FLOAT		*/	4,
      /* GL_2_BYTES		*/	2,
      /* GL_3_BYTES		*/	3,
      /* GL_4_BYTES		*/	4,
};

#define __glCallListsSize(type)				\
	((type) >= GL_BYTE && (type) <= GL_4_BYTES ?	\
	__GLdlsize_tab[(type)-GL_BYTE] : -1)

#define DL_LINK_SIZE            (sizeof(__GLlistExecFunc *)+sizeof(GLubyte *))
#define DL_TERMINATOR_SIZE      sizeof(GLubyte *)
#define DL_OVERHEAD             (offsetof(__GLdlist, head)+DL_LINK_SIZE+\
                                 DL_TERMINATOR_SIZE)

// This value should be a power of two
#define DL_BLOCK_SIZE           (256 * 1024)

// This value is chosen specifically to give the initial total size
// of the dlist an even block size
#define DL_INITIAL_SIZE         (DL_BLOCK_SIZE-DL_OVERHEAD)

// Skip to the next block in the display list block chain
const GLubyte * FASTCALL __glle_NextBlock(__GLcontext *gc, const GLubyte *PC)
{
#ifdef DL_BLOCK_VERBOSE
    DbgPrint("NextBlock: %08lX\n", *(const GLubyte * UNALIGNED64 *)PC);
#endif
    
    return *(const GLubyte * UNALIGNED64 *)PC;
}

/*
** Used to pad display list entries to double word boundaries where needed
** (for those few OpenGL commands which take double precision values).
*/
const GLubyte * FASTCALL __glle_Nop(__GLcontext *gc, const GLubyte *PC)
{
    return PC;
}

void APIENTRY
glcltNewList ( IN GLuint list, IN GLenum mode )
{
    __GLdlistMachine *dlstate;
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    dlstate = &gc->dlist;

    /* Valid mode? */
    switch(mode) {
      case GL_COMPILE:
      case GL_COMPILE_AND_EXECUTE:
	break;
      default:
	GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    if (dlstate->currentList) {
	/* Must call EndList before calling NewList again! */
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    if (list == 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

// If we are in COMPILE mode, we need to clear the command buffer,
// the poly array buffer, and the poly material buffer so that we
// can use them to compile poly array.  Otherwise, previously batched
// commands may be lost.

    if (mode == GL_COMPILE)
	glsbAttention();

    ASSERTOPENGL((DL_BLOCK_SIZE & (DL_BLOCK_SIZE-1)) == 0,
                 "DL_BLOCK_SIZE is not a power of two\n");
    ASSERTOPENGL(dlstate->listData == NULL,
                 "listData non-NULL in NewList\n");
    
    dlstate->listData = __glAllocDlist(gc, DL_INITIAL_SIZE);
    if (dlstate->listData == NULL)
    {
        GLSETERROR(GL_OUT_OF_MEMORY);
        return;
    }
    
    /*
    ** Save current client dispatch pointers into saved state in context.  Then
    ** switch to the list tables.
    */
    gc->savedCltProcTable.cEntries = ListCompCltProcTable.cEntries;
    gc->savedExtProcTable.cEntries = ListCompExtProcTable.cEntries;
    GetCltProcTable(&gc->savedCltProcTable, &gc->savedExtProcTable, FALSE);
    SetCltProcTable(&ListCompCltProcTable, &ListCompExtProcTable, FALSE);

    dlstate->currentList = list;
    dlstate->mode = mode;
    dlstate->nesting = 0;
#if 0
    dlstate->drawBuffer = GL_FALSE;
#endif
    dlstate->beginRec = NULL;

    (*dlstate->initState)(gc);
}

void APIENTRY
glcltEndList ( void )
{
    __GLdlistMachine *dlstate;
    __GLdlist *dlist;
    __GLdlist *newDlist;
    __GLdlist *prevDlist;
    GLubyte *allEnd;
    GLubyte *data;
    GLuint totalSize;
    GLuint currentList;
    POLYARRAY *pa;
    __GL_SETUP();

    pa = gc->paTeb;

    dlstate = &gc->dlist;

    /* Must call NewList() first! */
    if (dlstate->currentList == 0) {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// In COMPILE_AND_EXECUTE mode, EndList must not be called in Begin.
// In COMPILE mode, however, this flag should be clear (enforced in NewList)
// unless it was set in the poly array compilation code.

    if (dlstate->mode == GL_COMPILE_AND_EXECUTE &&
        pa->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

// If we are in the middle of compiling poly array, end the poly array
// compilation.

    if (gc->dlist.beginRec)
    {
	ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin!\n");

	gc->dlist.beginRec->flags |= DLIST_BEGIN_NO_MATCHING_END;

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);

	// Terminate poly array compilation
	gc->dlist.beginRec = NULL;
    }

// If we are in COMPILE mode, we need to reset the command buffer,
// the poly array buffer, and the poly material buffer.

    if (gc->dlist.mode == GL_COMPILE)
    {
	glsbResetBuffers(gc->dlist.beginRec ? TRUE : FALSE);

	// Clear begin flag too
        pa->flags &= ~POLYARRAY_IN_BEGIN;
    }

    dlist = dlstate->listData;
    
#if 0
    // Copy over the DrawBuffer flag
    dlist->drawBuffer = dlstate->drawBuffer;
#endif

    // Shrink this block to remove wasted space
    dlist = __glShrinkDlist(gc, dlist);

    // Remember the true end of the list
    allEnd = dlist->head+dlist->used;
    
    // Reverse the order of the list
    prevDlist = NULL;
    while (dlist->nextBlock != NULL)
    {
        newDlist = dlist->nextBlock;
        dlist->nextBlock = prevDlist;
        prevDlist = dlist;
        dlist = newDlist;
    }
    dlist->nextBlock = prevDlist;
    
    // Set the end pointer correctly
    dlist->end = allEnd;
    // Mark the end of the display list data with 0:
    *((DWORD *)dlist->end) = 0;

    dlstate->listData = NULL;

    currentList = dlstate->currentList;
    dlstate->currentList = 0;
    
#ifdef DL_HEAP_VERBOSE
    DbgPrint("Dlists using %8d, total %8d\n",
             cbDlistTotal, glSize);
#endif

#ifdef DL_BLOCK_VERBOSE
    DbgPrint("List %d: start %08lX, end %08lX\n", currentList,
             dlist->head, dlist->end);
    DbgPrint("Blocks at:");
    newDlist = dlist;
    while (newDlist != NULL)
    {
        DbgPrint(" %08lX:%d", newDlist, GL_MSIZE(newDlist));
        newDlist = newDlist->nextBlock;
    }
    DbgPrint("\n");
#endif

    // __glNamesNewData sets dlist refcount to 1.
    if (!__glNamesNewData(gc, gc->dlist.namesArray, currentList, dlist))
    {
	/* 
	** No memory!
	** Nuke the list! 
	*/
	__glFreeDlist(gc, dlist);
    }
    
    /* Switch back to saved dispatch state */
    SetCltProcTable(&gc->savedCltProcTable, &gc->savedExtProcTable, FALSE);
}

#ifdef NT_SERVER_SHARE_LISTS

/******************************Public*Routine******************************\
*
* DlLockLists
*
* Remember the locked lists for possible later cleanup
*
* History:
*  Mon Dec 12 18:58:32 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

// Number of locks to allocate when the lock list needs to grow
// Must be a power of two
#define DL_LOCK_LIST_BLOCK 32

GLboolean DlLockLists(__GLcontext *gc, GLsizei n, __GLdlist **dlists)
{
    DlLockArray *pdla;
    DlLockEntry *pdle;
    GLsizei nNewSize;

    pdla = &gc->dla;
    
    // Extend current lock array if needed
    if (pdla->nAllocated-pdla->nFilled < n)
    {
        // Round the needed size up to the block size
        nNewSize = (pdla->nAllocated+n+DL_LOCK_LIST_BLOCK-1) &
            ~(DL_LOCK_LIST_BLOCK-1);
        
        pdle = GCREALLOC(gc, pdla->pdleEntries, sizeof(DlLockEntry)*nNewSize);
        if (pdle == NULL)
        {
            return 0;
        }

        pdla->nAllocated = nNewSize;
        pdla->pdleEntries = pdle;
    }

    // We must have enough space now
    ASSERTOPENGL(pdla->nAllocated-pdla->nFilled >= n, "no enough space!\n");

    // Lock down dlists and remember them
    pdle = pdla->pdleEntries+pdla->nFilled;
    pdla->nFilled += n;
    
    while (n-- > 0)
    {
        pdle->dlist = *dlists;

        DBGLEVEL3(LEVEL_INFO, "Locked %p for %p, ref %d\n", *dlists, gc,
                  (*dlists)->refcount);
        
        dlists++;
        pdle++;
    }
    
    return (GLboolean) (pdla->nFilled != 0);	// return high water mark
}

/******************************Public*Routine******************************\
*
* DlUnlockLists
*
* Remove list lock entries.
*
* History:
*  Mon Dec 12 18:58:54 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DlUnlockLists(__GLcontext *gc, GLsizei n)
{
    DlLockArray *pdla;
    DlLockEntry *pdle;
    GLsizei i;
    __GLdlist *dlist;

// Since DlLockLists and DlUnlockLists are called in a recursive manner,
// we can simply decrement the filled count.

    pdla = &gc->dla;
    
    pdla->nFilled -= n;

    // Lock list doesn't shrink.  This would be fairly easy since realloc
    // is guaranteed not to fail when the memory block shrinks
    // Is this important?
}

/******************************Public*Routine******************************\
*
* DlReleaseLocks
*
* Releases any locks in the lock list and frees the lock list
*
* Must be executed under the dlist semaphore
*
* History:
*  Tue Dec 13 11:45:26 1994	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DlReleaseLocks(__GLcontext *gc)
{
    DlLockArray *pdla;
    DlLockEntry *pdle;

    __GL_NAMES_ASSERT_LOCKED(gc->dlist.namesArray);
    
    pdla = &gc->dla;

    DBGLEVEL3(LEVEL_INFO, "Cleaning up %p, locks %d (%d)\n", gc,
              pdla->nFilled, pdla->nAllocated);

    // Sanity check the counts
    ASSERTOPENGL(pdla->nFilled <= pdla->nAllocated, "bad nFilled!\n");
    
    pdle = pdla->pdleEntries;
    while (pdla->nFilled)
    {
	pdla->nFilled--;

// This function is called to clean up display list locks held by
// glCallList or glCallLists when it dies.  We need to release the
// locks here and free the dlists if their refcounts reach 0.
// The refcounts will reach 0 here only when the dlists were deleted
// by another thread while this thread was also holding the locks.

	__glDisposeDlist(gc, pdle->dlist);
	pdle++;
    }

    pdla->nAllocated = 0;
    if (pdla->pdleEntries)
    {
	GCFREE(gc, pdla->pdleEntries);
    }
}

#endif // NT_SERVER_SIDE

// If the a dlist was deleted by another thread while we have it locked,
// we need to free the dlist here.
void FASTCALL DlCleanup(__GLcontext *gc, void *pData)
{
    __glFreeDlist(gc, (__GLdlist *)pData);
}

void FASTCALL DoCallList(GLuint list)
{
    __GLdlist *dlist;
    __GLdlistMachine *dlstate;
    const GLubyte *end, *PC;
    __GLlistExecFunc *fp;
    __GL_SETUP();

    dlstate = &gc->dlist;

    if (dlstate->nesting >= __GL_MAX_LIST_NESTING) {
	/* Force unwinding of the display list */
	dlstate->nesting = __GL_MAX_LIST_NESTING*2;
	return;
    }

    /* Increment dlist refcount */
    dlist = __glNamesLockData(gc, gc->dlist.namesArray, list);

    /* No list, no action! */
    if (!dlist) {
	return;
    }

#ifdef NT_SERVER_SHARE_LISTS
    if (!DlLockLists(gc, 1, &dlist))
    {
	/* Decrement dlist refcount */
        __glNamesUnlockData(gc, (void *)dlist, DlCleanup);
	GLSETERROR(GL_OUT_OF_MEMORY);
        return;
    }
#endif
    
    dlstate->nesting++;

    end = dlist->end;
    PC = dlist->head;

    while (PC != end)
    {
	// Get the current function pointer.
	fp = *((__GLlistExecFunc * const UNALIGNED64 *) PC);

	// Execute the current function.  Return value is pointer to
	// next function/parameter block in the display list.

	PC = (*fp)(gc, PC+sizeof(__GLlistExecFunc * const *));
    }

    dlstate->nesting--;

    /* Decrement dlist refcount */
    // Will perform cleanup if necessary
    __glNamesUnlockData(gc, (void *)dlist, DlCleanup);
    
#ifdef NT_SERVER_SHARE_LISTS
    DlUnlockLists(gc, 1);
#endif
}

/*
** Display list compilation and execution versions of CallList and CallLists
** are maintained here for the sake of sanity.  Note that __glle_CallList
** may not call glcltCallList or it will break the infinite recursive
** display list prevention code.
*/
void APIENTRY
__gllc_CallList ( IN GLuint list )
{
    struct __gllc_CallList_Rec *data;
    __GL_SETUP();

    if (list == 0) {
	__gllc_InvalidValue();
	return;
    }

// It is extremely difficult to make CallList(s) work with poly array
// compilation.  For example, in the call sequence in COMPILE_AND_EXECUTE
// mode [Begin, TexCoord, CallList, Vertex, ...], it is difficult to record
// the partial POLYDATA in both COMPILE and COMPILE_AND_EXECUTE modes.
// That is, we may end up recording and playing back TexCoord twice in the
// above example.  As a result, we may have to stop building poly array in
// some cases.  Fortunately, this situation is rare.

    if (gc->dlist.beginRec)
    {
	gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_CALLLIST;

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);
    }

    data = (struct __gllc_CallList_Rec *)
        __glDlistAddOpUnaligned(gc,
                                DLIST_SIZE(sizeof(struct __gllc_CallList_Rec)),
                                DLIST_GENERIC_OP(CallList));
    if (data == NULL) return;
    data->list = list;
    __glDlistAppendOp(gc, data, __glle_CallList);

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

// In COMPILE_AND_EXECUTE mode, we can actually get out of the Begin mode.
// Although it is an application error, we need to terminate poly array
// compilation!

	if (!(pa->flags & POLYARRAY_IN_BEGIN))
	    gc->dlist.beginRec = NULL;
	else
	{
// If there is a partial vertex record after CallList(s), we will terminate
// the poly array compilation.  Otherwise, it is safe to continue the
// processing.

	    if (pa->pdNextVertex->flags)
	    {
		// Terminate poly array compilation
		gc->dlist.beginRec = NULL;

		if (gc->dlist.mode == GL_COMPILE)
		{
		    glsbResetBuffers(TRUE);

		    // Clear begin flag too
		    pa->flags &= ~POLYARRAY_IN_BEGIN;
		}

	    }
	}
    }
}

const GLubyte * FASTCALL __glle_CallList(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CallList_Rec *data;

    data = (struct __gllc_CallList_Rec *) PC;
    DoCallList(data->list);
    return PC + sizeof(struct __gllc_CallList_Rec);
}

void APIENTRY
glcltCallList ( IN GLuint list )
{
    __GL_SETUP();
    
    if (list == 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }

    gc->dlist.nesting = 0;
    DoCallList(list);
}

void FASTCALL DoCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
    __GLdlist *dlists[MAX_LISTS_CACHE];
    __GLdlist *dlist;
    __GLdlistMachine *dlstate;
    GLint i, dlcount, datasize;
    const GLubyte *listiter;
    const GLubyte *end, *PC;
    __GLlistExecFunc *fp;
    __GL_SETUP();

    dlstate = &gc->dlist;

    datasize = __glCallListsSize(type);

    if (dlstate->nesting >= __GL_MAX_LIST_NESTING) {
	/* Force unwinding of the display list */
	dlstate->nesting = __GL_MAX_LIST_NESTING*2;
	return;
    }
    dlstate->nesting++;

    listiter = (const GLubyte *) lists;
    while (n) {
	dlcount = n;
	if (dlcount > MAX_LISTS_CACHE) dlcount = MAX_LISTS_CACHE;

#ifdef NT_SERVER_SHARE_LISTS
        // Is there anything we can do here in the failure case besides
        // just skip the lists?  This is more or less consistent
        // with the behavior for not-found lists
        
	/* Increment dlist refcount */
	__glNamesLockDataList(gc, gc->dlist.namesArray, dlcount, type, 
                              gc->state.list.listBase, 
                              (const GLvoid *) listiter, (void **)dlists);

        if (!DlLockLists(gc, dlcount, dlists))
        {
	    /* Decrement dlist refcount */
            __glNamesUnlockDataList(gc, dlcount, (void **)dlists, DlCleanup);
	    GLSETERROR(GL_OUT_OF_MEMORY);
        }
        else
        {
#else
	__glNamesLockDataList(gc, gc->dlist.namesArray, dlcount, type, 
		gc->state.list.listBase, 
		(const GLvoid *) listiter, (void **)dlists);
#endif

	i = 0;
	while (i < dlcount) {
	    dlist = dlists[i];
	    end = dlist->end;
	    PC = dlist->head;
                     
	    while (PC != end)
	    {
		// Get the current function pointer.
		fp = *((__GLlistExecFunc * const UNALIGNED64 *) PC);

		// Execute the current function.  Return value is pointer to
		// next function/parameter block in the display list.

		PC = (*fp)(gc, PC+sizeof(__GLlistExecFunc * const *));
	    }
	    i++;
	}

	/* Decrement dlist refcount */
	// Will perform cleanup if necessary
	__glNamesUnlockDataList(gc, dlcount, (void **)dlists, DlCleanup);

#ifdef NT_SERVER_SHARE_LISTS
        DlUnlockLists(gc, dlcount);
        
        }
#endif

	listiter += dlcount * datasize;
	n -= dlcount;
    }

    dlstate->nesting--;
}

/*
** Display list compilation and execution versions of CallList and CallLists
** are maintained here for the sake of sanity.  Note that __glle_CallLists
** may not call glcltCallLists or it will break the infinite recursive
** display list prevention code.
*/
void APIENTRY
__gllc_CallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_CallLists_Rec *data;
    __GL_SETUP();

    if (n < 0) {
	__gllc_InvalidValue();
	return;
    }
    else if (n == 0) {
	return;
    }

// It is extremely difficult to make CallList(s) work with poly array
// compilation.  For example, in the call sequence in COMPILE_AND_EXECUTE
// mode [Begin, TexCoord, CallList, Vertex, ...], it is difficult to record
// the partial POLYDATA in both COMPILE and COMPILE_AND_EXECUTE modes.
// That is, we may end up recording and playing back TexCoord twice in the
// above example.  As a result, we may have to stop building poly array in
// some cases.  Fortunately, this situation is rare.

    if (gc->dlist.beginRec)
    {
	gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_CALLLIST;

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);
    }

    arraySize = __glCallListsSize(type)*n;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
#ifdef NT
    size = sizeof(struct __gllc_CallLists_Rec) + __GL_PAD(arraySize);
#else
    arraySize = __GL_PAD(arraySize);
    size = sizeof(struct __gllc_CallLists_Rec) + arraySize;
#endif
    data = (struct __gllc_CallLists_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size),
                                DLIST_GENERIC_OP(CallLists));
    if (data == NULL) return;
    data->n = n;
    data->type = type;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_CallLists_Rec),
		 lists, arraySize);
    __glDlistAppendOp(gc, data, __glle_CallLists);

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

// In COMPILE_AND_EXECUTE mode, we can actually get out of the Begin mode.
// Although it is an application error, we need to terminate poly array
// compilation!

	if (!(pa->flags & POLYARRAY_IN_BEGIN))
	    gc->dlist.beginRec = NULL;
	else
	{
// If there is a partial vertex record after CallList(s), we will terminate
// the poly array compilation.  Otherwise, it is safe to continue the
// processing.

	    if (pa->pdNextVertex->flags)
	    {
		// Terminate poly array compilation
		gc->dlist.beginRec = NULL;

		if (gc->dlist.mode == GL_COMPILE)
		{
		    glsbResetBuffers(TRUE);

		    // Clear begin flag too
		    pa->flags &= ~POLYARRAY_IN_BEGIN;
		}

	    }
	}
    }
}

const GLubyte * FASTCALL __glle_CallLists(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_CallLists_Rec *data;

    data = (struct __gllc_CallLists_Rec *) PC;
    DoCallLists(data->n, data->type, (GLvoid *) (data+1));
    arraySize = __GL_PAD(__glCallListsSize(data->type)*data->n);
    size = sizeof(struct __gllc_CallLists_Rec) + arraySize;
    return PC + size;
}

void APIENTRY
glcltCallLists ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists )
{
    __GL_SETUP();

    if (n < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }
    else if (n == 0) {
	return;
    }

    if ((GLint) __glCallListsSize(type) < 0) {
	GLSETERROR(GL_INVALID_ENUM);
	return;
    }

    gc->dlist.nesting = 0;
    DoCallLists(n, type, lists);
}

/************************************************************************/

// Expand a dlist
__GLdlist *__glDlistGrow(GLuint size)
{
    __GLdlist *dlist, *newDlist;
    GLubyte * UNALIGNED64 *op;
    __GL_SETUP();
        
    newDlist = __glAllocDlist(gc, size);
    if (newDlist == NULL)
    {
        GLSETERROR(GL_OUT_OF_MEMORY);
        return NULL;
    }

    // Add on record to link old block to new block
    dlist = gc->dlist.listData;

    op = (GLubyte **)(dlist->head+dlist->used);
    *(__GLlistExecFunc * UNALIGNED64 *)op = __glle_NextBlock;
    *(op+1) = newDlist->head;

    // Shrink old block down to remove any wasted space at the end of it
    dlist = __glShrinkDlist(gc, dlist);
    
    // Link new block into chain
    newDlist->nextBlock = dlist;
    gc->dlist.listData = newDlist;

    return newDlist;
}

// Shrink a dlist block down to the minimum size
// Guaranteed not to fail since we can always just use the overly
// large block if the realloc fails
// NOTE: This function should only be used during build time
// where the nextBlock links are in the opposite direction of
// the __glle_NextBlock link record links
__GLdlist *__glShrinkDlist(__GLcontext *gc, __GLdlist *dlist)
{
    __GLdlist *newDlist, *prevDlist;
    
// If the amount of unused space is small, don't bother shrinking the block.

    if (dlist->size - dlist->used < 4096)
	return dlist;

// If it is in COMPILE_AND_EXECUTE mode, flush the command buffer before
// reallocating listData.  Shrinking listData may invalidate the memory
// pointers placed in the command buffer by the the display list execution
// code.  When we are in the middle of building POLYARRAY, glsbAttention
// will not flush commands batched before the Begin call.  As a result,
// we also need to flush the command buffer before compiling the Begin call.

    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
	glsbAttention();

#ifdef DL_HEAP_VERBOSE
    cbDlistTotal -= GL_MSIZE(dlist);
#endif
    
    newDlist = (__GLdlist *)GCREALLOC(gc, dlist, dlist->used+DL_OVERHEAD);

    // If the realloc fails, just use the original list
    if (newDlist != NULL)
    {
        // If the realloc moved the block, fix up the link from the
        // previous block.  This should be relatively rare
        if (newDlist != dlist && newDlist->nextBlock != NULL)
        {
            prevDlist = newDlist->nextBlock;

            ASSERTOPENGL(*(__GLlistExecFunc * UNALIGNED64 *)
                         (prevDlist->head+prevDlist->used) == __glle_NextBlock,
                         "Link not found where expected\n");
            
            *(GLubyte * UNALIGNED64 *)(prevDlist->head+prevDlist->used+
                          sizeof(__GLlistExecFunc *)) = newDlist->head;
        }

	// If we are compiling the poly array record, we need to fix up
	// the Begin pointer!  Note that if beginRec is not in the moved
	// block, the pointer does not change!
        if (newDlist != dlist && gc->dlist.beginRec &&
	    (GLubyte *) gc->dlist.beginRec >= dlist->head &&
	    (GLubyte *) gc->dlist.beginRec <= dlist->head + dlist->used)
        {
	    gc->dlist.beginRec += newDlist->head - dlist->head;
        }
        
        dlist = newDlist;
        dlist->size = dlist->used;
    }

#ifdef DL_HEAP_VERBOSE
    cbDlistTotal += GL_MSIZE(dlist);
#endif
    
    return dlist;
}

__GLdlist *__glAllocDlist(__GLcontext *gc, GLuint size)
{
    __GLdlist *dlist;
    __GLdlist temp;
    GLuint memsize;

    // Add on overhead and round size to an even block
    memsize = (size+DL_OVERHEAD+DL_BLOCK_SIZE-1) & ~(DL_BLOCK_SIZE-1);
    // Check overflow
    if (memsize < size)
	return NULL;
    size = memsize-DL_OVERHEAD;

    dlist = (__GLdlist *)GCALLOC(gc, memsize);
    if (dlist == NULL)
        return NULL;
#if 0 // NT_SERVER_SHARE_LISTS
    dlist->refcount = 1;
#else
// refcount is set to 1 in __glNamesNewData.
    dlist->refcount = 0;
#endif
    dlist->size = size;
    dlist->used = 0;
    dlist->nextBlock = NULL;
    
#ifdef DL_HEAP_VERBOSE
    cbDlistTotal += GL_MSIZE(dlist);
#endif
    
    return dlist;
}

void FASTCALL __glFreeDlist(__GLcontext *gc, __GLdlist *dlist)
{
    __GLdlist *dlistNext;
    
#ifdef NT_SERVER_SHARE_LISTS
    if (dlist->refcount != 0)
    {
        WARNING2("dlist %p refcount on free is %d\n", dlist, dlist->refcount);
    }
#endif

    while (dlist != NULL)
    {
        dlistNext = dlist->nextBlock;

#ifdef DL_HEAP_VERBOSE
        cbDlistTotal -= GL_MSIZE(dlist);
#endif
        
        GCFREE(gc, dlist);
        dlist = dlistNext;
    }

#ifdef DL_HEAP_VERBOSE
    DbgPrint("Dlists using %8d, total %8d\n",
             cbDlistTotal, glSize);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_listc.c ===
/******************************Module*Header*******************************\
* Module Name: dl_listc.c (formerly soft\so_listc.c)
*
* Display list compilation routines.
*
* Created: 12-27-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/23 00:34:54 $
*/
#include "precomp.h"
#pragma hdrstop

/* Generic OpenGL Client using subbatching. */

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"
#include "subbatch.h"
#include "batchinf.h"

#include "image.h"            // __glFillImage and __glImageSize definitions

#include "listcomp.h"
#include "lcfuncs.h"
#include "dlist.h"
#include "dlistopt.h"
#include "glclt.h"

/*
** The code in here makes a lot of assumptions about the size of the 
** various user types (GLfloat, GLint, etcetra).  
*/

void APIENTRY
__gllc_Bitmap ( IN GLsizei width,
                IN GLsizei height,
                IN GLfloat xorig,
                IN GLfloat yorig,
                IN GLfloat xmove,
                IN GLfloat ymove,
                IN const GLubyte oldbits[]
              )
{
    __GLbitmap *bitmap;
    GLubyte *newbits;
    GLint imageSize;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }

    imageSize = height * ((width + 7) >> 3);
    imageSize = __GL_PAD(imageSize);

    bitmap = (__GLbitmap *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(imageSize + sizeof(__GLbitmap)),
                                DLIST_GENERIC_OP(Bitmap));
    if (bitmap == NULL) return;

    bitmap->width = width;
    bitmap->height = height;
    bitmap->xorig = xorig;
    bitmap->yorig = yorig;
    bitmap->xmove = xmove;
    bitmap->ymove = ymove;
    bitmap->imageSize = imageSize;

    newbits = (GLubyte *)bitmap + sizeof(__GLbitmap); 
    __glFillImage(gc, width, height, GL_COLOR_INDEX, GL_BITMAP, 
                  oldbits, newbits);

    __glDlistAppendOp(gc, bitmap, __glle_Bitmap);
}

const GLubyte * FASTCALL __glle_Bitmap(__GLcontext *gc, const GLubyte *PC)
{
    const __GLbitmap *bitmap;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    bitmap = (const __GLbitmap *) PC;
    GLCLIENT_BEGIN( Bitmap, BITMAP )
        pMsg->width     = bitmap->width  ;
        pMsg->height    = bitmap->height ;
        pMsg->xorig     = bitmap->xorig  ;
        pMsg->yorig     = bitmap->yorig  ;
        pMsg->xmove     = bitmap->xmove  ;
        pMsg->ymove     = bitmap->ymove  ;
        pMsg->bitmapOff = (ULONG_PTR) bitmap ;
        pMsg->_IsDlist  = GL_TRUE        ;
    GLCLIENT_END
    return PC + sizeof(__GLbitmap) + bitmap->imageSize;
}

void APIENTRY
__gllc_PolygonStipple ( const GLubyte *mask )
{
    void *data;
    __GL_SETUP();
    GLubyte *newbits;

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    newbits = (GLubyte *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(__glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP)),
                                DLIST_GENERIC_OP(PolygonStipple));
    if (newbits == NULL) return;

    __glFillImage(gc, 32, 32, GL_COLOR_INDEX, GL_BITMAP, mask, newbits);

    __glDlistAppendOp(gc, newbits, __glle_PolygonStipple);
}

const GLubyte * FASTCALL __glle_PolygonStipple(__GLcontext *gc, const GLubyte *PC)
{
// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    GLCLIENT_BEGIN( PolygonStipple, POLYGONSTIPPLE )
        pMsg->maskOff  = (ULONG_PTR) PC ;
        pMsg->_IsDlist = GL_TRUE    ;
    GLCLIENT_END
    return PC + __glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP);
}

void
__gllc_Map1_Internal ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const void *points , GLboolean bDouble )
{
    __GLmap1 *map1data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();
    
    k=__glEvalComputeK(target);
    if (k < 0) {
	    __gllc_InvalidEnum();
	    return;
    }

    if (order > gc->constants.maxEvalOrder || stride < k ||
	    order < 1 || u1 == u2) {
	    __gllc_InvalidValue();
	    return;
    }

    cmdsize = sizeof(__GLmap1) + 
	    __glMap1_size(k, order) * sizeof(__GLfloat);

    map1data = (__GLmap1 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map1));
    if (map1data == NULL) return;

    map1data->target = target;
    map1data->u1 = u1;
    map1data->u2 = u2;
    map1data->order = order;
    data = (__GLfloat *) ((GLubyte *)map1data + sizeof(__GLmap1));
    if (bDouble)
	    __glFillMap1d(k, order, stride, (const GLdouble *) points, data);
    else
	    __glFillMap1f(k, order, stride, (const GLfloat *) points, data);

    __glDlistAppendOp(gc, map1data, __glle_Map1);
}

void APIENTRY
__gllc_Map1f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] )
{
    __gllc_Map1_Internal(target, u1, u2, stride, order,
	(const void *) points, GL_FALSE);
}

void APIENTRY
__gllc_Map1d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] )
{
    __gllc_Map1_Internal(target, (GLfloat) u1, (GLfloat) u2, stride, order,
	(const void *) points, GL_TRUE);
}

const GLubyte * FASTCALL __glle_Map1(__GLcontext *gc, const GLubyte *PC)
{
    const __GLmap1 *map1data;
    GLint k, dataSize;
    __GLevaluator1 *ev;
    __GLfloat *gc_data;
    POLYARRAY *pa;

    map1data = (const __GLmap1 *) PC;
    k = __glEvalComputeK(map1data->target);
	dataSize = __glMap1_size(k, map1data->order) * sizeof(__GLfloat);

	// Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	    GLSETERROR(GL_INVALID_OPERATION);
        return PC + sizeof(__GLmap1) + dataSize;
    }

    ev = __glSetUpMap1 (gc, map1data->target, map1data->order, 
						map1data->u1, map1data->u2);
		
    if (ev != 0) 
	{
	    gc_data = gc->eval.eval1Data[__GL_EVAL1D_INDEX(map1data->target)];
		memcpy (gc_data, (GLfloat *) (PC + sizeof(__GLmap1)), dataSize);
	}

    return PC + sizeof(__GLmap1) + dataSize;
}

void
__gllc_Map2_Internal ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const void *points , GLboolean bDouble )
{
    __GLmap2 *map2data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();

    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum();
	return;
    }

    if (vorder > gc->constants.maxEvalOrder || vstride < k ||
	    vorder < 1 || u1 == u2 || ustride < k ||
	    uorder > gc->constants.maxEvalOrder || uorder < 1 ||
	    v1 == v2) {
	__gllc_InvalidValue();
	return;
    }

    cmdsize = sizeof(__GLmap2) + 
	    __glMap2_size(k, uorder, vorder) * sizeof(__GLfloat);

    map2data = (__GLmap2 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map2));
    if (map2data == NULL) return;

    map2data->target = target;
    map2data->u1 = u1;
    map2data->u2 = u2;
    map2data->uorder = uorder;
    map2data->v1 = v1;
    map2data->v2 = v2;
    map2data->vorder = vorder;

    data = (__GLfloat *) ((GLubyte *)map2data + sizeof(__GLmap2));
    if (bDouble)
	__glFillMap2d(k, uorder, vorder, ustride, vstride,
	    (const GLdouble *) points, data);
    else
	__glFillMap2f(k, uorder, vorder, ustride, vstride,
	    (const GLfloat *) points, data);

    __glDlistAppendOp(gc, map2data, __glle_Map2);
}

void APIENTRY
__gllc_Map2f ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] )
{
    __gllc_Map2_Internal(target, u1, u2, ustride, uorder,
	v1, v2, vstride, vorder, (const void *) points, GL_FALSE);
}

void APIENTRY
__gllc_Map2d ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] )
{
    __gllc_Map2_Internal(target, (GLfloat) u1, (GLfloat) u2, ustride, uorder,
	(GLfloat) v1, (GLfloat) v2, vstride, vorder, (const void *) points, GL_TRUE);
}

const GLubyte * FASTCALL __glle_Map2(__GLcontext *gc, const GLubyte *PC)
{
    const __GLmap2 *map2data;
    GLint k, dataSize;
    __GLevaluator2 *ev;
    __GLfloat *gc_data;
    POLYARRAY *pa;

    map2data = (const __GLmap2 *) PC;

    k = __glEvalComputeK (map2data->target);
	dataSize = __glMap2_size(k, map2data->uorder, map2data->vorder) * 
	                                                      sizeof(__GLfloat);
	// Check if it is called inside a Begin-End block
    // If we are already in the begin/end bracket, return an error.

    pa = GLTEB_CLTPOLYARRAY();
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	    GLSETERROR(GL_INVALID_OPERATION);
        return PC + sizeof(__GLmap2) + dataSize;
    }

    ev = __glSetUpMap2 (gc, map2data->target, 
						map2data->uorder, map2data->vorder,
						map2data->u1, map2data->u2, 
						map2data->v1, map2data->v2);
	
    if (ev != 0) 
	{
	    gc_data = gc->eval.eval2Data[__GL_EVAL2D_INDEX(map2data->target)];
		memcpy (gc_data, (GLfloat *) (PC + sizeof(__GLmap2)), dataSize);
	}
	
    return PC + sizeof(__GLmap2) + dataSize;
}


void APIENTRY
__gllc_DrawPixels ( IN GLsizei width,
                    IN GLsizei height,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                  )
{
    __GLdrawPixels *pixdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_DEPTH_COMPONENT:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    pixdata = (__GLdrawPixels *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLdrawPixels) + imageSize),
                                DLIST_GENERIC_OP(DrawPixels));
    if (pixdata == NULL) return;

    pixdata->width = width;
    pixdata->height = height;
    pixdata->format = format;
    pixdata->type = type;

    __glFillImage(gc, width, height, format, type, pixels, 
                  (GLubyte *)pixdata + sizeof(__GLdrawPixels));

    __glDlistAppendOp(gc, pixdata, __glle_DrawPixels);
}

const GLubyte * FASTCALL __glle_DrawPixels(__GLcontext *gc, const GLubyte *PC)
{
    const __GLdrawPixels *pixdata;
    GLint imageSize;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    pixdata = (const __GLdrawPixels *) PC;
    imageSize = __glImageSize(pixdata->width, pixdata->height, 
			      pixdata->format, pixdata->type);

    GLCLIENT_BEGIN( DrawPixels, DRAWPIXELS )
        pMsg->width     = pixdata->width      ;
        pMsg->height    = pixdata->height     ;
        pMsg->format    = pixdata->format     ;
        pMsg->type      = pixdata->type       ;
        pMsg->pixelsOff = (ULONG_PTR) (pixdata+1) ;
        pMsg->_IsDlist  = GL_TRUE             ;
    GLCLIENT_END
    return PC + sizeof(__GLdrawPixels) + __GL_PAD(imageSize);
}

void APIENTRY
__gllc_TexImage1D ( IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                  )
{
    __GLtexImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue();
	return;
    }
    if (width < 0) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    if (target == GL_PROXY_TEXTURE_1D) {
	glcltTexImage1D(target, level, components, width, border, format,
                        type, pixels);
	return;
    } else if (target != GL_TEXTURE_1D) {
	__gllc_InvalidEnum();
	return;
    } else if (pixels == NULL) {
        imageSize = 0;
    } else {
	imageSize = __glImageSize(width, 1, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage1D)+imageSize),
                                DLIST_GENERIC_OP(TexImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, width, 1, format, type, pixels, 
                      (GLubyte *)texdata + sizeof(__GLtexImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage1D);
}

void APIENTRY
__gllc_TexImage2D ( IN GLenum target,
                    IN GLint level,
                    IN GLint components,
                    IN GLsizei width,
                    IN GLsizei height,
                    IN GLint border,
                    IN GLenum format,
                    IN GLenum type,
                    IN const GLvoid *pixels
                  )
{
    __GLtexImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue();
	return;
    }
    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    if (target == GL_PROXY_TEXTURE_2D) {
        glcltTexImage2D(target, level, components, width, height, border,
                        format, type, pixels);
	return;
    } else if (target != GL_TEXTURE_2D) {
	__gllc_InvalidEnum();
	return;
    } else if (pixels == NULL) {
        imageSize = 0;
    } else {
        imageSize = __glImageSize(width, height, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->height = height;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, width, height, format, type, pixels, 
                      (GLubyte *) (GLubyte *)texdata + sizeof(__GLtexImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage2D);
}

const GLubyte * FASTCALL __glle_TexImage1D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexImage1D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexImage1D *) PC;
    GLCLIENT_BEGIN( TexImage1D, TEXIMAGE1D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->components    = data->components ;
        pMsg->width         = data->width      ;
        pMsg->border        = data->border     ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = data->imageSize > 0 ? (ULONG_PTR) (data+1) : 0;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexImage1D) + data->imageSize;
}

const GLubyte * FASTCALL __glle_TexImage2D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexImage2D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexImage2D *) PC;
    GLCLIENT_BEGIN( TexImage2D, TEXIMAGE2D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->components    = data->components ;
        pMsg->width         = data->width      ;
        pMsg->height        = data->height     ;
        pMsg->border        = data->border     ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = data->imageSize > 0 ? (ULONG_PTR) (data+1) : 0;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexImage2D) + data->imageSize;
}

void APIENTRY __gllc_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                   GLsizei width, GLenum format, GLenum type,
                                   const GLvoid *pixels)
{
    __GLtexSubImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if (width < 0) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    imageSize = __glImageSize(width, 1, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage1D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->width = width;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, 1, format, type, pixels, 
		(GLubyte *)texdata + sizeof(__GLtexSubImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage1D);
}

void APIENTRY __gllc_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                   GLint yoffset, GLsizei width, GLsizei height,
                                   GLenum format, GLenum type,
                                   const GLvoid *pixels)
{
    __GLtexSubImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

// Flush the command buffer before accessing server side gc states.

    glsbAttention();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue();
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum();
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum();
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->yoffset = yoffset;
    texdata->width = width;
    texdata->height = height;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, height, format, type, pixels, 
		(GLubyte *) texdata + sizeof(__GLtexSubImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage2D);
}

const GLubyte * FASTCALL __glle_TexSubImage1D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexSubImage1D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexSubImage1D *) PC;
    GLCLIENT_BEGIN( TexSubImage1D, TEXSUBIMAGE1D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->xoffset       = data->xoffset    ;
        pMsg->width         = data->width      ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = (ULONG_PTR) (data+1) ;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexSubImage1D) + data->imageSize;
}

const GLubyte * FASTCALL __glle_TexSubImage2D(__GLcontext *gc, const GLubyte *PC)
{
    const __GLtexSubImage2D *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLtexSubImage2D *) PC;
    GLCLIENT_BEGIN( TexSubImage2D, TEXSUBIMAGE2D )
        pMsg->target        = data->target     ;
        pMsg->level         = data->level      ;
        pMsg->xoffset       = data->xoffset    ;
        pMsg->yoffset       = data->yoffset    ;
        pMsg->width         = data->width      ;
        pMsg->height        = data->height     ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->pixelsOff     = (ULONG_PTR) (data+1) ;
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLtexSubImage2D) + data->imageSize;
}

GLint __gllc_CheckColorTableArgs(GLenum target, GLsizei count,
                                 GLenum format, GLenum type)
{
    GLint imageSize;
    
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
        __gllc_InvalidEnum();
        return -1;
    }

    switch (format)
    {
      case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
    default:
        __gllc_InvalidEnum();
        return -1;
    }
    
    if (target != GL_TEXTURE_1D && target != GL_TEXTURE_2D &&
        target != GL_PROXY_TEXTURE_1D && target != GL_PROXY_TEXTURE_2D)
    {
	__gllc_InvalidEnum();
	return -1;
    }
    else
    {
	imageSize = __glImageSize(count, 1, format, type);
    }
    imageSize = __GL_PAD(imageSize);
    return imageSize;
}

void APIENTRY
__gllc_ColorTableEXT ( IN GLenum target,
                       IN GLenum internalFormat,
                       IN GLsizei width,
                       IN GLenum format,
                       IN GLenum type,
                       IN const GLvoid *data
                     )
{
    __GLcolorTableEXT *record;
    GLint imageSize;
    __GL_SETUP();

    // Flush the command buffer before accessing server side gc states.
    glsbAttention();

    imageSize = __gllc_CheckColorTableArgs(target, width, format, type);
    if (imageSize < 0)
    {
        return;
    }

    switch(internalFormat)
    {
    case GL_RGB:		case 3:
    case GL_R3_G3_B2:		case GL_RGB4:
    case GL_RGB5:		case GL_RGB8:
    case GL_RGB10:	        case GL_RGB12:
    case GL_RGB16:
#ifdef GL_EXT_bgra
    case GL_BGR_EXT:
#endif
        break;
    case GL_RGBA:		case 4:
    case GL_RGBA2:	        case GL_RGBA4:
    case GL_RGBA8:              case GL_RGB5_A1:
    case GL_RGBA12:             case GL_RGBA16:
    case GL_RGB10_A2:
#ifdef GL_EXT_bgra
    case GL_BGRA_EXT:
#endif
        break;
    default:
        __gllc_InvalidEnum();
        return;
    }

    record = (__GLcolorTableEXT *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLcolorTableEXT)+imageSize),
                                DLIST_GENERIC_OP(ColorTableEXT));
    if (record == NULL) return;

    record->target = target;
    record->internalFormat = internalFormat;
    record->width = width;
    record->format = format;
    record->type = type;
    record->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, width, 1, format, type, data, 
                      (GLubyte *)record + sizeof(__GLcolorTableEXT));
    }

    __glDlistAppendOp(gc, record, __glle_ColorTableEXT);
}

const GLubyte * FASTCALL __glle_ColorTableEXT(__GLcontext *gc,
                                              const GLubyte *PC)
{
    const __GLcolorTableEXT *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLcolorTableEXT *) PC;
    GLCLIENT_BEGIN( ColorTableEXT, COLORTABLEEXT )
        pMsg->target        = data->target     ;
        pMsg->internalFormat = data->internalFormat;
        pMsg->width         = data->width      ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->data          = (const GLvoid *) (data+1);
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLcolorTableEXT) + data->imageSize;
}

void APIENTRY
__gllc_ColorSubTableEXT ( IN GLenum target,
                          IN GLsizei start,
                          IN GLsizei count,
                          IN GLenum format,
                          IN GLenum type,
                          IN const GLvoid *data
                          )
{
    __GLcolorSubTableEXT *record;
    GLint imageSize;
    __GL_SETUP();

    // Flush the command buffer before accessing server side gc states.
    glsbAttention();

    imageSize = __gllc_CheckColorTableArgs(target, count, format, type);
    if (imageSize < 0)
    {
        return;
    }

    record = (__GLcolorSubTableEXT *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLcolorSubTableEXT)+imageSize),
                                DLIST_GENERIC_OP(ColorSubTableEXT));
    if (record == NULL) return;

    record->target = target;
    record->start = start;
    record->count = count;
    record->format = format;
    record->type = type;
    record->imageSize = imageSize;

    if (imageSize > 0)
    {
        __glFillImage(gc, count, 1, format, type, data, 
                      (GLubyte *)record + sizeof(__GLcolorSubTableEXT));
    }

    __glDlistAppendOp(gc, record, __glle_ColorSubTableEXT);
}

const GLubyte * FASTCALL __glle_ColorSubTableEXT(__GLcontext *gc,
                                                 const GLubyte *PC)
{
    const __GLcolorSubTableEXT *data;

// Call the server side display list execute function.
// Batch the pointer here but we need to flush the command buffer before
// the memory is moved or modified!

    data = (const __GLcolorSubTableEXT *) PC;
    GLCLIENT_BEGIN( ColorSubTableEXT, COLORSUBTABLEEXT )
        pMsg->target        = data->target     ;
        pMsg->start         = data->start      ;
        pMsg->count         = data->count      ;
        pMsg->format        = data->format     ;
        pMsg->type          = data->type       ;
        pMsg->data          = (const GLvoid *) (data+1);
        pMsg->_IsDlist      = GL_TRUE          ;
    GLCLIENT_END
    return PC + sizeof(__GLcolorSubTableEXT) + data->imageSize;
}

#ifdef GL_WIN_multiple_textures
void APIENTRY __gllc_CurrentTextureIndexWIN
    (GLuint index)
{
    struct __gllc_CurrentTextureIndexWIN_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CurrentTextureIndexWIN_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CurrentTextureIndexWIN_Rec)),
                                DLIST_GENERIC_OP(CurrentTextureIndexWIN));
    if (data == NULL) return;
    data->index = index;
    __glDlistAppendOp(gc, data, __glle_CurrentTextureIndexWIN);
}

void APIENTRY __gllc_BindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture)
{
    struct __gllc_BindNthTextureWIN_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_BindNthTextureWIN_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_BindNthTextureWIN_Rec)),
                                DLIST_GENERIC_OP(BindNthTextureWIN));
    if (data == NULL) return;
    data->index = index;
    data->target = target;
    data->texture = texture;
    __glDlistAppendOp(gc, data, __glle_BindNthTextureWIN);
}

void APIENTRY __gllc_NthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
    struct __gllc_NthTexCombineFuncWIN_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_NthTexCombineFuncWIN_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_NthTexCombineFuncWIN_Rec)),
                                DLIST_GENERIC_OP(NthTexCombineFuncWIN));
    if (data == NULL) return;
    data->index = index;
    data->leftColorFactor = leftColorFactor;
    data->colorOp = colorOp;
    data->rightColorFactor = rightColorFactor;
    data->leftAlphaFactor = leftAlphaFactor;
    data->alphaOp = alphaOp;
    data->rightAlphaFactor = rightAlphaFactor;
    __glDlistAppendOp(gc, data, __glle_NthTexCombineFuncWIN);
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_lexec.c ===
/******************************Module*Header*******************************\
* Module Name: dl_lexec.c
*
* Display list execution routines.
*
* Created: 12-24-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/*
** Execution routines for display lists for all of the basic
** OpenGL commands.  These were automatically generated at one point, 
** but now the basic format has stabilized, and we make minor changes to
** individual routines from time to time.
*/

/***************************************************************************/
// Color functions.

const GLubyte * FASTCALL __glle_Color3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color3fv_Rec *data;

    data = (struct __gllc_Color3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor3fv)(data->v);
    return PC + sizeof(struct __gllc_Color3fv_Rec);
}

const GLubyte * FASTCALL __glle_Color3ubv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color3ubv_Rec *data;

    data = (struct __gllc_Color3ubv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor3ubv)(data->v);
    return PC + sizeof(struct __gllc_Color3ubv_Rec);
}

const GLubyte * FASTCALL __glle_Color4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color4fv_Rec *data;

    data = (struct __gllc_Color4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor4fv)(data->v);
    return PC + sizeof(struct __gllc_Color4fv_Rec);
}

const GLubyte * FASTCALL __glle_Color4ubv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Color4ubv_Rec *data;

    data = (struct __gllc_Color4ubv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColor4ubv)(data->v);
    return PC + sizeof(struct __gllc_Color4ubv_Rec);
}

/***************************************************************************/
// EdgeFlag function.

const GLubyte * FASTCALL __glle_EdgeFlag(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EdgeFlag_Rec *data;

    data = (struct __gllc_EdgeFlag_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEdgeFlag)(data->flag);
    return PC + sizeof(struct __gllc_EdgeFlag_Rec);
}

/***************************************************************************/
// Indexf function.

const GLubyte * FASTCALL __glle_Indexf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Indexf_Rec *data;

    data = (struct __gllc_Indexf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glIndexf)(data->c);
    return PC + sizeof(struct __gllc_Indexf_Rec);
}

/***************************************************************************/
// Normal functions.

const GLubyte * FASTCALL __glle_Normal3bv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Normal3bv_Rec *data;

    data = (struct __gllc_Normal3bv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glNormal3bv)(data->v);
    return PC + sizeof(struct __gllc_Normal3bv_Rec);
}

const GLubyte * FASTCALL __glle_Normal3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Normal3fv_Rec *data;

    data = (struct __gllc_Normal3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glNormal3fv)(data->v);
    return PC + sizeof(struct __gllc_Normal3fv_Rec);
}

/***************************************************************************/
// RasterPos functions.

const GLubyte * FASTCALL __glle_RasterPos2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_RasterPos2f_Rec *data;

    data = (struct __gllc_RasterPos2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRasterPos2f)(data->x, data->y);
    return PC + sizeof(struct __gllc_RasterPos2f_Rec);
}

const GLubyte * FASTCALL __glle_RasterPos3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_RasterPos3fv_Rec *data;

    data = (struct __gllc_RasterPos3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRasterPos3fv)(data->v);
    return PC + sizeof(struct __gllc_RasterPos3fv_Rec);
}

const GLubyte * FASTCALL __glle_RasterPos4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_RasterPos4fv_Rec *data;

    data = (struct __gllc_RasterPos4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRasterPos4fv)(data->v);
    return PC + sizeof(struct __gllc_RasterPos4fv_Rec);
}

/***************************************************************************/
// Rectf function.

const GLubyte * FASTCALL __glle_Rectf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Rectf_Rec *data;

    data = (struct __gllc_Rectf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRectf)(data->x1, data->y1, data->x2, data->y2);
    return PC + sizeof(struct __gllc_Rectf_Rec);
}

/***************************************************************************/
// TexCoord functions.

const GLubyte * FASTCALL __glle_TexCoord1f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord1f_Rec *data;

    data = (struct __gllc_TexCoord1f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord1f)(data->s);
    return PC + sizeof(struct __gllc_TexCoord1f_Rec);
}

const GLubyte * FASTCALL __glle_TexCoord2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord2f_Rec *data;

    data = (struct __gllc_TexCoord2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord2f)(data->s, data->t);
    return PC + sizeof(struct __gllc_TexCoord2f_Rec);
}

const GLubyte * FASTCALL __glle_TexCoord3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord3fv_Rec *data;

    data = (struct __gllc_TexCoord3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord3fv)(data->v);
    return PC + sizeof(struct __gllc_TexCoord3fv_Rec);
}

const GLubyte * FASTCALL __glle_TexCoord4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_TexCoord4fv_Rec *data;

    data = (struct __gllc_TexCoord4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexCoord4fv)(data->v);
    return PC + sizeof(struct __gllc_TexCoord4fv_Rec);
}

/***************************************************************************/
// Vertex functions.

const GLubyte * FASTCALL __glle_Vertex2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Vertex2f_Rec *data;

    data = (struct __gllc_Vertex2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glVertex2f)(data->x, data->y);
    return PC + sizeof(struct __gllc_Vertex2f_Rec);
}

const GLubyte * FASTCALL __glle_Vertex3fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Vertex3fv_Rec *data;

    data = (struct __gllc_Vertex3fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glVertex3fv)(data->v);
    return PC + sizeof(struct __gllc_Vertex3fv_Rec);
}

const GLubyte * FASTCALL __glle_Vertex4fv(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Vertex4fv_Rec *data;

    data = (struct __gllc_Vertex4fv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glVertex4fv)(data->v);
    return PC + sizeof(struct __gllc_Vertex4fv_Rec);
}

/***************************************************************************/
// Fogfv function.

const GLubyte * FASTCALL __glle_Fogfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_Fogfv_Rec *data;

    data = (struct __gllc_Fogfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glFogfv)(data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_Fogfv_Rec)));
    arraySize = __glFogfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_Fogfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// Lightfv function.

const GLubyte * FASTCALL __glle_Lightfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_Lightfv_Rec *data;

    data = (struct __gllc_Lightfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLightfv)(data->light, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_Lightfv_Rec)));
    arraySize = __glLightfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_Lightfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// LightModelfv function.

const GLubyte * FASTCALL __glle_LightModelfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_LightModelfv_Rec *data;

    data = (struct __gllc_LightModelfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLightModelfv)(data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_LightModelfv_Rec)));
    arraySize = __glLightModelfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_LightModelfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// Materialfv function.

const GLubyte * FASTCALL __glle_Materialfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_Materialfv_Rec *data;

    data = (struct __gllc_Materialfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMaterialfv)(data->face, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_Materialfv_Rec)));
    arraySize = __glMaterialfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_Materialfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// TexParameter functions.

const GLubyte * FASTCALL __glle_TexParameterfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexParameterfv_Rec *data;

    data = (struct __gllc_TexParameterfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexParameterfv)(data->target, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_TexParameterfv_Rec)));
    arraySize = __glTexParameterfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexParameterfv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_TexParameteriv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexParameteriv_Rec *data;

    data = (struct __gllc_TexParameteriv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexParameteriv)(data->target, data->pname, 
	    (GLint *) (PC + sizeof(struct __gllc_TexParameteriv_Rec)));
    arraySize = __glTexParameteriv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexParameteriv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// TexEnv functions.

const GLubyte * FASTCALL __glle_TexEnvfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexEnvfv_Rec *data;

    data = (struct __gllc_TexEnvfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexEnvfv)(data->target, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_TexEnvfv_Rec)));
    arraySize = __glTexEnvfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexEnvfv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_TexEnviv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexEnviv_Rec *data;

    data = (struct __gllc_TexEnviv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexEnviv)(data->target, data->pname, 
	    (GLint *) (PC + sizeof(struct __gllc_TexEnviv_Rec)));
    arraySize = __glTexEnviv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexEnviv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// TexGenfv function.

const GLubyte * FASTCALL __glle_TexGenfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_TexGenfv_Rec *data;

    data = (struct __gllc_TexGenfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTexGenfv)(data->coord, data->pname, 
	    (GLfloat *) (PC + sizeof(struct __gllc_TexGenfv_Rec)));
    arraySize = __glTexGenfv_size(data->pname) * 4;
    size = sizeof(struct __gllc_TexGenfv_Rec) + arraySize;
    return PC + size;
}

/***************************************************************************/
// MapGrid functions.

const GLubyte * FASTCALL __glle_MapGrid1f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MapGrid1f_Rec *data;

    data = (struct __gllc_MapGrid1f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMapGrid1f)(data->un, data->u1, data->u2);
    return PC + sizeof(struct __gllc_MapGrid1f_Rec);
}

const GLubyte * FASTCALL __glle_MapGrid2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MapGrid2f_Rec *data;

    data = (struct __gllc_MapGrid2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMapGrid2f)(data->un, data->u1, data->u2, data->vn, 
	    data->v1, data->v2);
    return PC + sizeof(struct __gllc_MapGrid2f_Rec);
}

/***************************************************************************/
// EvalCoord functions.

const GLubyte * FASTCALL __glle_EvalCoord1f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalCoord1f_Rec *data;

    data = (struct __gllc_EvalCoord1f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord1f)(data->u);
    return PC + sizeof(struct __gllc_EvalCoord1f_Rec);
}

const GLubyte * FASTCALL __glle_EvalCoord2f(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalCoord2f_Rec *data;

    data = (struct __gllc_EvalCoord2f_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord2f)(data->u, data->v);
    return PC + sizeof(struct __gllc_EvalCoord2f_Rec);
}

/***************************************************************************/
// LoadMatrixf function.

const GLubyte * FASTCALL __glle_LoadMatrixf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LoadMatrixf_Rec *data;

    data = (struct __gllc_LoadMatrixf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLoadMatrixf)(data->m);
    return PC + sizeof(struct __gllc_LoadMatrixf_Rec);
}

/***************************************************************************/
// MultMatrixf function.

const GLubyte * FASTCALL __glle_MultMatrixf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MultMatrixf_Rec *data;

    data = (struct __gllc_MultMatrixf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMultMatrixf)(data->m);
    return PC + sizeof(struct __gllc_MultMatrixf_Rec);
}

/***************************************************************************/
// Rotatef functions.

const GLubyte * FASTCALL __glle_Rotatef(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Rotatef_Rec *data;

    data = (struct __gllc_Rotatef_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glRotatef)(data->angle, data->x, data->y, data->z);
    return PC + sizeof(struct __gllc_Rotatef_Rec);
}

/***************************************************************************/
// Scalef functions.

const GLubyte * FASTCALL __glle_Scalef(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Scalef_Rec *data;

    data = (struct __gllc_Scalef_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glScalef)(data->x, data->y, data->z);
    return PC + sizeof(struct __gllc_Scalef_Rec);
}

/***************************************************************************/
// Translatef functions.

const GLubyte * FASTCALL __glle_Translatef(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Translatef_Rec *data;

    data = (struct __gllc_Translatef_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glTranslatef)(data->x, data->y, data->z);
    return PC + sizeof(struct __gllc_Translatef_Rec);
}

/***************************************************************************/
// Other functions.

const GLubyte * FASTCALL __glle_ListBase(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ListBase_Rec *data;

    data = (struct __gllc_ListBase_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glListBase)(data->base);
    return PC + sizeof(struct __gllc_ListBase_Rec);
}

const GLubyte * FASTCALL __glle_ClipPlane(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClipPlane_Rec *data;

    data = (struct __gllc_ClipPlane_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClipPlane)(data->plane, data->equation);
    return PC + sizeof(struct __gllc_ClipPlane_Rec);
}

const GLubyte * FASTCALL __glle_ColorMaterial(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ColorMaterial_Rec *data;

    data = (struct __gllc_ColorMaterial_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColorMaterial)(data->face, data->mode);
    return PC + sizeof(struct __gllc_ColorMaterial_Rec);
}

const GLubyte * FASTCALL __glle_CullFace(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CullFace_Rec *data;

    data = (struct __gllc_CullFace_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCullFace)(data->mode);
    return PC + sizeof(struct __gllc_CullFace_Rec);
}

const GLubyte * FASTCALL __glle_FrontFace(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_FrontFace_Rec *data;

    data = (struct __gllc_FrontFace_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glFrontFace)(data->mode);
    return PC + sizeof(struct __gllc_FrontFace_Rec);
}

const GLubyte * FASTCALL __glle_Hint(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Hint_Rec *data;

    data = (struct __gllc_Hint_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glHint)(data->target, data->mode);
    return PC + sizeof(struct __gllc_Hint_Rec);
}

const GLubyte * FASTCALL __glle_LineStipple(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LineStipple_Rec *data;

    data = (struct __gllc_LineStipple_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLineStipple)(data->factor, data->pattern);
    return PC + sizeof(struct __gllc_LineStipple_Rec);
}

const GLubyte * FASTCALL __glle_LineWidth(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LineWidth_Rec *data;

    data = (struct __gllc_LineWidth_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLineWidth)(data->width);
    return PC + sizeof(struct __gllc_LineWidth_Rec);
}

const GLubyte * FASTCALL __glle_PointSize(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PointSize_Rec *data;

    data = (struct __gllc_PointSize_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPointSize)(data->size);
    return PC + sizeof(struct __gllc_PointSize_Rec);
}

const GLubyte * FASTCALL __glle_PolygonMode(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PolygonMode_Rec *data;

    data = (struct __gllc_PolygonMode_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPolygonMode)(data->face, data->mode);
    return PC + sizeof(struct __gllc_PolygonMode_Rec);
}

const GLubyte * FASTCALL __glle_Scissor(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Scissor_Rec *data;

    data = (struct __gllc_Scissor_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glScissor)(data->x, data->y, data->width, data->height);
    return PC + sizeof(struct __gllc_Scissor_Rec);
}

const GLubyte * FASTCALL __glle_ShadeModel(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ShadeModel_Rec *data;

    data = (struct __gllc_ShadeModel_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glShadeModel)(data->mode);
    return PC + sizeof(struct __gllc_ShadeModel_Rec);
}

const GLubyte * FASTCALL __glle_InitNames(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glInitNames)();
    return PC;
}

const GLubyte * FASTCALL __glle_LoadName(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LoadName_Rec *data;

    data = (struct __gllc_LoadName_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLoadName)(data->name);
    return PC + sizeof(struct __gllc_LoadName_Rec);
}

const GLubyte * FASTCALL __glle_PassThrough(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PassThrough_Rec *data;

    data = (struct __gllc_PassThrough_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPassThrough)(data->token);
    return PC + sizeof(struct __gllc_PassThrough_Rec);
}

const GLubyte * FASTCALL __glle_PopName(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPopName)();
    return PC;
}

const GLubyte * FASTCALL __glle_PushName(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PushName_Rec *data;

    data = (struct __gllc_PushName_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPushName)(data->name);
    return PC + sizeof(struct __gllc_PushName_Rec);
}

const GLubyte * FASTCALL __glle_DrawBuffer(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DrawBuffer_Rec *data;

    data = (struct __gllc_DrawBuffer_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDrawBuffer)(data->mode);
    return PC + sizeof(struct __gllc_DrawBuffer_Rec);
}

const GLubyte * FASTCALL __glle_Clear(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Clear_Rec *data;

    data = (struct __gllc_Clear_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClear)(data->mask);
    return PC + sizeof(struct __gllc_Clear_Rec);
}

const GLubyte * FASTCALL __glle_ClearAccum(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearAccum_Rec *data;

    data = (struct __gllc_ClearAccum_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearAccum)(data->red, data->green, data->blue, data->alpha);
    return PC + sizeof(struct __gllc_ClearAccum_Rec);
}

const GLubyte * FASTCALL __glle_ClearIndex(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearIndex_Rec *data;

    data = (struct __gllc_ClearIndex_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearIndex)(data->c);
    return PC + sizeof(struct __gllc_ClearIndex_Rec);
}

const GLubyte * FASTCALL __glle_ClearColor(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearColor_Rec *data;

    data = (struct __gllc_ClearColor_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearColor)(data->red, data->green, data->blue, data->alpha);
    return PC + sizeof(struct __gllc_ClearColor_Rec);
}

const GLubyte * FASTCALL __glle_ClearStencil(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearStencil_Rec *data;

    data = (struct __gllc_ClearStencil_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearStencil)(data->s);
    return PC + sizeof(struct __gllc_ClearStencil_Rec);
}

const GLubyte * FASTCALL __glle_ClearDepth(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ClearDepth_Rec *data;

    data = (struct __gllc_ClearDepth_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glClearDepth)(data->depth);
    return PC + sizeof(struct __gllc_ClearDepth_Rec);
}

const GLubyte * FASTCALL __glle_StencilMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_StencilMask_Rec *data;

    data = (struct __gllc_StencilMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glStencilMask)(data->mask);
    return PC + sizeof(struct __gllc_StencilMask_Rec);
}

const GLubyte * FASTCALL __glle_ColorMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ColorMask_Rec *data;

    data = (struct __gllc_ColorMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glColorMask)(data->red, data->green, data->blue, data->alpha);
    return PC + sizeof(struct __gllc_ColorMask_Rec);
}

const GLubyte * FASTCALL __glle_DepthMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DepthMask_Rec *data;

    data = (struct __gllc_DepthMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDepthMask)(data->flag);
    return PC + sizeof(struct __gllc_DepthMask_Rec);
}

const GLubyte * FASTCALL __glle_IndexMask(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_IndexMask_Rec *data;

    data = (struct __gllc_IndexMask_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glIndexMask)(data->mask);
    return PC + sizeof(struct __gllc_IndexMask_Rec);
}

const GLubyte * FASTCALL __glle_Accum(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Accum_Rec *data;

    data = (struct __gllc_Accum_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glAccum)(data->op, data->value);
    return PC + sizeof(struct __gllc_Accum_Rec);
}

const GLubyte * FASTCALL __glle_Disable(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Disable_Rec *data;

    data = (struct __gllc_Disable_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDisable)(data->cap);
    return PC + sizeof(struct __gllc_Disable_Rec);
}

const GLubyte * FASTCALL __glle_Enable(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Enable_Rec *data;

    data = (struct __gllc_Enable_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEnable)(data->cap);
    return PC + sizeof(struct __gllc_Enable_Rec);
}

const GLubyte * FASTCALL __glle_PopAttrib(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPopAttrib)();
    return PC;
}

const GLubyte * FASTCALL __glle_PushAttrib(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PushAttrib_Rec *data;

    data = (struct __gllc_PushAttrib_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPushAttrib)(data->mask);
    return PC + sizeof(struct __gllc_PushAttrib_Rec);
}

const GLubyte * FASTCALL __glle_EvalMesh1(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalMesh1_Rec *data;

    data = (struct __gllc_EvalMesh1_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalMesh1)(data->mode, data->i1, data->i2);
    return PC + sizeof(struct __gllc_EvalMesh1_Rec);
}

const GLubyte * FASTCALL __glle_EvalPoint1(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalPoint1_Rec *data;

    data = (struct __gllc_EvalPoint1_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint1)(data->i);
    return PC + sizeof(struct __gllc_EvalPoint1_Rec);
}

const GLubyte * FASTCALL __glle_EvalMesh2(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalMesh2_Rec *data;

    data = (struct __gllc_EvalMesh2_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalMesh2)(data->mode, data->i1, data->i2, data->j1, 
	    data->j2);
    return PC + sizeof(struct __gllc_EvalMesh2_Rec);
}

const GLubyte * FASTCALL __glle_EvalPoint2(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_EvalPoint2_Rec *data;

    data = (struct __gllc_EvalPoint2_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint2)(data->i, data->j);
    return PC + sizeof(struct __gllc_EvalPoint2_Rec);
}

const GLubyte * FASTCALL __glle_AlphaFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_AlphaFunc_Rec *data;

    data = (struct __gllc_AlphaFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glAlphaFunc)(data->func, data->ref);
    return PC + sizeof(struct __gllc_AlphaFunc_Rec);
}

const GLubyte * FASTCALL __glle_BlendFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_BlendFunc_Rec *data;

    data = (struct __gllc_BlendFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glBlendFunc)(data->sfactor, data->dfactor);
    return PC + sizeof(struct __gllc_BlendFunc_Rec);
}

const GLubyte * FASTCALL __glle_LogicOp(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_LogicOp_Rec *data;

    data = (struct __gllc_LogicOp_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glLogicOp)(data->opcode);
    return PC + sizeof(struct __gllc_LogicOp_Rec);
}

const GLubyte * FASTCALL __glle_StencilFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_StencilFunc_Rec *data;

    data = (struct __gllc_StencilFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glStencilFunc)(data->func, data->ref, data->mask);
    return PC + sizeof(struct __gllc_StencilFunc_Rec);
}

const GLubyte * FASTCALL __glle_StencilOp(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_StencilOp_Rec *data;

    data = (struct __gllc_StencilOp_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glStencilOp)(data->fail, data->zfail, data->zpass);
    return PC + sizeof(struct __gllc_StencilOp_Rec);
}

const GLubyte * FASTCALL __glle_DepthFunc(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DepthFunc_Rec *data;

    data = (struct __gllc_DepthFunc_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDepthFunc)(data->func);
    return PC + sizeof(struct __gllc_DepthFunc_Rec);
}

const GLubyte * FASTCALL __glle_PixelZoom(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PixelZoom_Rec *data;

    data = (struct __gllc_PixelZoom_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelZoom)(data->xfactor, data->yfactor);
    return PC + sizeof(struct __gllc_PixelZoom_Rec);
}

const GLubyte * FASTCALL __glle_PixelTransferf(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PixelTransferf_Rec *data;

    data = (struct __gllc_PixelTransferf_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelTransferf)(data->pname, data->param);
    return PC + sizeof(struct __gllc_PixelTransferf_Rec);
}

const GLubyte * FASTCALL __glle_PixelTransferi(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PixelTransferi_Rec *data;

    data = (struct __gllc_PixelTransferi_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelTransferi)(data->pname, data->param);
    return PC + sizeof(struct __gllc_PixelTransferi_Rec);
}

const GLubyte * FASTCALL __glle_PixelMapfv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_PixelMapfv_Rec *data;

    data = (struct __gllc_PixelMapfv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelMapfv)(data->map, data->mapsize, 
	    (GLfloat *) (PC + sizeof(struct __gllc_PixelMapfv_Rec)));
    arraySize = data->mapsize * 4;
    size = sizeof(struct __gllc_PixelMapfv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_PixelMapuiv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_PixelMapuiv_Rec *data;

    data = (struct __gllc_PixelMapuiv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelMapuiv)(data->map, data->mapsize, 
	    (GLuint *) (PC + sizeof(struct __gllc_PixelMapuiv_Rec)));
    arraySize = data->mapsize * 4;
    size = sizeof(struct __gllc_PixelMapuiv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_PixelMapusv(__GLcontext *gc, const GLubyte *PC)
{
    GLuint size;
    GLuint arraySize;
    struct __gllc_PixelMapusv_Rec *data;

    data = (struct __gllc_PixelMapusv_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPixelMapusv)(data->map, data->mapsize, 
	    (GLushort *) (PC + sizeof(struct __gllc_PixelMapusv_Rec)));
    arraySize = __GL_PAD(data->mapsize * 2);
    size = sizeof(struct __gllc_PixelMapusv_Rec) + arraySize;
    return PC + size;
}

const GLubyte * FASTCALL __glle_ReadBuffer(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_ReadBuffer_Rec *data;

    data = (struct __gllc_ReadBuffer_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glReadBuffer)(data->mode);
    return PC + sizeof(struct __gllc_ReadBuffer_Rec);
}

const GLubyte * FASTCALL __glle_CopyPixels(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyPixels_Rec *data;

    data = (struct __gllc_CopyPixels_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyPixels)(data->x, data->y, data->width, data->height, 
	    data->type);
    return PC + sizeof(struct __gllc_CopyPixels_Rec);
}

const GLubyte * FASTCALL __glle_DepthRange(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DepthRange_Rec *data;

    data = (struct __gllc_DepthRange_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glDepthRange)(data->zNear, data->zFar);
    return PC + sizeof(struct __gllc_DepthRange_Rec);
}

const GLubyte * FASTCALL __glle_Frustum(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Frustum_Rec *data;

    data = (struct __gllc_Frustum_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glFrustum)(data->left, data->right, data->bottom, data->top, 
	    data->zNear, data->zFar);
    return PC + sizeof(struct __gllc_Frustum_Rec);
}

const GLubyte * FASTCALL __glle_LoadIdentity(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glLoadIdentity)();
    return PC;
}

const GLubyte * FASTCALL __glle_MatrixMode(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_MatrixMode_Rec *data;

    data = (struct __gllc_MatrixMode_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glMatrixMode)(data->mode);
    return PC + sizeof(struct __gllc_MatrixMode_Rec);
}

const GLubyte * FASTCALL __glle_Ortho(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Ortho_Rec *data;

    data = (struct __gllc_Ortho_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glOrtho)(data->left, data->right, data->bottom, data->top, 
	    data->zNear, data->zFar);
    return PC + sizeof(struct __gllc_Ortho_Rec);
}

const GLubyte * FASTCALL __glle_PopMatrix(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPopMatrix)();
    return PC;
}

const GLubyte * FASTCALL __glle_PushMatrix(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glPushMatrix)();
    return PC;
}

const GLubyte * FASTCALL __glle_Viewport(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_Viewport_Rec *data;

    data = (struct __gllc_Viewport_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glViewport)(data->x, data->y, data->width, data->height);
    return PC + sizeof(struct __gllc_Viewport_Rec);
}

const GLubyte * FASTCALL __glle_BindTexture(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_BindTexture_Rec *data;

    data = (struct __gllc_BindTexture_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glBindTexture)(data->target, data->texture);
    return PC + sizeof(struct __gllc_BindTexture_Rec);
}

const GLubyte * FASTCALL __glle_PrioritizeTextures(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PrioritizeTextures_Rec *data;

    data = (struct __gllc_PrioritizeTextures_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPrioritizeTextures)
        (data->n,
         (const GLuint *)(PC + sizeof(struct __gllc_PrioritizeTextures_Rec)),
         (const GLclampf *)(PC + sizeof(struct __gllc_PrioritizeTextures_Rec)+
                            data->n*sizeof(GLuint)));
    return PC + sizeof(struct __gllc_PrioritizeTextures_Rec) +
	    data->n*(sizeof(GLuint)+sizeof(GLclampf));
}

const GLubyte * FASTCALL __glle_CopyTexImage1D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexImage1D_Rec *data;

    data = (struct __gllc_CopyTexImage1D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexImage1D)(data->target, data->level, data->internalformat, data->x, data->y, data->width, data->border);
    return PC + sizeof(struct __gllc_CopyTexImage1D_Rec);
}

const GLubyte * FASTCALL __glle_CopyTexImage2D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexImage2D_Rec *data;

    data = (struct __gllc_CopyTexImage2D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexImage2D)(data->target, data->level, data->internalformat, data->x, data->y, data->width, data->height, data->border);
    return PC + sizeof(struct __gllc_CopyTexImage2D_Rec);
}

const GLubyte * FASTCALL __glle_CopyTexSubImage1D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexSubImage1D_Rec *data;

    data = (struct __gllc_CopyTexSubImage1D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexSubImage1D)(data->target, data->level, data->xoffset, data->x, data->y, data->width);
    return PC + sizeof(struct __gllc_CopyTexSubImage1D_Rec);
}

const GLubyte * FASTCALL __glle_CopyTexSubImage2D(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_CopyTexSubImage2D_Rec *data;

    data = (struct __gllc_CopyTexSubImage2D_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glCopyTexSubImage2D)(data->target, data->level, data->xoffset, data->yoffset, data->x, data->y, data->width, data->height);
    return PC + sizeof(struct __gllc_CopyTexSubImage2D_Rec);
}

const GLubyte * FASTCALL __glle_PolygonOffset(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_PolygonOffset_Rec *data;

    data = (struct __gllc_PolygonOffset_Rec *) PC;
    (*gc->savedCltProcTable.glDispatchTable.glPolygonOffset)(data->factor, data->units);
    return PC + sizeof(struct __gllc_PolygonOffset_Rec);
}

#ifdef GL_WIN_multiple_textures
const GLubyte * FASTCALL __glle_CurrentTextureIndexWIN(__GLcontext *gc,
                                                       const GLubyte *PC)
{
    struct __gllc_CurrentTextureIndexWIN_Rec *data;

    data = (struct __gllc_CurrentTextureIndexWIN_Rec *) PC;
    (*gc->savedExtProcTable.glDispatchTable.glCurrentTextureIndexWIN)
        (data->index);
    return PC + sizeof(struct __gllc_CurrentTextureIndexWIN_Rec);
}

const GLubyte * FASTCALL __glle_BindNthTextureWIN(__GLcontext *gc,
                                                  const GLubyte *PC)
{
    struct __gllc_BindNthTextureWIN_Rec *data;

    data = (struct __gllc_BindNthTextureWIN_Rec *) PC;
    (*gc->savedExtProcTable.glDispatchTable.glBindNthTextureWIN)
        (data->index, data->target, data->texture);
    return PC + sizeof(struct __gllc_BindNthTextureWIN_Rec);
}

const GLubyte * FASTCALL __glle_NthTexCombineFuncWIN(__GLcontext *gc,
                                                     const GLubyte *PC)
{
    struct __gllc_NthTexCombineFuncWIN_Rec *data;

    data = (struct __gllc_NthTexCombineFuncWIN_Rec *) PC;
    (*gc->savedExtProcTable.glDispatchTable.glNthTexCombineFuncWIN)
        (data->index, data->leftColorFactor, data->colorOp,
         data->rightColorFactor, data->leftAlphaFactor, data->alphaOp,
         data->leftAlphaFactor);
    return PC + sizeof(struct __gllc_NthTexCombineFuncWIN_Rec);
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_opt.c ===
/******************************Module*Header*******************************\
* Module Name: dl_opt.c
*
* Display list compilation error routines.
*
* Created: 12-24-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include "glclt.h"

void FASTCALL VA_ArrayElementCompile(__GLcontext *gc, GLint i);

/************************************************************************/

/*
** Optimized errors.  Strange but true.  These are called to save an error
** in the display list.
*/
void __gllc_InvalidValue()
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InvalidValue));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InvalidValue);
}

void __gllc_InvalidEnum()
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InvalidEnum));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InvalidEnum);
}

void __gllc_InvalidOperation()
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InvalidOperation));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InvalidOperation);
}

/*
** These routines execute an error stored in a display list.
*/
const GLubyte * FASTCALL __glle_InvalidValue(__GLcontext *gc, const GLubyte *PC)
{
    GLSETERROR(GL_INVALID_VALUE);
    return PC;
}

const GLubyte * FASTCALL __glle_InvalidEnum(__GLcontext *gc, const GLubyte *PC)
{
    GLSETERROR(GL_INVALID_ENUM);
    return PC;
}

const GLubyte * FASTCALL __glle_InvalidOperation(__GLcontext *gc, const GLubyte *PC)
{
    GLSETERROR(GL_INVALID_OPERATION);
    return PC;
}

/***************************************************************************/
// This function compiles a poly material structure.  It does not
// execute the record in COMPILE_AND_EXECUTE mode.  The execution is done
// when the poly array buffer is flushed.
void APIENTRY __gllc_PolyMaterial(GLuint faceName, __GLmatChange *pdMat)
{
    GLubyte *data, *data0;
    GLuint  dirtyBits;
    GLuint  size, newSize;
    __GL_SETUP();

    ASSERTOPENGL(faceName == POLYDATA_MATERIAL_FRONT ||
		 faceName == POLYDATA_MATERIAL_BACK, "bad faceName\n");

    // Allocate big enough record and resize it later
    size = sizeof(__GLmatChange) + sizeof(GLuint) + sizeof(GLuint);
    data = (GLubyte *) __glDlistAddOpUnaligned(gc, DLIST_SIZE(size),
		DLIST_GENERIC_OP(PolyMaterial));
    if (data == NULL) return;
    data0 = data;
    dirtyBits = pdMat->dirtyBits;

    // Skip size field to be filled in last
    ((GLuint *)data)++;

    // Record face name
    *((GLuint *) data)++ = faceName;

    *((GLuint *) data)++ = dirtyBits;

    if (dirtyBits & __GL_MATERIAL_AMBIENT)
	*((__GLcolor *) data)++ = pdMat->ambient;

    if (dirtyBits & __GL_MATERIAL_DIFFUSE)
	*((__GLcolor *) data)++ = pdMat->diffuse;

    if (dirtyBits & __GL_MATERIAL_SPECULAR)
	*((__GLcolor *) data)++ = pdMat->specular;

    if (dirtyBits & __GL_MATERIAL_EMISSIVE)
	*((__GLcolor *) data)++ = pdMat->emissive;

    if (dirtyBits & __GL_MATERIAL_SHININESS)
	*((__GLfloat *) data)++ = pdMat->shininess;

    if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
    {
	*((__GLfloat *) data)++ = pdMat->cmapa;
	*((__GLfloat *) data)++ = pdMat->cmapd;
	*((__GLfloat *) data)++ = pdMat->cmaps;
    }

    // Now fill in the size field
    newSize = (GLuint) (data - data0);
    *((GLuint *) data0) = newSize;

    // Resize the record
    __glDlistResizeCurrentOp(gc, DLIST_SIZE(size), DLIST_SIZE(newSize));
}

// Playback a PolyMaterial record in Begin.
const GLubyte * FASTCALL __glle_PolyMaterial(__GLcontext *gc, const GLubyte *PC)
{
    GLubyte   *data;
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLuint    size, faceName, dirtyBits;
    __GLmatChange *pdMat;
    POLYMATERIAL *pm;

    data = (GLubyte *) PC;

    size      = *((GLuint *) data)++;
    faceName  = *((GLuint *) data)++;
    dirtyBits = *((GLuint *) data)++;

    ASSERTOPENGL(faceName == POLYDATA_MATERIAL_FRONT ||
		 faceName == POLYDATA_MATERIAL_BACK, "bad faceName\n");

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
// Update pa flags POLYARRAY_MATERIAL_FRONT and POLYARRAY_MATERIAL_BACK.

	pa->flags |= faceName;

// Do front or back material for this vertex.
// Overwrite the previous material changes for this vertex if they exist since
// only the last material changes matter.

	pd = pa->pdNextVertex;

	// allocate __GLmatChange structure if this vertex hasn't got one
	if (!(pd->flags & faceName))
	{
	    if (!(pdMat = PAMatAlloc()))
		return PC + size;

	    // Get POLYMATERIAL pointer after PAMatAlloc!
	    pm = GLTEB_CLTPOLYMATERIAL();
	    if (faceName == POLYDATA_MATERIAL_FRONT)
		pm->pdMaterial0[pd - pa->pdBuffer0].front = pdMat;
	    else
		pm->pdMaterial0[pd - pa->pdBuffer0].back  = pdMat;

	    pdMat->dirtyBits = dirtyBits;
	}
	else
	{
	    pm = GLTEB_CLTPOLYMATERIAL();
	    if (faceName == POLYDATA_MATERIAL_FRONT)
		pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].front;
	    else
		pdMat = pm->pdMaterial0[pd - pa->pdBuffer0].back;

	    pdMat->dirtyBits |= dirtyBits;
	}

	if (dirtyBits & __GL_MATERIAL_AMBIENT)
	    pdMat->ambient = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_DIFFUSE)
	    pdMat->diffuse = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_SPECULAR)
	    pdMat->specular = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_EMISSIVE)
	    pdMat->emissive = *((__GLcolor *) data)++;

	if (dirtyBits & __GL_MATERIAL_SHININESS)
	    pdMat->shininess = *((__GLfloat *) data)++;

	if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
	{
	    pdMat->cmapa = *((__GLfloat *) data)++;
	    pdMat->cmapd = *((__GLfloat *) data)++;
	    pdMat->cmaps = *((__GLfloat *) data)++;
	}

// Finally, update pd flags

	pd->flags |= faceName;
    }
    else
    {
// Something went wrong at playback time!  We can either try to playback
// this record using the regular API or punt it altogether.  I cannot think
// of a situation when this can happen, so we will punt it for now.

	WARNING("Display list: playing back POLYMATERIAL outside BEGIN!\n");
    }

    return PC + size;
}

// Compile a PolyData structure in Begin.  If the poly data contains
// material changes, it will call __gllc_PolyMaterial to compile the material
// changes.  This function does not execute the record in COMPILE_AND_EXECUTE
// mode.  The execution is done when the poly array buffer is flushed.
void APIENTRY __glDlistCompilePolyData(__GLcontext *gc, GLboolean bPartial)
{
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLubyte *data, *data0;
    GLuint  pdflags;
    GLuint  size, newSize;
    __GLlistExecFunc *fp;

    ASSERTOPENGL(gc->dlist.beginRec, "not in being!\n");

// If we have already recorded it in PolyArrayFlushPartialPrimitive, skip it.

    if (gc->dlist.skipPolyData)
    {
	gc->dlist.skipPolyData = GL_FALSE;
	return;
    }

    pa = gc->paTeb;
    if (bPartial)
    {
	// Record only current attribute changes
	pd = pa->pdNextVertex;
	if (!pd->flags)
	    return;
    }
    else
    {
	pd = pa->pdNextVertex - 1;
    }

// Record material changes first.

    if (pd->flags & (POLYDATA_MATERIAL_FRONT | POLYDATA_MATERIAL_BACK))
    {
	POLYMATERIAL *pm;

	pm = GLTEB_CLTPOLYMATERIAL();

	if (pd->flags & POLYDATA_MATERIAL_FRONT)
	    __gllc_PolyMaterial(POLYDATA_MATERIAL_FRONT,
		pm->pdMaterial0[pd - pa->pdBuffer0].front);

	if (pd->flags & POLYDATA_MATERIAL_BACK)
	    __gllc_PolyMaterial(POLYDATA_MATERIAL_BACK,
		pm->pdMaterial0[pd - pa->pdBuffer0].back);

	if (bPartial)
	{
	    if (!(pd->flags & ~(POLYDATA_MATERIAL_FRONT | POLYDATA_MATERIAL_BACK)))
		return;
	}
    }

// Record POLYARRAY_CLAMP_COLOR flag in the begin record.

    if (pa->flags & POLYARRAY_CLAMP_COLOR)
	gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_CLAMP_COLOR;

// Make sure that we handle all the flags!

    ASSERTOPENGL(
    !(pd->flags &
      ~(POLYDATA_EDGEFLAG_BOUNDARY |
        POLYDATA_EDGEFLAG_VALID |
        POLYDATA_COLOR_VALID |
        POLYDATA_NORMAL_VALID |
        POLYDATA_TEXTURE_VALID |
        POLYDATA_VERTEX2 |
        POLYDATA_VERTEX3 |
        POLYDATA_VERTEX4 |
        POLYDATA_DLIST_COLOR_4 |
        POLYDATA_FOG_VALID   |
        POLYDATA_DLIST_TEXTURE1 |
        POLYDATA_DLIST_TEXTURE2 |
        POLYDATA_DLIST_TEXTURE3 |
        POLYDATA_DLIST_TEXTURE4 |
        POLYDATA_MATERIAL_FRONT |
        POLYDATA_MATERIAL_BACK)),
    "Unknown POLYDATA flags!\n");

// Get the flags that we are interested.

    pdflags = pd->flags &
	   (POLYDATA_EDGEFLAG_BOUNDARY |
	    POLYDATA_EDGEFLAG_VALID |
	    POLYDATA_COLOR_VALID |
	    POLYDATA_NORMAL_VALID |
	    POLYDATA_TEXTURE_VALID |
	    POLYDATA_VERTEX2 |
	    POLYDATA_VERTEX3 |
	    POLYDATA_VERTEX4 |
	    POLYDATA_DLIST_COLOR_4 |
	    POLYDATA_DLIST_TEXTURE1 |
	    POLYDATA_DLIST_TEXTURE2 |
	    POLYDATA_DLIST_TEXTURE3 |
	    POLYDATA_DLIST_TEXTURE4);

// Find out if it matches one of the following packed data structure for
// fast playback.
//   C3F_V3F
//   N3F_V3F
//   C3F_N3F_V3F (non 1.1 format)
//   C4F_N3F_V3F
//   T2F_V3F
//   T2F_C3F_V3F
//   T2F_N3F_V3F
//   T2F_C3F_N3F_V3F (non 1.1 format)
//   T2F_C4F_N3F_V3F

#define VTYPE_V2F	      (POLYDATA_VERTEX2)
#define VTYPE_V3F	      (POLYDATA_VERTEX3)
#define VTYPE_V4F	      (POLYDATA_VERTEX4)
#define VTYPE_C3F	      (POLYDATA_COLOR_VALID)
#define VTYPE_C4F	      (POLYDATA_COLOR_VALID | POLYDATA_DLIST_COLOR_4)
#define VTYPE_N3F	      (POLYDATA_NORMAL_VALID)
#define VTYPE_T2F	      (POLYDATA_TEXTURE_VALID | POLYDATA_DLIST_TEXTURE2)
#define VTYPE_C3F_V3F         (VTYPE_C3F | VTYPE_V3F)
#define VTYPE_N3F_V3F         (VTYPE_N3F | VTYPE_V3F)
#define VTYPE_C3F_N3F_V3F     (VTYPE_C3F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_C4F_N3F_V3F     (VTYPE_C4F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_T2F_V3F         (VTYPE_T2F | VTYPE_V3F)
#define VTYPE_T2F_C3F_V3F     (VTYPE_T2F | VTYPE_C3F | VTYPE_V3F)
#define VTYPE_T2F_N3F_V3F     (VTYPE_T2F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_T2F_C3F_N3F_V3F (VTYPE_T2F | VTYPE_C3F | VTYPE_N3F | VTYPE_V3F)
#define VTYPE_T2F_C4F_N3F_V3F (VTYPE_T2F | VTYPE_C4F | VTYPE_N3F | VTYPE_V3F)

    // Default playback routine
    fp = __glle_PolyData;

    if (!gc->modes.colorIndexMode &&
	!(pdflags & (POLYDATA_EDGEFLAG_BOUNDARY |
		     POLYDATA_EDGEFLAG_VALID)))
    {
	switch (pdflags)
	{
	  case VTYPE_V2F:
	  case VTYPE_V3F:
	  case VTYPE_V4F:
	    ASSERTOPENGL(gc->dlist.mode != GL_COMPILE,
		"should have been recorded as a Vertex call\n");
	    break;
	  case VTYPE_C3F_V3F:
	    fp = __glle_PolyData_C3F_V3F;
	    break;
	  case VTYPE_N3F_V3F:
            fp = __glle_PolyData_N3F_V3F;
	    break;
	  case VTYPE_C3F_N3F_V3F:
            fp = __glle_PolyData_C3F_N3F_V3F;
	    break;
	  case VTYPE_C4F_N3F_V3F:
            fp = __glle_PolyData_C4F_N3F_V3F;
	    break;
	  case VTYPE_T2F_V3F:
            fp = __glle_PolyData_T2F_V3F;
	    break;
	  case VTYPE_T2F_C3F_V3F:
            fp = __glle_PolyData_T2F_C3F_V3F;
	    break;
	  case VTYPE_T2F_N3F_V3F:
            fp = __glle_PolyData_T2F_N3F_V3F;
	    break;
	  case VTYPE_T2F_C3F_N3F_V3F:
            fp = __glle_PolyData_T2F_C3F_N3F_V3F;
	    break;
	  case VTYPE_T2F_C4F_N3F_V3F:
            fp = __glle_PolyData_T2F_C4F_N3F_V3F;
	    break;
	}
    }

// Allocate the dlist record.  Allocate big enough record and resize it later.

    size = sizeof(POLYDATA) + sizeof(GLuint);
    data = (GLubyte *) __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), fp);
    if (data == NULL) return;
    data0 = data;
  
// Increment vertex count.

    if (!bPartial)
	gc->dlist.beginRec->nVertices++;

// Compile the poly data record.
// The fast poly data records do not include size and flags fields.

    if (fp == __glle_PolyData)
    {
	// Skip size field to be filled in last
	((GLuint *) data)++;

	// flags and edge flag
	*((GLuint *) data)++ = pdflags;
    }

    // Texture coord
    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
		 | POLYDATA_DLIST_TEXTURE2 | POLYDATA_DLIST_TEXTURE1))
    {
	*((__GLfloat *) data)++ = pd->texture.x;
	if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
		     | POLYDATA_DLIST_TEXTURE2))
	{
	    *((__GLfloat *) data)++ = pd->texture.y;
	    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3))
	    {
		*((__GLfloat *) data)++ = pd->texture.z;
		if (pdflags & (POLYDATA_DLIST_TEXTURE4))
		    *((__GLfloat *) data)++ = pd->texture.w;
	    }
	}
    }

    // Color
    if (pdflags & POLYDATA_COLOR_VALID)
    {
	*((__GLfloat *) data)++ = pd->colors[0].r;
	if (!gc->modes.colorIndexMode)
	{
	    *((__GLfloat *) data)++ = pd->colors[0].g;
	    *((__GLfloat *) data)++ = pd->colors[0].b;
	    if (pdflags & POLYDATA_DLIST_COLOR_4)
		*((__GLfloat *) data)++ = pd->colors[0].a;
	}
    }

    // Normal
    if (pdflags & POLYDATA_NORMAL_VALID)
    {
	*((__GLfloat *) data)++ = pd->normal.x;
	*((__GLfloat *) data)++ = pd->normal.y;
	*((__GLfloat *) data)++ = pd->normal.z;
    }

    // Vertex, evalcoord1, evalcoord2, evapoint1, or evalpoint2
    if (pdflags & (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | POLYDATA_VERTEX4)) 
    {
	    ASSERTOPENGL(!bPartial, "vertex unexpected\n");
	    *((__GLfloat *) data)++ = pd->obj.x;
	    if (pdflags & (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
	    {
	        *((__GLfloat *) data)++ = pd->obj.y;
	        if (pdflags & (POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
	        {
		        *((__GLfloat *) data)++ = pd->obj.z;
		        if (pdflags & (POLYDATA_VERTEX4))
		            *((__GLfloat *) data)++ = pd->obj.w;
	        }
	    }
    }
    else
    {
	    ASSERTOPENGL(bPartial, "vertex expected\n");
    }

    // Now fill in the size field
    newSize = (GLuint) (data - data0);
    if (fp == __glle_PolyData)
	*((GLuint *) data0) = newSize;

    // Resize the record
    __glDlistResizeCurrentOp(gc, DLIST_SIZE(size), DLIST_SIZE(newSize));
}

#ifndef __GL_ASM_FAST_DLIST_PLAYBACK

// Define fast playback routines for PolyData records.
#define __GLLE_POLYDATA_C3F_V3F		1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_C3F_V3F
#define __GLLE_POLYDATA_N3F_V3F		1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_N3F_V3F
#define __GLLE_POLYDATA_C3F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_C3F_N3F_V3F
#define __GLLE_POLYDATA_C4F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_C4F_N3F_V3F
#define __GLLE_POLYDATA_T2F_V3F		1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_V3F
#define __GLLE_POLYDATA_T2F_C3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_C3F_V3F
#define __GLLE_POLYDATA_T2F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_N3F_V3F
#define __GLLE_POLYDATA_T2F_C3F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_C3F_N3F_V3F
#define __GLLE_POLYDATA_T2F_C4F_N3F_V3F	1
#include "dl_pdata.h"
#undef __GLLE_POLYDATA_T2F_C4F_N3F_V3F

#endif	// __GL_ASM_FAST_DLIST_PLAYBACK

// Playback a PolyData record in Begin.
const GLubyte * FASTCALL __glle_PolyData(__GLcontext *gc, const GLubyte *PC)
{
    GLubyte   *data;
    POLYARRAY *pa;
    POLYDATA  *pd;
    GLuint    size, pdflags;

    data = (GLubyte *) PC;

    size = *((GLuint *) data)++;

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	pdflags = *((GLuint *) data)++;

// Make sure that we handle all the flags!

	ASSERTOPENGL(
	    !(pdflags &
	      ~(POLYDATA_EDGEFLAG_BOUNDARY |
		POLYDATA_EDGEFLAG_VALID |
		POLYDATA_COLOR_VALID |
		POLYDATA_NORMAL_VALID |
		POLYDATA_TEXTURE_VALID |
		POLYDATA_VERTEX2 |
		POLYDATA_VERTEX3 |
		POLYDATA_VERTEX4 |
		POLYDATA_DLIST_COLOR_4 |
		POLYDATA_DLIST_TEXTURE1 |
		POLYDATA_DLIST_TEXTURE2 |
		POLYDATA_DLIST_TEXTURE3 |
		POLYDATA_DLIST_TEXTURE4)),
	    "Unknown POLYDATA flags!\n");

// Update pa flags.

	pa->flags |= pdflags &
		    (POLYARRAY_VERTEX2 | POLYARRAY_VERTEX3 | POLYARRAY_VERTEX4 |
		     POLYARRAY_TEXTURE1 | POLYARRAY_TEXTURE2 |
		     POLYARRAY_TEXTURE3 | POLYARRAY_TEXTURE4);

// Update pd attributes.

	pd = pa->pdNextVertex;
	pd->flags |= (pdflags & ~POLYDATA_EDGEFLAG_BOUNDARY);

	// Edge flag
	if (pdflags & POLYDATA_EDGEFLAG_VALID)
	{
	    // Clear the edge flag here since they may be a previous edge flag
	    pd->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
	    pd->flags |= pdflags;
	    pa->pdCurEdgeFlag = pd;
	}

	// Texture coord
	// We need to be careful here if it has 2 TexCoord calls with
	// different sizes.
	if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
		     | POLYDATA_DLIST_TEXTURE2 | POLYDATA_DLIST_TEXTURE1))
	{
	    pd->texture.x = *((__GLfloat *) data)++;
	    pa->pdCurTexture = pd;

	    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3
			 | POLYDATA_DLIST_TEXTURE2))
		pd->texture.y = *((__GLfloat *) data)++;
	    else
		pd->texture.y = __glZero;
	    if (pdflags & (POLYDATA_DLIST_TEXTURE4 | POLYDATA_DLIST_TEXTURE3))
		pd->texture.z = *((__GLfloat *) data)++;
	    else
		pd->texture.z = __glZero;
	    if (pdflags & (POLYDATA_DLIST_TEXTURE4))
		pd->texture.w = *((__GLfloat *) data)++;
	    else
		pd->texture.w = __glOne;
	}

	// Color
	if (pdflags & POLYDATA_COLOR_VALID)
	{
	    pd->color[0].r = *((__GLfloat *) data)++;
	    if (!gc->modes.colorIndexMode)
	    {
		pd->color[0].g = *((__GLfloat *) data)++;
		pd->color[0].b = *((__GLfloat *) data)++;
		if (pdflags & POLYDATA_DLIST_COLOR_4)
		    pd->color[0].a = *((__GLfloat *) data)++;
		else
		    pd->color[0].a = gc->alphaVertexScale;
	    }
	    pa->pdCurColor = pd;
	}

	// Normal
	if (pdflags & POLYDATA_NORMAL_VALID)
	{
	    pd->normal.x = *((__GLfloat *) data)++;
	    pd->normal.y = *((__GLfloat *) data)++;
	    pd->normal.z = *((__GLfloat *) data)++;
	    pa->pdCurNormal = pd;
	}

	// Vertex, evalcoord1, evalcoord2, evapoint1, or evalpoint2
	if (pdflags &
	    (POLYARRAY_VERTEX2 | POLYARRAY_VERTEX3 | POLYARRAY_VERTEX4))
	{
	    pd->obj.x = *((__GLfloat *) data)++;

	    if (pdflags & (POLYDATA_VERTEX2 | POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
		    pd->obj.y = *((__GLfloat *) data)++;
	    if (pdflags & (POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
		    pd->obj.z = *((__GLfloat *) data)++;
	    else
		    pd->obj.z = __glZero;
	    if (pdflags & (POLYDATA_VERTEX4))
		    pd->obj.w = *((__GLfloat *) data)++;
	    else
		    pd->obj.w = __glOne;

	    // Advance vertex pointer
	    pa->pdNextVertex++;
	    pd[1].flags = 0;

	    if (pd >= pa->pdFlush)
		    PolyArrayFlushPartialPrimitive();
	}
    }
    else
    {
// Something went wrong at playback time!  We can either try to playback
// this record using the regular API or punt it altogether.  I cannot think
// of a situation when this can happen, so we will punt it for now.

	WARNING("Display list: playing back POLYDATA outside BEGIN!\n");
    }

    return PC + size;
}

void APIENTRY __gllc_ArrayElement(GLint i)
{
    __GL_SETUP();

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

    VA_ArrayElementCompile(gc, i);
}

#define COMPILEARRAYPOINTER(ap, i) \
    ((*(ap).pfnCompile)((ap).pointer + (i) * (ap).ibytes))

void FASTCALL VA_ArrayElementCompile(__GLcontext *gc, GLint i)
{
    GLuint vaMask = gc->vertexArray.mask;

// Call the individual compilation routines.  They handle Begin mode,
// color mode, and COMPILE_AND_EXECUTE mode correctly.

    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
	COMPILEARRAYPOINTER(gc->vertexArray.edgeFlag, i);
    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.texCoord, i);
    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.color, i);
    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.index, i);
    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.normal, i);
    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
        COMPILEARRAYPOINTER(gc->vertexArray.vertex, i);
}

// Compile DrawArrays into Begin/End records.  Since Begin/End records
// contain optimized POLYDATA records, execution speed of these records
// is optimal.  However, it takes longer to compile this function using
// this approach.  But with this method, we don't have to deal with color
// mode and COMPILE_AND_EXECUTE mode here.
void APIENTRY __gllc_DrawArrays(GLenum mode, GLint first, GLsizei count)
{
    int i;
    POLYARRAY    *pa;
    __GL_SETUP();

    pa = gc->paTeb;

// Not allowed in begin/end.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	__gllc_InvalidOperation();
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
	__gllc_InvalidEnum();
	return;
    }

    if (count < 0)
    {
	__gllc_InvalidValue();
        return;
    } else if (!count)
        return;

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// Draw the array elements.

    __gllc_Begin(mode);
    gc->dlist.beginRec->flags |= DLIST_BEGIN_DRAWARRAYS;

    for (i = 0; i < count; i++)
	VA_ArrayElementCompile(gc, first + i);

    __gllc_End();
}

#define __GL_PAD8(x)    (((x) + 7) & ~7)

GLuint FASTCALL __glDrawElements_size(__GLcontext *gc, GLsizei nVertices,
    GLsizei nElements, struct __gllc_DrawElements_Rec *rec)
{
    GLuint size;
    GLuint vaMask;

// Compute the size of each of the six arrays.  Always keep size and address
// QWORD aligned since some arrays may use GLdouble.

    size = __GL_PAD8(sizeof(struct __gllc_DrawElements_Rec));
    vaMask = gc->vertexArray.mask;

    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
    {
	rec->edgeFlagOff = size;
	size += __GL_PAD8(nVertices * sizeof(GLboolean));
    }
    else
	rec->edgeFlagOff = 0;

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
    {
	rec->texCoordOff = size;
	size += __GL_PAD8(nVertices * gc->vertexArray.texCoord.size *
			  __GLTYPESIZE(gc->vertexArray.texCoord.type));
    }
    else
	rec->texCoordOff = 0;

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
    {
	rec->colorOff = size;
	size += __GL_PAD8(nVertices * gc->vertexArray.color.size *
			  __GLTYPESIZE(gc->vertexArray.color.type));
    }
    else
	rec->colorOff = 0;

    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
    {
	rec->indexOff = size;
	size += __GL_PAD8(nVertices * __GLTYPESIZE(gc->vertexArray.index.type));
    }
    else
	rec->indexOff = 0;

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
    {
	rec->normalOff = size;
	size += __GL_PAD8(nVertices * 3 *
			  __GLTYPESIZE(gc->vertexArray.normal.type));
    }
    else
	rec->normalOff = 0;

    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
    {
	rec->vertexOff = size;
	size += __GL_PAD8(nVertices * gc->vertexArray.vertex.size *
			  __GLTYPESIZE(gc->vertexArray.vertex.type));
    }
    else
	rec->vertexOff = 0;

    rec->mapOff = size;
    size += __GL_PAD8(nElements * sizeof(GLubyte));

    return(size);
}

void FASTCALL __gllc_ReducedElementsHandler(__GLcontext *gc,
                                            GLenum mode,
                                            GLsizei iVertexCount,
                                            GLsizei iVertexBase,
                                            VAMAP *pvmVertices,
                                            GLsizei iElementCount,
                                            GLubyte *pbElements,
                                            GLboolean fPartial)
{
    GLuint       vaMask;
    GLuint       size;
    GLubyte      *pv1, *pv2;
    GLsizei      stride;
    GLsizei      i;
    struct __gllc_DrawElements_Rec *data, drawElementsRec;

    ASSERTOPENGL(pvmVertices != NULL,
                 "__gllc_ReducedElementsHandler requires mapped vertices\n");
    
// Allocate the record.

    size = __glDrawElements_size(gc, iVertexCount, iElementCount,
                                 &drawElementsRec);
    data = (struct __gllc_DrawElements_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(size),
			      DLIST_GENERIC_OP(DrawElements));
    if (data == NULL)
    {
	return;
    }

#ifndef _IA64_
    ASSERTOPENGL((UINT_PTR) data == __GL_PAD8((UINT_PTR) data),
	"data not qword aligned\n");
#endif

    vaMask = gc->vertexArray.mask;
    
    data->mode        = mode;
    data->iElementCount = iElementCount;
    data->iVertexCount = iVertexCount;
    data->vaMask      = vaMask;
    data->partial     = fPartial;
    data->recSize     = size;
    data->edgeFlagOff = drawElementsRec.edgeFlagOff;
    data->texCoordOff = drawElementsRec.texCoordOff;
    data->indexOff    = drawElementsRec.indexOff;
    data->colorOff    = drawElementsRec.colorOff;
    data->normalOff   = drawElementsRec.normalOff;
    data->vertexOff   = drawElementsRec.vertexOff;
    data->mapOff      = drawElementsRec.mapOff;

// Record the vertex arrays.

// Note that iVertexBase parameter is not used, since all accesses here are
// 0-based.  It is there for function ptr compatibility with glcltReducedElementHandler
    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->edgeFlagOff];
	pv1    = (GLubyte *) gc->vertexArray.edgeFlag.pointer;
	stride = gc->vertexArray.edgeFlag.ibytes;

	for (i = 0; i < iVertexCount; i++)
	{
	    *((GLboolean *) pv2) = *((GLboolean *)
                                     (pv1 + pvmVertices[i].iIn * stride));
	    pv2 += sizeof(GLboolean);
	}
    }

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->texCoordOff];
	size   = gc->vertexArray.texCoord.size *
	         __GLTYPESIZE(gc->vertexArray.texCoord.type);
	pv1    = (GLubyte *) gc->vertexArray.texCoord.pointer;
	stride = gc->vertexArray.texCoord.ibytes;
	data->texCoordSize = gc->vertexArray.texCoord.size;
	data->texCoordType = gc->vertexArray.texCoord.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->colorOff];
	size   = gc->vertexArray.color.size *
	         __GLTYPESIZE(gc->vertexArray.color.type);
	pv1    = (GLubyte *) gc->vertexArray.color.pointer;
	stride = gc->vertexArray.color.ibytes;
	data->colorSize = gc->vertexArray.color.size;
	data->colorType = gc->vertexArray.color.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->indexOff];
	size   = __GLTYPESIZE(gc->vertexArray.index.type);
	pv1    = (GLubyte *) gc->vertexArray.index.pointer;
	stride = gc->vertexArray.index.ibytes;
	data->indexType = gc->vertexArray.index.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->normalOff];
	size   = 3 * __GLTYPESIZE(gc->vertexArray.normal.type);
	pv1    = (GLubyte *) gc->vertexArray.normal.pointer;
	stride = gc->vertexArray.normal.ibytes;
	data->normalType = gc->vertexArray.normal.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
    {
	pv2    = &((GLubyte *) data)[data->vertexOff];
	size   = gc->vertexArray.vertex.size *
	         __GLTYPESIZE(gc->vertexArray.vertex.type);
	pv1    = (GLubyte *) gc->vertexArray.vertex.pointer;
	stride = gc->vertexArray.vertex.ibytes;
	data->vertexSize = gc->vertexArray.vertex.size;
	data->vertexType = gc->vertexArray.vertex.type;

	for (i = 0; i < iVertexCount; i++)
	{
	    memcpy(pv2, pv1 + pvmVertices[i].iIn * stride, size);
	    pv2 += size;
	}
    }

// Record new index mapping array.

    pv2 = &((GLubyte *) data)[data->mapOff];
    memcpy(pv2, pbElements, iElementCount*sizeof(GLubyte));

    __glDlistAppendOp(gc, data, __glle_DrawElements);
}

void APIENTRY __gllc_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *pIn)
{
    POLYARRAY    *pa;
    GLuint       iIn;
    GLsizei      iCount;
    struct __gllc_DrawElementsBegin_Rec *dataBegin;

    __GL_SETUP();

// Flush the cached memory pointers if we are in COMPILE_AND_EXECUTE mode.
// See __glShrinkDlist for details.

    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
	glsbAttention();

    pa = gc->paTeb;

// If we are already in the begin/end bracket, return an error.

    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	__gllc_InvalidOperation();
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
	__gllc_InvalidEnum();
	return;
    }

    if (count < 0)
    {
	__gllc_InvalidValue();
        return;
    } else if (!count)
        return;

    switch (type)
    {
      case GL_UNSIGNED_BYTE:
      case GL_UNSIGNED_SHORT:
      case GL_UNSIGNED_INT:
	break;
      default:
	__gllc_InvalidEnum();
        return;
    }

// Find array element function to use.

    if (gc->vertexArray.flags & __GL_VERTEX_ARRAY_DIRTY)
	VA_ValidateArrayPointers(gc);

// Convert Points, Line Loop and Polygon to DrawArrays call.  Points and Polygon
// don't benefit from optimization in this function.  Further, Polygon and
// Line Loop are too tricky to deal with in this function.

    if (mode == GL_POINTS || mode == GL_LINE_LOOP || mode == GL_POLYGON)
    {
	__gllc_Begin(mode);
	gc->dlist.beginRec->flags |= DLIST_BEGIN_DRAWARRAYS;

	for (iCount = 0; iCount < count; iCount++)
	{
	    // Get next input index.
	    if (type == GL_UNSIGNED_BYTE)
		iIn = (GLuint) ((GLubyte *)  pIn)[iCount];
	    else if (type == GL_UNSIGNED_SHORT)
		iIn = (GLuint) ((GLushort *) pIn)[iCount];
	    else
		iIn = (GLuint) ((GLuint *)   pIn)[iCount];

	    VA_ArrayElementCompile(gc, iIn);
	}

	__gllc_End();
	return;
    }

    // Allocate begin record
    dataBegin = (struct __gllc_DrawElementsBegin_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DrawElementsBegin_Rec)),
                                DLIST_GENERIC_OP(DrawElementsBegin));
    if (dataBegin == NULL)
    {
	return;
    }

    dataBegin->mode = mode;
    dataBegin->count = min(count, VA_DRAWELEM_MAP_SIZE);
    dataBegin->vaMask = gc->vertexArray.mask;
        
    __glDlistAppendOp(gc, dataBegin, __glle_DrawElementsBegin);

    // Reduce input data into easily processed chunks
    ReduceDrawElements(gc, mode, count, type, pIn,
                       __gllc_ReducedElementsHandler);
}

const GLubyte * FASTCALL __glle_DrawElementsBegin(__GLcontext *gc, const GLubyte *PC)
{
    struct __gllc_DrawElementsBegin_Rec *data;

// Not allowed in begin/end.

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
        // Mark saved state as invalid
        gc->savedVertexArray.flags = 0xffffffff;
	goto __glle_DrawElementsBegin_exit;
    }

    data = (struct __gllc_DrawElementsBegin_Rec *) PC;

// Save vertex array states.

    gc->savedVertexArray = gc->vertexArray;

// Set up temporary vertex arrays.
// By setting up the mask value in gc, we don't need to call EnableClientState
// and DisableClientState.  We still need to set up pointers for the enabled
// arrays.

    gc->vertexArray.mask = data->vaMask;
    // Force validation since we just completely changed the vertex array
    // enable state
    VA_ValidateArrayPointers(gc);

    // Begin primitive
    VA_DrawElementsBegin(gc->paTeb, data->mode, data->count);
    
__glle_DrawElementsBegin_exit:
    return PC + sizeof(struct __gllc_DrawElementsBegin_Rec);
}

void APIENTRY __gllc_DrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *pIn)
{
    // !!! Currently we call the DrawElements function here when in lc mode.  
    // If compile time performance for DrawRangeElements becomes an issue, then
    // we can flesh out this function.
    __gllc_DrawElements( mode, count, type, pIn );
}

const GLubyte * FASTCALL __glle_DrawElements(__GLcontext *gc, const GLubyte *PC)
{
    GLuint vaMask;
    POLYARRAY *pa;
    struct __gllc_DrawElements_Rec *data;

    data = (struct __gllc_DrawElements_Rec *) PC;
    pa = gc->paTeb;
    
// Must be in begin since DrawElementsBegin has started the primitive

    // Must use the client side begin state
    if ((pa->flags & POLYARRAY_IN_BEGIN) == 0 ||
        gc->savedVertexArray.flags == 0xffffffff)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	goto __glle_DrawElements_exit;
    }

    vaMask = data->vaMask;

// Set up temporary vertex arrays.
// We need to temporarily mask off the begin flag so that these
// calls can succeed.  We probably want to do something smarter
// that avoids parameter validation but this is good enough for now
// Note that in immediate mode, the array function pointers are set up
// once in __glle_DrawElementsBegin and remain unchanged until all
// sub-batches are processed.  In COMPILE_AND_EXECUTE mode, the array
// function pointers are also set up once in __glle_DrawElementsBegin.
// Since these function pointers are the same for compilation and
// execution, we don't need to re-validate them for each sub-batch here.

    pa->flags ^= POLYARRAY_IN_BEGIN;
    
    if (vaMask & VAMASK_EDGEFLAG_ENABLE_MASK)
        glcltEdgeFlagPointer(0, &((GLubyte *) data)[data->edgeFlagOff]);

    if (vaMask & VAMASK_TEXCOORD_ENABLE_MASK)
        glcltTexCoordPointer(data->texCoordSize, data->texCoordType,
	    0, &((GLubyte *) data)[data->texCoordOff]);

    if (vaMask & VAMASK_COLOR_ENABLE_MASK)
        glcltColorPointer(data->colorSize, data->colorType,
	    0, &((GLubyte *) data)[data->colorOff]);

    if (vaMask & VAMASK_INDEX_ENABLE_MASK)
        glcltIndexPointer(data->indexType,
	    0, &((GLubyte *) data)[data->indexOff]);

    if (vaMask & VAMASK_NORMAL_ENABLE_MASK)
        glcltNormalPointer(data->normalType,
	    0, &((GLubyte *) data)[data->normalOff]);

    if (vaMask & VAMASK_VERTEX_ENABLE_MASK)
        glcltVertexPointer(data->vertexSize, data->vertexType,
	    0, &((GLubyte *) data)[data->vertexOff]);

    pa->flags ^= POLYARRAY_IN_BEGIN;
    
    // Call immediate mode chunk handler
    glcltReducedElementsHandler(gc, data->mode,
                                data->iVertexCount, 0, NULL,
                                data->iElementCount,
                                (GLubyte *)data+data->mapOff,
                                data->partial);

// Restore vertex array states in the following conditions:
// 1. The DrawElements record is completed
// 2. It is in COMPILE_AND_EXECUTE mode and it is not called as a result
//    of executing a CallList record.  That is, the record is being
//    compile *and* executed at the same time.

    if ((!data->partial) ||
	((gc->dlist.mode == GL_COMPILE_AND_EXECUTE) && !gc->dlist.nesting))
    {
        gc->vertexArray = gc->savedVertexArray;
    }

__glle_DrawElements_exit:
    return PC + data->recSize;
}

void APIENTRY
__gllc_Begin ( IN GLenum mode )
{
    POLYARRAY *pa;
    struct __gllc_Begin_Rec *data;
    __GL_SETUP();

// Flush the cached memory pointers if we are in COMPILE_AND_EXECUTE mode.
// See __glShrinkDlist for details.

    if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE)
	glsbAttention();

// If we are already in the begin/end bracket, return an error.

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
	__gllc_InvalidOperation();
	return;
    }

    if ((GLuint) mode > GL_POLYGON)
    {
	__gllc_InvalidEnum();
	return;
    }

// Add the Begin record.

    data = (struct __gllc_Begin_Rec *)
        __glDlistAddOpUnaligned(gc,
                                DLIST_SIZE(sizeof(struct __gllc_Begin_Rec)),
                                DLIST_GENERIC_OP(Begin));
    if (data == NULL) return;
    data->mode = mode;
    data->flags = 0;
    data->nVertices = 0;

    gc->dlist.skipPolyData = GL_FALSE;

// Use poly array code to compile the data structure for this primitive.

    (*gc->savedCltProcTable.glDispatchTable.glBegin)(mode);

// Save the Begin record pointer.  We are now compiling the poly array
// primitive.  It is set to NULL in End.

    gc->dlist.beginRec = data;
}

const GLubyte * FASTCALL __glle_Begin(__GLcontext *gc, const GLubyte *PC)
{
    POLYARRAY *pa;
    struct __gllc_Begin_Rec *data;

    data = (struct __gllc_Begin_Rec *) PC;

    pa = gc->paTeb;

    // try not to break the poly data records into batches!  The number 8
    // is loosely chosen to allow for the poly array entry, the reserved
    // polygon entries, and the flush limit.  At worst, it causes an
    // unnecessary attention!
    if (data->nVertices <= (GLint) gc->vertex.pdBufSize - 8
     && data->nVertices >= (GLint) (pa->pdBufferMax - pa->pdBufferNext + 1 - 8))
	glsbAttention();

    // call glcltBegin first
    (*gc->savedCltProcTable.glDispatchTable.glBegin)(data->mode);
    if (data->flags & DLIST_BEGIN_DRAWARRAYS)
	pa->flags |= POLYARRAY_SAME_POLYDATA_TYPE;

// Set POLYARRAY_CLAMP_COLOR flag.

    if (data->flags & DLIST_BEGIN_HAS_CLAMP_COLOR)
	pa->flags |= POLYARRAY_CLAMP_COLOR;

    // handle "otherColor"
    if (data->flags & DLIST_BEGIN_HAS_OTHER_COLOR)
    {
	if (gc->modes.colorIndexMode)
	    (*gc->savedCltProcTable.glDispatchTable.glColor4fv)((GLfloat *) &data->otherColor);
	else
	    (*gc->savedCltProcTable.glDispatchTable.glIndexf)(data->otherColor.r);
    }

    return PC + sizeof(struct __gllc_Begin_Rec);
}

void APIENTRY
__gllc_End ( void )
{
    GLuint size;
    POLYARRAY *pa;
    void *data;
    __GL_SETUP();

    pa = gc->paTeb;

// If we are compiling poly array, finish the poly array processing.
// Note that we may have aborted poly array compilation in CallList(s).
// In that case, we need to compile an End record.

    if (gc->dlist.beginRec)
    {
	ASSERTOPENGL(pa->flags & POLYARRAY_IN_BEGIN, "not in begin!\n");

// Record the last POLYDATA since it may contain attribute changes.

	__glDlistCompilePolyData(gc, GL_TRUE);

// Call glcltEnd to finish the primitive.

	(*gc->savedCltProcTable.glDispatchTable.glEnd)();

// Record the End call.

	__glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(End));

// If we are in COMPILE mode, we need to reset the command buffer,
// the poly array buffer, and the poly material buffer.

	if (gc->dlist.mode == GL_COMPILE)
	{
	    glsbResetBuffers(TRUE);

	    // Clear begin flag too
	    pa->flags &= ~POLYARRAY_IN_BEGIN;
	}

	// Terminate poly array compilation
	gc->dlist.beginRec = NULL;
    }
    else
    {
// Record the call.

	data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(End));
	if (data == NULL) return;
	__glDlistAppendOp(gc, data, __glle_End);
    }
}

const GLubyte * FASTCALL __glle_End(__GLcontext *gc, const GLubyte *PC)
{

    (*gc->savedCltProcTable.glDispatchTable.glEnd)();
    return PC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_lcomp.c ===
/******************************Module*Header*******************************\
* Module Name: dl_lcomp.c
*
* Display list compilation routines.
*
* Created: 12-24-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** Compilation routines for building display lists for all of the basic
** OpenGL commands.  These were automatically generated at one point, 
** but now the basic format has stabilized, and we make minor changes to
** individual routines from time to time.
*/

/***************************************************************************/
// Color functions.
// Compile only Color3ub, Color3f, Color4ub, and Color4f functions.
// Convert the other functions to one of the compiled Color functions.

void APIENTRY
__gllc_Color3ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue )
{
    struct __gllc_Color3ubv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor3ub)(red, green, blue);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color3ubv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color3ubv_Rec)),
                                DLIST_GENERIC_OP(Color3ubv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color3ubv);
}

void APIENTRY
__gllc_Color3ubv ( IN const GLubyte v[3] )
{
    __gllc_Color3ub(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Color3f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue )
{
    struct __gllc_Color3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor3f)(red, green, blue);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color3fv_Rec)),
                                DLIST_GENERIC_OP(Color3fv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color3fv);
}

void APIENTRY
__gllc_Color3fv ( IN const GLfloat v[3] )
{
    __gllc_Color3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Color3b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue )
{
    __gllc_Color3f(__GL_B_TO_FLOAT(red), __GL_B_TO_FLOAT(green),
	           __GL_B_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3bv ( IN const GLbyte v[3] )
{
    __gllc_Color3f(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	           __GL_B_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue )
{
    __gllc_Color3f((GLfloat) red, (GLfloat) green, (GLfloat) blue);
}

void APIENTRY
__gllc_Color3dv ( IN const GLdouble v[3] )
{
    __gllc_Color3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Color3i ( IN GLint red, IN GLint green, IN GLint blue )
{
    __gllc_Color3f(__GL_I_TO_FLOAT(red), __GL_I_TO_FLOAT(green),
		   __GL_I_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3iv ( IN const GLint v[3] )
{
    __gllc_Color3f(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
		   __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3s ( IN GLshort red, IN GLshort green, IN GLshort blue )
{
    __gllc_Color3f(__GL_S_TO_FLOAT(red), __GL_S_TO_FLOAT(green),
		   __GL_S_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3sv ( IN const GLshort v[3] )
{
    __gllc_Color3f(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
		   __GL_S_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3ui ( IN GLuint red, IN GLuint green, IN GLuint blue )
{
    __gllc_Color3f(__GL_UI_TO_FLOAT(red), __GL_UI_TO_FLOAT(green),
		   __GL_UI_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3uiv ( IN const GLuint v[3] )
{
    __gllc_Color3f(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
		   __GL_UI_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color3us ( IN GLushort red, IN GLushort green, IN GLushort blue )
{
    __gllc_Color3f(__GL_US_TO_FLOAT(red), __GL_US_TO_FLOAT(green),
		   __GL_US_TO_FLOAT(blue));
}

void APIENTRY
__gllc_Color3usv ( IN const GLushort v[3] )
{
    __gllc_Color3f(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
		   __GL_US_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Color4ub ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha )
{
    struct __gllc_Color4ubv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor4ub)(red, green, blue, alpha);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color4ubv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color4ubv_Rec)),
                                DLIST_GENERIC_OP(Color4ubv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
    data->v[3] = alpha;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color4ubv);
}

void APIENTRY
__gllc_Color4ubv ( IN const GLubyte v[4] )
{
    __gllc_Color4ub(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_Color4f ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    struct __gllc_Color4fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glColor4f)(red, green, blue, alpha);

	// Record "otherColor" here
	if (gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor = gc->paTeb->otherColor;
	}
	return;
    }

    data = (struct __gllc_Color4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Color4fv_Rec)),
                                DLIST_GENERIC_OP(Color4fv));
    if (data == NULL) return;
    data->v[0] = red;
    data->v[1] = green;
    data->v[2] = blue;
    data->v[3] = alpha;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;
#endif
    __glDlistAppendOp(gc, data, __glle_Color4fv);
}

void APIENTRY
__gllc_Color4fv ( IN const GLfloat v[4] )
{
    __gllc_Color4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_Color4b ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha )
{
    __gllc_Color4f(__GL_B_TO_FLOAT(red),  __GL_B_TO_FLOAT(green),
	           __GL_B_TO_FLOAT(blue), __GL_B_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4bv ( IN const GLbyte v[4] )
{
    __gllc_Color4f(__GL_B_TO_FLOAT(v[0]), __GL_B_TO_FLOAT(v[1]),
	           __GL_B_TO_FLOAT(v[2]), __GL_B_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4d ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha )
{
    __gllc_Color4f((GLfloat) red, (GLfloat) green, (GLfloat) blue, (GLfloat) alpha);
}

void APIENTRY
__gllc_Color4dv ( IN const GLdouble v[4] )
{
    __gllc_Color4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_Color4i ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha )
{
    __gllc_Color4f(__GL_I_TO_FLOAT(red),  __GL_I_TO_FLOAT(green),
	           __GL_I_TO_FLOAT(blue), __GL_I_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4iv ( IN const GLint v[4] )
{
    __gllc_Color4f(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
	           __GL_I_TO_FLOAT(v[2]), __GL_I_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4s ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha )
{
    __gllc_Color4f(__GL_S_TO_FLOAT(red),  __GL_S_TO_FLOAT(green),
	           __GL_S_TO_FLOAT(blue), __GL_S_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4sv ( IN const GLshort v[4] )
{
    __gllc_Color4f(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
	           __GL_S_TO_FLOAT(v[2]), __GL_S_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4ui ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha )
{
    __gllc_Color4f(__GL_UI_TO_FLOAT(red),  __GL_UI_TO_FLOAT(green),
	           __GL_UI_TO_FLOAT(blue), __GL_UI_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4uiv ( IN const GLuint v[4] )
{
    __gllc_Color4f(__GL_UI_TO_FLOAT(v[0]), __GL_UI_TO_FLOAT(v[1]),
	           __GL_UI_TO_FLOAT(v[2]), __GL_UI_TO_FLOAT(v[3]));
}

void APIENTRY
__gllc_Color4us ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha )
{
    __gllc_Color4f(__GL_US_TO_FLOAT(red),  __GL_US_TO_FLOAT(green),
	           __GL_US_TO_FLOAT(blue), __GL_US_TO_FLOAT(alpha));
}

void APIENTRY
__gllc_Color4usv ( IN const GLushort v[4] )
{
    __gllc_Color4f(__GL_US_TO_FLOAT(v[0]), __GL_US_TO_FLOAT(v[1]),
	           __GL_US_TO_FLOAT(v[2]), __GL_US_TO_FLOAT(v[3]));
}

/***************************************************************************/
// EdgeFlag functions.
// Compile only EdgeFlag function.
// Convert the other function to the compiled EdgeFlag function.

void APIENTRY
__gllc_EdgeFlag ( IN GLboolean flag )
{
    struct __gllc_EdgeFlag_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glEdgeFlag)(flag);
	return;
    }

    data = (struct __gllc_EdgeFlag_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EdgeFlag_Rec)),
                                DLIST_GENERIC_OP(EdgeFlag));
    if (data == NULL) return;
    data->flag = flag;
    __glDlistAppendOp(gc, data, __glle_EdgeFlag);
}

void APIENTRY
__gllc_EdgeFlagv ( IN const GLboolean flag[1] )
{
    __gllc_EdgeFlag(flag[0]);
}

/***************************************************************************/
// Index functions.
// Compile only Indexf function.
// Convert the other functions to the compiled Indexf function.

void APIENTRY
__gllc_Indexf ( IN GLfloat c )
{
    struct __gllc_Indexf_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glIndexf)(c);

	// Record "otherColor" here
	if (!gc->modes.colorIndexMode)
	{
	    gc->dlist.beginRec->flags |= DLIST_BEGIN_HAS_OTHER_COLOR;
	    gc->dlist.beginRec->otherColor.r = gc->paTeb->otherColor.r;
	}
	return;
    }

    data = (struct __gllc_Indexf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Indexf_Rec)),
                                DLIST_GENERIC_OP(Indexf));
    if (data == NULL) return;
    data->c = c;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_INDEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Indexf);
}

void APIENTRY
__gllc_Indexfv ( IN const GLfloat c[1] )
{
    __gllc_Indexf(c[0]);
}

void APIENTRY
__gllc_Indexd ( IN GLdouble c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexdv ( IN const GLdouble c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

void APIENTRY
__gllc_Indexi ( IN GLint c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexiv ( IN const GLint c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

void APIENTRY
__gllc_Indexs ( IN GLshort c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexsv ( IN const GLshort c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

void APIENTRY
__gllc_Indexub ( IN GLubyte c )
{
    __gllc_Indexf((GLfloat) c);
}

void APIENTRY
__gllc_Indexubv ( IN const GLubyte c[1] )
{
    __gllc_Indexf((GLfloat) c[0]);
}

/***************************************************************************/
// Normal functions.
// Compile only Normal3b and Normal3f functions.
// Convert the other functions to one of the compiled Normal functions.

void APIENTRY
__gllc_Normal3b ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz )
{
    struct __gllc_Normal3bv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glNormal3b)(nx, ny, nz);
	return;
    }

    data = (struct __gllc_Normal3bv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Normal3bv_Rec)),
                                DLIST_GENERIC_OP(Normal3bv));
    if (data == NULL) return;
    data->v[0] = nx;
    data->v[1] = ny;
    data->v[2] = nz;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_NORMAL;
#endif
    __glDlistAppendOp(gc, data, __glle_Normal3bv);
}

void APIENTRY
__gllc_Normal3bv ( IN const GLbyte v[3] )
{
    __gllc_Normal3b(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Normal3f ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz )
{
    struct __gllc_Normal3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glNormal3f)(nx, ny, nz);
	return;
    }

    data = (struct __gllc_Normal3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Normal3fv_Rec)),
                                DLIST_GENERIC_OP(Normal3fv));
    if (data == NULL) return;
    data->v[0] = nx;
    data->v[1] = ny;
    data->v[2] = nz;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_NORMAL;
#endif
    __glDlistAppendOp(gc, data, __glle_Normal3fv);
}

void APIENTRY
__gllc_Normal3fv ( IN const GLfloat v[3] )
{
    __gllc_Normal3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Normal3d ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz )
{
    __gllc_Normal3f((GLfloat) nx, (GLfloat) ny, (GLfloat) nz);
}

void APIENTRY
__gllc_Normal3dv ( IN const GLdouble v[3] )
{
    __gllc_Normal3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Normal3i ( IN GLint nx, IN GLint ny, IN GLint nz )
{
    __gllc_Normal3f(__GL_I_TO_FLOAT(nx), __GL_I_TO_FLOAT(ny),
		    __GL_I_TO_FLOAT(nz));
}

void APIENTRY
__gllc_Normal3iv ( IN const GLint v[3] )
{
    __gllc_Normal3f(__GL_I_TO_FLOAT(v[0]), __GL_I_TO_FLOAT(v[1]),
		    __GL_I_TO_FLOAT(v[2]));
}

void APIENTRY
__gllc_Normal3s ( IN GLshort nx, IN GLshort ny, IN GLshort nz )
{
    __gllc_Normal3f(__GL_S_TO_FLOAT(nx), __GL_S_TO_FLOAT(ny),
		    __GL_S_TO_FLOAT(nz));
}

void APIENTRY
__gllc_Normal3sv ( IN const GLshort v[3] )
{
    __gllc_Normal3f(__GL_S_TO_FLOAT(v[0]), __GL_S_TO_FLOAT(v[1]),
		    __GL_S_TO_FLOAT(v[2]));
}

/***************************************************************************/
// RasterPos functions.
// Compile only RasterPos2f, RasterPos3f and RasterPos4f functions.
// Convert the other functions to one of the compiled RasterPos functions.

void APIENTRY
__gllc_RasterPos2f ( IN GLfloat x, IN GLfloat y )
{
    struct __gllc_RasterPos2f_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_RasterPos2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_RasterPos2f_Rec)),
                                DLIST_GENERIC_OP(RasterPos2f));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;
#endif
    __glDlistAppendOp(gc, data, __glle_RasterPos2f);
}

void APIENTRY
__gllc_RasterPos2fv ( IN const GLfloat v[2] )
{
    __gllc_RasterPos2f(v[0], v[1]);
}

void APIENTRY
__gllc_RasterPos2d ( IN GLdouble x, IN GLdouble y )
{
    __gllc_RasterPos2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_RasterPos2dv ( IN const GLdouble v[2] )
{
    __gllc_RasterPos2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_RasterPos2i ( IN GLint x, IN GLint y )
{
    __gllc_RasterPos2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_RasterPos2iv ( IN const GLint v[2] )
{
    __gllc_RasterPos2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_RasterPos2s ( IN GLshort x, IN GLshort y )
{
    __gllc_RasterPos2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_RasterPos2sv ( IN const GLshort v[2] )
{
    __gllc_RasterPos2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_RasterPos3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_RasterPos3fv_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_RasterPos3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_RasterPos3fv_Rec)),
                                DLIST_GENERIC_OP(RasterPos3fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;
#endif
    __glDlistAppendOp(gc, data, __glle_RasterPos3fv);
}

void APIENTRY
__gllc_RasterPos3fv ( IN const GLfloat v[3] )
{
    __gllc_RasterPos3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_RasterPos3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_RasterPos3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_RasterPos3dv ( IN const GLdouble v[3] )
{
    __gllc_RasterPos3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_RasterPos3i ( IN GLint x, IN GLint y, IN GLint z )
{
    __gllc_RasterPos3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_RasterPos3iv ( IN const GLint v[3] )
{
    __gllc_RasterPos3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_RasterPos3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    __gllc_RasterPos3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_RasterPos3sv ( IN const GLshort v[3] )
{
    __gllc_RasterPos3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_RasterPos4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    struct __gllc_RasterPos4fv_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_RasterPos4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_RasterPos4fv_Rec)),
                                DLIST_GENERIC_OP(RasterPos4fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
    data->v[3] = w;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;
#endif
    __glDlistAppendOp(gc, data, __glle_RasterPos4fv);
}

void APIENTRY
__gllc_RasterPos4fv ( IN const GLfloat v[4] )
{
    __gllc_RasterPos4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_RasterPos4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    __gllc_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_RasterPos4dv ( IN const GLdouble v[4] )
{
    __gllc_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_RasterPos4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    __gllc_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_RasterPos4iv ( IN const GLint v[4] )
{
    __gllc_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_RasterPos4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    __gllc_RasterPos4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_RasterPos4sv ( IN const GLshort v[4] )
{
    __gllc_RasterPos4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

/***************************************************************************/
// Rect functions.
// Compile only Rectf function.
// Convert the other functions to the compiled Rectf function.

void APIENTRY
__gllc_Rectf ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 )
{
    struct __gllc_Rectf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Rectf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Rectf_Rec)),
                                DLIST_GENERIC_OP(Rectf));
    if (data == NULL) return;
    data->x1 = x1;
    data->y1 = y1;
    data->x2 = x2;
    data->y2 = y2;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RECT;
#endif
    __glDlistAppendOp(gc, data, __glle_Rectf);
}

void APIENTRY
__gllc_Rectfv ( IN const GLfloat v1[2], IN const GLfloat v2[2] )
{
    __gllc_Rectf(v1[0], v1[1], v2[0], v2[1]);
}

void APIENTRY
__gllc_Rectd ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 )
{
    __gllc_Rectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
__gllc_Rectdv ( IN const GLdouble v1[2], IN const GLdouble v2[2] )
{
    __gllc_Rectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
__gllc_Recti ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 )
{
    __gllc_Rectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
__gllc_Rectiv ( IN const GLint v1[2], IN const GLint v2[2] )
{
    __gllc_Rectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

void APIENTRY
__gllc_Rects ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 )
{
    __gllc_Rectf((GLfloat) x1, (GLfloat) y1, (GLfloat) x2, (GLfloat) y2);
}

void APIENTRY
__gllc_Rectsv ( IN const GLshort v1[2], IN const GLshort v2[2] )
{
    __gllc_Rectf((GLfloat) v1[0], (GLfloat) v1[1], (GLfloat) v2[0], (GLfloat) v2[1]);
}

/***************************************************************************/
// TexCoord functions.
// Compile only TexCoord1f, TexCoord2f, TexCoord3f and TexCoord4f functions.
// Convert the other functions to one of the compiled TexCoord functions.

void APIENTRY
__gllc_TexCoord1f ( IN GLfloat s )
{
    struct __gllc_TexCoord1f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord1f)(s);
	return;
    }

    data = (struct __gllc_TexCoord1f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord1f_Rec)),
                                DLIST_GENERIC_OP(TexCoord1f));
    if (data == NULL) return;
    data->s = s;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord1f);
}

void APIENTRY
__gllc_TexCoord1fv ( IN const GLfloat v[1] )
{
    __gllc_TexCoord1f(v[0]);
}

void APIENTRY
__gllc_TexCoord1d ( IN GLdouble s )
{
    __gllc_TexCoord1f((GLfloat) s);
}

void APIENTRY
__gllc_TexCoord1dv ( IN const GLdouble v[1] )
{
    __gllc_TexCoord1f((GLfloat) v[0]);
}

void APIENTRY
__gllc_TexCoord1i ( IN GLint s )
{
    __gllc_TexCoord1f((GLfloat) s);
}

void APIENTRY
__gllc_TexCoord1iv ( IN const GLint v[1] )
{
    __gllc_TexCoord1f((GLfloat) v[0]);
}

void APIENTRY
__gllc_TexCoord1s ( IN GLshort s )
{
    __gllc_TexCoord1f((GLfloat) s);
}

void APIENTRY
__gllc_TexCoord1sv ( IN const GLshort v[1] )
{
    __gllc_TexCoord1f((GLfloat) v[0]);
}

void APIENTRY
__gllc_TexCoord2f ( IN GLfloat s, IN GLfloat t )
{
    struct __gllc_TexCoord2f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord2f)(s, t);
	return;
    }

    data = (struct __gllc_TexCoord2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord2f_Rec)),
                                DLIST_GENERIC_OP(TexCoord2f));
    if (data == NULL) return;
    data->s = s;
    data->t = t;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord2f);
}

void APIENTRY
__gllc_TexCoord2fv ( IN const GLfloat v[2] )
{
    __gllc_TexCoord2f(v[0], v[1]);
}

void APIENTRY
__gllc_TexCoord2d ( IN GLdouble s, IN GLdouble t )
{
    __gllc_TexCoord2f((GLfloat) s, (GLfloat) t);
}

void APIENTRY
__gllc_TexCoord2dv ( IN const GLdouble v[2] )
{
    __gllc_TexCoord2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_TexCoord2i ( IN GLint s, IN GLint t )
{
    __gllc_TexCoord2f((GLfloat) s, (GLfloat) t);
}

void APIENTRY
__gllc_TexCoord2iv ( IN const GLint v[2] )
{
    __gllc_TexCoord2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_TexCoord2s ( IN GLshort s, IN GLshort t )
{
    __gllc_TexCoord2f((GLfloat) s, (GLfloat) t);
}

void APIENTRY
__gllc_TexCoord2sv ( IN const GLshort v[2] )
{
    __gllc_TexCoord2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_TexCoord3f ( IN GLfloat s, IN GLfloat t, IN GLfloat r )
{
    struct __gllc_TexCoord3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord3f)(s, t, r);
	return;
    }

    data = (struct __gllc_TexCoord3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord3fv_Rec)),
                                DLIST_GENERIC_OP(TexCoord3fv));
    if (data == NULL) return;
    data->v[0] = s;
    data->v[1] = t;
    data->v[2] = r;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord3fv);
}

void APIENTRY
__gllc_TexCoord3fv ( IN const GLfloat v[3] )
{
    __gllc_TexCoord3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_TexCoord3d ( IN GLdouble s, IN GLdouble t, IN GLdouble r )
{
    __gllc_TexCoord3f((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
__gllc_TexCoord3dv ( IN const GLdouble v[3] )
{
    __gllc_TexCoord3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_TexCoord3i ( IN GLint s, IN GLint t, IN GLint r )
{
    __gllc_TexCoord3f((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
__gllc_TexCoord3iv ( IN const GLint v[3] )
{
    __gllc_TexCoord3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_TexCoord3s ( IN GLshort s, IN GLshort t, IN GLshort r )
{
    __gllc_TexCoord3f((GLfloat) s, (GLfloat) t, (GLfloat) r);
}

void APIENTRY
__gllc_TexCoord3sv ( IN const GLshort v[3] )
{
    __gllc_TexCoord3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_TexCoord4f ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q )
{
    struct __gllc_TexCoord4fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glTexCoord4f)(s, t, r, q);
	return;
    }

    data = (struct __gllc_TexCoord4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_TexCoord4fv_Rec)),
                                DLIST_GENERIC_OP(TexCoord4fv));
    if (data == NULL) return;
    data->v[0] = s;
    data->v[1] = t;
    data->v[2] = r;
    data->v[3] = q;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;
#endif
    __glDlistAppendOp(gc, data, __glle_TexCoord4fv);
}

void APIENTRY
__gllc_TexCoord4fv ( IN const GLfloat v[4] )
{
    __gllc_TexCoord4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_TexCoord4d ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q )
{
    __gllc_TexCoord4f((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
__gllc_TexCoord4dv ( IN const GLdouble v[4] )
{
    __gllc_TexCoord4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_TexCoord4i ( IN GLint s, IN GLint t, IN GLint r, IN GLint q )
{
    __gllc_TexCoord4f((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
__gllc_TexCoord4iv ( IN const GLint v[4] )
{
    __gllc_TexCoord4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_TexCoord4s ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q )
{
    __gllc_TexCoord4f((GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
}

void APIENTRY
__gllc_TexCoord4sv ( IN const GLshort v[4] )
{
    __gllc_TexCoord4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

#ifdef GL_WIN_multiple_textures
void APIENTRY __gllc_MultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s)
{
}

void APIENTRY __gllc_MultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s)
{
}

void APIENTRY __gllc_MultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord1iWIN
    (GLbitfield mask, GLint s)
{
}

void APIENTRY __gllc_MultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord1sWIN
    (GLbitfield mask, GLshort s)
{
}

void APIENTRY __gllc_MultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v)
{
}

void APIENTRY __gllc_MultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t)
{
}

void APIENTRY __gllc_MultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t)
{
}

void APIENTRY __gllc_MultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t)
{
}

void APIENTRY __gllc_MultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t)
{
}

void APIENTRY __gllc_MultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v)
{
}

void APIENTRY __gllc_MultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r)
{
}

void APIENTRY __gllc_MultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r)
{
}

void APIENTRY __gllc_MultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r)
{
}

void APIENTRY __gllc_MultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r)
{
}

void APIENTRY __gllc_MultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v)
{
}

void APIENTRY __gllc_MultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
}

void APIENTRY __gllc_MultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v)
{
}

void APIENTRY __gllc_MultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
}

void APIENTRY __gllc_MultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v)
{
}

void APIENTRY __gllc_MultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q)
{
}

void APIENTRY __gllc_MultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v)
{
}

void APIENTRY __gllc_MultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q)
{
}

void APIENTRY __gllc_MultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v)
{
}
#endif // GL_WIN_multiple_textures

/***************************************************************************/
// Vertex functions.
// Compile only Vertex2f, Vertex3f and Vertex4f functions.
// Convert the other functions to one of the compiled Vertex functions.

void APIENTRY
__gllc_Vertex2f ( IN GLfloat x, IN GLfloat y )
{
    struct __gllc_Vertex2f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glVertex2f)(x, y);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a Vertex record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_Vertex2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Vertex2f_Rec)),
                                DLIST_GENERIC_OP(Vertex2f));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Vertex2f);
}

void APIENTRY
__gllc_Vertex2fv ( IN const GLfloat v[2] )
{
    __gllc_Vertex2f(v[0], v[1]);
}

void APIENTRY
__gllc_Vertex2d ( IN GLdouble x, IN GLdouble y )
{
    __gllc_Vertex2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_Vertex2dv ( IN const GLdouble v[2] )
{
    __gllc_Vertex2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_Vertex2i ( IN GLint x, IN GLint y )
{
    __gllc_Vertex2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_Vertex2iv ( IN const GLint v[2] )
{
    __gllc_Vertex2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_Vertex2s ( IN GLshort x, IN GLshort y )
{
    __gllc_Vertex2f((GLfloat) x, (GLfloat) y);
}

void APIENTRY
__gllc_Vertex2sv ( IN const GLshort v[2] )
{
    __gllc_Vertex2f((GLfloat) v[0], (GLfloat) v[1]);
}

void APIENTRY
__gllc_Vertex3f ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Vertex3fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glVertex3f)(x, y, z);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a Vertex record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_Vertex3fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Vertex3fv_Rec)),
                                DLIST_GENERIC_OP(Vertex3fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Vertex3fv);
}

void APIENTRY
__gllc_Vertex3fv ( IN const GLfloat v[3] )
{
    __gllc_Vertex3f(v[0], v[1], v[2]);
}

void APIENTRY
__gllc_Vertex3d ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Vertex3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_Vertex3dv ( IN const GLdouble v[3] )
{
    __gllc_Vertex3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Vertex3i ( IN GLint x, IN GLint y, IN GLint z )
{
    __gllc_Vertex3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_Vertex3iv ( IN const GLint v[3] )
{
    __gllc_Vertex3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Vertex3s ( IN GLshort x, IN GLshort y, IN GLshort z )
{
    __gllc_Vertex3f((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

void APIENTRY
__gllc_Vertex3sv ( IN const GLshort v[3] )
{
    __gllc_Vertex3f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
}

void APIENTRY
__gllc_Vertex4f ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w )
{
    struct __gllc_Vertex4fv_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glVertex4f)(x, y, z, w);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a Vertex record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_Vertex4fv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Vertex4fv_Rec)),
                                DLIST_GENERIC_OP(Vertex4fv));
    if (data == NULL) return;
    data->v[0] = x;
    data->v[1] = y;
    data->v[2] = z;
    data->v[3] = w;
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;
#endif
    __glDlistAppendOp(gc, data, __glle_Vertex4fv);
}

void APIENTRY
__gllc_Vertex4fv ( IN const GLfloat v[4] )
{
    __gllc_Vertex4f(v[0], v[1], v[2], v[3]);
}

void APIENTRY
__gllc_Vertex4d ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w )
{
    __gllc_Vertex4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_Vertex4dv ( IN const GLdouble v[4] )
{
    __gllc_Vertex4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_Vertex4i ( IN GLint x, IN GLint y, IN GLint z, IN GLint w )
{
    __gllc_Vertex4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_Vertex4iv ( IN const GLint v[4] )
{
    __gllc_Vertex4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

void APIENTRY
__gllc_Vertex4s ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w )
{
    __gllc_Vertex4f((GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}

void APIENTRY
__gllc_Vertex4sv ( IN const GLshort v[4] )
{
    __gllc_Vertex4f((GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
}

/***************************************************************************/
// Fog functions.
// Compile only Fogfv function.
// Convert the other functions to the compiled Fogfv function.

void APIENTRY
__gllc_Fogfv ( IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_Fogfv_Rec *data;
    __GL_SETUP();

    arraySize = __glFogfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_Fogfv_Rec) + arraySize;
    data = (struct __gllc_Fogfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(Fogfv));
    if (data == NULL) return;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_Fogfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_Fogfv);
}

void APIENTRY
__gllc_Fogf ( IN GLenum pname, IN GLfloat param )
{
// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_Fogfv(pname, &param);
}

void APIENTRY
__gllc_Fogi ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// FOG_ASSERT

    if (!RANGE(pname,GL_FOG_INDEX,GL_FOG_MODE))
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_Fogfv(pname, &fParam);
}

void APIENTRY
__gllc_Fogiv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_FOG_INDEX:
      case GL_FOG_DENSITY:
      case GL_FOG_START:
      case GL_FOG_END:
      case GL_FOG_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
      case GL_FOG_COLOR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
    }

    __gllc_Fogfv(pname, fParams);
}

/***************************************************************************/
// Light functions.
// Compile only Lightfv function.
// Convert the other functions to the compiled Lightfv function.

void APIENTRY
__gllc_Lightfv ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_Lightfv_Rec *data;
    __GL_SETUP();

    arraySize = __glLightfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_Lightfv_Rec) + arraySize;
    data = (struct __gllc_Lightfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(Lightfv));
    if (data == NULL) return;
    data->light = light;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_Lightfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_Lightfv);
}

void APIENTRY
__gllc_Lightf ( IN GLenum light, IN GLenum pname, IN GLfloat param )
{
// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_Lightfv(light, pname, &param);
}

void APIENTRY
__gllc_Lighti ( IN GLenum light, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_SOURCE_ASSERT

    if (!RANGE(pname,GL_SPOT_EXPONENT,GL_QUADRATIC_ATTENUATION))
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_Lightfv(light, pname, &fParam);
}

void APIENTRY
__gllc_Lightiv ( IN GLenum light, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_POSITION:
	fParams[3] = (GLfloat) params[3];
      case GL_SPOT_DIRECTION:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SPOT_EXPONENT:
      case GL_SPOT_CUTOFF:
      case GL_CONSTANT_ATTENUATION:
      case GL_LINEAR_ATTENUATION:
      case GL_QUADRATIC_ATTENUATION:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_Lightfv(light, pname, fParams);
}

/***************************************************************************/
// LightModel functions.
// Compile only LightModelfv function.
// Convert the other functions to the compiled LightModelfv function.

void APIENTRY
__gllc_LightModelfv ( IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_LightModelfv_Rec *data;
    __GL_SETUP();

    arraySize = __glLightModelfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_LightModelfv_Rec) + arraySize;
    data = (struct __gllc_LightModelfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(LightModelfv));
    if (data == NULL) return;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_LightModelfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_LightModelfv);
}

void APIENTRY
__gllc_LightModelf ( IN GLenum pname, IN GLfloat param )
{
// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
	__gllc_InvalidEnum();
        return;
    }

    __gllc_LightModelfv(pname, &param);
}

void APIENTRY
__gllc_LightModeli ( IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

// LIGHT_MODEL_ASSERT

    if (!RANGE(pname,GL_LIGHT_MODEL_LOCAL_VIEWER,GL_LIGHT_MODEL_TWO_SIDE))
    {
	__gllc_InvalidEnum();
        return;
    }

    fParam = (GLfloat) param;
    __gllc_LightModelfv(pname, &fParam);
}

void APIENTRY
__gllc_LightModeliv ( IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_LIGHT_MODEL_AMBIENT:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
      case GL_LIGHT_MODEL_TWO_SIDE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_LightModelfv(pname, fParams);
}

/***************************************************************************/
// Material functions.
// Compile only Materialfv function.
// Convert the other functions to the compiled Materialfv function.

void APIENTRY
__gllc_Materialfv ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    GLenum error;
    struct __gllc_Materialfv_Rec *data;
    __GL_SETUP();

#ifdef SGI
// Check this at playback time
    error = __glErrorCheckMaterial(face, pname, params[0]);
    if (error != GL_NO_ERROR) {
	__gllc_Error(gc, error);
	return;
    }
#endif
    arraySize = __glMaterialfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }

// If we are compiling poly array primitive, update the poly data record.

    if (gc->dlist.beginRec)
    {
	(*gc->savedCltProcTable.glDispatchTable.glMaterialfv)(face, pname, params);
	return;
    }

    size = sizeof(struct __gllc_Materialfv_Rec) + arraySize;
    data = (struct __gllc_Materialfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(Materialfv));
    if (data == NULL) return;
    data->face = face;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_Materialfv_Rec),
		 params, arraySize);
#ifndef NT
    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_MATERIAL;
#endif
    __glDlistAppendOp(gc, data, __glle_Materialfv);
}

void APIENTRY
__gllc_Materialf ( IN GLenum face, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_SHININESS)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_Materialfv(face, pname, &param);
}

void APIENTRY
__gllc_Materiali ( IN GLenum face, IN GLenum pname, IN GLint param )
{
    GLfloat fParams[1];

    if (pname != GL_SHININESS)
    {
	__gllc_InvalidEnum();
        return;
    }

    fParams[0] = (GLfloat) param;
    __gllc_Materialfv(face, pname, fParams);
}

void APIENTRY
__gllc_Materialiv ( IN GLenum face, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_EMISSION:
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
      case GL_AMBIENT_AND_DIFFUSE:
	fParams[0] = __GL_I_TO_FLOAT(params[0]);
	fParams[1] = __GL_I_TO_FLOAT(params[1]);
	fParams[2] = __GL_I_TO_FLOAT(params[2]);
	fParams[3] = __GL_I_TO_FLOAT(params[3]);
        break;
      case GL_COLOR_INDEXES:
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
      case GL_SHININESS:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_Materialfv(face, pname, fParams);
}

/***************************************************************************/
// TexParameter functions.
// Compile only TexParameterfv and TexParameteriv functions.
// Convert the other functions to one of the compiled TexParameter functions.

void APIENTRY
__gllc_TexParameterfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexParameterfv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexParameterfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexParameterfv_Rec) + arraySize;
    data = (struct __gllc_TexParameterfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexParameterfv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexParameterfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexParameterfv);
}

void APIENTRY
__gllc_TexParameterf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexParameterfv(target, pname, &param);
}

void APIENTRY
__gllc_TexParameteriv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexParameteriv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexParameteriv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexParameteriv_Rec) + arraySize;
    data = (struct __gllc_TexParameteriv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexParameteriv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexParameteriv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexParameteriv);
}

void APIENTRY
__gllc_TexParameteri ( IN GLenum target, IN GLenum pname, IN GLint param )
{
// TEX_PARAMETER_ASSERT

    if (!RANGE(pname,GL_TEXTURE_MAG_FILTER,GL_TEXTURE_WRAP_T) &&
        pname != GL_TEXTURE_PRIORITY)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexParameteriv(target, pname, &param);
}

/***************************************************************************/
// TexEnv functions.
// Compile only TexEnvfv and TexEnviv functions.
// Convert the other functions to one of the compiled TexEnv functions.

void APIENTRY
__gllc_TexEnvfv ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexEnvfv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexEnvfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexEnvfv_Rec) + arraySize;
    data = (struct __gllc_TexEnvfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexEnvfv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexEnvfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexEnvfv);
}

void APIENTRY
__gllc_TexEnvf ( IN GLenum target, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexEnvfv(target, pname, &param);
}

void APIENTRY
__gllc_TexEnviv ( IN GLenum target, IN GLenum pname, IN const GLint params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexEnviv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexEnviv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexEnviv_Rec) + arraySize;
    data = (struct __gllc_TexEnviv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexEnviv));
    if (data == NULL) return;
    data->target = target;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexEnviv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexEnviv);
}

void APIENTRY
__gllc_TexEnvi ( IN GLenum target, IN GLenum pname, IN GLint param )
{
    if (pname != GL_TEXTURE_ENV_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexEnviv(target, pname, &param);
}

/***************************************************************************/
// TexGen functions.
// Compile only TexGenfv function.
// Convert the other functions to the compiled TexGenfv function.

void APIENTRY
__gllc_TexGenfv ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_TexGenfv_Rec *data;
    __GL_SETUP();

    arraySize = __glTexGenfv_size(pname) * 4;
    if (arraySize < 0) {
	__gllc_InvalidEnum();
	return;
    }
    size = sizeof(struct __gllc_TexGenfv_Rec) + arraySize;
    data = (struct __gllc_TexGenfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(TexGenfv));
    if (data == NULL) return;
    data->coord = coord;
    data->pname = pname;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_TexGenfv_Rec),
		 params, arraySize);
    __glDlistAppendOp(gc, data, __glle_TexGenfv);
}

void APIENTRY
__gllc_TexGend ( IN GLenum coord, IN GLenum pname, IN GLdouble param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_TexGenfv(coord, pname, &fParam);
}

void APIENTRY
__gllc_TexGendv ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_TexGenfv(coord, pname, fParams);
}

void APIENTRY
__gllc_TexGenf ( IN GLenum coord, IN GLenum pname, IN GLfloat param )
{
    if (pname != GL_TEXTURE_GEN_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    __gllc_TexGenfv(coord, pname, &param);
}

void APIENTRY
__gllc_TexGeni ( IN GLenum coord, IN GLenum pname, IN GLint param )
{
    GLfloat fParam;

    if (pname != GL_TEXTURE_GEN_MODE)
    {
	__gllc_InvalidEnum();
	return;
    }

    fParam = (GLfloat) param;
    __gllc_TexGenfv(coord, pname, &fParam);
}

void APIENTRY
__gllc_TexGeniv ( IN GLenum coord, IN GLenum pname, IN const GLint params[] )
{
    GLfloat fParams[4];

    switch (pname)
    {
      case GL_OBJECT_PLANE:
      case GL_EYE_PLANE:
	fParams[3] = (GLfloat) params[3];
	fParams[2] = (GLfloat) params[2];
	fParams[1] = (GLfloat) params[1];
	// fall through
      case GL_TEXTURE_GEN_MODE:
	fParams[0] = (GLfloat) params[0];
        break;
    }

    __gllc_TexGenfv(coord, pname, fParams);
}

/***************************************************************************/
// MapGrid functions.
// Compile only MapGrid1f and MapGrid2f functions.
// Convert the other functions to one of the compiled MapGrid functions.

void APIENTRY
__gllc_MapGrid1f ( IN GLint un, IN GLfloat u1, IN GLfloat u2 )
{
    struct __gllc_MapGrid1f_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MapGrid1f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MapGrid1f_Rec)),
                                DLIST_GENERIC_OP(MapGrid1f));
    if (data == NULL) return;
    data->un = un;
    data->u1 = u1;
    data->u2 = u2;
    __glDlistAppendOp(gc, data, __glle_MapGrid1f);
}

void APIENTRY
__gllc_MapGrid1d ( IN GLint un, IN GLdouble u1, IN GLdouble u2 )
{
    __gllc_MapGrid1f(un, (GLfloat) u1, (GLfloat) u2);
}

void APIENTRY
__gllc_MapGrid2f ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 )
{
    struct __gllc_MapGrid2f_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MapGrid2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MapGrid2f_Rec)),
                                DLIST_GENERIC_OP(MapGrid2f));
    if (data == NULL) return;
    data->un = un;
    data->u1 = u1;
    data->u2 = u2;
    data->vn = vn;
    data->v1 = v1;
    data->v2 = v2;
    __glDlistAppendOp(gc, data, __glle_MapGrid2f);
}

void APIENTRY
__gllc_MapGrid2d ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 )
{
    __gllc_MapGrid2f(un, (GLfloat) u1, (GLfloat) u2, vn, (GLfloat) v1, (GLfloat) v2);
}

/***************************************************************************/
// EvalCoord functions.
// Compile only EvalCoord1f and EvalCoord2f functions.
// Convert the other functions to one of the compiled EvalCoord functions.

void APIENTRY
__gllc_EvalCoord1f ( IN GLfloat u )
{
    struct __gllc_EvalCoord1f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord1f)(u);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalCoord record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalCoord1f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalCoord1f_Rec)),
                                DLIST_GENERIC_OP(EvalCoord1f));
    if (data == NULL) return;
    data->u = u;
    __glDlistAppendOp(gc, data, __glle_EvalCoord1f);
}

void APIENTRY
__gllc_EvalCoord1d ( IN GLdouble u )
{
    __gllc_EvalCoord1f((GLfloat) u);
}

void APIENTRY
__gllc_EvalCoord1dv ( IN const GLdouble u[1] )
{
    __gllc_EvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
__gllc_EvalCoord1fv ( IN const GLfloat u[1] )
{
    __gllc_EvalCoord1f((GLfloat) u[0]);
}

void APIENTRY
__gllc_EvalCoord2f ( IN GLfloat u, IN GLfloat v )
{
    struct __gllc_EvalCoord2f_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalCoord2f)(u, v);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalCoord record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalCoord2f_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalCoord2f_Rec)),
                                DLIST_GENERIC_OP(EvalCoord2f));
    if (data == NULL) return;
    data->u = u;
    data->v = v;
    __glDlistAppendOp(gc, data, __glle_EvalCoord2f);
}

void APIENTRY
__gllc_EvalCoord2d ( IN GLdouble u, IN GLdouble v )
{
    __gllc_EvalCoord2f((GLfloat) u, (GLfloat) v);
}

void APIENTRY
__gllc_EvalCoord2dv ( IN const GLdouble u[2] )
{
    __gllc_EvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

void APIENTRY
__gllc_EvalCoord2fv ( IN const GLfloat u[2] )
{
    __gllc_EvalCoord2f((GLfloat) u[0], (GLfloat) u[1]);
}

/***************************************************************************/
// LoadMatrix functions.
// Compile only LoadMatrixf function.
// Convert the other functions to the compiled LoadMatrixf function.

void APIENTRY
__gllc_LoadMatrixf ( IN const GLfloat m[16] )
{
    struct __gllc_LoadMatrixf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LoadMatrixf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LoadMatrixf_Rec)),
                                DLIST_GENERIC_OP(LoadMatrixf));
    if (data == NULL) return;
    __GL_MEMCOPY(data->m, m, sizeof(data->m));
    __glDlistAppendOp(gc, data, __glle_LoadMatrixf);
}

void APIENTRY
__gllc_LoadMatrixd ( IN const GLdouble m[16] )
{
    GLfloat fm[16];

    fm[ 0] = (GLfloat) m[ 0];
    fm[ 1] = (GLfloat) m[ 1];
    fm[ 2] = (GLfloat) m[ 2];
    fm[ 3] = (GLfloat) m[ 3];
    fm[ 4] = (GLfloat) m[ 4];
    fm[ 5] = (GLfloat) m[ 5];
    fm[ 6] = (GLfloat) m[ 6];
    fm[ 7] = (GLfloat) m[ 7];
    fm[ 8] = (GLfloat) m[ 8];
    fm[ 9] = (GLfloat) m[ 9];
    fm[10] = (GLfloat) m[10];
    fm[11] = (GLfloat) m[11];
    fm[12] = (GLfloat) m[12];
    fm[13] = (GLfloat) m[13];
    fm[14] = (GLfloat) m[14];
    fm[15] = (GLfloat) m[15];

    __gllc_LoadMatrixf(fm);
}

/***************************************************************************/
// MultMatrix functions.
// Compile only MultMatrixf function.
// Convert the other functions to the compiled MultMatrixf function.

void APIENTRY
__gllc_MultMatrixf ( IN const GLfloat m[16] )
{
    struct __gllc_MultMatrixf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MultMatrixf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MultMatrixf_Rec)),
                                DLIST_GENERIC_OP(MultMatrixf));
    if (data == NULL) return;
    __GL_MEMCOPY(data->m, m, sizeof(data->m));
    __glDlistAppendOp(gc, data, __glle_MultMatrixf);
}

void APIENTRY
__gllc_MultMatrixd ( IN const GLdouble m[16] )
{
    GLfloat fm[16];

    fm[ 0] = (GLfloat) m[ 0];
    fm[ 1] = (GLfloat) m[ 1];
    fm[ 2] = (GLfloat) m[ 2];
    fm[ 3] = (GLfloat) m[ 3];
    fm[ 4] = (GLfloat) m[ 4];
    fm[ 5] = (GLfloat) m[ 5];
    fm[ 6] = (GLfloat) m[ 6];
    fm[ 7] = (GLfloat) m[ 7];
    fm[ 8] = (GLfloat) m[ 8];
    fm[ 9] = (GLfloat) m[ 9];
    fm[10] = (GLfloat) m[10];
    fm[11] = (GLfloat) m[11];
    fm[12] = (GLfloat) m[12];
    fm[13] = (GLfloat) m[13];
    fm[14] = (GLfloat) m[14];
    fm[15] = (GLfloat) m[15];

    __gllc_MultMatrixf(fm);
}

/***************************************************************************/
// Rotate functions.
// Compile only Rotatef function.
// Convert the other functions to the compiled Rotatef function.

void APIENTRY
__gllc_Rotatef ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Rotatef_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Rotatef_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Rotatef_Rec)),
                                DLIST_GENERIC_OP(Rotatef));
    if (data == NULL) return;
    data->angle = angle;
    data->x = x;
    data->y = y;
    data->z = z;
    __glDlistAppendOp(gc, data, __glle_Rotatef);
}

void APIENTRY
__gllc_Rotated ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Rotatef((GLfloat) angle, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}

/***************************************************************************/
// Scale functions.
// Compile only Scalef function.
// Convert the other functions to the compiled Scalef function.

void APIENTRY
__gllc_Scalef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Scalef_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Scalef_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Scalef_Rec)),
                                DLIST_GENERIC_OP(Scalef));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->z = z;
    __glDlistAppendOp(gc, data, __glle_Scalef);
}

void APIENTRY
__gllc_Scaled ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Scalef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

/***************************************************************************/
// Translate functions.
// Compile only Translatef function.
// Convert the other functions to the compiled Translatef function.

void APIENTRY
__gllc_Translatef ( IN GLfloat x, IN GLfloat y, IN GLfloat z )
{
    struct __gllc_Translatef_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Translatef_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Translatef_Rec)),
                                DLIST_GENERIC_OP(Translatef));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->z = z;
    __glDlistAppendOp(gc, data, __glle_Translatef);
}

void APIENTRY
__gllc_Translated ( IN GLdouble x, IN GLdouble y, IN GLdouble z )
{
    __gllc_Translatef((GLfloat) x, (GLfloat) y, (GLfloat) z);
}

/***************************************************************************/
// Other functions.

void APIENTRY
__gllc_ListBase ( IN GLuint base )
{
    struct __gllc_ListBase_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ListBase_Rec *)
        __glDlistAddOpUnaligned(gc,
                                DLIST_SIZE(sizeof(struct __gllc_ListBase_Rec)),
                                DLIST_GENERIC_OP(ListBase));
    if (data == NULL) return;
    data->base = base;
    __glDlistAppendOp(gc, data, __glle_ListBase);
}

void APIENTRY
__gllc_ClipPlane ( IN GLenum plane, IN const GLdouble equation[4] )
{
    struct __gllc_ClipPlane_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClipPlane_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClipPlane_Rec)),
                              DLIST_GENERIC_OP(ClipPlane));
    if (data == NULL) return;
    data->plane = plane;
    data->equation[0] = equation[0];
    data->equation[1] = equation[1];
    data->equation[2] = equation[2];
    data->equation[3] = equation[3];
    __glDlistAppendOp(gc, data, __glle_ClipPlane);
}

void APIENTRY
__gllc_ColorMaterial ( IN GLenum face, IN GLenum mode )
{
    struct __gllc_ColorMaterial_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ColorMaterial_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ColorMaterial_Rec)),
                                DLIST_GENERIC_OP(ColorMaterial));
    if (data == NULL) return;
    data->face = face;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_ColorMaterial);
}

void APIENTRY
__gllc_CullFace ( IN GLenum mode )
{
    struct __gllc_CullFace_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CullFace_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CullFace_Rec)),
                                DLIST_GENERIC_OP(CullFace));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_CullFace);
}

void APIENTRY
__gllc_FrontFace ( IN GLenum mode )
{
    struct __gllc_FrontFace_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_FrontFace_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_FrontFace_Rec)),
                                DLIST_GENERIC_OP(FrontFace));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_FrontFace);
}

void APIENTRY
__gllc_Hint ( IN GLenum target, IN GLenum mode )
{
    struct __gllc_Hint_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Hint_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Hint_Rec)),
                                DLIST_GENERIC_OP(Hint));
    if (data == NULL) return;
    data->target = target;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_Hint);
}

void APIENTRY
__gllc_LineStipple ( IN GLint factor, IN GLushort pattern )
{
    struct __gllc_LineStipple_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LineStipple_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LineStipple_Rec)),
                                DLIST_GENERIC_OP(LineStipple));
    if (data == NULL) return;
    data->factor = factor;
    data->pattern = pattern;
    __glDlistAppendOp(gc, data, __glle_LineStipple);
}

void APIENTRY
__gllc_LineWidth ( IN GLfloat width )
{
    struct __gllc_LineWidth_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LineWidth_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LineWidth_Rec)),
                                DLIST_GENERIC_OP(LineWidth));
    if (data == NULL) return;
    data->width = width;
    __glDlistAppendOp(gc, data, __glle_LineWidth);
}

void APIENTRY
__gllc_PointSize ( IN GLfloat size )
{
    struct __gllc_PointSize_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PointSize_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PointSize_Rec)),
                                DLIST_GENERIC_OP(PointSize));
    if (data == NULL) return;
    data->size = size;
    __glDlistAppendOp(gc, data, __glle_PointSize);
}

void APIENTRY
__gllc_PolygonMode ( IN GLenum face, IN GLenum mode )
{
    struct __gllc_PolygonMode_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PolygonMode_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PolygonMode_Rec)),
                                DLIST_GENERIC_OP(PolygonMode));
    if (data == NULL) return;
    data->face = face;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_PolygonMode);
}

void APIENTRY
__gllc_Scissor ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    struct __gllc_Scissor_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Scissor_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Scissor_Rec)),
                                DLIST_GENERIC_OP(Scissor));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    __glDlistAppendOp(gc, data, __glle_Scissor);
}

void APIENTRY
__gllc_ShadeModel ( IN GLenum mode )
{
    struct __gllc_ShadeModel_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ShadeModel_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ShadeModel_Rec)),
                                DLIST_GENERIC_OP(ShadeModel));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_ShadeModel);
}

void APIENTRY
__gllc_InitNames ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(InitNames));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_InitNames);
}

void APIENTRY
__gllc_LoadName ( IN GLuint name )
{
    struct __gllc_LoadName_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LoadName_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LoadName_Rec)),
                                DLIST_GENERIC_OP(LoadName));
    if (data == NULL) return;
    data->name = name;
    __glDlistAppendOp(gc, data, __glle_LoadName);
}

void APIENTRY
__gllc_PassThrough ( IN GLfloat token )
{
    struct __gllc_PassThrough_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PassThrough_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PassThrough_Rec)),
                                DLIST_GENERIC_OP(PassThrough));
    if (data == NULL) return;
    data->token = token;
    __glDlistAppendOp(gc, data, __glle_PassThrough);
}

void APIENTRY
__gllc_PopName ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PopName));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PopName);
}

void APIENTRY
__gllc_PushName ( IN GLuint name )
{
    struct __gllc_PushName_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PushName_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PushName_Rec)),
                                DLIST_GENERIC_OP(PushName));
    if (data == NULL) return;
    data->name = name;
    __glDlistAppendOp(gc, data, __glle_PushName);
}

void APIENTRY
__gllc_DrawBuffer ( IN GLenum mode )
{
    struct __gllc_DrawBuffer_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DrawBuffer_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DrawBuffer_Rec)),
                                DLIST_GENERIC_OP(DrawBuffer));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_DrawBuffer);
#if 0
#ifdef NT
    gc->dlist.drawBuffer = GL_TRUE;
#endif
#endif
}

void APIENTRY
__gllc_Clear ( IN GLbitfield mask )
{
    struct __gllc_Clear_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Clear_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Clear_Rec)),
                                DLIST_GENERIC_OP(Clear));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_Clear);
}

void APIENTRY
__gllc_ClearAccum ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha )
{
    struct __gllc_ClearAccum_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearAccum_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearAccum_Rec)),
                                DLIST_GENERIC_OP(ClearAccum));
    if (data == NULL) return;
    data->red = red;
    data->green = green;
    data->blue = blue;
    data->alpha = alpha;
    __glDlistAppendOp(gc, data, __glle_ClearAccum);
}

void APIENTRY
__gllc_ClearIndex ( IN GLfloat c )
{
    struct __gllc_ClearIndex_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearIndex_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearIndex_Rec)),
                                DLIST_GENERIC_OP(ClearIndex));
    if (data == NULL) return;
    data->c = c;
    __glDlistAppendOp(gc, data, __glle_ClearIndex);
}

void APIENTRY
__gllc_ClearColor ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha )
{
    struct __gllc_ClearColor_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearColor_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearColor_Rec)),
                                DLIST_GENERIC_OP(ClearColor));
    if (data == NULL) return;
    data->red = red;
    data->green = green;
    data->blue = blue;
    data->alpha = alpha;
    __glDlistAppendOp(gc, data, __glle_ClearColor);
}

void APIENTRY
__gllc_ClearStencil ( IN GLint s )
{
    struct __gllc_ClearStencil_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearStencil_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearStencil_Rec)),
                                DLIST_GENERIC_OP(ClearStencil));
    if (data == NULL) return;
    data->s = s;
    __glDlistAppendOp(gc, data, __glle_ClearStencil);
}

void APIENTRY
__gllc_ClearDepth ( IN GLclampd depth )
{
    struct __gllc_ClearDepth_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ClearDepth_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ClearDepth_Rec)),
                                DLIST_GENERIC_OP(ClearDepth));
    if (data == NULL) return;
    data->depth = depth;
    __glDlistAppendOp(gc, data, __glle_ClearDepth);
}

void APIENTRY
__gllc_StencilMask ( IN GLuint mask )
{
    struct __gllc_StencilMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_StencilMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_StencilMask_Rec)),
                                DLIST_GENERIC_OP(StencilMask));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_StencilMask);
}

void APIENTRY
__gllc_ColorMask ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha )
{
    struct __gllc_ColorMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ColorMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ColorMask_Rec)),
                                DLIST_GENERIC_OP(ColorMask));
    if (data == NULL) return;
    data->red = red;
    data->green = green;
    data->blue = blue;
    data->alpha = alpha;
    __glDlistAppendOp(gc, data, __glle_ColorMask);
}

void APIENTRY
__gllc_DepthMask ( IN GLboolean flag )
{
    struct __gllc_DepthMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DepthMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DepthMask_Rec)),
                                DLIST_GENERIC_OP(DepthMask));
    if (data == NULL) return;
    data->flag = flag;
    __glDlistAppendOp(gc, data, __glle_DepthMask);
}

void APIENTRY
__gllc_IndexMask ( IN GLuint mask )
{
    struct __gllc_IndexMask_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_IndexMask_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_IndexMask_Rec)),
                                DLIST_GENERIC_OP(IndexMask));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_IndexMask);
}

void APIENTRY
__gllc_Accum ( IN GLenum op, IN GLfloat value )
{
    struct __gllc_Accum_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Accum_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Accum_Rec)),
                                DLIST_GENERIC_OP(Accum));
    if (data == NULL) return;
    data->op = op;
    data->value = value;
    __glDlistAppendOp(gc, data, __glle_Accum);
}

void APIENTRY
__gllc_Disable ( IN GLenum cap )
{
    struct __gllc_Disable_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Disable_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Disable_Rec)),
                                DLIST_GENERIC_OP(Disable));
    if (data == NULL) return;
    data->cap = cap;
    __glDlistAppendOp(gc, data, __glle_Disable);
}

void APIENTRY
__gllc_Enable ( IN GLenum cap )
{
    struct __gllc_Enable_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Enable_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Enable_Rec)),
                                DLIST_GENERIC_OP(Enable));
    if (data == NULL) return;
    data->cap = cap;
    __glDlistAppendOp(gc, data, __glle_Enable);
}

void APIENTRY
__gllc_PopAttrib ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PopAttrib));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PopAttrib);
}

void APIENTRY
__gllc_PushAttrib ( IN GLbitfield mask )
{
    struct __gllc_PushAttrib_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PushAttrib_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PushAttrib_Rec)),
                                DLIST_GENERIC_OP(PushAttrib));
    if (data == NULL) return;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_PushAttrib);
}

void APIENTRY
__gllc_EvalMesh1 ( IN GLenum mode, IN GLint i1, IN GLint i2 )
{
    struct __gllc_EvalMesh1_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_EvalMesh1_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalMesh1_Rec)),
                                DLIST_GENERIC_OP(EvalMesh1));
    if (data == NULL) return;
    data->mode = mode;
    data->i1 = i1;
    data->i2 = i2;
    __glDlistAppendOp(gc, data, __glle_EvalMesh1);
}

void APIENTRY
__gllc_EvalPoint1 ( IN GLint i )
{
    struct __gllc_EvalPoint1_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint1)(i);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalPoint record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalPoint1_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalPoint1_Rec)),
                                DLIST_GENERIC_OP(EvalPoint1));
    if (data == NULL) return;
    data->i = i;
    __glDlistAppendOp(gc, data, __glle_EvalPoint1);
}

void APIENTRY
__gllc_EvalMesh2 ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 )
{
    struct __gllc_EvalMesh2_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_EvalMesh2_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalMesh2_Rec)),
                                DLIST_GENERIC_OP(EvalMesh2));
    if (data == NULL) return;
    data->mode = mode;
    data->i1 = i1;
    data->i2 = i2;
    data->j1 = j1;
    data->j2 = j2;
    __glDlistAppendOp(gc, data, __glle_EvalMesh2);
}

void APIENTRY
__gllc_EvalPoint2 ( IN GLint i, IN GLint j )
{
    struct __gllc_EvalPoint2_Rec *data;
    __GL_SETUP();

// If we are compiling poly array primitive, update and record the poly data
// record.

    if (gc->dlist.beginRec)
    {
	POLYARRAY *pa;

	pa = gc->paTeb;

	// If we are in COMPILE_AND_EXECUTE mode or there are attribute
	// changes associated with the vertex, process the poly data.
	if (gc->dlist.mode == GL_COMPILE_AND_EXECUTE
	 || pa->pdNextVertex->flags)
	{
	    (*gc->savedCltProcTable.glDispatchTable.glEvalPoint2)(i, j);
	    __glDlistCompilePolyData(gc, GL_FALSE);
	    return;
	}

	// Otherwise, increment vertex count and compile a EvalPoint record
	// instead.
	gc->dlist.beginRec->nVertices++;
    }

    data = (struct __gllc_EvalPoint2_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_EvalPoint2_Rec)),
                                DLIST_GENERIC_OP(EvalPoint2));
    if (data == NULL) return;
    data->i = i;
    data->j = j;
    __glDlistAppendOp(gc, data, __glle_EvalPoint2);
}

void APIENTRY
__gllc_AlphaFunc ( IN GLenum func, IN GLclampf ref )
{
    struct __gllc_AlphaFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_AlphaFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_AlphaFunc_Rec)),
                                DLIST_GENERIC_OP(AlphaFunc));
    if (data == NULL) return;
    data->func = func;
    data->ref = ref;
    __glDlistAppendOp(gc, data, __glle_AlphaFunc);
}

void APIENTRY
__gllc_BlendFunc ( IN GLenum sfactor, IN GLenum dfactor )
{
    struct __gllc_BlendFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_BlendFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_BlendFunc_Rec)),
                                DLIST_GENERIC_OP(BlendFunc));
    if (data == NULL) return;
    data->sfactor = sfactor;
    data->dfactor = dfactor;
    __glDlistAppendOp(gc, data, __glle_BlendFunc);
}

void APIENTRY
__gllc_LogicOp ( IN GLenum opcode )
{
    struct __gllc_LogicOp_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_LogicOp_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_LogicOp_Rec)),
                                DLIST_GENERIC_OP(LogicOp));
    if (data == NULL) return;
    data->opcode = opcode;
    __glDlistAppendOp(gc, data, __glle_LogicOp);
}

void APIENTRY
__gllc_StencilFunc ( IN GLenum func, IN GLint ref, IN GLuint mask )
{
    struct __gllc_StencilFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_StencilFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_StencilFunc_Rec)),
                                DLIST_GENERIC_OP(StencilFunc));
    if (data == NULL) return;
    data->func = func;
    data->ref = ref;
    data->mask = mask;
    __glDlistAppendOp(gc, data, __glle_StencilFunc);
}

void APIENTRY
__gllc_StencilOp ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass )
{
    struct __gllc_StencilOp_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_StencilOp_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_StencilOp_Rec)),
                                DLIST_GENERIC_OP(StencilOp));
    if (data == NULL) return;
    data->fail = fail;
    data->zfail = zfail;
    data->zpass = zpass;
    __glDlistAppendOp(gc, data, __glle_StencilOp);
}

void APIENTRY
__gllc_DepthFunc ( IN GLenum func )
{
    struct __gllc_DepthFunc_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DepthFunc_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DepthFunc_Rec)),
                                DLIST_GENERIC_OP(DepthFunc));
    if (data == NULL) return;
    data->func = func;
    __glDlistAppendOp(gc, data, __glle_DepthFunc);
}

void APIENTRY
__gllc_PixelZoom ( IN GLfloat xfactor, IN GLfloat yfactor )
{
    struct __gllc_PixelZoom_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PixelZoom_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PixelZoom_Rec)),
                                DLIST_GENERIC_OP(PixelZoom));
    if (data == NULL) return;
    data->xfactor = xfactor;
    data->yfactor = yfactor;
    __glDlistAppendOp(gc, data, __glle_PixelZoom);
}

void APIENTRY
__gllc_PixelTransferf ( IN GLenum pname, IN GLfloat param )
{
    struct __gllc_PixelTransferf_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PixelTransferf_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PixelTransferf_Rec)),
                                DLIST_GENERIC_OP(PixelTransferf));
    if (data == NULL) return;
    data->pname = pname;
    data->param = param;
    __glDlistAppendOp(gc, data, __glle_PixelTransferf);
}

void APIENTRY
__gllc_PixelTransferi ( IN GLenum pname, IN GLint param )
{
    struct __gllc_PixelTransferi_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PixelTransferi_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PixelTransferi_Rec)),
                                DLIST_GENERIC_OP(PixelTransferi));
    if (data == NULL) return;
    data->pname = pname;
    data->param = param;
    __glDlistAppendOp(gc, data, __glle_PixelTransferi);
}

void APIENTRY
__gllc_PixelMapfv ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_PixelMapfv_Rec *data;
    __GL_SETUP();

    arraySize = mapsize * 4;
    if (arraySize < 0) {
	__gllc_InvalidValue();
	return;
    }
    size = sizeof(struct __gllc_PixelMapfv_Rec) + arraySize;
    data = (struct __gllc_PixelMapfv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(PixelMapfv));
    if (data == NULL) return;
    data->map = map;
    data->mapsize = mapsize;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_PixelMapfv_Rec),
		 values, arraySize);
    __glDlistAppendOp(gc, data, __glle_PixelMapfv);
}

void APIENTRY
__gllc_PixelMapuiv ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_PixelMapuiv_Rec *data;
    __GL_SETUP();

    arraySize = mapsize * 4;
    if (arraySize < 0) {
	__gllc_InvalidValue();
	return;
    }
    size = sizeof(struct __gllc_PixelMapuiv_Rec) + arraySize;
    data = (struct __gllc_PixelMapuiv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(PixelMapuiv));
    if (data == NULL) return;
    data->map = map;
    data->mapsize = mapsize;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_PixelMapuiv_Rec),
		 values, arraySize);
    __glDlistAppendOp(gc, data, __glle_PixelMapuiv);
}

void APIENTRY
__gllc_PixelMapusv ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] )
{
    GLuint size;
    GLint arraySize;
    struct __gllc_PixelMapusv_Rec *data;
    __GL_SETUP();

    arraySize = mapsize * 2;
    if (arraySize < 0) {
	__gllc_InvalidValue();
	return;
    }
#ifdef NT
    size = sizeof(struct __gllc_PixelMapusv_Rec) + __GL_PAD(arraySize);
#else
    arraySize = __GL_PAD(arraySize);
    size = sizeof(struct __gllc_PixelMapusv_Rec) + arraySize;
#endif
    data = (struct __gllc_PixelMapusv_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(size), DLIST_GENERIC_OP(PixelMapusv));
    if (data == NULL) return;
    data->map = map;
    data->mapsize = mapsize;
    __GL_MEMCOPY((GLubyte *)data + sizeof(struct __gllc_PixelMapusv_Rec),
		 values, arraySize);
    __glDlistAppendOp(gc, data, __glle_PixelMapusv);
}

void APIENTRY
__gllc_ReadBuffer ( IN GLenum mode )
{
    struct __gllc_ReadBuffer_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_ReadBuffer_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_ReadBuffer_Rec)),
                                DLIST_GENERIC_OP(ReadBuffer));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_ReadBuffer);
}

void APIENTRY
__gllc_CopyPixels ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type )
{
    struct __gllc_CopyPixels_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyPixels_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyPixels_Rec)),
                                DLIST_GENERIC_OP(CopyPixels));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    data->type = type;
    __glDlistAppendOp(gc, data, __glle_CopyPixels);
}

void APIENTRY
__gllc_DepthRange ( IN GLclampd zNear, IN GLclampd zFar )
{
    struct __gllc_DepthRange_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_DepthRange_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_DepthRange_Rec)),
                                DLIST_GENERIC_OP(DepthRange));
    if (data == NULL) return;
    data->zNear = zNear;
    data->zFar = zFar;
    __glDlistAppendOp(gc, data, __glle_DepthRange);
}

void APIENTRY
__gllc_Frustum ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    struct __gllc_Frustum_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Frustum_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(sizeof(struct __gllc_Frustum_Rec)),
                              DLIST_GENERIC_OP(Frustum));
    if (data == NULL) return;
    data->left = left;
    data->right = right;
    data->bottom = bottom;
    data->top = top;
    data->zNear = zNear;
    data->zFar = zFar;
    __glDlistAppendOp(gc, data, __glle_Frustum);
}

void APIENTRY
__gllc_LoadIdentity ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(LoadIdentity));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_LoadIdentity);
}

void APIENTRY
__gllc_MatrixMode ( IN GLenum mode )
{
    struct __gllc_MatrixMode_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_MatrixMode_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_MatrixMode_Rec)),
                                DLIST_GENERIC_OP(MatrixMode));
    if (data == NULL) return;
    data->mode = mode;
    __glDlistAppendOp(gc, data, __glle_MatrixMode);
}

void APIENTRY
__gllc_Ortho ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar )
{
    struct __gllc_Ortho_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Ortho_Rec *)
        __glDlistAddOpAligned(gc, DLIST_SIZE(sizeof(struct __gllc_Ortho_Rec)),
                              DLIST_GENERIC_OP(Ortho));
    if (data == NULL) return;
    data->left = left;
    data->right = right;
    data->bottom = bottom;
    data->top = top;
    data->zNear = zNear;
    data->zFar = zFar;
    __glDlistAppendOp(gc, data, __glle_Ortho);
}

void APIENTRY
__gllc_PopMatrix ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PopMatrix));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PopMatrix);
}

void APIENTRY
__gllc_PushMatrix ( void )
{
    void *data;
    __GL_SETUP();

    data = __glDlistAddOpUnaligned(gc, DLIST_SIZE(0), DLIST_GENERIC_OP(PushMatrix));
    if (data == NULL) return;
    __glDlistAppendOp(gc, data, __glle_PushMatrix);
}

void APIENTRY
__gllc_Viewport ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height )
{
    struct __gllc_Viewport_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_Viewport_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_Viewport_Rec)),
                                DLIST_GENERIC_OP(Viewport));
    if (data == NULL) return;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    __glDlistAppendOp(gc, data, __glle_Viewport);
}

void APIENTRY __gllc_BindTexture(GLenum target, GLuint texture)
{
    struct __gllc_BindTexture_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_BindTexture_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_BindTexture_Rec)),
                                DLIST_GENERIC_OP(BindTexture));
    if (data == NULL) return;
    data->target = target;
    data->texture = texture;
    __glDlistAppendOp(gc, data, __glle_BindTexture);
}

void APIENTRY __gllc_PrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities)
{
    struct __gllc_PrioritizeTextures_Rec *data;
    __GL_SETUP();
    GLuint size;
    GLubyte *extra;

    size = DLIST_SIZE(sizeof(struct __gllc_PrioritizeTextures_Rec)+
                      n*(sizeof(GLuint)+sizeof(GLclampf)));
    data = (struct __gllc_PrioritizeTextures_Rec *)
        __glDlistAddOpUnaligned(gc, size,
                                DLIST_GENERIC_OP(PrioritizeTextures));
    if (data == NULL) return;
    data->n = n;
    extra = (GLubyte *)data+sizeof(struct __gllc_PrioritizeTextures_Rec);
    __GL_MEMCOPY(extra, textures, n*sizeof(GLuint));
    extra += n*sizeof(GLuint);
    __GL_MEMCOPY(extra, priorities, n*sizeof(GLclampf));
    __glDlistAppendOp(gc, data, __glle_PrioritizeTextures);
}

void APIENTRY __gllc_CopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border)
{
    struct __gllc_CopyTexImage1D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexImage1D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexImage1D_Rec)),
                                DLIST_GENERIC_OP(CopyTexImage1D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->internalformat = internalformat;
    data->x = x;
    data->y = y;
    data->width = width;
    data->border = border;
    __glDlistAppendOp(gc, data, __glle_CopyTexImage1D);
}

void APIENTRY __gllc_CopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border)
{
    struct __gllc_CopyTexImage2D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexImage2D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexImage2D_Rec)),
                                DLIST_GENERIC_OP(CopyTexImage2D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->internalformat = internalformat;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    data->border = border;
    __glDlistAppendOp(gc, data, __glle_CopyTexImage2D);
}

void APIENTRY __gllc_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width)
{
    struct __gllc_CopyTexSubImage1D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexSubImage1D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexSubImage1D_Rec)),
                                DLIST_GENERIC_OP(CopyTexSubImage1D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->xoffset = xoffset;
    data->x = x;
    data->y = y;
    data->width = width;
    __glDlistAppendOp(gc, data, __glle_CopyTexSubImage1D);
}

void APIENTRY __gllc_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height)
{
    struct __gllc_CopyTexSubImage2D_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_CopyTexSubImage2D_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_CopyTexSubImage2D_Rec)),
                                DLIST_GENERIC_OP(CopyTexSubImage2D));
    if (data == NULL) return;
    data->target = target;
    data->level = level;
    data->xoffset = xoffset;
    data->yoffset = yoffset;
    data->x = x;
    data->y = y;
    data->width = width;
    data->height = height;
    __glDlistAppendOp(gc, data, __glle_CopyTexSubImage2D);
}

void APIENTRY __gllc_PolygonOffset(GLfloat factor, GLfloat units)
{
    struct __gllc_PolygonOffset_Rec *data;
    __GL_SETUP();

    data = (struct __gllc_PolygonOffset_Rec *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(struct __gllc_PolygonOffset_Rec)),
                                DLIST_GENERIC_OP(PolygonOffset));
    if (data == NULL) return;
    data->factor = factor;
    data->units = units;
    __glDlistAppendOp(gc, data, __glle_PolygonOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_proc.c ===
/******************************Module*Header*******************************\
* Module Name: dl_proc.c
*
* Display list compilation routines.
*
* Created: 12-26-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

/* Client Side Display List Compilation Procedure Table */

#include "precomp.h"
#pragma hdrstop

#include "glclt.h"
#include "exttable.h"

GLCLTPROCTABLE ListCompCltProcTable =
{

/* Number of function entries in the table */

     sizeof(GLDISPATCHTABLE) / sizeof(PROC),

/* gl Entry points */
  {
     glcltNewList                ,
     glcltEndList                ,
     __gllc_CallList               ,
     __gllc_CallLists              ,
     glcltDeleteLists            ,
     glcltGenLists               ,
     __gllc_ListBase               ,
     __gllc_Begin                  ,
     __gllc_Bitmap                 ,
     __gllc_Color3b                ,
     __gllc_Color3bv               ,
     __gllc_Color3d                ,
     __gllc_Color3dv               ,
     __gllc_Color3f                ,
     __gllc_Color3fv               ,
     __gllc_Color3i                ,
     __gllc_Color3iv               ,
     __gllc_Color3s                ,
     __gllc_Color3sv               ,
     __gllc_Color3ub               ,
     __gllc_Color3ubv              ,
     __gllc_Color3ui               ,
     __gllc_Color3uiv              ,
     __gllc_Color3us               ,
     __gllc_Color3usv              ,
     __gllc_Color4b                ,
     __gllc_Color4bv               ,
     __gllc_Color4d                ,
     __gllc_Color4dv               ,
     __gllc_Color4f                ,
     __gllc_Color4fv               ,
     __gllc_Color4i                ,
     __gllc_Color4iv               ,
     __gllc_Color4s                ,
     __gllc_Color4sv               ,
     __gllc_Color4ub               ,
     __gllc_Color4ubv              ,
     __gllc_Color4ui               ,
     __gllc_Color4uiv              ,
     __gllc_Color4us               ,
     __gllc_Color4usv              ,
     __gllc_EdgeFlag               ,
     __gllc_EdgeFlagv              ,
     __gllc_End                    ,
     __gllc_Indexd                 ,
     __gllc_Indexdv                ,
     __gllc_Indexf                 ,
     __gllc_Indexfv                ,
     __gllc_Indexi                 ,
     __gllc_Indexiv                ,
     __gllc_Indexs                 ,
     __gllc_Indexsv                ,
     __gllc_Normal3b               ,
     __gllc_Normal3bv              ,
     __gllc_Normal3d               ,
     __gllc_Normal3dv              ,
     __gllc_Normal3f               ,
     __gllc_Normal3fv              ,
     __gllc_Normal3i               ,
     __gllc_Normal3iv              ,
     __gllc_Normal3s               ,
     __gllc_Normal3sv              ,
     __gllc_RasterPos2d            ,
     __gllc_RasterPos2dv           ,
     __gllc_RasterPos2f            ,
     __gllc_RasterPos2fv           ,
     __gllc_RasterPos2i            ,
     __gllc_RasterPos2iv           ,
     __gllc_RasterPos2s            ,
     __gllc_RasterPos2sv           ,
     __gllc_RasterPos3d            ,
     __gllc_RasterPos3dv           ,
     __gllc_RasterPos3f            ,
     __gllc_RasterPos3fv           ,
     __gllc_RasterPos3i            ,
     __gllc_RasterPos3iv           ,
     __gllc_RasterPos3s            ,
     __gllc_RasterPos3sv           ,
     __gllc_RasterPos4d            ,
     __gllc_RasterPos4dv           ,
     __gllc_RasterPos4f            ,
     __gllc_RasterPos4fv           ,
     __gllc_RasterPos4i            ,
     __gllc_RasterPos4iv           ,
     __gllc_RasterPos4s            ,
     __gllc_RasterPos4sv           ,
     __gllc_Rectd                  ,
     __gllc_Rectdv                 ,
     __gllc_Rectf                  ,
     __gllc_Rectfv                 ,
     __gllc_Recti                  ,
     __gllc_Rectiv                 ,
     __gllc_Rects                  ,
     __gllc_Rectsv                 ,
     __gllc_TexCoord1d             ,
     __gllc_TexCoord1dv            ,
     __gllc_TexCoord1f             ,
     __gllc_TexCoord1fv            ,
     __gllc_TexCoord1i             ,
     __gllc_TexCoord1iv            ,
     __gllc_TexCoord1s             ,
     __gllc_TexCoord1sv            ,
     __gllc_TexCoord2d             ,
     __gllc_TexCoord2dv            ,
     __gllc_TexCoord2f             ,
     __gllc_TexCoord2fv            ,
     __gllc_TexCoord2i             ,
     __gllc_TexCoord2iv            ,
     __gllc_TexCoord2s             ,
     __gllc_TexCoord2sv            ,
     __gllc_TexCoord3d             ,
     __gllc_TexCoord3dv            ,
     __gllc_TexCoord3f             ,
     __gllc_TexCoord3fv            ,
     __gllc_TexCoord3i             ,
     __gllc_TexCoord3iv            ,
     __gllc_TexCoord3s             ,
     __gllc_TexCoord3sv            ,
     __gllc_TexCoord4d             ,
     __gllc_TexCoord4dv            ,
     __gllc_TexCoord4f             ,
     __gllc_TexCoord4fv            ,
     __gllc_TexCoord4i             ,
     __gllc_TexCoord4iv            ,
     __gllc_TexCoord4s             ,
     __gllc_TexCoord4sv            ,
     __gllc_Vertex2d               ,
     __gllc_Vertex2dv              ,
     __gllc_Vertex2f               ,
     __gllc_Vertex2fv              ,
     __gllc_Vertex2i               ,
     __gllc_Vertex2iv              ,
     __gllc_Vertex2s               ,
     __gllc_Vertex2sv              ,
     __gllc_Vertex3d               ,
     __gllc_Vertex3dv              ,
     __gllc_Vertex3f               ,
     __gllc_Vertex3fv              ,
     __gllc_Vertex3i               ,
     __gllc_Vertex3iv              ,
     __gllc_Vertex3s               ,
     __gllc_Vertex3sv              ,
     __gllc_Vertex4d               ,
     __gllc_Vertex4dv              ,
     __gllc_Vertex4f               ,
     __gllc_Vertex4fv              ,
     __gllc_Vertex4i               ,
     __gllc_Vertex4iv              ,
     __gllc_Vertex4s               ,
     __gllc_Vertex4sv              ,
     __gllc_ClipPlane              ,
     __gllc_ColorMaterial          ,
     __gllc_CullFace               ,
     __gllc_Fogf                   ,
     __gllc_Fogfv                  ,
     __gllc_Fogi                   ,
     __gllc_Fogiv                  ,
     __gllc_FrontFace              ,
     __gllc_Hint                   ,
     __gllc_Lightf                 ,
     __gllc_Lightfv                ,
     __gllc_Lighti                 ,
     __gllc_Lightiv                ,
     __gllc_LightModelf            ,
     __gllc_LightModelfv           ,
     __gllc_LightModeli            ,
     __gllc_LightModeliv           ,
     __gllc_LineStipple            ,
     __gllc_LineWidth              ,
     __gllc_Materialf              ,
     __gllc_Materialfv             ,
     __gllc_Materiali              ,
     __gllc_Materialiv             ,
     __gllc_PointSize              ,
     __gllc_PolygonMode            ,
     __gllc_PolygonStipple         ,
     __gllc_Scissor                ,
     __gllc_ShadeModel             ,
     __gllc_TexParameterf          ,
     __gllc_TexParameterfv         ,
     __gllc_TexParameteri          ,
     __gllc_TexParameteriv         ,
     __gllc_TexImage1D             ,
     __gllc_TexImage2D             ,
     __gllc_TexEnvf                ,
     __gllc_TexEnvfv               ,
     __gllc_TexEnvi                ,
     __gllc_TexEnviv               ,
     __gllc_TexGend                ,
     __gllc_TexGendv               ,
     __gllc_TexGenf                ,
     __gllc_TexGenfv               ,
     __gllc_TexGeni                ,
     __gllc_TexGeniv               ,
     glcltFeedbackBuffer         ,
     glcltSelectBuffer           ,
     glcltRenderMode             ,
     __gllc_InitNames              ,
     __gllc_LoadName               ,
     __gllc_PassThrough            ,
     __gllc_PopName                ,
     __gllc_PushName               ,
     __gllc_DrawBuffer             ,
     __gllc_Clear                  ,
     __gllc_ClearAccum             ,
     __gllc_ClearIndex             ,
     __gllc_ClearColor             ,
     __gllc_ClearStencil           ,
     __gllc_ClearDepth             ,
     __gllc_StencilMask            ,
     __gllc_ColorMask              ,
     __gllc_DepthMask              ,
     __gllc_IndexMask              ,
     __gllc_Accum                  ,
     __gllc_Disable                ,
     __gllc_Enable                 ,
     glcltFinish                 ,
     glcltFlush                  ,
     __gllc_PopAttrib              ,
     __gllc_PushAttrib             ,
     __gllc_Map1d                  ,
     __gllc_Map1f                  ,
     __gllc_Map2d                  ,
     __gllc_Map2f                  ,
     __gllc_MapGrid1d              ,
     __gllc_MapGrid1f              ,
     __gllc_MapGrid2d              ,
     __gllc_MapGrid2f              ,
     __gllc_EvalCoord1d            ,
     __gllc_EvalCoord1dv           ,
     __gllc_EvalCoord1f            ,
     __gllc_EvalCoord1fv           ,
     __gllc_EvalCoord2d            ,
     __gllc_EvalCoord2dv           ,
     __gllc_EvalCoord2f            ,
     __gllc_EvalCoord2fv           ,
     __gllc_EvalMesh1              ,
     __gllc_EvalPoint1             ,
     __gllc_EvalMesh2              ,
     __gllc_EvalPoint2             ,
     __gllc_AlphaFunc              ,
     __gllc_BlendFunc              ,
     __gllc_LogicOp                ,
     __gllc_StencilFunc            ,
     __gllc_StencilOp              ,
     __gllc_DepthFunc              ,
     __gllc_PixelZoom              ,
     __gllc_PixelTransferf         ,
     __gllc_PixelTransferi         ,
     glcltPixelStoref            ,
     glcltPixelStorei            ,
     __gllc_PixelMapfv             ,
     __gllc_PixelMapuiv            ,
     __gllc_PixelMapusv            ,
     __gllc_ReadBuffer             ,
     __gllc_CopyPixels             ,
     glcltReadPixels             ,
     __gllc_DrawPixels             ,
     glcltGetBooleanv            ,
     glcltGetClipPlane           ,
     glcltGetDoublev             ,
     glcltGetError               ,
     glcltGetFloatv              ,
     glcltGetIntegerv            ,
     glcltGetLightfv             ,
     glcltGetLightiv             ,
     glcltGetMapdv               ,
     glcltGetMapfv               ,
     glcltGetMapiv               ,
     glcltGetMaterialfv          ,
     glcltGetMaterialiv          ,
     glcltGetPixelMapfv          ,
     glcltGetPixelMapuiv         ,
     glcltGetPixelMapusv         ,
     glcltGetPolygonStipple      ,
     glcltGetString              ,
     glcltGetTexEnvfv            ,
     glcltGetTexEnviv            ,
     glcltGetTexGendv            ,
     glcltGetTexGenfv            ,
     glcltGetTexGeniv            ,
     glcltGetTexImage            ,
     glcltGetTexParameterfv      ,
     glcltGetTexParameteriv      ,
     glcltGetTexLevelParameterfv ,
     glcltGetTexLevelParameteriv ,
     glcltIsEnabled              ,
     glcltIsList                 ,
     __gllc_DepthRange             ,
     __gllc_Frustum                ,
     __gllc_LoadIdentity           ,
     __gllc_LoadMatrixf            ,
     __gllc_LoadMatrixd            ,
     __gllc_MatrixMode             ,
     __gllc_MultMatrixf            ,
     __gllc_MultMatrixd            ,
     __gllc_Ortho                  ,
     __gllc_PopMatrix              ,
     __gllc_PushMatrix             ,
     __gllc_Rotated                ,
     __gllc_Rotatef                ,
     __gllc_Scaled                 ,
     __gllc_Scalef                 ,
     __gllc_Translated             ,
     __gllc_Translatef             ,
     __gllc_Viewport               ,
     __gllc_ArrayElement           ,
     __gllc_BindTexture            ,
     glcltColorPointer             ,
     glcltDisableClientState       ,
     __gllc_DrawArrays             ,
     __gllc_DrawElements           ,
     glcltEdgeFlagPointer          ,
     glcltEnableClientState        ,
     glcltIndexPointer             ,
     __gllc_Indexub                ,
     __gllc_Indexubv               ,
     glcltInterleavedArrays        ,
     glcltNormalPointer            ,
     __gllc_PolygonOffset          ,
     glcltTexCoordPointer          ,
     glcltVertexPointer            ,
     glcltAreTexturesResident      ,
     __gllc_CopyTexImage1D         ,
     __gllc_CopyTexImage2D         ,
     __gllc_CopyTexSubImage1D      ,
     __gllc_CopyTexSubImage2D      ,
     glcltDeleteTextures           ,
     glcltGenTextures              ,
     glcltGetPointerv              ,
     glcltIsTexture                ,
     __gllc_PrioritizeTextures     ,
     __gllc_TexSubImage1D          ,
     __gllc_TexSubImage2D          ,
     glcltPopClientAttrib          ,
     glcltPushClientAttrib         ,
  }

};

GLEXTPROCTABLE ListCompExtProcTable =
{
    /* Number of function entries in the table */
    sizeof(GLEXTDISPATCHTABLE) / sizeof(PROC),

    /* gl EXT Entry points */
  {
      __gllc_DrawRangeElementsWIN,
      __gllc_ColorTableEXT,
      __gllc_ColorSubTableEXT,
      glcltGetColorTableEXT,
      glcltGetColorTableParameterivEXT,
      glcltGetColorTableParameterfvEXT,
#ifdef GL_WIN_multiple_textures
      __gllc_CurrentTextureIndexWIN,
      __gllc_MultiTexCoord1dWIN,
      __gllc_MultiTexCoord1dvWIN,
      __gllc_MultiTexCoord1fWIN,
      __gllc_MultiTexCoord1fvWIN,
      __gllc_MultiTexCoord1iWIN,
      __gllc_MultiTexCoord1ivWIN,
      __gllc_MultiTexCoord1sWIN,
      __gllc_MultiTexCoord1svWIN,
      __gllc_MultiTexCoord2dWIN,
      __gllc_MultiTexCoord2dvWIN,
      __gllc_MultiTexCoord2fWIN,
      __gllc_MultiTexCoord2fvWIN,
      __gllc_MultiTexCoord2iWIN,
      __gllc_MultiTexCoord2ivWIN,
      __gllc_MultiTexCoord2sWIN,
      __gllc_MultiTexCoord2svWIN,
      __gllc_MultiTexCoord3dWIN,
      __gllc_MultiTexCoord3dvWIN,
      __gllc_MultiTexCoord3fWIN,
      __gllc_MultiTexCoord3fvWIN,
      __gllc_MultiTexCoord3iWIN,
      __gllc_MultiTexCoord3ivWIN,
      __gllc_MultiTexCoord3sWIN,
      __gllc_MultiTexCoord3svWIN,
      __gllc_MultiTexCoord4dWIN,
      __gllc_MultiTexCoord4dvWIN,
      __gllc_MultiTexCoord4fWIN,
      __gllc_MultiTexCoord4fvWIN,
      __gllc_MultiTexCoord4iWIN,
      __gllc_MultiTexCoord4ivWIN,
      __gllc_MultiTexCoord4sWIN,
      __gllc_MultiTexCoord4svWIN,
      __gllc_BindNthTextureWIN,
      __gllc_NthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
  }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_pdata.h ===
/******************************Module*Header*******************************\
* Module Name: dl_pdata.h
*
* Routines to execute fast PolyData primitives.
*
* Created: 1-10-1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __dl_pdata_h_
#define __dl_pdata_h_

#define __PDATA_SIZE_T2F         (2 * sizeof(__GLfloat))
#define __PDATA_SIZE_C3F         (3 * sizeof(__GLfloat))
#define __PDATA_SIZE_C4F         (sizeof(__GLcolor))
#define __PDATA_SIZE_N3F         (3 * sizeof(__GLfloat))
//#define __PDATA_SIZE_V2F       (2 * sizeof(__GLfloat))
#define __PDATA_SIZE_V3F         (3 * sizeof(__GLfloat))

// We always set the POLYDATA_DLIST_COLOR_SLOW flag for colors.  It allows us
// to eliminate the flags field in the fast PolyData records.
#define __PDATA_PD_FLAGS_T2F     (POLYDATA_TEXTURE_VALID|POLYDATA_DLIST_TEXTURE2)
#define __PDATA_PD_FLAGS_C3F     (POLYDATA_COLOR_VALID)
#define __PDATA_PD_FLAGS_C4F     (POLYDATA_COLOR_VALID|POLYDATA_DLIST_COLOR_4)
#define __PDATA_PD_FLAGS_N3F     (POLYDATA_NORMAL_VALID)
//#define __PDATA_PD_FLAGS_V2F   (POLYDATA_VERTEX2)
#define __PDATA_PD_FLAGS_V3F     (POLYDATA_VERTEX3)

#define __PDATA_PA_FLAGS_T2F     (POLYARRAY_TEXTURE2)
#define __PDATA_PA_FLAGS_C3F     (0)
#define __PDATA_PA_FLAGS_C4F     (0)
#define __PDATA_PA_FLAGS_N3F     (0)
//#define __PDATA_PA_FLAGS_V2F   (POLYARRAY_VERTEX2)
#define __PDATA_PA_FLAGS_V3F     (POLYARRAY_VERTEX3)

#endif // __dl_pdata_h_

#ifndef __BUILD_GLI386__

#ifdef __GLLE_POLYDATA_C3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_C3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         0
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_N3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_C3F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_C3F_N3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_C4F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_C4F_N3F_V3F
    #define __DL_PDATA_T2F         0
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         1
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         0
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_C3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_C3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         0
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_N3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_C3F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_C3F_N3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         1
    #define __DL_PDATA_C4F         0
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif
#ifdef __GLLE_POLYDATA_T2F_C4F_N3F_V3F
    #define __DL_PDATA_NAME        __glle_PolyData_T2F_C4F_N3F_V3F
    #define __DL_PDATA_T2F         1
    #define __DL_PDATA_C3F         0
    #define __DL_PDATA_C4F         1
    #define __DL_PDATA_N3F         1
    // #define __DL_PDATA_V2F      0
    #define __DL_PDATA_V3F         1
#endif

/*************************************************************************/
// Compute record size, pd flags and pa flags

#if __DL_PDATA_T2F
    #define __DL_PDATA_SIZE_T       __PDATA_SIZE_T2F
    #define __DL_PDATA_PD_FLAGS_T   __PDATA_PD_FLAGS_T2F
    #define __DL_PDATA_PA_FLAGS_T   __PDATA_PA_FLAGS_T2F
#else
    #define __DL_PDATA_SIZE_T       0
    #define __DL_PDATA_PD_FLAGS_T   0
    #define __DL_PDATA_PA_FLAGS_T   0
#endif

#if __DL_PDATA_C3F
    #define __DL_PDATA_SIZE_C       __PDATA_SIZE_C3F
    #define __DL_PDATA_PD_FLAGS_C   __PDATA_PD_FLAGS_C3F
    #define __DL_PDATA_PA_FLAGS_C   __PDATA_PA_FLAGS_C3F
#elif __DL_PDATA_C4F
    #define __DL_PDATA_SIZE_C       __PDATA_SIZE_C4F
    #define __DL_PDATA_PD_FLAGS_C   __PDATA_PD_FLAGS_C4F
    #define __DL_PDATA_PA_FLAGS_C   __PDATA_PA_FLAGS_C4F
#else
    #define __DL_PDATA_SIZE_C       0
    #define __DL_PDATA_PD_FLAGS_C   0
    #define __DL_PDATA_PA_FLAGS_C   0
#endif

#if __DL_PDATA_N3F
    #define __DL_PDATA_SIZE_N       __PDATA_SIZE_N3F
    #define __DL_PDATA_PD_FLAGS_N   __PDATA_PD_FLAGS_N3F
    #define __DL_PDATA_PA_FLAGS_N   __PDATA_PA_FLAGS_N3F
#else
    #define __DL_PDATA_SIZE_N       0
    #define __DL_PDATA_PD_FLAGS_N   0
    #define __DL_PDATA_PA_FLAGS_N   0
#endif

#if __DL_PDATA_V2F
    #define __DL_PDATA_SIZE_V       __PDATA_SIZE_V2F
    #define __DL_PDATA_PD_FLAGS_V   __PDATA_PD_FLAGS_V2F
    #define __DL_PDATA_PA_FLAGS_V   __PDATA_PA_FLAGS_V2F
#elif __DL_PDATA_V3F
    #define __DL_PDATA_SIZE_V       __PDATA_SIZE_V3F
    #define __DL_PDATA_PD_FLAGS_V   __PDATA_PD_FLAGS_V3F
    #define __DL_PDATA_PA_FLAGS_V   __PDATA_PA_FLAGS_V3F
#else
    #define __DL_PDATA_SIZE_V       0
    #define __DL_PDATA_PD_FLAGS_V   0
    #define __DL_PDATA_PA_FLAGS_V   0
#endif

#define __DL_PDATA_SIZE     \
    (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N+__DL_PDATA_SIZE_V)
#define __DL_PDATA_PD_FLAGS \
    (__DL_PDATA_PD_FLAGS_T|__DL_PDATA_PD_FLAGS_C|__DL_PDATA_PD_FLAGS_N|__DL_PDATA_PD_FLAGS_V)
#define __DL_PDATA_PA_FLAGS \
    (__DL_PDATA_PA_FLAGS_T|__DL_PDATA_PA_FLAGS_C|__DL_PDATA_PA_FLAGS_N|__DL_PDATA_PA_FLAGS_V)

/*************************************************************************/
// Compute data offsets.  This is here only because our compiler generates
// better x86 assembly output!

#define __DL_PDATA_TEXTURE_OFFSET    (0)
#define __DL_PDATA_COLOR_OFFSET	     (__DL_PDATA_SIZE_T)
#define __DL_PDATA_NORMAL_OFFSET     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C)
#define __DL_PDATA_VERTEX_OFFSET     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N)

/*************************************************************************/
// Playback a fast __glle_PolyData record in Begin.
const GLubyte * FASTCALL __DL_PDATA_NAME(__GLcontext *gc, const GLubyte *PC)
{
    POLYARRAY *pa;
    POLYDATA  *pd;

    pa = gc->paTeb;
    if (pa->flags & POLYARRAY_IN_BEGIN)
    {
// Update pa fields.

	pa->flags |= __DL_PDATA_PA_FLAGS;
	pd = pa->pdNextVertex++;

#if __DL_PDATA_T2F
	pa->pdCurTexture = pd;
#endif
#if __DL_PDATA_C3F || __DL_PDATA_C4F
	pa->pdCurColor   = pd;
#endif
#if __DL_PDATA_N3F
	pa->pdCurNormal  = pd;
#endif

// Update pd attributes.

	pd->flags |= __DL_PDATA_PD_FLAGS;

#if __DL_PDATA_V2F
	// Vertex
	pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	pd->obj.z = __glZero;
	pd->obj.w = __glOne;
#elif __DL_PDATA_V3F
	// Vertex
	pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	pd->obj.z = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->z;
	pd->obj.w = __glOne;
#endif

#if __DL_PDATA_T2F
	// Texture coord
	pd->texture.x = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->x;
	pd->texture.y = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->y;
	pd->texture.z = __glZero;
	pd->texture.w = __glOne;
#endif

#if __DL_PDATA_C3F
	// Color
	pd->color[0].r = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->r;
	pd->color[0].g = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->g;
	pd->color[0].b = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->b;
	pd->color[0].a = gc->alphaVertexScale;
#elif __DL_PDATA_C4F
	// Color
	pd->color[0] = *((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET]);
#endif

#if __DL_PDATA_N3F
	// Normal
	pd->normal.x = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->x;
	pd->normal.y = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->y;
	pd->normal.z = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->z;
#endif

	pd[1].flags = 0;
	if (pd >= pa->pdFlush)
	    PolyArrayFlushPartialPrimitive();
    }
    else
    {
// Something went wrong at playback time!  We can either try to playback
// this record using the regular API or punt it altogether.  I cannot think
// of a situation when this can happen, so we will punt it for now.

	WARNING("Display list: playing back POLYDATA outside BEGIN!\n");
    }

    return PC + __DL_PDATA_SIZE;
}
    #undef __DL_PDATA_NAME
    #undef __DL_PDATA_T2F
    #undef __DL_PDATA_C3F
    #undef __DL_PDATA_C4F
    #undef __DL_PDATA_N3F
    #undef __DL_PDATA_V2F
    #undef __DL_PDATA_V3F
    #undef __DL_PDATA_SIZE_T
    #undef __DL_PDATA_SIZE_C
    #undef __DL_PDATA_SIZE_N
    #undef __DL_PDATA_SIZE_V
    #undef __DL_PDATA_PD_FLAGS_T
    #undef __DL_PDATA_PD_FLAGS_C
    #undef __DL_PDATA_PD_FLAGS_N
    #undef __DL_PDATA_PD_FLAGS_V
    #undef __DL_PDATA_PA_FLAGS_T
    #undef __DL_PDATA_PA_FLAGS_C
    #undef __DL_PDATA_PA_FLAGS_N
    #undef __DL_PDATA_PA_FLAGS_V
    #undef __DL_PDATA_SIZE
    #undef __DL_PDATA_PD_FLAGS
    #undef __DL_PDATA_PA_FLAGS
    #undef __DL_PDATA_TEXTURE_OFFSET
    #undef __DL_PDATA_COLOR_OFFSET
    #undef __DL_PDATA_NORMAL_OFFSET
    #undef __DL_PDATA_VERTEX_OFFSET
#endif	// __BUILD_GLI386__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\i386\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IF PROFILE
EXTRN __penter:NEAR
	
PROF_ENTRY MACRO
	call __penter
	ENDM
ELSE
PROF_ENTRY MACRO
	ENDM
ENDIF
	
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\dl_table.c ===
/******************************Module*Header*******************************\
* Module Name: dl_table.c
*
* Display list API rountines.
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list table management routines.
**
** $Revision: 1.12 $
** $Date: 1993/10/30 00:06:54 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** The next three routines are used as callbacks by the 
** name space management code.
*/

/*
** Delete the specified display list.  This typically just means free it,
** but if it is refcounted we just decrement the ref count.
*/
void WINAPIV __glDisposeDlist(__GLcontext *gc, void *pData)
{
    __GLdlist *list = pData;

    __GL_NAMES_ASSERT_LOCKED(gc->dlist.namesArray);
    
    list->refcount--;
    
    /* less than zero references? */
    ASSERTOPENGL((GLint) list->refcount >= 0, "negative refcount!\n");
    
    if (list->refcount == 0)
	__glFreeDlist(gc, list);
}

GLboolean APIENTRY
glcltIsList ( IN GLuint list )
{
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return FALSE;
    }

    return __glNamesIsName(gc, gc->dlist.namesArray, list);
}

GLuint APIENTRY
glcltGenLists ( IN GLsizei range )
{
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return 0;
    }

    if (range < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return 0;
    }
    if (range == 0) {
	return 0;
    }

    return __glNamesGenRange(gc, gc->dlist.namesArray, range);
}

void APIENTRY
glcltListBase ( IN GLuint base )
{ 
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }

    gc->state.list.listBase = base;
}

void APIENTRY
glcltDeleteLists ( IN GLuint list, IN GLsizei range )
{
    __GL_SETUP();

    // Must use the client side begin state
    if (gc->paTeb->flags & POLYARRAY_IN_BEGIN)
    {
	GLSETERROR(GL_INVALID_OPERATION);
	return;
    }


    if (range < 0) {
	GLSETERROR(GL_INVALID_VALUE);
	return;
    }
    if (range == 0) return;

    __glNamesDeleteRange(gc, gc->dlist.namesArray, list, range);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ddraw.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <glp.h>
#include <global.h>
#include <imports.h>
#include <dlist.h>
#include "dlistopt.h"
#include <listcomp.h>
#include <namesint.h>
#include <glsize.h>
#include "glsbcltu.h"
#include "compsize.h"

#include "dlistint.h"
#include "dlistfn.h"
#include "lcfuncs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\i386\dl_pdata.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: dl_pdata.inc
;
; OpenGL display-list macros/equates for i386.
;
; Created: 09/20/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;

if __GLLE_POLYDATA_C3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_C3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        0
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_N3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_C3F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_C3F_N3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_C4F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_C4F_N3F_V3F
    __DL_PDATA_T2F      =        0
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        1
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        0
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_C3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_C3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        0
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_N3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_C3F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_C3F_N3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        1
    __DL_PDATA_C4F      =        0
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

if __GLLE_POLYDATA_T2F_C4F_N3F_V3F
;;    __DL_PDATA_NAME     =        __glle_PolyData_T2F_C4F_N3F_V3F
    __DL_PDATA_T2F      =        1
    __DL_PDATA_C3F      =        0
    __DL_PDATA_C4F      =        1
    __DL_PDATA_N3F      =        1
    __DL_PDATA_V2F      =        0
    __DL_PDATA_V3F      =        1
endif

;; Compute record size, pd flags and pa flags

if __DL_PDATA_T2F
    __DL_PDATA_SIZE_T       =     __PDATA_SIZE_T2F
    __DL_PDATA_PD_FLAGS_T   =     __PDATA_PD_FLAGS_T2F
    __DL_PDATA_PA_FLAGS_T   =     __PDATA_PA_FLAGS_T2F
else
    __DL_PDATA_SIZE_T       =     0
    __DL_PDATA_PD_FLAGS_T   =     0
    __DL_PDATA_PA_FLAGS_T   =     0
endif

if __DL_PDATA_C3F
    __DL_PDATA_SIZE_C       =     __PDATA_SIZE_C3F
    __DL_PDATA_PD_FLAGS_C   =     __PDATA_PD_FLAGS_C3F
    __DL_PDATA_PA_FLAGS_C   =     __PDATA_PA_FLAGS_C3F
elseif __DL_PDATA_C4F
    __DL_PDATA_SIZE_C       =     __PDATA_SIZE_C4F
    __DL_PDATA_PD_FLAGS_C   =     __PDATA_PD_FLAGS_C4F
    __DL_PDATA_PA_FLAGS_C   =     __PDATA_PA_FLAGS_C4F
else
    __DL_PDATA_SIZE_C       =     0
    __DL_PDATA_PD_FLAGS_C   =     0
    __DL_PDATA_PA_FLAGS_C   =     0
endif

if __DL_PDATA_N3F
    __DL_PDATA_SIZE_N       =     __PDATA_SIZE_N3F
    __DL_PDATA_PD_FLAGS_N   =     __PDATA_PD_FLAGS_N3F
    __DL_PDATA_PA_FLAGS_N   =     __PDATA_PA_FLAGS_N3F
else
    __DL_PDATA_SIZE_N       =     0
    __DL_PDATA_PD_FLAGS_N   =     0
    __DL_PDATA_PA_FLAGS_N   =     0
endif

if __DL_PDATA_V2F
    __DL_PDATA_SIZE_V       =     __PDATA_SIZE_V2F
    __DL_PDATA_PD_FLAGS_V   =     __PDATA_PD_FLAGS_V2F
    __DL_PDATA_PA_FLAGS_V   =     __PDATA_PA_FLAGS_V2F
elseif __DL_PDATA_V3F
    __DL_PDATA_SIZE_V       =     __PDATA_SIZE_V3F
    __DL_PDATA_PD_FLAGS_V   =     __PDATA_PD_FLAGS_V3F
    __DL_PDATA_PA_FLAGS_V   =     __PDATA_PA_FLAGS_V3F
else
    __DL_PDATA_SIZE_V       =     0
    __DL_PDATA_PD_FLAGS_V   =     0
    __DL_PDATA_PA_FLAGS_V   =     0
endif

__DL_PDATA_SIZE             =     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N+__DL_PDATA_SIZE_V)
__DL_PDATA_PD_FLAGS         =     (__DL_PDATA_PD_FLAGS_T OR __DL_PDATA_PD_FLAGS_C OR __DL_PDATA_PD_FLAGS_N OR __DL_PDATA_PD_FLAGS_V)
__DL_PDATA_PA_FLAGS         =     (__DL_PDATA_PA_FLAGS_T OR __DL_PDATA_PA_FLAGS_C OR __DL_PDATA_PA_FLAGS_N OR __DL_PDATA_PA_FLAGS_V)

__DL_PDATA_TEXTURE_OFFSET   =     (0)
__DL_PDATA_COLOR_OFFSET	    =     (__DL_PDATA_SIZE_T)
__DL_PDATA_NORMAL_OFFSET    =     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C)
__DL_PDATA_VERTEX_OFFSET    =     (__DL_PDATA_SIZE_T+__DL_PDATA_SIZE_C+__DL_PDATA_SIZE_N)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\dlist\i386\dl_optx.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: dl_opt.asm
;
; OpenGL display-list function entries for i386.
;
; Created: 09/20/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small, pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include ks386.inc
        include gli386.inc
	PROFILE = 0
	include profile.inc
        .list

	OPTION PROLOGUE:NONE
	OPTION EPILOGUE:NONE

@PolyArrayFlushPartialPrimitive@0 PROTO SYSCALL
__imp__OutputDebugStringA@4 PROTO SYSCALL

    .data

ifdef DBG
    warningStr  db  'Display list: playing back POLYDATA outside BEGIN!', 13, 10, 0
endif

    .code

__GL_PDATA_FUNC MACRO name
public @&name&@8
@&name&@8 PROC

        PROF_ENTRY

        mov     eax, [ecx].GC_paTeb   ;; eax = pa
        push    ebx
        push    esi
        push    edi

if __DL_PDATA_C3F
        mov     ecx, [ecx].GC_alphaVertexScale
endif

@again:

        ;; if (pa->flags & POLYARRAY_IN_BEGIN) {
        ;;      pd = pa->pdNextVertex++;
        ;;      pa->flags |= __DL_PDATA_PA_FLAGS;

        mov     ebx, [eax].PA_flags         ;; ebx = flags
        mov     esi, [eax].PA_pdNextVertex  ;; esi = pd
        test    ebx, POLYARRAY_IN_BEGIN
        lea     edi, [esi + sizeof_POLYDATA]
        je      @notInBegin

        mov     [eax].PA_pdNextVertex, edi
        or      ebx, __DL_PDATA_PA_FLAGS

        ;; pd->flags |= __DL_PDATA_PD_FLAGS;

        mov     edi, [esi].PD_flags
        mov     [eax].PA_flags, ebx
        or      edi, __DL_PDATA_PD_FLAGS


if __DL_PDATA_C3F
        ;; pd->color[0].a = gc->alphaVertexScale;

        mov     [esi][PD_colors0 + 12], ecx
endif


;;
;; CACHE !!!
;;
;; In the logic below, we try to fill cache lines before we need them
;; by reading into registers that to not use the contents that they
;; fetched.  Unfortunatly, the data in the display list is not cached-
;; aligned, so this will be hit-and-miss.  It does, however, make a
;; measurable difference.
;;


if __DL_PDATA_T2F
        ;; pa->pdCurTexture = pd;
        mov      [eax].PA_pdCurTexture, esi
        mov      ecx, [edx][__DL_PDATA_TEXTURE_OFFSET + 0]  ;; fill cache
endif

if __DL_PDATA_C3F OR __DL_PDATA_C4F
        ;; pa->pdCurColor   = pd;
        mov      [eax].PA_pdCurColor, esi
        mov      ebx, [edx][__DL_PDATA_COLOR_OFFSET + 0]    ;; fill cache
endif

if __DL_PDATA_N3F
        ;; pa->pdCurNormal  = pd;
        mov      [eax].PA_pdCurNormal, esi
        mov      ecx, [edx][__DL_PDATA_NORMAL_OFFSET + 0]   ;; fill cache
endif

if __DL_PDATA_V2F or __DL_PDATA_V3F
        mov      ebx, [edx][__DL_PDATA_VERTEX_OFFSET + 0]   ;; fill cache
endif

        ;; finally, store pd flags:
    
        mov    [esi].PD_flags, edi

;; Update pd attributes.

        ;; constant: esi, edi, eax, edx
        ;; free:     ebx, ecx

if __DL_PDATA_T2F
	;; Texture coord
	;; pd->texture.x = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->x;
	;; pd->texture.y = ((__GLcoord *) &PC[__DL_PDATA_TEXTURE_OFFSET])->y;
	;; pd->texture.z = __glZero;
	;; pd->texture.w = __glOne;

        mov     ebx, [edx][__DL_PDATA_TEXTURE_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_TEXTURE_OFFSET + 4]
        mov     [esi][PD_texture + 0 ], ebx
        mov     [esi][PD_texture + 4 ], ecx
        mov     DWORD PTR [esi][PD_texture + 8 ], 0
        mov     DWORD PTR [esi][PD_texture + 12], __FLOAT_ONE;
endif

if __DL_PDATA_C3F
	;; Color
	;; pd->color[0].r = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->r;
	;; pd->color[0].g = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->g;
	;; pd->color[0].b = ((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET])->b;

        mov     ebx, [edx][__DL_PDATA_COLOR_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_COLOR_OFFSET + 4]
        mov     edi, [edx][__DL_PDATA_COLOR_OFFSET + 8]
        mov     [esi][PD_colors0 + 0 ], ebx
        mov     [esi][PD_colors0 + 4 ], ecx
        mov     [esi][PD_colors0 + 8 ], edi
elseif __DL_PDATA_C4F
	;; Color
	;; pd->color[0] = *((__GLcolor *) &PC[__DL_PDATA_COLOR_OFFSET]);

        mov     ebx, [edx][__DL_PDATA_COLOR_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_COLOR_OFFSET + 4]
        mov     [esi][PD_colors0 + 0 ], ebx
        mov     [esi][PD_colors0 + 4 ], ecx
        mov     ebx, [edx][__DL_PDATA_COLOR_OFFSET + 8]
        mov     ecx, [edx][__DL_PDATA_COLOR_OFFSET + 12]
        mov     [esi][PD_colors0 + 8 ], ebx
        mov     [esi][PD_colors0 + 12], ecx

endif

if __DL_PDATA_N3F
	;; Normal
	;; pd->normal.x = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->x;
	;; pd->normal.y = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->y;
	;; pd->normal.z = ((__GLcoord *) &PC[__DL_PDATA_NORMAL_OFFSET])->z;

        mov     ebx, [edx][__DL_PDATA_NORMAL_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_NORMAL_OFFSET + 4]
        mov     edi, [edx][__DL_PDATA_NORMAL_OFFSET + 8]
        mov     [esi][PD_normal + 0 ], ebx
        mov     [esi][PD_normal + 4 ], ecx
        mov     [esi][PD_normal + 8 ], edi            
endif

if __DL_PDATA_V2F
        ;; Vertex
        ;; pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	;; pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	;; pd->obj.z = __glZero;
	;; pd->obj.w = __glOne;

        mov     ebx, [edx][__DL_PDATA_VERTEX_OFFSET + 0]
        mov     ecx, [edx][__DL_PDATA_VERTEX_OFFSET + 4]
        mov     [esi][PD_obj + 0 ], ebx
        mov     [esi][PD_obj + 4 ], ecx
        mov     DWORD PTR [esi][PD_OBJ + 8 ], 0
        mov     DWORD PTR [esi][PD_obj + 12], __FLOAT_ONE

elseif __DL_PDATA_V3F
	;; Vertex
	;; pd->obj.x = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->x;
	;; pd->obj.y = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->y;
	;; pd->obj.z = ((__GLcoord *) &PC[__DL_PDATA_VERTEX_OFFSET])->z;
	;; pd->obj.w = __glOne;

        mov     ebx, [__DL_PDATA_VERTEX_OFFSET + 0][edx]
        mov     ecx, [__DL_PDATA_VERTEX_OFFSET + 4][edx]
        mov     edi, [__DL_PDATA_VERTEX_OFFSET + 8][edx]
        mov     [esi][PD_obj + 0 ], ebx
        mov     [esi][PD_obj + 4 ], ecx
        mov     [esi][PD_obj + 8 ], edi
        mov     DWORD PTR [esi][PD_obj + 12], __FLOAT_ONE
endif

	;; pd[1].flags = 0;
	;; if (pd >= pa->pdFlush)
	;;    PolyArrayFlushPartialPrimitive();

        mov     ebx, [eax].PA_pdFlush
        mov     DWORD PTR [esi][sizeof_POLYDATA + PD_flags], 0
        cmp     ebx, esi

        mov ebx, [edx - 4]
        mov ecx, [edx + __DL_PDATA_SIZE]

        ja      @noFlush


        push    esi
	push    edi
	push    eax
	push    ebx
	push    ecx
        push    edx
        call    @PolyArrayFlushPartialPrimitive@0
        pop     edx
	pop     ecx
	pop     ebx
	pop     eax
	pop     edi
	pop     esi

@noFlush:

        cmp     ebx, ecx
        jne     @doExit

        lea     edx, [edx + __DL_PDATA_SIZE + 4]
if __DL_PDATA_C3F
        mov     ecx, [esi][PD_colors0 + 12]
endif

        jmp     @again


@doExit:
        lea     eax, [edx + __DL_PDATA_SIZE]
        pop     edi
        pop     esi
        pop     ebx
        ret     0

@notInBegin:

ifdef DBG
        push    edx

        push    offset warningStr
        call    DWORD PTR __imp__OutputDebugStringA@4

        pop     edx
endif

        lea     eax, [edx + __DL_PDATA_SIZE]
        pop     edi
        pop     esi
        pop     ebx
        ret     0

@&name&@8 ENDP

ENDM


;; Define fast playback routines for PolyData records.

__GLLE_POLYDATA_C3F_V3F         =     0
__GLLE_POLYDATA_N3F_V3F         =     0
__GLLE_POLYDATA_C3F_N3F_V3F     =     0
__GLLE_POLYDATA_C4F_N3F_V3F     =     0
__GLLE_POLYDATA_T2F_V3F         =     0
__GLLE_POLYDATA_T2F_C3F_V3F     =     0
__GLLE_POLYDATA_T2F_N3F_V3F     =     0
__GLLE_POLYDATA_T2F_C3F_N3F_V3F =     0
__GLLE_POLYDATA_T2F_C4F_N3F_V3F =     0


__GLLE_POLYDATA_C3F_V3F		=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_C3F_V3F>
__GLLE_POLYDATA_C3F_V3F         =     0

__GLLE_POLYDATA_N3F_V3F		=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_N3F_V3F>
__GLLE_POLYDATA_N3F_V3F         =     0

__GLLE_POLYDATA_C3F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_C3F_N3F_V3F>
__GLLE_POLYDATA_C3F_N3F_V3F     =     0

__GLLE_POLYDATA_C4F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_C4F_N3F_V3F>
__GLLE_POLYDATA_C4F_N3F_V3F     =     0

__GLLE_POLYDATA_T2F_V3F		=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_V3F>
__GLLE_POLYDATA_T2F_V3F         =     0

__GLLE_POLYDATA_T2F_C3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_C3F_V3F>
__GLLE_POLYDATA_T2F_C3F_V3F     =     0

__GLLE_POLYDATA_T2F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_N3F_V3F>
__GLLE_POLYDATA_T2F_N3F_V3F     =     0

__GLLE_POLYDATA_T2F_C3F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_C3F_N3F_V3F>
__GLLE_POLYDATA_T2F_C3F_N3F_V3F =     0

__GLLE_POLYDATA_T2F_C4F_N3F_V3F	=     1
include dl_pdata.inc
__GL_PDATA_FUNC <__glle_PolyData_T2F_C4F_N3F_V3F>
__GLLE_POLYDATA_T2F_C4F_N3F_V3F =     0


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\exts\defs\glxext.h ===
/* *** Incomplete *** */

/*
** GLX Extension Strings
*/
#define GLX_SGI_swap_control    1
#define GLX_SGI_video_sync      1
#define GLX_SGIS_multisample    1
#define GLX_SGI_make_current_read 1 
#define GLX_EXT_visual_rating   1
#define GLX_EXT_visual_info     1
#define GLX_SGI_transparent_pixel 1 


/*
** GLX_SGI_swap_control
*/

/* GLX_SGI_swap_control: Swap modes */
#define GLX_SWAP_DEFAULT_SGI    1
#define GLX_SWAP_MUXPIPE_SGI    2
#define GLX_SWAP_GANG_SGI       3

/* GLX_SGI_swap_control: Mode specific parameters */
#define GLX_MUXPIPE0_SGI        0x1
#define GLX_MUXPIPE1_SGI        0x2
#define GLX_MUXPIPE2_SGI        0x4


/*
** Names for attributes to glXGetConfig.
*/

#define GLX_VISUAL_RATING_EXT   0x20
#define GLX_UGLY_VISUAL_OK_EXT  0x21
#define GLX_X_VISUAL_TYPE_EXT   0x22

#define GLX_SAMPLES_SGIS        100000  /* number of samples per pixel */
#define GLX_SAMPLE_BUFFER_SGIS  100001  /* the number of multisample buffers */

/* GLX_EXT_visual_rating: visual rating tokens */
#define GLX_GOOD_VISUAL_EXT     0x1
#define GLX_BAD_VISUAL_EXT      0x2
#define GLX_UGLY_VISUAL_EXT     0x3

/* GLX_EXT_visual_info: visual type tokens */
#define GLX_TRUE_COLOR_EXT      0x1
#define GLX_DIRECT_COLOR_EXT    0x2
#define GLX_PSEUDO_COLOR_EXT    0x3
#define GLX_STATIC_COLOR_EXT    0x4
#define GLX_GRAY_SCALE_EXT      0x5
#define GLX_STATIC_GRAY_EXT     0x6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\exts\defs\glext.h ===
/* Note: SGI includes definitions for supported extensions in gl.h. */
/* This file is for documentation purposes only		            */

#define GL_EXT_abgr                         1
#define GL_EXT_blend_color                  1
#define GL_EXT_blend_logic_op               1
#define GL_EXT_blend_minmax                 1
#define GL_EXT_blend_subtract               1
#define GL_EXT_convolution                  1
#define GL_EXT_copy_texture		    1
#define GL_EXT_histogram                    1
#define GL_EXT_polygon_offset               1
#define GL_EXT_subtexture                   1
#define GL_EXT_texture                      1
#define GL_EXT_texture_object		    1
#define GL_EXT_texture3D                    1
#define GL_EXT_vertex_array		    1
#define GL_EXT_cmyka			    1
#define GL_EXT_packed_pixels		    1
#define GL_EXT_rescale_normal		    1
#define GL_EXT_visual_info		    1

#define GL_SGI_color_matrix		    1
#define GL_SGI_texture_color_table	    1
#define GL_SGI_color_table		    1
#define GL_SGIS_multisample                 1
#define GL_SGIS_sharpen_texture             1

/* No enums assigned yet */
#define GL_SGIS_texture_filter4		    1
#define GL_SGIS_texture4D		    1
#define GL_SGIX_pixel_texture		    1

/* Not covered; specs are available though */
#define GL_SGIS_texture_lod		    1
#define GL_SGIS_generate_mipmap		    1
#define GL_SGIS_shadow		    	    1
#define GL_SGIS_texture_edge_clamp	    1
#define GL_SGIS_texture_border_clamp	    1

/*************************************************************/

#define GL_DOUBLE_EXT                       0x140A

/* EXT_abgr */
#define GL_ABGR_EXT                         0x8000

/* EXT_blend_color */
#define GL_CONSTANT_COLOR_EXT               0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR_EXT     0x8002
#define GL_CONSTANT_ALPHA_EXT               0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT     0x8004
#define GL_BLEND_COLOR_EXT                  0x8005

/* EXT_blend_minmax */
#define GL_FUNC_ADD_EXT                     0x8006
#define GL_MIN_EXT                          0x8007
#define GL_MAX_EXT                          0x8008
#define GL_BLEND_EQUATION_EXT               0x8009

/* EXT_blend_subtract */
#define GL_FUNC_SUBTRACT_EXT                0x800A
#define GL_FUNC_REVERSE_SUBTRACT_EXT        0x800B

/* EXT_convolution */
#define GL_CONVOLUTION_1D_EXT               0x8010
#define GL_CONVOLUTION_2D_EXT               0x8011
#define GL_SEPARABLE_2D_EXT                 0x8012
#define GL_CONVOLUTION_BORDER_MODE_EXT      0x8013
#define GL_CONVOLUTION_FILTER_SCALE_EXT     0x8014
#define GL_CONVOLUTION_FILTER_BIAS_EXT      0x8015
#define GL_REDUCE_EXT                       0x8016
#define GL_CONVOLUTION_FORMAT_EXT           0x8017
#define GL_CONVOLUTION_WIDTH_EXT            0x8018
#define GL_CONVOLUTION_HEIGHT_EXT           0x8019
#define GL_MAX_CONVOLUTION_WIDTH_EXT        0x801A
#define GL_MAX_CONVOLUTION_HEIGHT_EXT       0x801B
#define GL_POST_CONVOLUTION_RED_SCALE_EXT   0x801C
#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT  0x801E
#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
#define GL_POST_CONVOLUTION_RED_BIAS_EXT    0x8020
#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT  0x8021
#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT   0x8022
#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT  0x8023

/* EXT_histogram */
#define GL_HISTOGRAM_EXT                    0x8024
#define GL_PROXY_HISTOGRAM_EXT              0x8025
#define GL_HISTOGRAM_WIDTH_EXT              0x8026
#define GL_HISTOGRAM_FORMAT_EXT             0x8027
#define GL_HISTOGRAM_RED_SIZE_EXT           0x8028
#define GL_HISTOGRAM_GREEN_SIZE_EXT         0x8029
#define GL_HISTOGRAM_BLUE_SIZE_EXT          0x802A
#define GL_HISTOGRAM_ALPHA_SIZE_EXT         0x802B
#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT     0x802C
#define GL_HISTOGRAM_SINK_EXT               0x802D
#define GL_MINMAX_EXT                       0x802E
#define GL_MINMAX_FORMAT_EXT                0x802F
#define GL_MINMAX_SINK_EXT                  0x8030
#define GL_TABLE_TOO_LARGE_EXT              0x8031

/* EXT_polygon_offset */
#define GL_POLYGON_OFFSET_EXT               0x8037
#define GL_POLYGON_OFFSET_FACTOR_EXT        0x8038
#define GL_POLYGON_OFFSET_BIAS_EXT          0x8039

/* EXT_texture */
#define GL_ALPHA4_EXT                       0x803B
#define GL_ALPHA8_EXT                       0x803C
#define GL_ALPHA12_EXT                      0x803D
#define GL_ALPHA16_EXT                      0x803E
#define GL_LUMINANCE4_EXT                   0x803F
#define GL_LUMINANCE8_EXT                   0x8040
#define GL_LUMINANCE12_EXT                  0x8041
#define GL_LUMINANCE16_EXT                  0x8042
#define GL_LUMINANCE4_ALPHA4_EXT            0x8043
#define GL_LUMINANCE6_ALPHA2_EXT            0x8044
#define GL_LUMINANCE8_ALPHA8_EXT            0x8045
#define GL_LUMINANCE12_ALPHA4_EXT           0x8046
#define GL_LUMINANCE12_ALPHA12_EXT          0x8047
#define GL_LUMINANCE16_ALPHA16_EXT          0x8048
#define GL_INTENSITY_EXT                    0x8049
#define GL_INTENSITY4_EXT                   0x804A
#define GL_INTENSITY8_EXT                   0x804B
#define GL_INTENSITY12_EXT                  0x804C
#define GL_INTENSITY16_EXT                  0x804D
#define GL_RGB2_EXT                         0x804E
#define GL_RGB4_EXT                         0x804F
#define GL_RGB5_EXT                         0x8050
#define GL_RGB8_EXT                         0x8051
#define GL_RGB10_EXT                        0x8052
#define GL_RGB12_EXT                        0x8053
#define GL_RGB16_EXT                        0x8054
#define GL_RGBA2_EXT                        0x8055
#define GL_RGBA4_EXT                        0x8056
#define GL_RGB5_A1_EXT                      0x8057
#define GL_RGBA8_EXT                        0x8058
#define GL_RGB10_A2_EXT                     0x8059
#define GL_RGBA12_EXT                       0x805A
#define GL_RGBA16_EXT                       0x805B
#define GL_TEXTURE_RED_SIZE_EXT             0x805C
#define GL_TEXTURE_GREEN_SIZE_EXT           0x805D
#define GL_TEXTURE_BLUE_SIZE_EXT            0x805E
#define GL_TEXTURE_ALPHA_SIZE_EXT           0x805F
#define GL_TEXTURE_LUMINANCE_SIZE_EXT       0x8060
#define GL_TEXTURE_INTENSITY_SIZE_EXT       0x8061
#define GL_REPLACE_EXT                      0x8062
#define GL_PROXY_TEXTURE_1D_EXT             0x8063
#define GL_PROXY_TEXTURE_2D_EXT             0x8064
#define GL_TEXTURE_TOO_LARGE_EXT            0x8065

/* EXT_texture_object */
#define GL_TEXTURE_PRIORITY_EXT             0x8066
#define GL_TEXTURE_RESIDENT_EXT             0x8067
#define GL_TEXTURE_1D_BINDING_EXT           0x8068
#define GL_TEXTURE_2D_BINDING_EXT           0x8069
#define GL_TEXTURE_3D_BINDING_EXT           0x806A

/* EXT_texture3D */
#define GL_PACK_SKIP_IMAGES_EXT             0x806B
#define GL_PACK_IMAGE_HEIGHT_EXT            0x806C
#define GL_UNPACK_SKIP_IMAGES_EXT           0x806D
#define GL_UNPACK_IMAGE_HEIGHT_EXT          0x806E
#define GL_TEXTURE_3D_EXT                   0x806F
#define GL_PROXY_TEXTURE_3D_EXT             0x8070
#define GL_TEXTURE_DEPTH_EXT                0x8071
#define GL_TEXTURE_WRAP_R_EXT               0x8072
#define GL_MAX_3D_TEXTURE_SIZE_EXT          0x8073

/* EXT_vertex_array */
#define GL_VERTEX_ARRAY_EXT                 0x8074
#define GL_NORMAL_ARRAY_EXT                 0x8075
#define GL_COLOR_ARRAY_EXT                  0x8076
#define GL_INDEX_ARRAY_EXT                  0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT          0x8078
#define GL_EDGE_FLAG_ARRAY_EXT              0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT            0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT            0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT          0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT           0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT            0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT          0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT           0x8080
#define GL_COLOR_ARRAY_SIZE_EXT             0x8081
#define GL_COLOR_ARRAY_TYPE_EXT             0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT           0x8083
#define GL_COLOR_ARRAY_COUNT_EXT            0x8084
#define GL_INDEX_ARRAY_TYPE_EXT             0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT           0x8086
#define GL_INDEX_ARRAY_COUNT_EXT            0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT     0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT     0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT   0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT    0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT       0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT        0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT         0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT         0x808F
#define GL_COLOR_ARRAY_POINTER_EXT          0x8090
#define GL_INDEX_ARRAY_POINTER_EXT          0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT  0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT      0x8093

/* SGIS_multisample */
#define GL_MULTISAMPLE_BIT_EXT              0x20000000
#define GL_MULTISAMPLE_SGIS                 0x809D
#define GL_SAMPLE_ALPHA_TO_MASK_SGIS        0x809E
#define GL_SAMPLE_ALPHA_TO_ONE_SGIS         0x809F
#define GL_SAMPLE_MASK_SGIS                 0x80A0
#define GL_1PASS_SGIS                       0x80A1
#define GL_2PASS_0_SGIS                     0x80A2
#define GL_2PASS_1_SGIS                     0x80A3
#define GL_4PASS_0_SGIS                     0x80A4
#define GL_4PASS_1_SGIS                     0x80A5
#define GL_4PASS_2_SGIS                     0x80A6
#define GL_4PASS_3_SGIS                     0x80A7
#define GL_SAMPLE_BUFFERS_SGIS              0x80A8
#define GL_SAMPLES_SGIS                     0x80A9
#define GL_SAMPLE_MASK_VALUE_SGIS           0x80AA
#define GL_SAMPLE_MASK_INVERT_SGIS          0x80AB
#define GL_SAMPLE_PATTERN_SGIS              0x80AC

/* SGIS_sharpen_texture */
#define GL_LINEAR_SHARPEN_SGIS              0x80AD
#define GL_LINEAR_SHARPEN_ALPHA_SGIS        0x80AE
#define GL_LINEAR_SHARPEN_COLOR_SGIS        0x80AF
#define GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS 0x80B0


/* SGI_color_matrix */
#define GL_COLOR_MATRIX_SGI                 0x80B1
#define GL_COLOR_MATRIX_STACK_DEPTH_SGI     0x80B2
#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI  0x80B4
#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI   0x80B8
#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI  0x80BA
#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB

/* SGI_texture_color_table */
#define GL_TEXTURE_COLOR_TABLE_SGI          0x80BC
#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI    0x80BD
#define GL_TEXTURE_COLOR_TABLE_BIAS_SGI     0x80BE
#define GL_TEXTURE_COLOR_TABLE_SCALE_SGI    0x80BF

/* SGI_color_table */
#define GL_COLOR_TABLE_SGI                  0x80D0
#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
#define GL_PROXY_COLOR_TABLE_SGI            0x80D3
#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
#define GL_COLOR_TABLE_SCALE_SGI            0x80D6
#define GL_COLOR_TABLE_BIAS_SGI             0x80D7
#define GL_COLOR_TABLE_FORMAT_SGI           0x80D8
#define GL_COLOR_TABLE_WIDTH_SGI            0x80D9
#define GL_COLOR_TABLE_RED_SIZE_SGI         0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_SGI       0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_SGI        0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_SGI       0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI   0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI   0x80DF


/*************************************************************/

/* EXT_cmyka */
#define GL_CMYK_EXT                         0x800C
#define GL_CMYKA_EXT                        0x800D
#define GL_PACK_CMYK_HINT_EXT               0x800E
#define GL_UNPACK_CMYK_HINT_EXT             0x800F

/* EXT_packed_pixels */
#define GL_UNSIGNED_BYTE_3_3_2_EXT          0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4_EXT       0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1_EXT       0x8034
#define GL_UNSIGNED_INT_8_8_8_8_EXT         0x8035
#define GL_UNSIGNED_INT_10_10_10_2_EXT      0x8036

/* EXT_rescale_normal */
#define GL_RESCALE_NORMAL_EXT               0x803A

/*************************************************************/

/* SGI_color_matrix */
#define GL_COLOR_MATRIX_SGI                 0
#define GL_COLOR_MATRIX_STACK_DEPTH_SGI     0
#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0
#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI  0
#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0
#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0
#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0
#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI   0
#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0
#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI  0
#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0

/* SGI_color_table */
#define GL_COLOR_TABLE_SGI                  0
#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0
#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0
#define GL_PROXY_COLOR_TABLE_SGI            0
#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0
#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0
#define GL_COLOR_TABLE_SCALE_SGI            0
#define GL_COLOR_TABLE_BIAS_SGI             0
#define GL_COLOR_TABLE_FORMAT_SGI           0
#define GL_COLOR_TABLE_WIDTH_SGI            0
#define GL_COLOR_TABLE_RED_SIZE_SGI         0
#define GL_COLOR_TABLE_GREEN_SIZE_SGI       0
#define GL_COLOR_TABLE_BLUE_SIZE_SGI        0
#define GL_COLOR_TABLE_ALPHA_SIZE_SGI       0
#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI   0
#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI   0

/* SGI_texture_color_table */
#define GL_POST_TEXTURE_FILTER_COLOR_TABLE_SGI 0
#define GL_PROXY_POST_TEXTURE_FILTER_COLOR_TABLE_SGI 0

/* SGIS_texture_filter4 */
#define GL_FILTER4_SGIS                     0
#define GL_TEXTURE_FILTER4_PARAMETERS_SGIS  0

/* SGIS_texture4D */
#define GL_PACK_SKIP_VOLUMES_SGIS           0
#define GL_PACK_IMAGE_DEPTH_SGIS            0
#define GL_UNPACK_SKIP_VOLUMES_SGIS         0
#define GL_UNPACK_IMAGE_DEPTH_SGIS          0
#define GL_TEXTURE_4D_SGIS                  0
#define GL_PROXY_TEXTURE_4D_SGIS            0
#define GL_TEXTURE_4DSIZE_SGIS              0
#define GL_TEXTURE_WRAP_Q_SGIS              0
#define GL_MAX_4D_TEXTURE_SIZE_SGIS         0

/* SGIX_pixel_texture */
#define GL_PIXEL_TEX_GEN_MODE_SGIX          0

/*************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\exts\defs\glxproto.h ===
/* Requests */

/*
** glXVendorPrivate request.
** Used for glXVendorPrivate and glXVendorPrivateWithReply requests.
** GLX vendor private request.  Commands that go over as vendor private GLX 
** protocol requests use this structure.  The glxCode will be one of the 
** X_GLvop opcodes.
*/
typedef struct GLXVendorPrivate {
    CARD8	reqType;
    CARD8	glxCode;
    CARD16	length B16;
    CARD32	vendorCode B32;		/* vendor-specific opcode */
    GLXContextTag contextTag B32;
    /*
    ** More data may follow; this is just the header.
    */
} xGLXVendorPrivateReq;
#define sz_xGLXVendorPrivateReq 12

/*
** glXSwapIntervalSGI (VendorPrivate) request.
*/
typedef struct GLXSwapIntervalSGI {
    CARD8	reqType;
    CARD8	glxCode;
    CARD16	length B16;
    CARD32	vendorCode B32;		/* vendor-specific opcode */
    GLXContextTag contextTag B32;
    CARD32	interval B32;
} xGLXSwapIntervalSGIReq;
#define sz_xGLXSwapIntervalSGIReq 16

/*
** glXMakeCurrentRead request
*/
typedef struct GLXMakeCurrentRead {
    CARD8	reqType;
    CARD8	glxCode;
    CARD16	length B16;
    CARD32	vendorCode B32;		/* vendor-specific opcode */
    GLXContextTag oldContextTag B32;
    GLXDrawable	drawable B32;
    GLXDrawable	readdrawable B32;
    GLXContextID context B32;
} xGLXMakeCurrentReadReq;
#define sz_xGLXMakeCurrentReadReq 20

/************************************************************************/

/* Replies */

typedef struct {
    BYTE	type;			/* X_Reply */
    CARD8	unused;			/* not used */
    CARD16	sequenceNumber B16;
    CARD32	length B32;
    CARD32	pad1 B32;
    CARD32	pad2 B32;
    CARD32	width B32;
    CARD32	height B32;
    CARD32	pad5 B32;
    CARD32	pad6 B32;
} xGLXGetSeparableFilterEXTReply;
#define sz_xGLXGetSeparableFilterEXT 32

typedef struct {
    BYTE	type;			/* X_Reply */
    CARD8	unused;			/* not used */
    CARD16	sequenceNumber B16;
    CARD32	length B32;
    CARD32	pad1 B32;
    CARD32	pad2 B32;
    CARD32	width B32;
    CARD32	height B32;
    CARD32	pad5 B32;
    CARD32	pad6 B32;
} xGLXGetConvolutionFilterEXTReply;
#define sz_xGLXGetConvolutionFilterEXTReply 32

typedef struct {
    BYTE	type;			/* X_Reply */
    CARD8	unused;			/* not used */
    CARD16	sequenceNumber B16;
    CARD32	length B32;
    CARD32	pad1 B32;
    CARD32	pad2 B32;
    CARD32	width B32;
    CARD32	pad4 B32;
    CARD32	pad5 B32;
    CARD32	pad6 B32;
} xGLXGetHistogramEXTReply;
#define sz_xGLXGetHistogramEXTReply 32

typedef struct {
    BYTE	type;			/* X_Reply */
    CARD8	unused;			/* not used */
    CARD16	sequenceNumber B16;
    CARD32	length B32;
    CARD32	pad1 B32;
    CARD32	pad2 B32;
    CARD32	pad3 B32;
    CARD32	pad4 B32;
    CARD32	pad5 B32;
    CARD32	pad6 B32;
} xGLXGetMinmaxEXTReply;
#define sz_xGLXGetMinmaxEXTReply 32


/*
** This reply structure is used for all Vendor Private replies. Vendor
** Private replies can ship up to 24 bytes within the header or can
** be variable sized, in which case, the reply length field indicates
** the number of words of data which follow the header.
*/
typedef struct {
    BYTE	type;			/* X_Reply */
    CARD8	unused;			/* not used */
    CARD16	sequenceNumber B16;
    CARD32	length B32;
    CARD32	retval B32;
    CARD32	size B32;
    CARD32	pad3 B32;		
    CARD32	pad4 B32;	
    CARD32	pad5 B32;
    CARD32	pad6 B32;
} xGLXVendorPrivReply;
#define sz_xGLXVendorPrivReply 32

typedef struct {
    BYTE	type;			/* X_Reply */
    CARD8	unused;			/* not used */
    CARD16	sequenceNumber B16;
    CARD32	length B32;
    GLXContextTag contextTag B32;
    CARD32	writeVid B32;
    CARD32	writeType B32;
    CARD32	readVid B32;
    CARD32	readType B32;
    CARD32	pad6 B32;
} xGLXMakeCurrentReadReply;
#define sz_xGLXMakeCurrentReadReply 32

/************************************************************************/

/*
** Data that is specific to a glTexSubImage3D and 4D calls.  The
** data is sent in the following order:
** 	Render or RenderLarge header
** 	Pixel header
** 	TexSubImage header
** When a glTexSubImage3D call is made, the woffset and size4d fields 
** are unexamined by the server and are considered to be padding.
*/
#define __GLX_TEXSUBIMAGE_3D4D_HDR	\
    CARD32	target B32;	\
    CARD32	level B32;	\
    CARD32	xoffset B32;	\
    CARD32	yoffset B32;	\
    CARD32	zoffset B32;	\
    CARD32	woffset B32;	\
    CARD32	width B32;	\
    CARD32	height B32;	\
    CARD32	depth B32;	\
    CARD32	size4d B32;	\
    CARD32	format B32;	\
    CARD32	type B32;	\
    CARD32	nullImage	\

#define __GLX_TEXSUBIMAGE_3D4D_HDR_SIZE 52

#define __GLX_TEXSUBIMAGE_3D4D_CMD_HDR_SIZE \
    (__GLX_RENDER_HDR_SIZE + __GLX_PIXEL_3D4D_HDR_SIZE + \
		__GLX_TEXSUBIMAGE_3D4D_HDR_SIZE)

#define __GLX_TEXSUBIMAGE_3D4D_CMD_DISPATCH_HDR_SIZE \
    (__GLX_PIXEL_3D4D_HDR_SIZE + __GLX_TEXSUBIMAGE_3D4D_HDR_SIZE)

typedef struct {
    __GLX_RENDER_HDR;
    __GLX_PIXEL_3D4D_HDR;
    __GLX_TEXSUBIMAGE_3D4D_HDR;
} __GLXtexSubImage3D4DHeader;

typedef struct {
    __GLX_RENDER_LARGE_HDR;
    __GLX_PIXEL_3D4D_HDR;
    __GLX_TEXSUBIMAGE_3D4D_HDR;
} __GLXtexSubImage3D4DLargeHeader;

typedef struct {
    __GLX_PIXEL_3D4D_HDR;
    __GLX_TEXSUBIMAGE_3D4D_HDR;
} __GLXdispatchTexSubImage3D4DHeader;

/*
** Data that is specific to a glConvolutionFilter1DEXT or glConvolutionFilter2DEXT
** call.  The data is sent in the following order:
** 	Render or RenderLarge header
** 	Pixel header
** 	TexImage header
** When a glConvolutionFilter1D call the height field is unexamined by the server.
*/
#define __GLX_CONV_FILT_HDR	\
    CARD32	target B32;	\
    CARD32	internalformat B32;	\
    CARD32	width B32;	\
    CARD32	height B32;	\
    CARD32	format B32;	\
    CARD32	type B32

#define __GLX_CONV_FILT_HDR_SIZE 24

#define __GLX_CONV_FILT_CMD_HDR_SIZE \
    (__GLX_RENDER_HDR_SIZE + __GLX_PIXEL_HDR_SIZE + __GLX_CONV_FILT_HDR_SIZE)

#define __GLX_CONV_FILT_CMD_DISPATCH_HDR_SIZE \
    (__GLX_PIXEL_HDR_SIZE + __GLX_CONV_FILT_HDR_SIZE)
typedef struct {
    __GLX_RENDER_HDR;
    __GLX_PIXEL_HDR;
    __GLX_CONV_FILT_HDR;
} __GLXConvolutionFilterHeader;

typedef struct {
    __GLX_RENDER_LARGE_HDR;
    __GLX_PIXEL_HDR;
    __GLX_CONV_FILT_HDR;
} __GLXConvolutionFilterLargeHeader;

typedef struct {
    __GLX_PIXEL_HDR;
    __GLX_CONV_FILT_HDR;
} __GLXdispatchConvolutionFilterHeader;


/*****************************************************************************/

/* Opcodes for GLX commands */

#define X_GLXVendorPrivate               16
#define X_GLXVendorPrivateWithReply      17
#define X_GLXQueryServerString           19
#define X_GLXClientInfo                  20


/* Opcodes for single commands (part of GLX command space) */

#define X_GLrop_BlendColorEXT              4096
#define X_GLrop_BlendEquationEXT           4097
#define X_GLrop_PolygonOffsetEXT           4098
#define X_GLrop_TexSubImage1DEXT           4099
#define X_GLrop_TexSubImage2DEXT           4100
#define X_GLrop_SampleMaskSGIS             2048
#define X_GLrop_SamplePatternSGIS          2049
#define X_GLrop_TagSampleBufferSGIX        2050
#define X_GLrop_ConvolutionFilter1DEXT     4101
#define X_GLrop_ConvolutionFilter2DEXT     4102
#define X_GLrop_ConvolutionParameterfEXT   4103
#define X_GLrop_ConvolutionParameterfvEXT  4104
#define X_GLrop_ConvolutionParameteriEXT   4105
#define X_GLrop_ConvolutionParameterivEXT  4106
#define X_GLrop_CopyConvolutionFilter1DEXT  4107
#define X_GLrop_CopyConvolutionFilter2DEXT  4108
#define X_GLrop_SeparableFilter2DEXT       4109
#define X_GLrop_HistogramEXT               4110
#define X_GLrop_MinmaxEXT                  4111
#define X_GLrop_ResetHistogramEXT          4112
#define X_GLrop_ResetMinmaxEXT             4113
#define X_GLrop_TexImage3DEXT              4114
#define X_GLrop_TexSubImage3DEXT           4115
#define X_GLrop_DetailTexFuncSGIS          2051
#define X_GLrop_SharpenTexFuncSGIS         2052
#define X_GLrop_BindTextureEXT             4117
#define X_GLrop_PrioritizeTexturesEXT      4118
#define X_GLrop_ColorTableSGI              2053
#define X_GLrop_ColorTableParameterfvSGI   2054
#define X_GLrop_ColorTableParameterivSGI   2055
#define X_GLrop_CopyColorTableSGI          2056
#define X_GLrop_TexColorTableParameterfvSGI  2057
#define X_GLrop_TexColorTableParameterivSGI  2058


/* Opcodes for vendor private commands */

#define X_GLvop_GetConvolutionFilterEXT      1
#define X_GLvop_GetConvolutionParameterfvEXT    2
#define X_GLvop_GetConvolutionParameterivEXT    3
#define X_GLvop_GetSeparableFilterEXT        4
#define X_GLvop_GetHistogramEXT              5
#define X_GLvop_GetHistogramParameterfvEXT    6
#define X_GLvop_GetHistogramParameterivEXT    7
#define X_GLvop_GetMinmaxEXT                 8
#define X_GLvop_GetMinmaxParameterfvEXT      9
#define X_GLvop_GetMinmaxParameterivEXT     10
#define X_GLvop_GetDetailTexFuncSGIS       4096
#define X_GLvop_GetSharpenTexFuncSGIS      4097
#define X_GLvop_AreTexturesResidentEXT      11
#define X_GLvop_DeleteTexturesEXT           12
#define X_GLvop_GenTexturesEXT              13
#define X_GLvop_IsTextureEXT                14
#define X_GLvop_GetColorTableSGI           4098
#define X_GLvop_GetColorTableParameterfvSGI  4099
#define X_GLvop_GetColorTableParameterivSGI  4100
#define X_GLvop_GetTexColorTableParameterfvSGI  4101
#define X_GLvop_GetTexColorTableParameterivSGI  4102


/* Opcodes for GLX vendor private commands */

#define X_GLXvop_SwapIntervalSGI            65536
#define X_GLXvop_MakeCurrentReadSGI         65537
#define X_GLXvop_CreateGLXVideoSourceSGIX   65538
#define X_GLXvop_DestroyGLXVideoSourceSGIX  65539
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glexts\precomp.c ===
#include <stddef.h>
#include <excpt.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrmsg.h>
#include <ntstatus.h>
#include <ntdbg.h>

#include <windows.h>
#include <winerror.h>

#include <ntsdexts.h>
#define NOEXTAPI
#include <wdbgexts.h>

#include <gl\gl.h>
#include <gldrv.h>
#include <types.h>
#include <context.h>

#include "hacklocl.h"

#include "dbgfns.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glexts\dbgfns.h ===
/******************************Module*Header*******************************\
* Module Name: dbgfns.h
*
* Debugger extensions helper routines
*
* Created: 26-Jan-95
* Author: Drew Bliss
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#ifndef __DBGFNS_H__
#define __DBGFNS_H__

#define DBG_ENTRY(name) \
void name(HANDLE hCurrentProcess, HANDLE hCurrentThread, DWORD dwCurrentPc, \
          PWINDBG_EXTENSION_APIS pwea, LPSTR pszArguments)

#define PRINT           pwea->lpOutputRoutine
#define GET_SYMBOL      pwea->lpGetSymbolRoutine
#define GET_EXPR        pwea->lpGetExpressionRoutine

#define GM_OBJ(src, obj) \
    GetMemory(pwea, hCurrentProcess, src, (PVOID)&(obj), sizeof(obj))
#define GM_BLOCK(src, dst, cb) \
    GetMemory(pwea, hCurrentProcess, src, dst, cb)

BOOL GetMemory(PWINDBG_EXTENSION_APIS pwea,
               HANDLE hCurrentProcess,
               DWORD dwSrc, PVOID pvDst, DWORD cb);

#define CURRENT_TEB() GetTeb(pwea, hCurrentProcess, hCurrentThread)

PTEB GetTeb(PWINDBG_EXTENSION_APIS pwea,
            HANDLE hCurrentProcess,
            HANDLE hThread);

#define IS_CSR_SERVER_THREAD() \
    IsCsrServerThread(pwea, hCurrentProcess, hCurrentThread)

BOOL IsCsrServerThread(PWINDBG_EXTENSION_APIS pwea,
                       HANDLE hCurrentProcess,
                       HANDLE hThread);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glexts\dbgfns.c ===
/******************************Module*Header*******************************\
* Module Name: dbgfns.c
*
* Debugger extensions helper routines
*
* Created: 26-Jan-95
* Author: Drew Bliss
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.c"
#pragma hdrstop

/******************************Public*Routine******************************\
*
* GetMemory
*
* Reads a value from debuggee memory
*
* History:
*  Tue Jan 17 14:35:24 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL GetMemory(PWINDBG_EXTENSION_APIS pwea,
               HANDLE hCurrentProcess,
               DWORD dwSrc, PVOID pvDst, DWORD cb)
{
    BOOL fRet;
    
    try
    {
        if (pwea->nSize >= sizeof(WINDBG_EXTENSION_APIS))
        {
            fRet = (BOOL)pwea->lpReadProcessMemoryRoutine(dwSrc, pvDst,
                                                          cb, NULL);
        }
        else
        {
            fRet = NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                                                  (LPVOID)dwSrc,
                                                  pvDst, cb, NULL));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        PRINT("Invalid address %p\n", dwSrc);
        return FALSE;
    }

    if (!fRet)
    {
        PRINT("Unable to read memory at address %p\n", dwSrc);
    }

    return fRet;
}

/******************************Public*Routine******************************\
*
* GetTeb
*
* Retrieves the TEB pointer for the given thread
* Returns a pointer to a static TEB so subsequent calls
* will overwrite TEB information
*
* History:
*  Thu Jan 26 13:47:20 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PTEB GetTeb(PWINDBG_EXTENSION_APIS pwea,
            HANDLE hCurrentProcess,
            HANDLE hThread)
{
    static TEB tebLocal;
    NTSTATUS nts;
    THREAD_BASIC_INFORMATION tbi;

    nts = NtQueryInformationThread(hThread, ThreadBasicInformation,
                                   &tbi, sizeof(tbi), NULL);
    if (NT_SUCCESS(nts))
    {
        if (!GM_OBJ((DWORD)tbi.TebBaseAddress, tebLocal))
        {
            return NULL;
        }
        else
        {
            return &tebLocal;
        }
    }
    else
    {
        PRINT("Unable to retrieve thread information for %p\n", hThread);
        return NULL;
    }
}

/******************************Public*Routine******************************\
*
* IsCsrServerThread
*
* Determines whether the given thread is a CSR server thread or not
* Consider - Is this reliable?
*
* History:
*  Tue Jan 31 13:38:50 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL IsCsrServerThread(PWINDBG_EXTENSION_APIS pwea,
                       HANDLE hCurrentProcess,
                       HANDLE hThread)
{
    PTEB pteb;
    PCSR_QLPC_TEB pqteb;

    pteb = GetTeb(pwea, hCurrentProcess, hThread);
    if (pteb == NULL)
    {
        return FALSE;
    }

    pqteb = (PCSR_QLPC_TEB)&pteb->CsrQlpcTeb;
    if (pqteb->ClientThread != NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glexts\hacklocl.h ===
/******************************Module*Header*******************************\
* Module Name: local.h                                                     *
*                                                                          *
* Definitions needed for client side objects and attribute caching.        *
*                                                                          *
* Modified: 3-Aug-1992 22:35:30 by Gerrit van Wingerden [gerritv]          *
*   Added client side transform support.                                   *
*                                                                          *
* Created: 30-May-1991 21:55:01                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

/**************************************************************************\
 *
 * Local handle macros
 *
\**************************************************************************/

// Handle uniqueness is nice to check but an unnecesary performance cost in
// a free build.

// To match the uniqness field:  If the handle uniqness == 0, let it through
// anyway.  This is a method for WOW to only keep track of the low 16 bits but
// still get reasonable performance.  Even if a 32 bit app does this, all it
// can do is hose it self, not the system or another app.

#define INDEX_MASK  0xFFFF
#define UNIQ_SHIFT  16
#define UNIQ_MASK   0xFFFF
#define HIPART(x) *(((USHORT *) &(x))+1)
#define MATCHUNIQ(plhe,h) ((USHORT) plhe->iUniq == HIPART(h))
#define MASKINDEX(h) ((UINT)h & INDEX_MASK)
#define LHANDLE(i)  (i+((ULONG)pLocalTable[i].iUniq<<UNIQ_SHIFT))

//!!!XXX -- Do we really need typing?  Not really, but we may add more
//!!!XXX    later.  So eventually we might take it out, but its nice for now.

// Define the types of local objects.

enum LO_TYPE
{
    LO_NULL,
    LO_RC,
    LO_LAST
};

#define INVALID_INDEX 0xFFFFFFFFL
#define COMMIT_COUNT  (4096/sizeof(LHE))
#define MAX_HANDLES (16384/COMMIT_COUNT)*COMMIT_COUNT

// Define a Local Handle Entry.  Our Local Handle Table, pLocalTable, is an
// array of these.

typedef struct _LHE
{
    ULONG  hgre;        // GRE Handle.
    USHORT cRef;        // Reference count of the object.
    BYTE   iType;       // Object type.
    BYTE   iUniq;       // Handle uniqueness field.  Always non-zero.
    PVOID  pv;          // Pointer to local object.
    ULONG  metalink;    // Non-zero if object is a "metafile friend".
                        // Points to a metafile DC object if it's a metafile.
                        // Also links the free list.
    DWORD  tidOwner;    // Per-thread lock owner.
    LONG   cLock;       // Lock count.
} LHE,*PLHE;

extern LHE                  *pLocalTable;   // Points to handle table.
extern ULONG                 iFreeLhe;      // Identifies a free handle index.
extern ULONG                 cLheCommitted; // Count of LHEs with committed RAM.
extern CRITICAL_SECTION      semLocal;      // Semaphore for handle allocation.
extern CRITICAL_SECTION      wfo_cs;        // Semaphore for wglUseFontOutlines


// Semaphore utilities

#define INITIALIZECRITICALSECTION(psem) InitializeCriticalSection((psem))
#define ENTERCRITICALSECTION(hsem)      EnterCriticalSection((hsem))
#define LEAVECRITICALSECTION(hsem)      LeaveCriticalSection((hsem))
#define DELETECRITICALSECTION(psem)     DeleteCriticalSection((psem))

// Local data structures

// Maximum OpenGL driver name

#define MAX_GLDRIVER_NAME   MAX_PATH

// GetCurrentThreadID will never return this value

#define INVALID_THREAD_ID   0

// Shared section size

#define SHARED_SECTION_SIZE     8192

// Driver context function prototypes

typedef BOOL            (APIENTRY *PFN_DRVVALIDATEVERSION) (ULONG);
typedef VOID            (APIENTRY *PFN_DRVSETCALLBACKPROCS)(INT, PROC *);

// Driver data

typedef struct _GLDRIVER {
    HINSTANCE             hModule;             // Module handle

    // Driver function pointers

    // Required
    DHGLRC          (APIENTRY *pfnDrvCreateContext)(HDC);
    BOOL            (APIENTRY *pfnDrvDeleteContext)(DHGLRC);
    PGLCLTPROCTABLE (APIENTRY *pfnDrvSetContext)(HDC, DHGLRC,
                                                 PFN_SETPROCTABLE);
    BOOL            (APIENTRY *pfnDrvReleaseContext)(DHGLRC);

    // Optional
    BOOL            (APIENTRY *pfnDrvCopyContext)(DHGLRC, DHGLRC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateLayerContext)(HDC, int);
    BOOL            (APIENTRY *pfnDrvShareLists)(DHGLRC, DHGLRC);
    PROC            (APIENTRY *pfnDrvGetProcAddress)(LPCSTR);
    BOOL            (APIENTRY *pfnDrvDescribeLayerPlane)(HDC, INT, INT, UINT,
                                                      LPLAYERPLANEDESCRIPTOR);
    INT             (APIENTRY *pfnDrvSetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT,
                                                             CONST COLORREF *);
    INT             (APIENTRY *pfnDrvGetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT, COLORREF *);
    BOOL            (APIENTRY *pfnDrvRealizeLayerPalette)(HDC, INT, BOOL);
    BOOL            (APIENTRY *pfnDrvSwapLayerBuffers)(HDC, UINT);
    
#if defined(_CLIENTSIDE_)
    LONG            (APIENTRY *pfnDrvDescribePixelFormat)(HDC, LONG, ULONG,
                                                      PIXELFORMATDESCRIPTOR *);
    BOOL            (APIENTRY *pfnDrvSetPixelFormat)(HDC, LONG);
    BOOL            (APIENTRY *pfnDrvSwapBuffers)(HDC);
#endif

    struct _GLDRIVER    *pGLDriver;            // Next loaded GL driver
    WCHAR wszDrvName[MAX_GLDRIVER_NAME+1];     // Null terminated unicode
                                               //   driver name
} GLDRIVER, *PGLDRIVER;

extern PGLDRIVER APIENTRY pgldrvLoadInstalledDriver(HDC hdc);


/****************************************************************************/

// Local RC object

#define LRC_IDENTIFIER    0x2043524C    /* 'LRC ' */

typedef struct _LRC {
    DHGLRC    dhrc;             // Driver handle
    HGLRC     hrc;              // Client handle
    int       iPixelFormat;     // Pixel format index
    DWORD     ident;            // LRC_IDENTIFIER
    DWORD     tidCurrent;       // Thread id if the DC is current,
                                //   INVALID_THREAD_ID otherwise
    PGLDRIVER pGLDriver;        // Driver data
    HDC       hdcCurrent;       // hdc associated with the current context

#ifdef GL_METAFILE
    GLuint    uiGlsContext;     // GLS context for metafile RC's
    BOOL      fCapturing;       // GLS is in BeginCapture
    HDC       hdcMeta;          // GLS metafile context, needed even
                                // when the RC is not current
    
    // GLS playback scaling factors
    int iGlsSubtractX;
    int iGlsSubtractY;
    int iGlsNumeratorX;
    int iGlsNumeratorY;
    int iGlsDenominatorX;
    int iGlsDenominatorY;
    int iGlsAddX;
    int iGlsAddY;
    GLfloat fGlsScaleX;
    GLfloat fGlsScaleY;
#endif

    // vertex array data

    void * apVertex;
    void * apNormal;
    void * apColor;
    void * apIndex;
    void * apTexCoord;
    void * apEdgeFlag;

    void *      pfnEnable     ;
    void *     pfnDisable    ;
    void *   pfnIsEnabled  ;
    void * pfnGetBooleanv;
    void *  pfnGetDoublev ;
    void *   pfnGetFloatv  ;
    void * pfnGetIntegerv;
    void *   pfnGetString  ;

    GLubyte *pszExtensions;

#ifdef GL_METAFILE
    XFORM xformMeta;            // World transform storage during GLS blocks
    LPRECTL prclGlsBounds;      // Bounds during GLS recording
#endif
} LRC, *PLRC;

// Declare support functions.

ULONG   iAllocHandle(ULONG iType,ULONG hgre,PVOID pv);
VOID    vFreeHandle(ULONG h);
LONG    cLockHandle(ULONG h);
VOID    vUnlockHandle(ULONG h);

#define GdiSetLastError(x)  SetLastError(x)

// NT 3.51 specific function pointers
extern PROC pfnNtdllCsrClientSendMessage;
extern PROC pfnGdi32pstackConnect;
extern PROC pfnGdi32GdiConvertDC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glexts\glexts.c ===
/******************************Module*Header*******************************\
* Module Name: glexts.c
*
* This file is for debugging tools and extensions.
*
* Created: 17-Jan-95
*  Adapted from gdiexts
* Author: Drew Bliss
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.c"
#pragma hdrstop

char *gaszHelp[] =
{
 "=======================================================================\n"
,"GLEXTS debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"batch                    -- Print current message batching\n"
,"df ptr                   -- Dump a float\n"
,"dd ptr                   -- Dump a double\n"
,"dgc ptr                  -- Dump a __glContext\n"
,"dlrc ptr                 -- Dump an LRC\n"
,"gc                       -- Print current context\n"
,"cgc                      -- Print current context (client side only)\n"
,"sgc                      -- Print current context (server side only)\n"
,"help                     -- This message\n"
,"=======================================================================\n"
,NULL
};

/******************************Public*Routine******************************\
*
* help
*
* Print help
*
* History:
*  Tue Jan 17 14:11:21 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(help)
{
    char **ppsz = gaszHelp;

    while (*ppsz)
    {
        PRINT(*ppsz++);
    }
}

/******************************Public*Routine******************************\
*
* batch
*
* Print current message batching
*
* History:
*  Tue Jan 31 14:03:11 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(batch)
{
    PTEB pteb;
    GLCLTSHAREDSECTIONINFO gssi;
    GLMSGBATCHINFO gmbi;

    pteb = CURRENT_TEB();
    if (pteb == NULL)
    {
        return;
    }

    if (pteb->glSectionInfo == NULL ||
        pteb->glSection == NULL)
    {
        PRINT("No current section\n");
        return;
    }
    
    if (!GM_OBJ((DWORD)pteb->glSectionInfo, gssi) ||
        !GM_OBJ((DWORD)pteb->glSection, gmbi))
    {
        return;
    }

    if (IS_CSR_SERVER_THREAD())
    {
        PRINT("Server-side message batching:\n");
    }
    else
    {
        PRINT("Client-side message batching:\n");
    }

    PRINT("Section size   : 0x%08lX\n", gssi.ulSectionSize);
    PRINT("File mapping   : 0x%p\n", gssi.hFileMap);
    PRINT("Section address: 0x%p\n", gssi.pvSharedMemory);
    PRINT("\n");
    PRINT("Maximum offset : 0x%08lX\n", gmbi.MaximumOffset);
    PRINT("First offset   : 0x%08lX\n", gmbi.FirstOffset);
    PRINT("Next offset    : 0x%08lX\n", gmbi.NextOffset);
    PRINT("Return value   : 0x%08lX\n", gmbi.ReturnValue);
}

/******************************Public*Routine******************************\
*
* df
*
* Print float
*
* History:
*  Tue Jan 17 14:12:19 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(df)
{
    DWORD pf;
    float f;

    pf = GET_EXPR(pszArguments);
    if (!GM_OBJ(pf, f))
    {
        return;
    }
    
    PRINT("%08x %f\n", pf, f);
}

/******************************Public*Routine******************************\
*
* dd
*
* Print double
*
* History:
*  Tue Jan 17 14:12:19 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(dd)
{
    DWORD pd;
    double d;

    pd = GET_EXPR(pszArguments);
    if (!GM_OBJ(pd, d))
    {
        return;
    }
    
    PRINT("%08x %lf\n", pd, d);
}

/******************************Public*Routine******************************\
*
* dgc
*
* Dumps a context
*
* History:
*  Thu Jan 26 13:35:47 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(dgc)
{
    DWORD pgc;
    __GLcontext gc;

    pgc = GET_EXPR(pszArguments);
    if (!GM_OBJ(pgc, gc))
    {
        return;
    }
    
    PRINT("__glContext %p:\n", pgc);
    PRINT("Begin mode       : %d\n", gc.beginMode);
    PRINT("Render mode      : %d\n", gc.renderMode);
    PRINT("Error            : %d\n", gc.error);
    PRINT("Window dimensions: %d x %d\n",
          gc.constants.width, gc.constants.height);
}

/******************************Public*Routine******************************\
*
* dlrc
*
* Dump a client-side RC table entry
*
* History:
*  Tue Jan 31 11:35:46 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(dlrc)
{
    LRC lrc;
    DWORD plrc;

    plrc = GET_EXPR(pszArguments);
    if (!GM_OBJ(plrc, lrc))
    {
        return;
    }
    
    PRINT("Client-side RC %p\n", plrc);
    PRINT("dhrc     : %p\n", lrc.dhrc);
    PRINT("hrc      : %p\n", lrc.hrc);
    PRINT("pf       : %d\n", lrc.iPixelFormat);
    PRINT("tid      : %d\n", lrc.tidCurrent);
    PRINT("hdc      : %p\n", lrc.hdcCurrent);
    PRINT("pglDriver: %p\n", lrc.pGLDriver);
}

/******************************Public*Routine******************************\
*
* cgc
*
* Print current client-side context
*
* History:
*  Thu Jan 26 13:34:49 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(cgc)
{
    PTEB pteb;

    if (IS_CSR_SERVER_THREAD())
    {
        PRINT("Not a client-side thread\n");
        return;
    }
    
    pteb = CURRENT_TEB();
    if (pteb == NULL)
    {
        return;
    }

    PRINT("Current client-side RC is %p\n", pteb->glCurrentRC);
}

/******************************Public*Routine******************************\
*
* sgc
*
* Print current server-side context
*
* History:
*  Tue Jan 31 11:36:21 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(sgc)
{
    PTEB pteb;

    if (!IS_CSR_SERVER_THREAD())
    {
        PRINT("Not a server-side thread\n");
        return;
    }
    
    pteb = CURRENT_TEB();
    if (pteb == NULL)
    {
        return;
    }

    PRINT("Current server-side HRC is %p, context is %p\n",
          pteb->glCurrentRC, pteb->glContext);
}

/******************************Public*Routine******************************\
*
* gc
*
* Calls either cgc or sgc depending on the current thread state
*
* History:
*  Tue Jan 31 14:09:22 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DBG_ENTRY(gc)
{
    if (IS_CSR_SERVER_THREAD())
    {
        sgc(hCurrentProcess, hCurrentThread, dwCurrentPc, pwea, pszArguments);
    }
    else
    {
        cgc(hCurrentProcess, hCurrentThread, dwCurrentPc, pwea, pszArguments);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\cmd\glscat.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glsutil.h"
#include <stdlib.h>
#include <string.h>

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static struct {
    GLubyte **argv;
} global;

static void glscat_configStdio(void) {
    setbuf(stdin, GLS_NONE);
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdin), _O_BINARY);
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

static void glscat_checkError(void) {
    const GLSenum error = glsGetError(GL_TRUE);

    if (error) {
        fprintf(
            stderr,
            "%s fatal: %s\n",
            global.argv[0],
            glsEnumString(GLS_API_GLS, error)
        );
        exit(EXIT_FAILURE);
    }
}

static void glscat_usage(void) {
    fprintf(
        stderr,
        "usage: %s "
        "[-a] [-c] [-d dir]* [-h] [-o out] [-r] [-t type] [in]*\n"
        "    -a: append\n"
        "    -c: copy through context\n"
        "    -d: prepend dir to search path\n"
        "    -h: help\n"
        "    -o: output stream (default: standard output)\n"
        "    -r: recursive copy\n"
        "    -t: type of output stream, one of:\n"
        "            GLS_NONE              (default: same as input stream)\n"
        "            GLS_BINARY_LSB_FIRST  (little-endian binary)\n"
        "            GLS_BINARY_MSB_FIRST  (big-endian binary)\n"
        "            GLS_BINARY_SWAP0      (native binary)\n"
        "            GLS_BINARY_SWAP1      (swapped binary)\n"
        "            GLS_TEXT              (human-editable)\n",
        global.argv[0]
    );
    exit(EXIT_FAILURE);
}

int __MAIN_LINKAGE main(const GLsizei inArgc, GLubyte *inArgv[]) {
    GLint arg;
    GLboolean context = GL_FALSE;
    __GLSstring dir;
    __GLSstring inStream;
    __GLSstring outStream;
    GLboolean recursive = GL_FALSE;
    GLSenum type = GLS_NONE;
    GLbitfield writeFlags = GLS_NONE;

    glscat_configStdio();
    __glsString_init(&dir);
    __glsString_init(&inStream);
    __glsString_init(&outStream);
    global.argv = inArgv;
    glsContext(glsGenContext());
    for (arg = 1 ; arg < inArgc && inArgv[arg][0] == '-' ; ++arg) {
        if (inArgv[arg][2]) glscat_usage();
        switch (inArgv[arg][1]) {
            case 'a':
                writeFlags |= GLS_WRITE_APPEND_BIT;
                break;
            case 'c':
                context = GL_TRUE;
                break;
            case 'd':
                if (++arg >= inArgc) glscat_usage();
                __glsString_assign(&dir, inArgv[arg]);
                __glsString_appendChar(&dir, '/');
                glsReadPrefix(GLS_PREPEND, dir.head);
                break;
            case 'o':
                if (++arg >= inArgc) glscat_usage();
                __glsString_assign(&outStream, inArgv[arg]);
                break;
            case 'r':
                recursive = GL_TRUE;
                break;
            case 't':
                if (++arg >= inArgc) glscat_usage();
                if (
                    !strcmp((const char *)inArgv[arg], "GLS_NONE")
                ) {
                    type = GLS_NONE;
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_LSB_FIRST")
                ) {
                    type = GLS_BINARY_LSB_FIRST;
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_MSB_FIRST")
                ) {
                    type = GLS_BINARY_MSB_FIRST;
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_SWAP0")
                ) {
                    type = glsBinary(GL_FALSE);
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_BINARY_SWAP1")
                ) {
                    type = glsBinary(GL_TRUE);
                } else if (
                    !strcmp((const char *)inArgv[arg], "GLS_TEXT")
                ) {
                    type = GLS_TEXT;
                } else {
                    glscat_usage();
                }
                break;
            case 'h':
            default:
                glscat_usage();
        }
    }
    glscat_checkError();
    if (recursive) {
        glsCaptureFlags(GLS_OP_glsCallStream, GLS_CAPTURE_EXECUTE_BIT);
    }
    do {
        if (arg < inArgc) __glsString_assign(&inStream, inArgv[arg]);
        if (context) {
            GLSenum copyType = glsCopyStream(
                inStream.head, glsCSTR(""), GLS_CONTEXT, GLS_NONE
            );

            if (type != GLS_NONE) copyType = type;
            glsCopyStream(glsCSTR(""), outStream.head, copyType, writeFlags);
        } else {
            glsCopyStream(inStream.head, outStream.head, type, writeFlags);
        }
        glscat_checkError();
        writeFlags |= GLS_WRITE_APPEND_BIT;
    } while (++arg < inArgc);
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\glsint.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#define __GL_ATTRIB_MASK_COUNT                  23

#define __GLS_IMAGE_FLAGS_COUNT                 2
#define __GLS_API_COUNT                         2

#define __GL_ENUM_PAGE_COUNT                    130
#define __GLS_ENUM_PAGE_COUNT                   65

#define __GL_ENUMS_PER_PAGE                     256
#define __GLS_ENUMS_PER_PAGE                    16

#define __GLS_OPCODES_PER_PAGE                  16

#define __GLS_OPCODE_PAGE_INTERNAL0             0

#define __GLS_OPCODE_PAGE_GLS0                  1
#define __GLS_OPCODE_PAGE_GLS1                  2
#define __GLS_OPCODE_PAGE_GLS2                  3

#define __GLS_OPCODE_PAGE_GL0                   4
#define __GLS_OPCODE_PAGE_GL1                   5
#define __GLS_OPCODE_PAGE_GL2                   6
#define __GLS_OPCODE_PAGE_GL3                   7
#define __GLS_OPCODE_PAGE_GL4                   8
#define __GLS_OPCODE_PAGE_GL5                   9
#define __GLS_OPCODE_PAGE_GL6                   10
#define __GLS_OPCODE_PAGE_GL7                   11
#define __GLS_OPCODE_PAGE_GL8                   12
#define __GLS_OPCODE_PAGE_GL9                   13
#define __GLS_OPCODE_PAGE_GL10                  14
#define __GLS_OPCODE_PAGE_GL11                  15
#define __GLS_OPCODE_PAGE_GL12                  16
#define __GLS_OPCODE_PAGE_GL13                  17
#define __GLS_OPCODE_PAGE_GL14                  18
#define __GLS_OPCODE_PAGE_GL15                  19
#define __GLS_OPCODE_PAGE_GL16                  20
#define __GLS_OPCODE_PAGE_GL17                  21
#define __GLS_OPCODE_PAGE_GL18                  22
#define __GLS_OPCODE_PAGE_GL19                  23
#define __GLS_OPCODE_PAGE_GL20                  24

#define __GLS_OPCODE_PAGE_MAPPED0               25
#define __GLS_OPCODE_PAGE_EXTEND0               64

#define __GLS_OPCODE_PAGE_GL_SGI0               4095
#define __GLS_OPCODE_PAGE_GL_SGI1               4094
#define __GLS_OPCODE_PAGE_GL_SGI2               4093
#define __GLS_OPCODE_PAGE_GL_SGI3               4092
#define __GLS_OPCODE_PAGE_GL_SGI4               4091
#define __GLS_OPCODE_PAGE_GL_SGI5               4090
#define __GLS_OPCODE_PAGE_GL_MSFT0              4089

#define __GLS_MAPPED_OPCODE_PAGE_COUNT          7
#define __GLS_MAPPED_OPCODE_PAGE0               __GLS_OPCODE_PAGE_GL_SGI0
#define __GLS_MAPPED_OPCODE_PAGE1               __GLS_OPCODE_PAGE_GL_SGI1
#define __GLS_MAPPED_OPCODE_PAGE2               __GLS_OPCODE_PAGE_GL_SGI2
#define __GLS_MAPPED_OPCODE_PAGE3               __GLS_OPCODE_PAGE_GL_SGI3
#define __GLS_MAPPED_OPCODE_PAGE4               __GLS_OPCODE_PAGE_GL_SGI4
#define __GLS_MAPPED_OPCODE_PAGE5               __GLS_OPCODE_PAGE_GL_SGI5
#define __GLS_MAPPED_OPCODE_PAGE6               __GLS_OPCODE_PAGE_GL_MSFT0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\encoding.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

extern const GLubyte __glsCharType[256];

#define __GLS_CHAR_GRAPHIC_BIT 0x01
#define __GLS_CHAR_SPACE_BIT 0x02
#define __GLS_CHAR_TOKEN_BIT 0x04

#define __GLS_CHAR_IS_GRAPHIC(inChar) \
    (__glsCharType[inChar] & __GLS_CHAR_GRAPHIC_BIT)
#define __GLS_CHAR_IS_SPACE(inChar) \
    (__glsCharType[inChar] & __GLS_CHAR_SPACE_BIT)
#define __GLS_CHAR_IS_TOKEN(inChar) \
    (__glsCharType[inChar] & __GLS_CHAR_TOKEN_BIT)

#if __GLS_MSB_FIRST
    #define __GLS_BINARY_SWAP0 GLS_BINARY_MSB_FIRST
    #define __GLS_BINARY_SWAP1 GLS_BINARY_LSB_FIRST
    #define __GLS_COUNT_SMALL(inWord) (inWord & 0x0000ffff)
    #define __GLS_OP_SMALL(inWord) (inWord >> 16)
#else /* !__GLS_MSB_FIRST */
    #define __GLS_BINARY_SWAP0 GLS_BINARY_LSB_FIRST
    #define __GLS_BINARY_SWAP1 GLS_BINARY_MSB_FIRST
    #define __GLS_COUNT_SMALL(inWord) (inWord >> 16)
    #define __GLS_OP_SMALL(inWord) (inWord & 0x0000ffff)
#endif /* __GLS_MSB_FIRST */

#define __GLS_COMMAND_JUMP(inPC) ((__GLSbinCommand_jump *)inPC)
#define __GLS_HEAD_LARGE(inPC) ((__GLSbinCommandHead_large *)inPC)
#define __GLS_JUMP_ALLOC (sizeof(__GLSbinCommand_jump) + 4)

typedef struct {
    GLushort opSmall;
    GLushort countSmall;
} __GLSbinCommandHead_small;

typedef struct {
    GLushort opSmall;
    GLushort countSmall;
    GLuint opLarge;
    GLuint countLarge;
} __GLSbinCommandHead_large;

typedef struct {
    GLint major;
    GLint minor;
} __GLSversion;

typedef struct {
    __GLSbinCommandHead_large head;
    __GLSversion version;
} __GLSbinCommand_BeginGLS;

extern GLSenum __glsBinCommand_BeginGLS_getType(
    __GLSbinCommand_BeginGLS *inCommand, __GLSversion *outVersion
);

typedef struct {
    __GLSbinCommandHead_large head;
    GLuint pad;
    GLubyte *dest;
} __GLSbinCommand_jump;

typedef struct {
    __GLSbinCommandHead_small head;
} __GLSbinCommand_pad;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\ctx.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
Locale
******************************************************************************/

#define __GLS_C_LOCALE_DECLARE \
    const GLubyte *const __locale = glsCSTR(setlocale(LC_NUMERIC, GLS_NONE)); \
    GLboolean __saveLocale = (GLboolean)(__locale[0] != 'C' || __locale[1])

#define __GLS_C_LOCALE_BEGIN \
    if ( \
        __saveLocale && \
        __glsString_assign(&__GLS_CONTEXT->savedLocale, __locale) \
    ) { \
        setlocale(LC_NUMERIC, "C"); \
    } else { \
        __saveLocale = GL_FALSE; \
    }

#define __GLS_C_LOCALE_END \
    if (__saveLocale) setlocale( \
        LC_NUMERIC, (const char *)__GLS_CONTEXT->savedLocale.head \
    )

/******************************************************************************
__GLSglrc
******************************************************************************/

typedef struct {
    GLvoid *base;
    size_t byteCount;
} __GLSglrcBuf;

typedef struct __GLSglrc __GLSglrc;

struct __GLSglrc {
    GLuint layer;
    GLuint readLayer;
    GLuint shareGLRC;
    __GLSglrcBuf feedbackBuf;
    __GLSglrcBuf selectBuf;
    #if __GL_EXT_vertex_array
        __GLSglrcBuf colorBuf;
        __GLSglrcBuf edgeFlagBuf;
        __GLSglrcBuf indexBuf;
        __GLSglrcBuf normalBuf;
        __GLSglrcBuf texCoordBuf;
        __GLSglrcBuf vertexBuf;
    #endif /* __GL_EXT_vertex_array */
};

extern void __glsGLRC_final(__GLSglrc *inoutGLRC);
extern void __glsGLRC_init(__GLSglrc *outGLRC);

/******************************************************************************
__GLSlayer
******************************************************************************/

typedef struct __GLSlayer __GLSlayer;

struct __GLSlayer {
    GLfloat invisibleAspect;
    GLSenum displayFormat;
    GLint doubleBuffer;
    GLint invisible;
    GLint invisibleHeightPixels;
    GLint level;
    GLint stereo;
    GLint transparent;
    GLint indexBits;
    GLint redBits;
    GLint greenBits;
    GLint blueBits;
    GLint alphaBits;
    GLint depthBits;
    GLint stencilBits;
    GLint accumRedBits;
    GLint accumGreenBits;
    GLint accumBlueBits;
    GLint accumAlphaBits;
    GLint auxBuffers;
    #if __GL_SGIS_multisample
        GLint sampleBuffers;
        GLint samples;
    #endif /* __GL_SGIS_multisample */
};

extern void __glsLayer_init(__GLSlayer *outLayer);

/******************************************************************************
__GLSheader
******************************************************************************/

typedef struct __GLSheader __GLSheader;

struct __GLSheader {
    GLfloat aspect;
    GLfloat borderWidth;
    GLfloat contrastRatio;
    GLfloat heightMM;
    GLfloat borderColor[4];
    GLfloat gamma[4];
    GLfloat origin[2];
    GLfloat pageColor[4];
    GLfloat pageSize[2];
    GLfloat redPoint[2];
    GLfloat greenPoint[2];
    GLfloat bluePoint[2];
    GLfloat whitePoint[2];
    GLint frameCount;
    GLint glrcCount;
    __GLSglrc *glrcs;
    GLint heightPixels;
    GLint layerCount;
    GLint tileable;
    __GLSlayer *layers;
    GLint createTime[6];
    GLint modifyTime[6];
    __GLSstring extensions;
    __GLSstring author;
    __GLSstring description;
    __GLSstring notes;
    __GLSstring title;
    __GLSstring tools;
    __GLSstring version;
};

extern void __glsHeader_final(__GLSheader *inoutHeader);
extern GLboolean __glsHeader_init(__GLSheader *outHeader);
extern GLboolean __glsHeader_reset(__GLSheader *inoutHeader);

/******************************************************************************
__GLScontext
******************************************************************************/

#if !__GLS_PLATFORM_WIN32
// DrewB
typedef void (*__GLSdecodeBinFunc)(GLubyte *inoutPtr);
typedef void (*__GLSdecodeTextFunc)(__GLSreader *inoutReader);
#else
typedef void (*__GLSdecodeBinFunc)(struct __GLScontext *ctx,
                                   GLubyte *inoutPtr);
typedef void (*__GLSdecodeTextFunc)(struct __GLScontext *ctx,
                                    __GLSreader *inoutReader);
#endif

typedef struct __GLScontextStream __GLScontextStream;
typedef struct __GLSlistString __GLSlistString;

typedef struct {
    GLint count;
    GLulong vals[__GLS_MAX_OUT_ARGS];
} __GLSoutArgs;

typedef struct __GLScontext {
    __GLS_LIST_ELEM;
    GLSenum abortMode;
    GLSenum blockType;
    GLint callNesting;
    GLint captureEntryCount;
    GLScaptureFunc captureEntryFunc;
    GLScaptureFunc captureExitFunc;
    GLubyte captureFlags[__GLS_OPCODE_COUNT];
    GLint captureNesting;
    GLSfunc commandFuncs[__GLS_OPCODE_COUNT];
    GLboolean contextCall;
    __GLSdict *contextStreamDict;
    __GLS_ITERLIST(__GLScontextStream) contextStreamList;
    GLboolean current;
    GLuint currentGLRC;
    GLvoid *dataPointer;
    FILE *defaultReadChannel;
    FILE *defaultWriteChannel;
    GLboolean deleted;
    GLSfunc dispatchAPI[__GLS_OPCODE_COUNT];
    GLSfunc dispatchCall[__GLS_OPCODE_COUNT];
    __GLSdecodeBinFunc dispatchDecode_bin[__GLS_OPCODE_COUNT];
    __GLSheader header;
    GLuint name;
    __GLSoutArgs outArgs;
    GLboolean pixelSetupGen;
    GLSreadFunc readFunc;
    __GLS_ITERLIST(__GLSlistString) readPrefixList;
    __GLSstring returnString;
    __GLSstring savedLocale;
    __GLSversion streamVersion;
    GLSwriteFunc unreadFunc;
    struct __GLSwriter *writer;
    struct __GLSwriter *writers[__GLS_MAX_CAPTURE_NESTING];
    GLSwriteFunc writeFunc;
    __GLSlistString *writePrefix;
#if __GLS_PLATFORM_WIN32
    // DrewB
    GLboolean captureExecOverride;
    GLSfunc captureExec[__GLS_OPCODE_COUNT];
#endif
} __GLScontext;

typedef __GLS_LIST(__GLScontext) __GLScontextList;

extern GLvoid* __glsContext_allocFeedbackBuf(
    __GLScontext *inoutContext, size_t inByteCount
);

extern GLvoid* __glsContext_allocSelectBuf(
    __GLScontext *inoutContext, size_t inByteCount
);

#if __GL_EXT_vertex_array
    extern GLvoid* __glsContext_allocVertexArrayBuf(
        __GLScontext *inoutContext, GLSopcode inOpcode, size_t inByteCount
    );
#endif /* __GL_EXT_vertex_array */

extern __GLScontext* __glsContext_create(GLuint inName);
extern __GLScontext* __glsContext_destroy(__GLScontext *inContext);
extern void __glsContext_updateDispatchDecode_bin(__GLScontext *inoutContext);
extern void __glsContext_updateDispatchTables(__GLScontext *inoutContext);

/******************************************************************************
__GLScontextStream
******************************************************************************/

typedef struct __GLScontextStreamBlock __GLScontextStreamBlock;

struct __GLScontextStream {
    __GLS_LIST_ELEM;
    __GLS_LIST(__GLScontextStreamBlock) blockList;
    GLint callCount;
    __GLSstring name;
    GLboolean deleted;
};

typedef __GLS_LIST_ITER(__GLScontextStreamBlock) __GLScontextStreamBlockIter;

extern __GLScontextStream* __glsContextStream_create(const GLubyte *inName);

extern __GLScontextStream* __glsContextStream_destroy(
    __GLScontextStream *inStream
);

extern __GLScontextStreamBlock* __glsContextStream_appendBlock(
    __GLScontextStream *inoutStream, size_t inBufSize
);

extern void __glsContextStream_call(__GLScontextStream *inoutStream);

extern __GLScontextStreamBlock* __glsContextStream_firstBlock(
    __GLScontextStream *inoutStream
);

extern size_t __glsContextStream_getByteCount(__GLScontextStream *inoutStream);
extern GLuint __glsContextStream_getCRC32(__GLScontextStream *inoutStream);

extern __GLScontextStreamBlock* __glsContextStream_lastBlock(
    __GLScontextStream *inoutStream
);

extern void __glsContextStream_truncate(
    __GLScontextStream *inoutStream,
    __GLScontextStreamBlock *inBlock,
    size_t inOffset
);

#define __GLS_FULL_CONTEXT_STREAM_BLOCK 0.9f

struct __GLScontextStreamBlock {
    __GLS_LIST_ELEM;
    GLubyte *buf;
    GLubyte *bufTail;
    GLubyte *writeTail;
};

extern __GLScontextStreamBlock* __glsContextStreamBlock_create(
    size_t inBufSize
);

extern __GLScontextStreamBlock* __glsContextStreamBlock_destroy(
    __GLScontextStreamBlock *inBlock
);

extern GLboolean __glsContextStreamBlock_addJump(
    __GLScontextStreamBlock *inoutBlock, GLubyte *inDest
);

extern GLboolean __glsContextStreamBlock_addPad(
    __GLScontextStreamBlock *inoutBlock
);

extern GLboolean __glsContextStreamBlock_hasJump(
    __GLScontextStreamBlock *inBlock
);

extern GLboolean __glsContextStreamBlock_removeJump(
    __GLScontextStreamBlock *inoutBlock
);

/******************************************************************************
__GLSlistString
******************************************************************************/

struct __GLSlistString {
    __GLS_LIST_ELEM;
    __GLSstring val;
};

extern GLboolean __glsListString_prefix(
    const __GLSlistString *inString,
    const GLubyte *inName,
    __GLSstring *outPath
);

extern __GLSlistString* __glsListString_create(const GLubyte *inVal);
extern __GLSlistString* __glsListString_destroy(__GLSlistString *inString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\glssize.h ===
#ifndef __GLSSIZE_H__
#define __GLSSIZE_H__

GLint __glsTypeSize(GLenum type);
GLint __glsEvalComputeK(GLenum inTarget);
GLint __gls_glBitmap_bitmap_size(GLint inWidth, GLint inHeight);
GLint __gls_glCallLists_lists_size(GLint inCount, GLenum inType);
GLint __gls_glDrawPixels_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glFogfv_params_size(GLenum inPname);
GLint __gls_glFogiv_params_size(GLenum inPname);
GLint __gls_glGetBooleanv_params_size(GLenum inPname);
GLint __gls_glGetDoublev_params_size(GLenum inPname);
GLint __gls_glGetFloatv_params_size(GLenum inPname);
GLint __gls_glGetIntegerv_params_size(GLenum inPname);
GLint __gls_glGetLightfv_params_size(GLenum inPname);
GLint __gls_glGetLightiv_params_size(GLenum inPname);
GLint __gls_glGetMapdv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery);
GLint __gls_glGetMapfv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery);
GLint __gls_glGetMapiv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery);
GLint __gls_glGetMaterialfv_params_size(GLenum inPname);
GLint __gls_glGetMaterialiv_params_size(GLenum inPname);
GLint __gls_glGetPixelMapfv_values_size(__GLScontext *ctx, GLenum inMap);
GLint __gls_glGetPixelMapuiv_values_size(__GLScontext *ctx, GLenum inMap);
GLint __gls_glGetPixelMapusv_values_size(__GLScontext *ctx, GLenum inMap);
GLint __gls_glGetPolygonStipple_mask_size(void);
GLint __gls_glGetTexEnvfv_params_size(GLenum inPname);
GLint __gls_glGetTexEnviv_params_size(GLenum inPname);
GLint __gls_glGetTexGendv_params_size(GLenum inPname);
GLint __gls_glGetTexGenfv_params_size(GLenum inPname);
GLint __gls_glGetTexGeniv_params_size(GLenum inPname);
GLint __gls_glGetTexImage_pixels_size(
        __GLScontext *ctx,
        GLenum inTarget, GLint inLevel, GLenum inFormat, GLenum inType);
GLint __gls_glGetTexLevelParameterfv_params_size(GLenum inPname);
GLint __gls_glGetTexLevelParameteriv_params_size(GLenum inPname);
GLint __gls_glGetTexParameterfv_params_size(GLenum inPname);
GLint __gls_glGetTexParameteriv_params_size(GLenum inPname);
GLint __gls_glLightfv_params_size(GLenum inPname);
GLint __gls_glLightiv_params_size(GLenum inPname);
GLint __gls_glLightModelfv_params_size(GLenum inPname);
GLint __gls_glLightModeliv_params_size(GLenum inPname);
GLint __gls_glMap1d_points_size(
        GLenum inTarget, GLint inStride, GLint inOrder);
GLint __gls_glMap1f_points_size(
        GLenum inTarget, GLint inStride, GLint inOrder);
GLint __gls_glMap2d_points_size(
        GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
        GLint inVorder);
GLint __gls_glMap2f_points_size(
        GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
        GLint inVorder);
GLint __gls_glMaterialfv_params_size(GLenum inPname);
GLint __gls_glMaterialiv_params_size(GLenum inPname);
GLint __gls_glPolygonStipple_mask_size(void);
GLint __gls_glReadPixels_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glTexEnvfv_params_size(GLenum inPname);
GLint __gls_glTexEnviv_params_size(GLenum inPname);
GLint __gls_glTexGendv_params_size(GLenum inPname);
GLint __gls_glTexGenfv_params_size(GLenum inPname);
GLint __gls_glTexGeniv_params_size(GLenum inPname);
GLint __gls_glTexImage1D_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glColorSubTableEXT_entries_size(
        GLenum inFormat, GLenum inType, GLint inCount);
GLint __gls_glTexImage2D_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glTexParameterfv_params_size(GLenum inPname);
GLint __gls_glTexParameteriv_params_size(GLenum inPname);
GLint __gls_glsHeaderfv_inVec_size(GLenum inAttrib);
GLint __gls_glsHeaderiv_inVec_size(GLenum inAttrib);
GLint __gls_glConvolutionFilter1DEXT_image_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glConvolutionFilter2DEXT_image_size(
        GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight);
GLint __gls_glConvolutionParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glConvolutionParameterivEXT_params_size(GLenum inPname);
GLint __gls_glGetConvolutionFilterEXT_image_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetConvolutionParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetConvolutionParameterivEXT_params_size(GLenum inPname);
GLint __gls_glGetSeparableFilterEXT_row_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetSeparableFilterEXT_column_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetSeparableFilterEXT_span_size(
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glSeparableFilter2DEXT_row_size(
        GLenum inTarget, GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glSeparableFilter2DEXT_column_size(
        GLenum inTarget, GLenum inFormat, GLenum inType, GLint inHeight);
GLint __gls_glGetHistogramEXT_values_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetHistogramParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetHistogramParameterivEXT_params_size(GLenum inPname);
GLint __gls_glGetMinmaxEXT_values_siz;
GLint __gls_glGetMinmaxParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetMinmaxParameterivEXT_params_size(GLenum inPname);
GLint __gls_glTexSubImage1DEXT_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glTexSubImage1D_pixels_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glTexSubImage2DEXT_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight);
GLint __gls_glTexSubImage2D_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight);
GLint __gls_glTexSubImage3DEXT_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth);
GLint __gls_glTexImage3DEXT_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth);
GLint __gls_glColorPointerEXT_pointer_size(
        GLint inSize, GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glEdgeFlagPointerEXT_pointer_size(
        GLint inStride, GLint inCount);
GLint __gls_glIndexPointerEXT_pointer_size(
        GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glNormalPointerEXT_pointer_size(
        GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glTexCoordPointerEXT_pointer_size(
        GLint inSize, GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glVertexPointerEXT_pointer_size(
        GLint inSize, GLenum inType, GLint inStride, GLint inCount);
GLint __gls_glColorTableEXT_table_size(
        GLenum inFormat, GLenum inType, GLint inWidth);
GLint __gls_glColorTableParameterfvSGI_params_size(GLenum inPname);
GLint __gls_glColorTableParameterivSGI_params_size(GLenum inPname);
GLint __gls_glGetColorTableEXT_table_size(
        __GLScontext *ctx,
        GLenum inTarget, GLenum inFormat, GLenum inType);
GLint __gls_glGetColorTableParameterfvEXT_params_size(GLenum inPname);
GLint __gls_glGetColorTableParameterivEXT_params_size(GLenum inPname);
GLint __gls_glTexColorTableParameterfvSGI_params_size(GLenum inPname);
GLint __gls_glTexColorTableParameterivSGI_params_size(GLenum inPname);
GLint __gls_glGetTexColorTableParameterfvSGI_params_size(GLenum inPname);
GLint __gls_glGetTexColorTableParameterivSGI_params_size(GLenum inPname);
GLint __gls_glGetDetailTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget);
GLint __gls_glGetSharpenTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget);
GLint __gls_glTexImage4DSGIS_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth,
        GLint inSize4d);
GLint __gls_glTexSubImage4DSGIS_pixels_size(
        GLenum inFormat,
        GLenum inType,
        GLint inWidth,
        GLint inHeight,
        GLint inDepth,
        GLint inSize4d);

#endif // __GLSSIZE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\glslib.h ===
#if !defined(__glslib_h_)
#define __glslib_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
Constants
******************************************************************************/

#define __GLS_BOOLEAN 0x0001

#define __GLS_MAX_ALIGN_BYTES 8
#define __GLS_MAX_CALL_NESTING 64
#define __GLS_MAX_CAPTURE_NESTING 16
#define __GLS_MAX_OUT_ARGS 4
#define __GLS_VERSION_MAJOR 1
#define __GLS_VERSION_MINOR 0

#define __GLS_COMMAND_ALIGN_EVEN32_BIT  0x80000000
#define __GLS_COMMAND_ALIGN_ODD32_BIT   0x40000000
#define __GLS_COMMAND_0_PARAMS_BIT      0x20000000
#define __GLS_COMMAND_ATTRIB_MASK       0x0000FFFF

/******************************************************************************
Extensions
******************************************************************************/

// DrewB
#ifndef __GLS_PLATFORM_WIN32
#define __GL_EXT_abgr 1
#define __GL_EXT_blend_color 1
#define __GL_EXT_blend_logic_op 1
#define __GL_EXT_blend_minmax 1
#define __GL_EXT_blend_subtract 1
#define __GL_EXT_cmyka 1
#define __GL_EXT_convolution 1
#define __GL_EXT_copy_texture 1
#define __GL_EXT_histogram 1
#define __GL_EXT_packed_pixels 1
#define __GL_EXT_polygon_offset 1
#define __GL_EXT_rescale_normal 1
#define __GL_EXT_subtexture 1
#define __GL_EXT_texture 1
#define __GL_EXT_texture_object 1
#define __GL_EXT_texture3D 1
#define __GL_EXT_vertex_array 1
#else
#define __GL_EXT_paletted_texture 1
#define __GL_EXT_bgra 1
#define __GL_WIN_draw_range_elements 1
#endif

#if __GLS_PLATFORM_IRIX

    #define __GL_SGI_color_matrix 1
    #define __GL_SGI_color_table 1
    #define __GL_SGI_texture_color_table 1
    #define __GL_SGIS_component_select 1
    #define __GL_SGIS_detail_texture 1
    #define __GL_SGIS_multisample 1
    #define __GL_SGIS_sharpen_texture 1
    #define __GL_SGIS_texture_border_clamp 1
    #define __GL_SGIS_texture4D 1
    #define __GL_SGIX_interlace 1
    #define __GL_SGIX_multisample 1
    #define __GL_SGIX_pixel_texture 1
    #define __GL_SGIX_pixel_tiles 1
    #define __GL_SGIX_texture_multi_buffer 1

    #if __GLS_PLATFORM_IRIX_FUTURE
        #define __GL_SGIS_texture_edge_clamp 1
        #define __GL_SGIS_texture_filter4 0
        #define __GL_SGIS_texture_lod 1
        #define __GL_SGIX_multipass 0
        #define __GL_SGIX_sprite 0
    #endif /* __GLS_PLATFORM_IRIX_FUTURE */

#endif /* __GLS_PLATFORM_IRIX */

/******************************************************************************
Macros
******************************************************************************/

#define __GL_ENUM_OFFSET(inEnum) (GLint)(inEnum % __GL_ENUMS_PER_PAGE)
#define __GL_ENUM_PAGE(inEnum) (GLint)(inEnum / __GL_ENUMS_PER_PAGE)

#define __GL_ENUM(inPage, inOffset) ( \
    (inPage) * __GL_ENUMS_PER_PAGE + (inOffset) \
)

#define __GLS_ENUM_OFFSET(inEnum) (GLint)(inEnum % __GLS_ENUMS_PER_PAGE)
#define __GLS_ENUM_PAGE(inEnum) (GLint)(inEnum / __GLS_ENUMS_PER_PAGE)

#define __GLS_ENUM(inPage, inOffset) ( \
    (inPage) * __GLS_ENUMS_PER_PAGE + (inOffset) \
)

#define __GLS_FORWARD

/******************************************************************************
Includes
******************************************************************************/

#include <glmf.h>
#include "glsint.h"
#include "glsutil.h"
#include "encoding.h"
#include "opcode.h"
#include "pixel.h"
#include "read.h"
#include "parser.h"
#include "ctx.h"
#include "platform.h"
#include "write.h"
#ifdef __GLS_PLATFORM_WIN32
// DrewB
#include "glssize.h"
#endif

/******************************************************************************
Global data
******************************************************************************/

extern const GLSenum __glsAllAPIs[__GLS_API_COUNT + 1];
extern const GLubyte *const __glAttribMaskString[__GL_ATTRIB_MASK_COUNT];
extern const GLbitfield __glAttribMaskVal[__GL_ATTRIB_MASK_COUNT];
extern __GLSdict *__glsContextDict;
extern __GLScontextList __glsContextList;
extern const GLubyte *const *const __glEnumString[__GL_ENUM_PAGE_COUNT];
extern const GLint __glEnumStringCount[__GL_ENUM_PAGE_COUNT];
extern const GLSfunc __glsDispatchCapture[__GLS_OPCODE_COUNT];
extern __GLSdecodeBinFunc __glsDispatchDecode_bin_default[__GLS_OPCODE_COUNT];

extern const __GLSdecodeBinFunc __glsDispatchDecode_bin_swap[
    __GLS_OPCODE_COUNT
];

extern const __GLSdecodeTextFunc __glsDispatchDecode_text[__GLS_OPCODE_COUNT];
extern GLSfunc __glsDispatchExec[__GLS_OPCODE_COUNT];
extern const GLubyte *const *const __glsEnumString[__GLS_ENUM_PAGE_COUNT];
extern const GLint __glsEnumStringCount[__GLS_ENUM_PAGE_COUNT];
extern const GLubyte *const __glsExtensions;
extern const GLubyte *const __glsImageFlagsString[__GLS_IMAGE_FLAGS_COUNT];
extern const GLbitfield __glsImageFlagsVal[__GLS_IMAGE_FLAGS_COUNT];
extern const GLbitfield __glsOpcodeAttrib[__GLS_OPCODE_COUNT];
extern const GLubyte *const __glsOpcodeString[__GLS_OPCODE_COUNT];
extern const GLSopcode __glsOpcodesGL[];
extern const GLSopcode __glsOpcodesGLS[];
extern const GLint __glsOpcodesGLCount;
extern const GLint __glsOpcodesGLSCount;
extern __GLSparser *__glsParser;

#if __GLS_MAPPED_OPCODE_PAGE_COUNT
extern const GLint __glsOpPageMap[__GLS_MAPPED_OPCODE_PAGE_COUNT];
#endif /* __GLS_MAPPED_OPCODE_PAGE_COUNT */

/******************************************************************************
Global functions
******************************************************************************/

#define __GLS_RAISE_ERROR(inError) if (!__GLS_ERROR) __GLS_PUT_ERROR(inError)

#ifndef __GLS_PLATFORM_WIN32
// DrewB
extern void __glsCallError(GLSopcode inOpcode, GLSenum inError);
#define __GLS_CALL_ERROR(ctx, inOpcode, inError) \
    __glsCallError(inOpcode, inError)
extern void __glsCallUnsupportedCommand(void);
#define __GLS_CALL_UNSUPPORTED_COMMAND(ctx) \
    __glsCallUnsupportedCommand()
#else
extern void __glsCallError(__GLScontext *ctx,
                           GLSopcode inOpcode, GLSenum inError);
#define __GLS_CALL_ERROR(ctx, inOpcode, inError) \
    __glsCallError(ctx, inOpcode, inError)
extern void __glsCallUnsupportedCommand(__GLScontext *ctx);
#define __GLS_CALL_UNSUPPORTED_COMMAND(ctx) \
    __glsCallUnsupportedCommand(ctx)
#endif

#endif /* __glslib_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\opcode.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define __GLS_OPCODE(inPage, inOffset) ( \
    (inPage) * __GLS_OPCODES_PER_PAGE + (inOffset) \
)

#define __GLS_OPCODE_COUNT ( \
    (__GLS_OPCODE_PAGE_MAPPED0 + __GLS_MAPPED_OPCODE_PAGE_COUNT) * \
    __GLS_OPCODES_PER_PAGE \
)

#define __GLS_OPCODE_OFFSET(inOpcode) (inOpcode % __GLS_OPCODES_PER_PAGE)
#define __GLS_OPCODE_PAGE(inOpcode) (inOpcode / __GLS_OPCODES_PER_PAGE)

extern GLSopcode __glsMapOpcode(GLSopcode inOpcode);
extern GLSenum __glsOpcodeAPI(GLSopcode inOpcode);
extern GLSopcode __glsUnmapOpcode(GLSopcode inOpcode);
extern GLboolean __glsValidateOpcode(GLSopcode inOpcode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\parser.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

typedef struct {
    __GLSdict *glAttribMaskDict;
    __GLSdict *glEnumDict;
    __GLSdict *glsEnumDict;
    __GLSdict *glsImageFlagsDict;
    __GLSdict *glsOpDict;
} __GLSparser;

extern __GLSparser* __glsParser_create(void);
extern __GLSparser* __glsParser_destroy(__GLSparser *inParser);

extern GLboolean __glsParser_findCommand(
    const __GLSparser *inParser,
    const GLubyte *inCommand,
    GLSopcode *outOpcode
);

extern void __glsParser_print(const __GLSparser *inParser);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\glsutil.h ===
#if !defined(__glsutil_h_)
#define __glsutil_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <glmf.h>
#include <assert.h>

#if defined(__cplusplus)
    extern "C" {
#endif

/******************************************************************************
Array
******************************************************************************/

#define __GLS_ARRAY(inType) \
    struct { \
        inType *base; \
        size_t count; \
        size_t bufCount; \
    }

typedef __GLS_ARRAY(GLvoid) __GLSarray;

#define __GLS_ARRAY_CHECK(inArray) \
    assert( \
        sizeof((inArray)->base) && \
        sizeof(*(inArray)) == sizeof(__GLSarray) \
    )

#define __GLS_ARRAY_APPEND(inoutArray, inCount, inInit) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_insert( \
        (__GLSarray *)inoutArray, \
        inoutArray->count, \
        inCount, \
        inInit, \
        sizeof(*(inoutArray)->base) \
    )

#define __GLS_ARRAY_FINAL(inoutArray) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_final((__GLSarray *)inoutArray)

#define __GLS_ARRAY_INIT(outArray) \
    __GLS_ARRAY_CHECK(outArray); \
    __glsArray_init((__GLSarray *)outArray)

#define __GLS_ARRAY_COMPACT(inoutArray) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_compact((__GLSarray *)inoutArray, sizeof(*(inoutArray)->base))

#define __GLS_ARRAY_DELETE(inoutArray, inIndex, inCount) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_delete( \
        (__GLSarray *)inoutArray, \
        inIndex, \
        inCount, \
        sizeof(*(inoutArray)->base) \
    )

#define __GLS_ARRAY_INSERT(inoutArray, inIndex, inCount, inInit) \
    __GLS_ARRAY_CHECK(inoutArray); \
    __glsArray_insert( \
        (__GLSarray *)inoutArray, \
        inIndex, \
        inCount, \
        inInit, \
        sizeof(*(inoutArray)->base) \
    )

extern void __glsArray_final(__GLSarray *inoutArray);
extern void __glsArray_init(__GLSarray *outArray);
extern void __glsArray_compact(__GLSarray *inoutArray, size_t inElemSize);

extern void __glsArray_delete(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    size_t inElemSize
);

extern GLboolean __glsArray_insert(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    GLboolean inInit,
    size_t inElemSize
);

/******************************************************************************
Checksum
******************************************************************************/

#define __GLS_CRC32_STEP(inCRC, inByte) \
    inCRC = (inCRC << 8) ^ __glsCRC32table[(inCRC >> 24) ^ inByte];

extern const GLuint __glsCRC32table[256];

/******************************************************************************
Dict
******************************************************************************/

typedef struct __GLSdict __GLSdict;

extern __GLSdict* __glsIntDict_create(size_t inTableCount);
extern __GLSdict* __glsIntDict_destroy(__GLSdict *inDict);
extern void __glsIntDict_print(__GLSdict *inoutDict, const GLubyte *inName);
extern void __glsIntDict_remove(__GLSdict *inoutDict, GLint inKey);

extern GLboolean __glsInt2IntDict_add(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
);

extern GLboolean __glsInt2IntDict_find(
    const __GLSdict *inDict, GLint inKey, GLint *optoutVal
);

extern GLboolean __glsInt2IntDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
);

extern GLboolean __glsInt2PtrDict_add(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
);

extern GLvoid* __glsInt2PtrDict_find(
    const __GLSdict *inDict, GLint inKey
);

extern GLboolean __glsInt2PtrDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
);

extern __GLSdict* __glsStrDict_create(
    size_t inTableCount, GLboolean inStaticKeys
);

extern __GLSdict* __glsStrDict_destroy(__GLSdict *inDict);
extern void __glsStrDict_print(__GLSdict *inoutDict, const GLubyte *inName);
extern void __glsStrDict_remove(__GLSdict *inoutDict, const GLubyte *inKey);

extern GLboolean __glsStr2IntDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
);

extern GLboolean __glsStr2IntDict_find(
    const __GLSdict *inDict, const GLubyte *inKey, GLint *optoutVal
);

extern GLboolean __glsStr2IntDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
);

extern GLboolean __glsStr2PtrDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
);

extern GLvoid* __glsStr2PtrDict_find(
    const __GLSdict *inDict, const GLubyte *inKey
);

extern GLboolean __glsStr2PtrDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
);

/******************************************************************************
List
******************************************************************************/

#define __GLS_LIST(inType) \
    struct { \
        inType *head; \
    }

#define __GLS_LIST_ITER(inType) \
    struct { \
        inType *elem; \
    }

typedef struct __GLSlistElem __GLSlistElem;
typedef void (*__GLSlistElemDestructor)(__GLSlistElem *inElem);
typedef __GLS_LIST(__GLSlistElem) __GLSlist;
typedef __GLS_LIST_ITER(__GLSlistElem) __GLSlistIter;

struct __GLSlistElem {
    __GLSlistElem *next;
    __GLSlistElem *prev;
};

#define __GLS_LIST_ELEM \
    __GLSlistElem __glsListElem

#define __GLS_LIST_CHECK(inList) \
    assert(sizeof((inList)->head) && sizeof(*(inList)) == sizeof(__GLSlist))

#define __GLS_LIST_ELEM_CHECK(inElem) \
    assert(sizeof((inElem)->__glsListElem.next))

#define __GLS_LIST_ITER_CHECK(inIter) \
    assert( \
        sizeof((inIter)->elem) && sizeof(*(inIter)) == sizeof(__GLSlistIter) \
    )

#define __GLS_LIST_APPEND(inoutList, inoutElem) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsListAppend((__GLSlist *)(inoutList), (__GLSlistElem *)(inoutElem))

#define __GLS_LIST_CLEAR_DESTROY(inoutList, inDestructor) \
    __GLS_LIST_CHECK(inoutList); \
    __glsListClearDestroy( \
        (__GLSlist *)(inoutList), (__GLSlistElemDestructor)(inDestructor) \
    )

#define __GLS_LIST_FIRST(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListFirst((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_LAST(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListLast((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_NEXT(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListNext((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_PREPEND(inoutList, inoutElem) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsListPrepend((__GLSlist *)(inoutList), (__GLSlistElem *)(inoutElem))

#define __GLS_LIST_PREV(inList, inoutIter) \
    __GLS_LIST_CHECK(inList); \
    __GLS_LIST_ITER_CHECK(inoutIter); \
    __glsListPrev((__GLSlist *)(inList), (__GLSlistIter *)(inoutIter))

#define __GLS_LIST_REMOVE(inoutList, inoutElem) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsListRemove((__GLSlist *)(inoutList), (__GLSlistElem*)(inoutElem))

#define __GLS_LIST_REMOVE_DESTROY(inoutList, inElem, inDestructor) \
    __GLS_LIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inElem); \
    __glsListRemoveDestroy( \
        (__GLSlist *)(inoutList), \
        (__GLSlistElem *)(inElem), \
        (__GLSlistElemDestructor)(inDestructor) \
    )

extern void __glsListAppend(__GLSlist *inoutList, __GLSlistElem *inoutElem);

extern void __glsListClearDestroy(
    __GLSlist *inoutList, __GLSlistElemDestructor inDestructor
);

extern void __glsListFirst(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListLast(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListNext(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListPrepend(__GLSlist *inoutList, __GLSlistElem *inoutElem);
extern void __glsListPrev(__GLSlist *inList, __GLSlistIter *inoutIter);
extern void __glsListRemove(__GLSlist *inoutList, __GLSlistElem *inoutElem);

extern void __glsListRemoveDestroy(
    __GLSlist *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
);

/******************************************************************************
IterList
******************************************************************************/

#define __GLS_ITERLIST(inType) \
    struct { \
        inType *head; \
        size_t count; \
        inType *iterElem; \
        size_t iterIndex; \
    }

typedef __GLS_ITERLIST(__GLSlistElem) __GLSiterList;

#define __GLS_ITERLIST_CHECK(inList) \
    assert( \
        sizeof((inList)->head) && sizeof(*(inList)) == sizeof(__GLSiterList) \
    )

#define __GLS_ITERLIST_APPEND(inoutList, inoutElem) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsIterListAppend( \
        (__GLSiterList *)(inoutList), (__GLSlistElem *)(inoutElem) \
    )

#define __GLS_ITERLIST_CLEAR_DESTROY(inoutList, inDestructor) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListClearDestroy( \
        (__GLSiterList *)(inoutList), (__GLSlistElemDestructor)(inDestructor) \
    )

#define __GLS_ITERLIST_FIRST(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListFirst((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_LAST(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListLast((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_NEXT(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListNext((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_PREPEND(inoutList, inoutElem) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsIterListPrepend( \
        (__GLSiterList *)(inoutList), (__GLSlistElem *)(inoutElem) \
    )

#define __GLS_ITERLIST_PREV(inoutList) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListPrev((__GLSiterList *)(inoutList))

#define __GLS_ITERLIST_REMOVE(inoutList, inoutElem) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inoutElem); \
    __glsIterListRemove( \
        (__GLSiterList *)(inoutList), (__GLSlistElem*)(inoutElem) \
    )

#define __GLS_ITERLIST_REMOVE_DESTROY(inoutList, inElem, inDestructor) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __GLS_LIST_ELEM_CHECK(inElem); \
    __glsIterListRemoveDestroy( \
        (__GLSiterList *)(inoutList), \
        (__GLSlistElem *)(inElem), \
        (__GLSlistElemDestructor)(inDestructor) \
    )

#define __GLS_ITERLIST_SEEK(inoutList, inIndex) \
    __GLS_ITERLIST_CHECK(inoutList); \
    __glsIterListSeek((__GLSiterList *)(inoutList), inIndex)

extern void __glsIterListAppend(
    __GLSiterList *inoutList, __GLSlistElem *inoutElem
);

extern void __glsIterListClearDestroy(
    __GLSiterList *inoutList, __GLSlistElemDestructor inDestructor
);

extern void __glsIterListFirst(__GLSiterList *inoutList);
extern void __glsIterListLast(__GLSiterList *inoutList);
extern void __glsIterListNext(__GLSiterList *inoutList);

extern void __glsIterListPrepend(
    __GLSiterList *inoutList, __GLSlistElem *inoutElem
);

extern void __glsIterListPrev(__GLSiterList *inoutList);

extern void __glsIterListRemove(
    __GLSiterList *inoutList, __GLSlistElem *inoutElem
);

extern void __glsIterListRemoveDestroy(
    __GLSiterList *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
);

extern void __glsIterListSeek(__GLSiterList *inoutList, size_t inIndex);

/******************************************************************************
Memory
******************************************************************************/

extern GLvoid* __glsCalloc(size_t inCount, size_t inSize);
extern GLvoid* __glsMalloc(size_t inSize);

/******************************************************************************
Nop
******************************************************************************/

#define __GLS_NULL

extern void __glsNop(void);

/******************************************************************************
Number
******************************************************************************/

#define __GLS_MAX(in1, in2) ((in1) > (in2) ? (in1) : (in2))
#define __GLS_MIN(in1, in2) ((in1) < (in2) ? (in1) : (in2))

#define __GLS_SWAP_DECLARE \
    GLubyte __swapSave

#define __GLS_SWAP(inPtr, in1, in2) \
    __swapSave = ((GLubyte*)(inPtr))[in1]; \
    ((GLubyte *)(inPtr))[in1] = ((GLubyte *)(inPtr))[in2]; \
    ((GLubyte *)(inPtr))[in2] = __swapSave;

#define __GLS_SWAP1(inPtr)

#define __GLS_SWAP2(inPtr) \
    __GLS_SWAP(inPtr, 0, 1);

#define __GLS_SWAP4(inPtr) \
    __GLS_SWAP(inPtr, 0, 3); \
    __GLS_SWAP(inPtr, 1, 2);

#define __GLS_SWAP8(inPtr) \
    __GLS_SWAP(inPtr, 0, 7); \
    __GLS_SWAP(inPtr, 1, 6); \
    __GLS_SWAP(inPtr, 2, 5); \
    __GLS_SWAP(inPtr, 3, 4);

extern const GLubyte __glsBitReverse[256];
extern const GLubyte __glsQuietNaN[8];

extern size_t __glsCeilBase2(size_t inVal);
extern size_t __glsLogBase2(size_t inVal);
GLulong __glsPtrToULong(const GLvoid *inPtr);
GLlong __glsSizeToLong(size_t inSize);
#define __glsSwap1(inoutVec)
extern void __glsSwap2(GLvoid *inoutVec);
extern void __glsSwap2v(size_t inCount, GLvoid *inoutVec);
extern void __glsSwap4(GLvoid *inoutVec);
extern void __glsSwap4v(size_t inCount, GLvoid *inoutVec);
extern void __glsSwap8(GLvoid *inoutVec);
extern void __glsSwap8v(size_t inCount, GLvoid *inoutVec);
extern GLint __glsSwapi(GLint inVal);
extern GLshort __glsSwaps(GLshort inVal);
extern void __glsSwapv(GLenum inType, size_t inBytes, GLvoid *inoutVec);

/******************************************************************************
String
******************************************************************************/

#define __GLS_STRING_BUF_BYTES 32

typedef GLubyte __GLSstringBuf[__GLS_STRING_BUF_BYTES];

typedef struct {
    GLubyte *head;
    GLubyte *tail;
    GLubyte *bufTail;
    __GLSstringBuf buf;
} __GLSstring;

extern GLboolean __glsString_append(
    __GLSstring *inoutString, const GLubyte* inAppend
);

extern GLboolean __glsString_appendChar(
    __GLSstring *inoutString, GLubyte inAppend
);

extern GLboolean __glsString_appendCounted(
    __GLSstring *inoutString, const GLubyte* inAppend, size_t inCount
);

extern GLboolean __glsString_appendInt(
    __GLSstring *inoutString, const GLubyte *inFormat, GLint inVal
);

extern GLboolean __glsString_assign(
    __GLSstring *inoutString, const GLubyte *inAssign
);

extern GLboolean __glsString_assignCounted(
    __GLSstring *inoutString, const GLubyte *inAssign, size_t inCount
);

extern void __glsString_final(__GLSstring *inoutString);
extern void __glsString_init(__GLSstring *outString);
extern size_t __glsString_length(const __GLSstring *inString);
extern void __glsString_reset(__GLSstring *inoutString);

extern const GLubyte* __glsUCS1String(const GLubyte *inUTF8String);
extern GLboolean __glsValidateString(const GLubyte *inString);

/******************************************************************************
Vertex array
******************************************************************************/

#define __GLS_PAD_EIGHT(v) (((v) + 7) & ~7)

#define __GLS_EXACT_ARRAY_SIZE(count, size, type) \
    ((count) * (size) * __glsTypeSize(type))
#define __GLS_ARRAY_SIZE(count, size, type) \
    __GLS_PAD_EIGHT(__GLS_EXACT_ARRAY_SIZE(count, size, type))

typedef struct
{
    GLint size;
    GLenum type;
    GLsizei stride;
    const GLvoid *data;
} __GLSsingleArrayState;

#define __GLS_VERTEX_ARRAY_ENABLE               0x00000001
#define __GLS_NORMAL_ARRAY_ENABLE               0x00000002
#define __GLS_COLOR_ARRAY_ENABLE                0x00000004
#define __GLS_INDEX_ARRAY_ENABLE                0x00000008
#define __GLS_TEXTURE_COORD_ARRAY_ENABLE        0x00000010
#define __GLS_EDGE_FLAG_ARRAY_ENABLE            0x00000020

#define __GLS_ARRAY_COUNT                       6

typedef struct
{
    GLuint enabled;
    __GLSsingleArrayState vertex;
    __GLSsingleArrayState normal;
    __GLSsingleArrayState color;
    __GLSsingleArrayState index;
    __GLSsingleArrayState textureCoord;
    __GLSsingleArrayState edgeFlag;
} __GLSarrayState;

extern void __glsGetArrayState(struct __GLScontext *ctx,
                               __GLSarrayState *arrayState);
extern GLint __glsArrayDataSize(GLsizei count, __GLSarrayState *arrayState);
extern void __glsWriteArrayData(struct __GLSwriter *writer, GLint size,
                                GLint first, GLsizei count,
                                GLenum type, const GLvoid *indices,
                                __GLSarrayState *arrayState);
extern void __glsSetArrayState(struct __GLScontext *ctx, GLubyte *data);
extern GLvoid *__glsSetArrayStateText(struct __GLScontext *ctx,
                                      struct __GLSreader *reader,
                                      GLuint *enabled, GLsizei *count);
extern void __glsDisableArrayState(struct __GLScontext *ctx, GLuint enabled);
extern void __glsSwapArrayData(GLubyte *data);

typedef struct
{
    void *freePtr;
    GLuint *indices;
    GLuint *vertices;
    GLint vtxCount;
} __GLSdrawElementsState;

extern GLint __glsDrawElementsDataSize(GLsizei count, GLenum type,
                                       const GLvoid *indices,
                                       __GLSarrayState *arrayState,
                                       __GLSdrawElementsState *deState);
extern void __glsWriteDrawElementsData(struct __GLSwriter *writer, GLint size,
                                       GLsizei count,
                                       __GLSarrayState *arrayState,
                                       __GLSdrawElementsState *deState);

#if defined(__cplusplus)
    }
#endif

#endif /* __glsutil_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\gls_wnt.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE APIENTRY

#include <windef.h>
#include <wingdi.h>
#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef __int64 GLlong;
typedef unsigned __int64 GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (GLS_LINKAGE *GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (GLS_LINKAGE *GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (GLS_LINKAGE *GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (GLS_LINKAGE *GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (GLS_LINKAGE *GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableSGI                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvSGI      65481
#define GLS_OP_glGetColorTableParameterivSGI      65482
#define GLS_OP_glGetColorTableSGI                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

/*************************************************************/

/* GLS global commands */
extern GLSenum GLS_LINKAGE glsBinary (GLboolean inSwapped);
extern GLSenum GLS_LINKAGE glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* GLS_LINKAGE glsCommandString (GLSopcode inOpcode);
extern void GLS_LINKAGE glsContext (GLuint inContext);
extern void GLS_LINKAGE glsDeleteContext (GLuint inContext);
extern const GLubyte* GLS_LINKAGE glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint GLS_LINKAGE glsGenContext (void);
extern GLuint* GLS_LINKAGE glsGetAllContexts (void);
extern GLScommandAlignment* GLS_LINKAGE glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield GLS_LINKAGE glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint GLS_LINKAGE glsGetConsti (GLSenum inAttrib);
extern const GLint* GLS_LINKAGE glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetConstubz (GLSenum inAttrib);
extern GLuint GLS_LINKAGE glsGetCurrentContext (void);
extern GLint* GLS_LINKAGE glsGetCurrentTime (GLint *outTime);
extern GLSenum GLS_LINKAGE glsGetError (GLboolean inClear);
extern GLint GLS_LINKAGE glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* GLS_LINKAGE glsGetOpcodes (GLSenum inAPI);
extern GLboolean GLS_LINKAGE glsIsContext (GLuint inContext);
extern GLboolean GLS_LINKAGE glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean GLS_LINKAGE glsIsUTF8String (const GLubyte *inString);
extern GLlong GLS_LINKAGE glsLong (GLint inHigh, GLuint inLow);
extern GLint GLS_LINKAGE glsLongHigh (GLlong inVal);
extern GLuint GLS_LINKAGE glsLongLow (GLlong inVal);
extern GLSfunc GLS_LINKAGE glsNullCommandFunc (GLSopcode inOpcode);
extern void GLS_LINKAGE glsPixelSetup (void);
extern GLulong GLS_LINKAGE glsULong (GLuint inHigh, GLuint inLow);
extern GLuint GLS_LINKAGE glsULongHigh (GLulong inVal);
extern GLuint GLS_LINKAGE glsULongLow (GLulong inVal);
extern GLint GLS_LINKAGE glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* GLS_LINKAGE glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint GLS_LINKAGE glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean GLS_LINKAGE glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean GLS_LINKAGE glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void GLS_LINKAGE glsAbortCall (GLSenum inMode);
extern GLboolean GLS_LINKAGE glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void GLS_LINKAGE glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void GLS_LINKAGE glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void GLS_LINKAGE glsChannel (GLSenum inTarget, FILE *inChannel);
extern void GLS_LINKAGE glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum GLS_LINKAGE glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsDataPointer (GLvoid *inPointer);
extern void GLS_LINKAGE glsDeleteReadPrefix (GLuint inIndex);
extern void GLS_LINKAGE glsDeleteStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndCapture (void);
extern void GLS_LINKAGE glsFlush (GLSenum inFlushType);
extern GLSfunc *GLS_LINKAGE glsGetCaptureDispatchTable(void);
extern GLbitfield GLS_LINKAGE glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetContextFunc (GLSenum inAttrib);
extern GLlong GLS_LINKAGE glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* GLS_LINKAGE glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* GLS_LINKAGE glsGetContextPointer (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetContexti (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetContextubz (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* GLS_LINKAGE glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint GLS_LINKAGE glsGetHeaderi (GLSenum inAttrib);
extern GLint* GLS_LINKAGE glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* GLS_LINKAGE glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield GLS_LINKAGE glsGetStreamAttrib (const GLubyte *inName);
extern GLuint GLS_LINKAGE glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* GLS_LINKAGE glsGetStreamReadName (const GLubyte *inName);
extern size_t GLS_LINKAGE glsGetStreamSize (const GLubyte *inName);
extern GLSenum GLS_LINKAGE glsGetStreamType (const GLubyte *inName);
extern GLboolean GLS_LINKAGE glsIsContextStream (const GLubyte *inName);
extern void GLS_LINKAGE glsPixelSetupGen (GLboolean inEnabled);
extern void GLS_LINKAGE glsReadFunc (GLSreadFunc inFunc);
extern void GLS_LINKAGE glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void GLS_LINKAGE glsUnreadFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWriteFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void GLS_LINKAGE glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void GLS_LINKAGE glsBlock (GLSenum inBlockType);
extern GLSenum GLS_LINKAGE glsCallStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndGLS (void);
extern void GLS_LINKAGE glsError (GLSopcode inOpcode, GLSenum inError);
extern void GLS_LINKAGE glsGLRC (GLuint inGLRC);
extern void GLS_LINKAGE glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void GLS_LINKAGE glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void GLS_LINKAGE glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void GLS_LINKAGE glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void GLS_LINKAGE glsRequireExtension (const GLubyte *inExtension);
extern void GLS_LINKAGE glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void GLS_LINKAGE glsAppRef (GLulong inAddress, GLuint inCount);
extern void GLS_LINKAGE glsBeginObj (const GLubyte *inTag);
extern void GLS_LINKAGE glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void GLS_LINKAGE glsComment (const GLubyte *inComment);
extern void GLS_LINKAGE glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsEndObj (void);
extern void GLS_LINKAGE glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void GLS_LINKAGE glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void GLS_LINKAGE glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void GLS_LINKAGE glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void GLS_LINKAGE glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void GLS_LINKAGE glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsNumi (const GLubyte *inTag, GLint inVal);
extern void GLS_LINKAGE glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void GLS_LINKAGE glsNuml (const GLubyte *inTag, GLlong inVal);
extern void GLS_LINKAGE glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void GLS_LINKAGE glsNums (const GLubyte *inTag, GLshort inVal);
extern void GLS_LINKAGE glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void GLS_LINKAGE glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void GLS_LINKAGE glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void GLS_LINKAGE glsNumui (const GLubyte *inTag, GLuint inVal);
extern void GLS_LINKAGE glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void GLS_LINKAGE glsNumul (const GLubyte *inTag, GLulong inVal);
extern void GLS_LINKAGE glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void GLS_LINKAGE glsNumus (const GLubyte *inTag, GLushort inVal);
extern void GLS_LINKAGE glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void GLS_LINKAGE glsPad (void);
extern void GLS_LINKAGE glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\gls_ll.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE

#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef long long GLlong;
typedef unsigned long long GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (*GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (*GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (*GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (*GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (*GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableSGI                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvSGI      65481
#define GLS_OP_glGetColorTableParameterivSGI      65482
#define GLS_OP_glGetColorTableSGI                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

/*************************************************************/

/* GLS global commands */
extern GLSenum glsBinary (GLboolean inSwapped);
extern GLSenum glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* glsCommandString (GLSopcode inOpcode);
extern void glsContext (GLuint inContext);
extern void glsDeleteContext (GLuint inContext);
extern const GLubyte* glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint glsGenContext (void);
extern GLuint* glsGetAllContexts (void);
extern GLScommandAlignment* glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint glsGetConsti (GLSenum inAttrib);
extern const GLint* glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* glsGetConstubz (GLSenum inAttrib);
extern GLuint glsGetCurrentContext (void);
extern GLint* glsGetCurrentTime (GLint *outTime);
extern GLSenum glsGetError (GLboolean inClear);
extern GLint glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* glsGetOpcodes (GLSenum inAPI);
extern GLboolean glsIsContext (GLuint inContext);
extern GLboolean glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean glsIsUTF8String (const GLubyte *inString);
extern GLlong glsLong (GLint inHigh, GLuint inLow);
extern GLint glsLongHigh (GLlong inVal);
extern GLuint glsLongLow (GLlong inVal);
extern GLSfunc glsNullCommandFunc (GLSopcode inOpcode);
extern void glsPixelSetup (void);
extern GLulong glsULong (GLuint inHigh, GLuint inLow);
extern GLuint glsULongHigh (GLulong inVal);
extern GLuint glsULongLow (GLulong inVal);
extern GLint glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void glsAbortCall (GLSenum inMode);
extern GLboolean glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void glsChannel (GLSenum inTarget, FILE *inChannel);
extern void glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void glsDataPointer (GLvoid *inPointer);
extern void glsDeleteReadPrefix (GLuint inIndex);
extern void glsDeleteStream (const GLubyte *inName);
extern void glsEndCapture (void);
extern void glsFlush (GLSenum inFlushType);
extern GLbitfield glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc glsGetContextFunc (GLSenum inAttrib);
extern GLlong glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* glsGetContextPointer (GLSenum inAttrib);
extern GLint glsGetContexti (GLSenum inAttrib);
extern const GLubyte* glsGetContextubz (GLSenum inAttrib);
extern GLint glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint glsGetHeaderi (GLSenum inAttrib);
extern GLint* glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield glsGetStreamAttrib (const GLubyte *inName);
extern GLuint glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* glsGetStreamReadName (const GLubyte *inName);
extern size_t glsGetStreamSize (const GLubyte *inName);
extern GLSenum glsGetStreamType (const GLubyte *inName);
extern GLboolean glsIsContextStream (const GLubyte *inName);
extern void glsPixelSetupGen (GLboolean inEnabled);
extern void glsReadFunc (GLSreadFunc inFunc);
extern void glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void glsUnreadFunc (GLSwriteFunc inFunc);
extern void glsWriteFunc (GLSwriteFunc inFunc);
extern void glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void glsBlock (GLSenum inBlockType);
extern GLSenum glsCallStream (const GLubyte *inName);
extern void glsEndGLS (void);
extern void glsError (GLSopcode inOpcode, GLSenum inError);
extern void glsGLRC (GLuint inGLRC);
extern void glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void glsRequireExtension (const GLubyte *inExtension);
extern void glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void glsAppRef (GLulong inAddress, GLuint inCount);
extern void glsBeginObj (const GLubyte *inTag);
extern void glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void glsComment (const GLubyte *inComment);
extern void glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void glsEndObj (void);
extern void glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void glsNumi (const GLubyte *inTag, GLint inVal);
extern void glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void glsNuml (const GLubyte *inTag, GLlong inVal);
extern void glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void glsNums (const GLubyte *inTag, GLshort inVal);
extern void glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void glsNumui (const GLubyte *inTag, GLuint inVal);
extern void glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void glsNumul (const GLubyte *inTag, GLulong inVal);
extern void glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void glsNumus (const GLubyte *inTag, GLushort inVal);
extern void glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void glsPad (void);
extern void glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\gls_ref.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE

#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef struct {GLuint uint0; GLuint uint1;} GLlong;
typedef struct {GLuint uint0; GLuint uint1;} GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (*GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (*GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (*GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (*GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (*GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableSGI                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvSGI      65481
#define GLS_OP_glGetColorTableParameterivSGI      65482
#define GLS_OP_glGetColorTableSGI                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

/*************************************************************/

/* GLS global commands */
extern GLSenum glsBinary (GLboolean inSwapped);
extern GLSenum glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* glsCommandString (GLSopcode inOpcode);
extern void glsContext (GLuint inContext);
extern void glsDeleteContext (GLuint inContext);
extern const GLubyte* glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint glsGenContext (void);
extern GLuint* glsGetAllContexts (void);
extern GLScommandAlignment* glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint glsGetConsti (GLSenum inAttrib);
extern const GLint* glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* glsGetConstubz (GLSenum inAttrib);
extern GLuint glsGetCurrentContext (void);
extern GLint* glsGetCurrentTime (GLint *outTime);
extern GLSenum glsGetError (GLboolean inClear);
extern GLint glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* glsGetOpcodes (GLSenum inAPI);
extern GLboolean glsIsContext (GLuint inContext);
extern GLboolean glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean glsIsUTF8String (const GLubyte *inString);
extern GLlong glsLong (GLint inHigh, GLuint inLow);
extern GLint glsLongHigh (GLlong inVal);
extern GLuint glsLongLow (GLlong inVal);
extern GLSfunc glsNullCommandFunc (GLSopcode inOpcode);
extern void glsPixelSetup (void);
extern GLulong glsULong (GLuint inHigh, GLuint inLow);
extern GLuint glsULongHigh (GLulong inVal);
extern GLuint glsULongLow (GLulong inVal);
extern GLint glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void glsAbortCall (GLSenum inMode);
extern GLboolean glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void glsChannel (GLSenum inTarget, FILE *inChannel);
extern void glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void glsDataPointer (GLvoid *inPointer);
extern void glsDeleteReadPrefix (GLuint inIndex);
extern void glsDeleteStream (const GLubyte *inName);
extern void glsEndCapture (void);
extern void glsFlush (GLSenum inFlushType);
extern GLbitfield glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc glsGetContextFunc (GLSenum inAttrib);
extern GLlong glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* glsGetContextPointer (GLSenum inAttrib);
extern GLint glsGetContexti (GLSenum inAttrib);
extern const GLubyte* glsGetContextubz (GLSenum inAttrib);
extern GLint glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint glsGetHeaderi (GLSenum inAttrib);
extern GLint* glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield glsGetStreamAttrib (const GLubyte *inName);
extern GLuint glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* glsGetStreamReadName (const GLubyte *inName);
extern size_t glsGetStreamSize (const GLubyte *inName);
extern GLSenum glsGetStreamType (const GLubyte *inName);
extern GLboolean glsIsContextStream (const GLubyte *inName);
extern void glsPixelSetupGen (GLboolean inEnabled);
extern void glsReadFunc (GLSreadFunc inFunc);
extern void glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void glsUnreadFunc (GLSwriteFunc inFunc);
extern void glsWriteFunc (GLSwriteFunc inFunc);
extern void glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void glsBlock (GLSenum inBlockType);
extern GLSenum glsCallStream (const GLubyte *inName);
extern void glsEndGLS (void);
extern void glsError (GLSopcode inOpcode, GLSenum inError);
extern void glsGLRC (GLuint inGLRC);
extern void glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void glsRequireExtension (const GLubyte *inExtension);
extern void glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void glsAppRef (GLulong inAddress, GLuint inCount);
extern void glsBeginObj (const GLubyte *inTag);
extern void glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void glsComment (const GLubyte *inComment);
extern void glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void glsEndObj (void);
extern void glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void glsNumi (const GLubyte *inTag, GLint inVal);
extern void glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void glsNuml (const GLubyte *inTag, GLlong inVal);
extern void glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void glsNums (const GLubyte *inTag, GLshort inVal);
extern void glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void glsNumui (const GLubyte *inTag, GLuint inVal);
extern void glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void glsNumul (const GLubyte *inTag, GLulong inVal);
extern void glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void glsNumus (const GLubyte *inTag, GLushort inVal);
extern void glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void glsPad (void);
extern void glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\pixel.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

extern void __glsGenPixelSetup_pack(struct __GLScontext *ctx);
extern void __glsGenPixelSetup_unpack(struct __GLScontext *ctx);
extern void __glsPixelSetup_pack(void);
extern void __glsPixelSetup_unpack(void);

typedef struct {
    GLint alignment;
    GLint lsbFirst;
    GLint rowLength;
    GLint skipRows;
    GLint skipPixels;
    GLint swapBytes;
    #if __GL_EXT_texture3D
        GLint imageHeight;
        GLint skipImages;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        GLint imageDepth;
        GLint skipVolumes;
    #endif /* __GL_SGIS_texture4D */
} __GLSpixelStoreConfig;

extern void __glsPixelStoreConfig_get_pack(
    __GLSpixelStoreConfig *outConfig
);
extern void __glsPixelStoreConfig_get_unpack(
    __GLSpixelStoreConfig *outConfig
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\write.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
__GLSwriteStream
******************************************************************************/

typedef struct {
    FILE *channel;
    __GLSstring name;
    GLboolean created;
    GLboolean opened;
    GLSwriteFunc writeFunc;
} __GLSwriteStream;

extern __GLSwriteStream* __glsWriteStream_create(
    const GLubyte *inName, GLboolean inAppend
);

extern __GLSwriteStream* __glsWriteStream_destroy(__GLSwriteStream *inStream);
extern size_t __glsWriteStream_getByteCount(const __GLSwriteStream *inStream);

/******************************************************************************
__GLSwriter
******************************************************************************/

typedef struct __GLSwriter __GLSwriter;

struct __GLSwriter {
    GLboolean (*alloc)(
        __GLSwriter *inoutWriter, size_t inWordCount
    );
    GLboolean (*beginCommand)(
        __GLSwriter *inoutWriter, GLSopcode inOpcode, size_t inByteCount
    );
    void (*endCommand)(
        __GLSwriter *inoutWriter
    );
    void (*nextList)(
        __GLSwriter *inoutWriter
    );
    GLboolean (*padWordCount)(
        __GLSwriter *inoutWriter, GLboolean inCountMod2
    );
    void (*putGLSenum)(
        __GLSwriter *inoutWriter, GLSenum inVal
    );
    void (*putGLSimageFlags)(
        __GLSwriter *inoutWriter, GLbitfield inVal
    );
    void (*putGLSopcode)(
        __GLSwriter *inoutWriter, GLSopcode inVal
    );
    void (*putGLattribMask)(
        __GLSwriter *inoutWriter, GLbitfield inVal
    );
    void (*putGLbitvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inItemLeftShift,
        GLint inStrideDataItems,
        GLint inStridePadItems,
        GLint inStrideCount,
        const GLubyte *inVec
    );
    void (*putGLblendingFactor)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLboolean)(
        __GLSwriter *inoutWriter, GLboolean inVal
    );
    void (*putGLbooleanv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLboolean *inVec
    );
    void (*putGLbooleanvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLboolean *inVec
    );
    void (*putGLbyte)(
        __GLSwriter *inoutWriter, GLbyte inVal
    );
    void (*putGLbytev)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLbyte *inVec
    );
    void (*putGLbytevs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLbyte *inVec
    );
    void (*putGLcharv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLubyte *inVec
    );
    void (*putGLclearBufferMask)(
        __GLSwriter *inoutWriter, GLbitfield inVal
    );
    void (*putGLdouble)(
        __GLSwriter *inoutWriter, GLdouble inVal
    );
    void (*putGLdoubleOrGLenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLdouble inVal
    );
    void (*putGLdoubleOrGLenumv)(
        __GLSwriter *inoutWriter,
        GLenum inParam, GLuint inCount, const GLdouble *inVec
    );
    void (*putGLdoublem)(
        __GLSwriter *inoutWriter, const GLdouble *inMat
    );
    void (*putGLdoublev)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLdouble *inVec
    );
    void (*putGLdoublevs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLdouble *inVec
    );
    void (*putGLdrawBufferMode)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLenum)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLfloat)(
        __GLSwriter *inoutWriter, GLfloat inVal
    );
    void (*putGLfloatOrGLenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLfloat inVal
    );
    void (*putGLfloatOrGLenumv)(
        __GLSwriter *inoutWriter,
        GLenum inParam, GLuint inCount, const GLfloat *inVec
    );
    void (*putGLfloatm)(
        __GLSwriter *inoutWriter, const GLfloat *inMat
    );
    void (*putGLfloatv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLfloat *inVec
    );
    void (*putGLfloatvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLfloat *inVec
    );
    void (*putGLint)(
        __GLSwriter *inoutWriter, GLint inVal
    );
    void (*putGLintOrGLSenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLint inVal
    );
    void (*putGLintOrGLenum)(
        __GLSwriter *inoutWriter, GLenum inParam, GLint inVal
    );
    void (*putGLintOrGLenumv)(
        __GLSwriter *inoutWriter,
        GLenum inParam, GLuint inCount, const GLint *inVec
    );
    void (*putGLintv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLint *inVec
    );
    void (*putGLintvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLint *inVec
    );
    void (*putGLlong)(
        __GLSwriter *inoutWriter, GLlong inVal
    );
    void (*putGLlongv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLlong *inVec
    );
    void (*putGLoutArg)(
        __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
    );
    void (*putGLshort)(
        __GLSwriter *inoutWriter, GLshort inVal
    );
    void (*putGLshortv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLshort *inVec
    );
    void (*putGLshortvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLshort *inVec
    );
    void (*putGLstencilOp)(
        __GLSwriter *inoutWriter, GLenum inVal
    );
    void (*putGLtextureComponentCount)(
        __GLSwriter *inoutWriter, GLint inVal
    );
    void (*putGLubyte)(
        __GLSwriter *inoutWriter, GLubyte inVal
    );
    void (*putGLubytev)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLubyte *inVec
    );
    void (*putGLubytevs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLubyte *inVec
    );
    void (*putGLuint)(
        __GLSwriter *inoutWriter, GLuint inVal
    );
    void (*putGLuinthex)(
        __GLSwriter *inoutWriter, GLuint inVal
    );
    void (*putGLuintv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLuint *inVec
    );
    void (*putGLuintvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLuint *inVec
    );
    void (*putGLulong)(
        __GLSwriter *inoutWriter, GLulong inVal
    );
    void (*putGLulonghex)(
        __GLSwriter *inoutWriter, GLulong inVal
    );
    void (*putGLulongv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLulong *inVec
    );
    void (*putGLushort)(
        __GLSwriter *inoutWriter, GLushort inVal
    );
    void (*putGLushorthex)(
        __GLSwriter *inoutWriter, GLushort inVal
    );
    void (*putGLushortv)(
        __GLSwriter *inoutWriter, GLuint inCount, const GLushort *inVec
    );
    void (*putGLushortvs)(
        __GLSwriter *inoutWriter,
        GLboolean inItemSwap,
        GLint inStride1DataItems,
        GLint inStride1PadBytes,
        GLint inStride1Count,
        GLint inStride2PadBytes,
        GLint inStride2Count,
        const GLushort *inVec
    );
    GLubyte *bufPtr;
    GLubyte *bufTail;
    GLSopcode commandOpcode;
    GLubyte *commandHead;
    GLubyte *commandTail;
    GLboolean contextCreated;
    __GLScontextStream *contextStream;
    GLboolean error;
    GLubyte *externBuf;
    GLubyte *externBufHead;
    __GLSwriteStream *externStream;
    GLint paramCount;
    __GLSbinCommandHead_large *prevCommand;
    __GLScontextStreamBlock *startBlock;
    size_t startOffset;
    GLSenum type;
    size_t wordCount;
};

extern __GLSwriter* __glsWriter_create(
    const GLubyte *inStreamName, GLSenum inStreamType, GLbitfield inWriteFlags
);

extern __GLSwriter* __glsWriter_destroy(__GLSwriter *inWriter);
extern GLboolean __glsWriter_flush(__GLSwriter *inoutWriter);

extern void __glsWriter_putListv(
    __GLSwriter *inoutWriter,
    GLenum inType,
    GLint inCount,
    const GLvoid *inVec
);

extern void __glsWriter_putPixelv(
    __GLSwriter *inoutWriter,
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    const GLvoid *inVec
);

// DrewB - Always enabled for 1.1 support
extern void __glsWriter_putVertexv(
        __GLSwriter *inoutWriter,
        GLint inSize,
        GLenum inType,
        GLint inStride,
        GLint inCount,
        const GLvoid *inVec
    );

/******************************************************************************
__GLSwriter binary
******************************************************************************/

extern void __glsWriter_initDispatch_bin(
    __GLSwriter *inoutWriter, GLSenum inStreamType
);

/******************************************************************************
__GLSwriter text
******************************************************************************/

extern void __glsWriter_initDispatch_text(
    __GLSwriter *inoutWriter
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\platform.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
AIX
******************************************************************************/

#if __GLS_PLATFORM_AIX

    #pragma alloca

    #define __GL_LIB_NAME "libGL.a"
    #define __GLS_FAKE_THREAD_LOCAL_STORAGE 1
    #define __GLS_GL_DISPATCH 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_PLATFORM "AIX"

    #if !__GLS_FAKE_FINITE_FUNC
        extern int finite(double);
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_AIX */

/******************************************************************************
DECUNIX
******************************************************************************/

#if __GLS_PLATFORM_DECUNIX

    #include <alloca.h>
    #include <errno.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_GL_DISPATCH_DSO 1
    #define __GLS_INT64 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_OUT_FORMAT_INT64 "%ld"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16lx"
    #define __GLS_OUT_FORMAT_INT64U "%lu"
    #define __GLS_PLATFORM "Digital UNIX"
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 strtol
    #define __GLS_STR_TO_INT64U strtoul

    #if !__GLS_FAKE_FINITE_FUNC
        #include <math.h>
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include <pthread.h>

        extern pthread_key_t __gls_contextTLS;
        extern __GLScontext* __glsGetContext(void);
        #define __GLS_CONTEXT __glsGetContext()
        #define __GLS_PUT_CONTEXT(inContext) \
            pthread_setspecific(__gls_contextTLS, (pthread_addr_t)inContext)

        extern pthread_key_t __gls_errorTLS;
        extern GLSenum __glsGetError(void);
        #define __GLS_ERROR __glsGetError()
        #define __GLS_PUT_ERROR(inError) \
            pthread_setspecific(__gls_errorTLS, (pthread_addr_t)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

    #define __GLS_ERRNO _Geterrno()
    #define __GLS_PUT_ERRNO(inError) _Seterrno(inError)

#endif /* __GLS_PLATFORM_DECUNIX */

/******************************************************************************
HPUX
******************************************************************************/

#if __GLS_PLATFORM_HPUX

    #define __GL_LIB_NAME "libGL.sl"
    #define __GLS_FAKE_MUTEX 1
    #define __GLS_FAKE_THREAD_LOCAL_STORAGE 1
    #define __GLS_GL_DISPATCH 1
    #define __GLS_INT64 1
    #define __GLS_PLATFORM "HP-UX"

    #if !__GLS_FAKE_FINITE_FUNC
        extern int finite(double);
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_HPUX */

/******************************************************************************
IRIX
******************************************************************************/

#if __GLS_PLATFORM_IRIX

    #include <alloca.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_INT64 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_OUT_FORMAT_INT64 "%lld"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16llx"
    #define __GLS_OUT_FORMAT_INT64U "%llu"
    #define __GLS_PLATFORM "IRIX"
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 strtoll
    #define __GLS_STR_TO_INT64U strtoull

    extern GLlong strtoll(const char *, char **, int);
    extern GLulong strtoull(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        #include <ieeefp.h>
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include "os.h"

        #define __GLS_CONTEXT \
            (PAGE_ONE->glsContext)
        #define __GLS_PUT_CONTEXT(inContext) \
            __GLS_CONTEXT = inContext

        #define __GLS_ERROR \
            (PAGE_ONE->glsError)
        #define __GLS_PUT_ERROR(inError) \
            __GLS_ERROR = inError
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <sys/types.h>
        extern int fileno(FILE *inChannel);
        extern int ftruncate(int, off_t);
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), (off_t)inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

    extern GLint oserror(void);
    #define __GLS_ERRNO oserror()

    extern GLint setoserror(GLint inError);
    #define __GLS_PUT_ERRNO(inError) setoserror(inError)

#endif /* __GLS_PLATFORM_IRIX */

/******************************************************************************
LINUX
******************************************************************************/

#if __GLS_PLATFORM_LINUX

    #include <alloca.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_GL_DISPATCH_DSO 1
    #define __GLS_INT64 1
    #define __GLS_OUT_FORMAT_INT64 "%qd"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16qx"
    #define __GLS_OUT_FORMAT_INT64U "%qu"
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_PLATFORM "Linux"
    #define __GLS_POSIX_THREADS 0
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 strtoq
    #define __GLS_STR_TO_INT64U strtouq

    extern GLlong strtoq(const char *, char **, int);
    extern GLulong strtouq(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        #include <math.h>
        #define __GLS_FINITE(inDouble) __finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        extern int fileno(FILE *inChannel);
        extern int ftruncate(int, size_t);
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

    #if !__GLS_POSIX_THREADS
        #define __GLS_FAKE_MUTEX 1
        #define __GLS_FAKE_THREAD_LOCAL_STORAGE 1
    #endif /* !__GLS_POSIX_THREADS */

#endif /* __GLS_PLATFORM_LINUX */

/******************************************************************************
SOLARIS
******************************************************************************/

#if __GLS_PLATFORM_SOLARIS

    #include <errno.h>

    #define __GL_LIB_NAME "libGL.so"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_GL_DISPATCH_DSO 1
    #define __GLS_INT64 1
    #define __GLS_INT64_TO_STR lltostr
    #define __GLS_INT64U_TO_STR ulltostr
    #define __GLS_PLATFORM "Solaris"
    #define __GLS_STR_TO_INT64 strtoll
    #define __GLS_STR_TO_INT64U strtoull

    extern char *lltostr(GLlong, char *);
    extern char *ulltostr(GLulong, char *);
    extern GLlong strtoll(const char *, char **, int);
    extern GLulong strtoull(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        extern int finite(double);
        #define __GLS_FINITE(inDouble) finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include <thread.h>

        extern thread_key_t __gls_contextTLS;
        extern __GLScontext* __glsGetContext(void);
        #define __GLS_CONTEXT __glsGetContext()
        #define __GLS_PUT_CONTEXT(inContext) \
            thr_setspecific(__gls_contextTLS, inContext)

        extern thread_key_t __gls_errorTLS;
        extern GLSenum __glsGetError(void);
        #define __GLS_ERROR __glsGetError()
        #define __GLS_PUT_ERROR(inError) \
            thr_setspecific(__gls_errorTLS, (void *)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <unistd.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            ftruncate(fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_SOLARIS */

/******************************************************************************
WIN32
******************************************************************************/

#if __GLS_PLATFORM_WIN32

    #pragma warning(disable:4769)

    #include <excpt.h>
    #include <malloc.h>
    #include <winbase.h>

    #define __GL_LIB_NAME "opengl32.dll"
    #define __GLS_GL_DISPATCH 1
    #define __GLS_INT64 1
    #define __GLS_MAX_ALLOCA_BYTES 65536
    #define __GLS_OUT_FORMAT_INT64 "%I64d"
    #define __GLS_OUT_FORMAT_INT64HEX "0x%.16I64x"
    #define __GLS_OUT_FORMAT_INT64U "%I64u"
    #define __GLS_PLATFORM "Win32"
    #define __GLS_SINGLE_NULL_COMMAND_FUNC 0
    #define __GLS_SPRINTF_INT64 1
    #define __GLS_STR_TO_INT64 __gls_strtoi64
    #define __GLS_STR_TO_INT64U __gls_strtoui64

    #define __GLS_DEC_ALLOC_BIN(inParam, inType, inByteCount) \
        if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) __try { \
            inParam = (inType *)_alloca(inByteCount); \
        } __except(EXCEPTION_CONTINUE_EXECUTION) {} \
        if (!inParam) { \
            inParam = (inType *)__glsMalloc(inByteCount); \
            inParam##_malloc = GL_TRUE; \
        }

    #define __GLS_DEC_ALLOC_TEXT(inoutReader, inParam, inType, inByteCount) \
        if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) __try { \
            inParam = (inType *)_alloca(inByteCount); \
        } __except(EXCEPTION_CONTINUE_EXECUTION) {} \
        if (!inParam) { \
            inParam = (inType *)__glsReader_allocCallBuf( \
                inoutReader, inByteCount \
            ); \
            inParam##_malloc = GL_TRUE; \
        }

    extern GLlong __gls_strtoi64(const char *, char **, int);
    extern GLulong __gls_strtoui64(const char *, char **, int);

    #if !__GLS_FAKE_FINITE_FUNC
        #include <float.h>
        #define __GLS_FINITE(inDouble) _finite(inDouble)
    #endif /* !__GLS_FAKE_FINITE_FUNC */

    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        extern GLint __gls_contextTLS;
        #define __GLS_CONTEXT \
            ((__GLScontext *)TlsGetValue(__gls_contextTLS))
        #define __GLS_PUT_CONTEXT(inContext) \
            TlsSetValue(__gls_contextTLS, inContext)

        extern GLint __gls_errorTLS;
        #define __GLS_ERROR \
            ((GLSenum)((ULONG_PTR)TlsGetValue(__gls_errorTLS)))
        #define __GLS_PUT_ERROR(inError) \
            TlsSetValue(__gls_errorTLS, (GLvoid *)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

    #if !__GLS_FAKE_TRUNCATE_FUNC
        #include <io.h>
        #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) \
            _chsize(_fileno(inChannel), inByteCount)
    #endif /* !__GLS_FAKE_TRUNCATE_FUNC */

#endif /* __GLS_PLATFORM_WIN32 */

/******************************************************************************
Default definitions
******************************************************************************/

#if !defined(__GLS_CHECKSUM_BUF_BYTES)
    #define __GLS_CHECKSUM_BUF_BYTES 4096
#endif /* !defined(__GLS_CHECKSUM_BUF_BYTES) */

#if !defined(__GLS_CONTEXT_STREAM_BLOCK_BYTES)
    #define __GLS_CONTEXT_STREAM_BLOCK_BYTES 65536
#endif /* !defined(__GLS_CONTEXT_STREAM_BLOCK_BYTES) */

#if !defined(__GLS_READER_BUF_BYTES)
    #define __GLS_READER_BUF_BYTES 16384
#endif /* !defined(__GLS_READER_BUF_BYTES) */

#if !defined(__GLS_PLATFORM)
    #define __GLS_PLATFORM "Unknown"
#endif /* !defined(__GLS_PLATFORM) */

#if !defined(__GLS_RELEASE)
    #define __GLS_RELEASE "Unknown"
#endif /* !defined(__GLS_RELEASE) */

#if !defined(__GLS_SINGLE_NULL_COMMAND_FUNC)
    #define __GLS_SINGLE_NULL_COMMAND_FUNC 1
#endif /* !defined(__GLS_SINGLE_NULL_COMMAND_FUNC) */

#if !defined(__GLS_VENDOR)
    #define __GLS_VENDOR "ARB"
#endif /* !defined(__GLS_VENDOR) */

#if !defined(__GLS_WRITER_EXTERN_BUF_BYTES)
    #define __GLS_WRITER_EXTERN_BUF_BYTES 16384
#endif /* !defined(__GLS_WRIER_EXTERN_BUF_BYTES) */

#if !defined(__GLS_WRITER_EXTERN_BUF_SLOP)
    #define __GLS_WRITER_EXTERN_BUF_SLOP 256
#endif /* !defined(__GLS_WRITER_EXTERN_BUF_SLOP) */

#if !defined(__GLS_ERRNO)
    #define __GLS_ERRNO errno
#endif /* !defined(__GLS_ERRNO) */

#if !defined(__GLS_PUT_ERRNO)
    #define __GLS_PUT_ERRNO(inError) errno = inError
#endif /* !defined(__GLS_PUT_ERRNO) */

/******************************************************************************
Required platform-specific functions
******************************************************************************/

extern void __glsBeginCriticalSection(void);
extern void __glsEndCriticalSection(void);
extern void __glsUpdateDispatchTables(void);

#ifndef __GLS_PLATFORM_WIN32
// DrewB
extern void __glsBeginCaptureExec(GLSopcode inOpcode);
extern void __glsEndCaptureExec(GLSopcode inOpcode);
#define __GLS_BEGIN_CAPTURE_EXEC(ctx, op) __glsBeginCaptureExec(op)
#define __GLS_END_CAPTURE_EXEC(ctx, op) __glsEndCaptureExec(op)
#else
extern void __glsBeginCaptureExec(__GLScontext *ctx, GLSopcode inOpcode);
extern void __glsEndCaptureExec(__GLScontext *ctx, GLSopcode inOpcode);
#define __GLS_BEGIN_CAPTURE_EXEC(ctx, op) __glsBeginCaptureExec(ctx, op)
#define __GLS_END_CAPTURE_EXEC(ctx, op) __glsEndCaptureExec(ctx, op)
#endif

/******************************************************************************
Alloca
******************************************************************************/

#if defined(__GLS_MAX_ALLOCA_BYTES)

    #define __GLS_DEC_ALLOC_DECLARE(inParam) \
        GLboolean inParam##_malloc = GL_FALSE;

    #if !defined(__GLS_DEC_ALLOC_BIN)
        #define __GLS_DEC_ALLOC_BIN(inParam, inType, inByteCount) \
            if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) { \
                inParam = (inType *)alloca(inByteCount); \
            } \
            if (!inParam) { \
                inParam = (inType *)__glsMalloc(inByteCount); \
                inParam##_malloc = GL_TRUE; \
            }
    #endif /* !defined(__GLS_DEC_ALLOC_BIN) */

    #if !defined(__GLS_DEC_ALLOC_TEXT)
        #define __GLS_DEC_ALLOC_TEXT( \
            inoutReader, inParam, inType, inByteCount \
        ) \
            if (inByteCount <= __GLS_MAX_ALLOCA_BYTES) { \
                inParam = (inType *)alloca(inByteCount); \
            } \
            if (!inParam) { \
                inParam = (inType *)__glsReader_allocCallBuf( \
                    inoutReader, inByteCount \
                ); \
                inParam##_malloc = GL_TRUE; \
            }
    #endif /* !defined(__GLS_DEC_ALLOC_TEXT) */

    #define __GLS_DEC_FREE(inParam) \
        if (inParam##_malloc) free(inParam)

#else /* !defined(__GLS_MAX_ALLOCA_BYTES) */

    #define __GLS_DEC_ALLOC_DECLARE(inParam)

    #define __GLS_DEC_ALLOC_BIN(inParam, inType, inByteCount) \
        inParam = (inType *)__glsMalloc(inByteCount)

    #define __GLS_DEC_ALLOC_TEXT(inoutReader, inParam, inType, inByteCount) \
        inParam = (inType *)__glsReader_allocCallBuf(inoutReader, inByteCount)

    #define __GLS_DEC_FREE(inParam) \
        free(inParam)

#endif /* defined(__GLS_MAX_ALLOCA_BYTES) */

/******************************************************************************
POSIX threads
******************************************************************************/

#if __GLS_POSIX_THREADS
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        #include <pthread.h>

        extern pthread_key_t __gls_contextTLS;
        extern __GLScontext* __glsGetContext(void);
        #define __GLS_CONTEXT __glsGetContext()
        #define __GLS_PUT_CONTEXT(inContext) \
            pthread_setspecific(__gls_contextTLS, inContext)

        extern pthread_key_t __gls_errorTLS;
        extern GLSenum __glsGetError(void);
        #define __GLS_ERROR __glsGetError()
        #define __GLS_PUT_ERROR(inError) \
            pthread_setspecific(__gls_errorTLS, (GLvoid *)inError)
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
#endif /* __GLS_POSIX_THREADS */

/******************************************************************************
Fake finite function
******************************************************************************/

#if __GLS_FAKE_FINITE_FUNC
    #define __GLS_FINITE(inDouble) GL_TRUE
#endif /* __GLS_FAKE_FINITE_FUNC */

/******************************************************************************
Fake thread-local storage
******************************************************************************/

#if __GLS_FAKE_THREAD_LOCAL_STORAGE
    extern __GLScontext *__gls_context;
    #define __GLS_CONTEXT \
        __gls_context
    #define __GLS_PUT_CONTEXT(inContext) \
        __gls_context = inContext

    extern GLSenum __gls_error;
    #define __GLS_ERROR \
        __gls_error
    #define __GLS_PUT_ERROR(inError) \
        __gls_error = inError
#endif /* __GLS_FAKE_THREAD_LOCAL_STORAGE */

/******************************************************************************
Fake truncate function
******************************************************************************/

#if __GLS_FAKE_TRUNCATE_FUNC
    #define __GLS_TRUNCATE_EXTERN(inChannel, inByteCount) -1
#endif /* __GLS_FAKE_TRUNCATE_FUNC */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\cap.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

void __gls_capture_glMap1d(
    GLenum target,
    GLdouble u1,
    GLdouble u2,
    GLint stride,
    GLint order,
    const GLdouble *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap1d);
    captureFlags = ctx->captureFlags[GLS_OP_glMap1d];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap1d);
        glMap1d(target, u1, u2, stride, order, points);
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap1d);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (stride >= k) {
        pad = stride - k;
        stride = k;
    } else {
        k = pad = 0;
    }
    if (!writer->padWordCount(writer, 0)) goto end;
    if (
        !writer->beginCommand(
            writer, GLS_OP_glMap1d, 28 + __GLS_MAX(k * order * 8, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
    } else {
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
    }
    if (pad) {
        writer->putGLdoublevs(
            writer, GL_FALSE, k, pad * 8, order, 0, 1, points
        );
    } else {
        writer->putGLdoublev(writer, k * order, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap1d);
    --ctx->captureEntryCount;
}

void __gls_capture_glMap1f(
    GLenum target,
    GLfloat u1,
    GLfloat u2,
    GLint stride,
    GLint order,
    const GLfloat *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap1f);
    captureFlags = ctx->captureFlags[GLS_OP_glMap1f];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap1f);
        glMap1f(target, u1, u2, stride, order, points);
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap1f);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (stride >= k) {
        pad = stride - k;
        stride = k;
    } else {
        k = pad = 0;
    }
    if (
        !writer->beginCommand(
            writer, GLS_OP_glMap1f, 20 + __GLS_MAX(k * order * 4, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
    } else {
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
    }
    if (pad) {
        writer->putGLfloatvs(
            writer, GL_FALSE, k, pad * 4, order, 0, 1, points
        );
    } else {
        writer->putGLfloatv(writer, k * order, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap1f);
    --ctx->captureEntryCount;
}

void __gls_capture_glMap2d( \
    GLenum target,
    GLdouble u1,
    GLdouble u2,
    GLint ustride,
    GLint uorder,
    GLdouble v1,
    GLdouble v2,
    GLint vstride,
    GLint vorder,
    const GLdouble *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad0, pad1;
    GLint *const order0 = (ustride >= vstride) ? &vorder : &uorder;
    GLint *const order1 = (ustride >= vstride) ? &uorder : &vorder;
    GLint *const stride0 = (ustride >= vstride) ? &vstride : &ustride;
    GLint *const stride1 = (ustride >= vstride) ? &ustride : &vstride;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap2d);
    captureFlags = ctx->captureFlags[GLS_OP_glMap2d];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap2d);
        glMap2d(
            target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
        );
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap2d);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (*stride0 >= k) {
        pad0 = *stride0 - k;
        pad1 = *stride1 - *order0 * k;
        *stride0 = k;
        *stride1 = *order0 * k;
    } else {
        k = pad0 = pad1 = 0;
    }
    if (!writer->padWordCount(writer, 0)) goto end;
    if (
        !writer->beginCommand(
            writer,
            GLS_OP_glMap2d,
            52 + __GLS_MAX(k * vorder * uorder * 8, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
    } else {
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
    }
    if (pad1 || pad0) {
        writer->putGLdoublevs(
            writer, GL_FALSE, k, pad0 * 8, *order0, pad1 * 8, *order1, points
        );
    } else {
        writer->putGLdoublev(writer, k * vorder * uorder, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap2d);
    --ctx->captureEntryCount;
}

void __gls_capture_glMap2f( \
    GLenum target,
    GLfloat u1,
    GLfloat u2,
    GLint ustride,
    GLint uorder,
    GLfloat v1,
    GLfloat v2,
    GLint vstride,
    GLint vorder,
    const GLfloat *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad0, pad1;
    GLint *const order0 = (ustride >= vstride) ? &vorder : &uorder;
    GLint *const order1 = (ustride >= vstride) ? &uorder : &vorder;
    GLint *const stride0 = (ustride >= vstride) ? &vstride : &ustride;
    GLint *const stride1 = (ustride >= vstride) ? &ustride : &vstride;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap2f);
    captureFlags = ctx->captureFlags[GLS_OP_glMap2f];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap2f);
        glMap2f(
            target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
        );
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap2f);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (*stride0 >= k) {
        pad0 = *stride0 - k;
        pad1 = *stride1 - *order0 * k;
        *stride0 = k;
        *stride1 = *order0 * k;
    } else {
        k = pad0 = pad1 = 0;
    }
    if (
        !writer->beginCommand(
            writer,
            GLS_OP_glMap2f,
            36 + __GLS_MAX(k * vorder * uorder * 4, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLfloat(writer, v1);
        writer->putGLfloat(writer, v2);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
    } else {
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
        writer->putGLfloat(writer, v1);
        writer->putGLfloat(writer, v2);
    }
    if (pad0 || pad1) {
        writer->putGLfloatvs(
            writer, GL_FALSE, k, pad0 * 4, *order0, pad1 * 4, *order1, points
        );
    } else {
        writer->putGLfloatv(writer, k * vorder * uorder, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap2f);
    --ctx->captureEntryCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\dec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

// DrewB - All functions changed to use passed in context

void __gls_decode_bin_glsBeginPoints(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_POINTS
    );
}

void __gls_decode_bin_glsBeginLines(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_LINES
    );
}

void __gls_decode_bin_glsBeginLineLoop(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_LINE_LOOP
    );
}

void __gls_decode_bin_glsBeginLineStrip(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_LINE_STRIP
    );
}

void __gls_decode_bin_glsBeginTriangles(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_TRIANGLES
    );
}

void __gls_decode_bin_glsBeginTriangleStrip(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_TRIANGLE_STRIP
    );
}

void __gls_decode_bin_glsBeginTriangleFan(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_TRIANGLE_FAN
    );
}

void __gls_decode_bin_glsBeginQuads(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_QUADS
    );
}

void __gls_decode_bin_glsBeginQuadStrip(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_QUAD_STRIP
    );
}

void __gls_decode_bin_glsBeginPolygon(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_POLYGON
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\encoding.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

const GLubyte __glsCharType[256] = {
    /* nul 0x00 */    0,
    /* soh 0x01 */    0,
    /* stx 0x02 */    0,
    /* etx 0x03 */    0,
    /* eot 0x04 */    0,
    /* enq 0x05 */    0,
    /* ack 0x06 */    0,
    /* bel 0x07 */    0,
    /* bs  0x08 */    0,
    /* ht  0x09 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* nl  0x0A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* vt  0x0B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* np  0x0C */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* cr  0x0D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* so  0x0E */    0,
    /* si  0x0F */    0,
    /* dle 0x10 */    0,
    /* dc1 0x11 */    0,
    /* dc2 0x12 */    0,
    /* dc3 0x13 */    0,
    /* dc4 0x14 */    0,
    /* nak 0x15 */    0,
    /* syn 0x16 */    0,
    /* etb 0x17 */    0,
    /* can 0x18 */    0,
    /* em  0x19 */    0,
    /* sub 0x1A */    0,
    /* esc 0x1B */    0,
    /* fs  0x1C */    0,
    /* gs  0x1D */    0,
    /* rs  0x1E */    0,
    /* us  0x1F */    0,
    /* sp  0x20 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* !   0x21 */    __GLS_CHAR_GRAPHIC_BIT,
    /* "   0x22 */    __GLS_CHAR_GRAPHIC_BIT,
    /* #   0x23 */    __GLS_CHAR_GRAPHIC_BIT,
    /* $   0x24 */    __GLS_CHAR_GRAPHIC_BIT,
    /* %   0x25 */    __GLS_CHAR_GRAPHIC_BIT,
    /* &   0x26 */    __GLS_CHAR_GRAPHIC_BIT,
    /* '   0x27 */    __GLS_CHAR_GRAPHIC_BIT,
    /* (   0x28 */    __GLS_CHAR_GRAPHIC_BIT,
    /* )   0x29 */    __GLS_CHAR_GRAPHIC_BIT,
    /* *   0x2A */    __GLS_CHAR_GRAPHIC_BIT,
    /* +   0x2B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* ,   0x2C */    __GLS_CHAR_GRAPHIC_BIT,
    /* -   0x2D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* .   0x2E */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* /   0x2F */    __GLS_CHAR_GRAPHIC_BIT,
    /* 0   0x30 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 1   0x31 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 2   0x32 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 3   0x33 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 4   0x34 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 5   0x35 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 6   0x36 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 7   0x37 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 8   0x38 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 9   0x39 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* :   0x3A */    __GLS_CHAR_GRAPHIC_BIT,
    /* ;   0x3B */    __GLS_CHAR_GRAPHIC_BIT,
    /* <   0x3C */    __GLS_CHAR_GRAPHIC_BIT,
    /* =   0x3D */    __GLS_CHAR_GRAPHIC_BIT,
    /* >   0x3E */    __GLS_CHAR_GRAPHIC_BIT,
    /* ?   0x3F */    __GLS_CHAR_GRAPHIC_BIT,
    /* @   0x40 */    __GLS_CHAR_GRAPHIC_BIT,
    /* A   0x41 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* B   0x42 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* C   0x43 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* D   0x44 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* E   0x45 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* F   0x46 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* G   0x47 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* H   0x48 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* I   0x49 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* J   0x4A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* K   0x4B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* L   0x4C */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* M   0x4D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* N   0x4E */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* O   0x4F */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* P   0x50 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* Q   0x51 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* R   0x52 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* S   0x53 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* T   0x54 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* U   0x55 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* V   0x56 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* W   0x57 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* X   0x58 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* Y   0x59 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* Z   0x5A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* [   0x5B */    __GLS_CHAR_GRAPHIC_BIT,
    /* \   0x5C */    __GLS_CHAR_GRAPHIC_BIT,
    /* ]   0x5D */    __GLS_CHAR_GRAPHIC_BIT,
    /* ^   0x5E */    __GLS_CHAR_GRAPHIC_BIT,
    /* _   0x5F */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* `   0x60 */    __GLS_CHAR_GRAPHIC_BIT,
    /* a   0x61 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* b   0x62 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* c   0x63 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* d   0x64 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* e   0x65 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* f   0x66 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* g   0x67 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* h   0x68 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* i   0x69 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* j   0x6A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* k   0x6B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* l   0x6C */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* m   0x6D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* n   0x6E */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* o   0x6F */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* p   0x70 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* q   0x71 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* r   0x72 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* s   0x73 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* t   0x74 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* u   0x75 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* v   0x76 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* w   0x77 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* x   0x78 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* y   0x79 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* z   0x7A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* {   0x7B */    __GLS_CHAR_GRAPHIC_BIT,
    /* |   0x7C */    __GLS_CHAR_GRAPHIC_BIT,
    /* }   0x7D */    __GLS_CHAR_GRAPHIC_BIT,
    /* ~   0x7E */    __GLS_CHAR_GRAPHIC_BIT,
    /* del 0x7F */    0,
    /*     0x80 */    0,
    /*     0x81 */    0,
    /*     0x82 */    0,
    /*     0x83 */    0,
    /*     0x84 */    0,
    /*     0x85 */    0,
    /*     0x86 */    0,
    /*     0x87 */    0,
    /*     0x88 */    0,
    /*     0x89 */    0,
    /*     0x8A */    0,
    /*     0x8B */    0,
    /*     0x8C */    0,
    /*     0x8D */    0,
    /*     0x8E */    0,
    /*     0x8F */    0,
    /*     0x90 */    0,
    /*     0x91 */    0,
    /*     0x92 */    0,
    /*     0x93 */    0,
    /*     0x94 */    0,
    /*     0x95 */    0,
    /*     0x96 */    0,
    /*     0x97 */    0,
    /*     0x98 */    0,
    /*     0x99 */    0,
    /*     0x9A */    0,
    /*     0x9B */    0,
    /*     0x9C */    0,
    /*     0x9D */    0,
    /*     0x9E */    0,
    /*     0x9F */    0,
    /*     0xA0 */    0,
    /*     0xA1 */    0,
    /*     0xA2 */    0,
    /*     0xA3 */    0,
    /*     0xA4 */    0,
    /*     0xA5 */    0,
    /*     0xA6 */    0,
    /*     0xA7 */    0,
    /*     0xA8 */    0,
    /*     0xA9 */    0,
    /*     0xAA */    0,
    /*     0xAB */    0,
    /*     0xAC */    0,
    /*     0xAD */    0,
    /*     0xAE */    0,
    /*     0xAF */    0,
    /*     0xB0 */    0,
    /*     0xB1 */    0,
    /*     0xB2 */    0,
    /*     0xB3 */    0,
    /*     0xB4 */    0,
    /*     0xB5 */    0,
    /*     0xB6 */    0,
    /*     0xB7 */    0,
    /*     0xB8 */    0,
    /*     0xB9 */    0,
    /*     0xBA */    0,
    /*     0xBB */    0,
    /*     0xBC */    0,
    /*     0xBD */    0,
    /*     0xBE */    0,
    /*     0xBF */    0,
    /*     0xC0 */    0,
    /*     0xC1 */    0,
    /*     0xC2 */    0,
    /*     0xC3 */    0,
    /*     0xC4 */    0,
    /*     0xC5 */    0,
    /*     0xC6 */    0,
    /*     0xC7 */    0,
    /*     0xC8 */    0,
    /*     0xC9 */    0,
    /*     0xCA */    0,
    /*     0xCB */    0,
    /*     0xCC */    0,
    /*     0xCD */    0,
    /*     0xCE */    0,
    /*     0xCF */    0,
    /*     0xD0 */    0,
    /*     0xD1 */    0,
    /*     0xD2 */    0,
    /*     0xD3 */    0,
    /*     0xD4 */    0,
    /*     0xD5 */    0,
    /*     0xD6 */    0,
    /*     0xD7 */    0,
    /*     0xD8 */    0,
    /*     0xD9 */    0,
    /*     0xDA */    0,
    /*     0xDB */    0,
    /*     0xDC */    0,
    /*     0xDD */    0,
    /*     0xDE */    0,
    /*     0xDF */    0,
    /*     0xE0 */    0,
    /*     0xE1 */    0,
    /*     0xE2 */    0,
    /*     0xE3 */    0,
    /*     0xE4 */    0,
    /*     0xE5 */    0,
    /*     0xE6 */    0,
    /*     0xE7 */    0,
    /*     0xE8 */    0,
    /*     0xE9 */    0,
    /*     0xEA */    0,
    /*     0xEB */    0,
    /*     0xEC */    0,
    /*     0xED */    0,
    /*     0xEE */    0,
    /*     0xEF */    0,
    /*     0xF0 */    0,
    /*     0xF1 */    0,
    /*     0xF2 */    0,
    /*     0xF3 */    0,
    /*     0xF4 */    0,
    /*     0xF5 */    0,
    /*     0xF6 */    0,
    /*     0xF7 */    0,
    /*     0xF8 */    0,
    /*     0xF9 */    0,
    /*     0xFA */    0,
    /*     0xFB */    0,
    /*     0xFC */    0,
    /*     0xFD */    0,
    /*     0xFE */    0,
    /*     0xFF */    0,
};

GLSenum __glsBinCommand_BeginGLS_getType(
    __GLSbinCommand_BeginGLS *inCommand, __GLSversion *outVersion
) {
    GLuint countLarge = inCommand->head.countLarge;
    GLuint opLarge = inCommand->head.opLarge;
    __GLSversion version = inCommand->version;

    if (inCommand->head.opSmall || inCommand->head.countSmall) return GLS_NONE;
    if (
        opLarge == GLS_OP_glsBeginGLS &&
        countLarge == sizeof(*inCommand) / 4 &&
        (!version.major || version.major == __GLS_VERSION_MAJOR)
    ) {
        *outVersion = version;
        return __GLS_BINARY_SWAP0;
    }
    __glsSwap4(&opLarge);
    __glsSwap4(&countLarge);
    __glsSwap4(&version.major);
    __glsSwap4(&version.minor);
    if (
        opLarge == GLS_OP_glsBeginGLS &&
        countLarge == sizeof(*inCommand) / 4 &&
        (!version.major || version.major == __GLS_VERSION_MAJOR)
    ) {
        *outVersion = version;
        return __GLS_BINARY_SWAP1;
    }
    return GLS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\inc\read.h ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/******************************************************************************
__GLSreadStream
******************************************************************************/

typedef struct {
    FILE *channel;
    __GLSstring name;
    GLboolean opened;
    GLSreadFunc readFunc;
    GLSwriteFunc unreadFunc;
} __GLSreadStream;

extern __GLSreadStream* __glsReadStream_create(const GLubyte *inName);
extern __GLSreadStream* __glsReadStream_destroy(__GLSreadStream *inStream);
extern GLbitfield __glsReadStream_getAttrib(const __GLSreadStream *inStream);
extern size_t __glsReadStream_getByteCount(const __GLSreadStream *inStream);
extern GLuint __glsReadStream_getCRC32(const __GLSreadStream *inStream);
extern GLSenum __glsReadStream_getType(const __GLSreadStream *inStream);

/******************************************************************************
__GLSreader
******************************************************************************/

#define __GLS_GET_SPACE(inoutReader) { \
    GLboolean __comment = GL_FALSE; \
    GLubyte __spaceChar; \
    do { \
        __GLS_READ_CHAR(inoutReader, __spaceChar); \
        switch (__spaceChar) { \
            case '#': \
                __comment = GL_TRUE; \
                break; \
            case '\n': \
            case '\r': \
                __comment = GL_FALSE; \
                break; \
        } \
    } while (__GLS_CHAR_IS_SPACE(__spaceChar) || __comment); \
    __GLS_UNREAD_CHAR(inoutReader); \
}

#define __GLS_READ_CHAR(inoutReader, outChar) \
    if ( \
        inoutReader->readPtr >= inoutReader->readTail && \
        !__glsReader_fillBuf(inoutReader, 1, GL_FALSE) \
    ) { \
        outChar = 0; \
    } else { \
        outChar = *inoutReader->readPtr++; \
    }

#define __GLS_UNREAD_CHAR(inoutReader) \
    if (inoutReader->readPtr > inoutReader->buf) --inoutReader->readPtr;

typedef struct __GLSreader {
    GLubyte *buf;
    size_t bufSize;
    GLSenum error;
    GLint paramCount;
    GLubyte *readHead;
    GLubyte *readPtr;
    GLubyte *readTail;
    const __GLSreadStream *stream;
    GLSenum type;
    __GLSversion version;
} __GLSreader;

extern GLvoid* __glsReader_allocCallBuf(
    __GLSreader *inoutReader, size_t inByteCount
);

extern GLvoid* __glsReader_allocFeedbackBuf(
    __GLSreader *inoutReader, size_t inByteCount
);

extern GLvoid* __glsReader_allocSelectBuf(
    __GLSreader *inoutReader, size_t inByteCount
);

#if __GL_EXT_vertex_array
    extern GLvoid* __glsReader_allocVertexArrayBuf(
        __GLSreader *inoutReader, GLSopcode inOpcode, size_t inByteCount
    );
#endif /* __GL_EXT_vertex_array */

extern void __glsReader_call(__GLSreader *inoutReader);

extern __GLSreader* __glsReader_final(__GLSreader *inoutReader);

extern GLboolean __glsReader_fillBuf(
    __GLSreader *inoutReader, size_t inMinBytes, GLboolean inRealign
);

extern __GLSreader* __glsReader_init_array(
    __GLSreader *outReader, const GLubyte *inArray, size_t inCount
);

extern __GLSreader* __glsReader_init_stream(
    __GLSreader *outReader, const __GLSreadStream *inStream, size_t inBufSize
);

extern void __glsReader_raiseError(__GLSreader *inoutReader, GLSenum inError);

/******************************************************************************
__GLSreader binary
******************************************************************************/

extern GLboolean __glsReader_call_bin(__GLSreader *inoutReader);
extern GLboolean __glsReader_call_bin_swap(__GLSreader *inoutReader);

extern GLSenum __glsReader_readBeginGLS_bin(
    __GLSreader *inoutReader, __GLSversion *outVersion
);

/******************************************************************************
__GLSreader text
******************************************************************************/

extern GLboolean __glsReader_abortCommand_text(__GLSreader *inoutReader);

extern GLboolean __glsReader_beginCommand_text(
    __GLSreader *inoutReader, __GLSstring *outCommand
);

extern GLboolean __glsReader_call_text(__GLSreader *inoutReader);
extern GLboolean __glsReader_endCommand_text(__GLSreader *inoutReader);

extern GLboolean __glsReader_getGLSenum_text(
    __GLSreader *inoutReader, GLSenum *outVal
);

extern GLboolean __glsReader_getGLSimageFlags_text(
    __GLSreader *inoutReader, GLbitfield *outVal
);

extern GLboolean __glsReader_getGLSopcode_text(
    __GLSreader *inoutReader, GLSopcode *outVal
);

extern GLboolean __glsReader_getGLattribMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
);

extern GLboolean __glsReader_getGLblendingFactor_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLboolean_text(
    __GLSreader *inoutReader, GLboolean *outVal
);

extern GLboolean __glsReader_getGLbooleanv_text(
    __GLSreader *inoutReader, GLuint inCount, GLboolean *outVec
);

extern GLboolean __glsReader_getGLbyte_text(
    __GLSreader *inoutReader, GLbyte *outVal
);

extern GLboolean __glsReader_getGLbytev_text(
    __GLSreader *inoutReader, GLuint inCount, GLbyte *outVec
);

extern GLboolean __glsReader_getGLcharv_text(
    __GLSreader *inoutReader, __GLSstring *outString
);

extern GLboolean __glsReader_getGLclearBufferMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
);

extern GLboolean __glsReader_getGLcompv_text(
    __GLSreader *inoutReader, GLenum inType, GLuint inBytes, GLvoid *outVec
);

extern GLboolean __glsReader_getGLdouble_text(
    __GLSreader *inoutReader, GLdouble *outVal
);

extern GLboolean __glsReader_getGLdoublev_text(
    __GLSreader *inoutReader, GLuint inCount, GLdouble *outVec
);

extern GLboolean __glsReader_getGLdrawBufferMode_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLenum_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLfloat_text(
    __GLSreader *inoutReader, GLfloat *outVal
);

extern GLboolean __glsReader_getGLfloatv_text(
    __GLSreader *inoutReader, GLuint inCount, GLfloat *outVec
);

extern GLboolean __glsReader_getGLint_text(
    __GLSreader *inoutReader, GLint *outVal
);

extern GLboolean __glsReader_getGLintv_text(
    __GLSreader *inoutReader, GLuint inCount, GLint *outVec
);

extern GLboolean __glsReader_getGLlong_text(
    __GLSreader *inoutReader, GLlong *outVal
);

extern GLboolean __glsReader_getGLlongv_text(
    __GLSreader *inoutReader, GLuint inCount, GLlong *outVec
);

extern GLboolean __glsReader_getGLshort_text(
    __GLSreader *inoutReader, GLshort *outVal
);

extern GLboolean __glsReader_getGLshortv_text(
    __GLSreader *inoutReader, GLuint inCount, GLshort *outVec
);

extern GLboolean __glsReader_getGLstencilOp_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLtextureComponentCount_text(
    __GLSreader *inoutReader, GLint *outVal
);

extern GLboolean __glsReader_getGLubyte_text(
    __GLSreader *inoutReader, GLubyte *outVal
);

extern GLboolean __glsReader_getGLubytev_text(
    __GLSreader *inoutReader, GLuint inCount, GLubyte *outVec
);

extern GLboolean __glsReader_getGLuint_text(
    __GLSreader *inoutReader, GLuint *outVal
);

extern GLboolean __glsReader_getGLuintv_text(
    __GLSreader *inoutReader, GLuint inCount, GLuint *outVec
);

extern GLboolean __glsReader_getGLulong_text(
    __GLSreader *inoutReader, GLulong *outVal
);

extern GLboolean __glsReader_getGLulongv_text(
    __GLSreader *inoutReader, GLuint inCount, GLulong *outVec
);

extern GLboolean __glsReader_getGLushort_text(
    __GLSreader *inoutReader, GLushort *outVal
);

extern GLboolean __glsReader_getGLushortv_text(
    __GLSreader *inoutReader, GLuint inCount, GLushort *outVec
);

extern GLboolean __glsReader_nextList_text(__GLSreader *inoutReader);

extern GLSenum __glsReader_readBeginGLS_text(
    __GLSreader *inoutReader, __GLSversion *outVersion
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\ctx.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

/******************************************************************************
__GLScontext
******************************************************************************/

static GLvoid* __glsGLRCbuf_alloc(__GLSglrcBuf *inoutBuf, size_t inByteCount) {
    GLvoid *base;

    if (inoutBuf->base && inoutBuf->byteCount >= inByteCount) {
        return inoutBuf->base;
    }
    if (base = __glsMalloc(inByteCount)) {
        free(inoutBuf->base);
        inoutBuf->base = base;
        inoutBuf->byteCount = inByteCount;
    }
    return base;
}

GLvoid* __glsContext_allocFeedbackBuf(
    __GLScontext *inoutContext, size_t inByteCount
) {
    return __glsGLRCbuf_alloc(
        &inoutContext->header.glrcs[inoutContext->currentGLRC].feedbackBuf,
        inByteCount
    );
}

GLvoid* __glsContext_allocSelectBuf(
    __GLScontext *inoutContext, size_t inByteCount
) {
    return __glsGLRCbuf_alloc(
        &inoutContext->header.glrcs[inoutContext->currentGLRC].selectBuf,
        inByteCount
    );
}

#if __GL_EXT_vertex_array
GLvoid* __glsContext_allocVertexArrayBuf(
    __GLScontext *inoutContext, GLSopcode inOpcode, size_t inByteCount
) {
    __GLSglrcBuf *buf;
    __GLSglrc *const glrc = (
        inoutContext->header.glrcs + inoutContext->currentGLRC
    );

    switch (inOpcode) {
        case GLS_OP_glColorPointerEXT:
            buf = &glrc->colorBuf;
            break;
        case GLS_OP_glEdgeFlagPointerEXT:
            buf = &glrc->edgeFlagBuf;
            break;
        case GLS_OP_glIndexPointerEXT:
            buf = &glrc->indexBuf;
            break;
        case GLS_OP_glNormalPointerEXT:
            buf = &glrc->normalBuf;
            break;
        case GLS_OP_glTexCoordPointerEXT:
            buf = &glrc->texCoordBuf;
            break;
        case GLS_OP_glVertexPointerEXT:
            buf = &glrc->vertexBuf;
            break;
        default:
            return GLS_NONE;
    }
    return __glsGLRCbuf_alloc(buf, inByteCount);
}
#endif /* __GL_EXT_vertex_array */

__GLScontext* __glsContext_create(GLuint inName) {
    const GLubyte *listSep;
    GLSopcode op;
    __GLScontext *const outContext = __glsCalloc(1, sizeof(__GLScontext));
    GLubyte *prefixPtr;
    __GLSlistString *readPrefix;

    if (!outContext) return GLS_NONE;
    outContext->blockType = GLS_FRAME;
    for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
        outContext->captureFlags[op] = GLS_CAPTURE_WRITE_BIT;
    }
    outContext->captureFlags[GLS_OP_glsBeginGLS] = GLS_NONE;
    outContext->captureFlags[GLS_OP_glsEndGLS] = GLS_NONE;
    outContext->captureFlags[GLS_OP_glsPad] = GLS_NONE;
    __glsString_init(&outContext->returnString);
    __glsString_init(&outContext->savedLocale);
    if (!__glsHeader_init(&outContext->header)) {
        return __glsContext_destroy(outContext);
    }
    outContext->contextStreamDict = __glsStrDict_create(1, GL_FALSE);
    if (!outContext->contextStreamDict) {
        return __glsContext_destroy(outContext);
    }
    outContext->currentGLRC = 1;
    outContext->defaultReadChannel = stdin;
    outContext->defaultWriteChannel = stdout;
    listSep = glsCSTR(getenv("GLS_LIST_SEPARATOR"));
    outContext->name = inName;
    outContext->pixelSetupGen = GL_TRUE;
#if __GLS_PLATFORM_WIN32
    // DrewB
    outContext->captureExecOverride = GL_FALSE;
#endif
    if (!listSep) listSep = glsCSTR(":");
    if (prefixPtr = glsSTR(getenv("GLS_READ_PREFIX_LIST"))) {
        __GLSstring prefixString;

        __glsString_init(&prefixString);
        if (!__glsString_append(&prefixString, prefixPtr)) {
            __glsString_final(&prefixString);
            return __glsContext_destroy(outContext);
        }
        prefixPtr = prefixString.head;
        while (
            prefixPtr = glsSTR(
                strtok((char *)prefixPtr, (const char *)listSep)
            )
        ) {
            readPrefix = __glsListString_create(prefixPtr);
            if (!readPrefix) {
                __glsString_final(&prefixString);
                return __glsContext_destroy(outContext);
            }
            __GLS_ITERLIST_APPEND(&outContext->readPrefixList, readPrefix);
            prefixPtr = GLS_NONE;
        }
        __glsString_final(&prefixString);
    }
    readPrefix = __glsListString_create(glsCSTR(""));
    if (!readPrefix) return __glsContext_destroy(outContext);
    __GLS_ITERLIST_APPEND(&outContext->readPrefixList, readPrefix);
    outContext->writePrefix = __glsListString_create(
        glsCSTR(getenv("GLS_WRITE_PREFIX"))
    );
    if (!outContext->writePrefix) return __glsContext_destroy(outContext);
    __glsContext_updateDispatchTables(outContext);
    return outContext;
}

__GLScontext* __glsContext_destroy(__GLScontext *inContext) {
    GLint i;

    if (!inContext) return GLS_NONE;
    __glsStrDict_destroy(inContext->contextStreamDict);
    __GLS_ITERLIST_CLEAR_DESTROY(
        &inContext->contextStreamList, __glsContextStream_destroy
    );
    __glsHeader_final(&inContext->header);
    __GLS_ITERLIST_CLEAR_DESTROY(
        &inContext->readPrefixList, __glsListString_destroy
    );
    __glsString_final(&inContext->returnString);
    __glsString_final(&inContext->savedLocale);
    for (i = 0 ; i < inContext->captureNesting ; ++i) {
        __glsWriter_destroy(inContext->writers[i]);
    }
    __glsListString_destroy(inContext->writePrefix);
    free(inContext);
    return GLS_NONE;
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsNullDecodeBinFunc(GLubyte *inoutPtr) {
}
#else
static void __glsNullDecodeBinFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
}
#endif

void __glsContext_updateDispatchDecode_bin(__GLScontext *inoutContext) {
    GLSopcode op;

    if (inoutContext->abortMode) {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            inoutContext->dispatchDecode_bin[op] = __glsNullDecodeBinFunc;
        }
    } else {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            __GLSdecodeBinFunc decode = __glsDispatchDecode_bin_default[op];

            if (decode) {
                inoutContext->dispatchDecode_bin[op] = decode;
            } else {
                inoutContext->dispatchDecode_bin[op] = (
                    (__GLSdecodeBinFunc)inoutContext->dispatchCall[op]
                );
            }
        }
    }
}

void __glsContext_updateDispatchTables(__GLScontext *inoutContext) {
    GLSopcode op;

    if (inoutContext->captureNesting) {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            inoutContext->dispatchAPI[op] = (GLSfunc)__glsDispatchCapture[op];
        }
    } else {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            inoutContext->dispatchAPI[op] = __glsDispatchExec[op];
        }
    }
    for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
        const GLSfunc commandFunc = inoutContext->commandFuncs[op];

        if (commandFunc) {
            inoutContext->dispatchCall[op] = commandFunc;
        } else {
            inoutContext->dispatchCall[op] = inoutContext->dispatchAPI[op];
        }
    }
    __glsContext_updateDispatchDecode_bin(inoutContext);
    __glsUpdateDispatchTables();
}

/******************************************************************************
__GLScontextStream
******************************************************************************/

__GLScontextStream* __glsContextStream_create(const GLubyte *inName) {
    __GLScontextStream *const outStream = __glsCalloc(
        1, sizeof(__GLScontextStream)
    );
    __GLScontextStreamBlock *block;

    if (!outStream) return GLS_NONE;
    __glsString_init(&outStream->name);
    if (!__glsString_append(&outStream->name, inName)) {
        return __glsContextStream_destroy(outStream);
    }
    block = __glsContextStream_appendBlock(outStream, __GLS_JUMP_ALLOC);
    if (!block) return __glsContextStream_destroy(outStream);
    __glsContextStreamBlock_addJump(block, GLS_NONE);
    return outStream;
}

__GLScontextStream* __glsContextStream_destroy(__GLScontextStream *inStream) {
    if (!inStream) return GLS_NONE;

    __glsString_final(&inStream->name);
    __GLS_LIST_CLEAR_DESTROY(
        &inStream->blockList, __glsContextStreamBlock_destroy
    );
    free(inStream);
    return GLS_NONE;
}

__GLScontextStreamBlock* __glsContextStream_appendBlock(
    __GLScontextStream *inoutStream, size_t inBufSize
) {
    __GLScontextStreamBlock *const outBlock = (
        __glsContextStreamBlock_create(inBufSize)
    );

    __GLS_LIST_APPEND(&inoutStream->blockList, outBlock);
    return outBlock;
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
#define __GLS_CONTEXT_STREAM_CALL_STEP \
    if (word = *(GLuint *)pc) { \
        dispatchDecode[__GLS_OP_SMALL(word)](pc + 4); \
        pc += __GLS_COUNT_SMALL(word) << 2; \
    } else if (word = __GLS_HEAD_LARGE(pc)->opLarge) { \
        dispatchDecode[word](pc + 12); \
        pc += __GLS_HEAD_LARGE(pc)->countLarge << 2; \
    } else { \
        pc = __GLS_COMMAND_JUMP(pc)->dest; \
        if (!pc || __GLS_CONTEXT->abortMode) break; \
    }
#else
#define __GLS_CONTEXT_STREAM_CALL_STEP \
    if (word = *(GLuint *)pc) { \
        dispatchDecode[__GLS_OP_SMALL(word)](ctx, pc + 4); \
        pc += __GLS_COUNT_SMALL(word) << 2; \
    } else if (word = __GLS_HEAD_LARGE(pc)->opLarge) { \
        dispatchDecode[word](ctx, pc + 12); \
        pc += __GLS_HEAD_LARGE(pc)->countLarge << 2; \
    } else { \
        pc = __GLS_COMMAND_JUMP(pc)->dest; \
        if (!pc || __GLS_CONTEXT->abortMode) break; \
    }
#endif

void __glsContextStream_call(__GLScontextStream *inoutStream) {
    GLboolean callSave;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSdecodeBinFunc *const dispatchDecode = ctx->dispatchDecode_bin;
    GLubyte *pc = inoutStream->blockList.head->buf;
    GLuint word;

    ++inoutStream->callCount;
    callSave = ctx->contextCall;
    ctx->contextCall = GL_TRUE;
    for (;;) {
        __GLS_CONTEXT_STREAM_CALL_STEP
        __GLS_CONTEXT_STREAM_CALL_STEP
        __GLS_CONTEXT_STREAM_CALL_STEP
        __GLS_CONTEXT_STREAM_CALL_STEP
    }
    ctx->contextCall = callSave;
    if (!--inoutStream->callCount && inoutStream->deleted) {
        __glsContextStream_destroy(inoutStream);
    }
}

__GLScontextStreamBlock* __glsContextStream_firstBlock(
    __GLScontextStream *inoutStream
) {
    return inoutStream->blockList.head;
}

size_t __glsContextStream_getByteCount(__GLScontextStream *inoutStream) {
    __GLScontextStreamBlockIter iter;
    size_t outVal = 0;

    __GLS_LIST_FIRST(&inoutStream->blockList, &iter);
    while (iter.elem) {
        outVal += (size_t)(iter.elem->writeTail - iter.elem->buf);
        if (__glsContextStreamBlock_hasJump(iter.elem)) {
            outVal -= sizeof(__GLSbinCommand_jump);
        }
        __GLS_LIST_NEXT(&inoutStream->blockList, &iter);
    }
    return outVal;
}

GLuint __glsContextStream_getCRC32(__GLScontextStream *inoutStream) {
    __GLScontextStreamBlockIter iter;
    GLuint outVal = 0xffffffff;
    GLubyte *ptr, *tail;

    __GLS_LIST_FIRST(&inoutStream->blockList, &iter);
    while (iter.elem) {
        ptr = iter.elem->buf;
        tail = iter.elem->writeTail;
        if (__glsContextStreamBlock_hasJump(iter.elem)) {
            tail -= sizeof(__GLSbinCommand_jump);
        }
        while (ptr < tail) __GLS_CRC32_STEP(outVal, *ptr++);
        __GLS_LIST_NEXT(&inoutStream->blockList, &iter);
    }
    return ~outVal;
}

__GLScontextStreamBlock* __glsContextStream_lastBlock(
    __GLScontextStream *inoutStream
) {
    __GLScontextStreamBlockIter iter;
    __GLS_LIST_LAST(&inoutStream->blockList, &iter);
    return iter.elem;
}

void __glsContextStream_truncate(
    __GLScontextStream *inoutStream,
    __GLScontextStreamBlock *inBlock,
    size_t inOffset
) {
    __GLScontextStreamBlockIter iter;

    inBlock->writeTail = inBlock->buf + inOffset;
    __glsContextStreamBlock_addJump(inBlock, GLS_NONE);
    if (inBlock->writeTail < inBlock->bufTail) {
        const size_t fillBytes = (size_t)(inBlock->writeTail - inBlock->buf);
        GLubyte *const buf = __glsMalloc(fillBytes);

        if (buf) {
            size_t i;

            for (i = 0 ; i < fillBytes ; ++i) buf[i] = inBlock->buf[i];
            free(inBlock->buf);
            inBlock->buf = buf;
            inBlock->bufTail = inBlock->writeTail = buf + fillBytes;
            iter.elem = inBlock;
            __GLS_LIST_PREV(&inoutStream->blockList, &iter);
            if (iter.elem) {
                __glsContextStreamBlock_removeJump(iter.elem);
                __glsContextStreamBlock_addJump(iter.elem, buf);
            }
        }
    }
    __GLS_LIST_LAST(&inoutStream->blockList, &iter);
    while (iter.elem != inBlock) {
        __GLScontextStreamBlock *const block = iter.elem;

        __GLS_LIST_PREV(&inoutStream->blockList, &iter);
        __GLS_LIST_REMOVE_DESTROY(
            &inoutStream->blockList, block, __glsContextStreamBlock_destroy
        );
    }
}

__GLScontextStreamBlock* __glsContextStreamBlock_create(size_t inBufSize) {
    __GLScontextStreamBlock *const outBlock = (
        __glsCalloc(1, sizeof(__GLScontextStreamBlock))
    );

    if (!outBlock) return GLS_NONE;
    outBlock->buf = __glsMalloc(inBufSize);
    if (!outBlock->buf) return __glsContextStreamBlock_destroy(outBlock);
    outBlock->bufTail = outBlock->buf + inBufSize;
    outBlock->writeTail = outBlock->buf;
    return outBlock;
}

__GLScontextStreamBlock* __glsContextStreamBlock_destroy(
    __GLScontextStreamBlock *inBlock
) {
    if (!inBlock) return GLS_NONE;
    free(inBlock->buf);
    free(inBlock);
    return GLS_NONE;
}

GLboolean __glsContextStreamBlock_addJump(
    __GLScontextStreamBlock *inoutBlock, GLubyte *inDest
) {
    __GLSbinCommand_jump *jump;
    const size_t wordCount = (
        ((size_t)(inoutBlock->writeTail - inoutBlock->buf)) >> 2
    );

    if ((wordCount & 1) && !__glsContextStreamBlock_addPad(inoutBlock)) {
        return GL_FALSE;
    }
    jump = (__GLSbinCommand_jump *)inoutBlock->writeTail;
    if (inoutBlock->writeTail + sizeof(*jump) > inoutBlock->bufTail) {
        return GL_FALSE;
    }
    jump->head.opSmall = GLS_NONE;
    jump->head.countSmall = 0;
    jump->head.opLarge = GLS_NONE;
    jump->head.countLarge = 0;
    jump->pad = 0;
    jump->dest = inDest;
    inoutBlock->writeTail += sizeof(*jump);
    return GL_TRUE;
}

GLboolean __glsContextStreamBlock_addPad(__GLScontextStreamBlock *inoutBlock) {
    __GLSbinCommand_pad *const pad = (
        (__GLSbinCommand_pad *)inoutBlock->writeTail
    );

    if (inoutBlock->writeTail + sizeof(*pad) > inoutBlock->bufTail) {
        return GL_FALSE;
    }
    pad->head.opSmall = GLS_OP_glsPad;
    pad->head.countSmall = 1;
    inoutBlock->writeTail += sizeof(*pad);
    return GL_TRUE;
}

GLboolean __glsContextStreamBlock_hasJump(__GLScontextStreamBlock *inBlock) {
    GLubyte *const jumpPos = (
        inBlock->writeTail - sizeof(__GLSbinCommand_jump)
    );
    __GLSbinCommand_jump *const jump = (__GLSbinCommand_jump *)jumpPos;

    return (GLboolean)(
        jumpPos >= inBlock->buf &&
        !jump->head.opSmall &&
        !jump->head.countSmall &&
        !jump->head.opLarge &&
        !jump->head.countLarge &&
        !jump->pad
    );
}

GLboolean __glsContextStreamBlock_removeJump(
    __GLScontextStreamBlock *inoutBlock
) {
    if (__glsContextStreamBlock_hasJump(inoutBlock)) {
        inoutBlock->writeTail -= sizeof(__GLSbinCommand_jump);
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/******************************************************************************
__GLSglrc
******************************************************************************/

void __glsGLRC_final(__GLSglrc *inoutGLRC) {
    free(inoutGLRC->feedbackBuf.base);
    free(inoutGLRC->selectBuf.base);
    #if __GL_EXT_vertex_array
        free(inoutGLRC->colorBuf.base);
        free(inoutGLRC->edgeFlagBuf.base);
        free(inoutGLRC->indexBuf.base);
        free(inoutGLRC->normalBuf.base);
        free(inoutGLRC->texCoordBuf.base);
        free(inoutGLRC->vertexBuf.base);
    #endif /* __GL_EXT_vertex_array */
}

void __glsGLRC_init(__GLSglrc *outGLRC) {
    memset(outGLRC, 0, sizeof(__GLSglrc));
    outGLRC->layer = 1;
}

/******************************************************************************
__GLSlayer
******************************************************************************/

void __glsLayer_init(__GLSlayer *outLayer) {
    memset(outLayer, 0, sizeof(__GLSlayer));
    outLayer->displayFormat = GLS_RGBA;
}

/******************************************************************************
__GLSheader
******************************************************************************/

void __glsHeader_final(__GLSheader *inoutHeader) {
    while (inoutHeader->glrcCount > 0) {
        __glsGLRC_final(inoutHeader->glrcs + --inoutHeader->glrcCount);
    }
    free(inoutHeader->glrcs);
    free(inoutHeader->layers);
    __glsString_final(&inoutHeader->extensions);
    __glsString_final(&inoutHeader->author);
    __glsString_final(&inoutHeader->description);
    __glsString_final(&inoutHeader->notes);
    __glsString_final(&inoutHeader->title);
    __glsString_final(&inoutHeader->tools);
    __glsString_final(&inoutHeader->version);
}

GLboolean __glsHeader_init(__GLSheader *outHeader) {
    memset(outHeader, 0, sizeof(__GLSheader));
    outHeader->glrcs = __glsMalloc(sizeof(__GLSglrc));
    outHeader->layers = __glsMalloc(sizeof(__GLSlayer));
    if (!outHeader->glrcs || !outHeader->layers) return GL_FALSE;
    __glsGLRC_init(outHeader->glrcs);
    __glsLayer_init(outHeader->layers);
    outHeader->glrcCount = 1;
    outHeader->layerCount = 1;
    outHeader->tileable = GL_TRUE;
    __glsString_init(&outHeader->extensions);
    __glsString_init(&outHeader->author);
    __glsString_init(&outHeader->description);
    __glsString_init(&outHeader->notes);
    __glsString_init(&outHeader->title);
    __glsString_init(&outHeader->tools);
    __glsString_init(&outHeader->version);
    return GL_TRUE;
}

GLboolean __glsHeader_reset(__GLSheader *inoutHeader) {
    __glsHeader_final(inoutHeader);
    return __glsHeader_init(inoutHeader);
}

/******************************************************************************
__GLSlistString
******************************************************************************/

GLboolean __glsListString_prefix(
    const __GLSlistString *inString,
    const GLubyte *inName,
    __GLSstring *outPath
) {
    if (
        __glsString_assign(outPath, inString->val.head) &&
        __glsString_append(outPath, inName)
    ) {
        return GL_TRUE;
    } else {
        __glsString_reset(outPath);
        return GL_FALSE;
    }
}

__GLSlistString* __glsListString_create(const GLubyte *inVal) {
    __GLSlistString *const outString = __glsCalloc(1, sizeof(__GLSlistString));

    if (!outString) return GLS_NONE;
    __glsString_init(&outString->val);
    if (inVal && !__glsString_append(&outString->val, inVal)) {
        return __glsListString_destroy(outString);
    }
    return outString;
}

__GLSlistString* __glsListString_destroy(__GLSlistString *inString) {
    if (!inString) return GLS_NONE;
    __glsString_final(&inString->val);
    free(inString);
    return GLS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\glref.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* Force loading of libGL.a.  Needed only for AIX */

void __gls_glRef(void) {
    if (0) glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\glslib.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

/******************************************************************************
Global data
******************************************************************************/

const GLSenum __glsAllAPIs[__GLS_API_COUNT + 1] = {
    GLS_API_GLS,
    GLS_API_GL,
    GLS_NONE,
};

const GLubyte *const __glsExtensions = (const GLubyte *)(
    ""

    #if __GL_EXT_abgr
        "GL_EXT_abgr "
    #endif /* __GL_EXT_abgr */

    #if __GL_EXT_blend_color
        "GL_EXT_blend_color "
    #endif /* __GL_EXT_blend_color */

    #if __GL_EXT_blend_logic_op
        "GL_EXT_blend_logic_op "
    #endif /* __GL_EXT_blend_logic_op */

    #if __GL_EXT_blend_minmax
        "GL_EXT_blend_minmax "
    #endif /* __GL_EXT_blend_minmax */

    #if __GL_EXT_blend_subtract
        "GL_EXT_blend_subtract "
    #endif /* __GL_EXT_blend_subtract */

    #if __GL_EXT_cmyka
        "GL_EXT_cmyka "
    #endif /* __GL_EXT_cmyka */

    #if __GL_EXT_convolution
        "GL_EXT_convolution "
    #endif /* __GL_EXT_convolution */

    #if __GL_EXT_copy_texture
        "GL_EXT_copy_texture "
    #endif /* __GL_EXT_copy_texture */

    #if __GL_EXT_histogram
        "GL_EXT_histogram "
    #endif /* __GL_EXT_histogram */

    #if __GL_EXT_packed_pixels
        "GL_EXT_packed_pixels "
    #endif /* __GL_EXT_packed_pixels */

    #if __GL_EXT_polygon_offset
        "GL_EXT_polygon_offset "
    #endif /* __GL_EXT_polygon_offset */

    #if __GL_EXT_rescale_normal
        "GL_EXT_rescale_normal "
    #endif /* __GL_EXT_rescale_normal */

    #if __GL_EXT_subtexture
        "GL_EXT_subtexture "
    #endif /* __GL_EXT_subtexture */

    #if __GL_EXT_texture
        "GL_EXT_texture "
    #endif /* __GL_EXT_texture */

    #if __GL_EXT_texture_object
        "GL_EXT_texture_object "
    #endif /* __GL_EXT_texture_object */

    #if __GL_EXT_texture3D
        "GL_EXT_texture3D "
    #endif /* __GL_EXT_texture3D */

    #if __GL_EXT_vertex_array
        "GL_EXT_vertex_array "
    #endif /* __GL_EXT_vertex_array */

    #if __GL_SGI_color_matrix
        "GL_SGI_color_matrix "
    #endif /* __GL_SGI_color_matrix */

    #if __GL_SGI_color_table
        "GL_SGI_color_table "
    #endif /* __GL_SGI_color_table */

    #if __GL_SGI_texture_color_table
        "GL_SGI_texture_color_table "
    #endif /* __GL_SGI_texture_color_table */

    #if __GL_SGIS_component_select
        "GL_SGIS_component_select "
    #endif /* __GL_SGIS_component_select */

    #if __GL_SGIS_detail_texture
        "GL_SGIS_detail_texture "
    #endif /* __GL_SGIS_detail_texture */

    #if __GL_SGIS_multisample
        "GL_SGIS_multisample "
    #endif /* __GL_SGIS_multisample */

    #if __GL_SGIS_sharpen_texture
        "GL_SGIS_sharpen_texture "
    #endif /* __GL_SGIS_sharpen_texture */

    #if __GL_SGIS_texture_border_clamp
        "GL_SGIS_texture_border_clamp "
    #endif /* __GL_SGIS_texture_border_clamp */

    #if __GL_SGIS_texture_edge_clamp
        "GL_SGIS_texture_edge_clamp "
    #endif /* __GL_SGIS_texture_edge_clamp */

    #if __GL_SGIS_texture_filter4
        "GL_SGIS_texture_filter4 "
    #endif /* __GL_SGIS_texture_filter4 */

    #if __GL_SGIS_texture_lod
        "GL_SGIS_texture_lod "
    #endif /* __GL_SGIS_texture_lod */

    #if __GL_SGIS_texture4D
        "GL_SGIS_texture4D "
    #endif /* __GL_SGIS_texture4D */

    #if __GL_SGIX_interlace
        "GL_SGIX_interlace "
    #endif /* __GL_SGIX_interlace */

    #if __GL_SGIX_multipass
        "GL_SGIX_multipass "
    #endif /* __GL_SGIX_multipass */

    #if __GL_SGIX_multisample
        "GL_SGIX_multisample "
    #endif /* __GL_SGIX_multisample */

    #if __GL_SGIX_pixel_texture
        "GL_SGIX_pixel_texture "
    #endif /* __GL_SGIX_pixel_texture */

    #if __GL_SGIX_pixel_tiles
        "GL_SGIX_pixel_tiles "
    #endif /* __GL_SGIX_pixel_tiles */

    #if __GL_SGIX_sprite
        "GL_SGIX_sprite "
    #endif /* __GL_SGIX_sprite */

    #if __GL_SGIX_texture_multi_buffer
        "GL_SGIX_texture_multi_buffer "
    #endif /* __GL_SGIX_texture_multi_buffer */
);

__GLSdict *__glsContextDict = GLS_NONE;
__GLScontextList __glsContextList = {GLS_NONE};
__GLSparser *__glsParser = GLS_NONE;

/******************************************************************************
Global functions
******************************************************************************/

#ifndef __GLS_PLATFORM_WIN32
// DrewB
void __glsCallError(GLSopcode inOpcode, GLSenum inError) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);

    ((__GLSdispatch)__GLS_CONTEXT->dispatchCall[GLS_OP_glsError])(
        inOpcode, inError
    );
}

void __glsCallUnsupportedCommand(void) {
    typedef void (*__GLSdispatch)(void);

    ((__GLSdispatch)__GLS_CONTEXT->dispatchCall[GLS_OP_glsUnsupportedCommand])(
    );
}
#else
void __glsCallError(__GLScontext *ctx, GLSopcode inOpcode, GLSenum inError) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);

    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glsError])(
        inOpcode, inError
    );
}

void __glsCallUnsupportedCommand(__GLScontext *ctx) {
    typedef void (*__GLSdispatch)(void);

    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glsUnsupportedCommand])(
    );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\glsutil.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

/******************************************************************************
Array
******************************************************************************/

void __glsArray_final(__GLSarray *inoutArray) {
    free(inoutArray->base);
    __glsArray_init(inoutArray);
}

void __glsArray_init(__GLSarray *outArray) {
    outArray->base = GLS_NONE;
    outArray->bufCount = outArray->count = 0;
}

void __glsArray_compact(__GLSarray *inoutArray, size_t inElemSize) {
    if (inoutArray->bufCount == inoutArray->count) return;
    if (inoutArray->count) {
        GLvoid *const newBase = realloc(
            inoutArray->base, inoutArray->count * inElemSize
        );

        if (newBase) {
            inoutArray->base = newBase;
            inoutArray->bufCount = inoutArray->count;
        }
    } else {
        __glsArray_final(inoutArray);
    }
}

void __glsArray_delete(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    size_t inElemSize
) { 
    if (inIndex >= inoutArray->count) return;
    if (inIndex + inCount >= inoutArray->count) {
        inoutArray->count = inIndex;
    } else {
        GLubyte *const p = (GLubyte *)inoutArray->base + inIndex * inElemSize;

        memmove(
            p,
            p + inCount * inElemSize,
            (inoutArray->count - (inIndex + inCount)) * inElemSize
        );
        inoutArray->count -= inCount;
    }
}

GLboolean __glsArray_insert(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    GLboolean inInit,
    size_t inElemSize
) {
    const size_t newCount = inoutArray->count + inCount;

    if (newCount > inoutArray->bufCount) {
        size_t newBufCount = __glsCeilBase2(newCount);
        GLvoid *buf = malloc(newBufCount * inElemSize);

        if (!buf) {
            newBufCount = newCount;
            buf = __glsMalloc(newBufCount * inElemSize);
            if (!buf) return GL_FALSE;
        }
        memmove(buf, inoutArray->base, inoutArray->count);
        free(inoutArray->base);
        inoutArray->base = buf;
        inoutArray->bufCount = newBufCount;
    }
    if (inIndex < inoutArray->count) {
        GLubyte *const p = (GLubyte *)inoutArray->base + inIndex * inElemSize;

        memmove(
            p + inCount * inElemSize,
            p,
            (inoutArray->count - inIndex) * inElemSize
        );
    } else {
        inIndex = inoutArray->count;
    }
    if (inInit) {
        memset(
            (GLubyte *)inoutArray->base + inIndex * inElemSize,
            0,
            inCount * inElemSize
        );
    }
    inoutArray->count = newCount;
    return GL_TRUE;
}

/******************************************************************************
Checksum
******************************************************************************/

#define __GLS_CRC32_POLY 0x04c11db7 /* AUTODIN II, Ethernet, & FDDI */

#if __GLS_UNUSED
static void __glsCRC32tableInit(void) {
    GLuint c, i, j;

    for (i = 0; i < 256; ++i) {
        for (c = i << 24, j = 8; j ; --j) {
           c = c & 0x80000000 ? (c << 1) ^ __GLS_CRC32_POLY : (c << 1);
        }
        __glsCRC32table[i] = c;
    }
}
#endif /* __GLS_UNUSED */

const GLuint __glsCRC32table[256] = {
    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
    0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
    0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
    0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
    0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
    0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
    0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
    0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
    0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
    0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
    0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
    0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
    0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
    0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
    0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
    0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
    0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
    0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
    0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
    0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
    0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
    0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
    0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
    0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
    0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
    0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
    0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
    0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
    0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
    0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
    0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
    0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
    0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4,
};

/******************************************************************************
Dict
******************************************************************************/

typedef struct {
    __GLS_LIST_ELEM;
    union {
        GLint intKey;
        const GLubyte *strKey;
    } key;
    union {
        GLint intVal;
        GLvoid *ptrVal;
    } val;
} __GLSdictEntry;

typedef __GLS_LIST(__GLSdictEntry) __GLSdictEntryList;
typedef __GLS_LIST_ITER(__GLSdictEntry) __GLSdictEntryIter;

struct __GLSdict{
    size_t count;
    __GLSdictEntryList *table;
    size_t tableMax;
    GLboolean staticKeys;
};

static __GLSdict* __glsDict_create(
    size_t inTableCount, GLboolean inStaticKeys
) {
    __GLSdict *outDict;

    if (inTableCount < 1) return GLS_NONE;
    outDict = __glsCalloc(1, sizeof(__GLSdict));
    if (!outDict) return GLS_NONE;
    outDict->staticKeys = inStaticKeys;
    inTableCount = __glsCeilBase2(inTableCount);
    outDict->table = __glsCalloc(inTableCount, sizeof(__GLSdictEntryList));
    if (!outDict->table) return __glsStrDict_destroy(outDict);
    outDict->tableMax = inTableCount - 1;
    return outDict;
}

__GLS_FORWARD static __GLSdictEntry* __glsIntDictEntry_destroy(
    __GLSdictEntry *inEntry
);

static __GLSdictEntry* __glsIntDictEntry_create(GLint inKey) {
    __GLSdictEntry *const outEntry = __glsCalloc(1, sizeof(__GLSdictEntry));

    if (!outEntry) return GLS_NONE;
    outEntry->key.intKey = inKey;
    return outEntry;
}

static __GLSdictEntry* __glsIntDictEntry_destroy(__GLSdictEntry *inEntry) {
    free(inEntry);
    return GLS_NONE;
}

static size_t __glsIntHash(const __GLSdict *inDict, GLint inKey) {
    return inKey & inDict->tableMax;
}

static GLboolean __glsIntDict_add(
    __GLSdict *inoutDict, GLint inKey, __GLSdictEntry *inEntry
) {
    if (inoutDict->count++ > inoutDict->tableMax) {
        const size_t newTableSize = (inoutDict->tableMax + 1) * 2;
        __GLSdictEntryList *const newTable = (
            __glsCalloc(newTableSize, sizeof(__GLSdictEntryList))
        );
        if (newTable) {
            size_t i = inoutDict->tableMax;

            inoutDict->tableMax = newTableSize - 1;
            for ( ; i != (size_t)-1; --i) {
                __GLSdictEntry *oldEntry;

                while (oldEntry = inoutDict->table[i].head) {
                    __GLS_LIST_REMOVE(inoutDict->table + i, oldEntry);
                    __GLS_LIST_APPEND(
                      newTable + __glsIntHash(inoutDict, oldEntry->key.intKey),
                      oldEntry
                    );
                }
            }
            free(inoutDict->table);
            inoutDict->table = newTable;
        }
    }
    __GLS_LIST_PREPEND(
        inoutDict->table + __glsIntHash(inoutDict, inKey), inEntry
    );

    return GL_TRUE;
}

__GLSdict* __glsIntDict_create(size_t inTableCount) {
    return __glsDict_create(inTableCount, GL_FALSE);
}

__GLSdict* __glsIntDict_destroy(__GLSdict *inDict) {
    size_t i;

    if (!inDict) return GLS_NONE;
    if (inDict->table) for (i = inDict->tableMax ; i != (size_t)-1; --i) {
        __GLS_LIST_CLEAR_DESTROY(inDict->table + i, __glsIntDictEntry_destroy);
    }
    free(inDict->table);
    free(inDict);
    return GLS_NONE;
}

void __glsIntDict_print(__GLSdict *inoutDict, const GLubyte *inName) {
    size_t i;

    fprintf(stdout, "%s(\n", inName);
    for (i = 0 ; i <= inoutDict->tableMax ; ++i) {
        __GLSdictEntryIter iter;

        __GLS_LIST_FIRST(inoutDict->table + i, &iter);
        if (iter.elem) {
            fprintf(stdout, "   ");
            while (iter.elem) {
                fprintf(stdout, " %d", iter.elem->key.intKey);
                __GLS_LIST_NEXT(inoutDict->table + i, &iter);
            }
            fprintf(stdout, "\n");
        }
    }
    fprintf(stdout, ")\n");
}

void __glsIntDict_remove(__GLSdict *inoutDict, GLint inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsIntHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            __GLS_LIST_REMOVE_DESTROY(
                list, iter.elem, __glsIntDictEntry_destroy
            );
            --inoutDict->count;
            return;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
}

GLboolean __glsInt2IntDict_add(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
) {
    __GLSdictEntry *entry;

    if (__glsInt2IntDict_find(inoutDict, inKey, GLS_NONE)) return GL_FALSE;
    entry = __glsIntDictEntry_create(inKey);
    if (!entry) return GL_FALSE;
    entry->val.intVal = inVal;
    return __glsIntDict_add(inoutDict, inKey, entry);
}

GLboolean __glsInt2PtrDict_add(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
) {
    __GLSdictEntry *entry;

    if (__glsInt2PtrDict_find(inoutDict, inKey)) return GL_FALSE;
    entry = __glsIntDictEntry_create(inKey);
    if (!entry) return GL_FALSE;
    entry->val.ptrVal = inVal;
    return __glsIntDict_add(inoutDict, inKey, entry);
}

GLboolean __glsInt2IntDict_find(
    const __GLSdict *inDict, GLint inKey, GLint *optoutVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsIntHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            if (optoutVal) *optoutVal = iter.elem->val.intVal;
            return GL_TRUE;
        }   
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLvoid* __glsInt2PtrDict_find(const __GLSdict *inDict, GLint inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsIntHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            return iter.elem->val.ptrVal;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GLS_NONE;
}

GLboolean __glsInt2IntDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsIntHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            iter.elem->val.intVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLboolean __glsInt2PtrDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsIntHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            iter.elem->val.ptrVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

__GLS_FORWARD static __GLSdictEntry* __glsStrDictEntry_destroy(
    __GLSdictEntry *inEntry, GLboolean inStaticKey
);

static __GLSdictEntry* __glsStrDictEntry_create(
    const GLubyte *inKey, GLboolean inStaticKey
) {
    __GLSdictEntry *const outEntry = __glsCalloc(1, sizeof(__GLSdictEntry));

    if (!outEntry) return GLS_NONE;
    if (inStaticKey) {
        outEntry->key.strKey = inKey;
    } else {
        GLubyte *const buf = __glsMalloc(strlen((const char *)inKey) + 1);

        if (!buf) {
            return __glsStrDictEntry_destroy(outEntry, GL_FALSE);
        }
        strcpy((char *)buf, (const char *)inKey);
        outEntry->key.strKey = buf;
    }
    return outEntry;
}

static __GLSdictEntry* __glsStrDictEntry_destroy(
    __GLSdictEntry *inEntry, GLboolean inStaticKey
) {
    if (!inEntry) return GLS_NONE;
    if (!inStaticKey) free((GLvoid *)inEntry->key.strKey);
    free(inEntry);
    return GLS_NONE;
}

static size_t __glsStrHash(const __GLSdict *inDict, const GLubyte *inKey) {
    GLubyte charVal;
    size_t outHash = 0;

    while (charVal = *inKey++) outHash += charVal;
    return outHash & inDict->tableMax;
}

static GLboolean __glsStrDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, __GLSdictEntry *inEntry
) {
    if (inoutDict->count++ > inoutDict->tableMax) {
        const size_t newTableSize = (inoutDict->tableMax + 1) * 2;
        __GLSdictEntryList *const newTable = (
            __glsCalloc(newTableSize, sizeof(__GLSdictEntryList))
        );

        if (newTable) {
            size_t i = inoutDict->tableMax;

            inoutDict->tableMax = newTableSize - 1;
            for ( ; i != (size_t)-1; --i) {
                __GLSdictEntry *oldEntry;

                while (oldEntry = inoutDict->table[i].head) {
                    __GLS_LIST_REMOVE(inoutDict->table + i, oldEntry);
                    __GLS_LIST_APPEND(
                      newTable + __glsStrHash(inoutDict, oldEntry->key.strKey),
                      oldEntry
                    );
                }
            }
            free(inoutDict->table);
            inoutDict->table = newTable;
        }
    }
    __GLS_LIST_PREPEND(
        inoutDict->table + __glsStrHash(inoutDict, inKey), inEntry
    );
    return GL_TRUE;
}

__GLSdict* __glsStrDict_create(size_t inTableCount, GLboolean inStaticKeys) {
    return __glsDict_create(inTableCount, inStaticKeys);
}

__GLSdict* __glsStrDict_destroy(__GLSdict *inDict) {
    size_t i;

    if (!inDict) return GLS_NONE;
    if (inDict->table) for (i = inDict->tableMax ; i != (size_t)-1; --i) {
        __GLSdictEntry *entry;

        while (entry = inDict->table[i].head) {
            __GLS_LIST_REMOVE(inDict->table + i, entry);
            __glsStrDictEntry_destroy(entry, inDict->staticKeys);
        }
    }
    free(inDict->table);
    free(inDict);
    return GLS_NONE;
}

void __glsStrDict_print(__GLSdict *inoutDict, const GLubyte *inName) {
    size_t i;

    fprintf(stdout, "%s(\n", inName);
    for (i = 0 ; i <= inoutDict->tableMax ; ++i) {
        __GLSdictEntryIter iter;
        __GLS_LIST_FIRST(inoutDict->table + i, &iter);
        if (iter.elem) {
            fprintf(stdout, "   ");
            while (iter.elem) {
                fprintf(stdout, " %s", iter.elem->key.strKey);
                __GLS_LIST_NEXT(inoutDict->table + i, &iter);
            }
            fprintf(stdout, "\n");
        }
    }
    fprintf(stdout, ")\n");
}

void __glsStrDict_remove(__GLSdict *inoutDict, const GLubyte *inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsStrHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            __GLS_LIST_REMOVE(list, iter.elem);
            __glsStrDictEntry_destroy(iter.elem, inoutDict->staticKeys);
            --inoutDict->count;
            return;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
}

GLboolean __glsStr2IntDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
) {
    __GLSdictEntry *entry;

    if (__glsStr2IntDict_find(inoutDict, inKey, GLS_NONE)) return GL_FALSE;
    entry = __glsStrDictEntry_create(inKey, inoutDict->staticKeys);
    if (!entry) return GL_FALSE;
    entry->val.intVal = inVal;
    return __glsStrDict_add(inoutDict, inKey, entry);
}

GLboolean __glsStr2PtrDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
) {
    __GLSdictEntry *entry;

    if (__glsStr2PtrDict_find(inoutDict, inKey)) return GL_FALSE;
    entry = __glsStrDictEntry_create(inKey, inoutDict->staticKeys);
    if (!entry) return GL_FALSE;
    entry->val.ptrVal = inVal;
    return __glsStrDict_add(inoutDict, inKey, entry);
}

GLboolean __glsStr2IntDict_find(
    const __GLSdict *inDict, const GLubyte *inKey, GLint *optoutVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsStrHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            if (optoutVal) *optoutVal = iter.elem->val.intVal;
            return GL_TRUE;
        }   
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLvoid* __glsStr2PtrDict_find(const __GLSdict *inDict, const GLubyte *inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsStrHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            return iter.elem->val.ptrVal;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GLS_NONE;
}

GLboolean __glsStr2IntDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsStrHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            iter.elem->val.intVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLboolean __glsStr2PtrDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsStrHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            iter.elem->val.ptrVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

/******************************************************************************
List
******************************************************************************/

void __glsListAppend(__GLSlist *inoutList, __GLSlistElem *inoutElem) {
    if (inoutList->head) {
        inoutList->head->prev->next = inoutElem;
        inoutElem->prev = inoutList->head->prev;
        inoutElem->next = inoutList->head;
        inoutList->head->prev = inoutElem;
    } else {
        inoutList->head = inoutElem;
        inoutElem->prev = inoutElem->next = inoutElem;
    }
}

void __glsListClearDestroy(
    __GLSlist *inoutList, __GLSlistElemDestructor inDestructor
) {
    while (inoutList->head) {
        __glsListRemoveDestroy(inoutList, inoutList->head, inDestructor);
    }
}

void __glsListFirst(__GLSlist *inList, __GLSlistIter *inoutIter) {
    inoutIter->elem = inList->head;
}

void __glsListLast(__GLSlist *inList, __GLSlistIter *inoutIter) {
    inoutIter->elem = inList->head ? inList->head->prev : GLS_NONE;
}

void __glsListNext(__GLSlist *inList, __GLSlistIter *inoutIter) {
    if (inoutIter->elem) {
        inoutIter->elem = inoutIter->elem->next;
        if (inoutIter->elem == inList->head) inoutIter->elem = GLS_NONE;
    }
}

void __glsListPrepend(__GLSlist *inoutList, __GLSlistElem *inoutElem) {
    if (inoutList->head) {
        inoutList->head->prev->next = inoutElem;
        inoutElem->prev = inoutList->head->prev;
        inoutElem->next = inoutList->head;
        inoutList->head->prev = inoutElem;
        inoutList->head = inoutElem;
    } else {
        inoutList->head = inoutElem;
        inoutElem->prev = inoutElem->next = inoutElem;
    }
}

void __glsListPrev(__GLSlist *inList, __GLSlistIter *inoutIter) {
    if (inoutIter->elem) {
        inoutIter->elem = (
            (inoutIter->elem == inList->head) ?
            GLS_NONE :
            inoutIter->elem->prev
        );
    }
}

void __glsListRemove(__GLSlist *inoutList, __GLSlistElem *inoutElem) {
    if (inoutList->head == inoutList->head->next) {
        inoutList->head = GLS_NONE;
    } else {
        inoutElem->next->prev = inoutElem->prev;
        inoutElem->prev->next = inoutElem->next;
        if (inoutList->head == inoutElem) {
            inoutList->head = inoutList->head->next;
        }
    }
}

void __glsListRemoveDestroy(
    __GLSlist *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
) {
    __glsListRemove(inoutList, inElem);
    inDestructor(inElem);
}

/******************************************************************************
IterList
******************************************************************************/

void __glsIterListAppend(__GLSiterList *inoutList, __GLSlistElem *inoutElem) {
    __glsListAppend((__GLSlist *)&inoutList->head, inoutElem);
    ++inoutList->count;
}

void __glsIterListClearDestroy(
    __GLSiterList *inoutList, __GLSlistElemDestructor inDestructor
) {
    __glsListClearDestroy((__GLSlist *)&inoutList->head, inDestructor);
    inoutList->iterElem = GLS_NONE;
    inoutList->count = inoutList->iterIndex = 0;
}

void __glsIterListFirst(__GLSiterList *inoutList) {
    __glsListFirst(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = 0;
}

void __glsIterListLast(__GLSiterList *inoutList) {
    __glsListLast(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = inoutList->iterElem ? inoutList->count - 1 : 0;
}

void __glsIterListNext(__GLSiterList *inoutList) {
    __glsListNext(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = inoutList->iterElem ? inoutList->iterIndex + 1 : 0;
}

void __glsIterListPrepend(__GLSiterList *inoutList, __GLSlistElem *inoutElem) {
    __glsListPrepend((__GLSlist *)&inoutList->head, inoutElem);
    ++inoutList->count;
    if (inoutList->iterElem) ++inoutList->iterIndex;
}

void __glsIterListPrev(__GLSiterList *inoutList) {
    __glsListPrev(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = inoutList->iterElem ? inoutList->iterIndex - 1 : 0;
}

void __glsIterListRemove(__GLSiterList *inoutList, __GLSlistElem *inoutElem) {
    __glsListRemove((__GLSlist *)&inoutList->head, inoutElem);
    inoutList->iterElem = GLS_NONE;
    --inoutList->count;
    inoutList->iterIndex = 0;
}

void __glsIterListRemoveDestroy(
    __GLSiterList *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
) {
    __glsListRemoveDestroy(
        (__GLSlist *)&inoutList->head, inElem, inDestructor
    );
    inoutList->iterElem = GLS_NONE;
    --inoutList->count;
    inoutList->iterIndex = 0;
}

void __glsIterListSeek(__GLSiterList *inoutList, size_t inIndex) {
    if (inIndex < inoutList->count) {
        if (!inoutList->iterElem) inoutList->iterElem = inoutList->head;
        while (inoutList->iterIndex < inIndex) __glsIterListNext(inoutList);
        while (inoutList->iterIndex > inIndex) __glsIterListPrev(inoutList);
    }
}

/******************************************************************************
Memory
******************************************************************************/

GLvoid* __glsCalloc(size_t inCount, size_t inSize) {
    GLvoid *outAddr;

    if (!inCount) inCount = 1;
    if (!inSize) inSize = 1;
    outAddr = calloc(inCount, inSize);
    if (!outAddr) __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
    return outAddr;
}

GLvoid* __glsMalloc(size_t inSize) {
    GLvoid *outAddr;
    
    if (!inSize) inSize = 1;
    outAddr = malloc(inSize);
    if (!outAddr) __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
    return outAddr;
}

/******************************************************************************
Nop
******************************************************************************/

void __glsNop(void) {}

/******************************************************************************
Number
******************************************************************************/

const GLubyte __glsBitReverse[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

const GLubyte __glsQuietNaN[8] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

size_t __glsCeilBase2(size_t inVal) {
    const size_t outVal = 1 << __glsLogBase2(inVal);

    return outVal < inVal ? outVal << 1 : outVal;
}

size_t __glsLogBase2(size_t inVal) {
    size_t outLog = 0;

    while (inVal >>= 1) ++outLog;
    return outLog;
}

GLulong __glsPtrToULong(const GLvoid *inPtr) {
    #if __GLS_INT64
        return (GLulong)(SIZE_T)inPtr;
    #else /* !__GLS_INT64 */
        return glsULong(0, (GLuint)inPtr);
    #endif /* __GLS_INT64 */
}

GLlong __glsSizeToLong(size_t inSize) {
    #if __GLS_INT64
        return (GLlong)inSize;
    #else /* !__GLS_INT64 */
        if (sizeof(GLuint) >= sizeof(size_t)) {
            return glsLong(0, inSize);
        } else {
            return glsLong(inSize >> 32, inSize & 0xffffffff);
        }
    #endif /* __GLS_INT64 */
}

void __glsSwap2(GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP2(inoutVec);
}

void __glsSwap2v(size_t inCount, GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;
    GLubyte *ptr = (GLubyte *)inoutVec;

    while (inCount--) {
        __GLS_SWAP2(ptr);
        ptr += 2;
    }
}

void __glsSwap4(GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP4(inoutVec);
}

void __glsSwap4v(size_t inCount, GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;
    GLubyte *ptr = (GLubyte *)inoutVec;

    while (inCount--) {
        __GLS_SWAP4(ptr);
        ptr += 4;
    }
}

void __glsSwap8(GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP8(inoutVec);
}

void __glsSwap8v(size_t inCount, GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;
    GLubyte *ptr = (GLubyte *)inoutVec;

    while (inCount-- > 0) {
        __GLS_SWAP8(ptr);
        ptr += 8;
    }
}

GLint __glsSwapi(GLint inVal) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP4(&inVal);
    return inVal;
}

GLshort __glsSwaps(GLshort inVal) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP2(&inVal);
    return inVal;
}

void __glsSwapv(GLenum inType, size_t inBytes, GLvoid *inoutVec) {
    switch (inType) {
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            __glsSwap4v(inBytes / 4, (GLubyte *)inoutVec);
            break;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            __glsSwap2v(inBytes / 2, (GLubyte *)inoutVec);
            break;
        #if __GL_EXT_vertex_array
            case GL_DOUBLE_EXT:
                __glsSwap8v(inBytes / 8, (GLubyte *)inoutVec);
                break;
        #endif /* __GL_EXT_vertex_array */
    }
}

/******************************************************************************
String
******************************************************************************/

static GLboolean __glsString_addRoom(
    __GLSstring *inoutString, size_t inCount
) {
    const size_t newSize = __glsCeilBase2(
        (size_t)((ULONG_PTR)(inoutString->bufTail - inoutString->head) + 1 + inCount)
    );
    GLubyte *buf = __glsMalloc(newSize);

    if (!buf) return GL_FALSE;
    strcpy((char *)buf, (const char *)inoutString->head);
    inoutString->tail = buf + (inoutString->tail - inoutString->head);
    if (inoutString->head != inoutString->buf) free(inoutString->head);
    inoutString->head = buf;
    inoutString->bufTail = buf + newSize - 1;
    return GL_TRUE;
}

GLboolean __glsString_append(
    __GLSstring *inoutString, const GLubyte* inAppend
) {
    const size_t count = strlen((const char *)inAppend);

    if (
        inoutString->tail + count > inoutString->bufTail &&
        !__glsString_addRoom(inoutString, count)
    ) {
        return GL_FALSE;
    }
    strcpy((char *)inoutString->tail, (const char *)inAppend);
    inoutString->tail += count;
    return GL_TRUE;
}

GLboolean __glsString_appendChar(
    __GLSstring *inoutString, GLubyte inAppend
) {
    *inoutString->tail++ = inAppend;
    if (inoutString->tail > inoutString->bufTail) {
        *--inoutString->tail = 0;
        if (!__glsString_addRoom(inoutString, 1)) return GL_FALSE;
        *inoutString->tail++ = inAppend;
    }
    *inoutString->tail = 0;
    return GL_TRUE;
}

GLboolean __glsString_appendCounted(
    __GLSstring *inoutString, const GLubyte* inAppend, size_t inCount
) {
    if (
        inoutString->tail + inCount > inoutString->bufTail &&
        !__glsString_addRoom(inoutString, inCount)
    ) {
        return GL_FALSE;
    }
    strncpy((char *)inoutString->tail, (const char *)inAppend, inCount);
    inoutString->tail += inCount;
    *inoutString->tail = 0;
    return GL_TRUE;
}

GLboolean __glsString_appendInt(
    __GLSstring *inoutString, const GLubyte* inFormat, GLint inVal
) {
    __GLSstringBuf buf;
    size_t count;
    
    if (sprintf((char *)buf, (const char *)inFormat, inVal) < 0) {
        fprintf(stderr, "GLS fatal: sprintf failed\n");
        exit(EXIT_FAILURE);
    }
    count = strlen((const char *)buf);
    if (
        inoutString->tail + count > inoutString->bufTail &&
        !__glsString_addRoom(inoutString, count)
    ) {
        return GL_FALSE;
    }
    strcpy((char *)inoutString->tail, (const char *)buf);
    inoutString->tail += count;
    return GL_TRUE;
}

GLboolean __glsString_assign(
    __GLSstring *inoutString, const GLubyte *inAssign
) {
    inoutString->tail = inoutString->head;
    return __glsString_append(inoutString, inAssign);
}

GLboolean __glsString_assignCounted(
    __GLSstring *inoutString, const GLubyte *inAssign, size_t inCount
) {
    inoutString->tail = inoutString->head;
    return __glsString_appendCounted(inoutString, inAssign, inCount);
}

void __glsString_final(__GLSstring *inoutString) {
    if (inoutString->head != inoutString->buf) {
        free(inoutString->head);
        inoutString->head = inoutString->buf;
    }
}

void __glsString_init(__GLSstring *outString) {
    outString->head = outString->tail = outString->buf;
    outString->bufTail = outString->buf + __GLS_STRING_BUF_BYTES - 1;
    outString->buf[0] = 0;
}

size_t __glsString_length(const __GLSstring *inString) {
    return (size_t)((ULONG_PTR)(inString->tail - inString->head));
}

void __glsString_reset(__GLSstring *inoutString) {
    __glsString_final(inoutString);
    __glsString_init(inoutString);
}

const GLubyte* __glsUCS1String(const GLubyte *inUTF8String) {
    GLuint b;
    const GLubyte *cp = inUTF8String;
    GLubyte *outVal, *p;

    while (b = *cp++) if (b & 0x80) break;
    if (!b) return inUTF8String;
    p = outVal = (GLubyte *)__glsMalloc(strlen((const char *)inUTF8String));
    if (!p) return GLS_NONE;
    while (*inUTF8String) {
        const GLint n = glsUTF8toUCS4(inUTF8String, &b);

        if (n && b <= 0xff) {
            inUTF8String += n;
            *p++ = (GLubyte)b;
        } else {
            free(outVal);
            if (!n) __GLS_RAISE_ERROR(GLS_INVALID_STRING);
            return GLS_NONE;
        }
    }
    *p = 0;
    return outVal;
}

GLboolean __glsValidateString(const GLubyte *inString) {
    if (!glsIsUTF8String(inString)) {
        __GLS_RAISE_ERROR(GLS_INVALID_STRING);
        return GL_FALSE;
    }
    return GL_TRUE;
}

/******************************************************************************
Vertex array
******************************************************************************/

void __glsGetArrayState(__GLScontext *ctx, __GLSarrayState *arrayState)
{
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glIsEnabled);
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetPointerv);

    arrayState->enabled = 0;

    if (glIsEnabled(GL_VERTEX_ARRAY))
    {
        arrayState->enabled |= __GLS_VERTEX_ARRAY_ENABLE;

        glGetIntegerv(GL_VERTEX_ARRAY_SIZE, &arrayState->vertex.size);
        glGetIntegerv(GL_VERTEX_ARRAY_TYPE, &arrayState->vertex.type);
        glGetIntegerv(GL_VERTEX_ARRAY_STRIDE, &arrayState->vertex.stride);
        glGetPointerv(GL_VERTEX_ARRAY_POINTER,
                      (GLvoid **)&arrayState->vertex.data);
    }
    
    if (glIsEnabled(GL_NORMAL_ARRAY))
    {
        arrayState->enabled |= __GLS_NORMAL_ARRAY_ENABLE;

        arrayState->normal.size = 3;
        glGetIntegerv(GL_NORMAL_ARRAY_TYPE, &arrayState->normal.type);
        glGetIntegerv(GL_NORMAL_ARRAY_STRIDE, &arrayState->normal.stride);
        glGetPointerv(GL_NORMAL_ARRAY_POINTER,
                      (GLvoid **)&arrayState->normal.data);
    }
    
    if (glIsEnabled(GL_COLOR_ARRAY))
    {
        arrayState->enabled |= __GLS_COLOR_ARRAY_ENABLE;

        glGetIntegerv(GL_COLOR_ARRAY_SIZE, &arrayState->color.size);
        glGetIntegerv(GL_COLOR_ARRAY_TYPE, &arrayState->color.type);
        glGetIntegerv(GL_COLOR_ARRAY_STRIDE, &arrayState->color.stride);
        glGetPointerv(GL_COLOR_ARRAY_POINTER,
                      (GLvoid **)&arrayState->color.data);
    }
    
    if (glIsEnabled(GL_INDEX_ARRAY))
    {
        arrayState->enabled |= __GLS_INDEX_ARRAY_ENABLE;

        arrayState->index.size = 1;
        glGetIntegerv(GL_INDEX_ARRAY_TYPE, &arrayState->index.type);
        glGetIntegerv(GL_INDEX_ARRAY_STRIDE, &arrayState->index.stride);
        glGetPointerv(GL_INDEX_ARRAY_POINTER,
                      (GLvoid **)&arrayState->index.data);
    }
    
    if (glIsEnabled(GL_TEXTURE_COORD_ARRAY))
    {
        arrayState->enabled |= __GLS_TEXTURE_COORD_ARRAY_ENABLE;

        glGetIntegerv(GL_TEXTURE_COORD_ARRAY_SIZE,
                      &arrayState->textureCoord.size);
        glGetIntegerv(GL_TEXTURE_COORD_ARRAY_TYPE,
                      &arrayState->textureCoord.type);
        glGetIntegerv(GL_TEXTURE_COORD_ARRAY_STRIDE,
                      &arrayState->textureCoord.stride);
        glGetPointerv(GL_TEXTURE_COORD_ARRAY_POINTER,
                      (GLvoid **)&arrayState->textureCoord.data);
    }
    
    if (glIsEnabled(GL_EDGE_FLAG_ARRAY))
    {
        arrayState->enabled |= __GLS_EDGE_FLAG_ARRAY_ENABLE;

        arrayState->edgeFlag.size = 1;
        arrayState->edgeFlag.type = __GLS_BOOLEAN;
        glGetIntegerv(GL_EDGE_FLAG_ARRAY_STRIDE, &arrayState->edgeFlag.stride);
        glGetPointerv(GL_EDGE_FLAG_ARRAY_POINTER,
                      (GLvoid **)&arrayState->edgeFlag.data);
    }
    
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glIsEnabled);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetPointerv);
}

GLint __glsArrayDataSize(GLsizei count, __GLSarrayState *arrayState)
{
    GLint size;
    GLint i;
    __GLSsingleArrayState *array;
    GLuint arrayBit;

    /* Start with space for the data size, count and enables */
    size = 12;

    /* Every array stores its size and type fields even
       for the cases where size and type are fixed.  This
       allows one piece of code to handle any array */

    array = &arrayState->vertex;
    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (arrayState->enabled & arrayBit)
        {
            size += 8 + __GLS_ARRAY_SIZE(count, array->size, array->type);
        }

        array++;
        arrayBit <<= 1;
    }

    return size;
}

typedef struct _DeHashEntry
{
    GLuint original;
    struct _DeHashEntry *next;
} DeHashEntry;

typedef GLubyte DeHashIndex;
#define DE_HASH_SIZE    256
#define DE_HASH(ui)     ((DeHashIndex)(ui))

GLint __glsDrawElementsDataSize(GLsizei count, GLenum type,
                                const GLvoid *indices,
                                __GLSarrayState *arrayState,
                                __GLSdrawElementsState *deState)
{
    GLubyte *allData;
    DeHashEntry *hashTable[DE_HASH_SIZE];
    GLint vtxCount;
    GLint i;
    GLubyte *idxData;
    GLuint idx;
    DeHashEntry *hashEntries;
    GLuint *outIndices;
    DeHashEntry *ent;
    DeHashIndex hash;
    
    // Determine the set of unique vertex indices by hashing
    // all the input indices and checking for duplicates
    // There can't be more unique indices than input indices
    // so count is an upper bound for our allocations
    
    allData = __glsMalloc(count * (sizeof(GLuint)+sizeof(DeHashEntry)));
    if (allData == NULL)
    {
        return -1;
    }

    deState->freePtr = allData;
    outIndices = (GLuint *)allData;
    deState->indices = outIndices;
    hashEntries = (DeHashEntry *)(outIndices+count);

    memset(hashTable, 0, DE_HASH_SIZE*sizeof(DeHashEntry *));

    vtxCount = 0;
    idxData = (GLubyte *)indices;

    for (i = 0; i < count; i++)
    {
        // Get incoming index
        switch(type)
        {
        case GL_UNSIGNED_BYTE:
            idx = *idxData++;
            break;
        case GL_UNSIGNED_SHORT:
            idx = *(GLushort *)idxData;
            idxData += sizeof(GLushort);
            break;
        case GL_UNSIGNED_INT:
            idx = *(GLuint *)idxData;
            idxData += sizeof(GLuint);
            break;
        }
        
        // Look for a matching index in the hash table
        hash = DE_HASH(idx);
        ent = hashTable[hash];
        while (ent != NULL && ent->original != idx)
        {
            ent = ent->next;
        }

        // If we didn't find a match, add a new vertex
        // reference
        if (ent == NULL)
        {
            ent = &hashEntries[vtxCount++];
            ent->original = idx;
            ent->next = hashTable[hash];
            hashTable[hash] = ent;
        }

        // Create index into unique vertex set
        *outIndices++ = (GLuint)((ULONG_PTR)(ent-hashEntries));
    }

    // Overwrite hash entries with just the vertex mappings for return
    outIndices = (GLuint *)hashEntries;
    deState->vertices = outIndices;
    deState->vtxCount = vtxCount;

    for (i = 0; i < vtxCount; i++)
    {
        *outIndices++ = hashEntries->original;
        hashEntries++;
    }

    // Return the combined size of the unique vertex data and
    // the new element indices
    return __glsArrayDataSize(vtxCount, arrayState) + count*sizeof(GLuint);
}

void __glsWriteArrayValues(__GLSwriter *writer, GLint first,
                           GLsizei count, __GLSsingleArrayState *array)
{
    GLint elStep;
    const GLvoid *data;

    if (array->stride > 0)
    {
        elStep = array->stride;
    }
    else
    {
        elStep = array->size * __glsTypeSize(array->type);
    }
    data = (const GLvoid *)((GLubyte *)array->data + first*elStep);
    
    __glsWriter_putVertexv(writer, array->size, array->type, array->stride,
                           count, data);
}

// This routine must be called with an odd writer alignment
void __glsWriteArrayData(__GLSwriter *writer, GLint size,
                         GLint first, GLsizei count,
                         GLenum type, const GLvoid *indices,
                         __GLSarrayState *arrayState)
{
    GLint i, el;
    __GLSsingleArrayState *array;
    GLuint arrayBit;
    GLubyte *ubIndices;
    GLushort *usIndices;
    GLuint *uiIndices;

    writer->putGLint(writer, size);
    writer->putGLint(writer, count);
    writer->putGLuint(writer, arrayState->enabled);

    array = &arrayState->vertex;
    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (arrayState->enabled & arrayBit)
        {
            writer->putGLint(writer, array->size);
            writer->putGLint(writer, array->type);

            if (indices != NULL)
            {
                switch(type)
                {
                case GL_UNSIGNED_BYTE:
                    ubIndices = (GLubyte *)indices;
                    for (el = 0; el < count; el++)
                    {
                        __glsWriteArrayValues(writer, ubIndices[el], 1, array);
                    }
                    break;
                case GL_UNSIGNED_SHORT:
                    usIndices = (GLshort *)indices;
                    for (el = 0; el < count; el++)
                    {
                        __glsWriteArrayValues(writer, usIndices[el], 1, array);
                    }
                    break;
                case GL_UNSIGNED_INT:
                    uiIndices = (GLuint *)indices;
                    for (el = 0; el < count; el++)
                    {
                        __glsWriteArrayValues(writer, uiIndices[el], 1, array);
                    }
                    break;
                }
            }
            else
            {
                __glsWriteArrayValues(writer, first, count, array);
            }

            // Pad data out to an eight-byte boundary
            if (writer->type != GLS_TEXT)
            {
                GLint pad;
                double padValue = 0.0;
        
                pad = 8 - (__GLS_EXACT_ARRAY_SIZE(count, array->size,
                                                  array->type) & 7);
                if (pad < 8)
                {
                    writer->putGLubytev(writer, pad,
                                        (const GLubyte *)&padValue);
                }
            }
        }

        array++;
        arrayBit <<= 1;
    }
}

// This routine must be called with an odd writer alignment
void __glsWriteDrawElementsData(__GLSwriter *writer, GLint size,
                                GLsizei count, __GLSarrayState *arrayState,
                                __GLSdrawElementsState *deState)
{
    __glsWriteArrayData(writer, size, 0, deState->vtxCount, GL_UNSIGNED_INT,
                        deState->vertices, arrayState);
    writer->putGLuintv(writer, count, deState->indices);
    free(deState->freePtr);
}

typedef void (*__GLSdispatchVertexPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchColorPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchEdgeFlagPointer)(GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchIndexPointer)(GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchNormalPointer)(GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchTexCoordPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

void __glsSetArrayState(__GLScontext *ctx, GLubyte *data)
{
    GLsizei count;
    GLuint enabled;

    count = *(GLsizei *)(data+4);
    enabled = *(GLuint *)(data+8);
    data += 12;

    // Enable/DisableClientState produce their own records so
    // the current enable state should be correct
    
    if (enabled & __GLS_VERTEX_ARRAY_ENABLE)
    {
        ((__GLSdispatchVertexPointer)ctx->dispatchCall[385])
            (*(GLint *)(data+0),
             *(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, *(GLint *)(data+0),
                                     *(GLenum *)(data+4));
    }
    if (enabled & __GLS_NORMAL_ARRAY_ENABLE)
    {
        ((__GLSdispatchNormalPointer)ctx->dispatchCall[382])
            (*(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, 3, *(GLenum *)(data+4));
    }
    if (enabled & __GLS_COLOR_ARRAY_ENABLE)
    {
        ((__GLSdispatchColorPointer)ctx->dispatchCall[372])
            (*(GLint *)(data+0),
             *(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, *(GLint *)(data+0),
                                     *(GLenum *)(data+4));
    }
    if (enabled & __GLS_INDEX_ARRAY_ENABLE)
    {
        ((__GLSdispatchIndexPointer)ctx->dispatchCall[378])
            (*(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, 1, *(GLenum *)(data+4));
    }
    if (enabled & __GLS_TEXTURE_COORD_ARRAY_ENABLE)
    {
        ((__GLSdispatchTexCoordPointer)ctx->dispatchCall[384])
            (*(GLint *)(data+0),
             *(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, *(GLint *)(data+0),
                                     *(GLenum *)(data+4));
    }
    if (enabled & __GLS_EDGE_FLAG_ARRAY_ENABLE)
    {
        ((__GLSdispatchEdgeFlagPointer)ctx->dispatchCall[376])
            (0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, 1, __GLS_BOOLEAN);
    }
}

GLvoid *__glsSetArrayStateText(__GLScontext *ctx, __GLSreader *reader,
                               GLuint *enabled, GLsizei *count)
{
    GLint size;
    GLubyte *ptr;
    int i;
    GLuint arrayBit;
    GLvoid *data = GLS_NONE;
        
    __glsReader_getGLint_text(reader, &size);
    __glsReader_getGLint_text(reader, count);
    __glsReader_getGLuint_text(reader, enabled);

    data = __glsMalloc(size);
    if (!data) goto end;

    ptr = (GLubyte *)data;
    *(GLint *)(ptr+0) = size;
    *(GLsizei *)(ptr+4) = *count;
    *(GLuint *)(ptr+8) = *enabled;
    ptr += 12;

    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (*enabled & arrayBit)
        {
            __glsReader_getGLint_text(reader, (GLint *)(ptr+0));
            __glsReader_getGLenum_text(reader, (GLenum *)(ptr+4));
            
            size = __GLS_EXACT_ARRAY_SIZE(*count, *(GLint *)(ptr+0),
                                          *(GLenum *)(ptr+4));
            __glsReader_getGLcompv_text(reader, *(GLenum *)(ptr+4),
                                        size, ptr+8);
            
            ptr += 8 + __GLS_PAD_EIGHT(size);
        }

        arrayBit <<= 1;
    }
    
    if (reader->error)
    {
        free(data);
        data = NULL;
        goto end;
    }
    
    __glsSetArrayState(ctx, data);

end:
    return data;
}

void __glsDisableArrayState(__GLScontext *ctx, GLuint enabled)
{
    // Doesn't currently need to do anything because
    // enable/disable are handled by their own records
}

void __glsSwapArrayData(GLubyte *data)
{
    int i;
    GLuint arrayBit;
    GLsizei count;
    GLuint enabled;
    GLint size;
    
    __glsSwap4(data+0);
    __glsSwap4(data+4);
    count = *(GLsizei *)(data+4);
    __glsSwap4(data+8);
    enabled = *(GLuint *)(data+8);
    data += 12;
    
    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (enabled & arrayBit)
        {
            __glsSwap4(data+0);
            __glsSwap4(data+4);
            
            size = __GLS_EXACT_ARRAY_SIZE(count, *(GLint *)(data+0),
                                          *(GLenum *)(data+4));
            __glsSwapv(*(GLenum *)(data+4), size, data+8);

            data += 8 + __GLS_PAD_EIGHT(size);
        }

        arrayBit <<= 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\exec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

static GLclampf __glsFloatToClampf(GLfloat inVal) {
    if (inVal < 0.f) inVal = 0.f;
    if (inVal > 1.f) inVal = 1.f;
    return inVal;
}

void __gls_exec_glsBeginGLS(
    GLint inVersionMajor, GLint inVersionMinor
) {
    __GLS_CONTEXT->streamVersion.major = inVersionMajor;
    __GLS_CONTEXT->streamVersion.minor = inVersionMinor;
}

void __gls_exec_glsBlock(GLSenum inBlockType) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    switch (inBlockType) {
        case GLS_FRAME:
        case GLS_INIT:
        case GLS_STATIC:
            ctx->blockType = inBlockType;
            break;
        case GLS_HEADER:
            if (__glsHeader_reset(&ctx->header)) ctx->blockType = inBlockType;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

GLSenum __gls_exec_glsCallStream(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;
    GLSenum outType = GLS_NONE;
    __GLSversion versionSave;

    if (ctx->abortMode) return outType;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        glsAbortCall(GLS_ALL);
        return outType;
    }
    if (!__glsValidateString(inName)) return outType;
    ++ctx->callNesting;
    versionSave = ctx->streamVersion;
    ctx->streamVersion.major = ctx->streamVersion.minor = 0;
    if (
        contextStream = __glsStr2PtrDict_find(ctx->contextStreamDict, inName)
    ) {
        GLint i;

        outType = GLS_CONTEXT;
        for (i = 0 ; i < ctx->captureNesting ; ++i) {
            if (ctx->writers[i]->contextStream == contextStream) {
                __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                outType = GLS_NONE;
                break;
            }
        }
        if (outType == GLS_CONTEXT) __glsContextStream_call(contextStream);
    } else if (readStream = __glsReadStream_create(inName)) {
        __GLSreader reader;

        if (__glsReader_init_stream(
            &reader, readStream, __GLS_READER_BUF_BYTES
        )) {
            outType = reader.type;
            __glsReader_call(&reader);
            __glsReader_final(&reader);
        } else {
            __GLS_RAISE_ERROR(GLS_INVALID_STREAM);
        }
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
    }
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) glsAbortCall(GLS_NONE);
            break;
        case GLS_LAST:
            glsAbortCall(GLS_NONE);
            break;
    }
    ctx->streamVersion = versionSave;
    return outType;
}

void __gls_exec_glsEndGLS(void) {
    __GLS_CONTEXT->streamVersion.major = 0;
    __GLS_CONTEXT->streamVersion.minor = 0;
}

void __gls_exec_glsError(GLSopcode inOpcode, GLSenum inError) {
    if (
        inError &&
        (inError < GLS_CALL_OVERFLOW || inError > GLS_UNSUPPORTED_EXTENSION)
    ) {
        inError = GLS_INVALID_ENUM;
    }
    __GLS_RAISE_ERROR( UintToPtr(inError) );
}

void __gls_exec_glsGLRC(GLuint inGLRC) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!inGLRC || inGLRC > (GLuint)ctx->header.glrcCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
    } else {
        ctx->currentGLRC = inGLRC;
    }
}

void __gls_exec_glsGLRCLayer(
    GLuint inGLRC, GLuint inLayer, GLuint inReadLayer
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (
        !inGLRC ||
        inGLRC > (GLuint)ctx->header.glrcCount ||
        !inLayer ||
        inLayer > (GLuint)ctx->header.layerCount ||
        inReadLayer > (GLuint)ctx->header.layerCount
    ) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
    } else {
        __GLSglrc *const glrc = ctx->header.glrcs + inGLRC - 1;

        glrc->layer = inLayer;
        glrc->readLayer = inReadLayer;
    }
}

void __gls_exec_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSglrc *glrc;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!inGLRC || inGLRC > (GLuint)ctx->header.glrcCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    glrc = ctx->header.glrcs + inGLRC - 1;
    switch (inAttrib) {
        case GLS_LAYER:
            if (inVal < 1 || inVal > ctx->header.layerCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else {
                glrc->layer = inVal;
            }
            break;
        case GLS_READ_LAYER:
            if (inVal < 0 || inVal > ctx->header.layerCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else {
                glrc->readLayer = inVal;
            }
            break;
        case GLS_SHARE_GLRC:
            if (inVal < 0 || inVal > ctx->header.glrcCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else {
                glrc->shareGLRC = inVal;
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderLayerf(
    GLuint inLayer, GLSenum inAttrib, GLfloat inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_INVISIBLE_ASPECT:
            layer->invisibleAspect = inVal > 0.f ? inVal : 0.f;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderLayeri(
    GLuint inLayer, GLSenum inAttrib, GLint inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_DISPLAY_FORMAT:
            switch (inVal) {
                case GLS_IIII:
                case GLS_RGBA:
                case GLS_RRRA:
                    layer->displayFormat = inVal;
                    break;
                default:
                    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
                    break;
            }
            break;
        case GLS_DOUBLEBUFFER:
            layer->doubleBuffer = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_INVISIBLE:
            layer->invisible = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_INVISIBLE_HEIGHT_PIXELS:
            layer->invisibleHeightPixels = inVal > 0 ? inVal : 0;
            break;
        case GLS_LEVEL:
            layer->level = inVal;
            break;
        case GLS_STEREO:
            layer->stereo = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_TRANSPARENT:
            layer->transparent = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_INDEX_BITS:
            layer->indexBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_RED_BITS:
            layer->redBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_GREEN_BITS:
            layer->greenBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_BLUE_BITS:
            layer->blueBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ALPHA_BITS:
            layer->alphaBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_DEPTH_BITS:
            layer->depthBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_STENCIL_BITS:
            layer->stencilBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_RED_BITS:
            layer->accumRedBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_GREEN_BITS:
            layer->accumGreenBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_BLUE_BITS:
            layer->accumBlueBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_ALPHA_BITS:
            layer->accumAlphaBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_AUX_BUFFERS:
            layer->auxBuffers = inVal > 0 ? inVal : 0;
            break;
        #if __GL_SGIS_multisample
            case GLS_SAMPLE_BUFFERS_SGIS:
                layer->sampleBuffers = inVal > 0 ? inVal : 0;
                break;
            case GLS_SAMPLES_SGIS:
                layer->samples = inVal > 0 ? inVal : 0;
                break;
        #endif /* __GL_SGIS_multisample */
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderf(GLSenum inAttrib, GLfloat inVal) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_ASPECT:
            header->aspect = inVal > 0.f ? inVal : 0.f;
            break;
        case GLS_BORDER_WIDTH:
            header->borderWidth = inVal > 0.f ? inVal : 0.f;
            break;
        case GLS_CONTRAST_RATIO:
            header->contrastRatio = inVal > 0.f ? inVal : 0.f;
            break;
        case GLS_HEIGHT_MM:
            header->heightMM = inVal > 0.f ? inVal : 0.f;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;
    GLint i;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_BORDER_COLOR:
            for (i = 0 ; i < 4 ; ++i) {
                header->borderColor[i] = __glsFloatToClampf(inVec[i]);
            }
            break;
        case GLS_GAMMA:
            for (i = 0 ; i < 4 ; ++i) {
                header->gamma[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_ORIGIN:
            for (i = 0 ; i < 2 ; ++i) header->origin[i] = inVec[i];
            break;
        case GLS_PAGE_COLOR:
            for (i = 0 ; i < 4 ; ++i) {
                header->pageColor[i] = __glsFloatToClampf(inVec[i]);
            }
            break;
        case GLS_PAGE_SIZE:
            for (i = 0 ; i < 2 ; ++i) {
                header->pageSize[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_RED_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->redPoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_GREEN_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->greenPoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_BLUE_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->bluePoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_WHITE_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->whitePoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderi(GLSenum inAttrib, GLint inVal) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_FRAME_COUNT:
            header->frameCount = inVal > 0 ? inVal : 0;
            break;
        case GLS_GLRC_COUNT:
            if (inVal < header->glrcCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else if (inVal > header->glrcCount) {
                GLint i;
                __GLSglrc *glrcs = __glsMalloc(inVal * sizeof(__GLSglrc));

                if (!glrcs) break;
                memcpy(
                    glrcs,
                    header->glrcs,
                    header->glrcCount * sizeof(__GLSglrc)
                );
                for (i = header->glrcCount ; i < inVal ; ++i) {
                    __glsGLRC_init(glrcs + i);
                }
                header->glrcCount = inVal;
                free(header->glrcs);
                header->glrcs = glrcs;
            }
            break;
        case GLS_HEIGHT_PIXELS:
            header->heightPixels = inVal > 0 ? inVal : 0;
            break;
        case GLS_LAYER_COUNT:
            if (inVal < header->layerCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else if (inVal > header->layerCount) {
                GLint i;
                __GLSlayer *layers = __glsMalloc(inVal * sizeof(__GLSlayer));

                if (!layers) break;
                memcpy(
                    layers,
                    header->layers,
                    header->layerCount * sizeof(__GLSlayer)
                );
                for (i = header->layerCount ; i < inVal ; ++i) {
                    __glsLayer_init(layers + i);
                }
                header->layerCount = inVal;
                free(header->layers);
                header->layers = layers;
            }
            break;
        case GLS_TILEABLE:
            header->tileable = inVal ? GL_TRUE : GL_FALSE;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;
    GLint i;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_CREATE_TIME:
            for (i = 0 ; i < 6 ; ++i) {
                header->createTime[i] = inVec[i] > 0 ? inVec[i] : 0;
            }
            break;
        case GLS_MODIFY_TIME:
            for (i = 0 ; i < 6 ; ++i) {
                header->modifyTime[i] = inVec[i] > 0 ? inVec[i] : 0;
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!__glsValidateString(inString)) return;
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_EXTENSIONS:
            __glsString_assign(&header->extensions, inString);
            break;
        case GLS_AUTHOR:
            __glsString_assign(&header->author, inString);
            break;
        case GLS_DESCRIPTION:
            __glsString_assign(&header->description, inString);
            break;
        case GLS_NOTES:
            __glsString_assign(&header->notes, inString);
            break;
        case GLS_TITLE:
            __glsString_assign(&header->title, inString);
            break;
        case GLS_TOOLS:
            __glsString_assign(&header->tools, inString);
            break;
        case GLS_VERSION:
            __glsString_assign(&header->version, inString);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsRequireExtension(const GLubyte *inExtension) {
    if (!__glsValidateString(inExtension)) return;
    if (!glsIsExtensionSupported(inExtension)) {
        __GLS_RAISE_ERROR(GLS_UNSUPPORTED_EXTENSION);
    }
}

void __gls_exec_glsUnsupportedCommand(void) {
    __GLS_RAISE_ERROR(GLS_UNSUPPORTED_COMMAND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_cap.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"
#include <string.h>

// DrewB - Removed size externs
// DrewB - All inactive extension functions have had their capture
//         flags index removed since they all need to be reset to
//         account for the added 1.1 functions

void __gls_capture_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(16);
    captureFlags = ctx->captureFlags[16];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsBeginGLS(GLint, GLint);
        __gls_exec_glsBeginGLS(inVersionMajor, inVersionMinor);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 16, 8)) goto end;
    writer->putGLint(writer, inVersionMajor);
    writer->putGLint(writer, inVersionMinor);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(16);
    --ctx->captureEntryCount;
}

void __gls_capture_glsBlock(GLSenum inBlockType) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(17);
    captureFlags = ctx->captureFlags[17];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsBlock(GLSenum);
        __gls_exec_glsBlock(inBlockType);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 17, 4)) goto end;
    writer->putGLSenum(writer, inBlockType);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(17);
    --ctx->captureEntryCount;
}

GLSenum __gls_capture_glsCallStream(const GLubyte *inName) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLSenum _outVal = 0;
    GLint inName_count;
    if (!glsIsUTF8String(inName)) {
        glsError(18, GLS_INVALID_STRING);
        return _outVal;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(18);
    captureFlags = ctx->captureFlags[18];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern GLSenum __gls_exec_glsCallStream(const GLubyte *);
        _outVal = __gls_exec_glsCallStream(inName);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inName_count = (GLint)strlen((const char *)inName) + 1;
    if (!writer->beginCommand(writer, 18, 0 + inName_count)) goto end;
    writer->putGLcharv(writer, inName_count, inName);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(18);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glsEndGLS(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(19);
    captureFlags = ctx->captureFlags[19];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsEndGLS(void);
        __gls_exec_glsEndGLS();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 19, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(19);
    --ctx->captureEntryCount;
}

void __gls_capture_glsError(GLSopcode inOpcode, GLSenum inError) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(20);
    captureFlags = ctx->captureFlags[20];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsError(GLSopcode, GLSenum);
        __gls_exec_glsError(inOpcode, inError);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 20, 8)) goto end;
    writer->putGLSopcode(writer, inOpcode);
    writer->putGLSenum(writer, inError);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(20);
    --ctx->captureEntryCount;
}

void __gls_capture_glsGLRC(GLuint inGLRC) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(21);
    captureFlags = ctx->captureFlags[21];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsGLRC(GLuint);
        __gls_exec_glsGLRC(inGLRC);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 21, 4)) goto end;
    writer->putGLuint(writer, inGLRC);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(21);
    --ctx->captureEntryCount;
}

void __gls_capture_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(22);
    captureFlags = ctx->captureFlags[22];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsGLRCLayer(GLuint, GLuint, GLuint);
        __gls_exec_glsGLRCLayer(inGLRC, inLayer, inReadLayer);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 22, 12)) goto end;
    writer->putGLuint(writer, inGLRC);
    writer->putGLuint(writer, inLayer);
    writer->putGLuint(writer, inReadLayer);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(22);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(23);
    captureFlags = ctx->captureFlags[23];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderGLRCi(GLuint, GLSenum, GLint);
        __gls_exec_glsHeaderGLRCi(inGLRC, inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 23, 12)) goto end;
    writer->putGLuint(writer, inGLRC);
    writer->putGLSenum(writer, inAttrib);
    writer->putGLint(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(23);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(24);
    captureFlags = ctx->captureFlags[24];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderLayerf(GLuint, GLSenum, GLfloat);
        __gls_exec_glsHeaderLayerf(inLayer, inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 24, 12)) goto end;
    writer->putGLuint(writer, inLayer);
    writer->putGLSenum(writer, inAttrib);
    writer->putGLfloat(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(24);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(25);
    captureFlags = ctx->captureFlags[25];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderLayeri(GLuint, GLSenum, GLint);
        __gls_exec_glsHeaderLayeri(inLayer, inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 25, 12)) goto end;
    writer->putGLuint(writer, inLayer);
    writer->putGLSenum(writer, inAttrib);
    writer->putGLintOrGLSenum(writer, inAttrib, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(25);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderf(GLSenum inAttrib, GLfloat inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(26);
    captureFlags = ctx->captureFlags[26];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderf(GLSenum, GLfloat);
        __gls_exec_glsHeaderf(inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 26, 8)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLfloat(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(26);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inVec_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(27);
    captureFlags = ctx->captureFlags[27];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderfv(GLSenum, const GLfloat *);
        __gls_exec_glsHeaderfv(inAttrib, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inVec_count = __gls_glsHeaderfv_inVec_size(inAttrib);
    if (!writer->beginCommand(writer, 27, 4 + inVec_count * 4)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLfloatv(writer, inVec_count, inVec);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(27);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderi(GLSenum inAttrib, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(28);
    captureFlags = ctx->captureFlags[28];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderi(GLSenum, GLint);
        __gls_exec_glsHeaderi(inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 28, 8)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLint(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(28);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inVec_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(29);
    captureFlags = ctx->captureFlags[29];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderiv(GLSenum, const GLint *);
        __gls_exec_glsHeaderiv(inAttrib, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inVec_count = __gls_glsHeaderiv_inVec_size(inAttrib);
    if (!writer->beginCommand(writer, 29, 4 + inVec_count * 4)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLintv(writer, inVec_count, inVec);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(29);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inString_count;
    if (!glsIsUTF8String(inString)) {
        glsError(30, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(30);
    captureFlags = ctx->captureFlags[30];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderubz(GLSenum, const GLubyte *);
        __gls_exec_glsHeaderubz(inAttrib, inString);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inString_count = (GLint)strlen((const char *)inString) + 1;
    if (!writer->beginCommand(writer, 30, 4 + inString_count)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLcharv(writer, inString_count, inString);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(30);
    --ctx->captureEntryCount;
}

void __gls_capture_glsRequireExtension(const GLubyte *inExtension) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inExtension_count;
    if (!glsIsUTF8String(inExtension)) {
        glsError(31, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(31);
    captureFlags = ctx->captureFlags[31];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsRequireExtension(const GLubyte *);
        __gls_exec_glsRequireExtension(inExtension);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inExtension_count = (GLint)strlen((const char *)inExtension) + 1;
    if (!writer->beginCommand(writer, 31, 0 + inExtension_count)) goto end;
    writer->putGLcharv(writer, inExtension_count, inExtension);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(31);
    --ctx->captureEntryCount;
}

void __gls_capture_glsUnsupportedCommand(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(32);
    captureFlags = ctx->captureFlags[32];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsUnsupportedCommand(void);
        __gls_exec_glsUnsupportedCommand();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 32, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(32);
    --ctx->captureEntryCount;
}

void __gls_capture_glsAppRef(GLulong inAddress, GLuint inCount) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(33);
    captureFlags = ctx->captureFlags[33];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsAppRef(GLulong, GLuint);
        __gls_exec_glsAppRef(inAddress, inCount);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 33, 12)) goto end;
    writer->putGLulonghex(writer, inAddress);
    writer->putGLuint(writer, inCount);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(33);
    --ctx->captureEntryCount;
}

void __gls_capture_glsBeginObj(const GLubyte *inTag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(34, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(34);
    captureFlags = ctx->captureFlags[34];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsBeginObj(const GLubyte *);
        __gls_exec_glsBeginObj(inTag);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 34, 0 + inTag_count)) goto end;
    writer->putGLcharv(writer, inTag_count, inTag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(34);
    --ctx->captureEntryCount;
}

void __gls_capture_glsCharubz(const GLubyte *inTag, const GLubyte *inString) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    GLint inString_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(35, GLS_INVALID_STRING);
        return;
    }
    if (!glsIsUTF8String(inString)) {
        glsError(35, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(35);
    captureFlags = ctx->captureFlags[35];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsCharubz(const GLubyte *, const GLubyte *);
        __gls_exec_glsCharubz(inTag, inString);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    inString_count = (GLint)strlen((const char *)inString) + 1;
    if (!writer->beginCommand(writer, 35, 0 + inTag_count + inString_count)) goto end;
    writer->putGLcharv(writer, inTag_count, inTag);
    writer->putGLcharv(writer, inString_count, inString);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(35);
    --ctx->captureEntryCount;
}

void __gls_capture_glsComment(const GLubyte *inComment) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inComment_count;
    if (!glsIsUTF8String(inComment)) {
        glsError(36, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(36);
    captureFlags = ctx->captureFlags[36];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsComment(const GLubyte *);
        __gls_exec_glsComment(inComment);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inComment_count = (GLint)strlen((const char *)inComment) + 1;
    if (!writer->beginCommand(writer, 36, 0 + inComment_count)) goto end;
    writer->putGLcharv(writer, inComment_count, inComment);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(36);
    --ctx->captureEntryCount;
}

void __gls_capture_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(37);
    captureFlags = ctx->captureFlags[37];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsDisplayMapfv(GLuint, GLSenum, GLuint, const GLfloat *);
        __gls_exec_glsDisplayMapfv(inLayer, inMap, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 37, 12 + __GLS_MAX(inCount, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLuint(writer, inLayer);
        writer->putGLSenum(writer, inMap);
        writer->putGLuint(writer, inCount);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLuint(writer, inLayer);
        writer->putGLSenum(writer, inMap);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(37);
    --ctx->captureEntryCount;
}

void __gls_capture_glsEndObj(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(38);
    captureFlags = ctx->captureFlags[38];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsEndObj(void);
        __gls_exec_glsEndObj();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 38, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(38);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumb(const GLubyte *inTag, GLbyte inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(39, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(39);
    captureFlags = ctx->captureFlags[39];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumb(const GLubyte *, GLbyte);
        __gls_exec_glsNumb(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 39, 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLbyte(writer, inVal);
    } else {
        writer->putGLbyte(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(39);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(40, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(40);
    captureFlags = ctx->captureFlags[40];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumbv(const GLubyte *, GLuint, const GLbyte *);
        __gls_exec_glsNumbv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 40, 4 + __GLS_MAX(inCount, 0) * 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLbytev(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLbytev(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(40);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumd(const GLubyte *inTag, GLdouble inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(41, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(41);
    captureFlags = ctx->captureFlags[41];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumd(const GLubyte *, GLdouble);
        __gls_exec_glsNumd(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 41, 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLdouble(writer, inVal);
    } else {
        writer->putGLdouble(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(41);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(42, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(42);
    captureFlags = ctx->captureFlags[42];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumdv(const GLubyte *, GLuint, const GLdouble *);
        __gls_exec_glsNumdv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 42, 4 + __GLS_MAX(inCount, 0) * 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLdoublev(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLdoublev(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(42);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumf(const GLubyte *inTag, GLfloat inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(43, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(43);
    captureFlags = ctx->captureFlags[43];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumf(const GLubyte *, GLfloat);
        __gls_exec_glsNumf(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 43, 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLfloat(writer, inVal);
    } else {
        writer->putGLfloat(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(43);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(44, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(44);
    captureFlags = ctx->captureFlags[44];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumfv(const GLubyte *, GLuint, const GLfloat *);
        __gls_exec_glsNumfv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 44, 4 + __GLS_MAX(inCount, 0) * 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(44);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumi(const GLubyte *inTag, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(45, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(45);
    captureFlags = ctx->captureFlags[45];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumi(const GLubyte *, GLint);
        __gls_exec_glsNumi(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 45, 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLint(writer, inVal);
    } else {
        writer->putGLint(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(45);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(46, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(46);
    captureFlags = ctx->captureFlags[46];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumiv(const GLubyte *, GLuint, const GLint *);
        __gls_exec_glsNumiv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 46, 4 + __GLS_MAX(inCount, 0) * 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLintv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLintv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(46);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNuml(const GLubyte *inTag, GLlong inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(47, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(47);
    captureFlags = ctx->captureFlags[47];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNuml(const GLubyte *, GLlong);
        __gls_exec_glsNuml(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 47, 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLlong(writer, inVal);
    } else {
        writer->putGLlong(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(47);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(48, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(48);
    captureFlags = ctx->captureFlags[48];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumlv(const GLubyte *, GLuint, const GLlong *);
        __gls_exec_glsNumlv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 48, 4 + __GLS_MAX(inCount, 0) * 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLlongv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLlongv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(48);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNums(const GLubyte *inTag, GLshort inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(49, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(49);
    captureFlags = ctx->captureFlags[49];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNums(const GLubyte *, GLshort);
        __gls_exec_glsNums(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 49, 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLshort(writer, inVal);
    } else {
        writer->putGLshort(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(49);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(50, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(50);
    captureFlags = ctx->captureFlags[50];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumsv(const GLubyte *, GLuint, const GLshort *);
        __gls_exec_glsNumsv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 50, 4 + __GLS_MAX(inCount, 0) * 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLshortv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLshortv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(50);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumub(const GLubyte *inTag, GLubyte inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(51, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(51);
    captureFlags = ctx->captureFlags[51];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumub(const GLubyte *, GLubyte);
        __gls_exec_glsNumub(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 51, 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLubyte(writer, inVal);
    } else {
        writer->putGLubyte(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(51);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(52, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(52);
    captureFlags = ctx->captureFlags[52];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumubv(const GLubyte *, GLuint, const GLubyte *);
        __gls_exec_glsNumubv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 52, 4 + __GLS_MAX(inCount, 0) * 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLubytev(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLubytev(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(52);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumui(const GLubyte *inTag, GLuint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(53, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(53);
    captureFlags = ctx->captureFlags[53];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumui(const GLubyte *, GLuint);
        __gls_exec_glsNumui(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 53, 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inVal);
    } else {
        writer->putGLuint(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(53);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(54, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(54);
    captureFlags = ctx->captureFlags[54];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumuiv(const GLubyte *, GLuint, const GLuint *);
        __gls_exec_glsNumuiv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 54, 4 + __GLS_MAX(inCount, 0) * 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLuintv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLuintv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(54);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumul(const GLubyte *inTag, GLulong inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(55, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(55);
    captureFlags = ctx->captureFlags[55];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumul(const GLubyte *, GLulong);
        __gls_exec_glsNumul(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 55, 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLulong(writer, inVal);
    } else {
        writer->putGLulong(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(55);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(56, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(56);
    captureFlags = ctx->captureFlags[56];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumulv(const GLubyte *, GLuint, const GLulong *);
        __gls_exec_glsNumulv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 56, 4 + __GLS_MAX(inCount, 0) * 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLulongv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLulongv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(56);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumus(const GLubyte *inTag, GLushort inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(57, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(57);
    captureFlags = ctx->captureFlags[57];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumus(const GLubyte *, GLushort);
        __gls_exec_glsNumus(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 57, 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLushort(writer, inVal);
    } else {
        writer->putGLushort(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(57);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(58, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(58);
    captureFlags = ctx->captureFlags[58];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumusv(const GLubyte *, GLuint, const GLushort *);
        __gls_exec_glsNumusv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 58, 4 + __GLS_MAX(inCount, 0) * 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLushortv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLushortv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(58);
    --ctx->captureEntryCount;
}

void __gls_capture_glsPad(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(59);
    captureFlags = ctx->captureFlags[59];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsPad(void);
        __gls_exec_glsPad();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 59, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(59);
    --ctx->captureEntryCount;
}

void __gls_capture_glsSwapBuffers(GLuint inLayer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(60);
    captureFlags = ctx->captureFlags[60];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsSwapBuffers(GLuint);
        __gls_exec_glsSwapBuffers(inLayer);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 60, 4)) goto end;
    writer->putGLuint(writer, inLayer);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(60);
    --ctx->captureEntryCount;
}

void __gls_capture_glNewList(GLuint list, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(64);
    captureFlags = ctx->captureFlags[64];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 64);
        glNewList(list, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 64);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 64, 8)) goto end;
    writer->putGLuint(writer, list);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(64);
    --ctx->captureEntryCount;
}

void __gls_capture_glEndList(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65);
    captureFlags = ctx->captureFlags[65];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65);
        glEndList();
        __GLS_END_CAPTURE_EXEC(ctx, 65);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65);
    --ctx->captureEntryCount;
}

void __gls_capture_glCallList(GLuint list) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(66);
    captureFlags = ctx->captureFlags[66];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 66);
        glCallList(list);
        __GLS_END_CAPTURE_EXEC(ctx, 66);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 66, 4)) goto end;
    writer->putGLuint(writer, list);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(66);
    --ctx->captureEntryCount;
}

void __gls_capture_glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint lists_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(67);
    captureFlags = ctx->captureFlags[67];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 67);
        glCallLists(n, type, lists);
        __GLS_END_CAPTURE_EXEC(ctx, 67);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    lists_count = __gls_glCallLists_lists_size(n, type);
    if (!writer->beginCommand(writer, 67, 8 + lists_count * 1)) goto end;
    writer->putGLint(writer, n);
    writer->putGLenum(writer, type);
    __glsWriter_putListv(writer, type, n, lists);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(67);
    --ctx->captureEntryCount;
}

void __gls_capture_glDeleteLists(GLuint list, GLsizei range) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(68);
    captureFlags = ctx->captureFlags[68];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 68);
        glDeleteLists(list, range);
        __GLS_END_CAPTURE_EXEC(ctx, 68);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 68, 8)) goto end;
    writer->putGLuint(writer, list);
    writer->putGLint(writer, range);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(68);
    --ctx->captureEntryCount;
}

GLuint __gls_capture_glGenLists(GLsizei range) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLuint _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(69);
    captureFlags = ctx->captureFlags[69];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 69);
        _outVal = glGenLists(range);
        __GLS_END_CAPTURE_EXEC(ctx, 69);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 69, 4)) goto end;
    writer->putGLint(writer, range);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(69);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glListBase(GLuint base) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(70);
    captureFlags = ctx->captureFlags[70];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 70);
        glListBase(base);
        __GLS_END_CAPTURE_EXEC(ctx, 70);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 70, 4)) goto end;
    writer->putGLuint(writer, base);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(70);
    --ctx->captureEntryCount;
}

void __gls_capture_glBegin(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(71);
    captureFlags = ctx->captureFlags[71];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 71);
        glBegin(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 71);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (writer->contextStream && mode <= GL_POLYGON) {
        if (!writer->beginCommand(writer, 1 + mode, 0)) goto end;
        writer->endCommand(writer);
        goto end;
    }
    if (!writer->beginCommand(writer, 71, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(71);
    --ctx->captureEntryCount;
}

void __gls_capture_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint bitmap_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(72);
    captureFlags = ctx->captureFlags[72];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 72);
        glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
        __GLS_END_CAPTURE_EXEC(ctx, 72);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    bitmap_count = __gls_glBitmap_bitmap_size(width, height);
    if (!writer->beginCommand(writer, 72, 28 + bitmap_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLfloat(writer, xorig);
    writer->putGLfloat(writer, yorig);
    writer->putGLfloat(writer, xmove);
    writer->putGLfloat(writer, ymove);
    __glsWriter_putPixelv(writer, GL_COLOR_INDEX, GL_BITMAP, width, height, bitmap_count ? bitmap : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(72);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(73);
    captureFlags = ctx->captureFlags[73];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 73);
        glColor3b(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 73);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 73, 3)) goto end;
    writer->putGLbyte(writer, red);
    writer->putGLbyte(writer, green);
    writer->putGLbyte(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(73);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3bv(const GLbyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(74);
    captureFlags = ctx->captureFlags[74];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 74);
        glColor3bv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 74);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 74, 3)) goto end;
    writer->putGLbytev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(74);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(75);
    captureFlags = ctx->captureFlags[75];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 75);
        glColor3d(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 75);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 75, 24)) goto end;
    writer->putGLdouble(writer, red);
    writer->putGLdouble(writer, green);
    writer->putGLdouble(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(75);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(76);
    captureFlags = ctx->captureFlags[76];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 76);
        glColor3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 76);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 76, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(76);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(77);
    captureFlags = ctx->captureFlags[77];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 77);
        glColor3f(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 77);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 77, 12)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(77);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(78);
    captureFlags = ctx->captureFlags[78];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 78);
        glColor3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 78);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 78, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(78);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3i(GLint red, GLint green, GLint blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(79);
    captureFlags = ctx->captureFlags[79];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 79);
        glColor3i(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 79);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 79, 12)) goto end;
    writer->putGLint(writer, red);
    writer->putGLint(writer, green);
    writer->putGLint(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(79);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(80);
    captureFlags = ctx->captureFlags[80];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 80);
        glColor3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 80);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 80, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(80);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3s(GLshort red, GLshort green, GLshort blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(81);
    captureFlags = ctx->captureFlags[81];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 81);
        glColor3s(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 81);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 81, 6)) goto end;
    writer->putGLshort(writer, red);
    writer->putGLshort(writer, green);
    writer->putGLshort(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(81);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(82);
    captureFlags = ctx->captureFlags[82];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 82);
        glColor3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 82);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 82, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(82);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(83);
    captureFlags = ctx->captureFlags[83];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 83);
        glColor3ub(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 83);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 83, 3)) goto end;
    writer->putGLubyte(writer, red);
    writer->putGLubyte(writer, green);
    writer->putGLubyte(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(83);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3ubv(const GLubyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(84);
    captureFlags = ctx->captureFlags[84];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 84);
        glColor3ubv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 84);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 84, 3)) goto end;
    writer->putGLubytev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(84);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3ui(GLuint red, GLuint green, GLuint blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(85);
    captureFlags = ctx->captureFlags[85];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 85);
        glColor3ui(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 85);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 85, 12)) goto end;
    writer->putGLuint(writer, red);
    writer->putGLuint(writer, green);
    writer->putGLuint(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(85);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3uiv(const GLuint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(86);
    captureFlags = ctx->captureFlags[86];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 86);
        glColor3uiv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 86);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 86, 12)) goto end;
    writer->putGLuintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(86);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3us(GLushort red, GLushort green, GLushort blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(87);
    captureFlags = ctx->captureFlags[87];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 87);
        glColor3us(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 87);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 87, 6)) goto end;
    writer->putGLushort(writer, red);
    writer->putGLushort(writer, green);
    writer->putGLushort(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(87);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3usv(const GLushort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(88);
    captureFlags = ctx->captureFlags[88];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 88);
        glColor3usv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 88);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 88, 6)) goto end;
    writer->putGLushortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(88);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(89);
    captureFlags = ctx->captureFlags[89];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 89);
        glColor4b(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 89);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 89, 4)) goto end;
    writer->putGLbyte(writer, red);
    writer->putGLbyte(writer, green);
    writer->putGLbyte(writer, blue);
    writer->putGLbyte(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(89);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4bv(const GLbyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(90);
    captureFlags = ctx->captureFlags[90];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 90);
        glColor4bv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 90);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 90, 4)) goto end;
    writer->putGLbytev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(90);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(91);
    captureFlags = ctx->captureFlags[91];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 91);
        glColor4d(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 91);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 91, 32)) goto end;
    writer->putGLdouble(writer, red);
    writer->putGLdouble(writer, green);
    writer->putGLdouble(writer, blue);
    writer->putGLdouble(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(91);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(92);
    captureFlags = ctx->captureFlags[92];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 92);
        glColor4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 92);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 92, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(92);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(93);
    captureFlags = ctx->captureFlags[93];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 93);
        glColor4f(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 93);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 93, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(93);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(94);
    captureFlags = ctx->captureFlags[94];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 94);
        glColor4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 94);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 94, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(94);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(95);
    captureFlags = ctx->captureFlags[95];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 95);
        glColor4i(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 95);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 95, 16)) goto end;
    writer->putGLint(writer, red);
    writer->putGLint(writer, green);
    writer->putGLint(writer, blue);
    writer->putGLint(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(95);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(96);
    captureFlags = ctx->captureFlags[96];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 96);
        glColor4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 96);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 96, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(96);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(97);
    captureFlags = ctx->captureFlags[97];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 97);
        glColor4s(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 97);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 97, 8)) goto end;
    writer->putGLshort(writer, red);
    writer->putGLshort(writer, green);
    writer->putGLshort(writer, blue);
    writer->putGLshort(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(97);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(98);
    captureFlags = ctx->captureFlags[98];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 98);
        glColor4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 98);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 98, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(98);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(99);
    captureFlags = ctx->captureFlags[99];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 99);
        glColor4ub(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 99);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 99, 4)) goto end;
    writer->putGLubyte(writer, red);
    writer->putGLubyte(writer, green);
    writer->putGLubyte(writer, blue);
    writer->putGLubyte(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(99);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4ubv(const GLubyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(100);
    captureFlags = ctx->captureFlags[100];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 100);
        glColor4ubv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 100);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 100, 4)) goto end;
    writer->putGLubytev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(100);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(101);
    captureFlags = ctx->captureFlags[101];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 101);
        glColor4ui(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 101);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 101, 16)) goto end;
    writer->putGLuint(writer, red);
    writer->putGLuint(writer, green);
    writer->putGLuint(writer, blue);
    writer->putGLuint(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(101);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4uiv(const GLuint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(102);
    captureFlags = ctx->captureFlags[102];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 102);
        glColor4uiv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 102);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 102, 16)) goto end;
    writer->putGLuintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(102);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(103);
    captureFlags = ctx->captureFlags[103];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 103);
        glColor4us(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 103);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 103, 8)) goto end;
    writer->putGLushort(writer, red);
    writer->putGLushort(writer, green);
    writer->putGLushort(writer, blue);
    writer->putGLushort(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(103);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4usv(const GLushort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(104);
    captureFlags = ctx->captureFlags[104];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 104);
        glColor4usv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 104);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 104, 8)) goto end;
    writer->putGLushortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(104);
    --ctx->captureEntryCount;
}

void __gls_capture_glEdgeFlag(GLboolean flag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(105);
    captureFlags = ctx->captureFlags[105];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 105);
        glEdgeFlag(flag);
        __GLS_END_CAPTURE_EXEC(ctx, 105);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 105, 1)) goto end;
    writer->putGLboolean(writer, flag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(105);
    --ctx->captureEntryCount;
}

void __gls_capture_glEdgeFlagv(const GLboolean *flag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(106);
    captureFlags = ctx->captureFlags[106];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 106);
        glEdgeFlagv(flag);
        __GLS_END_CAPTURE_EXEC(ctx, 106);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 106, 1)) goto end;
    writer->putGLbooleanv(writer, 1, flag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(106);
    --ctx->captureEntryCount;
}

void __gls_capture_glEnd(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(107);
    captureFlags = ctx->captureFlags[107];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 107);
        glEnd();
        __GLS_END_CAPTURE_EXEC(ctx, 107);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 107, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(107);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexd(GLdouble c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(108);
    captureFlags = ctx->captureFlags[108];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 108);
        glIndexd(c);
        __GLS_END_CAPTURE_EXEC(ctx, 108);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 108, 8)) goto end;
    writer->putGLdouble(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(108);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexdv(const GLdouble *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(109);
    captureFlags = ctx->captureFlags[109];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 109);
        glIndexdv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 109);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 109, 8)) goto end;
    writer->putGLdoublev(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(109);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexf(GLfloat c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(110);
    captureFlags = ctx->captureFlags[110];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 110);
        glIndexf(c);
        __GLS_END_CAPTURE_EXEC(ctx, 110);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 110, 4)) goto end;
    writer->putGLfloat(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(110);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexfv(const GLfloat *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(111);
    captureFlags = ctx->captureFlags[111];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 111);
        glIndexfv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 111);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 111, 4)) goto end;
    writer->putGLfloatv(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(111);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexub(GLubyte c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(379);
    captureFlags = ctx->captureFlags[379];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 379);
        glIndexub(c);
        __GLS_END_CAPTURE_EXEC(ctx, 379);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 379, 1)) goto end;
    writer->putGLubyte(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(379);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexubv(const GLubyte *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(380);
    captureFlags = ctx->captureFlags[380];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 380);
        glIndexubv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 380);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 380, 1)) goto end;
    writer->putGLubytev(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(380);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexi(GLint c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(112);
    captureFlags = ctx->captureFlags[112];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 112);
        glIndexi(c);
        __GLS_END_CAPTURE_EXEC(ctx, 112);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 112, 4)) goto end;
    writer->putGLint(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(112);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexiv(const GLint *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(113);
    captureFlags = ctx->captureFlags[113];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 113);
        glIndexiv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 113);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 113, 4)) goto end;
    writer->putGLintv(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(113);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexs(GLshort c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(114);
    captureFlags = ctx->captureFlags[114];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 114);
        glIndexs(c);
        __GLS_END_CAPTURE_EXEC(ctx, 114);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 114, 2)) goto end;
    writer->putGLshort(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(114);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexsv(const GLshort *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(115);
    captureFlags = ctx->captureFlags[115];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 115);
        glIndexsv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 115);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 115, 2)) goto end;
    writer->putGLshortv(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(115);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(116);
    captureFlags = ctx->captureFlags[116];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 116);
        glNormal3b(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 116);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 116, 3)) goto end;
    writer->putGLbyte(writer, nx);
    writer->putGLbyte(writer, ny);
    writer->putGLbyte(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(116);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3bv(const GLbyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(117);
    captureFlags = ctx->captureFlags[117];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 117);
        glNormal3bv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 117);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 117, 3)) goto end;
    writer->putGLbytev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(117);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(118);
    captureFlags = ctx->captureFlags[118];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 118);
        glNormal3d(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 118);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 118, 24)) goto end;
    writer->putGLdouble(writer, nx);
    writer->putGLdouble(writer, ny);
    writer->putGLdouble(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(118);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(119);
    captureFlags = ctx->captureFlags[119];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 119);
        glNormal3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 119);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 119, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(119);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(120);
    captureFlags = ctx->captureFlags[120];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 120);
        glNormal3f(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 120);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 120, 12)) goto end;
    writer->putGLfloat(writer, nx);
    writer->putGLfloat(writer, ny);
    writer->putGLfloat(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(120);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(121);
    captureFlags = ctx->captureFlags[121];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 121);
        glNormal3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 121);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 121, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(121);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3i(GLint nx, GLint ny, GLint nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(122);
    captureFlags = ctx->captureFlags[122];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 122);
        glNormal3i(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 122);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 122, 12)) goto end;
    writer->putGLint(writer, nx);
    writer->putGLint(writer, ny);
    writer->putGLint(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(122);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(123);
    captureFlags = ctx->captureFlags[123];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 123);
        glNormal3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 123);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 123, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(123);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(124);
    captureFlags = ctx->captureFlags[124];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 124);
        glNormal3s(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 124);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 124, 6)) goto end;
    writer->putGLshort(writer, nx);
    writer->putGLshort(writer, ny);
    writer->putGLshort(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(124);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(125);
    captureFlags = ctx->captureFlags[125];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 125);
        glNormal3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 125);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 125, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(125);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2d(GLdouble x, GLdouble y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(126);
    captureFlags = ctx->captureFlags[126];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 126);
        glRasterPos2d(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 126);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 126, 16)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(126);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(127);
    captureFlags = ctx->captureFlags[127];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 127);
        glRasterPos2dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 127);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 127, 16)) goto end;
    writer->putGLdoublev(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(127);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2f(GLfloat x, GLfloat y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(128);
    captureFlags = ctx->captureFlags[128];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 128);
        glRasterPos2f(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 128);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 128, 8)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(128);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(129);
    captureFlags = ctx->captureFlags[129];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 129);
        glRasterPos2fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 129);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 129, 8)) goto end;
    writer->putGLfloatv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(129);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2i(GLint x, GLint y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(130);
    captureFlags = ctx->captureFlags[130];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 130);
        glRasterPos2i(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 130);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 130, 8)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(130);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(131);
    captureFlags = ctx->captureFlags[131];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 131);
        glRasterPos2iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 131);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 131, 8)) goto end;
    writer->putGLintv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(131);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2s(GLshort x, GLshort y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(132);
    captureFlags = ctx->captureFlags[132];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 132);
        glRasterPos2s(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 132);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 132, 4)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(132);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(133);
    captureFlags = ctx->captureFlags[133];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 133);
        glRasterPos2sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 133);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 133, 4)) goto end;
    writer->putGLshortv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(133);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(134);
    captureFlags = ctx->captureFlags[134];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 134);
        glRasterPos3d(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 134);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 134, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(134);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(135);
    captureFlags = ctx->captureFlags[135];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 135);
        glRasterPos3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 135);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 135, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(135);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(136);
    captureFlags = ctx->captureFlags[136];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 136);
        glRasterPos3f(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 136);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 136, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(136);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(137);
    captureFlags = ctx->captureFlags[137];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 137);
        glRasterPos3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 137);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 137, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(137);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3i(GLint x, GLint y, GLint z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(138);
    captureFlags = ctx->captureFlags[138];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 138);
        glRasterPos3i(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 138);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 138, 12)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(138);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(139);
    captureFlags = ctx->captureFlags[139];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 139);
        glRasterPos3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 139);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 139, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(139);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(140);
    captureFlags = ctx->captureFlags[140];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 140);
        glRasterPos3s(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 140);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 140, 6)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(140);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(141);
    captureFlags = ctx->captureFlags[141];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 141);
        glRasterPos3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 141);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 141, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(141);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(142);
    captureFlags = ctx->captureFlags[142];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 142);
        glRasterPos4d(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 142);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 142, 32)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->putGLdouble(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(142);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(143);
    captureFlags = ctx->captureFlags[143];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 143);
        glRasterPos4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 143);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 143, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(143);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(144);
    captureFlags = ctx->captureFlags[144];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 144);
        glRasterPos4f(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 144);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 144, 16)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->putGLfloat(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(144);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(145);
    captureFlags = ctx->captureFlags[145];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 145);
        glRasterPos4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 145);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 145, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(145);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(146);
    captureFlags = ctx->captureFlags[146];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 146);
        glRasterPos4i(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 146);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 146, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->putGLint(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(146);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(147);
    captureFlags = ctx->captureFlags[147];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 147);
        glRasterPos4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 147);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 147, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(147);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(148);
    captureFlags = ctx->captureFlags[148];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 148);
        glRasterPos4s(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 148);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 148, 8)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->putGLshort(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(148);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(149);
    captureFlags = ctx->captureFlags[149];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 149);
        glRasterPos4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 149);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 149, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(149);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(150);
    captureFlags = ctx->captureFlags[150];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 150);
        glRectd(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 150);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 150, 32)) goto end;
    writer->putGLdouble(writer, x1);
    writer->putGLdouble(writer, y1);
    writer->putGLdouble(writer, x2);
    writer->putGLdouble(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(150);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectdv(const GLdouble *v1, const GLdouble *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(151);
    captureFlags = ctx->captureFlags[151];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 151);
        glRectdv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 151);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 151, 32)) goto end;
    writer->putGLdoublev(writer, 2, v1);
    writer->putGLdoublev(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(151);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(152);
    captureFlags = ctx->captureFlags[152];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 152);
        glRectf(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 152);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 152, 16)) goto end;
    writer->putGLfloat(writer, x1);
    writer->putGLfloat(writer, y1);
    writer->putGLfloat(writer, x2);
    writer->putGLfloat(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(152);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectfv(const GLfloat *v1, const GLfloat *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(153);
    captureFlags = ctx->captureFlags[153];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 153);
        glRectfv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 153);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 153, 16)) goto end;
    writer->putGLfloatv(writer, 2, v1);
    writer->putGLfloatv(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(153);
    --ctx->captureEntryCount;
}

void __gls_capture_glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(154);
    captureFlags = ctx->captureFlags[154];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 154);
        glRecti(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 154);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 154, 16)) goto end;
    writer->putGLint(writer, x1);
    writer->putGLint(writer, y1);
    writer->putGLint(writer, x2);
    writer->putGLint(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(154);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectiv(const GLint *v1, const GLint *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(155);
    captureFlags = ctx->captureFlags[155];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 155);
        glRectiv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 155);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 155, 16)) goto end;
    writer->putGLintv(writer, 2, v1);
    writer->putGLintv(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(155);
    --ctx->captureEntryCount;
}

void __gls_capture_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(156);
    captureFlags = ctx->captureFlags[156];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 156);
        glRects(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 156);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 156, 8)) goto end;
    writer->putGLshort(writer, x1);
    writer->putGLshort(writer, y1);
    writer->putGLshort(writer, x2);
    writer->putGLshort(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(156);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectsv(const GLshort *v1, const GLshort *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(157);
    captureFlags = ctx->captureFlags[157];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 157);
        glRectsv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 157);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 157, 8)) goto end;
    writer->putGLshortv(writer, 2, v1);
    writer->putGLshortv(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(157);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1d(GLdouble s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(158);
    captureFlags = ctx->captureFlags[158];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 158);
        glTexCoord1d(s);
        __GLS_END_CAPTURE_EXEC(ctx, 158);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 158, 8)) goto end;
    writer->putGLdouble(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(158);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(159);
    captureFlags = ctx->captureFlags[159];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 159);
        glTexCoord1dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 159);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 159, 8)) goto end;
    writer->putGLdoublev(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(159);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1f(GLfloat s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(160);
    captureFlags = ctx->captureFlags[160];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 160);
        glTexCoord1f(s);
        __GLS_END_CAPTURE_EXEC(ctx, 160);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 160, 4)) goto end;
    writer->putGLfloat(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(160);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(161);
    captureFlags = ctx->captureFlags[161];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 161);
        glTexCoord1fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 161);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 161, 4)) goto end;
    writer->putGLfloatv(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(161);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1i(GLint s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(162);
    captureFlags = ctx->captureFlags[162];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 162);
        glTexCoord1i(s);
        __GLS_END_CAPTURE_EXEC(ctx, 162);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 162, 4)) goto end;
    writer->putGLint(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(162);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(163);
    captureFlags = ctx->captureFlags[163];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 163);
        glTexCoord1iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 163);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 163, 4)) goto end;
    writer->putGLintv(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(163);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1s(GLshort s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(164);
    captureFlags = ctx->captureFlags[164];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 164);
        glTexCoord1s(s);
        __GLS_END_CAPTURE_EXEC(ctx, 164);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 164, 2)) goto end;
    writer->putGLshort(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(164);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(165);
    captureFlags = ctx->captureFlags[165];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 165);
        glTexCoord1sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 165);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 165, 2)) goto end;
    writer->putGLshortv(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(165);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2d(GLdouble s, GLdouble t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(166);
    captureFlags = ctx->captureFlags[166];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 166);
        glTexCoord2d(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 166);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 166, 16)) goto end;
    writer->putGLdouble(writer, s);
    writer->putGLdouble(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(166);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(167);
    captureFlags = ctx->captureFlags[167];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 167);
        glTexCoord2dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 167);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 167, 16)) goto end;
    writer->putGLdoublev(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(167);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2f(GLfloat s, GLfloat t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(168);
    captureFlags = ctx->captureFlags[168];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 168);
        glTexCoord2f(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 168);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 168, 8)) goto end;
    writer->putGLfloat(writer, s);
    writer->putGLfloat(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(168);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(169);
    captureFlags = ctx->captureFlags[169];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 169);
        glTexCoord2fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 169);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 169, 8)) goto end;
    writer->putGLfloatv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(169);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2i(GLint s, GLint t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(170);
    captureFlags = ctx->captureFlags[170];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 170);
        glTexCoord2i(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 170);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 170, 8)) goto end;
    writer->putGLint(writer, s);
    writer->putGLint(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(170);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(171);
    captureFlags = ctx->captureFlags[171];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 171);
        glTexCoord2iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 171);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 171, 8)) goto end;
    writer->putGLintv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(171);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2s(GLshort s, GLshort t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(172);
    captureFlags = ctx->captureFlags[172];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 172);
        glTexCoord2s(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 172);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 172, 4)) goto end;
    writer->putGLshort(writer, s);
    writer->putGLshort(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(172);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(173);
    captureFlags = ctx->captureFlags[173];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 173);
        glTexCoord2sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 173);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 173, 4)) goto end;
    writer->putGLshortv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(173);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(174);
    captureFlags = ctx->captureFlags[174];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 174);
        glTexCoord3d(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 174);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 174, 24)) goto end;
    writer->putGLdouble(writer, s);
    writer->putGLdouble(writer, t);
    writer->putGLdouble(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(174);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(175);
    captureFlags = ctx->captureFlags[175];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 175);
        glTexCoord3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 175);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 175, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(175);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(176);
    captureFlags = ctx->captureFlags[176];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 176);
        glTexCoord3f(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 176);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 176, 12)) goto end;
    writer->putGLfloat(writer, s);
    writer->putGLfloat(writer, t);
    writer->putGLfloat(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(176);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(177);
    captureFlags = ctx->captureFlags[177];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 177);
        glTexCoord3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 177);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 177, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(177);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3i(GLint s, GLint t, GLint r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(178);
    captureFlags = ctx->captureFlags[178];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 178);
        glTexCoord3i(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 178);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 178, 12)) goto end;
    writer->putGLint(writer, s);
    writer->putGLint(writer, t);
    writer->putGLint(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(178);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(179);
    captureFlags = ctx->captureFlags[179];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 179);
        glTexCoord3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 179);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 179, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(179);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(180);
    captureFlags = ctx->captureFlags[180];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 180);
        glTexCoord3s(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 180);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 180, 6)) goto end;
    writer->putGLshort(writer, s);
    writer->putGLshort(writer, t);
    writer->putGLshort(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(180);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(181);
    captureFlags = ctx->captureFlags[181];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 181);
        glTexCoord3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 181);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 181, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(181);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(182);
    captureFlags = ctx->captureFlags[182];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 182);
        glTexCoord4d(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 182);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 182, 32)) goto end;
    writer->putGLdouble(writer, s);
    writer->putGLdouble(writer, t);
    writer->putGLdouble(writer, r);
    writer->putGLdouble(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(182);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(183);
    captureFlags = ctx->captureFlags[183];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 183);
        glTexCoord4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 183);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 183, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(183);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(184);
    captureFlags = ctx->captureFlags[184];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 184);
        glTexCoord4f(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 184);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 184, 16)) goto end;
    writer->putGLfloat(writer, s);
    writer->putGLfloat(writer, t);
    writer->putGLfloat(writer, r);
    writer->putGLfloat(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(184);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(185);
    captureFlags = ctx->captureFlags[185];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 185);
        glTexCoord4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 185);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 185, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(185);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(186);
    captureFlags = ctx->captureFlags[186];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 186);
        glTexCoord4i(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 186);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 186, 16)) goto end;
    writer->putGLint(writer, s);
    writer->putGLint(writer, t);
    writer->putGLint(writer, r);
    writer->putGLint(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(186);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(187);
    captureFlags = ctx->captureFlags[187];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 187);
        glTexCoord4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 187);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 187, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(187);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(188);
    captureFlags = ctx->captureFlags[188];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 188);
        glTexCoord4s(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 188);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 188, 8)) goto end;
    writer->putGLshort(writer, s);
    writer->putGLshort(writer, t);
    writer->putGLshort(writer, r);
    writer->putGLshort(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(188);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(189);
    captureFlags = ctx->captureFlags[189];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 189);
        glTexCoord4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 189);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 189, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(189);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2d(GLdouble x, GLdouble y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(190);
    captureFlags = ctx->captureFlags[190];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 190);
        glVertex2d(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 190);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 190, 16)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(190);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(191);
    captureFlags = ctx->captureFlags[191];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 191);
        glVertex2dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 191);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 191, 16)) goto end;
    writer->putGLdoublev(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(191);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2f(GLfloat x, GLfloat y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(192);
    captureFlags = ctx->captureFlags[192];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 192);
        glVertex2f(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 192);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 192, 8)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(192);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(193);
    captureFlags = ctx->captureFlags[193];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 193);
        glVertex2fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 193);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 193, 8)) goto end;
    writer->putGLfloatv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(193);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2i(GLint x, GLint y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(194);
    captureFlags = ctx->captureFlags[194];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 194);
        glVertex2i(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 194);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 194, 8)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(194);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(195);
    captureFlags = ctx->captureFlags[195];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 195);
        glVertex2iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 195);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 195, 8)) goto end;
    writer->putGLintv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(195);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2s(GLshort x, GLshort y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(196);
    captureFlags = ctx->captureFlags[196];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 196);
        glVertex2s(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 196);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 196, 4)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(196);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(197);
    captureFlags = ctx->captureFlags[197];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 197);
        glVertex2sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 197);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 197, 4)) goto end;
    writer->putGLshortv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(197);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(198);
    captureFlags = ctx->captureFlags[198];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 198);
        glVertex3d(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 198);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 198, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(198);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(199);
    captureFlags = ctx->captureFlags[199];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 199);
        glVertex3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 199);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 199, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(199);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(200);
    captureFlags = ctx->captureFlags[200];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 200);
        glVertex3f(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 200);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 200, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(200);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(201);
    captureFlags = ctx->captureFlags[201];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 201);
        glVertex3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 201);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 201, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(201);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3i(GLint x, GLint y, GLint z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(202);
    captureFlags = ctx->captureFlags[202];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 202);
        glVertex3i(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 202);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 202, 12)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(202);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(203);
    captureFlags = ctx->captureFlags[203];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 203);
        glVertex3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 203);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 203, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(203);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3s(GLshort x, GLshort y, GLshort z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(204);
    captureFlags = ctx->captureFlags[204];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 204);
        glVertex3s(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 204);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 204, 6)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(204);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(205);
    captureFlags = ctx->captureFlags[205];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 205);
        glVertex3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 205);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 205, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(205);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(206);
    captureFlags = ctx->captureFlags[206];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 206);
        glVertex4d(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 206);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 206, 32)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->putGLdouble(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(206);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(207);
    captureFlags = ctx->captureFlags[207];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 207);
        glVertex4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 207);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 207, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(207);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(208);
    captureFlags = ctx->captureFlags[208];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 208);
        glVertex4f(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 208);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 208, 16)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->putGLfloat(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(208);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(209);
    captureFlags = ctx->captureFlags[209];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 209);
        glVertex4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 209);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 209, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(209);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(210);
    captureFlags = ctx->captureFlags[210];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 210);
        glVertex4i(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 210);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 210, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->putGLint(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(210);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(211);
    captureFlags = ctx->captureFlags[211];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 211);
        glVertex4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 211);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 211, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(211);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(212);
    captureFlags = ctx->captureFlags[212];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 212);
        glVertex4s(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 212);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 212, 8)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->putGLshort(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(212);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(213);
    captureFlags = ctx->captureFlags[213];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 213);
        glVertex4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 213);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 213, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(213);
    --ctx->captureEntryCount;
}

void __gls_capture_glClipPlane(GLenum plane, const GLdouble *equation) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(214);
    captureFlags = ctx->captureFlags[214];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 214);
        glClipPlane(plane, equation);
        __GLS_END_CAPTURE_EXEC(ctx, 214);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 214, 36)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, plane);
        writer->putGLdoublev(writer, 4, equation);
    } else {
        writer->putGLdoublev(writer, 4, equation);
        writer->putGLenum(writer, plane);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(214);
    --ctx->captureEntryCount;
}

void __gls_capture_glColorMaterial(GLenum face, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(215);
    captureFlags = ctx->captureFlags[215];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 215);
        glColorMaterial(face, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 215);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 215, 8)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(215);
    --ctx->captureEntryCount;
}

void __gls_capture_glCullFace(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(216);
    captureFlags = ctx->captureFlags[216];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 216);
        glCullFace(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 216);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 216, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(216);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogf(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(217);
    captureFlags = ctx->captureFlags[217];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 217);
        glFogf(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 217);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 217, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(217);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogfv(GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(218);
    captureFlags = ctx->captureFlags[218];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 218);
        glFogfv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 218);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glFogfv_params_size(pname);
    if (!writer->beginCommand(writer, 218, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(218);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogi(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(219);
    captureFlags = ctx->captureFlags[219];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 219);
        glFogi(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 219);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 219, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(219);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogiv(GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(220);
    captureFlags = ctx->captureFlags[220];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 220);
        glFogiv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 220);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glFogiv_params_size(pname);
    if (!writer->beginCommand(writer, 220, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(220);
    --ctx->captureEntryCount;
}

void __gls_capture_glFrontFace(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(221);
    captureFlags = ctx->captureFlags[221];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 221);
        glFrontFace(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 221);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 221, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(221);
    --ctx->captureEntryCount;
}

void __gls_capture_glHint(GLenum target, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(222);
    captureFlags = ctx->captureFlags[222];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 222);
        glHint(target, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 222);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 222, 8)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(222);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightf(GLenum light, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(223);
    captureFlags = ctx->captureFlags[223];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 223);
        glLightf(light, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 223);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 223, 12)) goto end;
    writer->putGLenum(writer, light);
    writer->putGLenum(writer, pname);
    writer->putGLfloat(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(223);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightfv(GLenum light, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(224);
    captureFlags = ctx->captureFlags[224];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 224);
        glLightfv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 224);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightfv_params_size(pname);
    if (!writer->beginCommand(writer, 224, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, light);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(224);
    --ctx->captureEntryCount;
}

void __gls_capture_glLighti(GLenum light, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(225);
    captureFlags = ctx->captureFlags[225];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 225);
        glLighti(light, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 225);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 225, 12)) goto end;
    writer->putGLenum(writer, light);
    writer->putGLenum(writer, pname);
    writer->putGLint(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(225);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightiv(GLenum light, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(226);
    captureFlags = ctx->captureFlags[226];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 226);
        glLightiv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 226);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightiv_params_size(pname);
    if (!writer->beginCommand(writer, 226, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, light);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(226);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModelf(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(227);
    captureFlags = ctx->captureFlags[227];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 227);
        glLightModelf(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 227);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 227, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(227);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModelfv(GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(228);
    captureFlags = ctx->captureFlags[228];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 228);
        glLightModelfv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 228);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightModelfv_params_size(pname);
    if (!writer->beginCommand(writer, 228, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(228);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModeli(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(229);
    captureFlags = ctx->captureFlags[229];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 229);
        glLightModeli(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 229);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 229, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(229);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModeliv(GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(230);
    captureFlags = ctx->captureFlags[230];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 230);
        glLightModeliv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 230);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightModeliv_params_size(pname);
    if (!writer->beginCommand(writer, 230, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(230);
    --ctx->captureEntryCount;
}

void __gls_capture_glLineStipple(GLint factor, GLushort pattern) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(231);
    captureFlags = ctx->captureFlags[231];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 231);
        glLineStipple(factor, pattern);
        __GLS_END_CAPTURE_EXEC(ctx, 231);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 231, 8)) goto end;
    writer->putGLint(writer, factor);
    writer->putGLushorthex(writer, pattern);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(231);
    --ctx->captureEntryCount;
}

void __gls_capture_glLineWidth(GLfloat width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(232);
    captureFlags = ctx->captureFlags[232];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 232);
        glLineWidth(width);
        __GLS_END_CAPTURE_EXEC(ctx, 232);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 232, 4)) goto end;
    writer->putGLfloat(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(232);
    --ctx->captureEntryCount;
}

void __gls_capture_glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(233);
    captureFlags = ctx->captureFlags[233];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 233);
        glMaterialf(face, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 233);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 233, 12)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, pname);
    writer->putGLfloat(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(233);
    --ctx->captureEntryCount;
}

void __gls_capture_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(234);
    captureFlags = ctx->captureFlags[234];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 234);
        glMaterialfv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 234);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glMaterialfv_params_size(pname);
    if (!writer->beginCommand(writer, 234, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, face);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(234);
    --ctx->captureEntryCount;
}

void __gls_capture_glMateriali(GLenum face, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(235);
    captureFlags = ctx->captureFlags[235];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 235);
        glMateriali(face, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 235);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 235, 12)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, pname);
    writer->putGLint(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(235);
    --ctx->captureEntryCount;
}

void __gls_capture_glMaterialiv(GLenum face, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(236);
    captureFlags = ctx->captureFlags[236];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 236);
        glMaterialiv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 236);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glMaterialiv_params_size(pname);
    if (!writer->beginCommand(writer, 236, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, face);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(236);
    --ctx->captureEntryCount;
}

void __gls_capture_glPointSize(GLfloat size) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(237);
    captureFlags = ctx->captureFlags[237];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 237);
        glPointSize(size);
        __GLS_END_CAPTURE_EXEC(ctx, 237);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 237, 4)) goto end;
    writer->putGLfloat(writer, size);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(237);
    --ctx->captureEntryCount;
}

void __gls_capture_glPolygonMode(GLenum face, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(238);
    captureFlags = ctx->captureFlags[238];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 238);
        glPolygonMode(face, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 238);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 238, 8)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(238);
    --ctx->captureEntryCount;
}

void __gls_capture_glPolygonStipple(const GLubyte *mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint mask_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(239);
    captureFlags = ctx->captureFlags[239];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 239);
        glPolygonStipple(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 239);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    mask_count = __gls_glPolygonStipple_mask_size();
    if (!writer->beginCommand(writer, 239, 4 + mask_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    __glsWriter_putPixelv(writer, GL_COLOR_INDEX, GL_BITMAP, 32, 32, mask_count ? mask : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(239);
    --ctx->captureEntryCount;
}

void __gls_capture_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(240);
    captureFlags = ctx->captureFlags[240];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 240);
        glScissor(x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 240);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 240, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(240);
    --ctx->captureEntryCount;
}

void __gls_capture_glShadeModel(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(241);
    captureFlags = ctx->captureFlags[241];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 241);
        glShadeModel(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 241);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 241, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(241);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(242);
    captureFlags = ctx->captureFlags[242];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 242);
        glTexParameterf(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 242);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 242, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(242);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(243);
    captureFlags = ctx->captureFlags[243];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 243);
        glTexParameterfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 243);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexParameterfv_params_size(pname);
    if (!writer->beginCommand(writer, 243, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(243);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameteri(GLenum target, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(244);
    captureFlags = ctx->captureFlags[244];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 244);
        glTexParameteri(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 244);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 244, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(244);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(245);
    captureFlags = ctx->captureFlags[245];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 245);
        glTexParameteriv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 245);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexParameteriv_params_size(pname);
    if (!writer->beginCommand(writer, 245, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(245);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(246);
    captureFlags = ctx->captureFlags[246];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 246);
        glTexImage1D(target, level, components, width, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 246);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage1D_pixels_size(format, type, width) : 0;
    if (!writer->beginCommand(writer, 246, 32 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, width);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(246);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(247);
    captureFlags = ctx->captureFlags[247];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 247);
        glTexImage2D(target, level, components, width, height, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 247);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage2D_pixels_size(format, type, width, height) : 0;
    if (!writer->beginCommand(writer, 247, 36 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(247);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(248);
    captureFlags = ctx->captureFlags[248];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 248);
        glTexEnvf(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 248);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 248, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(248);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(249);
    captureFlags = ctx->captureFlags[249];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 249);
        glTexEnvfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 249);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexEnvfv_params_size(pname);
    if (!writer->beginCommand(writer, 249, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(249);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnvi(GLenum target, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(250);
    captureFlags = ctx->captureFlags[250];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 250);
        glTexEnvi(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 250);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 250, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(250);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnviv(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(251);
    captureFlags = ctx->captureFlags[251];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 251);
        glTexEnviv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 251);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexEnviv_params_size(pname);
    if (!writer->beginCommand(writer, 251, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(251);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(252);
    captureFlags = ctx->captureFlags[252];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 252);
        glTexGend(coord, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 252);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 252, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLdoubleOrGLenum(writer, pname, param);
    } else {
        writer->putGLdoubleOrGLenum(writer, pname, param);
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(252);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(253);
    captureFlags = ctx->captureFlags[253];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 253);
        glTexGendv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 253);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexGendv_params_size(pname);
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 253, 8 + params_count * 8)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLdoubleOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLdoubleOrGLenumv(writer, pname, params_count, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(253);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(254);
    captureFlags = ctx->captureFlags[254];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 254);
        glTexGenf(coord, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 254);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 254, 12)) goto end;
    writer->putGLenum(writer, coord);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(254);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(255);
    captureFlags = ctx->captureFlags[255];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 255);
        glTexGenfv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 255);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexGenfv_params_size(pname);
    if (!writer->beginCommand(writer, 255, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, coord);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(255);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGeni(GLenum coord, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(256);
    captureFlags = ctx->captureFlags[256];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 256);
        glTexGeni(coord, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 256);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 256, 12)) goto end;
    writer->putGLenum(writer, coord);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(256);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(257);
    captureFlags = ctx->captureFlags[257];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 257);
        glTexGeniv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 257);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexGeniv_params_size(pname);
    if (!writer->beginCommand(writer, 257, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, coord);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(257);
    --ctx->captureEntryCount;
}

void __gls_capture_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(258);
    captureFlags = ctx->captureFlags[258];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 258);
        glFeedbackBuffer(size, type, buffer);
        __GLS_END_CAPTURE_EXEC(ctx, 258);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 258, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, size);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, buffer);
    } else {
        writer->putGLint(writer, size);
        writer->putGLoutArg(writer, 0, buffer);
        writer->putGLenum(writer, type);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(258);
    --ctx->captureEntryCount;
}

void __gls_capture_glSelectBuffer(GLsizei size, GLuint *buffer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(259);
    captureFlags = ctx->captureFlags[259];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 259);
        glSelectBuffer(size, buffer);
        __GLS_END_CAPTURE_EXEC(ctx, 259);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 259, 12)) goto end;
    writer->putGLint(writer, size);
    writer->putGLoutArg(writer, 0, buffer);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(259);
    --ctx->captureEntryCount;
}

GLint __gls_capture_glRenderMode(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(260);
    captureFlags = ctx->captureFlags[260];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 260);
        _outVal = glRenderMode(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 260);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 260, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(260);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glInitNames(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(261);
    captureFlags = ctx->captureFlags[261];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 261);
        glInitNames();
        __GLS_END_CAPTURE_EXEC(ctx, 261);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 261, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(261);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadName(GLuint name) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(262);
    captureFlags = ctx->captureFlags[262];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 262);
        glLoadName(name);
        __GLS_END_CAPTURE_EXEC(ctx, 262);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 262, 4)) goto end;
    writer->putGLuint(writer, name);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(262);
    --ctx->captureEntryCount;
}

void __gls_capture_glPassThrough(GLfloat token) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(263);
    captureFlags = ctx->captureFlags[263];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 263);
        glPassThrough(token);
        __GLS_END_CAPTURE_EXEC(ctx, 263);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 263, 4)) goto end;
    writer->putGLfloat(writer, token);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(263);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopName(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(264);
    captureFlags = ctx->captureFlags[264];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 264);
        glPopName();
        __GLS_END_CAPTURE_EXEC(ctx, 264);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 264, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(264);
    --ctx->captureEntryCount;
}

void __gls_capture_glPushName(GLuint name) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(265);
    captureFlags = ctx->captureFlags[265];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 265);
        glPushName(name);
        __GLS_END_CAPTURE_EXEC(ctx, 265);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 265, 4)) goto end;
    writer->putGLuint(writer, name);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(265);
    --ctx->captureEntryCount;
}

void __gls_capture_glDrawBuffer(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(266);
    captureFlags = ctx->captureFlags[266];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 266);
        glDrawBuffer(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 266);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 266, 4)) goto end;
    writer->putGLdrawBufferMode(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(266);
    --ctx->captureEntryCount;
}

void __gls_capture_glClear(GLbitfield mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(267);
    captureFlags = ctx->captureFlags[267];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 267);
        glClear(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 267);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 267, 4)) goto end;
    writer->putGLclearBufferMask(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(267);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(268);
    captureFlags = ctx->captureFlags[268];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 268);
        glClearAccum(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 268);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 268, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(268);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearIndex(GLfloat c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(269);
    captureFlags = ctx->captureFlags[269];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 269);
        glClearIndex(c);
        __GLS_END_CAPTURE_EXEC(ctx, 269);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 269, 4)) goto end;
    writer->putGLfloat(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(269);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(270);
    captureFlags = ctx->captureFlags[270];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 270);
        glClearColor(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 270);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 270, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(270);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearStencil(GLint s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(271);
    captureFlags = ctx->captureFlags[271];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 271);
        glClearStencil(s);
        __GLS_END_CAPTURE_EXEC(ctx, 271);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 271, 4)) goto end;
    writer->putGLint(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(271);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearDepth(GLclampd depth) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(272);
    captureFlags = ctx->captureFlags[272];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 272);
        glClearDepth(depth);
        __GLS_END_CAPTURE_EXEC(ctx, 272);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 272, 8)) goto end;
    writer->putGLdouble(writer, depth);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(272);
    --ctx->captureEntryCount;
}

void __gls_capture_glStencilMask(GLuint mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(273);
    captureFlags = ctx->captureFlags[273];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 273);
        glStencilMask(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 273);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 273, 4)) goto end;
    writer->putGLuinthex(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(273);
    --ctx->captureEntryCount;
}

void __gls_capture_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(274);
    captureFlags = ctx->captureFlags[274];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 274);
        glColorMask(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 274);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 274, 4)) goto end;
    writer->putGLboolean(writer, red);
    writer->putGLboolean(writer, green);
    writer->putGLboolean(writer, blue);
    writer->putGLboolean(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(274);
    --ctx->captureEntryCount;
}

void __gls_capture_glDepthMask(GLboolean flag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(275);
    captureFlags = ctx->captureFlags[275];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 275);
        glDepthMask(flag);
        __GLS_END_CAPTURE_EXEC(ctx, 275);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 275, 1)) goto end;
    writer->putGLboolean(writer, flag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(275);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexMask(GLuint mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(276);
    captureFlags = ctx->captureFlags[276];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 276);
        glIndexMask(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 276);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 276, 4)) goto end;
    writer->putGLuinthex(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(276);
    --ctx->captureEntryCount;
}

void __gls_capture_glAccum(GLenum op, GLfloat value) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(277);
    captureFlags = ctx->captureFlags[277];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 277);
        glAccum(op, value);
        __GLS_END_CAPTURE_EXEC(ctx, 277);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 277, 8)) goto end;
    writer->putGLenum(writer, op);
    writer->putGLfloat(writer, value);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(277);
    --ctx->captureEntryCount;
}

void __gls_capture_glDisable(GLenum cap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(278);
    captureFlags = ctx->captureFlags[278];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 278);
        glDisable(cap);
        __GLS_END_CAPTURE_EXEC(ctx, 278);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 278, 4)) goto end;
    writer->putGLenum(writer, cap);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(278);
    --ctx->captureEntryCount;
}

void __gls_capture_glEnable(GLenum cap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(279);
    captureFlags = ctx->captureFlags[279];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 279);
        glEnable(cap);
        __GLS_END_CAPTURE_EXEC(ctx, 279);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 279, 4)) goto end;
    writer->putGLenum(writer, cap);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(279);
    --ctx->captureEntryCount;
}

void __gls_capture_glFinish(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(280);
    captureFlags = ctx->captureFlags[280];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 280);
        glFinish();
        __GLS_END_CAPTURE_EXEC(ctx, 280);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 280, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(280);
    --ctx->captureEntryCount;
}

void __gls_capture_glFlush(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(281);
    captureFlags = ctx->captureFlags[281];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 281);
        glFlush();
        __GLS_END_CAPTURE_EXEC(ctx, 281);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 281, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(281);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopAttrib(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(282);
    captureFlags = ctx->captureFlags[282];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 282);
        glPopAttrib();
        __GLS_END_CAPTURE_EXEC(ctx, 282);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 282, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(282);
    --ctx->captureEntryCount;
}

void __gls_capture_glPushAttrib(GLbitfield mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(283);
    captureFlags = ctx->captureFlags[283];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 283);
        glPushAttrib(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 283);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 283, 4)) goto end;
    writer->putGLattribMask(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(283);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(288);
    captureFlags = ctx->captureFlags[288];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 288);
        glMapGrid1d(un, u1, u2);
        __GLS_END_CAPTURE_EXEC(ctx, 288);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 288, 20)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, un);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
    } else {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, un);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(288);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(289);
    captureFlags = ctx->captureFlags[289];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 289);
        glMapGrid1f(un, u1, u2);
        __GLS_END_CAPTURE_EXEC(ctx, 289);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 289, 12)) goto end;
    writer->putGLint(writer, un);
    writer->putGLfloat(writer, u1);
    writer->putGLfloat(writer, u2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(289);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(290);
    captureFlags = ctx->captureFlags[290];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 290);
        glMapGrid2d(un, u1, u2, vn, v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 290);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 290, 40)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, un);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, vn);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
    } else {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
        writer->putGLint(writer, un);
        writer->putGLint(writer, vn);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(290);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(291);
    captureFlags = ctx->captureFlags[291];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 291);
        glMapGrid2f(un, u1, u2, vn, v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 291);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 291, 24)) goto end;
    writer->putGLint(writer, un);
    writer->putGLfloat(writer, u1);
    writer->putGLfloat(writer, u2);
    writer->putGLint(writer, vn);
    writer->putGLfloat(writer, v1);
    writer->putGLfloat(writer, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(291);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1d(GLdouble u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(292);
    captureFlags = ctx->captureFlags[292];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 292);
        glEvalCoord1d(u);
        __GLS_END_CAPTURE_EXEC(ctx, 292);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 292, 8)) goto end;
    writer->putGLdouble(writer, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(292);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1dv(const GLdouble *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(293);
    captureFlags = ctx->captureFlags[293];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 293);
        glEvalCoord1dv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 293);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 293, 8)) goto end;
    writer->putGLdoublev(writer, 1, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(293);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1f(GLfloat u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(294);
    captureFlags = ctx->captureFlags[294];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 294);
        glEvalCoord1f(u);
        __GLS_END_CAPTURE_EXEC(ctx, 294);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 294, 4)) goto end;
    writer->putGLfloat(writer, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(294);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1fv(const GLfloat *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(295);
    captureFlags = ctx->captureFlags[295];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 295);
        glEvalCoord1fv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 295);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 295, 4)) goto end;
    writer->putGLfloatv(writer, 1, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(295);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2d(GLdouble u, GLdouble v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(296);
    captureFlags = ctx->captureFlags[296];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 296);
        glEvalCoord2d(u, v);
        __GLS_END_CAPTURE_EXEC(ctx, 296);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 296, 16)) goto end;
    writer->putGLdouble(writer, u);
    writer->putGLdouble(writer, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(296);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2dv(const GLdouble *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(297);
    captureFlags = ctx->captureFlags[297];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 297);
        glEvalCoord2dv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 297);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 297, 16)) goto end;
    writer->putGLdoublev(writer, 2, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(297);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2f(GLfloat u, GLfloat v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(298);
    captureFlags = ctx->captureFlags[298];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 298);
        glEvalCoord2f(u, v);
        __GLS_END_CAPTURE_EXEC(ctx, 298);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 298, 8)) goto end;
    writer->putGLfloat(writer, u);
    writer->putGLfloat(writer, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(298);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2fv(const GLfloat *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(299);
    captureFlags = ctx->captureFlags[299];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 299);
        glEvalCoord2fv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 299);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 299, 8)) goto end;
    writer->putGLfloatv(writer, 2, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(299);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(300);
    captureFlags = ctx->captureFlags[300];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 300);
        glEvalMesh1(mode, i1, i2);
        __GLS_END_CAPTURE_EXEC(ctx, 300);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 300, 12)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, i1);
    writer->putGLint(writer, i2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(300);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalPoint1(GLint i) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(301);
    captureFlags = ctx->captureFlags[301];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 301);
        glEvalPoint1(i);
        __GLS_END_CAPTURE_EXEC(ctx, 301);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 301, 4)) goto end;
    writer->putGLint(writer, i);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(301);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(302);
    captureFlags = ctx->captureFlags[302];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 302);
        glEvalMesh2(mode, i1, i2, j1, j2);
        __GLS_END_CAPTURE_EXEC(ctx, 302);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 302, 20)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, i1);
    writer->putGLint(writer, i2);
    writer->putGLint(writer, j1);
    writer->putGLint(writer, j2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(302);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalPoint2(GLint i, GLint j) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(303);
    captureFlags = ctx->captureFlags[303];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 303);
        glEvalPoint2(i, j);
        __GLS_END_CAPTURE_EXEC(ctx, 303);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 303, 8)) goto end;
    writer->putGLint(writer, i);
    writer->putGLint(writer, j);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(303);
    --ctx->captureEntryCount;
}

void __gls_capture_glAlphaFunc(GLenum func, GLclampf ref) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(304);
    captureFlags = ctx->captureFlags[304];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 304);
        glAlphaFunc(func, ref);
        __GLS_END_CAPTURE_EXEC(ctx, 304);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 304, 8)) goto end;
    writer->putGLenum(writer, func);
    writer->putGLfloat(writer, ref);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(304);
    --ctx->captureEntryCount;
}

void __gls_capture_glBlendFunc(GLenum sfactor, GLenum dfactor) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(305);
    captureFlags = ctx->captureFlags[305];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 305);
        glBlendFunc(sfactor, dfactor);
        __GLS_END_CAPTURE_EXEC(ctx, 305);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 305, 8)) goto end;
    writer->putGLblendingFactor(writer, sfactor);
    writer->putGLblendingFactor(writer, dfactor);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(305);
    --ctx->captureEntryCount;
}

void __gls_capture_glLogicOp(GLenum opcode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(306);
    captureFlags = ctx->captureFlags[306];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 306);
        glLogicOp(opcode);
        __GLS_END_CAPTURE_EXEC(ctx, 306);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 306, 4)) goto end;
    writer->putGLenum(writer, opcode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(306);
    --ctx->captureEntryCount;
}

void __gls_capture_glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(307);
    captureFlags = ctx->captureFlags[307];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 307);
        glStencilFunc(func, ref, mask);
        __GLS_END_CAPTURE_EXEC(ctx, 307);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 307, 12)) goto end;
    writer->putGLenum(writer, func);
    writer->putGLint(writer, ref);
    writer->putGLuinthex(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(307);
    --ctx->captureEntryCount;
}

void __gls_capture_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(308);
    captureFlags = ctx->captureFlags[308];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 308);
        glStencilOp(fail, zfail, zpass);
        __GLS_END_CAPTURE_EXEC(ctx, 308);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 308, 12)) goto end;
    writer->putGLstencilOp(writer, fail);
    writer->putGLstencilOp(writer, zfail);
    writer->putGLstencilOp(writer, zpass);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(308);
    --ctx->captureEntryCount;
}

void __gls_capture_glDepthFunc(GLenum func) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(309);
    captureFlags = ctx->captureFlags[309];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 309);
        glDepthFunc(func);
        __GLS_END_CAPTURE_EXEC(ctx, 309);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 309, 4)) goto end;
    writer->putGLenum(writer, func);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(309);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(310);
    captureFlags = ctx->captureFlags[310];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 310);
        glPixelZoom(xfactor, yfactor);
        __GLS_END_CAPTURE_EXEC(ctx, 310);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 310, 8)) goto end;
    writer->putGLfloat(writer, xfactor);
    writer->putGLfloat(writer, yfactor);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(310);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelTransferf(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(311);
    captureFlags = ctx->captureFlags[311];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 311);
        glPixelTransferf(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 311);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 311, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(311);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelTransferi(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(312);
    captureFlags = ctx->captureFlags[312];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 312);
        glPixelTransferi(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 312);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 312, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(312);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelStoref(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(313);
    captureFlags = ctx->captureFlags[313];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 313);
        glPixelStoref(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 313);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 313, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(313);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelStorei(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(314);
    captureFlags = ctx->captureFlags[314];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 314);
        glPixelStorei(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 314);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 314, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(314);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(315);
    captureFlags = ctx->captureFlags[315];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 315);
        glPixelMapfv(map, mapsize, values);
        __GLS_END_CAPTURE_EXEC(ctx, 315);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 315, 8 + __GLS_MAX(mapsize, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, map);
        writer->putGLint(writer, mapsize);
        writer->putGLfloatv(writer, __GLS_MAX(mapsize, 0), values);
    } else {
        writer->putGLint(writer, mapsize);
        writer->putGLenum(writer, map);
        writer->putGLfloatv(writer, __GLS_MAX(mapsize, 0), values);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(315);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(316);
    captureFlags = ctx->captureFlags[316];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 316);
        glPixelMapuiv(map, mapsize, values);
        __GLS_END_CAPTURE_EXEC(ctx, 316);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 316, 8 + __GLS_MAX(mapsize, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, map);
        writer->putGLint(writer, mapsize);
        writer->putGLuintv(writer, __GLS_MAX(mapsize, 0), values);
    } else {
        writer->putGLint(writer, mapsize);
        writer->putGLenum(writer, map);
        writer->putGLuintv(writer, __GLS_MAX(mapsize, 0), values);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(316);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(317);
    captureFlags = ctx->captureFlags[317];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 317);
        glPixelMapusv(map, mapsize, values);
        __GLS_END_CAPTURE_EXEC(ctx, 317);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 317, 8 + __GLS_MAX(mapsize, 0) * 2)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, map);
        writer->putGLint(writer, mapsize);
        writer->putGLushortv(writer, __GLS_MAX(mapsize, 0), values);
    } else {
        writer->putGLint(writer, mapsize);
        writer->putGLenum(writer, map);
        writer->putGLushortv(writer, __GLS_MAX(mapsize, 0), values);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(317);
    --ctx->captureEntryCount;
}

void __gls_capture_glReadBuffer(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(318);
    captureFlags = ctx->captureFlags[318];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 318);
        glReadBuffer(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 318);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 318, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(318);
    --ctx->captureEntryCount;
}

void __gls_capture_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(319);
    captureFlags = ctx->captureFlags[319];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 319);
        glCopyPixels(x, y, width, height, type);
        __GLS_END_CAPTURE_EXEC(ctx, 319);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 319, 20)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLenum(writer, type);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(319);
    --ctx->captureEntryCount;
}

void __gls_capture_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(320);
    captureFlags = ctx->captureFlags[320];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 320);
        glReadPixels(x, y, width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 320);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 320, 32)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, x);
        writer->putGLint(writer, y);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, pixels);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, pixels);
        writer->putGLint(writer, x);
        writer->putGLint(writer, y);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(320);
    --ctx->captureEntryCount;
}

void __gls_capture_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(321);
    captureFlags = ctx->captureFlags[321];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 321);
        glDrawPixels(width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 321);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glDrawPixels_pixels_size(format, type, width, height);
    if (!writer->beginCommand(writer, 321, 20 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(321);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetBooleanv(GLenum pname, GLboolean *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(322);
    captureFlags = ctx->captureFlags[322];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 322);
        glGetBooleanv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 322);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 322, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(322);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetClipPlane(GLenum plane, GLdouble *equation) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(323);
    captureFlags = ctx->captureFlags[323];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 323);
        glGetClipPlane(plane, equation);
        __GLS_END_CAPTURE_EXEC(ctx, 323);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 323, 12)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, plane);
        writer->putGLoutArg(writer, 0, equation);
    } else {
        writer->putGLoutArg(writer, 0, equation);
        writer->putGLenum(writer, plane);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(323);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetDoublev(GLenum pname, GLdouble *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(324);
    captureFlags = ctx->captureFlags[324];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 324);
        glGetDoublev(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 324);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 324, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(324);
    --ctx->captureEntryCount;
}

GLenum __gls_capture_glGetError(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLenum _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(325);
    captureFlags = ctx->captureFlags[325];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 325);
        _outVal = glGetError();
        __GLS_END_CAPTURE_EXEC(ctx, 325);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 325, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(325);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glGetFloatv(GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(326);
    captureFlags = ctx->captureFlags[326];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 326);
        glGetFloatv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 326);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 326, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(326);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetIntegerv(GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(327);
    captureFlags = ctx->captureFlags[327];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 327);
        glGetIntegerv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 327);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 327, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(327);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(328);
    captureFlags = ctx->captureFlags[328];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 328);
        glGetLightfv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 328);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 328, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, light);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(328);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetLightiv(GLenum light, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(329);
    captureFlags = ctx->captureFlags[329];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 329);
        glGetLightiv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 329);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 329, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, light);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(329);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMapdv(GLenum target, GLenum query, GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(330);
    captureFlags = ctx->captureFlags[330];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 330);
        glGetMapdv(target, query, v);
        __GLS_END_CAPTURE_EXEC(ctx, 330);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 330, 16)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, query);
    writer->putGLoutArg(writer, 0, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(330);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMapfv(GLenum target, GLenum query, GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(331);
    captureFlags = ctx->captureFlags[331];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 331);
        glGetMapfv(target, query, v);
        __GLS_END_CAPTURE_EXEC(ctx, 331);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 331, 16)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, query);
    writer->putGLoutArg(writer, 0, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(331);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMapiv(GLenum target, GLenum query, GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(332);
    captureFlags = ctx->captureFlags[332];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 332);
        glGetMapiv(target, query, v);
        __GLS_END_CAPTURE_EXEC(ctx, 332);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 332, 16)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, query);
    writer->putGLoutArg(writer, 0, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(332);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(333);
    captureFlags = ctx->captureFlags[333];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 333);
        glGetMaterialfv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 333);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 333, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, face);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(333);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(334);
    captureFlags = ctx->captureFlags[334];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 334);
        glGetMaterialiv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 334);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 334, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, face);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(334);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPixelMapfv(GLenum map, GLfloat *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(335);
    captureFlags = ctx->captureFlags[335];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 335);
        glGetPixelMapfv(map, values);
        __GLS_END_CAPTURE_EXEC(ctx, 335);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 335, 12)) goto end;
    writer->putGLenum(writer, map);
    writer->putGLoutArg(writer, 0, values);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(335);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPixelMapuiv(GLenum map, GLuint *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(336);
    captureFlags = ctx->captureFlags[336];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 336);
        glGetPixelMapuiv(map, values);
        __GLS_END_CAPTURE_EXEC(ctx, 336);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 336, 12)) goto end;
    writer->putGLenum(writer, map);
    writer->putGLoutArg(writer, 0, values);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(336);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPixelMapusv(GLenum map, GLushort *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(337);
    captureFlags = ctx->captureFlags[337];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 337);
        glGetPixelMapusv(map, values);
        __GLS_END_CAPTURE_EXEC(ctx, 337);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 337, 12)) goto end;
    writer->putGLenum(writer, map);
    writer->putGLoutArg(writer, 0, values);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(337);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPolygonStipple(GLubyte *mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(338);
    captureFlags = ctx->captureFlags[338];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 338);
        glGetPolygonStipple(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 338);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 338, 8)) goto end;
    writer->putGLoutArg(writer, 0, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(338);
    --ctx->captureEntryCount;
}

const GLubyte * __gls_capture_glGetString(GLenum name) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    const GLubyte * _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(339);
    captureFlags = ctx->captureFlags[339];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 339);
        _outVal = glGetString(name);
        __GLS_END_CAPTURE_EXEC(ctx, 339);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 339, 4)) goto end;
    writer->putGLenum(writer, name);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(339);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(340);
    captureFlags = ctx->captureFlags[340];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 340);
        glGetTexEnvfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 340);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 340, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(340);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(341);
    captureFlags = ctx->captureFlags[341];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 341);
        glGetTexEnviv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 341);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 341, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(341);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(342);
    captureFlags = ctx->captureFlags[342];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 342);
        glGetTexGendv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 342);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 342, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(342);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(343);
    captureFlags = ctx->captureFlags[343];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 343);
        glGetTexGenfv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 343);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 343, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(343);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(344);
    captureFlags = ctx->captureFlags[344];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 344);
        glGetTexGeniv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 344);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 344, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(344);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(345);
    captureFlags = ctx->captureFlags[345];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 345);
        glGetTexImage(target, level, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 345);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 345, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, pixels);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(345);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(346);
    captureFlags = ctx->captureFlags[346];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 346);
        glGetTexParameterfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 346);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 346, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(346);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(347);
    captureFlags = ctx->captureFlags[347];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 347);
        glGetTexParameteriv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 347);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 347, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(347);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(348);
    captureFlags = ctx->captureFlags[348];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 348);
        glGetTexLevelParameterfv(target, level, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 348);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 348, 20)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(348);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(349);
    captureFlags = ctx->captureFlags[349];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 349);
        glGetTexLevelParameteriv(target, level, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 349);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 349, 20)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(349);
    --ctx->captureEntryCount;
}

GLboolean __gls_capture_glIsEnabled(GLenum cap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(350);
    captureFlags = ctx->captureFlags[350];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 350);
        _outVal = glIsEnabled(cap);
        __GLS_END_CAPTURE_EXEC(ctx, 350);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 350, 4)) goto end;
    writer->putGLenum(writer, cap);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(350);
    --ctx->captureEntryCount;
    return _outVal;
}

GLboolean __gls_capture_glIsList(GLuint list) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(351);
    captureFlags = ctx->captureFlags[351];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 351);
        _outVal = glIsList(list);
        __GLS_END_CAPTURE_EXEC(ctx, 351);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 351, 4)) goto end;
    writer->putGLuint(writer, list);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(351);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glDepthRange(GLclampd zNear, GLclampd zFar) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(352);
    captureFlags = ctx->captureFlags[352];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 352);
        glDepthRange(zNear, zFar);
        __GLS_END_CAPTURE_EXEC(ctx, 352);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 352, 16)) goto end;
    writer->putGLdouble(writer, zNear);
    writer->putGLdouble(writer, zFar);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(352);
    --ctx->captureEntryCount;
}

void __gls_capture_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(353);
    captureFlags = ctx->captureFlags[353];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 353);
        glFrustum(left, right, bottom, top, zNear, zFar);
        __GLS_END_CAPTURE_EXEC(ctx, 353);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 353, 48)) goto end;
    writer->putGLdouble(writer, left);
    writer->putGLdouble(writer, right);
    writer->putGLdouble(writer, bottom);
    writer->putGLdouble(writer, top);
    writer->putGLdouble(writer, zNear);
    writer->putGLdouble(writer, zFar);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(353);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadIdentity(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(354);
    captureFlags = ctx->captureFlags[354];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 354);
        glLoadIdentity();
        __GLS_END_CAPTURE_EXEC(ctx, 354);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 354, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(354);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadMatrixf(const GLfloat *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(355);
    captureFlags = ctx->captureFlags[355];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 355);
        glLoadMatrixf(m);
        __GLS_END_CAPTURE_EXEC(ctx, 355);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 355, 64)) goto end;
    writer->putGLfloatm(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(355);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadMatrixd(const GLdouble *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(356);
    captureFlags = ctx->captureFlags[356];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 356);
        glLoadMatrixd(m);
        __GLS_END_CAPTURE_EXEC(ctx, 356);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 356, 128)) goto end;
    writer->putGLdoublem(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(356);
    --ctx->captureEntryCount;
}

void __gls_capture_glMatrixMode(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(357);
    captureFlags = ctx->captureFlags[357];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 357);
        glMatrixMode(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 357);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 357, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(357);
    --ctx->captureEntryCount;
}

void __gls_capture_glMultMatrixf(const GLfloat *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(358);
    captureFlags = ctx->captureFlags[358];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 358);
        glMultMatrixf(m);
        __GLS_END_CAPTURE_EXEC(ctx, 358);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 358, 64)) goto end;
    writer->putGLfloatm(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(358);
    --ctx->captureEntryCount;
}

void __gls_capture_glMultMatrixd(const GLdouble *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(359);
    captureFlags = ctx->captureFlags[359];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 359);
        glMultMatrixd(m);
        __GLS_END_CAPTURE_EXEC(ctx, 359);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 359, 128)) goto end;
    writer->putGLdoublem(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(359);
    --ctx->captureEntryCount;
}

void __gls_capture_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(360);
    captureFlags = ctx->captureFlags[360];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 360);
        glOrtho(left, right, bottom, top, zNear, zFar);
        __GLS_END_CAPTURE_EXEC(ctx, 360);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 360, 48)) goto end;
    writer->putGLdouble(writer, left);
    writer->putGLdouble(writer, right);
    writer->putGLdouble(writer, bottom);
    writer->putGLdouble(writer, top);
    writer->putGLdouble(writer, zNear);
    writer->putGLdouble(writer, zFar);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(360);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopMatrix(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(361);
    captureFlags = ctx->captureFlags[361];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 361);
        glPopMatrix();
        __GLS_END_CAPTURE_EXEC(ctx, 361);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 361, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(361);
    --ctx->captureEntryCount;
}

void __gls_capture_glPushMatrix(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(362);
    captureFlags = ctx->captureFlags[362];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 362);
        glPushMatrix();
        __GLS_END_CAPTURE_EXEC(ctx, 362);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 362, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(362);
    --ctx->captureEntryCount;
}

void __gls_capture_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(363);
    captureFlags = ctx->captureFlags[363];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 363);
        glRotated(angle, x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 363);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 363, 32)) goto end;
    writer->putGLdouble(writer, angle);
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(363);
    --ctx->captureEntryCount;
}

void __gls_capture_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(364);
    captureFlags = ctx->captureFlags[364];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 364);
        glRotatef(angle, x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 364);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 364, 16)) goto end;
    writer->putGLfloat(writer, angle);
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(364);
    --ctx->captureEntryCount;
}

void __gls_capture_glScaled(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(365);
    captureFlags = ctx->captureFlags[365];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 365);
        glScaled(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 365);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 365, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(365);
    --ctx->captureEntryCount;
}

void __gls_capture_glScalef(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(366);
    captureFlags = ctx->captureFlags[366];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 366);
        glScalef(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 366);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 366, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(366);
    --ctx->captureEntryCount;
}

void __gls_capture_glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(367);
    captureFlags = ctx->captureFlags[367];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 367);
        glTranslated(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 367);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 367, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(367);
    --ctx->captureEntryCount;
}

void __gls_capture_glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(368);
    captureFlags = ctx->captureFlags[368];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 368);
        glTranslatef(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 368);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 368, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(368);
    --ctx->captureEntryCount;
}

void __gls_capture_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(369);
    captureFlags = ctx->captureFlags[369];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 369);
        glViewport(x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 369);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 369, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(369);
    --ctx->captureEntryCount;
}

#if __GL_EXT_blend_color
void __gls_capture_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65520);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65520);
        glBlendColorEXT(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 65520);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65520, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65520);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_capture_glBlendEquationEXT(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65521);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65521);
        glBlendEquationEXT(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 65521);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65521, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65521);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_capture_glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65522);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65522);
        glPolygonOffsetEXT(factor, bias);
        __GLS_END_CAPTURE_EXEC(ctx, 65522);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65522, 8)) goto end;
    writer->putGLfloat(writer, factor);
    writer->putGLfloat(writer, bias);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65522);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_polygon_offset */

void __gls_capture_glPolygonOffset(GLfloat factor, GLfloat units) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(383);
    captureFlags = ctx->captureFlags[383];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 383);
        glPolygonOffset(factor, units);
        __GLS_END_CAPTURE_EXEC(ctx, 383);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 383, 8)) goto end;
    writer->putGLfloat(writer, factor);
    writer->putGLfloat(writer, units);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(383);
    --ctx->captureEntryCount;
}

#if __GL_EXT_subtexture
void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
void __gls_capture_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65523);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65523);
        glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65523);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage1DEXT_pixels_size(format, type, width);
    if (!writer->beginCommand(writer, 65523, 28 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65523);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_subtexture */

void __gls_capture_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(396);
    captureFlags = ctx->captureFlags[396];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 396);
        glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 396);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage1D_pixels_size(format, type, width);
    if (!writer->beginCommand(writer, 396, 28 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(396);
    --ctx->captureEntryCount;
}

#if __GL_EXT_subtexture
void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
void __gls_capture_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65524);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65524);
        glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65524);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage2DEXT_pixels_size(format, type, width, height);
    if (!writer->beginCommand(writer, 65524, 36 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65524);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_subtexture */

void __gls_capture_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(397);
    captureFlags = ctx->captureFlags[397];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 397);
        glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 397);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage2D_pixels_size(format, type, width, height);
    if (!writer->beginCommand(writer, 397, 36 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(397);
    --ctx->captureEntryCount;
}

#if __GL_SGIS_multisample
void __gls_capture_glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65525);
    captureFlags = ctx->captureFlags[389];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65525);
        glSampleMaskSGIS(value, invert);
        __GLS_END_CAPTURE_EXEC(ctx, 65525);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65525, 5)) goto end;
    writer->putGLfloat(writer, value);
    writer->putGLboolean(writer, invert);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65525);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_capture_glSamplePatternSGIS(GLenum pattern) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65526);
    captureFlags = ctx->captureFlags[390];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65526);
        glSamplePatternSGIS(pattern);
        __GLS_END_CAPTURE_EXEC(ctx, 65526);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65526, 4)) goto end;
    writer->putGLenum(writer, pattern);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65526);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIX_multisample
void __gls_capture_glTagSampleBufferSGIX(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65527);
    captureFlags = ctx->captureFlags[391];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65527);
        glTagSampleBufferSGIX();
        __GLS_END_CAPTURE_EXEC(ctx, 65527);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65527, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65527);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIX_multisample */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint image_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65528);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65528);
        glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
        __GLS_END_CAPTURE_EXEC(ctx, 65528);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    image_count = __gls_glConvolutionFilter1DEXT_image_size(format, type, width);
    if (!writer->beginCommand(writer, 65528, 24 + image_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, image_count ? image : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, 1, image_count ? image : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65528);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint image_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65529);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65529);
        glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
        __GLS_END_CAPTURE_EXEC(ctx, 65529);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    image_count = __gls_glConvolutionFilter2DEXT_image_size(format, type, width, height);
    if (!writer->beginCommand(writer, 65529, 28 + image_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, image_count ? image : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, height, image_count ? image : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65529);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65530);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65530);
        glConvolutionParameterfEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65530);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65530, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65530);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65531);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65531);
        glConvolutionParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65531);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glConvolutionParameterfvEXT_params_size(pname);
    if (!writer->beginCommand(writer, 65531, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65531);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65532);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65532);
        glConvolutionParameteriEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65532);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65532, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65532);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65533);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65533);
        glConvolutionParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65533);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glConvolutionParameterivEXT_params_size(pname);
    if (!writer->beginCommand(writer, 65533, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65533);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65534);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65534);
        glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 65534);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65534, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65534);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65535);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65535);
        glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 65535);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65535, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65535);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65504);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65504);
        glGetConvolutionFilterEXT(target, format, type, image);
        __GLS_END_CAPTURE_EXEC(ctx, 65504);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65504, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, image);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65504);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65505);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65505);
        glGetConvolutionParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65505);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65505, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65505);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65506);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65506);
        glGetConvolutionParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65506);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65506, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65506);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65507);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65507);
        glGetSeparableFilterEXT(target, format, type, row, column, span);
        __GLS_END_CAPTURE_EXEC(ctx, 65507);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65507, 36)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, row);
    writer->putGLoutArg(writer, 0, column);
    writer->putGLoutArg(writer, 0, span);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65507);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint row_count;
    GLint column_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65508);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65508);
        glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
        __GLS_END_CAPTURE_EXEC(ctx, 65508);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    column_count = __gls_glSeparableFilter2DEXT_column_size(target, format, type, height);
    if (!writer->beginCommand(writer, 65508, 28 + row_count * 1 + column_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, row_count ? row : GLS_NONE);
        __glsWriter_putPixelv(writer, format, type, height, 1, column_count ? column : GLS_NONE);
    } else {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, 1, row_count ? row : GLS_NONE);
        __glsWriter_putPixelv(writer, format, type, height, 1, column_count ? column : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65508);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_capture_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65509);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65509);
        glGetHistogramEXT(target, reset, format, type, values);
        __GLS_END_CAPTURE_EXEC(ctx, 65509);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65509, 21)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLboolean(writer, reset);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
    } else {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
        writer->putGLboolean(writer, reset);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65509);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65510);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65510);
        glGetHistogramParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65510);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65510, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65510);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65511);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65511);
        glGetHistogramParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65511);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65511, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65511);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65512);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65512);
        glGetMinmaxEXT(target, reset, format, type, values);
        __GLS_END_CAPTURE_EXEC(ctx, 65512);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65512, 21)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLboolean(writer, reset);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
    } else {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
        writer->putGLboolean(writer, reset);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65512);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65513);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65513);
        glGetMinmaxParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65513);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65513, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65513);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65514);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65514);
        glGetMinmaxParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65514);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65514, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65514);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65515);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65515);
        glHistogramEXT(target, width, internalformat, sink);
        __GLS_END_CAPTURE_EXEC(ctx, 65515);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65515, 13)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, width);
    writer->putGLenum(writer, internalformat);
    writer->putGLboolean(writer, sink);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65515);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65516);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65516);
        glMinmaxEXT(target, internalformat, sink);
        __GLS_END_CAPTURE_EXEC(ctx, 65516);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65516, 9)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLboolean(writer, sink);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65516);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glResetHistogramEXT(GLenum target) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65517);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65517);
        glResetHistogramEXT(target);
        __GLS_END_CAPTURE_EXEC(ctx, 65517);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65517, 4)) goto end;
    writer->putGLenum(writer, target);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65517);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glResetMinmaxEXT(GLenum target) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65518);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65518);
        glResetMinmaxEXT(target);
        __GLS_END_CAPTURE_EXEC(ctx, 65518);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65518, 4)) goto end;
    writer->putGLenum(writer, target);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65518);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_capture_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65519);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65519);
        glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65519);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage3DEXT_pixels_size(format, type, width, height, depth) : 0;
    if (!writer->beginCommand(writer, 65519, 40 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65519);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture && __GL_EXT_texture3D
void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
void __gls_capture_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65488);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65488);
        glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65488);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage3DEXT_pixels_size(format, type, width, height, depth);
    if (!writer->beginCommand(writer, 65488, 44 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65488);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_capture_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65489);
    captureFlags = ctx->captureFlags[417];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65489);
        glDetailTexFuncSGIS(target, n, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65489);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65489, 8 + __GLS_MAX(n*2, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, n);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    } else {
        writer->putGLint(writer, n);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65489);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_capture_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65490);
    captureFlags = ctx->captureFlags[418];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65490);
        glGetDetailTexFuncSGIS(target, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65490);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65490, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLoutArg(writer, 0, points);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65490);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_capture_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65491);
    captureFlags = ctx->captureFlags[419];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65491);
        glSharpenTexFuncSGIS(target, n, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65491);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65491, 8 + __GLS_MAX(n*2, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, n);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    } else {
        writer->putGLint(writer, n);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65491);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_capture_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65492);
    captureFlags = ctx->captureFlags[420];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65492);
        glGetSharpenTexFuncSGIS(target, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65492);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65492, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLoutArg(writer, 0, points);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65492);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void glArrayElementEXT(GLint i);
void __gls_capture_glArrayElementEXT(GLint i) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65493);
    captureFlags = ctx->captureFlags[437];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65493);
        glArrayElementEXT(i);
        __GLS_END_CAPTURE_EXEC(ctx, 65493);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65493, 4)) goto end;
    writer->putGLint(writer, i);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65493);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glArrayElement(GLint i) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint size;
    __GLSarrayState arrayState;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(370);
    captureFlags = ctx->captureFlags[370];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 370);
        glArrayElement(i);
        __GLS_END_CAPTURE_EXEC(ctx, 370);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    __glsGetArrayState(ctx, &arrayState);
    size = __glsArrayDataSize(1, &arrayState);
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 370, size)) goto end;
    __glsWriteArrayData(writer, size, i, 1, GL_NONE, NULL, &arrayState);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(370);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65494);
    captureFlags = ctx->captureFlags[438];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65494);
        glColorPointerEXT(size, type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65494);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    if (!writer->beginCommand(writer, 65494, 16 + pointer_count * 1)) goto end;
    writer->putGLint(writer, size);
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, size, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65494);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(372);
    captureFlags = ctx->captureFlags[372];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 372);
        glColorPointer(size, type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 372);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(372);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
void __gls_capture_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65495);
    captureFlags = ctx->captureFlags[439];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65495);
        glDrawArraysEXT(mode, first, count);
        __GLS_END_CAPTURE_EXEC(ctx, 65495);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65495, 12)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, first);
    writer->putGLint(writer, count);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65495);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint size;
    __GLSarrayState arrayState;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(374);
    captureFlags = ctx->captureFlags[374];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 374);
        glDrawArrays(mode, first, count);
        __GLS_END_CAPTURE_EXEC(ctx, 374);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    __glsGetArrayState(ctx, &arrayState);
    size = __glsArrayDataSize(count, &arrayState);
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 374, size+4)) goto end;
    writer->putGLenum(writer, mode);
    __glsWriteArrayData(writer, size, first, count, GL_NONE, NULL, &arrayState);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(374);
    --ctx->captureEntryCount;
}

void __gls_capture_glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint size;
    __GLSarrayState arrayState;
    __GLSdrawElementsState deState;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(375);
    captureFlags = ctx->captureFlags[375];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 375);
        glDrawElements(mode, count, type, indices);
        __GLS_END_CAPTURE_EXEC(ctx, 375);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    __glsGetArrayState(ctx, &arrayState);
    size = __glsDrawElementsDataSize(count, type, indices, &arrayState,
                                     &deState);
    if (size < 0)
    {
        goto end;
    }
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 375, size+8)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, count);
    __glsWriteDrawElementsData(writer, size, count, &arrayState, &deState);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(375);
    --ctx->captureEntryCount;
}

#if __GL_WIN_draw_range_elements
void __gls_capture_glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) {
    // XXX : For best performance, flesh out this function instead of calling
    // DrawElements.
    __gls_capture_glDrawElements(mode, count, type, indices);
}
#endif

void __gls_capture_glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(381);
    captureFlags = ctx->captureFlags[381];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 381);
        glInterleavedArrays(format, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 381);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(381);
    --ctx->captureEntryCount;
}

void __gls_capture_glEnableClientState(GLenum array) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(377);
    captureFlags = ctx->captureFlags[377];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 377);
        glEnableClientState(array);
        __GLS_END_CAPTURE_EXEC(ctx, 377);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 377, 4)) goto end;
    writer->putGLenum(writer, array);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(377);
    --ctx->captureEntryCount;
}

void __gls_capture_glDisableClientState(GLenum array) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(373);
    captureFlags = ctx->captureFlags[373];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 373);
        glDisableClientState(array);
        __GLS_END_CAPTURE_EXEC(ctx, 373);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 373, 4)) goto end;
    writer->putGLenum(writer, array);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(373);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
void __gls_capture_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65496);
    captureFlags = ctx->captureFlags[440];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65496);
        glEdgeFlagPointerEXT(stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65496);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glEdgeFlagPointerEXT_pointer_size(stride, count);
    if (!writer->beginCommand(writer, 65496, 8 + pointer_count * 1)) goto end;
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, 1, __GLS_BOOLEAN, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65496);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(376);
    captureFlags = ctx->captureFlags[376];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 376);
        glEdgeFlagPointer(stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 376);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(376);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glGetPointervEXT(GLenum pname, GLvoid* *params);
void __gls_capture_glGetPointervEXT(GLenum pname, GLvoid* *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65497);
    captureFlags = ctx->captureFlags[441];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65497);
        glGetPointervEXT(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65497);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 65497, 12)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, pname);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65497);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glGetPointerv(GLenum pname, GLvoid* *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(393);
    captureFlags = ctx->captureFlags[393];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 393);
        glGetPointerv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 393);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 393, 12)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, pname);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(393);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65498);
    captureFlags = ctx->captureFlags[442];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65498);
        glIndexPointerEXT(type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65498);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    if (!writer->beginCommand(writer, 65498, 12 + pointer_count * 1)) goto end;
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, 1, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65498);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(378);
    captureFlags = ctx->captureFlags[378];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 378);
        glIndexPointer(type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 378);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(378);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65499);
    captureFlags = ctx->captureFlags[443];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65499);
        glNormalPointerEXT(type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65499);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    if (!writer->beginCommand(writer, 65499, 12 + pointer_count * 1)) goto end;
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, 3, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65499);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(382);
    captureFlags = ctx->captureFlags[382];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 382);
        glNormalPointer(type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 382);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(382);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65500);
    captureFlags = ctx->captureFlags[444];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65500);
        glTexCoordPointerEXT(size, type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65500);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    if (!writer->beginCommand(writer, 65500, 16 + pointer_count * 1)) goto end;
    writer->putGLint(writer, size);
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, size, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65500);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(384);
    captureFlags = ctx->captureFlags[384];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 384);
        glTexCoordPointer(size, type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 384);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(384);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65501);
    captureFlags = ctx->captureFlags[445];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65501);
        glVertexPointerEXT(size, type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65501);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    if (!writer->beginCommand(writer, 65501, 16 + pointer_count * 1)) goto end;
    writer->putGLint(writer, size);
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, size, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65501);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(385);
    captureFlags = ctx->captureFlags[385];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 385);
        glVertexPointer(size, type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 385);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(385);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
GLboolean __gls_capture_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65502);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65502);
        _outVal = glAreTexturesResidentEXT(n, textures, residences);
        __GLS_END_CAPTURE_EXEC(ctx, 65502);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65502, 12 + __GLS_MAX(n, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, n);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
        writer->putGLoutArg(writer, 0, residences);
    } else {
        writer->putGLint(writer, n);
        writer->putGLoutArg(writer, 0, residences);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65502);
    --ctx->captureEntryCount;
    return _outVal;
}
#endif /* __GL_EXT_texture_object */

GLboolean __gls_capture_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(386);
    captureFlags = ctx->captureFlags[386];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 386);
        _outVal = glAreTexturesResident(n, textures, residences);
        __GLS_END_CAPTURE_EXEC(ctx, 386);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 386, 12 + __GLS_MAX(n, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, n);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
        writer->putGLoutArg(writer, 0, residences);
    } else {
        writer->putGLint(writer, n);
        writer->putGLoutArg(writer, 0, residences);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(386);
    --ctx->captureEntryCount;
    return _outVal;
}

#if __GL_EXT_texture_object
void glBindTextureEXT(GLenum target, GLuint texture);
void __gls_capture_glBindTextureEXT(GLenum target, GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65503);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65503);
        glBindTextureEXT(target, texture);
        __GLS_END_CAPTURE_EXEC(ctx, 65503);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65503, 8)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65503);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glBindTexture(GLenum target, GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(371);
    captureFlags = ctx->captureFlags[371];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 371);
        glBindTexture(target, texture);
        __GLS_END_CAPTURE_EXEC(ctx, 371);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 371, 8)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(371);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
void glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
void __gls_capture_glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65472);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65472);
        glDeleteTexturesEXT(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 65472);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65472, 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65472);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glDeleteTextures(GLsizei n, const GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(391);
    captureFlags = ctx->captureFlags[391];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 391);
        glDeleteTextures(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 391);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 391, 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(391);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
void glGenTexturesEXT(GLsizei n, GLuint *textures);
void __gls_capture_glGenTexturesEXT(GLsizei n, GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65473);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65473);
        glGenTexturesEXT(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 65473);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65473, 12)) goto end;
    writer->putGLint(writer, n);
    writer->putGLoutArg(writer, 0, textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65473);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glGenTextures(GLsizei n, GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(392);
    captureFlags = ctx->captureFlags[392];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 392);
        glGenTextures(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 392);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 392, 12)) goto end;
    writer->putGLint(writer, n);
    writer->putGLoutArg(writer, 0, textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(392);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
GLboolean glIsTextureEXT(GLuint texture);
GLboolean __gls_capture_glIsTextureEXT(GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65474);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65474);
        _outVal = glIsTextureEXT(texture);
        __GLS_END_CAPTURE_EXEC(ctx, 65474);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65474, 4)) goto end;
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65474);
    --ctx->captureEntryCount;
    return _outVal;
}
#endif /* __GL_EXT_texture_object */

GLboolean __gls_capture_glIsTexture(GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(394);
    captureFlags = ctx->captureFlags[394];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 394);
        _outVal = glIsTexture(texture);
        __GLS_END_CAPTURE_EXEC(ctx, 394);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 394, 4)) goto end;
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(394);
    --ctx->captureEntryCount;
    return _outVal;
}

#if __GL_EXT_texture_object
void glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);
void __gls_capture_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65475);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65475);
        glPrioritizeTexturesEXT(n, textures, priorities);
        __GLS_END_CAPTURE_EXEC(ctx, 65475);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65475, 4 + __GLS_MAX(n, 0) * 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->putGLfloatv(writer, __GLS_MAX(n, 0), priorities);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65475);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(395);
    captureFlags = ctx->captureFlags[395];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 395);
        glPrioritizeTextures(n, textures, priorities);
        __GLS_END_CAPTURE_EXEC(ctx, 395);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 395, 4 + __GLS_MAX(n, 0) * 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->putGLfloatv(writer, __GLS_MAX(n, 0), priorities);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(395);
    --ctx->captureEntryCount;
}

#if __GL_EXT_paletted_texture
void glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
void __gls_capture_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint table_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65476);
    captureFlags = ctx->captureFlags[452];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65476);
        glColorTableEXT(target, internalformat, width, format, type, table);
        __GLS_END_CAPTURE_EXEC(ctx, 65476);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    table_count = __gls_glColorTableEXT_table_size(format, type, width);
    if (!writer->beginCommand(writer, 65476, 24 + table_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, table_count ? table : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, 1, table_count ? table : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65476);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_capture_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65477);
    captureFlags = ctx->captureFlags[437];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65477);
        glColorTableParameterfvSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65477);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glColorTableParameterfvSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65477, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65477);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_capture_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65478);
    captureFlags = ctx->captureFlags[438];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65478);
        glColorTableParameterivSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65478);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glColorTableParameterivSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65478, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65478);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_capture_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65479);
    captureFlags = ctx->captureFlags[439];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65479);
        glCopyColorTableSGI(target, internalformat, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 65479);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65479, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65479);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table);
void __gls_capture_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65480);
    captureFlags = ctx->captureFlags[456];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65480);
        glGetColorTableEXT(target, format, type, table);
        __GLS_END_CAPTURE_EXEC(ctx, 65480);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65480, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, table);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65480);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
void __gls_capture_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65481);
    captureFlags = ctx->captureFlags[457];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65481);
        glGetColorTableParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65481);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65481, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65481);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);
void __gls_capture_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65482);
    captureFlags = ctx->captureFlags[458];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65482);
        glGetColorTableParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65482);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65482, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65482);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_capture_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65483);
    captureFlags = ctx->captureFlags[443];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65483);
        glGetTexColorTableParameterfvSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65483);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65483, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65483);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_capture_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65484);
    captureFlags = ctx->captureFlags[444];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65484);
        glGetTexColorTableParameterivSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65484);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65484, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65484);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_capture_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65485);
    captureFlags = ctx->captureFlags[445];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65485);
        glTexColorTableParameterfvSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65485);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexColorTableParameterfvSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65485, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65485);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_capture_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65486);
    captureFlags = ctx->captureFlags[446];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65486);
        glTexColorTableParameterivSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65486);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexColorTableParameterivSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65486, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65486);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
void __gls_capture_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65487);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65487);
        glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
        __GLS_END_CAPTURE_EXEC(ctx, 65487);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65487, 28)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65487);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(387);
    captureFlags = ctx->captureFlags[387];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 387);
        glCopyTexImage1D(target, level, internalformat, x, y, width, border);
        __GLS_END_CAPTURE_EXEC(ctx, 387);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 387, 28)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(387);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture
void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
void __gls_capture_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65456);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65456);
        glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
        __GLS_END_CAPTURE_EXEC(ctx, 65456);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65456, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65456);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(388);
    captureFlags = ctx->captureFlags[388];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 388);
        glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
        __GLS_END_CAPTURE_EXEC(ctx, 388);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 388, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(388);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture
void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
void __gls_capture_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65457);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65457);
        glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 65457);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65457, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65457);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(389);
    captureFlags = ctx->captureFlags[389];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 389);
        glCopyTexSubImage1D(target, level, xoffset, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 389);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 389, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(389);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture
void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
void __gls_capture_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65458);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65458);
        glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 65458);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65458, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, yoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65458);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(390);
    captureFlags = ctx->captureFlags[390];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 390);
        glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 390);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 390, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, yoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(390);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture && __GL_EXT_texture3D
void __gls_capture_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65459);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65459);
        glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 65459);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65459, 36)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, yoffset);
    writer->putGLint(writer, zoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65459);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_capture_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65460);
    captureFlags = ctx->captureFlags[452];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65460);
        glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65460);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage4DSGIS_pixels_size(format, type, width, height, depth, size4d) : 0;
    if (!writer->beginCommand(writer, 65460, 44 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65460);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_capture_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65461);
    captureFlags = ctx->captureFlags[453];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65461);
        glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65461);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    if (!writer->beginCommand(writer, 65461, 52 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        writer->putGLint(writer, woffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        writer->putGLint(writer, woffset);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65461);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_capture_glPixelTexGenSGIX(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65462);
    captureFlags = ctx->captureFlags[454];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65462);
        glPixelTexGenSGIX(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 65462);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65462, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65462);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIX_pixel_texture */

#if __GL_EXT_paletted_texture
extern void glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void __gls_capture_glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint entries_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65424);
    captureFlags = ctx->captureFlags[496];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65424);
        glColorSubTableEXT(target, start, count, format, type, data);
        __GLS_END_CAPTURE_EXEC(ctx, 65424);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    entries_count = data ? __gls_glColorSubTableEXT_entries_size(format, type, count) : 0;
    if (!writer->beginCommand(writer, 65424, 24 + entries_count * 1)) goto end;
    writer->putGLSimageFlags(writer, data ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    writer->putGLenum(writer, target);
    writer->putGLuint(writer, start);
    writer->putGLint(writer, count);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    __glsWriter_putPixelv(writer, format, type, count, 1, entries_count ? data : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65424);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

void __gls_capture_glPushClientAttrib(GLbitfield mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(398);
    captureFlags = ctx->captureFlags[398];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 398);
        glPushClientAttrib(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 398);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 398, 4)) goto end;
    // Consider - Breaks enum representation, should have
    // clientAttribMask
    writer->putGLuint(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(398);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopClientAttrib(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(399);
    captureFlags = ctx->captureFlags[399];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 399);
        glPopClientAttrib();
        __GLS_END_CAPTURE_EXEC(ctx, 399);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 399, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(399);
    --ctx->captureEntryCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\global.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <string.h>
#include <time.h>

static GLuint __glsContextCount = 0;
static GLuint __glsNextContext = 1;

typedef struct {
    GLuint mask1;
    GLuint val1;
    GLuint shift;
    GLuint mask4;
    GLuint val4;
} __GLSutf8format;

static const __GLSutf8format __glsUTF8formats[] = {
    {0x80, 0x00, 0,  0x0000007f, 0x00000000,},
    {0xe0, 0xc0, 6,  0x000007ff, 0x00000080,},
    {0xf0, 0xe0, 12, 0x0000ffff, 0x00000800,},
    {0xf8, 0xf0, 18, 0x001fffff, 0x00010000,},
    {0xfc, 0xf8, 24, 0x03ffffff, 0x00200000,},
    {0xfe, 0xfc, 30, 0x7fffffff, 0x04000000,},
    {0x00, 0x00, 0,  0x00000000, 0x00000000,},
};

GLSenum glsBinary(GLboolean inSwapped) {
    return inSwapped ? __GLS_BINARY_SWAP1 : __GLS_BINARY_SWAP0;
}

GLSenum glsCommandAPI(GLSopcode inOpcode) {
    const GLSenum outVal = __glsOpcodeAPI(inOpcode);

    if (!outVal) __GLS_RAISE_ERROR(GLS_UNSUPPORTED_COMMAND);
    return outVal;
}

const GLubyte* glsCommandString(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return __glsOpcodeString[__glsMapOpcode(inOpcode)];
}

void glsContext(GLuint inContext) {
    __GLScontext *ctx = __GLS_CONTEXT;
    __GLScontext *newCtx;

    if (ctx && (ctx->callNesting || ctx->captureEntryCount)) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (inContext) {
        __glsBeginCriticalSection();
        if (
            newCtx = (__GLScontext *)__glsInt2PtrDict_find(
                    __glsContextDict, (GLint)inContext
            )
        ) {
            if (newCtx == ctx) {
                newCtx = GLS_NONE;
            } else {
                if (newCtx->current) {
                    __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                    newCtx = GLS_NONE;
                } else {
                    newCtx->current = GL_TRUE;
                    if (ctx)
                    {
                        if (ctx->deleted)
                        {
                            __glsContext_destroy(ctx);
                        }
                        else
                        {
                            ctx->current = GL_FALSE;
                        }
                    }
                }
            }
        } else {
            __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        }
        __glsEndCriticalSection();
        if (newCtx) {
            __GLS_PUT_CONTEXT(newCtx);
            __glsUpdateDispatchTables();
        }
    } else if (ctx) {
        __glsBeginCriticalSection();
        if (ctx->deleted) {
            __glsContext_destroy(ctx);
        } else {
            ctx->current = GL_FALSE;
        }
        __glsEndCriticalSection();
        __GLS_PUT_CONTEXT(GLS_NONE);
        __glsUpdateDispatchTables();
    }
}

void glsDeleteContext(GLuint inContext) {
    if (inContext) {
        __GLScontext *ctx;

        __glsBeginCriticalSection();
        if (
            ctx = (__GLScontext *)__glsInt2PtrDict_find(
                __glsContextDict, (GLint)inContext
            )
        ) {
            __glsIntDict_remove(__glsContextDict, (GLint)inContext);
            __GLS_LIST_REMOVE(&__glsContextList, ctx);
            --__glsContextCount;
            if (ctx->current) {
                ctx->deleted = GL_TRUE;
            } else {
                __glsContext_destroy(ctx);
            }
        } else {
            __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        }
        __glsEndCriticalSection();
    } else {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
    }
}

const GLubyte* glsEnumString(GLSenum inAPI, GLSenum inEnum) {
    GLint offset, page;

    switch (inAPI) {
        case GLS_API_GLS:
            page = __GLS_ENUM_PAGE(inEnum);
            offset = __GLS_ENUM_OFFSET(inEnum);
            if (
                page < __GLS_ENUM_PAGE_COUNT &&
                offset < __glsEnumStringCount[page] &&
                __glsEnumString[page][offset]
            ) {
                return __glsEnumString[page][offset];
            }
            break;
        case GLS_API_GL:
            page = __GL_ENUM_PAGE(inEnum);
            offset = __GL_ENUM_OFFSET(inEnum);
            if (
                page < __GL_ENUM_PAGE_COUNT &&
                offset < __glEnumStringCount[page] &&
                __glEnumString[page][offset]
            ) {
                return __glEnumString[page][offset];
            }
            break;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

GLuint glsGenContext(void) {
    GLboolean added = GL_FALSE;
    __GLScontext *ctx;
    GLuint name;

    __glsBeginCriticalSection();
    name = __glsNextContext;
    if (
        (ctx = __glsContext_create(name)) &&
        (added = __glsInt2PtrDict_add(__glsContextDict, (GLint)name, ctx))
    ) {
        ++__glsContextCount;
        ++__glsNextContext;
        __GLS_LIST_APPEND(&__glsContextList, ctx);
    }
    __glsEndCriticalSection();
    if (added) {
        return name;
    } else {
        __glsContext_destroy(ctx);
        return 0;
    }
}

GLuint* glsGetAllContexts(void) {
    GLuint *buf = GLS_NONE;
    GLint i = 0;

    __glsBeginCriticalSection();
    if (buf = __glsMalloc((__glsContextCount + 1) * sizeof(GLuint))) {
        __GLS_LIST_ITER(__GLScontext) iter;

        __GLS_LIST_FIRST(&__glsContextList, &iter);
        while (iter.elem) {
            buf[i++] = iter.elem->name;
            __GLS_LIST_NEXT(&__glsContextList, &iter);
        }
        buf[i] = 0;
    }
    __glsEndCriticalSection();
    return buf;
}

GLScommandAlignment* glsGetCommandAlignment(
    GLSopcode inOpcode,
    GLSenum inExternStreamType,
    GLScommandAlignment *outAlignment
) {
    GLbitfield attrib;

    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    attrib = __glsOpcodeAttrib[__glsMapOpcode(inOpcode)];
    switch (inExternStreamType) {
        case GLS_BINARY_LSB_FIRST:
        case GLS_BINARY_MSB_FIRST:
            if (attrib & __GLS_COMMAND_ALIGN_EVEN32_BIT) {
                outAlignment->mask = 7;
                outAlignment->value = 0;
            } else if (attrib & __GLS_COMMAND_ALIGN_ODD32_BIT) {
                outAlignment->mask = 7;
                outAlignment->value = 4;
            } else {
                outAlignment->mask = 3;
                outAlignment->value = 0;
            }
            break;
        case GLS_TEXT:
            outAlignment->mask = 0;
            outAlignment->value = 0;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return outAlignment;
}

GLbitfield glsGetCommandAttrib(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return (
        __glsOpcodeAttrib[__glsMapOpcode(inOpcode)] &
        __GLS_COMMAND_ATTRIB_MASK
    );
}

GLint glsGetConsti(GLSenum inAttrib) {
    switch (inAttrib) {
        case GLS_API_COUNT:
            return __GLS_API_COUNT;
        case GLS_MAX_CALL_NESTING:
            return __GLS_MAX_CALL_NESTING;
        case GLS_MAX_CAPTURE_NESTING:
            return __GLS_MAX_CAPTURE_NESTING;
        case GLS_VERSION_MAJOR:
            return __GLS_VERSION_MAJOR;
        case GLS_VERSION_MINOR:
            return __GLS_VERSION_MINOR;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

const GLint* glsGetConstiv(GLSenum inAttrib) {
    switch (inAttrib) {
        case GLS_ALL_APIS:
            return (const GLint *)__glsAllAPIs;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

const GLubyte* glsGetConstubz(GLSenum inAttrib) {
    switch (inAttrib) {
        case GLS_EXTENSIONS:
            return __glsExtensions;
        case GLS_PLATFORM:
            return glsCSTR(__GLS_PLATFORM);
        case GLS_RELEASE:
            return glsCSTR(__GLS_RELEASE);
        case GLS_VENDOR:
            return glsCSTR(__GLS_VENDOR);
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

GLuint glsGetCurrentContext(void) {
    return __GLS_CONTEXT ? __GLS_CONTEXT->name : 0;
}

GLint* glsGetCurrentTime(GLint *outTime) {
    GLint i;
    const time_t t = time(GLS_NONE);
    struct tm utc, *utcp;

    __glsBeginCriticalSection();
    if (utcp = gmtime(&t)) utc = *utcp;
    __glsEndCriticalSection();
    if (t != (time_t)-1 && utcp) {
        outTime[0] = 1900 + utc.tm_year;
        outTime[1] = 1 + utc.tm_mon;
        outTime[2] = utc.tm_mday;
        outTime[3] = utc.tm_hour;
        outTime[4] = utc.tm_min;
        outTime[5] = utc.tm_sec;
        return outTime;
    }
    for (i = 0 ; i < 6 ; ++i) outTime[i] = 0;
    return GLS_NONE;
}

GLSenum glsGetError(GLboolean inClear) {
    const GLSenum outError = __GLS_ERROR;

    if (inClear) __GLS_PUT_ERROR(GLS_NONE);
    return outError;
}

GLint glsGetOpcodeCount(GLSenum inAPI) {
    switch (inAPI) {
        case GLS_API_GLS:
            return __glsOpcodesGLSCount;
        case GLS_API_GL:
            return __glsOpcodesGLCount;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

const GLSopcode* glsGetOpcodes(GLSenum inAPI) {
    switch (inAPI) {
        case GLS_API_GLS:
            return __glsOpcodesGLS;
        case GLS_API_GL:
            return __glsOpcodesGL;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

GLboolean glsIsContext(GLuint inContext) {
    __GLScontext *ctx;

    __glsBeginCriticalSection();
    ctx = (__GLScontext *)__glsInt2PtrDict_find(
        __glsContextDict, (GLint)inContext
    );
    __glsEndCriticalSection();
    return (GLboolean)(ctx != GLS_NONE);
}

static GLboolean __glsFindExtension(
    const GLubyte *inExtension, const GLubyte *inList
) {
    const GLubyte *p0 = inList;
    
    while (
        p0 =
        (const GLubyte *)strstr((const char *)p0, (const char *)inExtension)
    ) {
        const GLubyte *const p1 = p0 + strlen((const char *)inExtension);

        if (!*p1 || *p1 == ' ') return GL_TRUE;
        p0 = p1;
    }
    return GL_FALSE;
}

GLboolean glsIsExtensionSupported(const GLubyte *inExtension) {
    if (!__glsValidateString(inExtension)) return GL_FALSE;
    if (!__glsFindExtension(inExtension, __glsExtensions)) return GL_FALSE;
    if (!strncmp((const char *)inExtension, "GL_", 3)) {
        const GLubyte *const p = glGetString(GL_EXTENSIONS);

        if (!p || !__glsFindExtension(inExtension, p)) return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean glsIsUTF8String(const GLubyte *inString) {
    GLuint b;

    while (b = *inString) {
        if (b & 0x80) goto slowPath;
        ++inString;
    }
    return GL_TRUE;
slowPath:
    while (*inString) {
        const GLint n = glsUTF8toUCS4(inString, &b);

        if (!n) return GL_FALSE;
        inString += n;
    }
    return GL_TRUE;
}

GLlong glsLong(GLint inHigh, GLuint inLow) {
    #if __GLS_INT64
        return ((GLlong)inHigh) << 32 | inLow;
    #elif __GLS_MSB_FIRST
        GLlong outVal;

        outVal.uint0 = inHigh;
        outVal.uint1 = inLow;
        return outVal;
    #else /* !__GLS_MSB_FIRST */
        GLlong outVal;

        outVal.uint0 = inLow;
        outVal.uint1 = inHigh;
        return outVal;
    #endif /* __GLS_INT64 */
}

GLint glsLongHigh(GLlong inVal) {
    #if __GLS_INT64
        return (GLint)(inVal >> 32 & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint0;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint1;
    #endif /* __GLS_INT64 */
}

GLuint glsLongLow(GLlong inVal) {
    #if __GLS_INT64
        return (GLuint)(inVal & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint1;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint0;
    #endif /* __GLS_INT64 */
}

void glsPixelSetup(void) {
    __glsPixelSetup_pack();
    __glsPixelSetup_unpack();
}

GLulong glsULong(GLuint inHigh, GLuint inLow) {
    #if __GLS_INT64
        return ((GLulong)inHigh) << 32 | inLow;
    #elif __GLS_MSB_FIRST
        GLulong outVal;

        outVal.uint0 = inHigh;
        outVal.uint1 = inLow;
        return outVal;
    #else /* !__GLS_MSB_FIRST */
        GLulong outVal;

        outVal.uint0 = inLow;
        outVal.uint1 = inHigh;
        return outVal;
    #endif /* __GLS_INT64 */
}

GLuint glsULongHigh(GLulong inVal) {
    #if __GLS_INT64
        return (GLuint)(inVal >> 32 & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint0;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint1;
    #endif /* __GLS_INT64 */
}

GLuint glsULongLow(GLulong inVal) {
    #if __GLS_INT64
        return (GLuint)(inVal & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint1;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint0;
    #endif /* __GLS_INT64 */
}

GLint glsUCS4toUTF8(GLuint inUCS4, GLubyte *outUTF8) {
    const __GLSutf8format *format;
    GLint outVal = 1;

    for (format = __glsUTF8formats ; format->mask1 ; ++format, ++outVal) {
        if (inUCS4 <= format->mask4) {
            GLuint shift = format->shift;

            *outUTF8++ = (GLubyte)(format->val1 | (inUCS4 >> shift));
            while (shift) {
                shift -= 6;
                *outUTF8++ = (GLubyte)(0x80 | ((inUCS4 >> shift) & 0x3f));
            }
            return outVal;
        }
    }
    return 0;
}

GLubyte* glsUCStoUTF8z(
    size_t inUCSbytes,
    const GLvoid *inUCSz,
    size_t inUTF8max,
    GLubyte *outUTF8z
) {
    switch (inUCSbytes) {
        case 1:
            return glsUCS1toUTF8z(
                (const GLubyte *)inUCSz, inUTF8max, outUTF8z
            );
        case 2:
            return glsUCS2toUTF8z(
                (const GLushort *)inUCSz, inUTF8max, outUTF8z
            );
        case 4:
            return glsUCS4toUTF8z(
                (const GLuint *)inUCSz, inUTF8max, outUTF8z
            );
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            return GLS_NONE;
    }
}

GLubyte* glsUCS1toUTF8z(
    const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z
) {
    GLuint b;
    GLubyte *const limit = outUTF8z + inUTF8max - 1;
    GLubyte *p = outUTF8z;

    while (b = *inUCS1z++) {
        if (p >= limit) return GLS_NONE;
        p += glsUCS4toUTF8(b, p);
    }
    if (p > limit) return GLS_NONE;
    *p = 0;
    return outUTF8z;
}

GLubyte* glsUCS2toUTF8z(
    const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z
) {
    GLuint b;
    GLubyte buf[3];
    GLubyte *const limit = outUTF8z + inUTF8max - 1;
    GLubyte *p = outUTF8z;

    while (b = *inUCS2z++) {
        GLubyte *bufPtr = buf;
        GLubyte *p0 = p;

        p += glsUCS4toUTF8(b, bufPtr);
        if (p > limit) return GLS_NONE;
        while (p0 < p) *p0++ = *bufPtr++;
    }
    *p = 0;
    return outUTF8z;
}

GLubyte* glsUCS4toUTF8z(
    const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z
) {
    GLuint b;
    GLubyte buf[6];
    GLubyte *const limit = outUTF8z + inUTF8max - 1;
    GLubyte *p = outUTF8z;

    while (b = *inUCS4z++) {
        GLubyte *bufPtr = buf;
        GLubyte *p0 = p;

        p += glsUCS4toUTF8(b, bufPtr);
        if (p > limit) return GLS_NONE;
        while (p0 < p) *p0++ = *bufPtr++;
    }
    *p = 0;
    return outUTF8z;
}

GLint glsUTF8toUCS4(const GLubyte *inUTF8, GLuint *outUCS4) {
    GLuint b, b0, ucs4;
    const __GLSutf8format *format;
    GLint outVal = 1;
  
    ucs4 = b0 = *inUTF8++;
    for (format = __glsUTF8formats ; format->mask1 ; ++format, ++outVal) {
        if ((b0 & format->mask1) == format->val1) {
            ucs4 &= format->mask4;
            if (ucs4 < format->val4) return 0;
            *outUCS4 = ucs4;
            return outVal;
        }
        b = *inUTF8++ ^ 0x80;
        if (b & 0xc0) return 0;
        ucs4 = (ucs4 << 6) | b;
    }
    return 0;
}

GLboolean glsUTF8toUCSz(
    size_t inUCSbytes,
    const GLubyte *inUTF8z,
    size_t inUCSmax,
    GLvoid *outUCSz
) {
    switch (inUCSbytes) {
        case 1:
            return glsUTF8toUCS1z(inUTF8z, inUCSmax, (GLubyte *)outUCSz);
        case 2:
            return glsUTF8toUCS2z(inUTF8z, inUCSmax, (GLushort *)outUCSz);
        case 4:
            return glsUTF8toUCS4z(inUTF8z, inUCSmax, (GLuint *)outUCSz);
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            return GL_FALSE;
    }
}

GLboolean glsUTF8toUCS1z(
    const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z
) {
    GLuint b;
    GLubyte *const limit = outUCS1z + inUCS1max - 1;

    while (*inUTF8z) {
        const GLint n = glsUTF8toUCS4(inUTF8z, &b);

        if (n && b <= 0xff && outUCS1z < limit) {
            inUTF8z += n;
            *outUCS1z++ = (GLubyte)b;
        } else {
            return GL_FALSE;
        }
    }
    if (outUCS1z > limit) return GL_FALSE;
    *outUCS1z = 0;
    return GL_TRUE;
}

GLboolean glsUTF8toUCS2z(
    const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z
) {
    GLuint b;
    GLushort *const limit = outUCS2z + inUCS2max - 1;

    while (*inUTF8z) {
        const GLint n = glsUTF8toUCS4(inUTF8z, &b);

        if (n && b <= 0xffff && outUCS2z < limit) {
            inUTF8z += n;
            *outUCS2z++ = (GLushort)b;
        } else {
            return GL_FALSE;
        }
    }
    if (outUCS2z > limit) return GL_FALSE;
    *outUCS2z = 0;
    return GL_TRUE;
}

GLboolean glsUTF8toUCS4z(
    const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z
) {
    GLuint b;
    GLuint *const limit = outUCS4z + inUCS4max - 1;

    while (*inUTF8z) {
        const GLint n = glsUTF8toUCS4(inUTF8z, &b);

        if (n && outUCS4z < limit) {
            inUTF8z += n;
            *outUCS4z++ = b;
        } else {
            return GL_FALSE;
        }
    }
    if (outUCS4z > limit) return GL_FALSE;
    *outUCS4z = 0;
    return GL_TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_const.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

const GLubyte *const __glAttribMaskString[__GL_ATTRIB_MASK_COUNT] = {
    glsCSTR("GL_NONE"),
    glsCSTR("GL_CURRENT_BIT"),
    glsCSTR("GL_POINT_BIT"),
    glsCSTR("GL_LINE_BIT"),
    glsCSTR("GL_POLYGON_BIT"),
    glsCSTR("GL_POLYGON_STIPPLE_BIT"),
    glsCSTR("GL_PIXEL_MODE_BIT"),
    glsCSTR("GL_LIGHTING_BIT"),
    glsCSTR("GL_FOG_BIT"),
    glsCSTR("GL_DEPTH_BUFFER_BIT"),
    glsCSTR("GL_ACCUM_BUFFER_BIT"),
    glsCSTR("GL_STENCIL_BUFFER_BIT"),
    glsCSTR("GL_VIEWPORT_BIT"),
    glsCSTR("GL_TRANSFORM_BIT"),
    glsCSTR("GL_ENABLE_BIT"),
    glsCSTR("GL_COLOR_BUFFER_BIT"),
    glsCSTR("GL_HINT_BIT"),
    glsCSTR("GL_EVAL_BIT"),
    glsCSTR("GL_LIST_BIT"),
    glsCSTR("GL_TEXTURE_BIT"),
    glsCSTR("GL_SCISSOR_BIT"),
    glsCSTR("GL_ALL_ATTRIB_BITS"),
    glsCSTR("GL_MULTISAMPLE_BIT_EXT"),
};
const GLbitfield __glAttribMaskVal[__GL_ATTRIB_MASK_COUNT] = {
    0,
    0x00000001,
    0x00000002,
    0x00000004,
    0x00000008,
    0x00000010,
    0x00000020,
    0x00000040,
    0x00000080,
    0x00000100,
    0x00000200,
    0x00000400,
    0x00000800,
    0x00001000,
    0x00002000,
    0x00004000,
    0x00008000,
    0x00010000,
    0x00020000,
    0x00040000,
    0x00080000,
    0x000fffff,
    0x20000000,
};

const GLubyte *const __glsImageFlagsString[__GLS_IMAGE_FLAGS_COUNT] = {
    glsCSTR("GLS_NONE"),
    glsCSTR("GLS_IMAGE_NULL_BIT"),
};
const GLbitfield __glsImageFlagsVal[__GLS_IMAGE_FLAGS_COUNT] = {
    0,
    0x00000001,
};

static const GLubyte *const __glEnumString0[10] = {
    glsCSTR("GL_POINTS"),
    glsCSTR("GL_LINES"),
    glsCSTR("GL_LINE_LOOP"),
    glsCSTR("GL_LINE_STRIP"),
    glsCSTR("GL_TRIANGLES"),
    glsCSTR("GL_TRIANGLE_STRIP"),
    glsCSTR("GL_TRIANGLE_FAN"),
    glsCSTR("GL_QUADS"),
    glsCSTR("GL_QUAD_STRIP"),
    glsCSTR("GL_POLYGON"),
};
static const GLubyte *const __glEnumString1[5] = {
    glsCSTR("GL_ACCUM"),
    glsCSTR("GL_LOAD"),
    glsCSTR("GL_RETURN"),
    glsCSTR("GL_MULT"),
    glsCSTR("GL_ADD"),
};
static const GLubyte *const __glEnumString2[8] = {
    glsCSTR("GL_NEVER"),
    glsCSTR("GL_LESS"),
    glsCSTR("GL_EQUAL"),
    glsCSTR("GL_LEQUAL"),
    glsCSTR("GL_GREATER"),
    glsCSTR("GL_NOTEQUAL"),
    glsCSTR("GL_GEQUAL"),
    glsCSTR("GL_ALWAYS"),
};
static const GLubyte *const __glEnumString3[9] = {
    glsCSTR("GL_SRC_COLOR"),
    glsCSTR("GL_ONE_MINUS_SRC_COLOR"),
    glsCSTR("GL_SRC_ALPHA"),
    glsCSTR("GL_ONE_MINUS_SRC_ALPHA"),
    glsCSTR("GL_DST_ALPHA"),
    glsCSTR("GL_ONE_MINUS_DST_ALPHA"),
    glsCSTR("GL_DST_COLOR"),
    glsCSTR("GL_ONE_MINUS_DST_COLOR"),
    glsCSTR("GL_SRC_ALPHA_SATURATE"),
};
static const GLubyte *const __glEnumString4[13] = {
    glsCSTR("GL_FRONT_LEFT"),
    glsCSTR("GL_FRONT_RIGHT"),
    glsCSTR("GL_BACK_LEFT"),
    glsCSTR("GL_BACK_RIGHT"),
    glsCSTR("GL_FRONT"),
    glsCSTR("GL_BACK"),
    glsCSTR("GL_LEFT"),
    glsCSTR("GL_RIGHT"),
    glsCSTR("GL_FRONT_AND_BACK"),
    glsCSTR("GL_AUX0"),
    glsCSTR("GL_AUX1"),
    glsCSTR("GL_AUX2"),
    glsCSTR("GL_AUX3"),
};
static const GLubyte *const __glEnumString5[6] = {
    glsCSTR("GL_INVALID_ENUM"),
    glsCSTR("GL_INVALID_VALUE"),
    glsCSTR("GL_INVALID_OPERATION"),
    glsCSTR("GL_STACK_OVERFLOW"),
    glsCSTR("GL_STACK_UNDERFLOW"),
    glsCSTR("GL_OUT_OF_MEMORY"),
};
static const GLubyte *const __glEnumString6[5] = {
    glsCSTR("GL_2D"),
    glsCSTR("GL_3D"),
    glsCSTR("GL_3D_COLOR"),
    glsCSTR("GL_3D_COLOR_TEXTURE"),
    glsCSTR("GL_4D_COLOR_TEXTURE"),
};
static const GLubyte *const __glEnumString7[8] = {
    glsCSTR("GL_PASS_THROUGH_TOKEN"),
    glsCSTR("GL_POINT_TOKEN"),
    glsCSTR("GL_LINE_TOKEN"),
    glsCSTR("GL_POLYGON_TOKEN"),
    glsCSTR("GL_BITMAP_TOKEN"),
    glsCSTR("GL_DRAW_PIXEL_TOKEN"),
    glsCSTR("GL_COPY_PIXEL_TOKEN"),
    glsCSTR("GL_LINE_RESET_TOKEN"),
};
static const GLubyte *const __glEnumString8[2] = {
    glsCSTR("GL_EXP"),
    glsCSTR("GL_EXP2"),
};
static const GLubyte *const __glEnumString9[2] = {
    glsCSTR("GL_CW"),
    glsCSTR("GL_CCW"),
};
static const GLubyte *const __glEnumString10[3] = {
    glsCSTR("GL_COEFF"),
    glsCSTR("GL_ORDER"),
    glsCSTR("GL_DOMAIN"),
};
static const GLubyte *const __glEnumString11[242] = {
    glsCSTR("GL_CURRENT_COLOR"),
    glsCSTR("GL_CURRENT_INDEX"),
    glsCSTR("GL_CURRENT_NORMAL"),
    glsCSTR("GL_CURRENT_TEXTURE_COORDS"),
    glsCSTR("GL_CURRENT_RASTER_COLOR"),
    glsCSTR("GL_CURRENT_RASTER_INDEX"),
    glsCSTR("GL_CURRENT_RASTER_TEXTURE_COORDS"),
    glsCSTR("GL_CURRENT_RASTER_POSITION"),
    glsCSTR("GL_CURRENT_RASTER_POSITION_VALID"),
    glsCSTR("GL_CURRENT_RASTER_DISTANCE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_POINT_SMOOTH"),
    glsCSTR("GL_POINT_SIZE"),
    glsCSTR("GL_POINT_SIZE_RANGE"),
    glsCSTR("GL_POINT_SIZE_GRANULARITY"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LINE_SMOOTH"),
    glsCSTR("GL_LINE_WIDTH"),
    glsCSTR("GL_LINE_WIDTH_RANGE"),
    glsCSTR("GL_LINE_WIDTH_GRANULARITY"),
    glsCSTR("GL_LINE_STIPPLE"),
    glsCSTR("GL_LINE_STIPPLE_PATTERN"),
    glsCSTR("GL_LINE_STIPPLE_REPEAT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LIST_MODE"),
    glsCSTR("GL_MAX_LIST_NESTING"),
    glsCSTR("GL_LIST_BASE"),
    glsCSTR("GL_LIST_INDEX"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_POLYGON_MODE"),
    glsCSTR("GL_POLYGON_SMOOTH"),
    glsCSTR("GL_POLYGON_STIPPLE"),
    glsCSTR("GL_EDGE_FLAG"),
    glsCSTR("GL_CULL_FACE"),
    glsCSTR("GL_CULL_FACE_MODE"),
    glsCSTR("GL_FRONT_FACE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LIGHTING"),
    glsCSTR("GL_LIGHT_MODEL_LOCAL_VIEWER"),
    glsCSTR("GL_LIGHT_MODEL_TWO_SIDE"),
    glsCSTR("GL_LIGHT_MODEL_AMBIENT"),
    glsCSTR("GL_SHADE_MODEL"),
    glsCSTR("GL_COLOR_MATERIAL_FACE"),
    glsCSTR("GL_COLOR_MATERIAL_PARAMETER"),
    glsCSTR("GL_COLOR_MATERIAL"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_FOG"),
    glsCSTR("GL_FOG_INDEX"),
    glsCSTR("GL_FOG_DENSITY"),
    glsCSTR("GL_FOG_START"),
    glsCSTR("GL_FOG_END"),
    glsCSTR("GL_FOG_MODE"),
    glsCSTR("GL_FOG_COLOR"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_DEPTH_RANGE"),
    glsCSTR("GL_DEPTH_TEST"),
    glsCSTR("GL_DEPTH_WRITEMASK"),
    glsCSTR("GL_DEPTH_CLEAR_VALUE"),
    glsCSTR("GL_DEPTH_FUNC"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_ACCUM_CLEAR_VALUE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_STENCIL_TEST"),
    glsCSTR("GL_STENCIL_CLEAR_VALUE"),
    glsCSTR("GL_STENCIL_FUNC"),
    glsCSTR("GL_STENCIL_VALUE_MASK"),
    glsCSTR("GL_STENCIL_FAIL"),
    glsCSTR("GL_STENCIL_PASS_DEPTH_FAIL"),
    glsCSTR("GL_STENCIL_PASS_DEPTH_PASS"),
    glsCSTR("GL_STENCIL_REF"),
    glsCSTR("GL_STENCIL_WRITEMASK"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MATRIX_MODE"),
    glsCSTR("GL_NORMALIZE"),
    glsCSTR("GL_VIEWPORT"),
    glsCSTR("GL_MODELVIEW_STACK_DEPTH"),
    glsCSTR("GL_PROJECTION_STACK_DEPTH"),
    glsCSTR("GL_TEXTURE_STACK_DEPTH"),
    glsCSTR("GL_MODELVIEW_MATRIX"),
    glsCSTR("GL_PROJECTION_MATRIX"),
    glsCSTR("GL_TEXTURE_MATRIX"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_ATTRIB_STACK_DEPTH"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_ALPHA_TEST"),
    glsCSTR("GL_ALPHA_TEST_FUNC"),
    glsCSTR("GL_ALPHA_TEST_REF"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_DITHER"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_BLEND_DST"),
    glsCSTR("GL_BLEND_SRC"),
    glsCSTR("GL_BLEND"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LOGIC_OP_MODE"),
    glsCSTR("GL_INDEX_LOGIC_OP"),
};
static const GLubyte *const __glEnumString12[246] = {
    glsCSTR("GL_AUX_BUFFERS"),
    glsCSTR("GL_DRAW_BUFFER"),
    glsCSTR("GL_READ_BUFFER"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_SCISSOR_BOX"),
    glsCSTR("GL_SCISSOR_TEST"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_INDEX_CLEAR_VALUE"),
    glsCSTR("GL_INDEX_WRITEMASK"),
    glsCSTR("GL_COLOR_CLEAR_VALUE"),
    glsCSTR("GL_COLOR_WRITEMASK"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_INDEX_MODE"),
    glsCSTR("GL_RGBA_MODE"),
    glsCSTR("GL_DOUBLEBUFFER"),
    glsCSTR("GL_STEREO"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_RENDER_MODE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PERSPECTIVE_CORRECTION_HINT"),
    glsCSTR("GL_POINT_SMOOTH_HINT"),
    glsCSTR("GL_LINE_SMOOTH_HINT"),
    glsCSTR("GL_POLYGON_SMOOTH_HINT"),
    glsCSTR("GL_FOG_HINT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_TEXTURE_GEN_S"),
    glsCSTR("GL_TEXTURE_GEN_T"),
    glsCSTR("GL_TEXTURE_GEN_R"),
    glsCSTR("GL_TEXTURE_GEN_Q"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PIXEL_MAP_I_TO_I"),
    glsCSTR("GL_PIXEL_MAP_S_TO_S"),
    glsCSTR("GL_PIXEL_MAP_I_TO_R"),
    glsCSTR("GL_PIXEL_MAP_I_TO_G"),
    glsCSTR("GL_PIXEL_MAP_I_TO_B"),
    glsCSTR("GL_PIXEL_MAP_I_TO_A"),
    glsCSTR("GL_PIXEL_MAP_R_TO_R"),
    glsCSTR("GL_PIXEL_MAP_G_TO_G"),
    glsCSTR("GL_PIXEL_MAP_B_TO_B"),
    glsCSTR("GL_PIXEL_MAP_A_TO_A"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PIXEL_MAP_I_TO_I_SIZE"),
    glsCSTR("GL_PIXEL_MAP_S_TO_S_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_R_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_G_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_B_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_A_SIZE"),
    glsCSTR("GL_PIXEL_MAP_R_TO_R_SIZE"),
    glsCSTR("GL_PIXEL_MAP_G_TO_G_SIZE"),
    glsCSTR("GL_PIXEL_MAP_B_TO_B_SIZE"),
    glsCSTR("GL_PIXEL_MAP_A_TO_A_SIZE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_UNPACK_SWAP_BYTES"),
    glsCSTR("GL_UNPACK_LSB_FIRST"),
    glsCSTR("GL_UNPACK_ROW_LENGTH"),
    glsCSTR("GL_UNPACK_SKIP_ROWS"),
    glsCSTR("GL_UNPACK_SKIP_PIXELS"),
    glsCSTR("GL_UNPACK_ALIGNMENT"),
};
static const GLubyte *const __glEnumString13[226] = {
    glsCSTR("GL_PACK_SWAP_BYTES"),
    glsCSTR("GL_PACK_LSB_FIRST"),
    glsCSTR("GL_PACK_ROW_LENGTH"),
    glsCSTR("GL_PACK_SKIP_ROWS"),
    glsCSTR("GL_PACK_SKIP_PIXELS"),
    glsCSTR("GL_PACK_ALIGNMENT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP_COLOR"),
    glsCSTR("GL_MAP_STENCIL"),
    glsCSTR("GL_INDEX_SHIFT"),
    glsCSTR("GL_INDEX_OFFSET"),
    glsCSTR("GL_RED_SCALE"),
    glsCSTR("GL_RED_BIAS"),
    glsCSTR("GL_ZOOM_X"),
    glsCSTR("GL_ZOOM_Y"),
    glsCSTR("GL_GREEN_SCALE"),
    glsCSTR("GL_GREEN_BIAS"),
    glsCSTR("GL_BLUE_SCALE"),
    glsCSTR("GL_BLUE_BIAS"),
    glsCSTR("GL_ALPHA_SCALE"),
    glsCSTR("GL_ALPHA_BIAS"),
    glsCSTR("GL_DEPTH_SCALE"),
    glsCSTR("GL_DEPTH_BIAS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAX_EVAL_ORDER"),
    glsCSTR("GL_MAX_LIGHTS"),
    glsCSTR("GL_MAX_CLIP_PLANES"),
    glsCSTR("GL_MAX_TEXTURE_SIZE"),
    glsCSTR("GL_MAX_PIXEL_MAP_TABLE"),
    glsCSTR("GL_MAX_ATTRIB_STACK_DEPTH"),
    glsCSTR("GL_MAX_MODELVIEW_STACK_DEPTH"),
    glsCSTR("GL_MAX_NAME_STACK_DEPTH"),
    glsCSTR("GL_MAX_PROJECTION_STACK_DEPTH"),
    glsCSTR("GL_MAX_TEXTURE_STACK_DEPTH"),
    glsCSTR("GL_MAX_VIEWPORT_DIMS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_SUBPIXEL_BITS"),
    glsCSTR("GL_INDEX_BITS"),
    glsCSTR("GL_RED_BITS"),
    glsCSTR("GL_GREEN_BITS"),
    glsCSTR("GL_BLUE_BITS"),
    glsCSTR("GL_ALPHA_BITS"),
    glsCSTR("GL_DEPTH_BITS"),
    glsCSTR("GL_STENCIL_BITS"),
    glsCSTR("GL_ACCUM_RED_BITS"),
    glsCSTR("GL_ACCUM_GREEN_BITS"),
    glsCSTR("GL_ACCUM_BLUE_BITS"),
    glsCSTR("GL_ACCUM_ALPHA_BITS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_NAME_STACK_DEPTH"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_AUTO_NORMAL"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP1_COLOR_4"),
    glsCSTR("GL_MAP1_INDEX"),
    glsCSTR("GL_MAP1_NORMAL"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_1"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_2"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_3"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_4"),
    glsCSTR("GL_MAP1_VERTEX_3"),
    glsCSTR("GL_MAP1_VERTEX_4"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP2_COLOR_4"),
    glsCSTR("GL_MAP2_INDEX"),
    glsCSTR("GL_MAP2_NORMAL"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_1"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_2"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_3"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_4"),
    glsCSTR("GL_MAP2_VERTEX_3"),
    glsCSTR("GL_MAP2_VERTEX_4"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP1_GRID_DOMAIN"),
    glsCSTR("GL_MAP1_GRID_SEGMENTS"),
    glsCSTR("GL_MAP2_GRID_DOMAIN"),
    glsCSTR("GL_MAP2_GRID_SEGMENTS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_TEXTURE_1D"),
    glsCSTR("GL_TEXTURE_2D"),
};
static const GLubyte *const __glEnumString16[6] = {
    glsCSTR("GL_TEXTURE_WIDTH"),
    glsCSTR("GL_TEXTURE_HEIGHT"),
    GLS_NONE,
    glsCSTR("GL_TEXTURE_COMPONENTS"),
    glsCSTR("GL_TEXTURE_BORDER_COLOR"),
    glsCSTR("GL_TEXTURE_BORDER"),
};
static const GLubyte *const __glEnumString17[3] = {
    glsCSTR("GL_DONT_CARE"),
    glsCSTR("GL_FASTEST"),
    glsCSTR("GL_NICEST"),
};
static const GLubyte *const __glEnumString18[10] = {
    glsCSTR("GL_AMBIENT"),
    glsCSTR("GL_DIFFUSE"),
    glsCSTR("GL_SPECULAR"),
    glsCSTR("GL_POSITION"),
    glsCSTR("GL_SPOT_DIRECTION"),
    glsCSTR("GL_SPOT_EXPONENT"),
    glsCSTR("GL_SPOT_CUTOFF"),
    glsCSTR("GL_CONSTANT_ATTENUATION"),
    glsCSTR("GL_LINEAR_ATTENUATION"),
    glsCSTR("GL_QUADRATIC_ATTENUATION"),
};
static const GLubyte *const __glEnumString19[2] = {
    glsCSTR("GL_COMPILE"),
    glsCSTR("GL_COMPILE_AND_EXECUTE"),
};
static const GLubyte *const __glEnumString20[11] = {
    glsCSTR("GL_BYTE"),
    glsCSTR("GL_UNSIGNED_BYTE"),
    glsCSTR("GL_SHORT"),
    glsCSTR("GL_UNSIGNED_SHORT"),
    glsCSTR("GL_INT"),
    glsCSTR("GL_UNSIGNED_INT"),
    glsCSTR("GL_FLOAT"),
    glsCSTR("GL_2_BYTES"),
    glsCSTR("GL_3_BYTES"),
    glsCSTR("GL_4_BYTES"),
    glsCSTR("GL_DOUBLE_EXT"),
};
static const GLubyte *const __glEnumString21[16] = {
    glsCSTR("GL_CLEAR"),
    glsCSTR("GL_AND"),
    glsCSTR("GL_AND_REVERSE"),
    glsCSTR("GL_COPY"),
    glsCSTR("GL_AND_INVERTED"),
    glsCSTR("GL_NOOP"),
    glsCSTR("GL_XOR"),
    glsCSTR("GL_OR"),
    glsCSTR("GL_NOR"),
    glsCSTR("GL_EQUIV"),
    glsCSTR("GL_INVERT"),
    glsCSTR("GL_OR_REVERSE"),
    glsCSTR("GL_COPY_INVERTED"),
    glsCSTR("GL_OR_INVERTED"),
    glsCSTR("GL_NAND"),
    glsCSTR("GL_SET"),
};
static const GLubyte *const __glEnumString22[4] = {
    glsCSTR("GL_EMISSION"),
    glsCSTR("GL_SHININESS"),
    glsCSTR("GL_AMBIENT_AND_DIFFUSE"),
    glsCSTR("GL_COLOR_INDEXES"),
};
static const GLubyte *const __glEnumString23[3] = {
    glsCSTR("GL_MODELVIEW"),
    glsCSTR("GL_PROJECTION"),
    glsCSTR("GL_TEXTURE"),
};
static const GLubyte *const __glEnumString24[3] = {
    glsCSTR("GL_COLOR"),
    glsCSTR("GL_DEPTH"),
    glsCSTR("GL_STENCIL"),
};
static const GLubyte *const __glEnumString25[11] = {
    glsCSTR("GL_COLOR_INDEX"),
    glsCSTR("GL_STENCIL_INDEX"),
    glsCSTR("GL_DEPTH_COMPONENT"),
    glsCSTR("GL_RED"),
    glsCSTR("GL_GREEN"),
    glsCSTR("GL_BLUE"),
    glsCSTR("GL_ALPHA"),
    glsCSTR("GL_RGB"),
    glsCSTR("GL_RGBA"),
    glsCSTR("GL_LUMINANCE"),
    glsCSTR("GL_LUMINANCE_ALPHA"),
};
static const GLubyte *const __glEnumString26[1] = {
    glsCSTR("GL_BITMAP"),
};
static const GLubyte *const __glEnumString27[3] = {
    glsCSTR("GL_POINT"),
    glsCSTR("GL_LINE"),
    glsCSTR("GL_FILL"),
};
static const GLubyte *const __glEnumString28[3] = {
    glsCSTR("GL_RENDER"),
    glsCSTR("GL_FEEDBACK"),
    glsCSTR("GL_SELECT"),
};
static const GLubyte *const __glEnumString29[2] = {
    glsCSTR("GL_FLAT"),
    glsCSTR("GL_SMOOTH"),
};
static const GLubyte *const __glEnumString30[4] = {
    glsCSTR("GL_KEEP"),
    glsCSTR("GL_REPLACE"),
    glsCSTR("GL_INCR"),
    glsCSTR("GL_DECR"),
};
static const GLubyte *const __glEnumString31[4] = {
    glsCSTR("GL_VENDOR"),
    glsCSTR("GL_RENDERER"),
    glsCSTR("GL_VERSION"),
    glsCSTR("GL_EXTENSIONS"),
};
static const GLubyte *const __glEnumString32[4] = {
    glsCSTR("GL_S"),
    glsCSTR("GL_T"),
    glsCSTR("GL_R"),
    glsCSTR("GL_Q"),
};
static const GLubyte *const __glEnumString33[2] = {
    glsCSTR("GL_MODULATE"),
    glsCSTR("GL_DECAL"),
};
static const GLubyte *const __glEnumString34[2] = {
    glsCSTR("GL_TEXTURE_ENV_MODE"),
    glsCSTR("GL_TEXTURE_ENV_COLOR"),
};
static const GLubyte *const __glEnumString35[1] = {
    glsCSTR("GL_TEXTURE_ENV"),
};
static const GLubyte *const __glEnumString36[3] = {
    glsCSTR("GL_EYE_LINEAR"),
    glsCSTR("GL_OBJECT_LINEAR"),
    glsCSTR("GL_SPHERE_MAP"),
};
static const GLubyte *const __glEnumString37[3] = {
    glsCSTR("GL_TEXTURE_GEN_MODE"),
    glsCSTR("GL_OBJECT_PLANE"),
    glsCSTR("GL_EYE_PLANE"),
};
static const GLubyte *const __glEnumString38[2] = {
    glsCSTR("GL_NEAREST"),
    glsCSTR("GL_LINEAR"),
};
static const GLubyte *const __glEnumString39[4] = {
    glsCSTR("GL_NEAREST_MIPMAP_NEAREST"),
    glsCSTR("GL_LINEAR_MIPMAP_NEAREST"),
    glsCSTR("GL_NEAREST_MIPMAP_LINEAR"),
    glsCSTR("GL_LINEAR_MIPMAP_LINEAR"),
};
static const GLubyte *const __glEnumString40[4] = {
    glsCSTR("GL_TEXTURE_MAG_FILTER"),
    glsCSTR("GL_TEXTURE_MIN_FILTER"),
    glsCSTR("GL_TEXTURE_WRAP_S"),
    glsCSTR("GL_TEXTURE_WRAP_T"),
};
static const GLubyte *const __glEnumString41[2] = {
    glsCSTR("GL_CLAMP"),
    glsCSTR("GL_REPEAT"),
};
static const GLubyte *const __glEnumString42[46] = {
    glsCSTR("GL_POLYGON_OFFSET_UNITS"),
    glsCSTR("GL_POLYGON_OFFSET_POINT"),
    glsCSTR("GL_POLYGON_OFFSET_LINE"),
    glsCSTR("GL_POLYGON_OFFSET_FILL"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_COLOR_LOGIC_OP"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_V2F"),
    glsCSTR("GL_V3F"),
    glsCSTR("GL_C4UB_V2F"),
    glsCSTR("GL_C4UB_V3F"),
    glsCSTR("GL_C3F_V3F"),
    glsCSTR("GL_N3F_V3F"),
    glsCSTR("GL_C4F_N3F_V3F"),
    glsCSTR("GL_T2F_V3F"),
    glsCSTR("GL_T4F_V4F"),
    glsCSTR("GL_T2F_C4UB_V3F"),
    glsCSTR("GL_T2F_C3F_V3F"),
    glsCSTR("GL_T2F_N3F_V3F"),
    glsCSTR("GL_T2F_C4F_N3F_V3F"),
    glsCSTR("GL_T4F_C4F_N3F_V4F"),
};
static const GLubyte *const __glEnumString48[6] = {
    glsCSTR("GL_CLIP_PLANE0"),
    glsCSTR("GL_CLIP_PLANE1"),
    glsCSTR("GL_CLIP_PLANE2"),
    glsCSTR("GL_CLIP_PLANE3"),
    glsCSTR("GL_CLIP_PLANE4"),
    glsCSTR("GL_CLIP_PLANE5"),
};
static const GLubyte *const __glEnumString64[8] = {
    glsCSTR("GL_LIGHT0"),
    glsCSTR("GL_LIGHT1"),
    glsCSTR("GL_LIGHT2"),
    glsCSTR("GL_LIGHT3"),
    glsCSTR("GL_LIGHT4"),
    glsCSTR("GL_LIGHT5"),
    glsCSTR("GL_LIGHT6"),
    glsCSTR("GL_LIGHT7"),
};
static const GLubyte *const __glEnumString128[241] = {
    glsCSTR("GL_ABGR_EXT"),
    glsCSTR("GL_CONSTANT_COLOR_EXT"),
    glsCSTR("GL_ONE_MINUS_CONSTANT_COLOR_EXT"),
    glsCSTR("GL_CONSTANT_ALPHA_EXT"),
    glsCSTR("GL_ONE_MINUS_CONSTANT_ALPHA_EXT"),
    glsCSTR("GL_BLEND_COLOR_EXT"),
    glsCSTR("GL_FUNC_ADD_EXT"),
    glsCSTR("GL_MIN_EXT"),
    glsCSTR("GL_MAX_EXT"),
    glsCSTR("GL_BLEND_EQUATION_EXT"),
    glsCSTR("GL_FUNC_SUBTRACT_EXT"),
    glsCSTR("GL_FUNC_REVERSE_SUBTRACT_EXT"),
    glsCSTR("GL_CMYK_EXT"),
    glsCSTR("GL_CMYKA_EXT"),
    glsCSTR("GL_PACK_CMYK_HINT_EXT"),
    glsCSTR("GL_UNPACK_CMYK_HINT_EXT"),
    glsCSTR("GL_CONVOLUTION_1D_EXT"),
    glsCSTR("GL_CONVOLUTION_2D_EXT"),
    glsCSTR("GL_SEPARABLE_2D_EXT"),
    glsCSTR("GL_CONVOLUTION_BORDER_MODE_EXT"),
    glsCSTR("GL_CONVOLUTION_FILTER_SCALE_EXT"),
    glsCSTR("GL_CONVOLUTION_FILTER_BIAS_EXT"),
    glsCSTR("GL_REDUCE_EXT"),
    glsCSTR("GL_CONVOLUTION_FORMAT_EXT"),
    glsCSTR("GL_CONVOLUTION_WIDTH_EXT"),
    glsCSTR("GL_CONVOLUTION_HEIGHT_EXT"),
    glsCSTR("GL_MAX_CONVOLUTION_WIDTH_EXT"),
    glsCSTR("GL_MAX_CONVOLUTION_HEIGHT_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_RED_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_GREEN_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_BLUE_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_ALPHA_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_RED_BIAS_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_GREEN_BIAS_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_BLUE_BIAS_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_ALPHA_BIAS_EXT"),
    glsCSTR("GL_HISTOGRAM_EXT"),
    glsCSTR("GL_PROXY_HISTOGRAM_EXT"),
    glsCSTR("GL_HISTOGRAM_WIDTH_EXT"),
    glsCSTR("GL_HISTOGRAM_FORMAT_EXT"),
    glsCSTR("GL_HISTOGRAM_RED_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_GREEN_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_BLUE_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_ALPHA_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_LUMINANCE_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_SINK_EXT"),
    glsCSTR("GL_MINMAX_EXT"),
    glsCSTR("GL_MINMAX_FORMAT_EXT"),
    glsCSTR("GL_MINMAX_SINK_EXT"),
    glsCSTR("GL_TABLE_TOO_LARGE_EXT"),
    glsCSTR("GL_UNSIGNED_BYTE_3_3_2_EXT"),
    glsCSTR("GL_UNSIGNED_SHORT_4_4_4_4_EXT"),
    glsCSTR("GL_UNSIGNED_SHORT_5_5_5_1_EXT"),
    glsCSTR("GL_UNSIGNED_INT_8_8_8_8_EXT"),
    glsCSTR("GL_UNSIGNED_INT_10_10_10_2_EXT"),
    glsCSTR("GL_POLYGON_OFFSET"),
    glsCSTR("GL_POLYGON_OFFSET_FACTOR"),
    glsCSTR("GL_POLYGON_OFFSET_BIAS_EXT"),
    glsCSTR("GL_RESCALE_NORMAL_EXT"),
    glsCSTR("GL_ALPHA4"),
    glsCSTR("GL_ALPHA8"),
    glsCSTR("GL_ALPHA12"),
    glsCSTR("GL_ALPHA16"),
    glsCSTR("GL_LUMINANCE4"),
    glsCSTR("GL_LUMINANCE8"),
    glsCSTR("GL_LUMINANCE12"),
    glsCSTR("GL_LUMINANCE16"),
    glsCSTR("GL_LUMINANCE4_ALPHA4"),
    glsCSTR("GL_LUMINANCE6_ALPHA2"),
    glsCSTR("GL_LUMINANCE8_ALPHA8"),
    glsCSTR("GL_LUMINANCE12_ALPHA4"),
    glsCSTR("GL_LUMINANCE12_ALPHA12"),
    glsCSTR("GL_LUMINANCE16_ALPHA16"),
    glsCSTR("GL_INTENSITY"),
    glsCSTR("GL_INTENSITY4"),
    glsCSTR("GL_INTENSITY8"),
    glsCSTR("GL_INTENSITY12"),
    glsCSTR("GL_INTENSITY16"),
    glsCSTR("GL_R3_G3_B2"),
    glsCSTR("GL_RGB4"),
    glsCSTR("GL_RGB5"),
    glsCSTR("GL_RGB8"),
    glsCSTR("GL_RGB10"),
    glsCSTR("GL_RGB12"),
    glsCSTR("GL_RGB16"),
    glsCSTR("GL_RGBA2"),
    glsCSTR("GL_RGBA4"),
    glsCSTR("GL_RGB5_A1"),
    glsCSTR("GL_RGBA8"),
    glsCSTR("GL_RGB10_A2"),
    glsCSTR("GL_RGBA12"),
    glsCSTR("GL_RGBA16"),
    glsCSTR("GL_TEXTURE_RED_SIZE"),
    glsCSTR("GL_TEXTURE_GREEN_SIZE"),
    glsCSTR("GL_TEXTURE_BLUE_SIZE"),
    glsCSTR("GL_TEXTURE_ALPHA_SIZE"),
    glsCSTR("GL_TEXTURE_LUMINANCE_SIZE"),
    glsCSTR("GL_TEXTURE_INTENSITY_SIZE"),
    glsCSTR("GL_REPLACE"),
    glsCSTR("GL_PROXY_TEXTURE_1D"),
    glsCSTR("GL_PROXY_TEXTURE_2D"),
    glsCSTR("GL_TEXTURE_TOO_LARGE"),
    glsCSTR("GL_TEXTURE_PRIORITY"),
    glsCSTR("GL_TEXTURE_RESIDENT"),
    glsCSTR("GL_TEXTURE_1D_BINDING"),
    glsCSTR("GL_TEXTURE_2D_BINDING"),
    glsCSTR("GL_TEXTURE_3D_BINDING_EXT"),
    glsCSTR("GL_PACK_SKIP_IMAGES_EXT"),
    glsCSTR("GL_PACK_IMAGE_HEIGHT_EXT"),
    glsCSTR("GL_UNPACK_SKIP_IMAGES_EXT"),
    glsCSTR("GL_UNPACK_IMAGE_HEIGHT_EXT"),
    glsCSTR("GL_TEXTURE_3D_EXT"),
    glsCSTR("GL_PROXY_TEXTURE_3D_EXT"),
    glsCSTR("GL_TEXTURE_DEPTH_EXT"),
    glsCSTR("GL_TEXTURE_WRAP_R_EXT"),
    glsCSTR("GL_MAX_3D_TEXTURE_SIZE_EXT"),
    glsCSTR("GL_VERTEX_ARRAY"),
    glsCSTR("GL_NORMAL_ARRAY"),
    glsCSTR("GL_COLOR_ARRAY"),
    glsCSTR("GL_INDEX_ARRAY"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY"),
    glsCSTR("GL_EDGE_FLAG_ARRAY"),
    glsCSTR("GL_VERTEX_ARRAY_SIZE"),
    glsCSTR("GL_VERTEX_ARRAY_TYPE"),
    glsCSTR("GL_VERTEX_ARRAY_STRIDE"),
    glsCSTR("GL_VERTEX_ARRAY_COUNT_EXT"),
    glsCSTR("GL_NORMAL_ARRAY_TYPE"),
    glsCSTR("GL_NORMAL_ARRAY_STRIDE"),
    glsCSTR("GL_NORMAL_ARRAY_COUNT_EXT"),
    glsCSTR("GL_COLOR_ARRAY_SIZE"),
    glsCSTR("GL_COLOR_ARRAY_TYPE"),
    glsCSTR("GL_COLOR_ARRAY_STRIDE"),
    glsCSTR("GL_COLOR_ARRAY_COUNT_EXT"),
    glsCSTR("GL_INDEX_ARRAY_TYPE"),
    glsCSTR("GL_INDEX_ARRAY_STRIDE"),
    glsCSTR("GL_INDEX_ARRAY_COUNT_EXT"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_SIZE"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_TYPE"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_STRIDE"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_COUNT_EXT"),
    glsCSTR("GL_EDGE_FLAG_ARRAY_STRIDE"),
    glsCSTR("GL_EDGE_FLAG_ARRAY_COUNT_EXT"),
    glsCSTR("GL_VERTEX_ARRAY_POINTER"),
    glsCSTR("GL_NORMAL_ARRAY_POINTER"),
    glsCSTR("GL_COLOR_ARRAY_POINTER"),
    glsCSTR("GL_INDEX_ARRAY_POINTER"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_POINTER"),
    glsCSTR("GL_EDGE_FLAG_ARRAY_POINTER"),
    glsCSTR("GL_INTERLACE_SGIX"),
    glsCSTR("GL_DETAIL_TEXTURE_2D_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_2D_BINDING_SGIS"),
    glsCSTR("GL_LINEAR_DETAIL_SGIS"),
    glsCSTR("GL_LINEAR_DETAIL_ALPHA_SGIS"),
    glsCSTR("GL_LINEAR_DETAIL_COLOR_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_LEVEL_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_MODE_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS"),
    glsCSTR("GL_MULTISAMPLE_SGIS"),
    glsCSTR("GL_SAMPLE_ALPHA_TO_MASK_SGIS"),
    glsCSTR("GL_SAMPLE_ALPHA_TO_ONE_SGIS"),
    glsCSTR("GL_SAMPLE_MASK_SGIS"),
    glsCSTR("GL_1PASS_SGIS"),
    glsCSTR("GL_2PASS_0_SGIS"),
    glsCSTR("GL_2PASS_1_SGIS"),
    glsCSTR("GL_4PASS_0_SGIS"),
    glsCSTR("GL_4PASS_1_SGIS"),
    glsCSTR("GL_4PASS_2_SGIS"),
    glsCSTR("GL_4PASS_3_SGIS"),
    glsCSTR("GL_SAMPLE_BUFFERS_SGIS"),
    glsCSTR("GL_SAMPLES_SGIS"),
    glsCSTR("GL_SAMPLE_MASK_VALUE_SGIS"),
    glsCSTR("GL_SAMPLE_MASK_INVERT_SGIS"),
    glsCSTR("GL_SAMPLE_PATTERN_SGIS"),
    glsCSTR("GL_LINEAR_SHARPEN_SGIS"),
    glsCSTR("GL_LINEAR_SHARPEN_ALPHA_SGIS"),
    glsCSTR("GL_LINEAR_SHARPEN_COLOR_SGIS"),
    glsCSTR("GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS"),
    glsCSTR("GL_COLOR_MATRIX_SGI"),
    glsCSTR("GL_COLOR_MATRIX_STACK_DEPTH_SGI"),
    glsCSTR("GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_RED_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_RED_BIAS_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI"),
    glsCSTR("GL_TEXTURE_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_TEXTURE_COLOR_TABLE_SGI"),
    glsCSTR("GL_TEXTURE_COLOR_TABLE_BIAS_SGI"),
    glsCSTR("GL_TEXTURE_COLOR_TABLE_SCALE_SGI"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_COLOR_TABLE_SGI"),
    glsCSTR("GL_POST_CONVOLUTION_COLOR_TABLE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI"),
    glsCSTR("GL_COLOR_TABLE_SCALE_SGI"),
    glsCSTR("GL_COLOR_TABLE_BIAS_SGI"),
    glsCSTR("GL_COLOR_TABLE_FORMAT_EXT"),
    glsCSTR("GL_COLOR_TABLE_WIDTH_EXT"),
    glsCSTR("GL_COLOR_TABLE_RED_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_GREEN_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_BLUE_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_ALPHA_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_LUMINANCE_SIZE_SGI"),
    glsCSTR("GL_COLOR_TABLE_INTENSITY_SIZE_SGI"),
    glsCSTR("GL_BGR_EXT"),
    glsCSTR("GL_BGRA_EXT"),
    glsCSTR("GL_COLOR_INDEX1_EXT"),
    glsCSTR("GL_COLOR_INDEX2_EXT"),
    glsCSTR("GL_COLOR_INDEX4_EXT"),
    glsCSTR("GL_COLOR_INDEX8_EXT"),
    glsCSTR("GL_COLOR_INDEX12_EXT"),
    glsCSTR("GL_COLOR_INDEX16_EXT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_CLIP_EXT"),
};
static const GLubyte *const __glEnumString129[70] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_SS_SGIS"),
    glsCSTR("GL_SS4_SGIS"),
    glsCSTR("GL_SS8_SGIS"),
    glsCSTR("GL_SS12_SGIS"),
    glsCSTR("GL_SS16_SGIS"),
    glsCSTR("GL_SSSS_SGIS"),
    glsCSTR("GL_SSSS2_SGIS"),
    glsCSTR("GL_SSSS4_SGIS"),
    glsCSTR("GL_SSSS8_SGIS"),
    glsCSTR("GL_SSSS12_SGIS"),
    glsCSTR("GL_SSSS16_SGIS"),
    glsCSTR("GL_TEXTURE_SS_SELECT_SGIS"),
    glsCSTR("GL_TEXTURE_SSSS_SELECT_SGIS"),
    glsCSTR("GL_ALPHA_SELECT0_SGIS"),
    glsCSTR("GL_ALPHA_SELECT1_SGIS"),
    glsCSTR("GL_ALPHA_SELECT2_SGIS"),
    glsCSTR("GL_ALPHA_SELECT3_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT0_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT1_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT2_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT3_SGIS"),
    glsCSTR("GL_LUMINANCE_ALPHA_SELECT0_SGIS"),
    glsCSTR("GL_LUMINANCE_ALPHA_SELECT2_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT0_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT1_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT2_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT3_SGIS"),
    glsCSTR("GL_RGBA_SELECT0_SGIS"),
    glsCSTR("GL_TEXTURE_COMPONENT_S_SIZE_SGIS"),
    glsCSTR("GL_CLAMP_TO_BORDER_SGIS"),
    glsCSTR("GL_TEXTURE_MULTI_BUFFER_HINT_SGIX"),
    GLS_NONE,
    glsCSTR("GL_PACK_SKIP_VOLUMES_SGIS"),
    glsCSTR("GL_PACK_IMAGE_DEPTH_SGIS"),
    glsCSTR("GL_UNPACK_SKIP_VOLUMES_SGIS"),
    glsCSTR("GL_UNPACK_IMAGE_DEPTH_SGIS"),
    glsCSTR("GL_TEXTURE_4D_SGIS"),
    glsCSTR("GL_PROXY_TEXTURE_4D_SGIS"),
    glsCSTR("GL_TEXTURE_4DSIZE_SGIS"),
    glsCSTR("GL_TEXTURE_WRAP_Q_SGIS"),
    glsCSTR("GL_MAX_4D_TEXTURE_SIZE_SGIS"),
    glsCSTR("GL_PIXEL_TEX_GEN_MODE_SGIX"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_CACHE_INCREMENT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_WIDTH_SGIX"),
    glsCSTR("GL_PIXEL_TILE_HEIGHT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_GRID_WIDTH_SGIX"),
    glsCSTR("GL_PIXEL_TILE_GRID_HEIGHT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_GRID_DEPTH_SGIX"),
    glsCSTR("GL_PIXEL_TILE_CACHE_SIZE_SGIX"),
};

const GLint __glEnumStringCount[130] = {
    10,
    5,
    8,
    9,
    13,
    6,
    5,
    8,
    2,
    2,
    3,
    242,
    246,
    226,
    0,
    0,
    6,
    3,
    10,
    2,
    11,
    16,
    4,
    3,
    3,
    11,
    1,
    3,
    3,
    2,
    4,
    4,
    4,
    2,
    2,
    1,
    3,
    3,
    2,
    4,
    4,
    2,
    46,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    241,
    70,
};

const GLubyte *const *const __glEnumString[130] = {
    __glEnumString0,
    __glEnumString1,
    __glEnumString2,
    __glEnumString3,
    __glEnumString4,
    __glEnumString5,
    __glEnumString6,
    __glEnumString7,
    __glEnumString8,
    __glEnumString9,
    __glEnumString10,
    __glEnumString11,
    __glEnumString12,
    __glEnumString13,
    GLS_NONE,
    GLS_NONE,
    __glEnumString16,
    __glEnumString17,
    __glEnumString18,
    __glEnumString19,
    __glEnumString20,
    __glEnumString21,
    __glEnumString22,
    __glEnumString23,
    __glEnumString24,
    __glEnumString25,
    __glEnumString26,
    __glEnumString27,
    __glEnumString28,
    __glEnumString29,
    __glEnumString30,
    __glEnumString31,
    __glEnumString32,
    __glEnumString33,
    __glEnumString34,
    __glEnumString35,
    __glEnumString36,
    __glEnumString37,
    __glEnumString38,
    __glEnumString39,
    __glEnumString40,
    __glEnumString41,
    __glEnumString42,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glEnumString48,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glEnumString64,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glEnumString128,
    __glEnumString129,
};

static const GLubyte *const __glsEnumString0[1] = {
    glsCSTR("GLS_NONE"),
};
static const GLubyte *const __glsEnumString1[2] = {
    glsCSTR("GLS_ALL"),
    glsCSTR("GLS_LAST"),
};
static const GLubyte *const __glsEnumString2[2] = {
    glsCSTR("GLS_API_GLS"),
    glsCSTR("GLS_API_GL"),
};
static const GLubyte *const __glsEnumString3[4] = {
    glsCSTR("GLS_FRAME"),
    glsCSTR("GLS_HEADER"),
    glsCSTR("GLS_INIT"),
    glsCSTR("GLS_STATIC"),
};
static const GLubyte *const __glsEnumString4[2] = {
    glsCSTR("GLS_CAPTURE_ENTRY_FUNC"),
    glsCSTR("GLS_CAPTURE_EXIT_FUNC"),
};
static const GLubyte *const __glsEnumString5[4] = {
    glsCSTR("GLS_CONTEXT"),
    glsCSTR("GLS_BINARY_LSB_FIRST"),
    glsCSTR("GLS_BINARY_MSB_FIRST"),
    glsCSTR("GLS_TEXT"),
};
static const GLubyte *const __glsEnumString6[2] = {
    glsCSTR("GLS_DEFAULT_READ_CHANNEL"),
    glsCSTR("GLS_DEFAULT_WRITE_CHANNEL"),
};
static const GLubyte *const __glsEnumString7[5] = {
    glsCSTR("GLS_API_COUNT"),
    glsCSTR("GLS_MAX_CALL_NESTING"),
    glsCSTR("GLS_MAX_CAPTURE_NESTING"),
    glsCSTR("GLS_VERSION_MAJOR"),
    glsCSTR("GLS_VERSION_MINOR"),
};
static const GLubyte *const __glsEnumString8[1] = {
    glsCSTR("GLS_ALL_APIS"),
};
static const GLubyte *const __glsEnumString9[4] = {
    glsCSTR("GLS_EXTENSIONS"),
    glsCSTR("GLS_PLATFORM"),
    glsCSTR("GLS_RELEASE"),
    glsCSTR("GLS_VENDOR"),
};
static const GLubyte *const __glsEnumString10[4] = {
    GLS_NONE,
    glsCSTR("GLS_READ_FUNC"),
    glsCSTR("GLS_UNREAD_FUNC"),
    glsCSTR("GLS_WRITE_FUNC"),
};
static const GLubyte *const __glsEnumString11[1] = {
    glsCSTR("GLS_OUT_ARG_LIST"),
};
static const GLubyte *const __glsEnumString12[2] = {
    glsCSTR("GLS_CONTEXT_STREAM_LIST"),
    glsCSTR("GLS_READ_PREFIX_LIST"),
};
static const GLubyte *const __glsEnumString14[11] = {
    glsCSTR("GLS_DATA_POINTER"),
    glsCSTR("GLS_BLOCK_TYPE"),
    glsCSTR("GLS_CALL_NESTING"),
    glsCSTR("GLS_CAPTURE_NESTING"),
    glsCSTR("GLS_CONTEXT_STREAM_COUNT"),
    glsCSTR("GLS_CURRENT_GLRC"),
    glsCSTR("GLS_OUT_ARG_COUNT"),
    glsCSTR("GLS_PIXEL_SETUP_GEN"),
    glsCSTR("GLS_READ_PREFIX_COUNT"),
    glsCSTR("GLS_STREAM_VERSION_MAJOR"),
    glsCSTR("GLS_STREAM_VERSION_MINOR"),
};
static const GLubyte *const __glsEnumString16[1] = {
    glsCSTR("GLS_WRITE_PREFIX"),
};
static const GLubyte *const __glsEnumString17[3] = {
    glsCSTR("GLS_IIII"),
    glsCSTR("GLS_RGBA"),
    glsCSTR("GLS_RRRA"),
};
static const GLubyte *const __glsEnumString18[4] = {
    glsCSTR("GLS_DISPLAY_MAP_I_TO_R"),
    glsCSTR("GLS_DISPLAY_MAP_I_TO_G"),
    glsCSTR("GLS_DISPLAY_MAP_I_TO_B"),
    glsCSTR("GLS_DISPLAY_MAP_I_TO_A"),
};
static const GLubyte *const __glsEnumString19[16] = {
    glsCSTR("GLS_CALL_OVERFLOW"),
    glsCSTR("GLS_DECODE_ERROR"),
    glsCSTR("GLS_ENCODE_ERROR"),
    glsCSTR("GLS_INVALID_ENUM"),
    glsCSTR("GLS_INVALID_OPERATION"),
    glsCSTR("GLS_INVALID_STREAM"),
    glsCSTR("GLS_INVALID_STRING"),
    glsCSTR("GLS_INVALID_VALUE"),
    glsCSTR("GLS_NOT_FOUND"),
    glsCSTR("GLS_OUT_OF_MEMORY"),
    glsCSTR("GLS_STREAM_CLOSE_ERROR"),
    glsCSTR("GLS_STREAM_DELETE_ERROR"),
    glsCSTR("GLS_STREAM_OPEN_ERROR"),
    glsCSTR("GLS_STREAM_READ_ERROR"),
    glsCSTR("GLS_STREAM_WRITE_ERROR"),
    glsCSTR("GLS_UNSUPPORTED_COMMAND"),
};
static const GLubyte *const __glsEnumString20[1] = {
    glsCSTR("GLS_UNSUPPORTED_EXTENSION"),
};
static const GLubyte *const __glsEnumString21[1] = {
    glsCSTR("GLS_UNKNOWN"),
};
static const GLubyte *const __glsEnumString22[3] = {
    glsCSTR("GLS_LAYER"),
    glsCSTR("GLS_READ_LAYER"),
    glsCSTR("GLS_SHARE_GLRC"),
};
static const GLubyte *const __glsEnumString23[4] = {
    glsCSTR("GLS_ASPECT"),
    glsCSTR("GLS_BORDER_WIDTH"),
    glsCSTR("GLS_CONTRAST_RATIO"),
    glsCSTR("GLS_HEIGHT_MM"),
};
static const GLubyte *const __glsEnumString24[9] = {
    glsCSTR("GLS_BORDER_COLOR"),
    glsCSTR("GLS_GAMMA"),
    glsCSTR("GLS_ORIGIN"),
    glsCSTR("GLS_PAGE_COLOR"),
    glsCSTR("GLS_PAGE_SIZE"),
    glsCSTR("GLS_RED_POINT"),
    glsCSTR("GLS_GREEN_POINT"),
    glsCSTR("GLS_BLUE_POINT"),
    glsCSTR("GLS_WHITE_POINT"),
};
static const GLubyte *const __glsEnumString26[5] = {
    glsCSTR("GLS_FRAME_COUNT"),
    glsCSTR("GLS_GLRC_COUNT"),
    glsCSTR("GLS_HEIGHT_PIXELS"),
    glsCSTR("GLS_LAYER_COUNT"),
    glsCSTR("GLS_TILEABLE"),
};
static const GLubyte *const __glsEnumString27[2] = {
    glsCSTR("GLS_CREATE_TIME"),
    glsCSTR("GLS_MODIFY_TIME"),
};
static const GLubyte *const __glsEnumString28[6] = {
    glsCSTR("GLS_AUTHOR"),
    glsCSTR("GLS_DESCRIPTION"),
    glsCSTR("GLS_NOTES"),
    glsCSTR("GLS_TITLE"),
    glsCSTR("GLS_TOOLS"),
    glsCSTR("GLS_VERSION"),
};
static const GLubyte *const __glsEnumString29[1] = {
    glsCSTR("GLS_INVISIBLE_ASPECT"),
};
static const GLubyte *const __glsEnumString30[16] = {
    glsCSTR("GLS_DISPLAY_FORMAT"),
    glsCSTR("GLS_DOUBLEBUFFER"),
    glsCSTR("GLS_INVISIBLE"),
    glsCSTR("GLS_INVISIBLE_HEIGHT_PIXELS"),
    glsCSTR("GLS_LEVEL"),
    glsCSTR("GLS_STEREO"),
    glsCSTR("GLS_TRANSPARENT"),
    glsCSTR("GLS_INDEX_BITS"),
    glsCSTR("GLS_RED_BITS"),
    glsCSTR("GLS_GREEN_BITS"),
    glsCSTR("GLS_BLUE_BITS"),
    glsCSTR("GLS_ALPHA_BITS"),
    glsCSTR("GLS_DEPTH_BITS"),
    glsCSTR("GLS_STENCIL_BITS"),
    glsCSTR("GLS_ACCUM_RED_BITS"),
    glsCSTR("GLS_ACCUM_GREEN_BITS"),
};
static const GLubyte *const __glsEnumString31[3] = {
    glsCSTR("GLS_ACCUM_BLUE_BITS"),
    glsCSTR("GLS_ACCUM_ALPHA_BITS"),
    glsCSTR("GLS_AUX_BUFFERS"),
};
static const GLubyte *const __glsEnumString32[2] = {
    glsCSTR("GLS_APPEND"),
    glsCSTR("GLS_PREPEND"),
};
static const GLubyte *const __glsEnumString64[2] = {
    glsCSTR("GLS_SAMPLE_BUFFERS_SGIS"),
    glsCSTR("GLS_SAMPLES_SGIS"),
};

const GLint __glsEnumStringCount[65] = {
    1,
    2,
    2,
    4,
    2,
    4,
    2,
    5,
    1,
    4,
    4,
    1,
    2,
    0,
    11,
    0,
    1,
    3,
    4,
    16,
    1,
    1,
    3,
    4,
    9,
    0,
    5,
    2,
    6,
    1,
    16,
    3,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
};

const GLubyte *const *const __glsEnumString[65] = {
    __glsEnumString0,
    __glsEnumString1,
    __glsEnumString2,
    __glsEnumString3,
    __glsEnumString4,
    __glsEnumString5,
    __glsEnumString6,
    __glsEnumString7,
    __glsEnumString8,
    __glsEnumString9,
    __glsEnumString10,
    __glsEnumString11,
    __glsEnumString12,
    GLS_NONE,
    __glsEnumString14,
    GLS_NONE,
    __glsEnumString16,
    __glsEnumString17,
    __glsEnumString18,
    __glsEnumString19,
    __glsEnumString20,
    __glsEnumString21,
    __glsEnumString22,
    __glsEnumString23,
    __glsEnumString24,
    GLS_NONE,
    __glsEnumString26,
    __glsEnumString27,
    __glsEnumString28,
    __glsEnumString29,
    __glsEnumString30,
    __glsEnumString31,
    __glsEnumString32,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glsEnumString64,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_decbin.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

// DrewB - All functions changed to use passed in context
// DrewB - Added optimized vector functions missing in original
// DrewB - Removed size externs

void __gls_decode_bin_glsBeginGLS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[16])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsBlock(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum);
    ((__GLSdispatch)ctx->dispatchCall[17])(
        *(GLSenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsError(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);
    ((__GLSdispatch)ctx->dispatchCall[20])(
        *(GLSopcode *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsGLRC(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[21])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsGLRCLayer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[22])(
        *(GLuint *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderGLRCi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[23])(
        *(GLuint *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderLayerf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[24])(
        *(GLuint *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderLayeri(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[25])(
        *(GLuint *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[26])(
        *(GLSenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[27])(
        *(GLSenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[28])(
        *(GLSenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[29])(
        *(GLSenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, const GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[30])(
        *(GLSenum *)(inoutPtr + 0),
        (GLubyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsAppRef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLulong, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[33])(
        *(GLulong *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsCharubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, const GLubyte *);
    GLint inTag_count;
    inTag_count = (GLint)strlen((const char *)(inoutPtr + 0)) + 1;
    ((__GLSdispatch)ctx->dispatchCall[35])(
        (GLubyte *)(inoutPtr + 0),
        (GLubyte *)(inoutPtr + 0 + inTag_count)
    );
}

void __gls_decode_bin_glsDisplayMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLuint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[37])(
        *(GLuint *)(inoutPtr + 4),
        *(GLSenum *)(inoutPtr + 8),
        *(GLuint *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glsNumb(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[39])(
        (GLubyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumbv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLbyte *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[40])(
        (GLubyte *)(inoutPtr + 4 + 1 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLbyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[41])(
        (GLubyte *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLdouble *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[42])(
        (GLubyte *)(inoutPtr + 4 + 8 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLdouble *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[43])(
        (GLubyte *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLfloat *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[44])(
        (GLubyte *)(inoutPtr + 4 + 4 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLint);
    ((__GLSdispatch)ctx->dispatchCall[45])(
        (GLubyte *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLint *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[46])(
        (GLubyte *)(inoutPtr + 4 + 4 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNuml(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLlong);
    ((__GLSdispatch)ctx->dispatchCall[47])(
        (GLubyte *)(inoutPtr + 8),
        *(GLlong *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumlv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLlong *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[48])(
        (GLubyte *)(inoutPtr + 4 + 8 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLlong *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNums(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[49])(
        (GLubyte *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLshort *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[50])(
        (GLubyte *)(inoutPtr + 4 + 2 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLubyte);
    ((__GLSdispatch)ctx->dispatchCall[51])(
        (GLubyte *)(inoutPtr + 1),
        *(GLubyte *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLubyte *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[52])(
        (GLubyte *)(inoutPtr + 4 + 1 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLubyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumui(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[53])(
        (GLubyte *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLuint *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[54])(
        (GLubyte *)(inoutPtr + 4 + 4 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumul(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLulong);
    ((__GLSdispatch)ctx->dispatchCall[55])(
        (GLubyte *)(inoutPtr + 8),
        *(GLulong *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumulv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLulong *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[56])(
        (GLubyte *)(inoutPtr + 4 + 8 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLulong *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumus(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[57])(
        (GLubyte *)(inoutPtr + 2),
        *(GLushort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLushort *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[58])(
        (GLubyte *)(inoutPtr + 4 + 2 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLushort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsSwapBuffers(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[60])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glNewList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[64])(
        *(GLuint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glCallList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[66])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glCallLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, const GLvoid *);
    ((__GLSdispatch)ctx->dispatchCall[67])(
        *(GLsizei *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLvoid *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glDeleteLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[68])(
        *(GLuint *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glGenLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[69])(
        *(GLsizei *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glListBase(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[70])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glBegin(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[71])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glBitmap(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[72])(
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12),
        *(GLfloat *)(inoutPtr + 16),
        *(GLfloat *)(inoutPtr + 20),
        *(GLfloat *)(inoutPtr + 24),
        (GLubyte *)(inoutPtr + 28)
    );
}

void __gls_decode_bin_glColor3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[73])(
        *(GLbyte *)(inoutPtr + 0),
        *(GLbyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glColor3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[75])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glColor3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[77])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glColor3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[79])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glColor3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[81])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glColor3ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte);
    ((__GLSdispatch)ctx->dispatchCall[83])(
        *(GLubyte *)(inoutPtr + 0),
        *(GLubyte *)(inoutPtr + 1),
        *(GLubyte *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glColor3ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[85])(
        *(GLuint *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glColor3us(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[87])(
        *(GLushort *)(inoutPtr + 0),
        *(GLushort *)(inoutPtr + 2),
        *(GLushort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glColor4b(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[89])(
        *(GLbyte *)(inoutPtr + 0),
        *(GLbyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 2),
        *(GLbyte *)(inoutPtr + 3)
    );
}

void __gls_decode_bin_glColor4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[91])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glColor4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[93])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glColor4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[95])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glColor4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[97])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glColor4ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte, GLubyte);
    ((__GLSdispatch)ctx->dispatchCall[99])(
        *(GLubyte *)(inoutPtr + 0),
        *(GLubyte *)(inoutPtr + 1),
        *(GLubyte *)(inoutPtr + 2),
        *(GLubyte *)(inoutPtr + 3)
    );
}

void __gls_decode_bin_glColor4ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[101])(
        *(GLuint *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8),
        *(GLuint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glColor4us(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[103])(
        *(GLushort *)(inoutPtr + 0),
        *(GLushort *)(inoutPtr + 2),
        *(GLushort *)(inoutPtr + 4),
        *(GLushort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glEdgeFlag(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[105])(
        *(GLboolean *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[108])(
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[110])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[112])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexs(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort);
    ((__GLSdispatch)ctx->dispatchCall[114])(
        *(GLshort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort);
    ((__GLSdispatch)ctx->dispatchCall[379])(
        *(GLubyte *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glNormal3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[116])(
        *(GLbyte *)(inoutPtr + 0),
        *(GLbyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glNormal3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[118])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glNormal3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[120])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glNormal3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[122])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glNormal3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[124])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[126])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRasterPos2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[128])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[130])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[132])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glRasterPos3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[134])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glRasterPos3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[136])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRasterPos3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[138])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRasterPos3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[140])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[142])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glRasterPos4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[144])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRasterPos4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[146])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRasterPos4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[148])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glRectd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[150])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glRectdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLdouble *, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[151])(
        (GLdouble *)(inoutPtr + 0),
        (GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glRectf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[152])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRectfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLfloat *, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[153])(
        (GLfloat *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRecti(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[154])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRectiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLint *, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[155])(
        (GLint *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRects(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[156])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glRectsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLshort *, const GLshort *);
    ((__GLSdispatch)ctx->dispatchCall[157])(
        (GLshort *)(inoutPtr + 0),
        (GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[158])(
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[160])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord1i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[162])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord1s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort);
    ((__GLSdispatch)ctx->dispatchCall[164])(
        *(GLshort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[166])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[168])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[170])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[172])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glTexCoord3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[174])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glTexCoord3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[176])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexCoord3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[178])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexCoord3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[180])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[182])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glTexCoord4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[184])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glTexCoord4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[186])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glTexCoord4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[188])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glVertex2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[190])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glVertex2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[192])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glVertex2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[194])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glVertex2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[196])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glVertex3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[198])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glVertex3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[200])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glVertex3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[202])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glVertex3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[204])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glVertex4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[206])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glVertex4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[208])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glVertex4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[210])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glVertex4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[212])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[214])(
        *(GLenum *)(inoutPtr + 32),
        (GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glColorMaterial(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[215])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glCullFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[216])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glFogf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[217])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFogfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[218])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFogi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[219])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFogiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[220])(
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFrontFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[221])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glHint(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[222])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[223])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[224])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLighti(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[225])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[226])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLightModelf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[227])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightModelfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[228])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightModeli(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[229])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightModeliv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[230])(
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLineStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[231])(
        *(GLint *)(inoutPtr + 0),
        *(GLushort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLineWidth(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[232])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glMaterialf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[233])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[234])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMateriali(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[235])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[236])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glPointSize(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[237])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPolygonMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[238])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[239])(
        (GLubyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glScissor(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[240])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glShadeModel(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[241])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexParameterf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[242])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[243])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexParameteri(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[244])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[245])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[246])(
        *(GLenum *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 28),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 32)
    );
}

void __gls_decode_bin_glTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[247])(
        *(GLenum *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 32),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 36)
    );
}

void __gls_decode_bin_glTexEnvf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[248])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[249])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexEnvi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[250])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[251])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGend(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[252])(
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLdouble *);
    GLenum pname;
    GLint params_count;
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glTexGendv_params_size(pname);
    ((__GLSdispatch)ctx->dispatchCall[253])(
        *(GLenum *)(inoutPtr + 4 + 8 * params_count),
        *(GLenum *)(inoutPtr + 0),
        (GLdouble *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexGenf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[254])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[255])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGeni(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[256])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[257])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glFeedbackBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei size;
    GLfloat *buffer = GLS_NONE;
    size = *(GLsizei *)(inoutPtr + 0);
    buffer = (GLfloat *)__glsContext_allocFeedbackBuf(ctx, 4 * __GLS_MAX(size, 0));
    if (!buffer) {
        __GLS_CALL_ERROR(ctx, 258, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[258])(
        *(GLsizei *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 12),
        (GLfloat *)buffer
    );
end:
    ctx->outArgs = __outArgsSave;
}

void __gls_decode_bin_glSelectBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei size;
    GLuint *buffer = GLS_NONE;
    size = *(GLsizei *)(inoutPtr + 0);
    buffer = (GLuint *)__glsContext_allocSelectBuf(ctx, 4 * __GLS_MAX(size, 0));
    if (!buffer) {
        __GLS_CALL_ERROR(ctx, 259, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[259])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)buffer
    );
end:
    ctx->outArgs = __outArgsSave;
}

void __gls_decode_bin_glRenderMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[260])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glLoadName(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[262])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPassThrough(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[263])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPushName(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[265])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glDrawBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[266])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClear(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbitfield);
    ((__GLSdispatch)ctx->dispatchCall[267])(
        *(GLbitfield *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClearAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[268])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glClearIndex(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[269])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClearColor(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    ((__GLSdispatch)ctx->dispatchCall[270])(
        *(GLclampf *)(inoutPtr + 0),
        *(GLclampf *)(inoutPtr + 4),
        *(GLclampf *)(inoutPtr + 8),
        *(GLclampf *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glClearStencil(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[271])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClearDepth(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampd);
    ((__GLSdispatch)ctx->dispatchCall[272])(
        *(GLclampd *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glStencilMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[273])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glColorMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLboolean, GLboolean, GLboolean, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[274])(
        *(GLboolean *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 1),
        *(GLboolean *)(inoutPtr + 2),
        *(GLboolean *)(inoutPtr + 3)
    );
}

void __gls_decode_bin_glDepthMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[275])(
        *(GLboolean *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[276])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[277])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glDisable(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[278])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEnable(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[279])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPushAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbitfield);
    ((__GLSdispatch)ctx->dispatchCall[283])(
        *(GLbitfield *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glMap1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[284])(
        *(GLenum *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 12),
        *(GLdouble *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        (GLdouble *)(inoutPtr + 28)
    );
}

void __gls_decode_bin_glMap1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[285])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 12),
        *(GLfloat *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        (GLfloat *)(inoutPtr + 20)
    );
}

void __gls_decode_bin_glMap2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[286])(
        *(GLenum *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 20),
        *(GLdouble *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 36),
        *(GLdouble *)(inoutPtr + 44),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        (GLdouble *)(inoutPtr + 52)
    );
}

void __gls_decode_bin_glMap2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[287])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 20),
        *(GLfloat *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 28),
        *(GLfloat *)(inoutPtr + 32),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        (GLfloat *)(inoutPtr + 36)
    );
}

void __gls_decode_bin_glMapGrid1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[288])(
        *(GLint *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMapGrid1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[289])(
        *(GLint *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMapGrid2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[290])(
        *(GLint *)(inoutPtr + 32),
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 36),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glMapGrid2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[291])(
        *(GLint *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLfloat *)(inoutPtr + 16),
        *(GLfloat *)(inoutPtr + 20)
    );
}

void __gls_decode_bin_glEvalCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[292])(
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEvalCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[294])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEvalCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[296])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glEvalCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[298])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glEvalMesh1(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[300])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glEvalPoint1(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[301])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEvalMesh2(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[302])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glEvalPoint2(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[303])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glAlphaFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLclampf);
    ((__GLSdispatch)ctx->dispatchCall[304])(
        *(GLenum *)(inoutPtr + 0),
        *(GLclampf *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glBlendFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[305])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLogicOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[306])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glStencilFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[307])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glStencilOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[308])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glDepthFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[309])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPixelZoom(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[310])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelTransferf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[311])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelTransferi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[312])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelStoref(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[313])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelStorei(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[314])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[315])(
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLuint *);
    ((__GLSdispatch)ctx->dispatchCall[316])(
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLushort *);
    ((__GLSdispatch)ctx->dispatchCall[317])(
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0),
        (GLushort *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glReadBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[318])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glCopyPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[319])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glReadPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    width = *(GLsizei *)(inoutPtr + 0);
    height = *(GLsizei *)(inoutPtr + 4);
    format = *(GLenum *)(inoutPtr + 8);
    type = *(GLenum *)(inoutPtr + 12);
    pixels_count = __gls_glReadPixels_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_BIN(pixels, GLvoid, 1 * pixels_count);
    if (!pixels) {
        __GLS_CALL_ERROR(ctx, 320, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 16);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[320])(
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLsizei *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
}

void __gls_decode_bin_glDrawPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[321])(
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 20)
    );
}

void __gls_decode_bin_glGetBooleanv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLboolean *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetBooleanv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLboolean, 1 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 322, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[322])(
        *(GLenum *)(inoutPtr + 0),
        (GLboolean *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLdouble equation[4];
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[323])(
        *(GLenum *)(inoutPtr + 8),
        equation
    );
    ctx->outArgs = __outArgsSave;
}

void __gls_decode_bin_glGetDoublev(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetDoublev_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLdouble, 8 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 324, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[324])(
        *(GLenum *)(inoutPtr + 0),
        (GLdouble *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetFloatv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetFloatv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 326, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[326])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetIntegerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetIntegerv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 327, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[327])(
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetLightfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 328, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[328])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetLightiv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 329, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[329])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetMapdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum query;
    GLint v_count;
    GLdouble *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    target = *(GLenum *)(inoutPtr + 0);
    query = *(GLenum *)(inoutPtr + 4);
    v_count = __gls_glGetMapdv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_BIN(v, GLdouble, 8 * v_count);
    if (!v) {
        __GLS_CALL_ERROR(ctx, 330, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 8);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[330])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLdouble *)v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
}

void __gls_decode_bin_glGetMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum query;
    GLint v_count;
    GLfloat *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    target = *(GLenum *)(inoutPtr + 0);
    query = *(GLenum *)(inoutPtr + 4);
    v_count = __gls_glGetMapfv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_BIN(v, GLfloat, 4 * v_count);
    if (!v) {
        __GLS_CALL_ERROR(ctx, 331, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 8);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[331])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLfloat *)v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
}

void __gls_decode_bin_glGetMapiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum query;
    GLint v_count;
    GLint *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    target = *(GLenum *)(inoutPtr + 0);
    query = *(GLenum *)(inoutPtr + 4);
    v_count = __gls_glGetMapiv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_BIN(v, GLint, 4 * v_count);
    if (!v) {
        __GLS_CALL_ERROR(ctx, 332, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 8);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[332])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLint *)v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
}

void __gls_decode_bin_glGetMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMaterialfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 333, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[333])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMaterialiv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 334, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[334])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum map;
    GLint values_count;
    GLfloat *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    map = *(GLenum *)(inoutPtr + 0);
    values_count = __gls_glGetPixelMapfv_values_size(ctx, map);
    __GLS_DEC_ALLOC_BIN(values, GLfloat, 4 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 335, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[335])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}

void __gls_decode_bin_glGetPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum map;
    GLint values_count;
    GLuint *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    map = *(GLenum *)(inoutPtr + 0);
    values_count = __gls_glGetPixelMapuiv_values_size(ctx, map);
    __GLS_DEC_ALLOC_BIN(values, GLuint, 4 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 336, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[336])(
        *(GLenum *)(inoutPtr + 0),
        (GLuint *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}

void __gls_decode_bin_glGetPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLushort *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum map;
    GLint values_count;
    GLushort *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    map = *(GLenum *)(inoutPtr + 0);
    values_count = __gls_glGetPixelMapusv_values_size(ctx, map);
    __GLS_DEC_ALLOC_BIN(values, GLushort, 2 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 337, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[337])(
        *(GLenum *)(inoutPtr + 0),
        (GLushort *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}

void __gls_decode_bin_glGetPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLint mask_count;
    GLubyte *mask = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(mask)
    mask_count = __gls_glGetPolygonStipple_mask_size();
    __GLS_DEC_ALLOC_BIN(mask, GLubyte, 1 * mask_count);
    if (!mask) {
        __GLS_CALL_ERROR(ctx, 338, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[338])(
        (GLubyte *)mask
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(mask);
}

void __gls_decode_bin_glGetString(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[339])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glGetTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexEnvfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 340, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[340])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexEnviv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 341, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[341])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexGendv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLdouble, 8 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 342, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[342])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLdouble *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexGenfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 343, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[343])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexGeniv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 344, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[344])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexImage(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    target = *(GLenum *)(inoutPtr + 0);
    level = *(GLint *)(inoutPtr + 4);
    format = *(GLenum *)(inoutPtr + 8);
    type = *(GLenum *)(inoutPtr + 12);
    pixels_count = __gls_glGetTexImage_pixels_size(ctx, target, level, format, type);
    __GLS_DEC_ALLOC_BIN(pixels, GLvoid, 1 * pixels_count);
    if (!pixels) {
        __GLS_CALL_ERROR(ctx, 345, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 16);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[345])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
}

void __gls_decode_bin_glGetTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 346, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[346])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 347, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[347])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexLevelParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexLevelParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 348, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[348])(
        *(GLenum *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexLevelParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexLevelParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 349, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[349])(
        *(GLenum *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glIsEnabled(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[350])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIsList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[351])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glDepthRange(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampd, GLclampd);
    ((__GLSdispatch)ctx->dispatchCall[352])(
        *(GLclampd *)(inoutPtr + 0),
        *(GLclampd *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glFrustum(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[353])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24),
        *(GLdouble *)(inoutPtr + 32),
        *(GLdouble *)(inoutPtr + 40)
    );
}

void __gls_decode_bin_glMatrixMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[357])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glOrtho(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[360])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24),
        *(GLdouble *)(inoutPtr + 32),
        *(GLdouble *)(inoutPtr + 40)
    );
}

void __gls_decode_bin_glRotated(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[363])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glRotatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[364])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glScaled(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[365])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glScalef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[366])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTranslated(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[367])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glTranslatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[368])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glViewport(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[369])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12)
    );
}

#if __GL_EXT_blend_color
void __gls_decode_bin_glBlendColorEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    ((__GLSdispatch)ctx->dispatchCall[384])(
        *(GLclampf *)(inoutPtr + 0),
        *(GLclampf *)(inoutPtr + 4),
        *(GLclampf *)(inoutPtr + 8),
        *(GLclampf *)(inoutPtr + 12)
    );
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_decode_bin_glBlendEquationEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[385])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_decode_bin_glPolygonOffsetEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[386])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}
#endif /* __GL_EXT_polygon_offset */

void __gls_decode_bin_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[383])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

#if __GL_EXT_subtexture
void __gls_decode_bin_glTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[387])(
        *(GLenum *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[396])(
        *(GLenum *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 28)
    );
}

#if __GL_EXT_subtexture
void __gls_decode_bin_glTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[388])(
        *(GLenum *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 36)
    );
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[397])(
        *(GLenum *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 36)
    );
}

#if __GL_SGIS_multisample
void __gls_decode_bin_glSampleMaskSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampf, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[389])(
        *(GLclampf *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 4)
    );
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_decode_bin_glSamplePatternSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[390])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_SGIS_multisample */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[392])(
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 24)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[393])(
        *(GLenum *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameterfEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[394])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[395])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameteriEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[396])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[397])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glCopyConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[398])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glCopyConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[399])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetConvolutionFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    image_count = __gls_glGetConvolutionFilterEXT_image_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(image, GLvoid, 1 * image_count);
    if (!image) {
        __GLS_CALL_ERROR(ctx, 65504, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[400])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)image
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(image);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetConvolutionParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65505, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[401])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetConvolutionParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65506, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[402])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetSeparableFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLint column_count;
    GLint span_count;
    GLvoid *row = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(row)
    GLvoid *column = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(column)
    GLvoid *span = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(span)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    row_count = __gls_glGetSeparableFilterEXT_row_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(row, GLvoid, 1 * row_count);
    if (!row) {
        __GLS_CALL_ERROR(ctx, 65507, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    column_count = __gls_glGetSeparableFilterEXT_column_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(column, GLvoid, 1 * column_count);
    if (!column) {
        __GLS_CALL_ERROR(ctx, 65507, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[1] = *(GLulong*)(inoutPtr + 20);
    span_count = __gls_glGetSeparableFilterEXT_span_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(span, GLvoid, 1 * span_count);
    if (!span) {
        __GLS_CALL_ERROR(ctx, 65507, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[2] = *(GLulong*)(inoutPtr + 28);
    ctx->outArgs.count = 3;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[403])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)row,
        (GLvoid *)column,
        (GLvoid *)span
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(row);
    __GLS_DEC_FREE(column);
    __GLS_DEC_FREE(span);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glSeparableFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
    GLenum target;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint row_count;
    target = *(GLenum *)(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 20);
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[404])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        (GLvoid *)(inoutPtr + 28),
        (GLvoid *)(inoutPtr + 28 + 1 * row_count)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    values_count = __gls_glGetHistogramEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(values, GLvoid, 1 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 65509, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[405])(
        *(GLenum *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetHistogramParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetHistogramParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65510, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[406])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetHistogramParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetHistogramParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65511, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[407])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    values_count = __gls_glGetMinmaxEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(values, GLvoid, 1 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 65512, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[408])(
        *(GLenum *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetMinmaxParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMinmaxParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65513, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[409])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetMinmaxParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMinmaxParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65514, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[410])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[411])(
        *(GLenum *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLboolean *)(inoutPtr + 12)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[412])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLboolean *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glResetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[413])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glResetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[414])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_decode_bin_glTexImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[415])(
        *(GLenum *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLenum *)(inoutPtr + 32),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 36),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 40)
    );
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture
void __gls_decode_bin_glTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[416])(
        *(GLenum *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLint *)(inoutPtr + 36),
        *(GLint *)(inoutPtr + 40),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        (GLvoid *)(inoutPtr + 44)
    );
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_glDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[417])(
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_glGetDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    target = *(GLenum *)(inoutPtr + 0);
    points_count = __gls_glGetDetailTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_BIN(points, GLfloat, 4 * points_count);
    if (!points) {
        __GLS_CALL_ERROR(ctx, 65490, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[418])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_glSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[419])(
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_glGetSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    target = *(GLenum *)(inoutPtr + 0);
    points_count = __gls_glGetSharpenTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_BIN(points, GLfloat, 4 * points_count);
    if (!points) {
        __GLS_CALL_ERROR(ctx, 65492, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[420])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void __gls_decode_bin_glArrayElementEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[437])(
        *(GLint *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    __glsSetArrayState(ctx, inoutPtr);
    ((__GLSdispatch)ctx->dispatchCall[370])(
        0
    );
    __glsDisableArrayState(ctx, *(GLuint *)inoutPtr);
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glColorPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    size = *(GLint *)(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65494, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65494, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 16, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 16;
    ((__GLSdispatch)ctx->dispatchCall[438])(
        *(GLint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because ColorPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glDrawArraysEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[439])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    __glsSetArrayState(ctx, inoutPtr+4);
    ((__GLSdispatch)ctx->dispatchCall[374])(
        *(GLenum *)(inoutPtr + 0),
        0,
        *(GLint *)(inoutPtr + 8)
    );
    __glsDisableArrayState(ctx, *(GLuint *)(inoutPtr+12));
}

void __gls_decode_bin_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr) {
    GLsizei count;
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, const GLvoid *);
    __glsSetArrayState(ctx, inoutPtr+8);
    count = *(GLsizei *)(inoutPtr+4);
    ((__GLSdispatch)ctx->dispatchCall[375])(
        *(GLenum *)(inoutPtr+0),
        count,
        GL_UNSIGNED_INT,
        inoutPtr + *(GLint *)(inoutPtr+8) + 8 - count*sizeof(GLuint)
    );
    __glsDisableArrayState(ctx, *(GLuint *)(inoutPtr+16));
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glEdgeFlagPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, const GLboolean *);
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLboolean *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    stride = *(GLsizei *)(inoutPtr + 0);
    count = *(GLsizei *)(inoutPtr + 4);
    pointer_count = __gls_glEdgeFlagPointerEXT_pointer_size(stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65496, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65496, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 8, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 8;
    ((__GLSdispatch)ctx->dispatchCall[440])(
        *(GLsizei *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        (GLboolean *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because EdgeFlagPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glGetPointervEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLvoid* params[1];
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[441])(
        *(GLenum *)(inoutPtr + 8),
        params
    );
    ctx->outArgs = __outArgsSave;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLvoid* params[1];
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[393])(
        *(GLenum *)(inoutPtr + 8),
        params
    );
    ctx->outArgs = __outArgsSave;
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glIndexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    type = *(GLenum *)(inoutPtr + 0);
    stride = *(GLsizei *)(inoutPtr + 4);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65498, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65498, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 12, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 12;
    ((__GLSdispatch)ctx->dispatchCall[442])(
        *(GLenum *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because IndexPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glNormalPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    type = *(GLenum *)(inoutPtr + 0);
    stride = *(GLsizei *)(inoutPtr + 4);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65499, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65499, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 12, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 12;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        *(GLenum *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because NormalPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glTexCoordPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    size = *(GLint *)(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65500, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65500, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 16, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 16;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        *(GLint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because TexCoordPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glVertexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    size = *(GLint *)(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65501, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65501, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 16, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 16;
    ((__GLSdispatch)ctx->dispatchCall[445])(
        *(GLint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because VertexPointer isn't captured
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glAreTexturesResidentEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) {
        __GLS_CALL_ERROR(ctx, 65502, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[430])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 12),
        (GLboolean *)residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(residences);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) {
        __GLS_CALL_ERROR(ctx, 65502, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[386])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 12),
        (GLboolean *)residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(residences);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glBindTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[431])(
        *(GLenum *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4)
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[371])(
        *(GLenum *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4)
    );
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glDeleteTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    ((__GLSdispatch)ctx->dispatchCall[432])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4)
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    ((__GLSdispatch)ctx->dispatchCall[391])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4)
    );
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) {
        __GLS_CALL_ERROR(ctx, 65473, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[433])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) {
        __GLS_CALL_ERROR(ctx, 65473, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[392])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glIsTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[434])(
        *(GLuint *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[394])(
        *(GLuint *)(inoutPtr + 0)
    );
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glPrioritizeTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    n = *(GLsizei *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[435])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4),
        (GLclampf *)(inoutPtr + 4 + 4 * __GLS_MAX(n, 0))
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    n = *(GLsizei *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[395])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4),
        (GLclampf *)(inoutPtr + 4 + 4 * __GLS_MAX(n, 0))
    );
}

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[452])(
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 24)
    );
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_decode_bin_glColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[437])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_glColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[438])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_glCopyColorTableSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[439])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16)
    );
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glGetColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint table_count;
    GLvoid *table = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(table)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    table_count = __gls_glGetColorTableEXT_table_size(ctx, target, format, type);
    __GLS_DEC_ALLOC_BIN(table, GLvoid, 1 * table_count);
    if (!table) {
        __GLS_CALL_ERROR(ctx, 65480, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[456])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)table
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(table);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glGetColorTableParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetColorTableParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65481, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[457])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glGetColorTableParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetColorTableParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65482, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[458])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glGetTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65483, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glGetTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65484, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[445])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[446])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[447])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[387])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[448])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[388])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[449])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[389])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[450])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[390])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 28)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[451])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 28),
        *(GLsizei *)(inoutPtr + 32)
    );
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_decode_bin_glTexImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[452])(
        *(GLenum *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLenum *)(inoutPtr + 36),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 40),
        *(GLenum *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 24),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 44)
    );
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_decode_bin_glTexSubImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[453])(
        *(GLenum *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLint *)(inoutPtr + 36),
        *(GLint *)(inoutPtr + 40),
        *(GLint *)(inoutPtr + 44),
        *(GLint *)(inoutPtr + 48),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 24),
        (GLvoid *)(inoutPtr + 52)
    );
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_decode_bin_glPixelTexGenSGIX(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[454])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_SGIX_pixel_texture */

#ifdef __GLS_PLATFORM_WIN32
void __gls_decode_bin_glsCallStream(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[18])(
        inoutPtr
    );
}

void __gls_decode_bin_glsRequireExtension(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[31])(
        inoutPtr
    );
}

void __gls_decode_bin_glsBeginObj(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[34])(
        inoutPtr
    );
}

void __gls_decode_bin_glsComment(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[36])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[74])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[76])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[78])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[80])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[82])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[84])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[86])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[88])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[90])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[92])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[94])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[96])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[98])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[100])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[102])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[104])(
        inoutPtr
    );
}

void __gls_decode_bin_glEdgeFlagv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[106])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[109])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[111])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[113])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[115])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[380])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[117])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[119])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[121])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[123])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[125])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[127])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[129])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[131])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[133])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[135])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[137])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[139])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[141])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[143])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[145])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[147])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[149])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[159])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[161])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[163])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[165])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[167])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[169])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[171])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[173])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[175])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[177])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[179])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[181])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[183])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[185])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[187])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[189])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[191])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[193])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[195])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[197])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[199])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[201])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[203])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[205])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[207])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[209])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[211])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[213])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[293])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[295])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[297])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[299])(
        inoutPtr
    );
}

void __gls_decode_bin_glLoadMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[355])(
        inoutPtr
    );
}

void __gls_decode_bin_glLoadMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[356])(
        inoutPtr
    );
}

void __gls_decode_bin_glMultMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[358])(
        inoutPtr
    );
}

void __gls_decode_bin_glMultMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[359])(
        inoutPtr
    );
}
#endif

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[496])(
        *(GLenum *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 24)
    );
}
#endif // __GL_EXT_paletted_texture

void __gls_decode_bin_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[373])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[377])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because InterleavedArrays isn't captured
}

void __gls_decode_bin_glPushClientAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbitfield);
    ((__GLSdispatch)ctx->dispatchCall[398])(
        *(GLbitfield *)(inoutPtr + 0)
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_dspcap.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

extern void __gls_capture_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor);
extern void __gls_capture_glsBlock(GLSenum inBlockType);
extern GLSenum __gls_capture_glsCallStream(const GLubyte *inName);
extern void __gls_capture_glsEndGLS(void);
extern void __gls_capture_glsError(GLSopcode inOpcode, GLSenum inError);
extern void __gls_capture_glsGLRC(GLuint inGLRC);
extern void __gls_capture_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void __gls_capture_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void __gls_capture_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void __gls_capture_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void __gls_capture_glsHeaderf(GLSenum inAttrib, GLfloat inVal);
extern void __gls_capture_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec);
extern void __gls_capture_glsHeaderi(GLSenum inAttrib, GLint inVal);
extern void __gls_capture_glsHeaderiv(GLSenum inAttrib, const GLint *inVec);
extern void __gls_capture_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString);
extern void __gls_capture_glsRequireExtension(const GLubyte *inExtension);
extern void __gls_capture_glsUnsupportedCommand(void);
extern void __gls_capture_glsAppRef(GLulong inAddress, GLuint inCount);
extern void __gls_capture_glsBeginObj(const GLubyte *inTag);
extern void __gls_capture_glsCharubz(const GLubyte *inTag, const GLubyte *inString);
extern void __gls_capture_glsComment(const GLubyte *inComment);
extern void __gls_capture_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void __gls_capture_glsEndObj(void);
extern void __gls_capture_glsNumb(const GLubyte *inTag, GLbyte inVal);
extern void __gls_capture_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void __gls_capture_glsNumd(const GLubyte *inTag, GLdouble inVal);
extern void __gls_capture_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void __gls_capture_glsNumf(const GLubyte *inTag, GLfloat inVal);
extern void __gls_capture_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void __gls_capture_glsNumi(const GLubyte *inTag, GLint inVal);
extern void __gls_capture_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void __gls_capture_glsNuml(const GLubyte *inTag, GLlong inVal);
extern void __gls_capture_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void __gls_capture_glsNums(const GLubyte *inTag, GLshort inVal);
extern void __gls_capture_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void __gls_capture_glsNumub(const GLubyte *inTag, GLubyte inVal);
extern void __gls_capture_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void __gls_capture_glsNumui(const GLubyte *inTag, GLuint inVal);
extern void __gls_capture_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void __gls_capture_glsNumul(const GLubyte *inTag, GLulong inVal);
extern void __gls_capture_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void __gls_capture_glsNumus(const GLubyte *inTag, GLushort inVal);
extern void __gls_capture_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void __gls_capture_glsPad(void);
extern void __gls_capture_glsSwapBuffers(GLuint inLayer);
extern void __gls_capture_glNewList(GLuint list, GLenum mode);
extern void __gls_capture_glEndList(void);
extern void __gls_capture_glCallList(GLuint list);
extern void __gls_capture_glCallLists(GLsizei n, GLenum type, const GLvoid *lists);
extern void __gls_capture_glDeleteLists(GLuint list, GLsizei range);
extern GLuint __gls_capture_glGenLists(GLsizei range);
extern void __gls_capture_glListBase(GLuint base);
extern void __gls_capture_glBegin(GLenum mode);
extern void __gls_capture_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void __gls_capture_glColor3b(GLbyte red, GLbyte green, GLbyte blue);
extern void __gls_capture_glColor3bv(const GLbyte *v);
extern void __gls_capture_glColor3d(GLdouble red, GLdouble green, GLdouble blue);
extern void __gls_capture_glColor3dv(const GLdouble *v);
extern void __gls_capture_glColor3f(GLfloat red, GLfloat green, GLfloat blue);
extern void __gls_capture_glColor3fv(const GLfloat *v);
extern void __gls_capture_glColor3i(GLint red, GLint green, GLint blue);
extern void __gls_capture_glColor3iv(const GLint *v);
extern void __gls_capture_glColor3s(GLshort red, GLshort green, GLshort blue);
extern void __gls_capture_glColor3sv(const GLshort *v);
extern void __gls_capture_glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
extern void __gls_capture_glColor3ubv(const GLubyte *v);
extern void __gls_capture_glColor3ui(GLuint red, GLuint green, GLuint blue);
extern void __gls_capture_glColor3uiv(const GLuint *v);
extern void __gls_capture_glColor3us(GLushort red, GLushort green, GLushort blue);
extern void __gls_capture_glColor3usv(const GLushort *v);
extern void __gls_capture_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void __gls_capture_glColor4bv(const GLbyte *v);
extern void __gls_capture_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void __gls_capture_glColor4dv(const GLdouble *v);
extern void __gls_capture_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glColor4fv(const GLfloat *v);
extern void __gls_capture_glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
extern void __gls_capture_glColor4iv(const GLint *v);
extern void __gls_capture_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void __gls_capture_glColor4sv(const GLshort *v);
extern void __gls_capture_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void __gls_capture_glColor4ubv(const GLubyte *v);
extern void __gls_capture_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void __gls_capture_glColor4uiv(const GLuint *v);
extern void __gls_capture_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void __gls_capture_glColor4usv(const GLushort *v);
extern void __gls_capture_glEdgeFlag(GLboolean flag);
extern void __gls_capture_glEdgeFlagv(const GLboolean *flag);
extern void __gls_capture_glEnd(void);
extern void __gls_capture_glIndexd(GLdouble c);
extern void __gls_capture_glIndexdv(const GLdouble *c);
extern void __gls_capture_glIndexf(GLfloat c);
extern void __gls_capture_glIndexfv(const GLfloat *c);
extern void __gls_capture_glIndexi(GLint c);
extern void __gls_capture_glIndexiv(const GLint *c);
extern void __gls_capture_glIndexs(GLshort c);
extern void __gls_capture_glIndexsv(const GLshort *c);
extern void __gls_capture_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
extern void __gls_capture_glNormal3bv(const GLbyte *v);
extern void __gls_capture_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
extern void __gls_capture_glNormal3dv(const GLdouble *v);
extern void __gls_capture_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
extern void __gls_capture_glNormal3fv(const GLfloat *v);
extern void __gls_capture_glNormal3i(GLint nx, GLint ny, GLint nz);
extern void __gls_capture_glNormal3iv(const GLint *v);
extern void __gls_capture_glNormal3s(GLshort nx, GLshort ny, GLshort nz);
extern void __gls_capture_glNormal3sv(const GLshort *v);
extern void __gls_capture_glRasterPos2d(GLdouble x, GLdouble y);
extern void __gls_capture_glRasterPos2dv(const GLdouble *v);
extern void __gls_capture_glRasterPos2f(GLfloat x, GLfloat y);
extern void __gls_capture_glRasterPos2fv(const GLfloat *v);
extern void __gls_capture_glRasterPos2i(GLint x, GLint y);
extern void __gls_capture_glRasterPos2iv(const GLint *v);
extern void __gls_capture_glRasterPos2s(GLshort x, GLshort y);
extern void __gls_capture_glRasterPos2sv(const GLshort *v);
extern void __gls_capture_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRasterPos3dv(const GLdouble *v);
extern void __gls_capture_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glRasterPos3fv(const GLfloat *v);
extern void __gls_capture_glRasterPos3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glRasterPos3iv(const GLint *v);
extern void __gls_capture_glRasterPos3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glRasterPos3sv(const GLshort *v);
extern void __gls_capture_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glRasterPos4dv(const GLdouble *v);
extern void __gls_capture_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glRasterPos4fv(const GLfloat *v);
extern void __gls_capture_glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glRasterPos4iv(const GLint *v);
extern void __gls_capture_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glRasterPos4sv(const GLshort *v);
extern void __gls_capture_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void __gls_capture_glRectdv(const GLdouble *v1, const GLdouble *v2);
extern void __gls_capture_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void __gls_capture_glRectfv(const GLfloat *v1, const GLfloat *v2);
extern void __gls_capture_glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
extern void __gls_capture_glRectiv(const GLint *v1, const GLint *v2);
extern void __gls_capture_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void __gls_capture_glRectsv(const GLshort *v1, const GLshort *v2);
extern void __gls_capture_glTexCoord1d(GLdouble s);
extern void __gls_capture_glTexCoord1dv(const GLdouble *v);
extern void __gls_capture_glTexCoord1f(GLfloat s);
extern void __gls_capture_glTexCoord1fv(const GLfloat *v);
extern void __gls_capture_glTexCoord1i(GLint s);
extern void __gls_capture_glTexCoord1iv(const GLint *v);
extern void __gls_capture_glTexCoord1s(GLshort s);
extern void __gls_capture_glTexCoord1sv(const GLshort *v);
extern void __gls_capture_glTexCoord2d(GLdouble s, GLdouble t);
extern void __gls_capture_glTexCoord2dv(const GLdouble *v);
extern void __gls_capture_glTexCoord2f(GLfloat s, GLfloat t);
extern void __gls_capture_glTexCoord2fv(const GLfloat *v);
extern void __gls_capture_glTexCoord2i(GLint s, GLint t);
extern void __gls_capture_glTexCoord2iv(const GLint *v);
extern void __gls_capture_glTexCoord2s(GLshort s, GLshort t);
extern void __gls_capture_glTexCoord2sv(const GLshort *v);
extern void __gls_capture_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
extern void __gls_capture_glTexCoord3dv(const GLdouble *v);
extern void __gls_capture_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
extern void __gls_capture_glTexCoord3fv(const GLfloat *v);
extern void __gls_capture_glTexCoord3i(GLint s, GLint t, GLint r);
extern void __gls_capture_glTexCoord3iv(const GLint *v);
extern void __gls_capture_glTexCoord3s(GLshort s, GLshort t, GLshort r);
extern void __gls_capture_glTexCoord3sv(const GLshort *v);
extern void __gls_capture_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void __gls_capture_glTexCoord4dv(const GLdouble *v);
extern void __gls_capture_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void __gls_capture_glTexCoord4fv(const GLfloat *v);
extern void __gls_capture_glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
extern void __gls_capture_glTexCoord4iv(const GLint *v);
extern void __gls_capture_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
extern void __gls_capture_glTexCoord4sv(const GLshort *v);
extern void __gls_capture_glVertex2d(GLdouble x, GLdouble y);
extern void __gls_capture_glVertex2dv(const GLdouble *v);
extern void __gls_capture_glVertex2f(GLfloat x, GLfloat y);
extern void __gls_capture_glVertex2fv(const GLfloat *v);
extern void __gls_capture_glVertex2i(GLint x, GLint y);
extern void __gls_capture_glVertex2iv(const GLint *v);
extern void __gls_capture_glVertex2s(GLshort x, GLshort y);
extern void __gls_capture_glVertex2sv(const GLshort *v);
extern void __gls_capture_glVertex3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glVertex3dv(const GLdouble *v);
extern void __gls_capture_glVertex3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glVertex3fv(const GLfloat *v);
extern void __gls_capture_glVertex3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glVertex3iv(const GLint *v);
extern void __gls_capture_glVertex3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glVertex3sv(const GLshort *v);
extern void __gls_capture_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glVertex4dv(const GLdouble *v);
extern void __gls_capture_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glVertex4fv(const GLfloat *v);
extern void __gls_capture_glVertex4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glVertex4iv(const GLint *v);
extern void __gls_capture_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glVertex4sv(const GLshort *v);
extern void __gls_capture_glClipPlane(GLenum plane, const GLdouble *equation);
extern void __gls_capture_glColorMaterial(GLenum face, GLenum mode);
extern void __gls_capture_glCullFace(GLenum mode);
extern void __gls_capture_glFogf(GLenum pname, GLfloat param);
extern void __gls_capture_glFogfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glFogi(GLenum pname, GLint param);
extern void __gls_capture_glFogiv(GLenum pname, const GLint *params);
extern void __gls_capture_glFrontFace(GLenum mode);
extern void __gls_capture_glHint(GLenum target, GLenum mode);
extern void __gls_capture_glLightf(GLenum light, GLenum pname, GLfloat param);
extern void __gls_capture_glLightfv(GLenum light, GLenum pname, const GLfloat *params);
extern void __gls_capture_glLighti(GLenum light, GLenum pname, GLint param);
extern void __gls_capture_glLightiv(GLenum light, GLenum pname, const GLint *params);
extern void __gls_capture_glLightModelf(GLenum pname, GLfloat param);
extern void __gls_capture_glLightModelfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glLightModeli(GLenum pname, GLint param);
extern void __gls_capture_glLightModeliv(GLenum pname, const GLint *params);
extern void __gls_capture_glLineStipple(GLint factor, GLushort pattern);
extern void __gls_capture_glLineWidth(GLfloat width);
extern void __gls_capture_glMaterialf(GLenum face, GLenum pname, GLfloat param);
extern void __gls_capture_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
extern void __gls_capture_glMateriali(GLenum face, GLenum pname, GLint param);
extern void __gls_capture_glMaterialiv(GLenum face, GLenum pname, const GLint *params);
extern void __gls_capture_glPointSize(GLfloat size);
extern void __gls_capture_glPolygonMode(GLenum face, GLenum mode);
extern void __gls_capture_glPolygonStipple(const GLubyte *mask);
extern void __gls_capture_glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glShadeModel(GLenum mode);
extern void __gls_capture_glTexParameterf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexParameteri(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexEnvf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexEnvi(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexEnviv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexGend(GLenum coord, GLenum pname, GLdouble param);
extern void __gls_capture_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params);
extern void __gls_capture_glTexGenf(GLenum coord, GLenum pname, GLfloat param);
extern void __gls_capture_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexGeni(GLenum coord, GLenum pname, GLint param);
extern void __gls_capture_glTexGeniv(GLenum coord, GLenum pname, const GLint *params);
extern void __gls_capture_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
extern void __gls_capture_glSelectBuffer(GLsizei size, GLuint *buffer);
extern GLint __gls_capture_glRenderMode(GLenum mode);
extern void __gls_capture_glInitNames(void);
extern void __gls_capture_glLoadName(GLuint name);
extern void __gls_capture_glPassThrough(GLfloat token);
extern void __gls_capture_glPopName(void);
extern void __gls_capture_glPushName(GLuint name);
extern void __gls_capture_glDrawBuffer(GLenum mode);
extern void __gls_capture_glClear(GLbitfield mask);
extern void __gls_capture_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glClearIndex(GLfloat c);
extern void __gls_capture_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glClearStencil(GLint s);
extern void __gls_capture_glClearDepth(GLclampd depth);
extern void __gls_capture_glStencilMask(GLuint mask);
extern void __gls_capture_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void __gls_capture_glDepthMask(GLboolean flag);
extern void __gls_capture_glIndexMask(GLuint mask);
extern void __gls_capture_glAccum(GLenum op, GLfloat value);
extern void __gls_capture_glDisable(GLenum cap);
extern void __gls_capture_glEnable(GLenum cap);
extern void __gls_capture_glFinish(void);
extern void __gls_capture_glFlush(void);
extern void __gls_capture_glPopAttrib(void);
extern void __gls_capture_glPushAttrib(GLbitfield mask);
extern void __gls_capture_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void __gls_capture_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void __gls_capture_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void __gls_capture_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void __gls_capture_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
extern void __gls_capture_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
extern void __gls_capture_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void __gls_capture_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void __gls_capture_glEvalCoord1d(GLdouble u);
extern void __gls_capture_glEvalCoord1dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord1f(GLfloat u);
extern void __gls_capture_glEvalCoord1fv(const GLfloat *u);
extern void __gls_capture_glEvalCoord2d(GLdouble u, GLdouble v);
extern void __gls_capture_glEvalCoord2dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord2f(GLfloat u, GLfloat v);
extern void __gls_capture_glEvalCoord2fv(const GLfloat *u);
extern void __gls_capture_glEvalMesh1(GLenum mode, GLint i1, GLint i2);
extern void __gls_capture_glEvalPoint1(GLint i);
extern void __gls_capture_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void __gls_capture_glEvalPoint2(GLint i, GLint j);
extern void __gls_capture_glAlphaFunc(GLenum func, GLclampf ref);
extern void __gls_capture_glBlendFunc(GLenum sfactor, GLenum dfactor);
extern void __gls_capture_glLogicOp(GLenum opcode);
extern void __gls_capture_glStencilFunc(GLenum func, GLint ref, GLuint mask);
extern void __gls_capture_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
extern void __gls_capture_glDepthFunc(GLenum func);
extern void __gls_capture_glPixelZoom(GLfloat xfactor, GLfloat yfactor);
extern void __gls_capture_glPixelTransferf(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelTransferi(GLenum pname, GLint param);
extern void __gls_capture_glPixelStoref(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelStorei(GLenum pname, GLint param);
extern void __gls_capture_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values);
extern void __gls_capture_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values);
extern void __gls_capture_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values);
extern void __gls_capture_glReadBuffer(GLenum mode);
extern void __gls_capture_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void __gls_capture_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glGetBooleanv(GLenum pname, GLboolean *params);
extern void __gls_capture_glGetClipPlane(GLenum plane, GLdouble *equation);
extern void __gls_capture_glGetDoublev(GLenum pname, GLdouble *params);
extern GLenum __gls_capture_glGetError(void);
extern void __gls_capture_glGetFloatv(GLenum pname, GLfloat *params);
extern void __gls_capture_glGetIntegerv(GLenum pname, GLint *params);
extern void __gls_capture_glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetLightiv(GLenum light, GLenum pname, GLint *params);
extern void __gls_capture_glGetMapdv(GLenum target, GLenum query, GLdouble *v);
extern void __gls_capture_glGetMapfv(GLenum target, GLenum query, GLfloat *v);
extern void __gls_capture_glGetMapiv(GLenum target, GLenum query, GLint *v);
extern void __gls_capture_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMaterialiv(GLenum face, GLenum pname, GLint *params);
extern void __gls_capture_glGetPixelMapfv(GLenum map, GLfloat *values);
extern void __gls_capture_glGetPixelMapuiv(GLenum map, GLuint *values);
extern void __gls_capture_glGetPixelMapusv(GLenum map, GLushort *values);
extern void __gls_capture_glGetPolygonStipple(GLubyte *mask);
extern const GLubyte * __gls_capture_glGetString(GLenum name);
extern void __gls_capture_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexEnviv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params);
extern void __gls_capture_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
extern GLboolean __gls_capture_glIsEnabled(GLenum cap);
extern GLboolean __gls_capture_glIsList(GLuint list);
extern void __gls_capture_glDepthRange(GLclampd near, GLclampd far);
extern void __gls_capture_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glLoadIdentity(void);
extern void __gls_capture_glLoadMatrixf(const GLfloat *m);
extern void __gls_capture_glLoadMatrixd(const GLdouble *m);
extern void __gls_capture_glMatrixMode(GLenum mode);
extern void __gls_capture_glMultMatrixf(const GLfloat *m);
extern void __gls_capture_glMultMatrixd(const GLdouble *m);
extern void __gls_capture_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glPopMatrix(void);
extern void __gls_capture_glPushMatrix(void);
extern void __gls_capture_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glScaled(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glScalef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glTranslated(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glTranslatef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glBlendEquationEXT(GLenum mode);
extern void __gls_capture_glPolygonOffsetEXT(GLfloat factor, GLfloat bias);
extern void __gls_capture_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glSampleMaskSGIS(GLclampf value, GLboolean invert);
extern void __gls_capture_glSamplePatternSGIS(GLenum pattern);
extern void __gls_capture_glTagSampleBufferSGIX(void);
extern void __gls_capture_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params);
extern void __gls_capture_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params);
extern void __gls_capture_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void __gls_capture_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern void __gls_capture_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void __gls_capture_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glResetHistogramEXT(GLenum target);
extern void __gls_capture_glResetMinmaxEXT(GLenum target);
extern void __gls_capture_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glArrayElementEXT(GLint i);
extern void __gls_capture_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
extern void __gls_capture_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
extern void __gls_capture_glGetPointervEXT(GLenum pname, GLvoid* *params);
extern void __gls_capture_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern GLboolean __gls_capture_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
extern void __gls_capture_glBindTextureEXT(GLenum target, GLuint texture);
extern void __gls_capture_glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
extern void __gls_capture_glGenTexturesEXT(GLsizei n, GLuint *textures);
extern GLboolean __gls_capture_glIsTextureEXT(GLuint texture);
extern void __gls_capture_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void __gls_capture_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void __gls_capture_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void __gls_capture_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void __gls_capture_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void __gls_capture_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glPixelTexGenSGIX(GLenum mode);

// DrewB - 1.1
extern void __gls_capture_glArrayElement(GLint i);
extern void __gls_capture_glBindTexture(GLenum target, GLuint texture);
extern void __gls_capture_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glDisableClientState(GLenum array);
extern void __gls_capture_glDrawArrays(GLenum mode, GLint first, GLsizei count);
extern void __gls_capture_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void __gls_capture_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glEnableClientState(GLenum array);
extern void __gls_capture_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glIndexub(GLubyte c);
extern void __gls_capture_glIndexubv(const GLubyte *c);
extern void __gls_capture_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glPolygonOffset(GLfloat factor, GLfloat units);
extern void __gls_capture_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences);
extern void __gls_capture_glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
extern void __gls_capture_glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void __gls_capture_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glDeleteTextures(GLsizei n, const GLuint *textures);
extern void __gls_capture_glGenTextures(GLsizei n, GLuint *textures);
extern void __gls_capture_glGetPointerv(GLenum pname, GLvoid* *params);
extern void __gls_capture_glIsTexture(GLuint texture);
extern void __gls_capture_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void __gls_capture_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glPushClientAttrib(GLbitfield mask);
extern void __gls_capture_glPopClientAttrib(void);

// DrewB
extern void __gls_capture_glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
// MarcFo
extern void __gls_capture_glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

const GLSfunc __glsDispatchCapture[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_capture_glsBeginGLS,
    (GLSfunc)__gls_capture_glsBlock,
    (GLSfunc)__gls_capture_glsCallStream,
    (GLSfunc)__gls_capture_glsEndGLS,
    (GLSfunc)__gls_capture_glsError,
    (GLSfunc)__gls_capture_glsGLRC,
    (GLSfunc)__gls_capture_glsGLRCLayer,
    (GLSfunc)__gls_capture_glsHeaderGLRCi,
    (GLSfunc)__gls_capture_glsHeaderLayerf,
    (GLSfunc)__gls_capture_glsHeaderLayeri,
    (GLSfunc)__gls_capture_glsHeaderf,
    (GLSfunc)__gls_capture_glsHeaderfv,
    (GLSfunc)__gls_capture_glsHeaderi,
    (GLSfunc)__gls_capture_glsHeaderiv,
    (GLSfunc)__gls_capture_glsHeaderubz,
    (GLSfunc)__gls_capture_glsRequireExtension,
    (GLSfunc)__gls_capture_glsUnsupportedCommand,
    (GLSfunc)__gls_capture_glsAppRef,
    (GLSfunc)__gls_capture_glsBeginObj,
    (GLSfunc)__gls_capture_glsCharubz,
    (GLSfunc)__gls_capture_glsComment,
    (GLSfunc)__gls_capture_glsDisplayMapfv,
    (GLSfunc)__gls_capture_glsEndObj,
    (GLSfunc)__gls_capture_glsNumb,
    (GLSfunc)__gls_capture_glsNumbv,
    (GLSfunc)__gls_capture_glsNumd,
    (GLSfunc)__gls_capture_glsNumdv,
    (GLSfunc)__gls_capture_glsNumf,
    (GLSfunc)__gls_capture_glsNumfv,
    (GLSfunc)__gls_capture_glsNumi,
    (GLSfunc)__gls_capture_glsNumiv,
    (GLSfunc)__gls_capture_glsNuml,
    (GLSfunc)__gls_capture_glsNumlv,
    (GLSfunc)__gls_capture_glsNums,
    (GLSfunc)__gls_capture_glsNumsv,
    (GLSfunc)__gls_capture_glsNumub,
    (GLSfunc)__gls_capture_glsNumubv,
    (GLSfunc)__gls_capture_glsNumui,
    (GLSfunc)__gls_capture_glsNumuiv,
    (GLSfunc)__gls_capture_glsNumul,
    (GLSfunc)__gls_capture_glsNumulv,
    (GLSfunc)__gls_capture_glsNumus,
    (GLSfunc)__gls_capture_glsNumusv,
    (GLSfunc)__gls_capture_glsPad,
    (GLSfunc)__gls_capture_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_capture_glNewList,
    (GLSfunc)__gls_capture_glEndList,
    (GLSfunc)__gls_capture_glCallList,
    (GLSfunc)__gls_capture_glCallLists,
    (GLSfunc)__gls_capture_glDeleteLists,
    (GLSfunc)__gls_capture_glGenLists,
    (GLSfunc)__gls_capture_glListBase,
    (GLSfunc)__gls_capture_glBegin,
    (GLSfunc)__gls_capture_glBitmap,
    (GLSfunc)__gls_capture_glColor3b,
    (GLSfunc)__gls_capture_glColor3bv,
    (GLSfunc)__gls_capture_glColor3d,
    (GLSfunc)__gls_capture_glColor3dv,
    (GLSfunc)__gls_capture_glColor3f,
    (GLSfunc)__gls_capture_glColor3fv,
    (GLSfunc)__gls_capture_glColor3i,
    (GLSfunc)__gls_capture_glColor3iv,
    (GLSfunc)__gls_capture_glColor3s,
    (GLSfunc)__gls_capture_glColor3sv,
    (GLSfunc)__gls_capture_glColor3ub,
    (GLSfunc)__gls_capture_glColor3ubv,
    (GLSfunc)__gls_capture_glColor3ui,
    (GLSfunc)__gls_capture_glColor3uiv,
    (GLSfunc)__gls_capture_glColor3us,
    (GLSfunc)__gls_capture_glColor3usv,
    (GLSfunc)__gls_capture_glColor4b,
    (GLSfunc)__gls_capture_glColor4bv,
    (GLSfunc)__gls_capture_glColor4d,
    (GLSfunc)__gls_capture_glColor4dv,
    (GLSfunc)__gls_capture_glColor4f,
    (GLSfunc)__gls_capture_glColor4fv,
    (GLSfunc)__gls_capture_glColor4i,
    (GLSfunc)__gls_capture_glColor4iv,
    (GLSfunc)__gls_capture_glColor4s,
    (GLSfunc)__gls_capture_glColor4sv,
    (GLSfunc)__gls_capture_glColor4ub,
    (GLSfunc)__gls_capture_glColor4ubv,
    (GLSfunc)__gls_capture_glColor4ui,
    (GLSfunc)__gls_capture_glColor4uiv,
    (GLSfunc)__gls_capture_glColor4us,
    (GLSfunc)__gls_capture_glColor4usv,
    (GLSfunc)__gls_capture_glEdgeFlag,
    (GLSfunc)__gls_capture_glEdgeFlagv,
    (GLSfunc)__gls_capture_glEnd,
    (GLSfunc)__gls_capture_glIndexd,
    (GLSfunc)__gls_capture_glIndexdv,
    (GLSfunc)__gls_capture_glIndexf,
    (GLSfunc)__gls_capture_glIndexfv,
    (GLSfunc)__gls_capture_glIndexi,
    (GLSfunc)__gls_capture_glIndexiv,
    (GLSfunc)__gls_capture_glIndexs,
    (GLSfunc)__gls_capture_glIndexsv,
    (GLSfunc)__gls_capture_glNormal3b,
    (GLSfunc)__gls_capture_glNormal3bv,
    (GLSfunc)__gls_capture_glNormal3d,
    (GLSfunc)__gls_capture_glNormal3dv,
    (GLSfunc)__gls_capture_glNormal3f,
    (GLSfunc)__gls_capture_glNormal3fv,
    (GLSfunc)__gls_capture_glNormal3i,
    (GLSfunc)__gls_capture_glNormal3iv,
    (GLSfunc)__gls_capture_glNormal3s,
    (GLSfunc)__gls_capture_glNormal3sv,
    (GLSfunc)__gls_capture_glRasterPos2d,
    (GLSfunc)__gls_capture_glRasterPos2dv,
    (GLSfunc)__gls_capture_glRasterPos2f,
    (GLSfunc)__gls_capture_glRasterPos2fv,
    (GLSfunc)__gls_capture_glRasterPos2i,
    (GLSfunc)__gls_capture_glRasterPos2iv,
    (GLSfunc)__gls_capture_glRasterPos2s,
    (GLSfunc)__gls_capture_glRasterPos2sv,
    (GLSfunc)__gls_capture_glRasterPos3d,
    (GLSfunc)__gls_capture_glRasterPos3dv,
    (GLSfunc)__gls_capture_glRasterPos3f,
    (GLSfunc)__gls_capture_glRasterPos3fv,
    (GLSfunc)__gls_capture_glRasterPos3i,
    (GLSfunc)__gls_capture_glRasterPos3iv,
    (GLSfunc)__gls_capture_glRasterPos3s,
    (GLSfunc)__gls_capture_glRasterPos3sv,
    (GLSfunc)__gls_capture_glRasterPos4d,
    (GLSfunc)__gls_capture_glRasterPos4dv,
    (GLSfunc)__gls_capture_glRasterPos4f,
    (GLSfunc)__gls_capture_glRasterPos4fv,
    (GLSfunc)__gls_capture_glRasterPos4i,
    (GLSfunc)__gls_capture_glRasterPos4iv,
    (GLSfunc)__gls_capture_glRasterPos4s,
    (GLSfunc)__gls_capture_glRasterPos4sv,
    (GLSfunc)__gls_capture_glRectd,
    (GLSfunc)__gls_capture_glRectdv,
    (GLSfunc)__gls_capture_glRectf,
    (GLSfunc)__gls_capture_glRectfv,
    (GLSfunc)__gls_capture_glRecti,
    (GLSfunc)__gls_capture_glRectiv,
    (GLSfunc)__gls_capture_glRects,
    (GLSfunc)__gls_capture_glRectsv,
    (GLSfunc)__gls_capture_glTexCoord1d,
    (GLSfunc)__gls_capture_glTexCoord1dv,
    (GLSfunc)__gls_capture_glTexCoord1f,
    (GLSfunc)__gls_capture_glTexCoord1fv,
    (GLSfunc)__gls_capture_glTexCoord1i,
    (GLSfunc)__gls_capture_glTexCoord1iv,
    (GLSfunc)__gls_capture_glTexCoord1s,
    (GLSfunc)__gls_capture_glTexCoord1sv,
    (GLSfunc)__gls_capture_glTexCoord2d,
    (GLSfunc)__gls_capture_glTexCoord2dv,
    (GLSfunc)__gls_capture_glTexCoord2f,
    (GLSfunc)__gls_capture_glTexCoord2fv,
    (GLSfunc)__gls_capture_glTexCoord2i,
    (GLSfunc)__gls_capture_glTexCoord2iv,
    (GLSfunc)__gls_capture_glTexCoord2s,
    (GLSfunc)__gls_capture_glTexCoord2sv,
    (GLSfunc)__gls_capture_glTexCoord3d,
    (GLSfunc)__gls_capture_glTexCoord3dv,
    (GLSfunc)__gls_capture_glTexCoord3f,
    (GLSfunc)__gls_capture_glTexCoord3fv,
    (GLSfunc)__gls_capture_glTexCoord3i,
    (GLSfunc)__gls_capture_glTexCoord3iv,
    (GLSfunc)__gls_capture_glTexCoord3s,
    (GLSfunc)__gls_capture_glTexCoord3sv,
    (GLSfunc)__gls_capture_glTexCoord4d,
    (GLSfunc)__gls_capture_glTexCoord4dv,
    (GLSfunc)__gls_capture_glTexCoord4f,
    (GLSfunc)__gls_capture_glTexCoord4fv,
    (GLSfunc)__gls_capture_glTexCoord4i,
    (GLSfunc)__gls_capture_glTexCoord4iv,
    (GLSfunc)__gls_capture_glTexCoord4s,
    (GLSfunc)__gls_capture_glTexCoord4sv,
    (GLSfunc)__gls_capture_glVertex2d,
    (GLSfunc)__gls_capture_glVertex2dv,
    (GLSfunc)__gls_capture_glVertex2f,
    (GLSfunc)__gls_capture_glVertex2fv,
    (GLSfunc)__gls_capture_glVertex2i,
    (GLSfunc)__gls_capture_glVertex2iv,
    (GLSfunc)__gls_capture_glVertex2s,
    (GLSfunc)__gls_capture_glVertex2sv,
    (GLSfunc)__gls_capture_glVertex3d,
    (GLSfunc)__gls_capture_glVertex3dv,
    (GLSfunc)__gls_capture_glVertex3f,
    (GLSfunc)__gls_capture_glVertex3fv,
    (GLSfunc)__gls_capture_glVertex3i,
    (GLSfunc)__gls_capture_glVertex3iv,
    (GLSfunc)__gls_capture_glVertex3s,
    (GLSfunc)__gls_capture_glVertex3sv,
    (GLSfunc)__gls_capture_glVertex4d,
    (GLSfunc)__gls_capture_glVertex4dv,
    (GLSfunc)__gls_capture_glVertex4f,
    (GLSfunc)__gls_capture_glVertex4fv,
    (GLSfunc)__gls_capture_glVertex4i,
    (GLSfunc)__gls_capture_glVertex4iv,
    (GLSfunc)__gls_capture_glVertex4s,
    (GLSfunc)__gls_capture_glVertex4sv,
    (GLSfunc)__gls_capture_glClipPlane,
    (GLSfunc)__gls_capture_glColorMaterial,
    (GLSfunc)__gls_capture_glCullFace,
    (GLSfunc)__gls_capture_glFogf,
    (GLSfunc)__gls_capture_glFogfv,
    (GLSfunc)__gls_capture_glFogi,
    (GLSfunc)__gls_capture_glFogiv,
    (GLSfunc)__gls_capture_glFrontFace,
    (GLSfunc)__gls_capture_glHint,
    (GLSfunc)__gls_capture_glLightf,
    (GLSfunc)__gls_capture_glLightfv,
    (GLSfunc)__gls_capture_glLighti,
    (GLSfunc)__gls_capture_glLightiv,
    (GLSfunc)__gls_capture_glLightModelf,
    (GLSfunc)__gls_capture_glLightModelfv,
    (GLSfunc)__gls_capture_glLightModeli,
    (GLSfunc)__gls_capture_glLightModeliv,
    (GLSfunc)__gls_capture_glLineStipple,
    (GLSfunc)__gls_capture_glLineWidth,
    (GLSfunc)__gls_capture_glMaterialf,
    (GLSfunc)__gls_capture_glMaterialfv,
    (GLSfunc)__gls_capture_glMateriali,
    (GLSfunc)__gls_capture_glMaterialiv,
    (GLSfunc)__gls_capture_glPointSize,
    (GLSfunc)__gls_capture_glPolygonMode,
    (GLSfunc)__gls_capture_glPolygonStipple,
    (GLSfunc)__gls_capture_glScissor,
    (GLSfunc)__gls_capture_glShadeModel,
    (GLSfunc)__gls_capture_glTexParameterf,
    (GLSfunc)__gls_capture_glTexParameterfv,
    (GLSfunc)__gls_capture_glTexParameteri,
    (GLSfunc)__gls_capture_glTexParameteriv,
    (GLSfunc)__gls_capture_glTexImage1D,
    (GLSfunc)__gls_capture_glTexImage2D,
    (GLSfunc)__gls_capture_glTexEnvf,
    (GLSfunc)__gls_capture_glTexEnvfv,
    (GLSfunc)__gls_capture_glTexEnvi,
    (GLSfunc)__gls_capture_glTexEnviv,
    (GLSfunc)__gls_capture_glTexGend,
    (GLSfunc)__gls_capture_glTexGendv,
    (GLSfunc)__gls_capture_glTexGenf,
    (GLSfunc)__gls_capture_glTexGenfv,
    (GLSfunc)__gls_capture_glTexGeni,
    (GLSfunc)__gls_capture_glTexGeniv,
    (GLSfunc)__gls_capture_glFeedbackBuffer,
    (GLSfunc)__gls_capture_glSelectBuffer,
    (GLSfunc)__gls_capture_glRenderMode,
    (GLSfunc)__gls_capture_glInitNames,
    (GLSfunc)__gls_capture_glLoadName,
    (GLSfunc)__gls_capture_glPassThrough,
    (GLSfunc)__gls_capture_glPopName,
    (GLSfunc)__gls_capture_glPushName,
    (GLSfunc)__gls_capture_glDrawBuffer,
    (GLSfunc)__gls_capture_glClear,
    (GLSfunc)__gls_capture_glClearAccum,
    (GLSfunc)__gls_capture_glClearIndex,
    (GLSfunc)__gls_capture_glClearColor,
    (GLSfunc)__gls_capture_glClearStencil,
    (GLSfunc)__gls_capture_glClearDepth,
    (GLSfunc)__gls_capture_glStencilMask,
    (GLSfunc)__gls_capture_glColorMask,
    (GLSfunc)__gls_capture_glDepthMask,
    (GLSfunc)__gls_capture_glIndexMask,
    (GLSfunc)__gls_capture_glAccum,
    (GLSfunc)__gls_capture_glDisable,
    (GLSfunc)__gls_capture_glEnable,
    (GLSfunc)__gls_capture_glFinish,
    (GLSfunc)__gls_capture_glFlush,
    (GLSfunc)__gls_capture_glPopAttrib,
    (GLSfunc)__gls_capture_glPushAttrib,
    (GLSfunc)__gls_capture_glMap1d,
    (GLSfunc)__gls_capture_glMap1f,
    (GLSfunc)__gls_capture_glMap2d,
    (GLSfunc)__gls_capture_glMap2f,
    (GLSfunc)__gls_capture_glMapGrid1d,
    (GLSfunc)__gls_capture_glMapGrid1f,
    (GLSfunc)__gls_capture_glMapGrid2d,
    (GLSfunc)__gls_capture_glMapGrid2f,
    (GLSfunc)__gls_capture_glEvalCoord1d,
    (GLSfunc)__gls_capture_glEvalCoord1dv,
    (GLSfunc)__gls_capture_glEvalCoord1f,
    (GLSfunc)__gls_capture_glEvalCoord1fv,
    (GLSfunc)__gls_capture_glEvalCoord2d,
    (GLSfunc)__gls_capture_glEvalCoord2dv,
    (GLSfunc)__gls_capture_glEvalCoord2f,
    (GLSfunc)__gls_capture_glEvalCoord2fv,
    (GLSfunc)__gls_capture_glEvalMesh1,
    (GLSfunc)__gls_capture_glEvalPoint1,
    (GLSfunc)__gls_capture_glEvalMesh2,
    (GLSfunc)__gls_capture_glEvalPoint2,
    (GLSfunc)__gls_capture_glAlphaFunc,
    (GLSfunc)__gls_capture_glBlendFunc,
    (GLSfunc)__gls_capture_glLogicOp,
    (GLSfunc)__gls_capture_glStencilFunc,
    (GLSfunc)__gls_capture_glStencilOp,
    (GLSfunc)__gls_capture_glDepthFunc,
    (GLSfunc)__gls_capture_glPixelZoom,
    (GLSfunc)__gls_capture_glPixelTransferf,
    (GLSfunc)__gls_capture_glPixelTransferi,
    (GLSfunc)__gls_capture_glPixelStoref,
    (GLSfunc)__gls_capture_glPixelStorei,
    (GLSfunc)__gls_capture_glPixelMapfv,
    (GLSfunc)__gls_capture_glPixelMapuiv,
    (GLSfunc)__gls_capture_glPixelMapusv,
    (GLSfunc)__gls_capture_glReadBuffer,
    (GLSfunc)__gls_capture_glCopyPixels,
    (GLSfunc)__gls_capture_glReadPixels,
    (GLSfunc)__gls_capture_glDrawPixels,
    (GLSfunc)__gls_capture_glGetBooleanv,
    (GLSfunc)__gls_capture_glGetClipPlane,
    (GLSfunc)__gls_capture_glGetDoublev,
    (GLSfunc)__gls_capture_glGetError,
    (GLSfunc)__gls_capture_glGetFloatv,
    (GLSfunc)__gls_capture_glGetIntegerv,
    (GLSfunc)__gls_capture_glGetLightfv,
    (GLSfunc)__gls_capture_glGetLightiv,
    (GLSfunc)__gls_capture_glGetMapdv,
    (GLSfunc)__gls_capture_glGetMapfv,
    (GLSfunc)__gls_capture_glGetMapiv,
    (GLSfunc)__gls_capture_glGetMaterialfv,
    (GLSfunc)__gls_capture_glGetMaterialiv,
    (GLSfunc)__gls_capture_glGetPixelMapfv,
    (GLSfunc)__gls_capture_glGetPixelMapuiv,
    (GLSfunc)__gls_capture_glGetPixelMapusv,
    (GLSfunc)__gls_capture_glGetPolygonStipple,
    (GLSfunc)__gls_capture_glGetString,
    (GLSfunc)__gls_capture_glGetTexEnvfv,
    (GLSfunc)__gls_capture_glGetTexEnviv,
    (GLSfunc)__gls_capture_glGetTexGendv,
    (GLSfunc)__gls_capture_glGetTexGenfv,
    (GLSfunc)__gls_capture_glGetTexGeniv,
    (GLSfunc)__gls_capture_glGetTexImage,
    (GLSfunc)__gls_capture_glGetTexParameterfv,
    (GLSfunc)__gls_capture_glGetTexParameteriv,
    (GLSfunc)__gls_capture_glGetTexLevelParameterfv,
    (GLSfunc)__gls_capture_glGetTexLevelParameteriv,
    (GLSfunc)__gls_capture_glIsEnabled,
    (GLSfunc)__gls_capture_glIsList,
    (GLSfunc)__gls_capture_glDepthRange,
    (GLSfunc)__gls_capture_glFrustum,
    (GLSfunc)__gls_capture_glLoadIdentity,
    (GLSfunc)__gls_capture_glLoadMatrixf,
    (GLSfunc)__gls_capture_glLoadMatrixd,
    (GLSfunc)__gls_capture_glMatrixMode,
    (GLSfunc)__gls_capture_glMultMatrixf,
    (GLSfunc)__gls_capture_glMultMatrixd,
    (GLSfunc)__gls_capture_glOrtho,
    (GLSfunc)__gls_capture_glPopMatrix,
    (GLSfunc)__gls_capture_glPushMatrix,
    (GLSfunc)__gls_capture_glRotated,
    (GLSfunc)__gls_capture_glRotatef,
    (GLSfunc)__gls_capture_glScaled,
    (GLSfunc)__gls_capture_glScalef,
    (GLSfunc)__gls_capture_glTranslated,
    (GLSfunc)__gls_capture_glTranslatef,
    (GLSfunc)__gls_capture_glViewport,
    // DrewB - 1.1
    (GLSfunc)__gls_capture_glArrayElement,
    (GLSfunc)__gls_capture_glBindTexture,
    (GLSfunc)__gls_capture_glColorPointer,
    (GLSfunc)__gls_capture_glDisableClientState,
    (GLSfunc)__gls_capture_glDrawArrays,
    (GLSfunc)__gls_capture_glDrawElements,
    (GLSfunc)__gls_capture_glEdgeFlagPointer,
    (GLSfunc)__gls_capture_glEnableClientState,
    (GLSfunc)__gls_capture_glIndexPointer,
    (GLSfunc)__gls_capture_glIndexub,
    (GLSfunc)__gls_capture_glIndexubv,
    (GLSfunc)__gls_capture_glInterleavedArrays,
    (GLSfunc)__gls_capture_glNormalPointer,
    (GLSfunc)__gls_capture_glPolygonOffset,
    (GLSfunc)__gls_capture_glTexCoordPointer,
    (GLSfunc)__gls_capture_glVertexPointer,
    (GLSfunc)__gls_capture_glAreTexturesResident,
    (GLSfunc)__gls_capture_glCopyTexImage1D,
    (GLSfunc)__gls_capture_glCopyTexImage2D,
    (GLSfunc)__gls_capture_glCopyTexSubImage1D,
    (GLSfunc)__gls_capture_glCopyTexSubImage2D,
    (GLSfunc)__gls_capture_glDeleteTextures,
    (GLSfunc)__gls_capture_glGenTextures,
    (GLSfunc)__gls_capture_glGetPointerv,
    (GLSfunc)__gls_capture_glIsTexture,
    (GLSfunc)__gls_capture_glPrioritizeTextures,
    (GLSfunc)__gls_capture_glTexSubImage1D,
    (GLSfunc)__gls_capture_glTexSubImage2D,
    (GLSfunc)__gls_capture_glPushClientAttrib,
    (GLSfunc)__gls_capture_glPopClientAttrib,
    #if __GL_EXT_blend_color
        (GLSfunc)__gls_capture_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        (GLSfunc)__gls_capture_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        (GLSfunc)__gls_capture_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_capture_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_capture_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_capture_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_capture_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        (GLSfunc)__gls_capture_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        (GLSfunc)__gls_capture_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture && __GL_EXT_texture3D
        (GLSfunc)__gls_capture_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_capture_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_capture_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_capture_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_capture_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_capture_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_capture_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_capture_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture && __GL_EXT_texture3D
        (GLSfunc)__gls_capture_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_capture_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_capture_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        (GLSfunc)__gls_capture_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        // DrewB
        (GLSfunc)__gls_capture_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    #if __GL_WIN_draw_range_elements
        // MarcFo
        (GLSfunc)__gls_capture_glDrawRangeElementsWIN,
    #else
        GLS_NONE,
    #endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_decswp.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

// DrewB - All functions changed to use passed in context

void __gls_decode_bin_swap_glsBeginGLS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsBeginGLS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsBeginGLS(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsBlock(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsBlock(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsBlock(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsCallStream(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[18])(inoutPtr);
}

void __gls_decode_bin_swap_glsEndGLS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[19])();
}

void __gls_decode_bin_swap_glsError(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsError(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsError(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsGLRC(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsGLRC(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsGLRC(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsGLRCLayer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsGLRCLayer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsGLRCLayer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderGLRCi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderGLRCi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsHeaderGLRCi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderLayerf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderLayerf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsHeaderLayerf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderLayeri(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderLayeri(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsHeaderLayeri(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsHeaderf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderfv(__GLScontext *, GLubyte *);
    GLSenum inAttrib;
    GLint inVec_count;
    __glsSwap4(inoutPtr + 0);
    inAttrib = *(GLSenum *)(inoutPtr + 0);
    inVec_count = __gls_glsHeaderfv_inVec_size(inAttrib);
    __glsSwap4v(inVec_count, inoutPtr + 4);
    __gls_decode_bin_glsHeaderfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsHeaderi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderiv(__GLScontext *, GLubyte *);
    GLSenum inAttrib;
    GLint inVec_count;
    __glsSwap4(inoutPtr + 0);
    inAttrib = *(GLSenum *)(inoutPtr + 0);
    inVec_count = __gls_glsHeaderiv_inVec_size(inAttrib);
    __glsSwap4v(inVec_count, inoutPtr + 4);
    __gls_decode_bin_glsHeaderiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderubz(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsHeaderubz(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsRequireExtension(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[31])(inoutPtr);
}

void __gls_decode_bin_swap_glsUnsupportedCommand(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[32])();
}

void __gls_decode_bin_swap_glsAppRef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsAppRef(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsAppRef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsBeginObj(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[34])(inoutPtr);
}

void __gls_decode_bin_swap_glsCharubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsCharubz(__GLScontext *, GLubyte *);
    __gls_decode_bin_glsCharubz(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsComment(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[36])(inoutPtr);
}

void __gls_decode_bin_swap_glsDisplayMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsDisplayMapfv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 12);
    __gls_decode_bin_glsDisplayMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsEndObj(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[38])();
}

void __gls_decode_bin_swap_glsNumb(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumb(__GLScontext *, GLubyte *);
    __gls_decode_bin_glsNumb(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumbv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumbv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumbv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumd(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumd(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glsNumd(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumdv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap8v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumdv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumfv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumiv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNuml(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNuml(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glsNuml(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumlv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumlv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap8v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumlv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNums(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNums(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glsNums(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumsv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap2v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumsv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glsNumub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumubv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumubv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumui(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumui(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumui(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumuiv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumuiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumul(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumul(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glsNumul(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumulv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumulv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap8v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumulv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumus(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumus(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glsNumus(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumusv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap2v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumusv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsPad(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[59])();
}

void __gls_decode_bin_swap_glsSwapBuffers(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsSwapBuffers(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsSwapBuffers(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNewList(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNewList(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glNewList(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEndList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[65])();
}

void __gls_decode_bin_swap_glCallList(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCallList(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glCallList(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glCallLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCallLists(__GLScontext *, GLubyte *);
    GLsizei n;
    GLenum type;
    GLint lists_count;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    lists_count = __gls_glCallLists_lists_size(n, type);
    __glsSwapv(type, lists_count, inoutPtr + 8);
    __gls_decode_bin_glCallLists(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDeleteLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDeleteLists(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glDeleteLists(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGenLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGenLists(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glGenLists(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glListBase(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glListBase(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glListBase(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glBegin(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBegin(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glBegin(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glBitmap(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBitmap(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __gls_decode_bin_glBitmap(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3b(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor3b(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[74])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glColor3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[76])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glColor3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[78])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glColor3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[80])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glColor3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[82])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3ub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor3ub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[84])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3ui(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glColor3ui(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[86])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3us(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3us(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glColor3us(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[88])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4b(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4b(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor4b(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[90])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glColor4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[92])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glColor4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[94])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glColor4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[96])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glColor4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[98])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4ub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor4ub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[100])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4ui(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glColor4ui(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[102])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4us(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4us(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glColor4us(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[104])(inoutPtr);
}

void __gls_decode_bin_swap_glEdgeFlag(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEdgeFlag(__GLScontext *, GLubyte *);
    __gls_decode_bin_glEdgeFlag(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEdgeFlagv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[106])(inoutPtr);
}

void __gls_decode_bin_swap_glEnd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[107])();
}

void __gls_decode_bin_swap_glIndexd(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexd(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glIndexd(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[109])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIndexf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[111])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIndexi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[113])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexs(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexs(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glIndexs(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[115])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glIndexub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[380])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3b(__GLScontext *, GLubyte *);
    __gls_decode_bin_glNormal3b(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[117])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glNormal3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[119])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glNormal3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[121])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glNormal3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[123])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glNormal3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[125])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glRasterPos2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[127])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glRasterPos2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[129])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glRasterPos2i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[131])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __gls_decode_bin_glRasterPos2s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[133])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glRasterPos3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[135])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glRasterPos3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[137])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glRasterPos3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[139])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glRasterPos3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[141])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glRasterPos4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[143])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRasterPos4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[145])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRasterPos4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[147])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glRasterPos4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[149])(inoutPtr);
}

void __gls_decode_bin_swap_glRectd(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectd(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glRectd(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectdv(__GLScontext *, GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    __glsSwap8v(2, inoutPtr + 16);
    __gls_decode_bin_glRectdv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRectf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectfv(__GLScontext *, GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    __glsSwap4v(2, inoutPtr + 8);
    __gls_decode_bin_glRectfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRecti(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRecti(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRecti(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectiv(__GLScontext *, GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    __glsSwap4v(2, inoutPtr + 8);
    __gls_decode_bin_glRectiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRects(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRects(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glRects(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectsv(__GLScontext *, GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    __glsSwap2v(2, inoutPtr + 4);
    __gls_decode_bin_glRectsv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[159])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[161])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[163])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[165])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glTexCoord2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[167])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glTexCoord2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[169])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glTexCoord2i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[171])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __gls_decode_bin_glTexCoord2s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[173])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glTexCoord3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[175])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexCoord3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[177])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexCoord3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[179])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glTexCoord3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[181])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glTexCoord4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[183])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glTexCoord4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[185])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glTexCoord4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[187])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glTexCoord4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[189])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glVertex2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[191])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glVertex2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[193])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glVertex2i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[195])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __gls_decode_bin_glVertex2s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[197])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glVertex3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[199])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glVertex3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[201])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glVertex3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[203])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glVertex3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[205])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glVertex4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[207])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glVertex4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[209])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glVertex4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[211])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glVertex4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[213])(inoutPtr);
}

void __gls_decode_bin_swap_glClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClipPlane(__GLScontext *, GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    __glsSwap4(inoutPtr + 32);
    __gls_decode_bin_glClipPlane(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColorMaterial(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorMaterial(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glColorMaterial(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glCullFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCullFace(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glCullFace(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glFogf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glFogfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glFogfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glFogi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogiv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glFogiv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glFogiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFrontFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFrontFace(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glFrontFace(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glHint(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glHint(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glHint(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glLightf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glLightfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glLightfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLighti(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLighti(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glLighti(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightiv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glLightiv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glLightiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModelf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModelf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glLightModelf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModelfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModelfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glLightModelfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glLightModelfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModeli(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModeli(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glLightModeli(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModeliv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModeliv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glLightModeliv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glLightModeliv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLineStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLineStipple(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glLineStipple(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLineWidth(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLineWidth(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glLineWidth(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMaterialf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMaterialf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glMaterialf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMaterialfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glMaterialfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glMaterialfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMateriali(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMateriali(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glMateriali(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMaterialiv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glMaterialiv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glMaterialiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPointSize(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPointSize(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPointSize(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPolygonMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonMode(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPolygonMode(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonStipple(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPolygonStipple(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glScissor(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glScissor(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glScissor(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glShadeModel(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glShadeModel(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glShadeModel(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameterf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameterf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexParameterf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameterfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexParameterfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexParameterfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameteri(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameteri(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexParameteri(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameteriv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexParameteriv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexParameteriv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage1D(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage1D_pixels_size(format, type, width);
    __glsSwapv(type, pixels_count, inoutPtr + 32);
    __gls_decode_bin_glTexImage1D(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage2D(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage2D_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 36);
    __gls_decode_bin_glTexImage2D(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnvf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnvf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexEnvf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnvfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexEnvfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexEnvfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnvi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnvi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexEnvi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnviv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexEnviv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexEnviv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGend(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGend(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glTexGend(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGendv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glTexGendv_params_size(pname);
    __glsSwap8v(params_count, inoutPtr + 4);
    __glsSwap4(inoutPtr + 4 + 8 * params_count);
    __gls_decode_bin_glTexGendv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGenf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGenf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexGenf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGenfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexGenfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexGenfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGeni(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGeni(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexGeni(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGeniv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexGeniv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexGeniv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFeedbackBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFeedbackBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glFeedbackBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glSelectBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSelectBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glSelectBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRenderMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRenderMode(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glRenderMode(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glInitNames(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[261])();
}

void __gls_decode_bin_swap_glLoadName(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLoadName(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glLoadName(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPassThrough(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPassThrough(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPassThrough(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPopName(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[264])();
}

void __gls_decode_bin_swap_glPushName(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPushName(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPushName(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDrawBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDrawBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClear(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClear(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glClear(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearAccum(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glClearAccum(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearIndex(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearIndex(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glClearIndex(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearColor(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearColor(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glClearColor(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearStencil(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearStencil(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glClearStencil(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearDepth(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearDepth(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glClearDepth(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glStencilMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glStencilMask(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glStencilMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColorMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorMask(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColorMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDepthMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDepthMask(__GLScontext *, GLubyte *);
    __gls_decode_bin_glDepthMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexMask(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIndexMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAccum(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glAccum(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDisable(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDisable(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDisable(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEnable(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEnable(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEnable(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFinish(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[280])();
}

void __gls_decode_bin_swap_glFlush(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[281])();
}

void __gls_decode_bin_swap_glPopAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[282])();
}

void __gls_decode_bin_swap_glPushAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPushAttrib(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPushAttrib(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap1d(__GLScontext *, GLubyte *);
    GLenum target;
    GLint stride;
    GLint order;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    order = *(GLint *)(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __glsSwap8(inoutPtr + 20);
    points_count = __gls_glMap1d_points_size(target, stride, order);
    __glsSwap8v(points_count, inoutPtr + 28);
    __gls_decode_bin_glMap1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap1f(__GLScontext *, GLubyte *);
    GLenum target;
    GLint stride;
    GLint order;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    order = *(GLint *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    points_count = __gls_glMap1f_points_size(target, stride, order);
    __glsSwap4v(points_count, inoutPtr + 20);
    __gls_decode_bin_glMap1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap2d(__GLScontext *, GLubyte *);
    GLenum target;
    GLint ustride;
    GLint uorder;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    ustride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    uorder = *(GLint *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    vstride = *(GLint *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    vorder = *(GLint *)(inoutPtr + 16);
    __glsSwap8(inoutPtr + 20);
    __glsSwap8(inoutPtr + 28);
    __glsSwap8(inoutPtr + 36);
    __glsSwap8(inoutPtr + 44);
    points_count = __gls_glMap2d_points_size(target, ustride, uorder, vstride, vorder);
    __glsSwap8v(points_count, inoutPtr + 52);
    __gls_decode_bin_glMap2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap2f(__GLScontext *, GLubyte *);
    GLenum target;
    GLint ustride;
    GLint uorder;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    ustride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    uorder = *(GLint *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    vstride = *(GLint *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    vorder = *(GLint *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    points_count = __gls_glMap2f_points_size(target, ustride, uorder, vstride, vorder);
    __glsSwap4v(points_count, inoutPtr + 36);
    __gls_decode_bin_glMap2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid1d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glMapGrid1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid1f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glMapGrid1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __gls_decode_bin_glMapGrid2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glMapGrid2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord1d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glEvalCoord1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[293])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord1f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEvalCoord1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[295])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glEvalCoord2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[297])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glEvalCoord2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[299])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalMesh1(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalMesh1(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glEvalMesh1(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalPoint1(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalPoint1(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEvalPoint1(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalMesh2(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalMesh2(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glEvalMesh2(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalPoint2(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalPoint2(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glEvalPoint2(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glAlphaFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAlphaFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glAlphaFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glBlendFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBlendFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glBlendFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLogicOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLogicOp(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glLogicOp(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glStencilFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glStencilFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glStencilFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glStencilOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glStencilOp(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glStencilOp(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDepthFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDepthFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDepthFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelZoom(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelZoom(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelZoom(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelTransferf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelTransferf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelTransferf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelTransferi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelTransferi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelTransferi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelStoref(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelStoref(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelStoref(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelStorei(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelStorei(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelStorei(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelMapfv(__GLScontext *, GLubyte *);
    GLint mapsize;
    __glsSwap4(inoutPtr + 0);
    mapsize = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(mapsize, 0), inoutPtr + 8);
    __gls_decode_bin_glPixelMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelMapuiv(__GLScontext *, GLubyte *);
    GLint mapsize;
    __glsSwap4(inoutPtr + 0);
    mapsize = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(mapsize, 0), inoutPtr + 8);
    __gls_decode_bin_glPixelMapuiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelMapusv(__GLScontext *, GLubyte *);
    GLint mapsize;
    __glsSwap4(inoutPtr + 0);
    mapsize = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap2v(__GLS_MAX(mapsize, 0), inoutPtr + 8);
    __gls_decode_bin_glPixelMapusv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glReadBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glReadBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glReadBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glCopyPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyPixels(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glCopyPixels(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glReadPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glReadPixels(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap8(inoutPtr + 16);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glReadPixels(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDrawPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawPixels(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    pixels_count = __gls_glDrawPixels_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 20);
    __gls_decode_bin_glDrawPixels(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetBooleanv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetBooleanv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetBooleanv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetClipPlane(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glGetClipPlane(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetDoublev(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetDoublev(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetDoublev(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetError(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[325])();
}

void __gls_decode_bin_swap_glGetFloatv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetFloatv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetFloatv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetIntegerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetIntegerv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetIntegerv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetLightfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetLightfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetLightiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetLightiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMapdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMapdv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glGetMapdv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMapfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glGetMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMapiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMapiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glGetMapiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMaterialfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMaterialfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMaterialiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMaterialiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPixelMapfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetPixelMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPixelMapuiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetPixelMapuiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPixelMapusv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetPixelMapusv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPolygonStipple(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glGetPolygonStipple(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetString(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetString(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glGetString(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexEnvfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexEnvfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexEnviv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexEnviv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexGendv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexGendv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexGenfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexGenfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexGeniv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexGeniv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexImage(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexImage(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glGetTexImage(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexParameterfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexParameterfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexParameteriv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexParameteriv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexLevelParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexLevelParameterfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glGetTexLevelParameterfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexLevelParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexLevelParameteriv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glGetTexLevelParameteriv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIsEnabled(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsEnabled(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsEnabled(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIsList(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsList(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsList(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDepthRange(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDepthRange(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glDepthRange(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFrustum(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFrustum(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __glsSwap8(inoutPtr + 32);
    __glsSwap8(inoutPtr + 40);
    __gls_decode_bin_glFrustum(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLoadIdentity(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[354])();
}

void __gls_decode_bin_swap_glLoadMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[355])(inoutPtr);
}

void __gls_decode_bin_swap_glLoadMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[356])(inoutPtr);
}

void __gls_decode_bin_swap_glMatrixMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMatrixMode(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glMatrixMode(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMultMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[358])(inoutPtr);
}

void __gls_decode_bin_swap_glMultMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[359])(inoutPtr);
}

void __gls_decode_bin_swap_glOrtho(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glOrtho(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __glsSwap8(inoutPtr + 32);
    __glsSwap8(inoutPtr + 40);
    __gls_decode_bin_glOrtho(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPopMatrix(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[361])();
}

void __gls_decode_bin_swap_glPushMatrix(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[362])();
}

void __gls_decode_bin_swap_glRotated(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRotated(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glRotated(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRotatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRotatef(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRotatef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glScaled(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glScaled(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glScaled(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glScalef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glScalef(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glScalef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTranslated(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTranslated(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glTranslated(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTranslatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTranslatef(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTranslatef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glViewport(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glViewport(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glViewport(ctx, inoutPtr);
}

#if __GL_EXT_blend_color
void __gls_decode_bin_swap_glBlendColorEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBlendColorEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glBlendColorEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_decode_bin_swap_glBlendEquationEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBlendEquationEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glBlendEquationEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_decode_bin_swap_glPolygonOffsetEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonOffsetEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPolygonOffsetEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_polygon_offset */

void __gls_decode_bin_swap_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonOffset(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPolygonOffset(ctx, inoutPtr);
}

#if __GL_EXT_subtexture
void __gls_decode_bin_swap_glTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage1DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    pixels_count = __gls_glTexSubImage1DEXT_pixels_size(format, type, width);
    __glsSwapv(type, pixels_count, inoutPtr + 28);
    __gls_decode_bin_glTexSubImage1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_swap_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage1D(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    pixels_count = __gls_glTexSubImage1D_pixels_size(format, type, width);
    __glsSwapv(type, pixels_count, inoutPtr + 28);
    __gls_decode_bin_glTexSubImage1D(ctx, inoutPtr);
}

#if __GL_EXT_subtexture
void __gls_decode_bin_swap_glTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage2DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    pixels_count = __gls_glTexSubImage2DEXT_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 36);
    __gls_decode_bin_glTexSubImage2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_swap_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage2D(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    pixels_count = __gls_glTexSubImage2D_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 36);
    __gls_decode_bin_glTexSubImage2D(ctx, inoutPtr);
}

#if __GL_SGIS_multisample
void __gls_decode_bin_swap_glSampleMaskSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSampleMaskSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glSampleMaskSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_decode_bin_swap_glSamplePatternSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSamplePatternSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glSamplePatternSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIX_multisample
void __gls_decode_bin_swap_glTagSampleBufferSGIX(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[391])();
}
#endif /* __GL_SGIX_multisample */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint image_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    image_count = __gls_glConvolutionFilter1DEXT_image_size(format, type, width);
    __glsSwapv(type, image_count, inoutPtr + 24);
    __gls_decode_bin_glConvolutionFilter1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint image_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    image_count = __gls_glConvolutionFilter2DEXT_image_size(format, type, width, height);
    __glsSwapv(type, image_count, inoutPtr + 28);
    __gls_decode_bin_glConvolutionFilter2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameterfEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameterfEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameterfEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glConvolutionParameterfvEXT_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameteriEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameteriEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameteriEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameterivEXT(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glConvolutionParameterivEXT_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glCopyConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glCopyConvolutionFilter1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glCopyConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glCopyConvolutionFilter2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetConvolutionFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetConvolutionFilterEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetConvolutionFilterEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetConvolutionParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetConvolutionParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetConvolutionParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetSeparableFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetSeparableFilterEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __glsSwap8(inoutPtr + 20);
    __glsSwap8(inoutPtr + 28);
    __gls_decode_bin_glGetSeparableFilterEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glSeparableFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSeparableFilter2DEXT(__GLScontext *, GLubyte *);
    GLenum target;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLint column_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    target = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    width = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    height = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    __glsSwapv(type, row_count, inoutPtr + 28);
    column_count = __gls_glSeparableFilter2DEXT_column_size(target, format, type, height);
    __glsSwapv(type, column_count, inoutPtr + 28 + 1 * row_count);
    __gls_decode_bin_glSeparableFilter2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetHistogramEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetHistogramEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetHistogramParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetHistogramParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetHistogramParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetHistogramParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetHistogramParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetHistogramParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMinmaxEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetMinmaxEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetMinmaxParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMinmaxParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMinmaxParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetMinmaxParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMinmaxParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMinmaxParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glHistogramEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glHistogramEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMinmaxEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glMinmaxEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glResetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glResetHistogramEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glResetHistogramEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glResetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glResetMinmaxEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glResetMinmaxEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_decode_bin_swap_glTexImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage3DEXT(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage3DEXT_pixels_size(format, type, width, height, depth);
    __glsSwapv(type, pixels_count, inoutPtr + 40);
    __gls_decode_bin_glTexImage3DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture
void __gls_decode_bin_swap_glTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage3DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __glsSwap4(inoutPtr + 40);
    pixels_count = __gls_glTexSubImage3DEXT_pixels_size(format, type, width, height, depth);
    __glsSwapv(type, pixels_count, inoutPtr + 44);
    __gls_decode_bin_glTexSubImage3DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_swap_glDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDetailTexFuncSGIS(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n*2, 0), inoutPtr + 8);
    __gls_decode_bin_glDetailTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_swap_glGetDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetDetailTexFuncSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetDetailTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_swap_glSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n*2, 0), inoutPtr + 8);
    __gls_decode_bin_glSharpenTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_swap_glGetSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetSharpenTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glArrayElementEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glArrayElementEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glArrayElementEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glArrayElement(__GLScontext *, GLubyte *);
    __glsSwapArrayData(inoutPtr);
    __gls_decode_bin_glArrayElement(ctx, inoutPtr);
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glColorPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorPointerEXT(__GLScontext *, GLubyte *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    size = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    stride = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 16);
    __gls_decode_bin_glColorPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because ColorPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glDrawArraysEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawArraysEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glDrawArraysEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawArrays(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwapArrayData(inoutPtr + 4);
    __gls_decode_bin_glDrawArrays(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr) {
    // DrewB - Non-functional
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glEdgeFlagPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEdgeFlagPointerEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glEdgeFlagPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because EdgeFlagPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glGetPointervEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPointervEXT(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glGetPointervEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPointerv(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glGetPointerv(ctx, inoutPtr);
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glIndexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexPointerEXT(__GLScontext *, GLubyte *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 12);
    __gls_decode_bin_glIndexPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because IndexPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glNormalPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormalPointerEXT(__GLScontext *, GLubyte *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 12);
    __gls_decode_bin_glNormalPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because NormalPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glTexCoordPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoordPointerEXT(__GLScontext *, GLubyte *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    size = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    stride = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 16);
    __gls_decode_bin_glTexCoordPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because TexCoordPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glVertexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertexPointerEXT(__GLScontext *, GLubyte *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    size = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    stride = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 16);
    __gls_decode_bin_glVertexPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because VertexPointer isn't captured
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glAreTexturesResidentEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAreTexturesResidentEXT(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 12);
    __gls_decode_bin_glAreTexturesResidentEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAreTexturesResident(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 12);
    __gls_decode_bin_glAreTexturesResident(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glBindTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBindTextureEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glBindTextureEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBindTexture(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glBindTexture(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glDeleteTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDeleteTexturesEXT(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __gls_decode_bin_glDeleteTexturesEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDeleteTextures(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __gls_decode_bin_glDeleteTextures(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glGenTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGenTexturesEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGenTexturesEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGenTextures(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGenTextures(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glIsTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsTextureEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsTextureEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsTexture(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsTexture(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glPrioritizeTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPrioritizeTexturesEXT(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4 + 4 * __GLS_MAX(n, 0));
    __gls_decode_bin_glPrioritizeTexturesEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPrioritizeTextures(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4 + 4 * __GLS_MAX(n, 0));
    __gls_decode_bin_glPrioritizeTextures(ctx, inoutPtr);
}

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorTableEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint table_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    table_count = __gls_glColorTableEXT_table_size(format, type, width);
    __glsSwapv(type, table_count, inoutPtr + 24);
    __gls_decode_bin_glColorTableEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_decode_bin_swap_glColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorTableParameterfvSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glColorTableParameterfvSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glColorTableParameterfvSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_swap_glColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorTableParameterivSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glColorTableParameterivSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glColorTableParameterivSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_swap_glCopyColorTableSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyColorTableSGI(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glCopyColorTableSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glGetColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetColorTableEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetColorTableEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glGetColorTableParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetColorTableParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetColorTableParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glGetColorTableParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetColorTableParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetColorTableParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glGetTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexColorTableParameterfvSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glGetTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexColorTableParameterivSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexColorTableParameterfvSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexColorTableParameterfvSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexColorTableParameterivSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexColorTableParameterivSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage1DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __gls_decode_bin_glCopyTexImage1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage1D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __gls_decode_bin_glCopyTexImage1D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage2DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexImage2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage2D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexImage2D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage1DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glCopyTexSubImage1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage1D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glCopyTexSubImage1D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage2DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexSubImage2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage2D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexSubImage2D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage3DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __gls_decode_bin_glCopyTexSubImage3DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_decode_bin_swap_glTexImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage4DSGIS(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    size4d = *(GLsizei *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    format = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    type = *(GLenum *)(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __glsSwap4(inoutPtr + 40);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __glsSwapv(type, pixels_count, inoutPtr + 44);
    __gls_decode_bin_glTexImage4DSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_decode_bin_swap_glTexSubImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage4DSGIS(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    size4d = *(GLsizei *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    format = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    type = *(GLenum *)(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __glsSwap4(inoutPtr + 40);
    __glsSwap4(inoutPtr + 44);
    __glsSwap4(inoutPtr + 48);
    pixels_count = __gls_glTexSubImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __glsSwapv(type, pixels_count, inoutPtr + 52);
    __gls_decode_bin_glTexSubImage4DSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_decode_bin_swap_glPixelTexGenSGIX(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelTexGenSGIX(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPixelTexGenSGIX(ctx, inoutPtr);
}
#endif /* __GL_SGIX_pixel_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorSubTableEXT(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei entries;
    GLenum format;
    GLenum type;
    GLint entries_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    entries = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    entries_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glColorSubTableEXT_entries_size(format, type, entries);
    __glsSwapv(type, entries_count, inoutPtr + 40);
    __gls_decode_bin_glColorSubTableEXT(ctx, inoutPtr);
}
#endif // __GL_EXT_paletted_texture

void __gls_decode_bin_swap_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDisableClientState(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDisableClientState(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEnableClientState(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEnableClientState(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because InterleavedArrays isn't captured
}

void __gls_decode_bin_swap_glPushClientAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPushClientAttrib(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPushClientAttrib(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPopClientAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[399])();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_dspexe.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

extern void __gls_exec_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor);
extern void __gls_exec_glsBlock(GLSenum inBlockType);
extern GLSenum __gls_exec_glsCallStream(const GLubyte *inName);
extern void __gls_exec_glsEndGLS(void);
extern void __gls_exec_glsError(GLSopcode inOpcode, GLSenum inError);
extern void __gls_exec_glsGLRC(GLuint inGLRC);
extern void __gls_exec_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void __gls_exec_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void __gls_exec_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void __gls_exec_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void __gls_exec_glsHeaderf(GLSenum inAttrib, GLfloat inVal);
extern void __gls_exec_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec);
extern void __gls_exec_glsHeaderi(GLSenum inAttrib, GLint inVal);
extern void __gls_exec_glsHeaderiv(GLSenum inAttrib, const GLint *inVec);
extern void __gls_exec_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString);
extern void __gls_exec_glsRequireExtension(const GLubyte *inExtension);
extern void __gls_exec_glsUnsupportedCommand(void);
extern void __gls_exec_glsAppRef(GLulong inAddress, GLuint inCount);
extern void __gls_exec_glsBeginObj(const GLubyte *inTag);
extern void __gls_exec_glsCharubz(const GLubyte *inTag, const GLubyte *inString);
extern void __gls_exec_glsComment(const GLubyte *inComment);
extern void __gls_exec_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void __gls_exec_glsEndObj(void);
extern void __gls_exec_glsNumb(const GLubyte *inTag, GLbyte inVal);
extern void __gls_exec_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void __gls_exec_glsNumd(const GLubyte *inTag, GLdouble inVal);
extern void __gls_exec_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void __gls_exec_glsNumf(const GLubyte *inTag, GLfloat inVal);
extern void __gls_exec_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void __gls_exec_glsNumi(const GLubyte *inTag, GLint inVal);
extern void __gls_exec_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void __gls_exec_glsNuml(const GLubyte *inTag, GLlong inVal);
extern void __gls_exec_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void __gls_exec_glsNums(const GLubyte *inTag, GLshort inVal);
extern void __gls_exec_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void __gls_exec_glsNumub(const GLubyte *inTag, GLubyte inVal);
extern void __gls_exec_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void __gls_exec_glsNumui(const GLubyte *inTag, GLuint inVal);
extern void __gls_exec_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void __gls_exec_glsNumul(const GLubyte *inTag, GLulong inVal);
extern void __gls_exec_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void __gls_exec_glsNumus(const GLubyte *inTag, GLushort inVal);
extern void __gls_exec_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void __gls_exec_glsPad(void);
extern void __gls_exec_glsSwapBuffers(GLuint inLayer);

#if __GLS_PLATFORM_WIN32
// DrewB - These are filled in by platform.c
#define glColorSubTableEXT NULL
#define glColorTableEXT NULL
#define glGetColorTableEXT NULL
#define glGetColorTableParameterivEXT NULL
#define glGetColorTableParameterfvEXT NULL
#endif

GLSfunc __glsDispatchExec[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_exec_glsBeginGLS,
    (GLSfunc)__gls_exec_glsBlock,
    (GLSfunc)__gls_exec_glsCallStream,
    (GLSfunc)__gls_exec_glsEndGLS,
    (GLSfunc)__gls_exec_glsError,
    (GLSfunc)__gls_exec_glsGLRC,
    (GLSfunc)__gls_exec_glsGLRCLayer,
    (GLSfunc)__gls_exec_glsHeaderGLRCi,
    (GLSfunc)__gls_exec_glsHeaderLayerf,
    (GLSfunc)__gls_exec_glsHeaderLayeri,
    (GLSfunc)__gls_exec_glsHeaderf,
    (GLSfunc)__gls_exec_glsHeaderfv,
    (GLSfunc)__gls_exec_glsHeaderi,
    (GLSfunc)__gls_exec_glsHeaderiv,
    (GLSfunc)__gls_exec_glsHeaderubz,
    (GLSfunc)__gls_exec_glsRequireExtension,
    (GLSfunc)__gls_exec_glsUnsupportedCommand,
    (GLSfunc)__gls_exec_glsAppRef,
    (GLSfunc)__gls_exec_glsBeginObj,
    (GLSfunc)__gls_exec_glsCharubz,
    (GLSfunc)__gls_exec_glsComment,
    (GLSfunc)__gls_exec_glsDisplayMapfv,
    (GLSfunc)__gls_exec_glsEndObj,
    (GLSfunc)__gls_exec_glsNumb,
    (GLSfunc)__gls_exec_glsNumbv,
    (GLSfunc)__gls_exec_glsNumd,
    (GLSfunc)__gls_exec_glsNumdv,
    (GLSfunc)__gls_exec_glsNumf,
    (GLSfunc)__gls_exec_glsNumfv,
    (GLSfunc)__gls_exec_glsNumi,
    (GLSfunc)__gls_exec_glsNumiv,
    (GLSfunc)__gls_exec_glsNuml,
    (GLSfunc)__gls_exec_glsNumlv,
    (GLSfunc)__gls_exec_glsNums,
    (GLSfunc)__gls_exec_glsNumsv,
    (GLSfunc)__gls_exec_glsNumub,
    (GLSfunc)__gls_exec_glsNumubv,
    (GLSfunc)__gls_exec_glsNumui,
    (GLSfunc)__gls_exec_glsNumuiv,
    (GLSfunc)__gls_exec_glsNumul,
    (GLSfunc)__gls_exec_glsNumulv,
    (GLSfunc)__gls_exec_glsNumus,
    (GLSfunc)__gls_exec_glsNumusv,
    (GLSfunc)__gls_exec_glsPad,
    (GLSfunc)__gls_exec_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)glNewList,
    (GLSfunc)glEndList,
    (GLSfunc)glCallList,
    (GLSfunc)glCallLists,
    (GLSfunc)glDeleteLists,
    (GLSfunc)glGenLists,
    (GLSfunc)glListBase,
    (GLSfunc)glBegin,
    (GLSfunc)glBitmap,
    (GLSfunc)glColor3b,
    (GLSfunc)glColor3bv,
    (GLSfunc)glColor3d,
    (GLSfunc)glColor3dv,
    (GLSfunc)glColor3f,
    (GLSfunc)glColor3fv,
    (GLSfunc)glColor3i,
    (GLSfunc)glColor3iv,
    (GLSfunc)glColor3s,
    (GLSfunc)glColor3sv,
    (GLSfunc)glColor3ub,
    (GLSfunc)glColor3ubv,
    (GLSfunc)glColor3ui,
    (GLSfunc)glColor3uiv,
    (GLSfunc)glColor3us,
    (GLSfunc)glColor3usv,
    (GLSfunc)glColor4b,
    (GLSfunc)glColor4bv,
    (GLSfunc)glColor4d,
    (GLSfunc)glColor4dv,
    (GLSfunc)glColor4f,
    (GLSfunc)glColor4fv,
    (GLSfunc)glColor4i,
    (GLSfunc)glColor4iv,
    (GLSfunc)glColor4s,
    (GLSfunc)glColor4sv,
    (GLSfunc)glColor4ub,
    (GLSfunc)glColor4ubv,
    (GLSfunc)glColor4ui,
    (GLSfunc)glColor4uiv,
    (GLSfunc)glColor4us,
    (GLSfunc)glColor4usv,
    (GLSfunc)glEdgeFlag,
    (GLSfunc)glEdgeFlagv,
    (GLSfunc)glEnd,
    (GLSfunc)glIndexd,
    (GLSfunc)glIndexdv,
    (GLSfunc)glIndexf,
    (GLSfunc)glIndexfv,
    (GLSfunc)glIndexi,
    (GLSfunc)glIndexiv,
    (GLSfunc)glIndexs,
    (GLSfunc)glIndexsv,
    (GLSfunc)glNormal3b,
    (GLSfunc)glNormal3bv,
    (GLSfunc)glNormal3d,
    (GLSfunc)glNormal3dv,
    (GLSfunc)glNormal3f,
    (GLSfunc)glNormal3fv,
    (GLSfunc)glNormal3i,
    (GLSfunc)glNormal3iv,
    (GLSfunc)glNormal3s,
    (GLSfunc)glNormal3sv,
    (GLSfunc)glRasterPos2d,
    (GLSfunc)glRasterPos2dv,
    (GLSfunc)glRasterPos2f,
    (GLSfunc)glRasterPos2fv,
    (GLSfunc)glRasterPos2i,
    (GLSfunc)glRasterPos2iv,
    (GLSfunc)glRasterPos2s,
    (GLSfunc)glRasterPos2sv,
    (GLSfunc)glRasterPos3d,
    (GLSfunc)glRasterPos3dv,
    (GLSfunc)glRasterPos3f,
    (GLSfunc)glRasterPos3fv,
    (GLSfunc)glRasterPos3i,
    (GLSfunc)glRasterPos3iv,
    (GLSfunc)glRasterPos3s,
    (GLSfunc)glRasterPos3sv,
    (GLSfunc)glRasterPos4d,
    (GLSfunc)glRasterPos4dv,
    (GLSfunc)glRasterPos4f,
    (GLSfunc)glRasterPos4fv,
    (GLSfunc)glRasterPos4i,
    (GLSfunc)glRasterPos4iv,
    (GLSfunc)glRasterPos4s,
    (GLSfunc)glRasterPos4sv,
    (GLSfunc)glRectd,
    (GLSfunc)glRectdv,
    (GLSfunc)glRectf,
    (GLSfunc)glRectfv,
    (GLSfunc)glRecti,
    (GLSfunc)glRectiv,
    (GLSfunc)glRects,
    (GLSfunc)glRectsv,
    (GLSfunc)glTexCoord1d,
    (GLSfunc)glTexCoord1dv,
    (GLSfunc)glTexCoord1f,
    (GLSfunc)glTexCoord1fv,
    (GLSfunc)glTexCoord1i,
    (GLSfunc)glTexCoord1iv,
    (GLSfunc)glTexCoord1s,
    (GLSfunc)glTexCoord1sv,
    (GLSfunc)glTexCoord2d,
    (GLSfunc)glTexCoord2dv,
    (GLSfunc)glTexCoord2f,
    (GLSfunc)glTexCoord2fv,
    (GLSfunc)glTexCoord2i,
    (GLSfunc)glTexCoord2iv,
    (GLSfunc)glTexCoord2s,
    (GLSfunc)glTexCoord2sv,
    (GLSfunc)glTexCoord3d,
    (GLSfunc)glTexCoord3dv,
    (GLSfunc)glTexCoord3f,
    (GLSfunc)glTexCoord3fv,
    (GLSfunc)glTexCoord3i,
    (GLSfunc)glTexCoord3iv,
    (GLSfunc)glTexCoord3s,
    (GLSfunc)glTexCoord3sv,
    (GLSfunc)glTexCoord4d,
    (GLSfunc)glTexCoord4dv,
    (GLSfunc)glTexCoord4f,
    (GLSfunc)glTexCoord4fv,
    (GLSfunc)glTexCoord4i,
    (GLSfunc)glTexCoord4iv,
    (GLSfunc)glTexCoord4s,
    (GLSfunc)glTexCoord4sv,
    (GLSfunc)glVertex2d,
    (GLSfunc)glVertex2dv,
    (GLSfunc)glVertex2f,
    (GLSfunc)glVertex2fv,
    (GLSfunc)glVertex2i,
    (GLSfunc)glVertex2iv,
    (GLSfunc)glVertex2s,
    (GLSfunc)glVertex2sv,
    (GLSfunc)glVertex3d,
    (GLSfunc)glVertex3dv,
    (GLSfunc)glVertex3f,
    (GLSfunc)glVertex3fv,
    (GLSfunc)glVertex3i,
    (GLSfunc)glVertex3iv,
    (GLSfunc)glVertex3s,
    (GLSfunc)glVertex3sv,
    (GLSfunc)glVertex4d,
    (GLSfunc)glVertex4dv,
    (GLSfunc)glVertex4f,
    (GLSfunc)glVertex4fv,
    (GLSfunc)glVertex4i,
    (GLSfunc)glVertex4iv,
    (GLSfunc)glVertex4s,
    (GLSfunc)glVertex4sv,
    (GLSfunc)glClipPlane,
    (GLSfunc)glColorMaterial,
    (GLSfunc)glCullFace,
    (GLSfunc)glFogf,
    (GLSfunc)glFogfv,
    (GLSfunc)glFogi,
    (GLSfunc)glFogiv,
    (GLSfunc)glFrontFace,
    (GLSfunc)glHint,
    (GLSfunc)glLightf,
    (GLSfunc)glLightfv,
    (GLSfunc)glLighti,
    (GLSfunc)glLightiv,
    (GLSfunc)glLightModelf,
    (GLSfunc)glLightModelfv,
    (GLSfunc)glLightModeli,
    (GLSfunc)glLightModeliv,
    (GLSfunc)glLineStipple,
    (GLSfunc)glLineWidth,
    (GLSfunc)glMaterialf,
    (GLSfunc)glMaterialfv,
    (GLSfunc)glMateriali,
    (GLSfunc)glMaterialiv,
    (GLSfunc)glPointSize,
    (GLSfunc)glPolygonMode,
    (GLSfunc)glPolygonStipple,
    (GLSfunc)glScissor,
    (GLSfunc)glShadeModel,
    (GLSfunc)glTexParameterf,
    (GLSfunc)glTexParameterfv,
    (GLSfunc)glTexParameteri,
    (GLSfunc)glTexParameteriv,
    (GLSfunc)glTexImage1D,
    (GLSfunc)glTexImage2D,
    (GLSfunc)glTexEnvf,
    (GLSfunc)glTexEnvfv,
    (GLSfunc)glTexEnvi,
    (GLSfunc)glTexEnviv,
    (GLSfunc)glTexGend,
    (GLSfunc)glTexGendv,
    (GLSfunc)glTexGenf,
    (GLSfunc)glTexGenfv,
    (GLSfunc)glTexGeni,
    (GLSfunc)glTexGeniv,
    (GLSfunc)glFeedbackBuffer,
    (GLSfunc)glSelectBuffer,
    (GLSfunc)glRenderMode,
    (GLSfunc)glInitNames,
    (GLSfunc)glLoadName,
    (GLSfunc)glPassThrough,
    (GLSfunc)glPopName,
    (GLSfunc)glPushName,
    (GLSfunc)glDrawBuffer,
    (GLSfunc)glClear,
    (GLSfunc)glClearAccum,
    (GLSfunc)glClearIndex,
    (GLSfunc)glClearColor,
    (GLSfunc)glClearStencil,
    (GLSfunc)glClearDepth,
    (GLSfunc)glStencilMask,
    (GLSfunc)glColorMask,
    (GLSfunc)glDepthMask,
    (GLSfunc)glIndexMask,
    (GLSfunc)glAccum,
    (GLSfunc)glDisable,
    (GLSfunc)glEnable,
    (GLSfunc)glFinish,
    (GLSfunc)glFlush,
    (GLSfunc)glPopAttrib,
    (GLSfunc)glPushAttrib,
    (GLSfunc)glMap1d,
    (GLSfunc)glMap1f,
    (GLSfunc)glMap2d,
    (GLSfunc)glMap2f,
    (GLSfunc)glMapGrid1d,
    (GLSfunc)glMapGrid1f,
    (GLSfunc)glMapGrid2d,
    (GLSfunc)glMapGrid2f,
    (GLSfunc)glEvalCoord1d,
    (GLSfunc)glEvalCoord1dv,
    (GLSfunc)glEvalCoord1f,
    (GLSfunc)glEvalCoord1fv,
    (GLSfunc)glEvalCoord2d,
    (GLSfunc)glEvalCoord2dv,
    (GLSfunc)glEvalCoord2f,
    (GLSfunc)glEvalCoord2fv,
    (GLSfunc)glEvalMesh1,
    (GLSfunc)glEvalPoint1,
    (GLSfunc)glEvalMesh2,
    (GLSfunc)glEvalPoint2,
    (GLSfunc)glAlphaFunc,
    (GLSfunc)glBlendFunc,
    (GLSfunc)glLogicOp,
    (GLSfunc)glStencilFunc,
    (GLSfunc)glStencilOp,
    (GLSfunc)glDepthFunc,
    (GLSfunc)glPixelZoom,
    (GLSfunc)glPixelTransferf,
    (GLSfunc)glPixelTransferi,
    (GLSfunc)glPixelStoref,
    (GLSfunc)glPixelStorei,
    (GLSfunc)glPixelMapfv,
    (GLSfunc)glPixelMapuiv,
    (GLSfunc)glPixelMapusv,
    (GLSfunc)glReadBuffer,
    (GLSfunc)glCopyPixels,
    (GLSfunc)glReadPixels,
    (GLSfunc)glDrawPixels,
    (GLSfunc)glGetBooleanv,
    (GLSfunc)glGetClipPlane,
    (GLSfunc)glGetDoublev,
    (GLSfunc)glGetError,
    (GLSfunc)glGetFloatv,
    (GLSfunc)glGetIntegerv,
    (GLSfunc)glGetLightfv,
    (GLSfunc)glGetLightiv,
    (GLSfunc)glGetMapdv,
    (GLSfunc)glGetMapfv,
    (GLSfunc)glGetMapiv,
    (GLSfunc)glGetMaterialfv,
    (GLSfunc)glGetMaterialiv,
    (GLSfunc)glGetPixelMapfv,
    (GLSfunc)glGetPixelMapuiv,
    (GLSfunc)glGetPixelMapusv,
    (GLSfunc)glGetPolygonStipple,
    (GLSfunc)glGetString,
    (GLSfunc)glGetTexEnvfv,
    (GLSfunc)glGetTexEnviv,
    (GLSfunc)glGetTexGendv,
    (GLSfunc)glGetTexGenfv,
    (GLSfunc)glGetTexGeniv,
    (GLSfunc)glGetTexImage,
    (GLSfunc)glGetTexParameterfv,
    (GLSfunc)glGetTexParameteriv,
    (GLSfunc)glGetTexLevelParameterfv,
    (GLSfunc)glGetTexLevelParameteriv,
    (GLSfunc)glIsEnabled,
    (GLSfunc)glIsList,
    (GLSfunc)glDepthRange,
    (GLSfunc)glFrustum,
    (GLSfunc)glLoadIdentity,
    (GLSfunc)glLoadMatrixf,
    (GLSfunc)glLoadMatrixd,
    (GLSfunc)glMatrixMode,
    (GLSfunc)glMultMatrixf,
    (GLSfunc)glMultMatrixd,
    (GLSfunc)glOrtho,
    (GLSfunc)glPopMatrix,
    (GLSfunc)glPushMatrix,
    (GLSfunc)glRotated,
    (GLSfunc)glRotatef,
    (GLSfunc)glScaled,
    (GLSfunc)glScalef,
    (GLSfunc)glTranslated,
    (GLSfunc)glTranslatef,
    (GLSfunc)glViewport,
    // DrewB - 1.1
    (GLSfunc)glArrayElement,
    (GLSfunc)glBindTexture,
    (GLSfunc)glColorPointer,
    (GLSfunc)glDisableClientState,
    (GLSfunc)glDrawArrays,
    (GLSfunc)glDrawElements,
    (GLSfunc)glEdgeFlagPointer,
    (GLSfunc)glEnableClientState,
    (GLSfunc)glIndexPointer,
    (GLSfunc)glIndexub,
    (GLSfunc)glIndexubv,
    (GLSfunc)glInterleavedArrays,
    (GLSfunc)glNormalPointer,
    (GLSfunc)glPolygonOffset,
    (GLSfunc)glTexCoordPointer,
    (GLSfunc)glVertexPointer,
    (GLSfunc)glAreTexturesResident,
    (GLSfunc)glCopyTexImage1D,
    (GLSfunc)glCopyTexImage2D,
    (GLSfunc)glCopyTexSubImage1D,
    (GLSfunc)glCopyTexSubImage2D,
    (GLSfunc)glDeleteTextures,
    (GLSfunc)glGenTextures,
    (GLSfunc)glGetPointerv,
    (GLSfunc)glIsTexture,
    (GLSfunc)glPrioritizeTextures,
    (GLSfunc)glTexSubImage1D,
    (GLSfunc)glTexSubImage2D,
    (GLSfunc)glPushClientAttrib,
    (GLSfunc)glPopClientAttrib,
    #if __GL_EXT_blend_color
        (GLSfunc)glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        (GLSfunc)glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        (GLSfunc)glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        (GLSfunc)glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        (GLSfunc)glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        (GLSfunc)glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        (GLSfunc)glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        (GLSfunc)glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        (GLSfunc)glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        (GLSfunc)glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture && __GL_EXT_texture3D
        (GLSfunc)glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        (GLSfunc)glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        (GLSfunc)glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        (GLSfunc)glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture && __GL_EXT_texture3D
        (GLSfunc)glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        (GLSfunc)glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        (GLSfunc)glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        (GLSfunc)glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        (GLSfunc)glColorSubTableEXT,
    #else
        GLS_NONE,
        GLS_NONE,
    #endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\gls\lib\g_dspdec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

// DrewB - All functions changed to use passed in context

extern void __gls_decode_bin_glsBeginGLS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBlock(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsError(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsGLRC(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsGLRCLayer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderGLRCi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderLayerf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderLayeri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsAppRef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsCharubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsDisplayMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumb(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumbv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNuml(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumlv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNums(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumul(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumulv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumus(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsSwapBuffers(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginPoints(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginLines(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginLineLoop(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginLineStrip(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginTriangles(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginTriangleStrip(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginTriangleFan(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginQuads(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginQuadStrip(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginPolygon(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNewList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCallList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCallLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDeleteLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGenLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glListBase(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBegin(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBitmap(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEdgeFlag(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexs(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRecti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRects(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorMaterial(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCullFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFrontFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glHint(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLighti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModelf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModelfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModeli(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModeliv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLineStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLineWidth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMaterialf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMateriali(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPointSize(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPolygonMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glScissor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glShadeModel(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameterf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameteri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage1D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage2D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnvf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnvi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGend(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGenf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGeni(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFeedbackBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSelectBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRenderMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLoadName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPassThrough(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPushName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDrawBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClear(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearIndex(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearColor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearStencil(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearDepth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glStencilMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDepthMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDisable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEnable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPushAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalMesh1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalPoint1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalMesh2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalPoint2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glAlphaFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBlendFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLogicOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glStencilFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glStencilOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDepthFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelZoom(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelTransferf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelTransferi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelStoref(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelStorei(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glReadBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glReadPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDrawPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetBooleanv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetDoublev(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetFloatv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetIntegerv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMapdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMapiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetString(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexImage(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexLevelParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexLevelParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIsEnabled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIsList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDepthRange(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFrustum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMatrixMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glOrtho(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRotated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRotatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glScaled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glScalef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTranslated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTranslatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glViewport(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBlendColorEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBlendEquationEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPolygonOffsetEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSampleMaskSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSamplePatternSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameterfEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameteriEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetConvolutionFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetSeparableFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSeparableFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetHistogramParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetHistogramParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMinmaxParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMinmaxParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glResetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glResetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glArrayElementEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDrawArraysEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEdgeFlagPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPointervEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormalPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoordPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glAreTexturesResidentEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBindTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDeleteTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGenTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIsTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPrioritizeTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyColorTableSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetColorTableParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetColorTableParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelTexGenSGIX(__GLScontext *, GLubyte *);
#ifdef __GLS_PLATFORM_WIN32
extern void __gls_decode_bin_glsCallStream(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsRequireExtension(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glsBeginObj(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glsComment(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3bv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3ubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3uiv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3usv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4bv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4ubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4uiv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4usv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEdgeFlagv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexdv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexfv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexiv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexsv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3bv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glLoadMatrixf(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glLoadMatrixd(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glMultMatrixf(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glMultMatrixd(__GLScontext *ctx, GLubyte *inoutPtr);
#endif

// DrewB - 1.1
extern void __gls_decode_bin_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glPushClientAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPopClientAttrib(__GLScontext *, GLubyte *);

// DrewB
extern void __gls_decode_bin_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr);

extern void __gls_decode_bin_swap_glsBeginGLS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsBlock(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsCallStream(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsEndGLS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsError(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsGLRC(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsGLRCLayer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderGLRCi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderLayerf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderLayeri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsRequireExtension(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsUnsupportedCommand(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsAppRef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsBeginObj(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsCharubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsComment(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsDisplayMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsEndObj(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumb(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumbv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNuml(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumlv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNums(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumul(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumulv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumus(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsPad(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsSwapBuffers(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNewList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEndList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCallList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCallLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDeleteLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGenLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glListBase(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBegin(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBitmap(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3bv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3ubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3uiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3usv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4bv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4ubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4uiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4usv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEdgeFlag(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEdgeFlagv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEnd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexs(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3bv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRecti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRects(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorMaterial(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCullFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFrontFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glHint(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLighti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModelf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModelfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModeli(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModeliv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLineStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLineWidth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMaterialf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMateriali(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPointSize(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPolygonMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glScissor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glShadeModel(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameterf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameteri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage1D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage2D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnvf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnvi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGend(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGenf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGeni(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFeedbackBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSelectBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRenderMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glInitNames(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPassThrough(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPushName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDrawBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClear(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearIndex(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearColor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearStencil(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearDepth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glStencilMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDepthMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDisable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEnable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFinish(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFlush(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPushAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalMesh1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalPoint1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalMesh2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalPoint2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glAlphaFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBlendFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLogicOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glStencilFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glStencilOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDepthFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelZoom(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelTransferf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelTransferi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelStoref(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelStorei(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glReadBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glReadPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDrawPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetBooleanv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetDoublev(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetError(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetFloatv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetIntegerv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMapdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMapiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetString(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexImage(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexLevelParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexLevelParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIsEnabled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIsList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDepthRange(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFrustum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadIdentity(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadMatrixf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadMatrixd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMatrixMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMultMatrixf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMultMatrixd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glOrtho(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopMatrix(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPushMatrix(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRotated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRotatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glScaled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glScalef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTranslated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTranslatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glViewport(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBlendColorEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBlendEquationEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPolygonOffsetEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSampleMaskSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSamplePatternSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTagSampleBufferSGIX(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameterfEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameteriEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetConvolutionFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetSeparableFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSeparableFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetHistogramParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetHistogramParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMinmaxParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMinmaxParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glResetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glResetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glArrayElementEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDrawArraysEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEdgeFlagPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPointervEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormalPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoordPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glAreTexturesResidentEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBindTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDeleteTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGenTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIsTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPrioritizeTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyColorTableSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetColorTableParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetColorTableParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelTexGenSGIX(__GLScontext *, GLubyte *);

// DrewB - 1.1
extern void __gls_decode_bin_swap_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glPushClientAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopClientAttrib(__GLScontext *, GLubyte *);

// DrewB
extern void __gls_decode_bin_swap_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr);

extern void __gls_decode_text_glsBeginGLS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsBlock(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsCallStream(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsEndGLS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsError(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsGLRC(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsGLRCLayer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderGLRCi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderLayerf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderLayeri(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderubz(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsRequireExtension(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsUnsupportedCommand(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsAppRef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsBeginObj(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsCharubz(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsComment(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsDisplayMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsEndObj(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumb(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumbv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNuml(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumlv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNums(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumsv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumub(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumubv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumui(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumuiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumul(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumulv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumus(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumusv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsPad(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsSwapBuffers(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNewList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEndList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCallList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCallLists(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDeleteLists(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGenLists(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glListBase(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBegin(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBitmap(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3b(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3bv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3ub(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3ubv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3ui(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3uiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3us(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3usv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4b(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4bv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4ub(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4ubv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4ui(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4uiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4us(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4usv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEdgeFlag(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEdgeFlagv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEnd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexs(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexsv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3b(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3bv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRecti(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRects(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectsv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClipPlane(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorMaterial(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCullFace(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFrontFace(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glHint(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLighti(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModelf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModelfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModeli(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModeliv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLineStipple(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLineWidth(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMaterialf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMaterialfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMateriali(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMaterialiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPointSize(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPolygonMode(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPolygonStipple(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glScissor(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glShadeModel(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameterf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameterfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameteri(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameteriv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage1D(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage2D(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnvf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnvfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnvi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnviv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGend(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGendv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGenf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGenfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGeni(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGeniv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFeedbackBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSelectBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRenderMode(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glInitNames(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadName(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPassThrough(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopName(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPushName(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDrawBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClear(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearAccum(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearIndex(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearColor(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearStencil(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearDepth(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glStencilMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDepthMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glAccum(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDisable(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEnable(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFinish(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFlush(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopAttrib(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPushAttrib(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalMesh1(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalPoint1(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalMesh2(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalPoint2(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glAlphaFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBlendFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLogicOp(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glStencilFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glStencilOp(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDepthFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelZoom(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelTransferf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelTransferi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelStoref(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelStorei(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelMapuiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelMapusv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glReadBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyPixels(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glReadPixels(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDrawPixels(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetBooleanv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetClipPlane(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetDoublev(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetError(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetFloatv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetIntegerv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetLightfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetLightiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMapdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMapiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMaterialfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMaterialiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPixelMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPixelMapuiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPixelMapusv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPolygonStipple(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetString(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexEnvfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexEnviv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexGendv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexGenfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexGeniv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexImage(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexParameterfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexParameteriv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexLevelParameterfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexLevelParameteriv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIsEnabled(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIsList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDepthRange(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFrustum(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadIdentity(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadMatrixf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadMatrixd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMatrixMode(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMultMatrixf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMultMatrixd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glOrtho(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopMatrix(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPushMatrix(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRotated(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRotatef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glScaled(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glScalef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTranslated(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTranslatef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glViewport(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBlendColorEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBlendEquationEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPolygonOffsetEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSampleMaskSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSamplePatternSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTagSampleBufferSGIX(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionFilter1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionFilter2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameterfEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameteriEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyConvolutionFilter1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyConvolutionFilter2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetConvolutionFilterEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetConvolutionParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetConvolutionParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetSeparableFilterEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSeparableFilter2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetHistogramEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetHistogramParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetHistogramParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMinmaxEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMinmaxParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMinmaxParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glHistogramEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMinmaxEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glResetHistogramEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glResetMinmaxEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage3DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage3DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDetailTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetDetailTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSharpenTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetSharpenTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glArrayElementEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDrawArraysEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEdgeFlagPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPointervEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormalPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoordPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertexPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glAreTexturesResidentEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBindTextureEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDeleteTexturesEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGenTexturesEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIsTextureEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPrioritizeTexturesEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorTableEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorTableParameterfvSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorTableParameterivSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyColorTableSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetColorTableEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetColorTableParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetColorTableParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexColorTableParameterfvSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexColorTableParameterivSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexColorTableParameterfvSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexColorTableParameterivSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage3DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage4DSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage4DSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelTexGenSGIX(__GLScontext *, __GLSreader *);

// DrewB - 1.1
extern void __gls_decode_text_glArrayElement(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glBindTexture(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glColorPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDisableClientState(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDrawArrays(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDrawElements(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glEdgeFlagPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glEnableClientState(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIndexPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIndexub(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIndexubv(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glInterleavedArrays(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glNormalPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glPolygonOffset(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glTexCoordPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glVertexPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glAreTexturesResident(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage1D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage2D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage1D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage2D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDeleteTextures(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glGenTextures(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glGetPointerv(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIsTexture(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glPrioritizeTextures(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glTexSubImage1D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glTexSubImage2D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glPushClientAttrib(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopClientAttrib(__GLScontext *, __GLSreader *);

// DrewB
extern void __gls_decode_text_glColorSubTableEXT(__GLScontext *ctx, __GLSreader *);

#ifndef __GLS_PLATFORM_WIN32
// DrewB
#define BIN_SINGLE(fn) GLS_NONE
#else
#define BIN_SINGLE(fn) fn
#endif

__GLSdecodeBinFunc __glsDispatchDecode_bin_default[
    __GLS_OPCODE_COUNT
] = {
    GLS_NONE,
    __gls_decode_bin_glsBeginPoints,
    __gls_decode_bin_glsBeginLines,
    __gls_decode_bin_glsBeginLineLoop,
    __gls_decode_bin_glsBeginLineStrip,
    __gls_decode_bin_glsBeginTriangles,
    __gls_decode_bin_glsBeginTriangleStrip,
    __gls_decode_bin_glsBeginTriangleFan,
    __gls_decode_bin_glsBeginQuads,
    __gls_decode_bin_glsBeginQuadStrip,
    __gls_decode_bin_glsBeginPolygon,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glsBeginGLS,
    __gls_decode_bin_glsBlock,
    BIN_SINGLE(__gls_decode_bin_glsCallStream),
    GLS_NONE,
    __gls_decode_bin_glsError,
    __gls_decode_bin_glsGLRC,
    __gls_decode_bin_glsGLRCLayer,
    __gls_decode_bin_glsHeaderGLRCi,
    __gls_decode_bin_glsHeaderLayerf,
    __gls_decode_bin_glsHeaderLayeri,
    __gls_decode_bin_glsHeaderf,
    __gls_decode_bin_glsHeaderfv,
    __gls_decode_bin_glsHeaderi,
    __gls_decode_bin_glsHeaderiv,
    __gls_decode_bin_glsHeaderubz,
    BIN_SINGLE(__gls_decode_bin_glsRequireExtension),
    GLS_NONE,
    __gls_decode_bin_glsAppRef,
    BIN_SINGLE(__gls_decode_bin_glsBeginObj),
    __gls_decode_bin_glsCharubz,
    BIN_SINGLE(__gls_decode_bin_glsComment),
    __gls_decode_bin_glsDisplayMapfv,
    GLS_NONE,
    __gls_decode_bin_glsNumb,
    __gls_decode_bin_glsNumbv,
    __gls_decode_bin_glsNumd,
    __gls_decode_bin_glsNumdv,
    __gls_decode_bin_glsNumf,
    __gls_decode_bin_glsNumfv,
    __gls_decode_bin_glsNumi,
    __gls_decode_bin_glsNumiv,
    __gls_decode_bin_glsNuml,
    __gls_decode_bin_glsNumlv,
    __gls_decode_bin_glsNums,
    __gls_decode_bin_glsNumsv,
    __gls_decode_bin_glsNumub,
    __gls_decode_bin_glsNumubv,
    __gls_decode_bin_glsNumui,
    __gls_decode_bin_glsNumuiv,
    __gls_decode_bin_glsNumul,
    __gls_decode_bin_glsNumulv,
    __gls_decode_bin_glsNumus,
    __gls_decode_bin_glsNumusv,
    GLS_NONE,
    __gls_decode_bin_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glNewList,
    GLS_NONE,
    __gls_decode_bin_glCallList,
    __gls_decode_bin_glCallLists,
    __gls_decode_bin_glDeleteLists,
    __gls_decode_bin_glGenLists,
    __gls_decode_bin_glListBase,
    __gls_decode_bin_glBegin,
    __gls_decode_bin_glBitmap,
    __gls_decode_bin_glColor3b,
    BIN_SINGLE(__gls_decode_bin_glColor3bv),
    __gls_decode_bin_glColor3d,
    BIN_SINGLE(__gls_decode_bin_glColor3dv),
    __gls_decode_bin_glColor3f,
    BIN_SINGLE(__gls_decode_bin_glColor3fv),
    __gls_decode_bin_glColor3i,
    BIN_SINGLE(__gls_decode_bin_glColor3iv),
    __gls_decode_bin_glColor3s,
    BIN_SINGLE(__gls_decode_bin_glColor3sv),
    __gls_decode_bin_glColor3ub,
    BIN_SINGLE(__gls_decode_bin_glColor3ubv),
    __gls_decode_bin_glColor3ui,
    BIN_SINGLE(__gls_decode_bin_glColor3uiv),
    __gls_decode_bin_glColor3us,
    BIN_SINGLE(__gls_decode_bin_glColor3usv),
    __gls_decode_bin_glColor4b,
    BIN_SINGLE(__gls_decode_bin_glColor4bv),
    __gls_decode_bin_glColor4d,
    BIN_SINGLE(__gls_decode_bin_glColor4dv),
    __gls_decode_bin_glColor4f,
    BIN_SINGLE(__gls_decode_bin_glColor4fv),
    __gls_decode_bin_glColor4i,
    BIN_SINGLE(__gls_decode_bin_glColor4iv),
    __gls_decode_bin_glColor4s,
    BIN_SINGLE(__gls_decode_bin_glColor4sv),
    __gls_decode_bin_glColor4ub,
    BIN_SINGLE(__gls_decode_bin_glColor4ubv),
    __gls_decode_bin_glColor4ui,
    BIN_SINGLE(__gls_decode_bin_glColor4uiv),
    __gls_decode_bin_glColor4us,
    BIN_SINGLE(__gls_decode_bin_glColor4usv),
    __gls_decode_bin_glEdgeFlag,
    BIN_SINGLE(__gls_decode_bin_glEdgeFlagv),
    GLS_NONE,
    __gls_decode_bin_glIndexd,
    BIN_SINGLE(__gls_decode_bin_glIndexdv),
    __gls_decode_bin_glIndexf,
    BIN_SINGLE(__gls_decode_bin_glIndexfv),
    __gls_decode_bin_glIndexi,
    BIN_SINGLE(__gls_decode_bin_glIndexiv),
    __gls_decode_bin_glIndexs,
    BIN_SINGLE(__gls_decode_bin_glIndexsv),
    __gls_decode_bin_glNormal3b,
    BIN_SINGLE(__gls_decode_bin_glNormal3bv),
    __gls_decode_bin_glNormal3d,
    BIN_SINGLE(__gls_decode_bin_glNormal3dv),
    __gls_decode_bin_glNormal3f,
    BIN_SINGLE(__gls_decode_bin_glNormal3fv),
    __gls_decode_bin_glNormal3i,
    BIN_SINGLE(__gls_decode_bin_glNormal3iv),
    __gls_decode_bin_glNormal3s,
    BIN_SINGLE(__gls_decode_bin_glNormal3sv),
    __gls_decode_bin_glRasterPos2d,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2dv),
    __gls_decode_bin_glRasterPos2f,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2fv),
    __gls_decode_bin_glRasterPos2i,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2iv),
    __gls_decode_bin_glRasterPos2s,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2sv),
    __gls_decode_bin_glRasterPos3d,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3dv),
    __gls_decode_bin_glRasterPos3f,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3fv),
    __gls_decode_bin_glRasterPos3i,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3iv),
    __gls_decode_bin_glRasterPos3s,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3sv),
    __gls_decode_bin_glRasterPos4d,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4dv),
    __gls_decode_bin_glRasterPos4f,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4fv),
    __gls_decode_bin_glRasterPos4i,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4iv),
    __gls_decode_bin_glRasterPos4s,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4sv),
    __gls_decode_bin_glRectd,
    __gls_decode_bin_glRectdv,
    __gls_decode_bin_glRectf,
    __gls_decode_bin_glRectfv,
    __gls_decode_bin_glRecti,
    __gls_decode_bin_glRectiv,
    __gls_decode_bin_glRects,
    __gls_decode_bin_glRectsv,
    __gls_decode_bin_glTexCoord1d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1dv),
    __gls_decode_bin_glTexCoord1f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1fv),
    __gls_decode_bin_glTexCoord1i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1iv),
    __gls_decode_bin_glTexCoord1s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1sv),
    __gls_decode_bin_glTexCoord2d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2dv),
    __gls_decode_bin_glTexCoord2f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2fv),
    __gls_decode_bin_glTexCoord2i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2iv),
    __gls_decode_bin_glTexCoord2s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2sv),
    __gls_decode_bin_glTexCoord3d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3dv),
    __gls_decode_bin_glTexCoord3f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3fv),
    __gls_decode_bin_glTexCoord3i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3iv),
    __gls_decode_bin_glTexCoord3s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3sv),
    __gls_decode_bin_glTexCoord4d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4dv),
    __gls_decode_bin_glTexCoord4f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4fv),
    __gls_decode_bin_glTexCoord4i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4iv),
    __gls_decode_bin_glTexCoord4s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4sv),
    __gls_decode_bin_glVertex2d,
    BIN_SINGLE(__gls_decode_bin_glVertex2dv),
    __gls_decode_bin_glVertex2f,
    BIN_SINGLE(__gls_decode_bin_glVertex2fv),
    __gls_decode_bin_glVertex2i,
    BIN_SINGLE(__gls_decode_bin_glVertex2iv),
    __gls_decode_bin_glVertex2s,
    BIN_SINGLE(__gls_decode_bin_glVertex2sv),
    __gls_decode_bin_glVertex3d,
    BIN_SINGLE(__gls_decode_bin_glVertex3dv),
    __gls_decode_bin_glVertex3f,
    BIN_SINGLE(__gls_decode_bin_glVertex3fv),
    __gls_decode_bin_glVertex3i,
    BIN_SINGLE(__gls_decode_bin_glVertex3iv),
    __gls_decode_bin_glVertex3s,
    BIN_SINGLE(__gls_decode_bin_glVertex3sv),
    __gls_decode_bin_glVertex4d,
    BIN_SINGLE(__gls_decode_bin_glVertex4dv),
    __gls_decode_bin_glVertex4f,
    BIN_SINGLE(__gls_decode_bin_glVertex4fv),
    __gls_decode_bin_glVertex4i,
    BIN_SINGLE(__gls_decode_bin_glVertex4iv),
    __gls_decode_bin_glVertex4s,
    BIN_SINGLE(__gls_decode_bin_glVertex4sv),
    __gls_decode_bin_glClipPlane,
    __gls_decode_bin_glColorMaterial,
    __gls_decode_bin_glCullFace,
    __gls_decode_bin_glFogf,
    __gls_decode_bin_glFogfv,
    __gls_decode_bin_glFogi,
    __gls_decode_bin_glFogiv,
    __gls_decode_bin_glFrontFace,
    __gls_decode_bin_glHint,
    __gls_decode_bin_glLightf,
    __gls_decode_bin_glLightfv,
    __gls_decode_bin_glLighti,
    __gls_decode_bin_glLightiv,
    __gls_decode_bin_glLightModelf,
    __gls_decode_bin_glLightModelfv,
    __gls_decode_bin_glLightModeli,
    __gls_decode_bin_glLightModeliv,
    __gls_decode_bin_glLineStipple,
    __gls_decode_bin_glLineWidth,
    __gls_decode_bin_glMaterialf,
    __gls_decode_bin_glMaterialfv,
    __gls_decode_bin_glMateriali,
    __gls_decode_bin_glMaterialiv,
    __gls_decode_bin_glPointSize,
    __gls_decode_bin_glPolygonMode,
    __gls_decode_bin_glPolygonStipple,
    __gls_decode_bin_glScissor,
    __gls_decode_bin_glShadeModel,
    __gls_decode_bin_glTexParameterf,
    __gls_decode_bin_glTexParameterfv,
    __gls_decode_bin_glTexParameteri,
    __gls_decode_bin_glTexParameteriv,
    __gls_decode_bin_glTexImage1D,
    __gls_decode_bin_glTexImage2D,
    __gls_decode_bin_glTexEnvf,
    __gls_decode_bin_glTexEnvfv,
    __gls_decode_bin_glTexEnvi,
    __gls_decode_bin_glTexEnviv,
    __gls_decode_bin_glTexGend,
    __gls_decode_bin_glTexGendv,
    __gls_decode_bin_glTexGenf,
    __gls_decode_bin_glTexGenfv,
    __gls_decode_bin_glTexGeni,
    __gls_decode_bin_glTexGeniv,
    __gls_decode_bin_glFeedbackBuffer,
    __gls_decode_bin_glSelectBuffer,
    __gls_decode_bin_glRenderMode,
    GLS_NONE,
    __gls_decode_bin_glLoadName,
    __gls_decode_bin_glPassThrough,
    GLS_NONE,
    __gls_decode_bin_glPushName,
    __gls_decode_bin_glDrawBuffer,
    __gls_decode_bin_glClear,
    __gls_decode_bin_glClearAccum,
    __gls_decode_bin_glClearIndex,
    __gls_decode_bin_glClearColor,
    __gls_decode_bin_glClearStencil,
    __gls_decode_bin_glClearDepth,
    __gls_decode_bin_glStencilMask,
    __gls_decode_bin_glColorMask,
    __gls_decode_bin_glDepthMask,
    __gls_decode_bin_glIndexMask,
    __gls_decode_bin_glAccum,
    __gls_decode_bin_glDisable,
    __gls_decode_bin_glEnable,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glPushAttrib,
    __gls_decode_bin_glMap1d,
    __gls_decode_bin_glMap1f,
    __gls_decode_bin_glMap2d,
    __gls_decode_bin_glMap2f,
    __gls_decode_bin_glMapGrid1d,
    __gls_decode_bin_glMapGrid1f,
    __gls_decode_bin_glMapGrid2d,
    __gls_decode_bin_glMapGrid2f,
    __gls_decode_bin_glEvalCoord1d,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord1dv),
    __gls_decode_bin_glEvalCoord1f,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord1fv),
    __gls_decode_bin_glEvalCoord2d,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord2dv),
    __gls_decode_bin_glEvalCoord2f,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord2fv),
    __gls_decode_bin_glEvalMesh1,
    __gls_decode_bin_glEvalPoint1,
    __gls_decode_bin_glEvalMesh2,
    __gls_decode_bin_glEvalPoint2,
    __gls_decode_bin_glAlphaFunc,
    __gls_decode_bin_glBlendFunc,
    __gls_decode_bin_glLogicOp,
    __gls_decode_bin_glStencilFunc,
    __gls_decode_bin_glStencilOp,
    __gls_decode_bin_glDepthFunc,
    __gls_decode_bin_glPixelZoom,
    __gls_decode_bin_glPixelTransferf,
    __gls_decode_bin_glPixelTransferi,
    __gls_decode_bin_glPixelStoref,
    __gls_decode_bin_glPixelStorei,
    __gls_decode_bin_glPixelMapfv,
    __gls_decode_bin_glPixelMapuiv,
    __gls_decode_bin_glPixelMapusv,
    __gls_decode_bin_glReadBuffer,
    __gls_decode_bin_glCopyPixels,
    __gls_decode_bin_glReadPixels,
    __gls_decode_bin_glDrawPixels,
    __gls_decode_bin_glGetBooleanv,
    __gls_decode_bin_glGetClipPlane,
    __gls_decode_bin_glGetDoublev,
    GLS_NONE,
    __gls_decode_bin_glGetFloatv,
    __gls_decode_bin_glGetIntegerv,
    __gls_decode_bin_glGetLightfv,
    __gls_decode_bin_glGetLightiv,
    __gls_decode_bin_glGetMapdv,
    __gls_decode_bin_glGetMapfv,
    __gls_decode_bin_glGetMapiv,
    __gls_decode_bin_glGetMaterialfv,
    __gls_decode_bin_glGetMaterialiv,
    __gls_decode_bin_glGetPixelMapfv,
    __gls_decode_bin_glGetPixelMapuiv,
    __gls_decode_bin_glGetPixelMapusv,
    __gls_decode_bin_glGetPolygonStipple,
    __gls_decode_bin_glGetString,
    __gls_decode_bin_glGetTexEnvfv,
    __gls_decode_bin_glGetTexEnviv,
    __gls_decode_bin_glGetTexGendv,
    __gls_decode_bin_glGetTexGenfv,
    __gls_decode_bin_glGetTexGeniv,
    __gls_decode_bin_glGetTexImage,
    __gls_decode_bin_glGetTexParameterfv,
    __gls_decode_bin_glGetTexParameteriv,
    __gls_decode_bin_glGetTexLevelParameterfv,
    __gls_decode_bin_glGetTexLevelParameteriv,
    __gls_decode_bin_glIsEnabled,
    __gls_decode_bin_glIsList,
    __gls_decode_bin_glDepthRange,
    __gls_decode_bin_glFrustum,
    GLS_NONE,
    BIN_SINGLE(__gls_decode_bin_glLoadMatrixf),
    BIN_SINGLE(__gls_decode_bin_glLoadMatrixd),
    __gls_decode_bin_glMatrixMode,
    BIN_SINGLE(__gls_decode_bin_glMultMatrixf),
    BIN_SINGLE(__gls_decode_bin_glMultMatrixd),
    __gls_decode_bin_glOrtho,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glRotated,
    __gls_decode_bin_glRotatef,
    __gls_decode_bin_glScaled,
    __gls_decode_bin_glScalef,
    __gls_decode_bin_glTranslated,
    __gls_decode_bin_glTranslatef,
    __gls_decode_bin_glViewport,
    // DrewB - 1.1
    __gls_decode_bin_glArrayElement,
    __gls_decode_bin_glBindTexture,
    __gls_decode_bin_glColorPointer,
    __gls_decode_bin_glDisableClientState,
    __gls_decode_bin_glDrawArrays,
    __gls_decode_bin_glDrawElements,
    __gls_decode_bin_glEdgeFlagPointer,
    __gls_decode_bin_glEnableClientState,
    __gls_decode_bin_glIndexPointer,
    __gls_decode_bin_glIndexub,
    __gls_decode_bin_glIndexubv,
    __gls_decode_bin_glInterleavedArrays,
    __gls_decode_bin_glNormalPointer,
    __gls_decode_bin_glPolygonOffset,
    __gls_decode_bin_glTexCoordPointer,
    __gls_decode_bin_glVertexPointer,
    __gls_decode_bin_glAreTexturesResident,
    __gls_decode_bin_glCopyTexImage1D,
    __gls_decode_bin_glCopyTexImage2D,
    __gls_decode_bin_glCopyTexSubImage1D,
    __gls_decode_bin_glCopyTexSubImage2D,
    __gls_decode_bin_glDeleteTextures,
    __gls_decode_bin_glGenTextures,
    __gls_decode_bin_glGetPointerv,
    __gls_decode_bin_glIsTexture,
    __gls_decode_bin_glPrioritizeTextures,
    __gls_decode_bin_glTexSubImage1D,
    __gls_decode_bin_glTexSubImage2D,
    __gls_decode_bin_glPushClientAttrib,
    GLS_NONE,
    #if __GL_EXT_blend_color
        __gls_decode_bin_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        __gls_decode_bin_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        __gls_decode_bin_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        __gls_decode_bin_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        __gls_decode_bin_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        __gls_decode_bin_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        __gls_decode_bin_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    GLS_NONE,
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        __gls_decode_bin_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        __gls_decode_bin_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        __gls_decode_bin_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        __gls_decode_bin_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    GLS_NONE, // __GL_WIN_draw_range_elements
};

const __GLSdecodeBinFunc __glsDispatchDecode_bin_swap[
    __GLS_OPCODE_COUNT
] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_swap_glsBeginGLS,
    __gls_decode_bin_swap_glsBlock,
    __gls_decode_bin_swap_glsCallStream,
    __gls_decode_bin_swap_glsEndGLS,
    __gls_decode_bin_swap_glsError,
    __gls_decode_bin_swap_glsGLRC,
    __gls_decode_bin_swap_glsGLRCLayer,
    __gls_decode_bin_swap_glsHeaderGLRCi,
    __gls_decode_bin_swap_glsHeaderLayerf,
    __gls_decode_bin_swap_glsHeaderLayeri,
    __gls_decode_bin_swap_glsHeaderf,
    __gls_decode_bin_swap_glsHeaderfv,
    __gls_decode_bin_swap_glsHeaderi,
    __gls_decode_bin_swap_glsHeaderiv,
    __gls_decode_bin_swap_glsHeaderubz,
    __gls_decode_bin_swap_glsRequireExtension,
    __gls_decode_bin_swap_glsUnsupportedCommand,
    __gls_decode_bin_swap_glsAppRef,
    __gls_decode_bin_swap_glsBeginObj,
    __gls_decode_bin_swap_glsCharubz,
    __gls_decode_bin_swap_glsComment,
    __gls_decode_bin_swap_glsDisplayMapfv,
    __gls_decode_bin_swap_glsEndObj,
    __gls_decode_bin_swap_glsNumb,
    __gls_decode_bin_swap_glsNumbv,
    __gls_decode_bin_swap_glsNumd,
    __gls_decode_bin_swap_glsNumdv,
    __gls_decode_bin_swap_glsNumf,
    __gls_decode_bin_swap_glsNumfv,
    __gls_decode_bin_swap_glsNumi,
    __gls_decode_bin_swap_glsNumiv,
    __gls_decode_bin_swap_glsNuml,
    __gls_decode_bin_swap_glsNumlv,
    __gls_decode_bin_swap_glsNums,
    __gls_decode_bin_swap_glsNumsv,
    __gls_decode_bin_swap_glsNumub,
    __gls_decode_bin_swap_glsNumubv,
    __gls_decode_bin_swap_glsNumui,
    __gls_decode_bin_swap_glsNumuiv,
    __gls_decode_bin_swap_glsNumul,
    __gls_decode_bin_swap_glsNumulv,
    __gls_decode_bin_swap_glsNumus,
    __gls_decode_bin_swap_glsNumusv,
    __gls_decode_bin_swap_glsPad,
    __gls_decode_bin_swap_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_swap_glNewList,
    __gls_decode_bin_swap_glEndList,
    __gls_decode_bin_swap_glCallList,
    __gls_decode_bin_swap_glCallLists,
    __gls_decode_bin_swap_glDeleteLists,
    __gls_decode_bin_swap_glGenLists,
    __gls_decode_bin_swap_glListBase,
    __gls_decode_bin_swap_glBegin,
    __gls_decode_bin_swap_glBitmap,
    __gls_decode_bin_swap_glColor3b,
    __gls_decode_bin_swap_glColor3bv,
    __gls_decode_bin_swap_glColor3d,
    __gls_decode_bin_swap_glColor3dv,
    __gls_decode_bin_swap_glColor3f,
    __gls_decode_bin_swap_glColor3fv,
    __gls_decode_bin_swap_glColor3i,
    __gls_decode_bin_swap_glColor3iv,
    __gls_decode_bin_swap_glColor3s,
    __gls_decode_bin_swap_glColor3sv,
    __gls_decode_bin_swap_glColor3ub,
    __gls_decode_bin_swap_glColor3ubv,
    __gls_decode_bin_swap_glColor3ui,
    __gls_decode_bin_swap_glColor3uiv,
    __gls_decode_bin_swap_glColor3us,
    __gls_decode_bin_swap_glColor3usv,
    __gls_decode_bin_swap_glColor4b,
    __gls_decode_bin_swap_glColor4bv,
    __gls_decode_bin_swap_glColor4d,
    __gls_decode_bin_swap_glColor4dv,
    __gls_decode_bin_swap_glColor4f,
    __gls_decode_bin_swap_glColor4fv,
    __gls_decode_bin_swap_glColor4i,
    __gls_decode_bin_swap_glColor4iv,
    __gls_decode_bin_swap_glColor4s,
    __gls_decode_bin_swap_glColor4sv,
    __gls_decode_bin_swap_glColor4ub,
    __gls_decode_bin_swap_glColor4ubv,
    __gls_decode_bin_swap_glColor4ui,
    __gls_decode_bin_swap_glColor4uiv,
    __gls_decode_bin_swap_glColor4us,
    __gls_decode_bin_swap_glColor4usv,
    __gls_decode_bin_swap_glEdgeFlag,
    __gls_decode_bin_swap_glEdgeFlagv,
    __gls_decode_bin_swap_glEnd,
    __gls_decode_bin_swap_glIndexd,
    __gls_decode_bin_swap_glIndexdv,
    __gls_decode_bin_swap_glIndexf,
    __gls_decode_bin_swap_glIndexfv,
    __gls_decode_bin_swap_glIndexi,
    __gls_decode_bin_swap_glIndexiv,
    __gls_decode_bin_swap_glIndexs,
    __gls_decode_bin_swap_glIndexsv,
    __gls_decode_bin_swap_glNormal3b,
    __gls_decode_bin_swap_glNormal3bv,
    __gls_decode_bin_swap_glNormal3d,
    __gls_decode_bin_swap_glNormal3dv,
    __gls_decode_bin_swap_glNormal3f,
    __gls_decode_bin_swap_glNormal3fv,
    __gls_decode_bin_swap_glNormal3i,
    __gls_decode_bin_swap_glNormal3iv,
    __gls_decode_bin_swap_glNormal3s,
    __gls_decode_bin_swap_glNormal3sv,
    __gls_decode_bin_swap_glRasterPos2d,
    __gls_decode_bin_swap_glRasterPos2dv,
    __gls_decode_bin_swap_glRasterPos2f,
    __gls_decode_bin_swap_glRasterPos2fv,
    __gls_decode_bin_swap_glRasterPos2i,
    __gls_decode_bin_swap_glRasterPos2iv,
    __gls_decode_bin_swap_glRasterPos2s,
    __gls_decode_bin_swap_glRasterPos2sv,
    __gls_decode_bin_swap_glRasterPos3d,
    __gls_decode_bin_swap_glRasterPos3dv,
    __gls_decode_bin_swap_glRasterPos3f,
    __gls_decode_bin_swap_glRasterPos3fv,
    __gls_decode_bin_swap_glRasterPos3i,
    __gls_decode_bin_swap_glRasterPos3iv,
    __gls_decode_bin_swap_glRasterPos3s,
    __gls_decode_bin_swap_glRasterPos3sv,
    __gls_decode_bin_swap_glRasterPos4d,
    __gls_decode_bin_swap_glRasterPos4dv,
    __gls_decode_bin_swap_glRasterPos4f,
    __gls_decode_bin_swap_glRasterPos4fv,
    __gls_decode_bin_swap_glRasterPos4i,
    __gls_decode_bin_swap_glRasterPos4iv,
    __gls_decode_bin_swap_glRasterPos4s,
    __gls_decode_bin_swap_glRasterPos4sv,
    __gls_decode_bin_swap_glRectd,
    __gls_decode_bin_swap_glRectdv,
    __gls_decode_bin_swap_glRectf,
    __gls_decode_bin_swap_glRectfv,
    __gls_decode_bin_swap_glRecti,
    __gls_decode_bin_swap_glRectiv,
    __gls_decode_bin_swap_glRects,
    __gls_decode_bin_swap_glRectsv,
    __gls_decode_bin_swap_glTexCoord1d,
    __gls_decode_bin_swap_glTexCoord1dv,
    __gls_decode_bin_swap_glTexCoord1f,
    __gls_decode_bin_swap_glTexCoord1fv,
    __gls_decode_bin_swap_glTexCoord1i,
    __gls_decode_bin_swap_glTexCoord1iv,
    __gls_decode_bin_swap_glTexCoord1s,
    __gls_decode_bin_swap_glTexCoord1sv,
    __gls_decode_bin_swap_glTexCoord2d,
    __gls_decode_bin_swap_glTexCoord2dv,
    __gls_decode_bin_swap_glTexCoord2f,
    __gls_decode_bin_swap_glTexCoord2fv,
    __gls_decode_bin_swap_glTexCoord2i,
    __gls_decode_bin_swap_glTexCoord2iv,
    __gls_decode_bin_swap_glTexCoord2s,
    __gls_decode_bin_swap_glTexCoord2sv,
    __gls_decode_bin_swap_glTexCoord3d,
    __gls_decode_bin_swap_glTexCoord3dv,
    __gls_decode_bin_swap_glTexCoord3f,
    __gls_decode_bin_swap_glTexCoord3fv,
    __gls_decode_bin_swap_glTexCoord3i,
    __gls_decode_bin_swap_glTexCoord3iv,
    __gls_decode_bin_swap_glTexCoord3s,
    __gls_decode_bin_swap_glTexCoord3sv,
    __gls_decode_bin_swap_glTexCoord4d,
    __gls_decode_bin_swap_glTexCoord4dv,
    __gls_decode_bin_swap_glTexCoord4f,
    __gls_decode_bin_swap_glTexCoord4fv,
    __gls_decode_bin_swap_glTexCoord4i,
    __gls_decode_bin_swap_glTexCoord4iv,
    __gls_decode_bin_swap_glTexCoord4s,
    __gls_decode_bin_swap_glTexCoord4sv,
    __gls_decode_bin_swap_glVertex2d,
    __gls_decode_bin_swap_glVertex2dv,
    __gls_decode_bin_swap_glVertex2f,
    __gls_decode_bin_swap_glVertex2fv,
    __gls_decode_bin_swap_glVertex2i,
    __gls_decode_bin_swap_glVertex2iv,
    __gls_decode_bin_swap_glVertex2s,
    __gls_decode_bin_swap_glVertex2sv,
    __gls_decode_bin_swap_glVertex3d,
    __gls_decode_bin_swap_glVertex3dv,
    __gls_decode_bin_swap_glVertex3f,
    __gls_decode_bin_swap_glVertex3fv,
    __gls_decode_bin_swap_glVertex3i,
    __gls_decode_bin_swap_glVertex3iv,
    __gls_decode_bin_swap_glVertex3s,
    __gls_decode_bin_swap_glVertex3sv,
    __gls_decode_bin_swap_glVertex4d,
    __gls_decode_bin_swap_glVertex4dv,
    __gls_decode_bin_swap_glVertex4f,
    __gls_decode_bin_swap_glVertex4fv,
    __gls_decode_bin_swap_glVertex4i,
    __gls_decode_bin_swap_glVertex4iv,
    __gls_decode_bin_swap_glVertex4s,
    __gls_decode_bin_swap_glVertex4sv,
    __gls_decode_bin_swap_glClipPlane,
    __gls_decode_bin_swap_glColorMaterial,
    __gls_decode_bin_swap_glCullFace,
    __gls_decode_bin_swap_glFogf,
    __gls_decode_bin_swap_glFogfv,
    __gls_decode_bin_swap_glFogi,
    __gls_decode_bin_swap_glFogiv,
    __gls_decode_bin_swap_glFrontFace,
    __gls_decode_bin_swap_glHint,
    __gls_decode_bin_swap_glLightf,
    __gls_decode_bin_swap_glLightfv,
    __gls_decode_bin_swap_glLighti,
    __gls_decode_bin_swap_glLightiv,
    __gls_decode_bin_swap_glLightModelf,
    __gls_decode_bin_swap_glLightModelfv,
    __gls_decode_bin_swap_glLightModeli,
    __gls_decode_bin_swap_glLightModeliv,
    __gls_decode_bin_swap_glLineStipple,
    __gls_decode_bin_swap_glLineWidth,
    __gls_decode_bin_swap_glMaterialf,
    __gls_decode_bin_swap_glMaterialfv,
    __gls_decode_bin_swap_glMateriali,
    __gls_decode_bin_swap_glMaterialiv,
    __gls_decode_bin_swap_glPointSize,
    __gls_decode_bin_swap_glPolygonMode,
    __gls_decode_bin_swap_glPolygonStipple,
    __gls_decode_bin_swap_glScissor,
    __gls_decode_bin_swap_glShadeModel,
    __gls_decode_bin_swap_glTexParameterf,
    __gls_decode_bin_swap_glTexParameterfv,
    __gls_decode_bin_swap_glTexParameteri,
    __gls_decode_bin_swap_glTexParameteriv,
    __gls_decode_bin_swap_glTexImage1D,
    __gls_decode_bin_swap_glTexImage2D,
    __gls_decode_bin_swap_glTexEnvf,
    __gls_decode_bin_swap_glTexEnvfv,
    __gls_decode_bin_swap_glTexEnvi,
    __gls_decode_bin_swap_glTexEnviv,
    __gls_decode_bin_swap_glTexGend,
    __gls_decode_bin_swap_glTexGendv,
    __gls_decode_bin_swap_glTexGenf,
    __gls_decode_bin_swap_glTexGenfv,
    __gls_decode_bin_swap_glTexGeni,
    __gls_decode_bin_swap_glTexGeniv,
    __gls_decode_bin_swap_glFeedbackBuffer,
    __gls_decode_bin_swap_glSelectBuffer,
    __gls_decode_bin_swap_glRenderMode,
    __gls_decode_bin_swap_glInitNames,
    __gls_decode_bin_swap_glLoadName,
    __gls_decode_bin_swap_glPassThrough,
    __gls_decode_bin_swap_glPopName,
    __gls_decode_bin_swap_glPushName,
    __gls_decode_bin_swap_glDrawBuffer,
    __gls_decode_bin_swap_glClear,
    __gls_decode_bin_swap_glClearAccum,
    __gls_decode_bin_swap_glClearIndex,
    __gls_decode_bin_swap_glClearColor,
    __gls_decode_bin_swap_glClearStencil,
    __gls_decode_bin_swap_glClearDepth,
    __gls_decode_bin_swap_glStencilMask,
    __gls_decode_bin_swap_glColorMask,
    __gls_decode_bin_swap_glDepthMask,
    __gls_decode_bin_swap_glIndexMask,
    __gls_decode_bin_swap_glAccum,
    __gls_decode_bin_swap_glDisable,
    __gls_decode_bin_swap_glEnable,
    __gls_decode_bin_swap_glFinish,
    __gls_decode_bin_swap_glFlush,
    __gls_decode_bin_swap_glPopAttrib,
    __gls_decode_bin_swap_glPushAttrib,
    __gls_decode_bin_swap_glMap1d,
    __gls_decode_bin_swap_glMap1f,
    __gls_decode_bin_swap_glMap2d,
    __gls_decode_bin_swap_glMap2f,
    __gls_decode_bin_swap_glMapGrid1d,
    __gls_decode_bin_swap_glMapGrid1f,
    __gls_decode_bin_swap_glMapGrid2d,
    __gls_decode_bin_swap_glMapGrid2f,
    __gls_decode_bin_swap_glEvalCoord1d,
    __gls_decode_bin_swap_glEvalCoord1dv,
    __gls_decode_bin_swap_glEvalCoord1f,
    __gls_decode_bin_swap_glEvalCoord1fv,
    __gls_decode_bin_swap_glEvalCoord2d,
    __gls_decode_bin_swap_glEvalCoord2dv,
    __gls_decode_bin_swap_glEvalCoord2f,
    __gls_decode_bin_swap_glEvalCoord2fv,
    __gls_decode_bin_swap_glEvalMesh1,
    __gls_decode_bin_swap_glEvalPoint1,
    __gls_decode_bin_swap_glEvalMesh2,
    __gls_decode_bin_swap_glEvalPoint2,
    __gls_decode_bin_swap_glAlphaFunc,
    __gls_decode_bin_swap_glBlendFunc,
    __gls_decode_bin_swap_glLogicOp,
    __gls_decode_bin_swap_glStencilFunc,
    __gls_decode_bin_swap_glStencilOp,
    __gls_decode_bin_swap_glDepthFunc,
    __gls_decode_bin_swap_glPixelZoom,
    __gls_decode_bin_swap_glPixelTransferf,
    __gls_decode_bin_swap_glPixelTransferi,
    __gls_decode_bin_swap_glPixelStoref,
    __gls_decode_bin_swap_glPixelStorei,
    __gls_decode_bin_swap_glPixelMapfv,
    __gls_decode_bin_swap_glPixelMapuiv,
    __gls_decode_bin_swap_glPixelMapusv,
    __gls_decode_bin_swap_glReadBuffer,
    __gls_decode_bin_swap_glCopyPixels,
    __gls_decode_bin_swap_glReadPixels,
    __gls_decode_bin_swap_glDrawPixels,
    __gls_decode_bin_swap_glGetBooleanv,
    __gls_decode_bin_swap_glGetClipPlane,
    __gls_decode_bin_swap_glGetDoublev,
    __gls_decode_bin_swap_glGetError,
    __gls_decode_bin_swap_glGetFloatv,
    __gls_decode_bin_swap_glGetIntegerv,
    __gls_decode_bin_swap_glGetLightfv,
    __gls_decode_bin_swap_glGetLightiv,
    __gls_decode_bin_swap_glGetMapdv,
    __gls_decode_bin_swap_glGetMapfv,
    __gls_decode_bin_swap_glGetMapiv,
    __gls_decode_bin_swap_glGetMaterialfv,
    __gls_decode_bin_swap_glGetMaterialiv,
    __gls_decode_bin_swap_glGetPixelMapfv,
    __gls_decode_bin_swap_glGetPixelMapuiv,
    __gls_decode_bin_swap_glGetPixelMapusv,
    __gls_decode_bin_swap_glGetPolygonStipple,
    __gls_decode_bin_swap_glGetString,
    __gls_decode_bin_swap_glGetTexEnvfv,
    __gls_decode_bin_swap_glGetTexEnviv,
    __gls_decode_bin_swap_glGetTexGendv,
    __gls_decode_bin_swap_glGetTexGenfv,
    __gls_decode_bin_swap_glGetTexGeniv,
    __gls_decode_bin_swap_glGetTexImage,
    __gls_decode_bin_swap_glGetTexParameterfv,
    __gls_decode_bin_swap_glGetTexParameteriv,
    __gls_decode_bin_swap_glGetTexLevelParameterfv,
    __gls_decode_bin_swap_glGetTexLevelParameteriv,
    __gls_decode_bin_swap_glIsEnabled,
    __gls_decode_bin_swap_glIsList,
    __gls_decode_bin_swap_glDepthRange,
    __gls_decode_bin_swap_glFrustum,
    __gls_decode_bin_swap_glLoadIdentity,
    __gls_decode_bin_swap_glLoadMatrixf,
    __gls_decode_bin_swap_glLoadMatrixd,
    __gls_decode_bin_swap_glMatrixMode,
    __gls_decode_bin_swap_glMultMatrixf,
    __gls_decode_bin_swap_glMultMatrixd,
    __gls_decode_bin_swap_glOrtho,
    __gls_decode_bin_swap_glPopMatrix,
    __gls_decode_bin_swap_glPushMatrix,
    __gls_decode_bin_swap_glRotated,
    __gls_decode_bin_swap_glRotatef,
    __gls_decode_bin_swap_glScaled,
    __gls_decode_bin_swap_glScalef,
    __gls_decode_bin_swap_glTranslated,
    __gls_decode_bin_swap_glTranslatef,
    __gls_decode_bin_swap_glViewport,
    // DrewB - 1.1
    __gls_decode_bin_swap_glArrayElement,
    __gls_decode_bin_swap_glBindTexture,
    __gls_decode_bin_swap_glColorPointer,
    __gls_decode_bin_swap_glDisableClientState,
    __gls_decode_bin_swap_glDrawArrays,
    __gls_decode_bin_swap_glDrawElements,
    __gls_decode_bin_swap_glEdgeFlagPointer,
    __gls_decode_bin_swap_glEnableClientState,
    __gls_decode_bin_swap_glIndexPointer,
    __gls_decode_bin_swap_glIndexub,
    __gls_decode_bin_swap_glIndexubv,
    __gls_decode_bin_swap_glInterleavedArrays,
    __gls_decode_bin_swap_glNormalPointer,
    __gls_decode_bin_swap_glPolygonOffset,
    __gls_decode_bin_swap_glTexCoordPointer,
    __gls_decode_bin_swap_glVertexPointer,
    __gls_decode_bin_swap_glAreTexturesResident,
    __gls_decode_bin_swap_glCopyTexImage1D,
    __gls_decode_bin_swap_glCopyTexImage2D,
    __gls_decode_bin_swap_glCopyTexSubImage1D,
    __gls_decode_bin_swap_glCopyTexSubImage2D,
    __gls_decode_bin_swap_glDeleteTextures,
    __gls_decode_bin_swap_glGenTextures,
    __gls_decode_bin_swap_glGetPointerv,
    __gls_decode_bin_swap_glIsTexture,
    __gls_decode_bin_swap_glPrioritizeTextures,
    __gls_decode_bin_swap_glTexSubImage1D,
    __gls_decode_bin_swap_glTexSubImage2D,
    __gls_decode_bin_swap_glPushClientAttrib,
    __gls_decode_bin_swap_glPopClientAttrib,
    #if __GL_EXT_blend_color
        __gls_decode_bin_swap_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        __gls_decode_bin_swap_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        __gls_decode_bin_swap_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        __gls_decode_bin_swap_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        __gls_decode_bin_swap_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        __gls_decode_bin_swap_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        __gls_decode_bin_swap_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        __gls_decode_bin_swap_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        __gls_decode_bin_swap_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        __gls_decode_bin_swap_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_swap_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_swap_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_swap_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_swap_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        __gls_decode_bin_swap_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_swap_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_swap_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_swap_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_swap_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        __gls_decode_bin_swap_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    GLS_NONE, // __GL_WIN_draw_range_elements
};

const __GLSdecodeTextFunc __glsDispatchDecode_text[
    __GLS_OPCODE_COUNT
] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_text_glsBeginGLS,
    __gls_decode_text_glsBlock,
    __gls_decode_text_glsCallStream,
    __gls_decode_text_glsEndGLS,
    __gls_decode_text_glsError,
    __gls_decode_text_glsGLRC,
    __gls_decode_text_glsGLRCLayer,
    __gls_decode_text_glsHeaderGLRCi,
    __gls_decode_text_glsHeaderLayerf,
    __gls_decode_text_glsHeaderLayeri,
    __gls_decode_text_glsHeaderf,
    __gls_decode_text_glsHeaderfv,
    __gls_decode_text_glsHeaderi,
    __gls_decode_text_glsHeaderiv,
    __gls_decode_text_glsHeaderubz,
    __gls_decode_text_glsRequireExtension,
    __gls_decode_text_glsUnsupportedCommand,
    __gls_decode_text_glsAppRef,
    __gls_decode_text_glsBeginObj,
    __gls_decode_text_glsCharubz,
    __gls_decode_text_glsComment,
    __gls_decode_text_glsDisplayMapfv,
    __gls_decode_text_glsEndObj,
    __gls_decode_text_glsNumb,
    __gls_decode_text_glsNumbv,
    __gls_decode_text_glsNumd,
    __gls_decode_text_glsNumdv,
    __gls_decode_text_glsNumf,
    __gls_decode_text_glsNumfv,
    __gls_decode_text_glsNumi,
    __gls_decode_text_glsNumiv,
    __gls_decode_text_glsNuml,
    __gls_decode_text_glsNumlv,
    __gls_decode_text_glsNums,
    __gls_decode_text_glsNumsv,
    __gls_decode_text_glsNumub,
    __gls_decode_text_glsNumubv,
    __gls_decode_text_glsNumui,
    __gls_decode_text_glsNumuiv,
    __gls_decode_text_glsNumul,
    __gls_decode_text_glsNumulv,
    __gls_decode_text_glsNumus,
    __gls_decode_text_glsNumusv,
    __gls_decode_text_glsPad,
    __gls_decode_text_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_text_glNewList,
    __gls_decode_text_glEndList,
    __gls_decode_text_glCallList,
    __gls_decode_text_glCallLists,
    __gls_decode_text_glDeleteLists,
    __gls_decode_text_glGenLists,
    __gls_decode_text_glListBase,
    __gls_decode_text_glBegin,
    __gls_decode_text_glBitmap,
    __gls_decode_text_glColor3b,
    __gls_decode_text_glColor3bv,
    __gls_decode_text_glColor3d,
    __gls_decode_text_glColor3dv,
    __gls_decode_text_glColor3f,
    __gls_decode_text_glColor3fv,
    __gls_decode_text_glColor3i,
    __gls_decode_text_glColor3iv,
    __gls_decode_text_glColor3s,
    __gls_decode_text_glColor3sv,
    __gls_decode_text_glColor3ub,
    __gls_decode_text_glColor3ubv,
    __gls_decode_text_glColor3ui,
    __gls_decode_text_glColor3uiv,
    __gls_decode_text_glColor3us,
    __gls_decode_text_glColor3usv,
    __gls_decode_text_glColor4b,
    __gls_decode_text_glColor4bv,
    __gls_decode_text_glColor4d,
    __gls_decode_text_glColor4dv,
    __gls_decode_text_glColor4f,
    __gls_decode_text_glColor4fv,
    __gls_decode_text_glColor4i,
    __gls_decode_text_glColor4iv,
    __gls_decode_text_glColor4s,
    __gls_decode_text_glColor4sv,
    __gls_decode_text_glColor4ub,
    __gls_decode_text_glColor4ubv,
    __gls_decode_text_glColor4ui,
    __gls_decode_text_glColor4uiv,
    __gls_decode_text_glColor4us,
    __gls_decode_text_glColor4usv,
    __gls_decode_text_glEdgeFlag,
    __gls_decode_text_glEdgeFlagv,
    __gls_decode_text_glEnd,
    __gls_decode_text_glIndexd,
    __gls_decode_text_glIndexdv,
    __gls_decode_text_glIndexf,
    __gls_decode_text_glIndexfv,
    __gls_decode_text_glIndexi,
    __gls_decode_text_glIndexiv,
    __gls_decode_text_glIndexs,
    __gls_decode_text_glIndexsv,
    __gls_decode_text_glNormal3b,
    __gls_decode_text_glNormal3bv,
    __gls_decode_text_glNormal3d,
    __gls_decode_text_glNormal3dv,
    __gls_decode_text_glNormal3f,
    __gls_decode_text_glNormal3fv,
    __gls_decode_text_glNormal3i,
    __gls_decode_text_glNormal3iv,
    __gls_decode_text_glNormal3s,
    __gls_decode_text_glNormal3sv,
    __gls_decode_text_glRasterPos2d,
    __gls_decode_text_glRasterPos2dv,
    __gls_decode_text_glRasterPos2f,
    __gls_decode_text_glRasterPos2fv,
    __gls_decode_text_glRasterPos2i,
    __gls_decode_text_glRasterPos2iv,
    __gls_decode_text_glRasterPos2s,
    __gls_decode_text_glRasterPos2sv,
    __gls_decode_text_glRasterPos3d,
    __gls_decode_text_glRasterPos3dv,
    __gls_decode_text_glRasterPos3f,
    __gls_decode_text_glRasterPos3fv,
    __gls_decode_text_glRasterPos3i,
    __gls_decode_text_glRasterPos3iv,
    __gls_decode_text_glRasterPos3s,
    __gls_decode_text_glRasterPos3sv,
    __gls_decode_text_glRasterPos4d,
    __gls_decode_text_glRasterPos4dv,
    __gls_decode_text_glRasterPos4f,
    __gls_decode_text_glRasterPos4fv,
    __gls_decode_text_glRasterPos4i,
    __gls_decode_text_glRasterPos4iv,
    __gls_decode_text_glRasterPos4s,
    __gls_decode_text_glRasterPos4sv,
    __gls_decode_text_glRectd,
    __gls_decode_text_glRectdv,
    __gls_decode_text_glRectf,
    __gls_decode_text_glRectfv,
    __gls_decode_text_glRecti,
    __gls_decode_text_glRectiv,
    __gls_decode_text_glRects,
    __gls_decode_text_glRectsv,
    __gls_decode_text_glTexCoord1d,
    __gls_decode_text_glTexCoord1dv,
    __gls_decode_text_glTexCoord1f,
    __gls_decode_text_glTexCoord1fv,
    __gls_decode_text_glTexCoord1i,
    __gls_decode_text_glTexCoord1iv,
    __gls_decode_text_glTexCoord1s,
    __gls_decode_text_glTexCoord1sv,
    __gls_decode_text_glTexCoord2d,
    __gls_decode_text_glTexCoord2dv,
    __gls_decode_text_glTexCoord2f,
    __gls_decode_text_glTexCoord2fv,
    __gls_decode_text_glTexCoord2i,
    __gls_decode_text_glTexCoord2iv,
    __gls_decode_text_glTexCoord2s,
    __gls_decode_text_glTexCoord2sv,
    __gls_decode_text_glTexCoord3d,
    __gls_decode_text_glTexCoord3dv,
    __gls_decode_text_glTexCoord3f,
    __gls_decode_text_glTexCoord3fv,
    __gls_decode_text_glTexCoord3i,
    __gls_decode_text_glTexCoord3iv,
    __gls_decode_text_glTexCoord3s,
    __gls_decode_text_glTexCoord3sv,
    __gls_decode_text_glTexCoord4d,
    __gls_decode_text_glTexCoord4dv,
    __gls_decode_text_glTexCoord4f,
    __gls_decode_text_glTexCoord4fv,
    __gls_decode_text_glTexCoord4i,
    __gls_decode_text_glTexCoord4iv,
    __gls_decode_text_glTexCoord4s,
    __gls_decode_text_glTexCoord4sv,
    __gls_decode_text_glVertex2d,
    __gls_decode_text_glVertex2dv,
    __gls_decode_text_glVertex2f,
    __gls_decode_text_glVertex2fv,
    __gls_decode_text_glVertex2i,
    __gls_decode_text_glVertex2iv,
    __gls_decode_text_glVertex2s,
    __gls_decode_text_glVertex2sv,
    __gls_decode_text_glVertex3d,
    __gls_decode_text_glVertex3dv,
    __gls_decode_text_glVertex3f,
    __gls_decode_text_glVertex3fv,
    __gls_decode_text_glVertex3i,
    __gls_decode_text_glVertex3iv,
    __gls_decode_text_glVertex3s,
    __gls_decode_text_glVertex3sv,
    __gls_decode_text_glVertex4d,
    __gls_decode_text_glVertex4dv,
    __gls_decode_text_glVertex4f,
    __gls_decode_text_glVertex4fv,
    __gls_decode_text_glVertex4i,
    __gls_decode_text_glVertex4iv,
    __gls_decode_text_glVertex4s,
    __gls_decode_text_glVertex4sv,
    __gls_decode_text_glClipPlane,
    __gls_decode_text_glColorMaterial,
    __gls_decode_text_glCullFace,
    __gls_decode_text_glFogf,
    __gls_decode_text_glFogfv,
    __gls_decode_text_glFogi,
    __gls_decode_text_glFogiv,
    __gls_decode_text_glFrontFace,
    __gls_decode_text_glHint,
    __gls_decode_text_glLightf,
    __gls_decode_text_glLightfv,
    __gls_decode_text_glLighti,
    __gls_decode_text_glLightiv,
    __gls_decode_text_glLightModelf,
    __gls_decode_text_glLightModelfv,
    __gls_decode_text_glLightModeli,
    __gls_decode_text_glLightModeliv,
    __gls_decode_text_glLineStipple,
    __gls_decode_text_glLineWidth,
    __gls_decode_text_glMaterialf,
    __gls_decode_text_glMaterialfv,
    __gls_decode_text_glMateriali,
    __gls_decode_text_glMaterialiv,
    __gls_decode_text_glPointSize,
    __gls_decode_text_glPolygonMode,
    __gls_decode_text_glPolygonStipple,
    __gls_decode_text_glScissor,
    __gls_decode_text_glShadeModel,
    __gls_decode_text_glTexParameterf,
    __gls_decode_text_glTexParameterfv,
    __gls_decode_text_glTexParameteri,
    __gls_decode_text_glTexParameteriv,
    __gls_decode_text_glTexImage1D,
    __gls_decode_text_glTexImage2D,
    __gls_decode_text_glTexEnvf,
    __gls_decode_text_glTexEnvfv,
    __gls_decode_text_glTexEnvi,
    __gls_decode_text_glTexEnviv,
    __gls_decode_text_glTexGend,
    __gls_decode_text_glTexGendv,
    __gls_decode_text_glTexGenf,
    __gls_decode_text_glTexGenfv,
    __gls_decode_text_glTexGeni,
    __gls_decode_text_glTexGeniv,
    __gls_decode_text_glFeedbackBuffer,
    __gls_decode_text_glSelectBuffer,
    __gls_decode_text_glRenderMode,
    __gls_decode_text_glInitNames,
    __gls_decode_text_glLoadName,
    __gls_decode_text_glPassThrough,
    __gls_decode_text_glPopName,
    __gls_decode_text_glPushName,
    __gls_decode_text_glDrawBuffer,
    __gls_decode_text_glClear,
    __gls_decode_text_glClearAccum,
    __gls_decode_text_glClearIndex,
    __gls_decode_text_glClearColor,
    __gls_decode_text_glClearStencil,
    __gls_decode_text_glClearDepth,
    __gls_decode_text_glStencilMask,
    __gls_decode_text_glColorMask,
    __gls_decode_text_glDepthMask,
    __gls_decode_text_glIndexMask,
    __gls_decode_text_glAccum,
    __gls_decode_text_glDisable,
    __gls_decode_text_glEnable,
    __gls_decode_text_glFinish,
    __gls_decode_text_glFlush,
    __gls_decode_text_glPopAttrib,
    __gls_decode_text_glPushAttrib,
    __gls_decode_text_glMap1d,
    __gls_decode_text_glMap1f,
    __gls_decode_text_glMap2d,
    __gls_decode_text_glMap2f,
    __gls_decode_text_glMapGrid1d,
    __gls_decode_text_glMapGrid1f,
    __gls_decode_text_glMapGrid2d,
    __gls_decode_text_glMapGrid2f,
    __gls_decode_text_glEvalCoord1d,
    __gls_decode_text_glEvalCoord1dv,
    __gls_decode_text_glEvalCoord1f,
    __gls_decode_text_glEvalCoord1fv,
    __gls_decode_text_glEvalCoord2d,
    __gls_decode_text_glEvalCoord2dv,
    __gls_decode_text_glEvalCoord2f,
    __gls_decode_text_glEvalCoord2fv,
    __gls_decode_text_glEvalMesh1,
    __gls_decode_text_glEvalPoint1,
    __gls_decode_text_glEvalMesh2,
    __gls_decode_text_glEvalPoint2,
    __gls_decode_text_glAlphaFunc,
    __gls_decode_text_glBlendFunc,
    __gls_decode_text_glLogicOp,
    __gls_decode_text_glStencilFunc,
    __gls_decode_text_glStencilOp,
    __gls_decode_text_glDepthFunc,
    __gls_decode_text_glPixelZoom,
    __gls_decode_text_glPixelTransferf,
    __gls_decode_text_glPixelTransferi,
    __gls_decode_text_glPixelStoref,
    __gls_decode_text_glPixelStorei,
    __gls_decode_text_glPixelMapfv,
    __gls_decode_text_glPixelMapuiv,
    __gls_decode_text_glPixelMapusv,
    __gls_decode_text_glReadBuffer,
    __gls_decode_text_glCopyPixels,
    __gls_decode_text_glReadPixels,
    __gls_decode_text_glDrawPixels,
    __gls_decode_text_glGetBooleanv,
    __gls_decode_text_glGetClipPlane,
    __gls_decode_text_glGetDoublev,
    __gls_decode_text_glGetError,
    __gls_decode_text_glGetFloatv,
    __gls_decode_text_glGetIntegerv,
    __gls_decode_text_glGetLightfv,
    __gls_decode_text_glGetLightiv,
    __gls_decode_text_glGetMapdv,
    __gls_decode_text_glGetMapfv,
    __gls_decode_text_glGetMapiv,
    __gls_decode_text_glGetMaterialfv,
    __gls_decode_text_glGetMaterialiv,
    __gls_decode_text_glGetPixelMapfv,
    __gls_decode_text_glGetPixelMapuiv,
    __gls_decode_text_glGetPixelMapusv,
    __gls_decode_text_glGetPolygonStipple,
    __gls_decode_text_glGetString,
    __gls_decode_text_glGetTexEnvfv,
    __gls_decode_text_glGetTexEnviv,
    __gls_decode_text_glGetTexGendv,
    __gls_decode_text_glGetTexGenfv,
    __gls_decode_text_glGetTexGeniv,
    __gls_decode_text_glGetTexImage,
    __gls_decode_text_glGetTexParameterfv,
    __gls_decode_text_glGetTexParameteriv,
    __gls_decode_text_glGetTexLevelParameterfv,
    __gls_decode_text_glGetTexLevelParameteriv,
    __gls_decode_text_glIsEnabled,
    __gls_decode_text_glIsList,
    __gls_decode_text_glDepthRange,
    __gls_decode_text_glFrustum,
    __gls_decode_text_glLoadIdentity,
    __gls_decode_text_glLoadMatrixf,
    __gls_decode_text_glLoadMatrixd,
    __gls_decode_text_glMatrixMode,
    __gls_decode_text_glMultMatrixf,
    __gls_decode_text_glMultMatrixd,
    __gls_decode_text_glOrtho,
    __gls_decode_text_glPopMatrix,
    __gls_decode_text_glPushMatrix,
    __gls_decode_text_glRotated,
    __gls_decode_text_glRotatef,
    __gls_decode_text_glScaled,
    __gls_decode_text_glScalef,
    __gls_decode_text_glTranslated,
    __gls_decode_text_glTranslatef,
    __gls_decode_text_glViewport,
    // DrewB - 1.1
    __gls_decode_text_glArrayElement,
    __gls_decode_text_glBindTexture,
    __gls_decode_text_glColorPointer,
    __gls_decode_text_glDisableClientState,
    __gls_decode_text_glDrawArrays,
    __gls_decode_text_glDrawElements,
    __gls_decode_text_glEdgeFlagPointer,
    __gls_decode_text_glEnableClientState,
    __gls_decode_text_glIndexPointer,
    __gls_decode_text_glIndexub,
    __gls_decode_text_glIndexubv,
    __gls_decode_text_glInterleavedArrays,
    __gls_decode_text_glNormalPointer,
    __gls_decode_text_glPolygonOffset,
    __gls_decode_text_glTexCoordPointer,
    __gls_decode_text_glVertexPointer,
    __gls_decode_text_glAreTexturesResident,
    __gls_decode_text_glCopyTexImage1D,
    __gls_decode_text_glCopyTexImage2D,
    __gls_decode_text_glCopyTexSubImage1D,
    __gls_decode_text_glCopyTexSubImage2D,
    __gls_decode_text_glDeleteTextures,
    __gls_decode_text_glGenTextures,
    __gls_decode_text_glGetPointerv,
    __gls_decode_text_glIsTexture,
    __gls_decode_text_glPrioritizeTextures,
    __gls_decode_text_glTexSubImage1D,
    __gls_decode_text_glTexSubImage2D,
    __gls_decode_text_glPushClientAttrib,
    __gls_decode_text_glPopClientAttrib,
    #if __GL_EXT_blend_color
        __gls_decode_text_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        __gls_decode_text_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        __gls_decode_text_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        __gls_decode_text_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        __gls_decode_text_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        __gls_decode_text_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        __gls_decode_text_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        __gls_decode_text_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode