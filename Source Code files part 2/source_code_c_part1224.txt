
PermediaSourceChromaBlt(    PPDev ppdev, 
                            LPDDHAL_BLTDATA lpBlt, 
                            PermediaSurfaceData* pDest, 
                            PermediaSurfaceData* pSource, 
                            RECTL *rDest, 
                            RECTL *rSrc, 
                            DWORD dwWindowBase, 
                            DWORD dwSourceOffset
                            )
{
    DWORD dwLowerBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
    DWORD dwUpperBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue;
    DWORD dwRenderDirection;
    LONG lPixelSize=pDest->SurfaceFormat.PixelSize;

    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 5, "DDraw:PermediaSourceChromaBlt"));

    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");

    // Changes pixel depth to Frame buffer pixel depth if neccessary.

    ConvertColorKeys( pSource, dwLowerBound, dwUpperBound);

    RESERVEDMAPTR(31);

    SEND_PERMEDIA_DATA(FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    if (lPixelSize != 0)
    {
        
        // set writeback to dest surface...
        SEND_PERMEDIA_DATA( DitherMode,
                            (pDest->SurfaceFormat.ColorOrder << 
                                PM_DITHERMODE_COLORORDER) | 
                            (pDest->SurfaceFormat.Format << 
                                PM_DITHERMODE_COLORFORMAT) |
                            (pDest->SurfaceFormat.FormatExtension << 
                                PM_DITHERMODE_COLORFORMATEXTENSION) |
                            (1 << PM_DITHERMODE_ENABLE)); 
        
    } 

    
    // Reject range
    SEND_PERMEDIA_DATA(YUVMode, PM_YUVMODE_CHROMATEST_FAILWITHIN << 1);
    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);

    // set no read of source.
    // add read src/dest enable
    SEND_PERMEDIA_DATA(FBReadMode,pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    //
    // modulate & ramp??
    SEND_PERMEDIA_DATA(TextureColorMode, (1 << PM_TEXCOLORMODE_ENABLE) |
                                         (_P2_TEXTURE_COPY << 
                                            PM_TEXCOLORMODE_APPLICATION));

    SEND_PERMEDIA_DATA(TextureReadMode, 
                       PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                       PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                       PM_TEXREADMODE_WIDTH(11) |
                       PM_TEXREADMODE_HEIGHT(11) );

    SEND_PERMEDIA_DATA(TextureDataFormat,   
                       (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                       (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                       (pSource->SurfaceFormat.ColorOrder << 
                            PM_TEXDATAFORMAT_COLORORDER));

    SEND_PERMEDIA_DATA( TextureMapFormat, 
                        (pSource->ulPackedPP) | 
                        (pSource->SurfaceFormat.PixelSize << 
                            PM_TEXMAPFORMAT_TEXELSIZE) );


    SEND_PERMEDIA_DATA(ChromaLowerBound, dwLowerBound);
    SEND_PERMEDIA_DATA(ChromaUpperBound, dwUpperBound);
    
    if ((lpBlt->lpDDDestSurface->lpGbl->fpVidMem) != 
        (lpBlt->lpDDSrcSurface->lpGbl->fpVidMem))
    {
        dwRenderDirection = 1;
    }
    else
    {
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else if(rSrc->left < rDest->left)
        {
            dwRenderDirection = 0;
        }
        else dwRenderDirection = 1;
    }

    /*
     * Render the rectangle
     */

    // Left -> right, top->bottom
    if (dwRenderDirection)
    {
        // set offset of source
        SEND_PERMEDIA_DATA(SStart,    rSrc->left<<20);
        SEND_PERMEDIA_DATA(TStart,    rSrc->top<<20);
        SEND_PERMEDIA_DATA(dSdx,      1 << 20);
        SEND_PERMEDIA_DATA(dSdyDom,   0);
        SEND_PERMEDIA_DATA(dTdx,      0);
        SEND_PERMEDIA_DATA(dTdyDom,   1 << 20);

        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }
    else
    // right->left, bottom->top
    {
        // set offset of source
        SEND_PERMEDIA_DATA(SStart,    rSrc->right << 20);
        SEND_PERMEDIA_DATA(TStart,    (rSrc->bottom - 1) << 20);
        SEND_PERMEDIA_DATA(dSdx,      (DWORD)(-1 << 20));
        SEND_PERMEDIA_DATA(dSdyDom,   0);
        SEND_PERMEDIA_DATA(dTdx,      0);
        SEND_PERMEDIA_DATA(dTdyDom,   (DWORD)(-1 << 20));

        // Render right to left, bottom to top
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY,        (DWORD)INTtoFIXED(-1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }


    // Turn off chroma key
    SEND_PERMEDIA_DATA(YUVMode, 0x0);

    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    if (pSource->SurfaceFormat.PixelSize != 0)
    {   
        SEND_PERMEDIA_DATA(DitherMode, 0);
    }

    COMMITDMAPTR();
    FLUSHDMA();

}   // PermediaSourceChromaBlt 

//--------------------------------------------------------------------------
//
// PermediaStretchCopyChromaBlt
//
// Does a blit through the texture unit to allow stretching.  Also
// handle mirroring and chroma keying if the stretched image requires it.
//
//--------------------------------------------------------------------------

VOID 
PermediaStretchCopyChromaBlt(   PPDev ppdev, 
                                LPDDHAL_BLTDATA lpBlt, 
                                PermediaSurfaceData* pDest, 
                                PermediaSurfaceData* pSource, 
                                RECTL *rDest, 
                                RECTL *rSrc, 
                                DWORD dwWindowBase, 
                                DWORD dwSourceOffset
                                )
{
    LONG lXScale;
    LONG lYScale;
    BOOL bYMirror;
    BOOL bXMirror;
    DWORD dwDestWidth = rDest->right - rDest->left;
    DWORD dwDestHeight = rDest->bottom - rDest->top;
    DWORD dwSourceWidth = rSrc->right - rSrc->left;
    DWORD dwSourceHeight = rSrc->bottom - rSrc->top;
    DWORD dwTexSStart, dwTexTStart;
    DWORD dwRenderDirection;
    LONG lPixelSize=pDest->SurfaceFormat.PixelSize;

    DWORD dwLowerBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
    DWORD dwUpperBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue;
    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 5, "DDraw:PermediaStretchCopyChromaBlt"));

    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");

    // Changes pixel depth to Frame buffer pixel depth if neccessary.

    ConvertColorKeys( pSource, dwLowerBound, dwUpperBound);

    RESERVEDMAPTR(31);

    SEND_PERMEDIA_DATA(FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    if (lPixelSize != 0)
    {

        // set writeback to dest surface...
        SEND_PERMEDIA_DATA( DitherMode,  
                            (pDest->SurfaceFormat.ColorOrder << 
                                PM_DITHERMODE_COLORORDER) | 
                            (pDest->SurfaceFormat.Format << 
                                PM_DITHERMODE_COLORFORMAT) |
                            (pDest->SurfaceFormat.FormatExtension << 
                                PM_DITHERMODE_COLORFORMATEXTENSION) |
                            (1 << PM_DITHERMODE_ENABLE)); 

    } 

    // Reject range
    SEND_PERMEDIA_DATA(YUVMode, PM_YUVMODE_CHROMATEST_FAILWITHIN <<1);
    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);

    // set no read of source.
    SEND_PERMEDIA_DATA(FBReadMode, pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    
    SEND_PERMEDIA_DATA( TextureColorMode,
                        (1 << PM_TEXCOLORMODE_ENABLE) |
                        (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION));

    SEND_PERMEDIA_DATA( TextureReadMode, 
                        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                        PM_TEXREADMODE_WIDTH(11) |
                        PM_TEXREADMODE_HEIGHT(11));

    lXScale = (dwSourceWidth << 20) / (dwDestWidth);
    lYScale = (dwSourceHeight << 20) / (dwDestHeight);

    SEND_PERMEDIA_DATA( TextureDataFormat,
                        (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                        (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                        (pSource->SurfaceFormat.ColorOrder << 
                            PM_TEXDATAFORMAT_COLORORDER));

    SEND_PERMEDIA_DATA( TextureMapFormat, 
                        (pSource->ulPackedPP) | 
                        (pSource->SurfaceFormat.PixelSize << 
                            PM_TEXMAPFORMAT_TEXELSIZE) );

    bYMirror = FALSE;
    bXMirror = FALSE;

    if ((lpBlt->lpDDDestSurface->lpGbl->fpVidMem) != 
        (lpBlt->lpDDSrcSurface->lpGbl->fpVidMem))
    {
        dwRenderDirection = 1;
    }
    else
    {
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else if(rSrc->left < rDest->left)
        {
            dwRenderDirection = 0;
        }
        else dwRenderDirection = 1;
    }

    if(lpBlt->dwFlags & DDBLT_DDFX)
    {
        bYMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN;
        bXMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT;

    } else
    {
        if (dwRenderDirection==0)
        {
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    if (bXMirror)        
    {
        dwTexSStart = rSrc->right - 1;
        lXScale = -lXScale;
    }   
    else
    {
        dwTexSStart = rSrc->left;
    }

    if (bYMirror)        
    {
        dwTexTStart = rSrc->bottom - 1;
        lYScale = -lYScale;
    }
    else
    {
        dwTexTStart = rSrc->top;
    }

    SEND_PERMEDIA_DATA(dTdyDom, lYScale);
    SEND_PERMEDIA_DATA(ChromaLowerBound, dwLowerBound);
    SEND_PERMEDIA_DATA(ChromaUpperBound, dwUpperBound);

    // set texture coordinates
    SEND_PERMEDIA_DATA(SStart,      dwTexSStart << 20);
    SEND_PERMEDIA_DATA(TStart,      dwTexTStart << 20);
    SEND_PERMEDIA_DATA(dSdx,        lXScale);
    SEND_PERMEDIA_DATA(dSdyDom,     0);
    SEND_PERMEDIA_DATA(dTdx,        0);

    //
    // Render the rectangle
    //

    if (dwRenderDirection)
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    }
    else
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY,        (DWORD)INTtoFIXED(-1));
    }

    SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                  __RENDER_TEXTURED_PRIMITIVE);


    // Turn off units
    SEND_PERMEDIA_DATA(YUVMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    if (pSource->SurfaceFormat.PixelSize != 0)
    {
        SEND_PERMEDIA_DATA(DitherMode, 0);
    }

    COMMITDMAPTR();
    FLUSHDMA();

} // PermediaStretchCopyChromaBlt 

//--------------------------------------------------------------------------
//
// PermediaYUVtoRGB
//
// Permedia2 YUV to RGB conversion blt
//
//--------------------------------------------------------------------------


VOID 
PermediaYUVtoRGB(   PPDev ppdev, 
                    DDBLTFX* lpBltFX, 
                    PermediaSurfaceData* pDest, 
                    PermediaSurfaceData* pSource, 
                    RECTL *rDest, 
                    RECTL *rSrc, 
                    DWORD dwWindowBase, 
                    DWORD dwSourceOffset)
{
    DWORD lXScale;
    DWORD lYScale;
    DWORD dwDestWidth = rDest->right - rDest->left;
    DWORD dwDestHeight = rDest->bottom - rDest->top;
    DWORD dwSourceWidth = rSrc->right - rSrc->left;
    DWORD dwSourceHeight = rSrc->bottom - rSrc->top;
    PERMEDIA_DEFS(ppdev);
    
    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");
    
    lXScale = (dwSourceWidth << 20) / dwDestWidth;
    lYScale = (dwSourceHeight << 20) / dwDestHeight;
    
    // Changes pixel depth to Frame buffer pixel depth if neccessary.
    
    RESERVEDMAPTR(29);

    SEND_PERMEDIA_DATA(FBReadPixel,ppdev->bPixShift);
    
    if (pDest->SurfaceFormat.PixelSize != __PERMEDIA_8BITPIXEL)
    {
        SEND_PERMEDIA_DATA(DitherMode, 
            (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
            (pDest->SurfaceFormat.Format << PM_DITHERMODE_COLORFORMAT) |
            (pDest->SurfaceFormat.FormatExtension << 
                PM_DITHERMODE_COLORFORMATEXTENSION) |
            (1 << PM_DITHERMODE_ENABLE) |
            (1 << PM_DITHERMODE_DITHERENABLE));
    }
    
    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);
    
    // set no read of source.
    SEND_PERMEDIA_DATA(FBReadMode, pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    
    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    
    SEND_PERMEDIA_DATA( TextureColorMode,
                        (1 << PM_TEXCOLORMODE_ENABLE) |
                        (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION));
    
    SEND_PERMEDIA_DATA( TextureReadMode, 
                        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                        PM_TEXREADMODE_FILTER(__PERMEDIA_ENABLE) |
                        PM_TEXREADMODE_WIDTH(11) |
                        PM_TEXREADMODE_HEIGHT(11) );
    
    SEND_PERMEDIA_DATA( TextureDataFormat, 
                        (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                        (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                        (INV_COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER));
    
    SEND_PERMEDIA_DATA( TextureMapFormat,    
                        (pSource->ulPackedPP) | 
                        (pSource->SurfaceFormat.PixelSize << 
                            PM_TEXMAPFORMAT_TEXELSIZE) );
    
    // Turn on the YUV unit
    SEND_PERMEDIA_DATA(YUVMode, 0x1);
    
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);
    
    // set offset of source
    SEND_PERMEDIA_DATA(SStart,    rSrc->left << 20);
    SEND_PERMEDIA_DATA(TStart,    rSrc->top << 20);
    SEND_PERMEDIA_DATA(dSdx,      lXScale);
    SEND_PERMEDIA_DATA(dSdyDom,   0);
    SEND_PERMEDIA_DATA(dTdx,      0);
    SEND_PERMEDIA_DATA(dTdyDom, lYScale);
    
    
    // Render the rectangle
    //
    SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
    SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
    SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
    SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                  __RENDER_TEXTURED_PRIMITIVE);
    
    if (pSource->SurfaceFormat.PixelSize != __PERMEDIA_8BITPIXEL)
    {
        SEND_PERMEDIA_DATA(DitherMode, 0);
    }
    
    // Turn off units
    SEND_PERMEDIA_DATA(YUVMode, 0x0);
    SEND_PERMEDIA_DATA( TextureAddressMode,
                        (0 << PM_TEXADDRESSMODE_ENABLE));
    SEND_PERMEDIA_DATA( TextureColorMode,    
                        (0 << PM_TEXCOLORMODE_ENABLE));
    COMMITDMAPTR();
    FLUSHDMA();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\ddenable.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddenable.c
*
* Content:    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"


//-----------------------------------------------------------------------------
//
//  SetDdPixelFormat
//
//  fill a DDPIXELFORMAT structure based with the current mode info
//
//-----------------------------------------------------------------------------

VOID 
SetDdPixelFormat(PPDev  ppdev,
                 LPDDPIXELFORMAT pdpf )
{
    pdpf->dwSize = sizeof( DDPIXELFORMAT );
    pdpf->dwFourCC = 0;
    
    pdpf->dwFlags = DDPF_RGB;
    
    pdpf->dwRBitMask = ppdev->flRed;
    pdpf->dwGBitMask = ppdev->flGreen;
    pdpf->dwBBitMask = ppdev->flBlue;
    
    // Calculate some bitdepth dependent stuff
    switch (ppdev->iBitmapFormat)
    {
    case BMF_8BPP:
        pdpf->dwRGBAlphaBitMask = 0;
        pdpf->dwRGBBitCount=8;
        pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
        break;
        
    case BMF_16BPP:
        pdpf->dwRGBBitCount=16;
        switch(ppdev->flRed)
        {
        case 0x7C00:
            pdpf->dwRGBAlphaBitMask = 0x8000L;
            break;
        default:
            pdpf->dwRGBAlphaBitMask = 0x0L;
        }
        break;
    case BMF_24BPP:
        pdpf->dwRGBAlphaBitMask = 0x00000000L;
        pdpf->dwRGBBitCount=24;
        break;
    case BMF_32BPP:
        pdpf->dwRGBAlphaBitMask = 0xff000000L;
        pdpf->dwRGBBitCount=32;
        break;
    default:
        ASSERTDD(FALSE,"trying to build unknown pixelformat");
        break;
            
    }
} // buildPixelFormat 

//-----------------------------------------------------------------------------
//
//  SetupDDData
//
//  Called to fill in DirectDraw specific information in the ppdev.
//
//-----------------------------------------------------------------------------

VOID
SetupDDData(PPDev ppdev)
{

    DBG_DD((7, "SetupDDData"));
    
    SetDdPixelFormat(ppdev, &ppdev->ddpfDisplay);
    

    //
    // Setup the display size information
    // cxMemory = Pixels across for one scanline 
    //      (not necessarily the same as the screen width)
    // cyMemory = Scanline height of the memory
    //
    ppdev->cxMemory = ppdev->cxScreen; 
    ppdev->cyMemory = ppdev->FrameBufferLength / 
                     (ppdev->cxScreen <<  ppdev->bPixShift);

    // reset some DDraw specific vars
    ppdev->bDdStereoMode=FALSE;
    ppdev->dwNewDDSurfaceOffset=0xffffffff;
    
    // Reset the GART copies.
    ppdev->dwGARTLin = 0;
    ppdev->dwGARTDev = 0;

}//  SetupDDData()



//-----------------------------------------------------------------------------
//
// DrvEnableDirectDraw
//
// This function is called by GDI at start of day or after a mode switch
// to enable DirectDraw 
//
//-----------------------------------------------------------------------------

BOOL 
DrvEnableDirectDraw(DHPDEV                  dhpdev,
                    DD_CALLBACKS*           pCallBacks,
                    DD_SURFACECALLBACKS*    pSurfaceCallBacks,
                    DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PPDev ppdev = (PDev*)dhpdev;
    
    DBG_DD((7,"DrvEnableDirectDraw called"));

    ppdev->pDDContext = P2AllocateNewContext(ppdev, 
                                             (PULONG)P2DisableAllUnits, 
                                             0, 
                                             P2CtxtUserFunc);

    if ( ppdev->pDDContext == NULL )
    {
        DBG_DD((0, "DrvEnableDirectDraw: ERROR: "
                    "failed to allocate DDRAW context"));
        
        //
        // Since we have already got the ppdev->pvmList, pointer to video memory
        // heap list, in DrvGetDirectDrawInfo(), we better NULL it out here.
        // The reason is that we can't enable DirectDraw. So the system won't
        // initialize the DDRAW heap manager for us. Then we won't be able to
        // use the video memory heap at all.
        //
        ppdev->pvmList = NULL;

        return(FALSE);
    }

    DBG_DD((7,"  Created DD Register context: 0x%p", ppdev->pDDContext));

    //
    //  setup some DirectDraw/D3D specific data in ppdev
    //

    SetupDDData(ppdev);

    InitDDHAL(ppdev);
    
    //
    // Fill in the function pointers at start of day.  
    // We copy these from the Initialisation done in InitDDHAL32Bit.
    //
    memcpy(pCallBacks, &ppdev->DDHALCallbacks, sizeof(DD_CALLBACKS));
    memcpy(pSurfaceCallBacks, &ppdev->DDSurfCallbacks, 
        sizeof(DD_SURFACECALLBACKS));
    
    return(TRUE);
} // DrvEnableDirectDraw()

//-----------------------------------------------------------------------------
//
//  DrvDisableDirectDraw
//
//  This function is called by GDI at end of day or after a mode switch
//
//-----------------------------------------------------------------------------

VOID 
DrvDisableDirectDraw( DHPDEV dhpdev)
{
    PPDev ppdev;
    
    DBG_DD((0, "DrvDisableDirectDraw(%lx)", dhpdev));
    
    ppdev = (PDev*) dhpdev;

    P2FreeContext (ppdev, ppdev->pDDContext);
    ppdev->pDDContext = NULL;
    ppdev->pvmList = NULL;

    MEMTRACKERDEBUGCHK();

    DBG_DD((3,"  freed Register context: 0x%x", ppdev->pDDContext));
}   /* DrvDisableDirectDraw */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\ddsurf.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddsurf.c
*
*  Content:    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"
#include "heap.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_US2P
// Texture tables defined in the D3D side of the driver (d3d.c)
// TODO: move to dd.h or d3d.h
extern ULONG gD3DNumberOfTextureFormats;
extern DDSURFACEDESC gD3DTextureFormats[];


//---------------------------------------------------------------------------
// BOOL bComparePixelFormat
//
// Function used to compare 2 pixels formats for equality. This is a 
// helper function to bCheckTextureFormat. A return value of TRUE indicates 
// equality
//
//---------------------------------------------------------------------------


BOOL 
bComparePixelFormat(LPDDPIXELFORMAT lpddpf1, LPDDPIXELFORMAT lpddpf2)
{
    if (lpddpf1->dwFlags != lpddpf2->dwFlags)
    {
        return FALSE;
    }

    // same bitcount for non-YUV surfaces?
    if (!(lpddpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)))
    {
        if (lpddpf1->dwRGBBitCount != lpddpf2->dwRGBBitCount )
        {
            return FALSE;
        }
    }

    // same RGB properties?
    if (lpddpf1->dwFlags & DDPF_RGB)
    {
        if ((lpddpf1->dwRBitMask != lpddpf2->dwRBitMask) ||
            (lpddpf1->dwGBitMask != lpddpf2->dwGBitMask) ||
            (lpddpf1->dwBBitMask != lpddpf2->dwBBitMask) ||
            (lpddpf1->dwRGBAlphaBitMask != lpddpf2->dwRGBAlphaBitMask))
        { 
             return FALSE;
        }
    }
    
    // same YUV properties?
    if (lpddpf1->dwFlags & DDPF_YUV)	
    {
        if ((lpddpf1->dwFourCC != lpddpf2->dwFourCC) ||
            (lpddpf1->dwYUVBitCount != lpddpf2->dwYUVBitCount) ||
            (lpddpf1->dwYBitMask != lpddpf2->dwYBitMask) ||
            (lpddpf1->dwUBitMask != lpddpf2->dwUBitMask) ||
            (lpddpf1->dwVBitMask != lpddpf2->dwVBitMask) ||
            (lpddpf1->dwYUVAlphaBitMask != lpddpf2->dwYUVAlphaBitMask))
        {
             return FALSE;
        }
    }
    else if (lpddpf1->dwFlags & DDPF_FOURCC)
    {
        if (lpddpf1->dwFourCC != lpddpf2->dwFourCC)
        {
            return FALSE;
        }
    }

    // If Interleaved Z then check Z bit masks are the same
    if (lpddpf1->dwFlags & DDPF_ZPIXELS)
    {
        if (lpddpf1->dwRGBZBitMask != lpddpf2->dwRGBZBitMask)
        {
            return FALSE;
        }
    }

    return TRUE;
} // bComparePixelFormat

//---------------------------------------------------------------------------
//
// BOOL bCheckTextureFormat
//
// Function used to determine if a texture format is supported. It traverses 
// the deviceTextureFormats list. We use this in DdCanCreateSurface32. A
// return value of TRUE indicates that we do support the requested texture 
// format.
//
//---------------------------------------------------------------------------

BOOL 
bCheckTextureFormat(LPDDPIXELFORMAT lpddpf)
{
    DWORD i;

    // Run the list for a matching format
    for (i=0; i < gD3DNumberOfTextureFormats; i++)
    {
        if (bComparePixelFormat(lpddpf, 
                                &gD3DTextureFormats[i].ddpfPixelFormat))
        {
            return TRUE;
        }   
    }

    return FALSE;
} // bCheckTextureFormat


//-----------------------------------------------------------------------------
//
// DdCanCreateSurface32
//
// This entry point is called after parameter validation but before
// any object creation. You can decide here if it is possible for
// you to create this surface.  For example, if the person is trying
// to create an overlay, and you already have the maximum number of
// overlays created, this is the place to fail the call.
//
// You also need to check if the pixel format specified can be supported.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
DdCanCreateSurface(LPDDHAL_CANCREATESURFACEDATA pccsd)
{    
    PPDev ppdev=(PPDev)pccsd->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    PDD_SURFACEDESC lpDDS=pccsd->lpDDSurfaceDesc;
    
    DBG_DD((2,"DDraw:DdCanCreateSurface"));
    
    if(lpDDS->dwLinearSize == 0)
    {
        // rectangular surface
        // Reject all widths larger than we can create partial products for.
        DUMPSURFACE(10, NULL, lpDDS);
        
        if (lpDDS->dwWidth > (ULONG)(2 << MAX_PARTIAL_PRODUCT_P2)) 
        {
            DBG_DD((1,"DDraw:DdCanCreateSurface: Surface rejected:"));
            DBG_DD((1,"  Width Requested: %ld (max. %ld)", 
                lpDDS->dwWidth,(2 << MAX_PARTIAL_PRODUCT_P2)));

            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;
        }
    }
    
    // We only support 16bits & 15bits (for stencils) Z-Buffer on PERMEDIA
    if ((lpDDS->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) &&
        (lpDDS->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        DWORD dwBitDepth;
        
        // verify where the right z buffer bit depth is
        if (DDSD_ZBUFFERBITDEPTH & lpDDS->dwFlags)
            dwBitDepth = lpDDS->dwZBufferBitDepth;
        else
            dwBitDepth = lpDDS->ddpfPixelFormat.dwZBufferBitDepth;
        
        // Notice we have to check for a BitDepth of 16 even if a stencil 
        // buffer is present. dwZBufferBitDepth in this case will be the 
        // sum of the z buffer and the stencil buffer bit depth.
        if (dwBitDepth == 16)
        {
            pccsd->ddRVal = DD_OK;
        }
        else
        {
            DBG_DD((2,"DDraw:DdCanCreateSurface: ERROR: "
                       "Depth buffer not 16Bits! - %d", dwBitDepth));
            
            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            
        }
        return DDHAL_DRIVER_HANDLED;
    }

    // pccsd->bIsDifferentPixelFormat tells us if the pixel format of the
    // surface being created matches that of the primary surface.  It can be
    // true for Z buffer and alpha buffers, so don't just reject it out of
    // hand...
 
    if (pccsd->bIsDifferentPixelFormat)
    {
        DBG_DD((3,"  Pixel Format is different to primary"));

        if(lpDDS->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
        {
            DBG_DD((3, "  FourCC requested (%4.4hs, 0x%08lx)", (LPSTR) 
                        &lpDDS->ddpfPixelFormat.dwFourCC,
                        lpDDS->ddpfPixelFormat.dwFourCC ));

            switch (lpDDS->ddpfPixelFormat.dwFourCC)
            {
            case FOURCC_YUV422:
                DBG_DD((3,"  Surface requested is YUV422"));
                if (ppdev->iBitmapFormat == BMF_8BPP)
                {
                    pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                } else
                {
                    lpDDS->ddpfPixelFormat.dwYUVBitCount = 16;
                    pccsd->ddRVal = DD_OK;
                }
                return DDHAL_DRIVER_HANDLED;

            default:
                DBG_DD((3,"  ERROR: Invalid FOURCC requested, refusing"));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
            }
        }
        else if((lpDDS->ddsCaps.dwCaps & DDSCAPS_TEXTURE))
        {

            if (bCheckTextureFormat(&pccsd->lpDDSurfaceDesc->ddpfPixelFormat))
            {
                // texture surface is in one or our supported texture formats
                DBG_DD((3, "  Texture Surface - OK" ));
                pccsd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }
            else
            {
                // we don't support this kind of texture format
                DBG_DD((3, "  ERROR: Texture Surface - NOT OK" ));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
            }
        } 
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
        else if (ValidRGBAlphaSurfaceformat(
                 &lpDDS->ddpfPixelFormat, 
                 NULL))
        {
            DBG_DD((3, "  RGB alpha Surface - OK" ));

            if (lpDDS->ddpfPixelFormat.dwRGBBitCount!=24)
            {
                pccsd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }

        }
#endif
//@@END_DDKSPLIT
        pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
    }
    
    pccsd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdCanCreateSurface32 

//-----------------------------------------------------------------------------
//
//  DdCreateSurface
//
//  This function is called by DirectDraw if a new surface is created. If the 
//  driver has its own memory manager, here is the place to allocate the 
//  videomemory or to fail the call. Note that we return 
//  DDHAL_DRIVER_NOTHANDLED here to indicate that we do not manage the heap.
//  fpVidMem is set to DDHAL_PLEASEALLOC_BLOCKSIZE, and the DDraw memory
//  manager wll allocate the memory for us.
//  
//  Note that the Permedia chip requires a partial product
//  to be setup for each surface.  They also limit the widths to a multiple
//  of 32 for the Partial Products to work.  The below code adjusts the
//  surfaces to meet this requirement.  Note that if we are using a
//  rectangular allocation scheme, the surface is already OK as the desktop
//  is a good width anyway.  This code also handles YUV 16 Bit colour space
//  compressed format (FOURCC_YUV422) which will always be 16 bits, regardless
//  of the desktop resolution/requested depth.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
DdCreateSurface(PDD_CREATESURFACEDATA lpCreateSurface)
{
    PPDev ppdev=        (PPDev)lpCreateSurface->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD               dwBitDepth;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    BOOL                bYUV = FALSE;
    BOOL                bResize = FALSE;
    DWORD               dwExtraBytes;
    PermediaSurfaceData*pPrivateData = NULL;

    DBG_DD((2, "DdCreateSurface called"));

    //
    // See if any of these surfaces are Z buffers. If they are, ensure that the
    // pitch is a valid LB width. The minimum partial product is 32 words or
    // 32 pixels on Permedia 2
    //
    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:
    //
    ASSERTDD(lpCreateSurface->dwSCnt == 1,
             "DdCreateSurface: Unexpected dwSCnt value not equal to one");

    lpSurfaceLocal = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal = lpSurfaceLocal->lpGbl;    
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    //
    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.
    //
    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    //
    // If the surface has already been allocated, don't reallocate it, just
    // reset it. This will happen if the surface is the primary surface.
    //

    if ( lpSurfaceGlobal->dwReserved1 != 0 )
    {
        pPrivateData = (PermediaSurfaceData*)lpSurfaceGlobal->dwReserved1;
        if ( CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData) )
        {
            DBG_DD((0, "  Already allocated Private Surface data 0x%x",
                     pPrivateData));
            memset(pPrivateData, 0, sizeof(PermediaSurfaceData));
        }
        else
        {
            pPrivateData = NULL;
        }
    }

    //
    // If the data isn't valid allocate it.
    //
    if ( pPrivateData == NULL )
    {
        pPrivateData = (PermediaSurfaceData *)
            ENGALLOCMEM(FL_ZERO_MEMORY, 
                        sizeof(PermediaSurfaceData), 
                        ALLOC_TAG);

        if ( pPrivateData == NULL )
        {
            DBG_DD((0, "DDraw:DdCreateSurface: "
                        "Not enough memory for private surface data!"));
            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
            
            return DDHAL_DRIVER_HANDLED;
        }
    }

    //
    // Store the pointer to the new data
    //
    lpSurfaceGlobal->dwReserved1 = (UINT_PTR)pPrivateData;
    DBG_DD((3,"DDraw:DdCreateSurface privatedata=0x%x lpGbl=0x%x lpLcl=0x%x "
        "dwFlags=%08lx &dwReserved1=0x%x", pPrivateData, lpSurfaceGlobal,
        lpSurfaceLocal, lpSurfaceLocal->dwFlags, 
        &lpSurfaceGlobal->dwReserved1));
    //
    // Set the magic number
    //
    pPrivateData->MagicNo = SURF_MAGIC_NO;
    
    //
    // Store away the important information
    //

    SetupPrivateSurfaceData(ppdev, pPrivateData, lpSurfaceLocal);

    if ( pPrivateData->SurfaceFormat.PixelSize != __PERMEDIA_24BITPIXEL )
    {
        dwBitDepth = (8 << pPrivateData->SurfaceFormat.PixelSize);
    }
    else
    {
        dwBitDepth = 24;
    }

    //
    // If the surface is a Z Buffer, then we always need to check the
    // pitch/partial products, and we need to get the depth from the
    // dwZBufferBitDepth field.
    //
    bYUV = FALSE;
    bResize = FALSE;
    dwExtraBytes = 0;

    //
    // get correct bit depth for Z buffers
    //
    if ( (lpSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
       &&(lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_ZBUFFER) )
    {
        DBG_DD((5,"  Surface is Z Buffer - Adjusting"));
        dwBitDepth = lpSurfaceGlobal->ddpfSurface.dwZBufferBitDepth;
    }

    if ( lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC )
    {
        //
        // The surface is a YUV format surface or we fail 
        //

        switch ( lpSurfaceGlobal->ddpfSurface.dwFourCC )
        {
            case FOURCC_YUV422:
                DBG_DD((3,"  Surface is YUV422 - Adjusting"));
                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 16;
                dwBitDepth = 16;
                bYUV = TRUE;
                break;

            default:
                //
                // We should never get here, as CanCreateSurface will
                // validate the YUV format for us.
                //
                ASSERTDD(0, "Trying to create an invalid YUV surface!");
                break;
        }
    }

    //
    // If the surface is a p2 texture and it is using a LUT, then we need to
    // allocate extra local buffer memory for the LUT entries (only on p2).
    //
    if ( (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
       &&(pPrivateData->SurfaceFormat.Format == PERMEDIA_8BIT_PALETTEINDEX) )
    {
        DBG_DD((7,"  Texture is a P2 8Bit LUT"));
        bResize = TRUE;
        dwExtraBytes = (256 * sizeof(DWORD));
    }

    DBG_DD((5,"  Surface Pitch is: 0x%x",  lpSurfaceGlobal->lPitch));

    //
    // Width is in pixels/texels
    //
    LONG lPitch;
    lPitch = lpSurfaceGlobal->wWidth;

    DBG_DD((4,"  Source Surface is %d texels/depth values across",
               lpSurfaceGlobal->wWidth));

    // align before hand to a DWPORD boundary
    if (pPrivateData->SurfaceFormat.PixelSize == __PERMEDIA_4BITPIXEL)
    {
        lPitch = ((lPitch >> 1) + 31) & ~31;
    }
    else
    {
        lPitch = (lPitch + 31) & ~31;
    }

    ULONG ulPackedPP;
    vCalcPackedPP( lPitch, &lPitch, &ulPackedPP);

    DBG_DD((7,"  Surface is 0x%x bits deep", dwBitDepth));

    if ( pPrivateData->SurfaceFormat.PixelSize != __PERMEDIA_4BITPIXEL )
    {
        //
        // Convert back to BYTES
        //
        if ( dwBitDepth != 24 )
        {
            lPitch <<= ((int)dwBitDepth) >> 4;
        }
        else
        {
            lPitch *= 3;
        }
    }

    pPrivateData->dwFlags |= P2_PPVALID;

    DWORD dwExtraLines = 0;

    if ( !bYUV )
    {
        //
        // PM Textures must be at least 32 high
        //
        if ( lpSurfaceGlobal->wHeight < 32 )
        {
            dwExtraLines = 32 - lpSurfaceGlobal->wHeight;
        }
    }

    lpSurfaceGlobal->dwBlockSizeX = 
        lPitch * (DWORD)(lpSurfaceGlobal->wHeight + dwExtraLines);
    lpSurfaceGlobal->dwBlockSizeY = 1;
    lpSurfaceGlobal->lPitch = lPitch;

    //
    // Store the partial productes in the structure
    //
    pPrivateData->ulPackedPP = ulPackedPP;

    DBG_DD((4, "  New Width of surface in Bytes: %d", lPitch));

    //
    // This flag is set if the surface needs resizing. This is currently only
    // used for the P2 LUT based textures.
    //
    if ( bResize )
    {
        DWORD dwExtraScanlines = 0;
        LONG  lExtraRemaining = (LONG)dwExtraBytes;

        //
        // ExtraScanlines is the count x, which * pitch is what we need to get
        // enough memory to hold the LUT.  This algorithm will ensure that even
        // requests for sizes less than a pitch length will get allocated.
        //
        do
        {
            dwExtraScanlines++;
            lExtraRemaining -= (LONG)lpSurfaceGlobal->lPitch;
        } while ( lExtraRemaining > 0 );

        DBG_DD((4, "Calculated extra Pitch lines = %d", dwExtraScanlines));

        //
        // Stretch the surface a little more in multiples of pitch.
        //
        lpSurfaceGlobal->dwBlockSizeX +=dwExtraScanlines * 
                                        lpSurfaceGlobal->lPitch;
    }// if ( bResize )

    
    //
    // Modify surface descriptions as appropriate and let Direct
    // Draw perform the allocation if the surface was not the primary
    //
    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        lpSurfaceGlobal->fpVidMem = NULL;
    }
    else
    {
        lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
    }
    
    lpSurfaceDesc->lPitch   = lpSurfaceGlobal->lPitch;
    lpSurfaceDesc->dwFlags |= DDSD_PITCH;

    if (lpSurfaceLocal->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        if (lpSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
        {
            lPitch =
            lpSurfaceDesc->lPitch   = 
            lpSurfaceGlobal->lPitch =
                ((lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount*
                lpSurfaceGlobal->wWidth+31)/32)*4;  //make it DWORD aligned
        }

        lpSurfaceGlobal->dwUserMemSize = lPitch * 
                                        (DWORD)(lpSurfaceGlobal->wHeight);
        lpSurfaceGlobal->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
    }

    lpCreateSurface->ddRVal = DD_OK;

    return DDHAL_DRIVER_NOTHANDLED;

}// DdCreateSurface()

//-----------------------------------------------------------------------------
//
// DdDestroySurface
//
// Frees up the private memory allocated with this surface.  Note that
// we return DDHAL_DRIVER_NOTHANDLED indicating that we didn't actually
// free the surface, since the heap is managed by DDraw.
//
//-----------------------------------------------------------------------------
extern TextureCacheManager P2TextureManager;

DWORD CALLBACK 
DdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd )
{
    PermediaSurfaceData *pPrivateData= 
        (PermediaSurfaceData*)psdd->lpDDSurface->lpGbl->dwReserved1;

    
    DBG_DD((3,"DDraw:DdDestroySurface pPrivateData=0x%x "
        "lpGbl=0x%x lpLcl=0x%x dwFlags=%08lx &dwReserved1=0x%x",
        pPrivateData, psdd->lpDDSurface->lpGbl, psdd->lpDDSurface,
        psdd->lpDDSurface->dwFlags, &psdd->lpDDSurface->lpGbl->dwReserved1));

    if (CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData))
    {
        PPERMEDIA_D3DTEXTURE pTexture=NULL;
        if ((psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle) &&
            (HandleList[psdd->lpDDSurface->dwReserved1].dwSurfaceList) &&
            (psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle <
                PtrToUlong(HandleList[psdd->lpDDSurface->dwReserved1].
                    dwSurfaceList[0])))
            pTexture=HandleList[psdd->lpDDSurface->dwReserved1].dwSurfaceList
                [psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle];

        DBG_DD((3,"psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2=%08lx",
            psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2));
        
        if (psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & 
            DDSCAPS2_TEXTUREMANAGE)
        {
            DBG_D3D((3, "free fpVidMem=%08lx fpVidMem=%08lx",
                pPrivateData->fpVidMem,psdd->lpDDSurface->lpGbl->fpVidMem));
            if ((pPrivateData->fpVidMem) && pTexture)
            {
                ASSERTDD(CHECK_D3DSURFACE_VALIDITY(pTexture),
                    "Invalid pTexture in DdDestroySurface");
                TextureCacheManagerRemove(&P2TextureManager,pTexture);
            }
            if (DDRAWISURF_INVALID & psdd->lpDDSurface->dwFlags)
            {
                // indicate that driver takes care of the lost surface already
                psdd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }
        }
        if (pTexture)
        {
            ENGFREEMEM(pTexture);
            HandleList[psdd->lpDDSurface->dwReserved1].dwSurfaceList
                [psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle]=0;
        }
        pPrivateData->MagicNo = NULL;        
        ENGFREEMEM(pPrivateData);
        psdd->lpDDSurface->lpGbl->dwReserved1 = 0;    
    }
#if DBG
    else
    {
        if (pPrivateData) {
            ASSERTDD(0, "DDraw:DdDestroySurface:ERROR:"
                        "Private Surface data not valid??");
        }
        DBG_DD((0, "DDraw:DdDestroySurface:WARNING:"
                    "No Private data in destroyed surface"));
    }
#endif    
    return DDHAL_DRIVER_NOTHANDLED;

} // DdDestroySurface 

//-----------------------------------------------------------------------------
//
// SetupPrivateSurfaceData
//
// Function to get info about DDRAW surface and store it away in the
// private structure.  Useful for partial products, pixel depths,
// texture setup (patching/formats), etc. 
//
//-----------------------------------------------------------------------------

VOID
SetupPrivateSurfaceData( PPDev ppdev, 
                         PermediaSurfaceData* pPrivateData, 
                         LPDDRAWI_DDRAWSURFACE_LCL pSurface)
{
    DDPIXELFORMAT* pPixFormat = NULL;
    
    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData), 
        "SetupPrivateSurfaceData: Private Surface data pointer invalid!!");
    ASSERTDD(pSurface, "SetupPrivateSurfaceData: Surface pointer invalid");
    
    DBG_DD((5,"DDraw:SetupPrivateSurfaceData"));
    DBG_DD((6,"  Width: %d, Height: %d", 
        pSurface->lpGbl->wWidth, pSurface->lpGbl->wHeight));

    // Surface is the primary surface
    if (pSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        DBG_DD((6,"  Surface is Primary"));
        pPrivateData->dwFlags |= P2_SURFACE_PRIMARY;
        pPixFormat = &ppdev->ddpfDisplay;
    } // Either the surface is a texture or it has a valid pixel format.
    else
    {
        DUMPSURFACE(6, pSurface, NULL);
        pPixFormat = &pSurface->lpGbl->ddpfSurface;
    }
    
    // At surface creation the surface has not been patched.
    pPrivateData->dwFlags &= ~P2_ISPATCHED;
    
    if (pSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        // If the user has chosen the normal mechanism, then patch the surface.
        if (pSurface->ddsCaps.dwCaps & DDSCAPS_ALLOCONLOAD) 
        {
            DBG_DD((6,"  Remembering to patch this surface"));
            pPrivateData->dwFlags |= P2_CANPATCH;
        }
        else
        {
            pPrivateData->dwFlags &= ~P2_CANPATCH;
        }
    }
     
    // Initially assume no Alpha
    pPrivateData->SurfaceFormat.bAlpha = FALSE;

    if (pPixFormat != NULL)
    {
        if (pPixFormat->dwFlags & DDPF_FOURCC)
        {
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            switch( pPixFormat->dwFourCC )
            {
            case FOURCC_YUV422:
                DBG_DD((6,"  Surface is 4:2:2 YUV"));
                pPrivateData->SurfaceFormat.Format = PERMEDIA_YUV422;
                pPrivateData->SurfaceFormat.FormatExtension = 
                    PERMEDIA_YUV422_EXTENSION;
                pPrivateData->SurfaceFormat.PixelSize = __PERMEDIA_16BITPIXEL;
                pPrivateData->SurfaceFormat.FBReadPixel= __PERMEDIA_16BITPIXEL;
                pPrivateData->SurfaceFormat.PixelMask = 1;
                pPrivateData->SurfaceFormat.PixelShift= 1;
                pPrivateData->SurfaceFormat.ColorComponents = 2;
                pPrivateData->SurfaceFormat.logPixelSize = log2(16);
                pPrivateData->SurfaceFormat.ColorOrder = 0;
                break;
            }
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED4)
        {
            DBG_DD((6,"  Surface is 4-Bit Palette"));
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_PALETTE;
            pPrivateData->SurfaceFormat.Format = PERMEDIA_4BIT_PALETTEINDEX;
            pPrivateData->SurfaceFormat.FormatExtension = 0;
            pPrivateData->SurfaceFormat.PixelSize = __PERMEDIA_4BITPIXEL;
            pPrivateData->SurfaceFormat.FBReadPixel= __PERMEDIA_8BITPIXEL;
            pPrivateData->SurfaceFormat.PixelMask = 7;
            pPrivateData->SurfaceFormat.PixelShift= 0;
            pPrivateData->SurfaceFormat.ColorComponents = 3;
            pPrivateData->SurfaceFormat.logPixelSize = log2(4);
            pPrivateData->SurfaceFormat.ColorOrder = 0;
            pPrivateData->dwFlags &= ~P2_CANPATCH;
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED8)
        {
            DBG_DD((6,"  Surface is 8-Bit Palette"));
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            pPrivateData->dwFlags |= P2_SURFACE_FORMAT_PALETTE;
            pPrivateData->SurfaceFormat.Format = PERMEDIA_8BIT_PALETTEINDEX;
            pPrivateData->SurfaceFormat.FormatExtension = 0;
            pPrivateData->SurfaceFormat.PixelSize = __PERMEDIA_8BITPIXEL;
            pPrivateData->SurfaceFormat.FBReadPixel= __PERMEDIA_8BITPIXEL;
            pPrivateData->SurfaceFormat.PixelMask = 3;
            pPrivateData->SurfaceFormat.PixelShift= 0;
            pPrivateData->SurfaceFormat.ColorComponents = 3;
            pPrivateData->SurfaceFormat.Texture16BitMode = 1;
            pPrivateData->SurfaceFormat.logPixelSize = log2(8);
            pPrivateData->SurfaceFormat.ColorOrder = 0;
        }
        else
        {
            if (SetRGBAlphaSurfaceFormat( pPixFormat, 
                                         &pPrivateData->SurfaceFormat))
            {
                pPrivateData->dwFlags |= P2_SURFACE_FORMAT_VALID;
            } else
            {
                pPrivateData->dwFlags &= ~P2_SURFACE_FORMAT_VALID;
            }
        }
    }
    else
    {
        ASSERTDD(0, "SetupPrivateSurfaceData:"
                    "Can't get valid surface format pointer");
    }
    

} // SetupPrivateSurfaceData 

//-----------------------------------------------------------------------------
//
// list all valid pixel formats for Permedia 2
// The P2 supports BGR for all formats, so these formats are not
// explicitely listed here, also formats having no alpha channel are permitted
//  
//-----------------------------------------------------------------------------

DDPIXELFORMAT Permedia2PixelFormats[] = {
    // 32 bit RGBa
    {PERMEDIA_8888_RGB,0,0,32,0x000000ff,0x0000ff00,0x00ff0000,0xff000000},     
    // 16 bit 5:6:5, RGB
    {PERMEDIA_565_RGB ,0,0,16,0x0000001f,0x000007e0,0x0000f800,0x00000000},     
    // 16 bit 4:4:4:4RGBa
    {PERMEDIA_444_RGB ,0,0,16,0x0000000f,0x000000f0,0x00000f00,0x0000f000},     
    // 15 bit 5:5:5, RGBa
    {PERMEDIA_5551_RGB,0,0,16,0x0000001f,0x000003e0,0x00007c00,0x00008000},     
    //  8 bit 3:3:2  RGB
    // 332 format is not symmetric. Its listed twice for BGR/RGB case
    {PERMEDIA_332_RGB ,1,0, 8,0x00000007,0x00000038,0x000000c0,0x00000000},     
    {PERMEDIA_332_RGB ,0,0, 8,0x00000003,0x0000001c,0x000000e0,0x00000000},     
//@@BEGIN_DDKSPLIT
//  there are no testcases against the 2321 format, so disable it for now
//  8 bit 2:3:2:1RGBa
//  {PERMEDIA_2321_RGB,0,0, 8,0x00000003,0x0000001c,0x00000060,0x00000080},     
//@@END_DDKSPLIT
    // 24 bit RGB
    {PERMEDIA_888_RGB ,0,0,24,0x000000ff,0x0000ff00,0x00ff0000,0x00000000}      
};
#define N_PERMEDIA2PIXELFORMATS \
    (sizeof(Permedia2PixelFormats)/sizeof(DDPIXELFORMAT))

BOOL
ValidRGBAlphaSurfaceformat( DDPIXELFORMAT *pPixFormat, INT *pIndex)
{
    INT i;

    if (pPixFormat==NULL) 
        return FALSE;

    if (pPixFormat->dwSize < sizeof(DDPIXELFORMAT))
        return FALSE;

    // The Z-Buffer is a special case. Its basically a 16 bit surface
    if (pPixFormat->dwFlags & DDPF_ZBUFFER)
    {
        if (pIndex!=0) *pIndex=1;
        return TRUE;
    }

    if ((pPixFormat->dwFlags & DDPF_RGB)==0)
        return FALSE;

    for ( i=0; i<N_PERMEDIA2PIXELFORMATS; i++)
    {
        // check if the RGB and alpha masks fit.
        // on Permedia we can swap R and B, so allow also BGR formats
        if ((((pPixFormat->dwRBitMask == 
                    Permedia2PixelFormats[i].dwRBitMask) &&
              (pPixFormat->dwBBitMask == 
                    Permedia2PixelFormats[i].dwBBitMask)) ||
             ((pPixFormat->dwRBitMask == 
                    Permedia2PixelFormats[i].dwBBitMask) &&
              (pPixFormat->dwBBitMask == 
                    Permedia2PixelFormats[i].dwRBitMask))) &&
            (pPixFormat->dwGBitMask == 
                    Permedia2PixelFormats[i].dwGBitMask) &&
            ((pPixFormat->dwRGBAlphaBitMask == 
                    Permedia2PixelFormats[i].dwRGBAlphaBitMask) ||
             (pPixFormat->dwRGBAlphaBitMask == 0) ||
             ((pPixFormat->dwFlags&DDPF_ALPHAPIXELS)==0)) &&
              (pPixFormat->dwRGBBitCount==
                    Permedia2PixelFormats[i].dwRGBBitCount)
            )
        {
            if (pIndex!=NULL)
            {
                *pIndex = i;
            }
            return TRUE;
        }
    }
     
    // no pixel format matched...

    return FALSE;

} // ValidRGBAlphaSurfaceformat


//-----------------------------------------------------------------------------
//
//  SetRGBAlphaSurfaceFormat
//
//  Store away pixel format information of a surface in the Permedia native 
//  format
//
//-----------------------------------------------------------------------------

BOOL
SetRGBAlphaSurfaceFormat(DDPIXELFORMAT *pPixFormat, 
                         PERMEDIA_SURFACE *pSurfaceFormat)
{
    INT iFormatIndex;

    if (!ValidRGBAlphaSurfaceformat( pPixFormat, &iFormatIndex))
    {
        DBG_DD((1,"couldn't set SurfaceFormat"));
        return FALSE;        
    }

    DBG_DD((6,"  Surface RGB Data Valid"));

    pSurfaceFormat->RedMask = pPixFormat->dwRBitMask;
    pSurfaceFormat->GreenMask = pPixFormat->dwGBitMask;
    pSurfaceFormat->BlueMask = pPixFormat->dwBBitMask;
    pSurfaceFormat->bPreMult = FALSE;

    if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
    {
        pSurfaceFormat->AlphaMask = pPixFormat->dwRGBAlphaBitMask;
    
        if (pSurfaceFormat->AlphaMask!=0)
        {
            pSurfaceFormat->bAlpha = TRUE;
        } 

        if (pPixFormat->dwFlags & DDPF_ALPHAPREMULT)
        {
            pSurfaceFormat->bPreMult = TRUE;
        }
    }

    pSurfaceFormat->ColorOrder = Permedia2PixelFormats[iFormatIndex].dwFlags;

    // check for the BGR case
    if (pPixFormat->dwRBitMask == 
        Permedia2PixelFormats[iFormatIndex].dwRBitMask)
        pSurfaceFormat->ColorOrder = !pSurfaceFormat->ColorOrder;
            
    switch (pPixFormat->dwRGBBitCount)
    {
    case 24:
        DBG_DD((6,"  Surface is 8:8:8 Packed 24 Bit"));
        pSurfaceFormat->Format = PERMEDIA_888_RGB;
        pSurfaceFormat->FormatExtension = PERMEDIA_888_RGB_EXTENSION;
        pSurfaceFormat->PixelSize = __PERMEDIA_24BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_24BITPIXEL;
        pSurfaceFormat->PixelMask = 0;  // not valid for 24 bit
        pSurfaceFormat->PixelShift= 0;
        pSurfaceFormat->logPixelSize = 0;
        pSurfaceFormat->ColorComponents = 3;
        break;

    case 32:
        DBG_DD((6,"  Surface is 8:8:8:8"));
        pSurfaceFormat->Format = PERMEDIA_8888_RGB;
        pSurfaceFormat->FormatExtension = PERMEDIA_8888_RGB_EXTENSION;
        pSurfaceFormat->PixelSize = __PERMEDIA_32BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_32BITPIXEL;
        pSurfaceFormat->PixelMask = 0;
        pSurfaceFormat->PixelShift= 2;
        pSurfaceFormat->logPixelSize = log2(32);
        pSurfaceFormat->ColorComponents = 3;
        break;

    case 16:
        pSurfaceFormat->logPixelSize = log2(16);
        pSurfaceFormat->PixelSize = __PERMEDIA_16BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_16BITPIXEL;
        pSurfaceFormat->PixelMask = 1;  // not valid for 24 bit
        pSurfaceFormat->PixelShift= 1;
        switch (Permedia2PixelFormats[iFormatIndex].dwSize)
        {
        case PERMEDIA_565_RGB:
            pSurfaceFormat->Texture16BitMode = 0;
            pSurfaceFormat->Format = PERMEDIA_565_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_565_RGB_EXTENSION;
            pSurfaceFormat->ColorComponents = 2;
            DBG_DD((6,"  Surface is 5:6:5"));
            break;

        case PERMEDIA_444_RGB:
            pSurfaceFormat->Format = PERMEDIA_444_RGB;
            pSurfaceFormat->FormatExtension = 0;
            pSurfaceFormat->ColorComponents = 3;
            if (pPixFormat->dwRGBAlphaBitMask != 0)
            {
                DBG_DD((6,"  Surface is 4:4:4:4"));
            } else
            {
                DBG_DD((6,"  Surface is 4:4:4:0"));
            }
            break;

        case PERMEDIA_5551_RGB:
            pSurfaceFormat->Texture16BitMode = 1;
            pSurfaceFormat->Format = PERMEDIA_5551_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_5551_RGB_EXTENSION;
            if (pPixFormat->dwRGBAlphaBitMask != 0)
            {
                DBG_DD((6,"  Surface is 5:5:5:1"));
                pSurfaceFormat->ColorComponents = 3;
            }
            else
            {
                DBG_DD((6,"  Surface is 5:5:5"));
                pSurfaceFormat->ColorComponents = 2;
            }
            break;
        default: 
            ASSERTDD( FALSE, "  16 bit Surface has unknown format");
            break;
        }
        break;

    case 8:
        pSurfaceFormat->PixelSize = __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->PixelMask = 3;
        pSurfaceFormat->PixelShift= 0;
        pSurfaceFormat->logPixelSize = log2(8);
        if (Permedia2PixelFormats[iFormatIndex].dwSize==PERMEDIA_2321_RGB)
        {
            pSurfaceFormat->Format = PERMEDIA_2321_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_2321_RGB_EXTENSION;
            pSurfaceFormat->ColorComponents = 3;
        }
        else if (Permedia2PixelFormats[iFormatIndex].dwSize==PERMEDIA_332_RGB)
        {
            pSurfaceFormat->Format = PERMEDIA_332_RGB;
            pSurfaceFormat->FormatExtension = PERMEDIA_332_RGB_EXTENSION;
            pSurfaceFormat->ColorComponents = 2;
        } else
        {
            ASSERTDD( FALSE, "  Surface (8bit) has unknown format");
        }
        break;

    case 0:
        DBG_DD((6,"  Surface is palleted"));
        pSurfaceFormat->Format = PERMEDIA_8BIT_PALETTEINDEX;
        pSurfaceFormat->FormatExtension = PERMEDIA_8BIT_PALETTEINDEX_EXTENSION;
        pSurfaceFormat->PixelSize = __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->FBReadPixel= __PERMEDIA_8BITPIXEL;
        pSurfaceFormat->PixelMask = 3;  // not valid for 24 bit
        pSurfaceFormat->PixelShift= 0;
        pSurfaceFormat->logPixelSize = log2(8);
        pSurfaceFormat->ColorComponents = 0;
        break;

    default:
        ASSERTDD( FALSE, "  Surface has unknown pixelformat");
        return FALSE;
    }

    return TRUE;

}  // SetRGBAlphaSurfaceFormat
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\debug.c ===
/******************************Module*Header***********************************\
*
*                           ****************
*                           *  SAMPLE CODE *
*                           ****************
*
* Module Name: debug.cpp
*
* Content:     Miscellaneous Driver Debug Routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "log.h"

LONG DebugLevel = 0;            // Set to '100' to debug initialization code
                                // (the default is '0')
DWORD DebugPrintFilter = 0;
DWORD DebugFilter = 0;


#define ALLOC_TAG ALLOC_TAG_ED2P
//------------------------------------------------------------------------------
//
//  VOID DebugPrint
//
//  Variable-argument level-sensitive debug print routine.
//
//  If the specified debug level for the print statement is lower or equal
//  to the current debug level, the message will be printed.
//
//  Parameters
//   DebugPrintLevel----Specifies at which debugging level the string should
//                      be printed
//   DebugMessage-------Variable argument ascii c string
//
//------------------------------------------------------------------------------

VOID
DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);

    if ( ((DebugPrintFilter & DebugFilter) && 
          (DebugPrintLevel <= DebugLevel ))    ||
         DebugPrintLevel <= 0                   )     
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

} // DebugPrint()


#if DBG

//------------------------------------------------------------------------------
//
//  VOID vDumpSurfobj
//
//  Dumps using DSPDBG usefull information about the given surface
//
//  Parameters
//   pso------------surface to dump
//
//------------------------------------------------------------------------------

void
vDumpSurfobj(SURFOBJ*   pso)
{
    ULONG   * bits;
    PPDev     ppdev;

    if(pso != NULL)
    {
        ULONG   width;
        ULONG   height;
        ULONG   stride;

        ppdev = (PPDev) pso->dhpdev;

        if(pso->dhsurf == NULL)
        {
            bits = (ULONG *) pso->pvScan0;
            width = pso->sizlBitmap.cx;
            height = pso->sizlBitmap.cy;
            stride = pso->lDelta;

            DISPDBG((0, "GDI managed surface %lx", pso));
        }
        else
        {
            Surf * surf = (Surf *) pso->dhsurf;
        
            if(surf->flags & SF_SM)
            {
                bits = (ULONG *) surf->pvScan0;
                DISPDBG((0, "device managed SM surface %lx", pso));
            }
            else
            {
                bits = (ULONG *) (ppdev->pjScreen + surf->ulByteOffset);
                DISPDBG((0, "device managed VM surface %lx", pso));
            }

            width = surf->cx;
            height = surf->cy;
            stride = surf->lDelta;
        }

        DISPDBG((0, "width %d height %d", width, height ));
        DISPDBG((0, "bits 0x%lx bits[0] 0x%lx stride %ld", bits, bits[0], stride));
    }
}

//------------------------------------------------------------------------------
//
//  VOID vDumpRect
//
//  Dumps the rectangle description using DISPDBG
//
//  Parameters
//   prcl-----------rectangle to dump
//
//------------------------------------------------------------------------------

void
vDumpRect(RECTL * prcl)
{
    if(prcl != NULL)
        DISPDBG((0, "left %d top %d width %d height %d",
                        prcl->left, prcl->top,
                        prcl->right - prcl->left,
                        prcl->bottom - prcl->top));
}

//------------------------------------------------------------------------------
//
//  VOID vDumpSurfobj
//
//  Dumps the point description using DISPDBG
//
//  Parameters
//   point----------point to dump
//
//------------------------------------------------------------------------------

void
vDumpPoint(POINTL * point)
{
    if(point != NULL)
        DISPDBG((0, "left %d top %d", point->x, point->y));
}


//------------------------------------------------------------------------------
//
// DEBUGGING INITIALIZATION CODE
//
// When you're bringing up your display for the first time, you can
// recompile with 'DebugLevel' set to 100.  That will cause absolutely
// all DISPDBG messages to be displayed on the kernel debugger (this
// is known as the "PrintF Approach to Debugging" and is about the only
// viable method for debugging driver initialization code).
//
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// THUNK_LAYER
//
// By Setting THUNK_LAYER equal to 1 you are adding a wrapper call on top of
// all DDI rendering functions.  In this thunk layer of wrapper calls
// several usefull debugging features are enabled.
//
// Surface checks--which can help catch errant rendering routines
// Event logging---which can record rendering evernts to a log file
//
//------------------------------------------------------------------------------

#if THUNK_LAYER

//------------------------------------------------------------------------------
//
// BOOL bSurfaceChecks
//
// By dynamically setting bSurfaceChecks  (via debugger) you can turn
// surface checking on and off.  Surface checking is usefull for catching 
// errant rendering operations overwritting other surfaces other then the
// destination surface.
//
//------------------------------------------------------------------------------

BOOL    bSurfaceChecks = 0;

//------------------------------------------------------------------------------
//
//  ULONG ulCalcSurfaceChecksum
//
//  Calculates a checksum for the given surface
//
//  Parameters
//   psurf----Surf to be used for checksum
//
//  Retuns checksum for given surface as a ULONG
//
//------------------------------------------------------------------------------

ULONG
ulCalcSurfaceChecksum(Surf* psurf)
{
    ULONG     ulChecksum = 0;

    if( psurf->dt == DT_VM )
    {
        //
        // Get the real memory address of this psurf
        //
        ULONG*  ulp = (ULONG*)(psurf->ppdev->pjScreen + psurf->ulByteOffset);

        //
        // Get total bytes allocated in this psurf. Here >> 2 is to make
        // 4 bytes as a unit so that we can use it to do checksum
        //
        ULONG   ulCount = (psurf->lDelta * psurf->cy) >> 2;

        //
        // Sum up the contents of all the bytes we allocated
        //
        while( ulCount-- )
        {
            ulChecksum += *ulp++;
        }
    }
    
    return ulChecksum;
}// vCalcSurfaceChecksum()

//------------------------------------------------------------------------------
//
//  VOID vCalcSurfaceChecksums
//
//  Calculates and stores all surface checksums except for the given destination
//  surface.
//
//  Parameters
//   psoDst---destination SURFOBJ
//   psoSrc---source SURFOBJ
//
//------------------------------------------------------------------------------

VOID
vCalcSurfaceChecksums(SURFOBJ * psoDst, SURFOBJ * psoSrc)
{
    PPDev   ppdev = NULL;
    Surf * pdSrcSurf = NULL;
    Surf * pdDstSurf = NULL;
    
    ASSERTDD(psoDst != NULL, "unexpected psoDst == NULL");

    pdDstSurf = (Surf *) psoDst->dhsurf;

    if(psoSrc != NULL)
        pdSrcSurf = (Surf *) psoSrc->dhsurf;

    if(pdDstSurf != NULL)
        ppdev = (PPDev) psoDst->dhpdev;
    else if(pdSrcSurf != NULL)
        ppdev = (PPDev) psoSrc->dhpdev;

    if(ppdev != NULL)
    {
        Surf * psurf = ppdev->psurfListHead;

        while(psurf != ppdev->psurfListTail)
        {
            if(psurf != pdDstSurf)
                psurf->ulChecksum = vCalcSurfaceChecksum(psurf);

            psurf = psurf->psurfNext;

        }
        
    }
}

//------------------------------------------------------------------------------
//
//  VOID vCheckSurfaceChecksums
//
//  Calculates and compares all surface checksums except for the given
//  destination surface.
//
//  Parameters
//   psoDst---destination SURFOBJ
//   psoSrc---source SURFOBJ
//
//------------------------------------------------------------------------------

VOID
vCheckSurfaceChecksums(SURFOBJ * psoDst, SURFOBJ * psoSrc)
{
    PPDev   ppdev = NULL;
    Surf * pdSrcSurf = NULL;
    Surf * pdDstSurf = NULL;
    
    ASSERTDD(psoDst != NULL, "unexpected psoDst == NULL");

    pdDstSurf = (Surf *) psoDst->dhsurf;

    if(psoSrc != NULL)
        pdSrcSurf = (Surf *) psoSrc->dhsurf;

    if(pdDstSurf != NULL)
        ppdev = (PPDev) psoDst->dhpdev;
    else if(pdSrcSurf != NULL)
        ppdev = (PPDev) psoSrc->dhpdev;

    if(ppdev != NULL)
    {
        Surf * psurf = ppdev->psurfListHead;

        while(psurf != ppdev->psurfListTail)
        {
            if(psurf != pdDstSurf)
            {
                ASSERTDD(psurf->ulChecksum == vCalcSurfaceChecksum(psurf),
                    "unexpected checksum mismatch");
            }

            psurf = psurf->psurfNext;

        }
        
    }
}


//------------------------------------------------------------------------------
// ULONG ulCallDepth
//
// Used for keeping track of how many times the DDI layer has been entered.
// Some punted calls to the GDI engine will cause callbacks into DDI.  This
// call depth information is used when event logging.
//
//------------------------------------------------------------------------------

ULONG   ulCallDepth = 0;

//------------------------------------------------------------------------------
//
// BOOL xDrvBitBlt
//
// Thunk layer wrapper for DrvBitBlt.
//
//------------------------------------------------------------------------------

BOOL
xDrvBitBlt(SURFOBJ*  psoDst,
          SURFOBJ*  psoSrc,
          SURFOBJ*  psoMsk,
          CLIPOBJ*  pco,
          XLATEOBJ* pxlo,
          RECTL*    prclDst,
          POINTL*   pptlSrc,
          POINTL*   pptlMsk,
          BRUSHOBJ* pbo,
          POINTL*   pptlBrush,
          ROP4      rop4)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;


    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                         pptlSrc, pptlMsk,pbo, pptlBrush, rop4);

    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc, pptlMsk,
                pbo, pptlBrush, rop4, llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);

    ulCallDepth--;

    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvCopyBits
//
// Thunk layer wrapper for DrvCopyBits.
//
//------------------------------------------------------------------------------

BOOL
xDrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);
    
    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);

    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc, 
                    llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);
    
    ulCallDepth--;
    
    return bResult;

}

//------------------------------------------------------------------------------
//
// BOOL xDrvTransparentBlt
//
// Thunk layer wrapper for DrvTransparentBlt.
//
//------------------------------------------------------------------------------

BOOL 
xDrvTransparentBlt(
   SURFOBJ *    psoDst,
   SURFOBJ *    psoSrc,
   CLIPOBJ *    pco,
   XLATEOBJ *   pxlo,
   RECTL *      prclDst,
   RECTL *      prclSrc,
   ULONG        iTransColor,
   ULONG        ulReserved)
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);
    
    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvTransparentBlt(psoDst,
                             psoSrc,
                             pco,
                             pxlo,
                             prclDst,
                             prclSrc,
                             iTransColor,
                             ulReserved);

    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, 
                       iTransColor,
                       llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);
    
    ulCallDepth--;
    
    return bResult;

}

//------------------------------------------------------------------------------
//
// BOOL xDrvAlphaBlend
//
// Thunk layer wrapper for DrvAlphaBlend.
//
//------------------------------------------------------------------------------

BOOL
xDrvAlphaBlend(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   RECTL    *prclSrc,
   BLENDOBJ *pBlendObj)
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, psoSrc);
    
    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvAlphaBlend(
        psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, pBlendObj);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogAlphaBlend(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, pBlendObj,
                    llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, psoSrc);
    
    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvGradientFill
//
// Thunk layer wrapper for DrvGradientFill.
//
//------------------------------------------------------------------------------

BOOL
xDrvGradientFill(
   SURFOBJ      *psoDst,
   CLIPOBJ      *pco,
   XLATEOBJ     *pxlo,
   TRIVERTEX    *pVertex,
   ULONG        nVertex,
   PVOID        pMesh,
   ULONG        nMesh,
   RECTL        *prclExtents,
   POINTL       *pptlDitherOrg,
   ULONG        ulMode
   )
{
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(psoDst, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvGradientFill(
            psoDst, pco, pxlo, pVertex, nVertex, 
            pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogGradientFill(psoDst, pco, pxlo, pVertex, nVertex, pMesh, nMesh,
                     prclExtents, pptlDitherOrg, ulMode,
                     llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(psoDst, NULL);
    
    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvTextOut
//
// Thunk layer wrapper for DrvTextOut.
//
//------------------------------------------------------------------------------

BOOL
xDrvTextOut(SURFOBJ*     pso,
           STROBJ*      pstro,
           FONTOBJ*     pfo,
           CLIPOBJ*     pco,
           RECTL*       prclExtra,
           RECTL*       prclOpaque,
           BRUSHOBJ*    pboFore,
           BRUSHOBJ*    pboOpaque,
           POINTL*      pptlBrush, 
           MIX          mix)
{    
    BOOL    bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque,
                           pboFore, pboOpaque, pptlBrush, mix);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque,
                 pboFore, pboOpaque, pptlBrush, mix,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvLineTo
//
// Thunk layer wrapper for DrvLineTo.
//
//------------------------------------------------------------------------------

BOOL
xDrvLineTo(
    SURFOBJ*  pso,
    CLIPOBJ*  pco,
    BRUSHOBJ* pbo,
    LONG      x1,
    LONG      y1,
    LONG      x2,
    LONG      y2,
    RECTL*    prclBounds,
    MIX       mix)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvFillPath
//
// Thunk layer wrapper for DrvFillPath.
//
//------------------------------------------------------------------------------

BOOL
xDrvFillPath(
    SURFOBJ*    pso,
    PATHOBJ*    ppo,
    CLIPOBJ*    pco,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    MIX         mix,
    FLONG       flOptions)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

//------------------------------------------------------------------------------
//
// BOOL xDrvStrokePath
//
// Thunk layer wrapper for DrvStrokePath.
//
//------------------------------------------------------------------------------

BOOL
xDrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    BOOL        bResult;
    LONGLONG    llStartTicks;
    LONGLONG    llElapsedTicks;

    ulCallDepth++;

    if(bSurfaceChecks)
        vCalcSurfaceChecksums(pso, NULL);

    EngQueryPerformanceCounter(&llStartTicks);
    
    bResult = DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
        
    EngQueryPerformanceCounter(&llElapsedTicks);
    llElapsedTicks -= llStartTicks;

    vLogStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix,
                 llElapsedTicks, ulCallDepth);

    if(bSurfaceChecks)
        vCheckSurfaceChecksums(pso, NULL);

    ulCallDepth--;
    
    return bResult;
}

#endif // THUNK LAYER

//-----------------------------------------------------------------------------
//  
//..Add some functions to aid tracking down memory leaks.
//  Its sole purpose is tracking down leaks, so its not optimized for speed.
//  WARNING: If two instances of same driver are active at the same time,
//  it will track the memory allocations of both.
//
//  To keep it simple, we just allocate an array here where we store memory allocations.
//  There is some simple algorithm to keep track of recently freed entries. Anyway,
//  to free a piece of memory we have to search through the whole table. So better
//  use for debugging memory holes.
//
//-----------------------------------------------------------------------------

#if DBG && TRACKMEMALLOC

typedef struct tagMemTrackInfo {
    PVOID    pMemory;
    LONG     lSize;
    PCHAR    pModule;
    LONG     lLineNo;
    //LONGINT                   save time of allocation?
    BOOL     bStopWhenFreed;
    BOOL     bTemp;
} MemTrackInfo, *PMemTrackInfo;

#define NEWCHUNKSIZE 256

static PMemTrackInfo pTrackPool=NULL;
static LONG lTrackPoolTotalSize=0;
static LONG lTrackPoolSize=0;
static LONG lInstances=0;
static LONG lTotalAllocatedMemory=0;
static LONG lNextFreeEntry=0;

//  glMemTrackerVerboseMode--- set flags according to debug output
//                          0   no output
//                          1   print summary for all allocations in same module/LineNo
//                          2   print all entries

LONG glMemTrackerVerboseMode=1;

//-----------------------------------------------------------------------------
//
//  MemTrackerAddInstance
//
//  Just count number of active instances of the driver
//
//-----------------------------------------------------------------------------

VOID MemTrackerAddInstance()
{
    lInstances++;
}

//-----------------------------------------------------------------------------
//
//  MemTrackerRemInstance
//
//  Just count number of active instances of the driver. Free Tracker memory
//  if last instance is destroyed!!!
//
//-----------------------------------------------------------------------------

VOID MemTrackerRemInstance()
{
    lInstances--;
    if (lInstances==0)
    {
        EngFreeMem(pTrackPool);
        pTrackPool=NULL;
        lTrackPoolTotalSize=0;
        lTrackPoolSize=0;
        lTotalAllocatedMemory=0;
        lNextFreeEntry=0;
    }
}

//-----------------------------------------------------------------------------
//
//  MemTrackerAllocateMem
//
//  Add memory top be tracked to table.
//
//  p--------address of memory chunk
//  lSize----Size of memory chunk
//  pModulo--module name
//  lLineNo--module line number
//  bStopWhenFreed--set a breakpoint if this memory is freed (not yet used)
//
//-----------------------------------------------------------------------------

PVOID MemTrackerAllocateMem(PVOID p, 
                           LONG lSize, 
                           PCHAR pModule, 
                           LONG lLineNo, 
                           BOOL bStopWhenFreed)
{
    // check for first time allocation
    if (p==NULL) return p;

    if (pTrackPool==NULL)
    {
        pTrackPool=(PMemTrackInfo)EngAllocMem( FL_ZERO_MEMORY, 
                                               NEWCHUNKSIZE*sizeof(MemTrackInfo), 
                                               ALLOC_TAG);
        if (pTrackPool==NULL) return p;
        lTrackPoolTotalSize=NEWCHUNKSIZE;
        lTrackPoolSize=2;
        lTotalAllocatedMemory=0;
        lNextFreeEntry=1;

        pTrackPool[0].pMemory= pTrackPool;
        pTrackPool[0].lSize=   NEWCHUNKSIZE*sizeof(MemTrackInfo);
        pTrackPool[0].pModule= __FILE__;
        pTrackPool[0].lLineNo= __LINE__;
        pTrackPool[0].bStopWhenFreed=FALSE;
    }

    if (lTrackPoolSize>=lTrackPoolTotalSize)
    {   // reallocation necessary
        LONG lNewTrackPoolTotalSize=lTrackPoolTotalSize+NEWCHUNKSIZE;
        LONG lNewSize;
        PMemTrackInfo pNewTrackPool=(PMemTrackInfo)
            EngAllocMem( FL_ZERO_MEMORY, lNewSize=lNewTrackPoolTotalSize*sizeof(MemTrackInfo), ALLOC_TAG);
        if (pNewTrackPool==NULL) return p;
        memcpy( pNewTrackPool, pTrackPool, lTrackPoolTotalSize*sizeof(MemTrackInfo));
        EngFreeMem( pTrackPool);
        pTrackPool=pNewTrackPool;
        lTrackPoolTotalSize=lNewTrackPoolTotalSize;

        pTrackPool[0].pMemory= pTrackPool;
        pTrackPool[0].lSize=   lNewSize;
        pTrackPool[0].pModule= __FILE__;
        pTrackPool[0].lLineNo= __LINE__;
        pTrackPool[0].bStopWhenFreed=FALSE;
    }

    LONG lThisEntry=lNextFreeEntry;

    lNextFreeEntry=pTrackPool[lThisEntry].lSize;

    pTrackPool[lThisEntry].pMemory= p;
    pTrackPool[lThisEntry].lSize=   lSize;
    pTrackPool[lThisEntry].pModule= pModule;
    pTrackPool[lThisEntry].lLineNo= lLineNo;
    pTrackPool[lThisEntry].bStopWhenFreed=FALSE;

    if (lNextFreeEntry==0)
    {
        lNextFreeEntry=lTrackPoolSize;
        lTrackPoolSize++;
    }

    lTotalAllocatedMemory += lSize;

    return p;
}

//-----------------------------------------------------------------------------
//
//  MemTrackerFreeMem
//
//  remove a memory chunk from table, because it is freed  
//
//  p-----address of memory to be removed from table
//  
//-----------------------------------------------------------------------------

VOID MemTrackerFreeMem( VOID *p)
{

    for (INT i=1; i<lTrackPoolSize; i++)
    {
        if (pTrackPool[i].pMemory==p)
        {
            lTotalAllocatedMemory -= pTrackPool[i].lSize;

            pTrackPool[i].pMemory=NULL;
            pTrackPool[i].lSize=lNextFreeEntry;
            pTrackPool[i].pModule=NULL;
            pTrackPool[i].lLineNo=0;
            pTrackPool[i].bStopWhenFreed=FALSE;

            lNextFreeEntry = i;

            return;
        }
    }

    DISPDBG(( 0, "freeing some piece of memory which was not allocated in this context"));

}

//-----------------------------------------------------------------------------
// 
//  MemTrackerDebugChk
//
//  print out some debug info about tracked memory
//
//-----------------------------------------------------------------------------

VOID MemTrackerDebugChk()
{
    if (glMemTrackerVerboseMode==0) return;

    DISPDBG(( 0, "MemTracker: %ld total allocated memory (%ld for tracker, total %ld)", 
        lTotalAllocatedMemory, pTrackPool[0].lSize,pTrackPool[0].lSize+lTotalAllocatedMemory));

    LONG lTotalTrackedMemory=0;
    for (INT i=0; i<lTrackPoolSize; i++)
    {
        pTrackPool[i].bTemp=FALSE;
        if (pTrackPool[i].pMemory!=NULL)
        {
            lTotalTrackedMemory += pTrackPool[i].lSize;

            if (glMemTrackerVerboseMode & 2)
            {
                DISPDBG((0, "%5ld:%s, line %5ld: %ld b, %p",
                    i, 
                    pTrackPool[i].lLineNo,
                    pTrackPool[i].pModule, 
                    pTrackPool[i].lSize,
                    pTrackPool[i].pMemory)); 
            }
        }
    }

    DISPDBG(( 0, "  sanity check: %ld bytes allocated", lTotalTrackedMemory));

    if (!(glMemTrackerVerboseMode & 1))
        return;

    for (i=1; i<lTrackPoolSize; i++)
    {
        if ( pTrackPool[i].pMemory!=NULL &&
            !pTrackPool[i].bTemp)
        {
            LONG lAllocations=0;
            LONG lTrackedMemory=0;

            for (INT v=i; v<lTrackPoolSize; v++)
            {
                if (!pTrackPool[v].bTemp &&
                     pTrackPool[v].lLineNo==pTrackPool[i].lLineNo &&
                     pTrackPool[v].pModule==pTrackPool[i].pModule)
                {
                    pTrackPool[v].bTemp=TRUE;
                    lAllocations++;
                    lTrackedMemory+=pTrackPool[v].lSize;
                }
            }

            DISPDBG((0, "  %s, line %5ld: %ld bytes total, %ld allocations",
                    pTrackPool[i].pModule, 
                    pTrackPool[i].lLineNo,
                    lTrackedMemory, 
                    lAllocations
                    ));
        }
    }
}

#endif
////////////////////////////////////////////////////////////////////////////

static DWORD readableRegistersP2[] = {
    __Permedia2TagStartXDom,
    __Permedia2TagdXDom,
    __Permedia2TagStartXSub,
    __Permedia2TagdXSub,
    __Permedia2TagStartY,
    __Permedia2TagdY,               
    __Permedia2TagCount,            
    __Permedia2TagRasterizerMode,   
    __Permedia2TagYLimits,
    __Permedia2TagXLimits,
    __Permedia2TagScissorMode,
    __Permedia2TagScissorMinXY,
    __Permedia2TagScissorMaxXY,
    __Permedia2TagScreenSize,
    __Permedia2TagAreaStippleMode,
    __Permedia2TagWindowOrigin,
    __Permedia2TagAreaStipplePattern0,
    __Permedia2TagAreaStipplePattern1,
    __Permedia2TagAreaStipplePattern2,
    __Permedia2TagAreaStipplePattern3,
    __Permedia2TagAreaStipplePattern4,
    __Permedia2TagAreaStipplePattern5,
    __Permedia2TagAreaStipplePattern6,
    __Permedia2TagAreaStipplePattern7,
    __Permedia2TagTextureAddressMode,
    __Permedia2TagSStart,
    __Permedia2TagdSdx,
    __Permedia2TagdSdyDom,
    __Permedia2TagTStart,
    __Permedia2TagdTdx,
    __Permedia2TagdTdyDom,
    __Permedia2TagQStart,
    __Permedia2TagdQdx,
    __Permedia2TagdQdyDom,
    // texellutindex..transfer are treated seperately
    __Permedia2TagTextureBaseAddress,
    __Permedia2TagTextureMapFormat,
    __Permedia2TagTextureDataFormat,
    __Permedia2TagTexel0,
    __Permedia2TagTextureReadMode,
    __Permedia2TagTexelLUTMode,
    __Permedia2TagTextureColorMode,
    __Permedia2TagFogMode,
    __Permedia2TagFogColor,
    __Permedia2TagFStart,
    __Permedia2TagdFdx,
    __Permedia2TagdFdyDom,
    __Permedia2TagKsStart,
    __Permedia2TagdKsdx,
    __Permedia2TagdKsdyDom,
    __Permedia2TagKdStart,
    __Permedia2TagdKddx,
    __Permedia2TagdKddyDom,
    __Permedia2TagRStart,
    __Permedia2TagdRdx,
    __Permedia2TagdRdyDom,
    __Permedia2TagGStart,
    __Permedia2TagdGdx,
    __Permedia2TagdGdyDom,
    __Permedia2TagBStart,
    __Permedia2TagdBdx,
    __Permedia2TagdBdyDom,
    __Permedia2TagAStart,
    __Permedia2TagColorDDAMode,
    __Permedia2TagConstantColor,
    __Permedia2TagAlphaBlendMode,
    __Permedia2TagDitherMode,
    __Permedia2TagFBSoftwareWriteMask,
    __Permedia2TagLogicalOpMode,
    __Permedia2TagLBReadMode,
    __Permedia2TagLBReadFormat,
    __Permedia2TagLBSourceOffset,
    __Permedia2TagLBWindowBase,
    __Permedia2TagLBWriteMode,
    __Permedia2TagLBWriteFormat,
    __Permedia2TagTextureDownloadOffset,
    __Permedia2TagWindow,
    __Permedia2TagStencilMode,
    __Permedia2TagStencilData,
    __Permedia2TagStencil,
    __Permedia2TagDepthMode,
    __Permedia2TagDepth,
    __Permedia2TagZStartU,
    __Permedia2TagZStartL,
    __Permedia2TagdZdxU,
    __Permedia2TagdZdxL,
    __Permedia2TagdZdyDomU,
    __Permedia2TagdZdyDomL,
    __Permedia2TagFBReadMode,
    __Permedia2TagFBSourceOffset,
    __Permedia2TagFBPixelOffset,
    __Permedia2TagFBWindowBase,
    __Permedia2TagFBWriteMode,
    __Permedia2TagFBHardwareWriteMask,
    __Permedia2TagFBBlockColor,
    __Permedia2TagFBReadPixel,
    __Permedia2TagFilterMode,
    __Permedia2TagStatisticMode,
    __Permedia2TagMinRegion,
    __Permedia2TagMaxRegion,
    __Permedia2TagFBBlockColorU,
    __Permedia2TagFBBlockColorL,
    __Permedia2TagFBSourceBase,
    __Permedia2TagTexelLUT0,
    __Permedia2TagTexelLUT1,
    __Permedia2TagTexelLUT2,
    __Permedia2TagTexelLUT3,
    __Permedia2TagTexelLUT4,
    __Permedia2TagTexelLUT5,
    __Permedia2TagTexelLUT6,
    __Permedia2TagTexelLUT7,
    __Permedia2TagTexelLUT8,
    __Permedia2TagTexelLUT9,
    __Permedia2TagTexelLUT10,
    __Permedia2TagTexelLUT11,
    __Permedia2TagTexelLUT12,
    __Permedia2TagTexelLUT13,
    __Permedia2TagTexelLUT14,
    __Permedia2TagTexelLUT15,

    __Permedia2TagYUVMode,
    __Permedia2TagChromaUpperBound,
    __Permedia2TagChromaLowerBound,
    __Permedia2TagAlphaMapUpperBound,
    __Permedia2TagAlphaMapLowerBound,

    // delta tag values. must be at the end of this array

    // v0/1/2 fixed are not used and for that reason not in the context
    
    __Permedia2TagV0FloatS,
    __Permedia2TagV0FloatT,
    __Permedia2TagV0FloatQ,
    __Permedia2TagV0FloatKs,
    __Permedia2TagV0FloatKd,
    __Permedia2TagV0FloatR,
    __Permedia2TagV0FloatG,
    __Permedia2TagV0FloatB,
    __Permedia2TagV0FloatA,
    __Permedia2TagV0FloatF,
    __Permedia2TagV0FloatX,
    __Permedia2TagV0FloatY,
    __Permedia2TagV0FloatZ,
    
    __Permedia2TagV1FloatS,
    __Permedia2TagV1FloatT,
    __Permedia2TagV1FloatQ,
    __Permedia2TagV1FloatKs,
    __Permedia2TagV1FloatKd,
    __Permedia2TagV1FloatR,
    __Permedia2TagV1FloatG,
    __Permedia2TagV1FloatB,
    __Permedia2TagV1FloatA,
    __Permedia2TagV1FloatF,
    __Permedia2TagV1FloatX,
    __Permedia2TagV1FloatY,
    __Permedia2TagV1FloatZ,
    
    __Permedia2TagV2FloatS,
    __Permedia2TagV2FloatT,
    __Permedia2TagV2FloatQ,
    __Permedia2TagV2FloatKs,
    __Permedia2TagV2FloatKd,
    __Permedia2TagV2FloatR,
    __Permedia2TagV2FloatG,
    __Permedia2TagV2FloatB,
    __Permedia2TagV2FloatA,
    __Permedia2TagV2FloatF,
    __Permedia2TagV2FloatX,
    __Permedia2TagV2FloatY,
    __Permedia2TagV2FloatZ,
    
    __Permedia2TagDeltaMode};

#define N_P2_READABLE_REGISTERS (sizeof(readableRegistersP2)/sizeof(DWORD))

static DWORD P2SaveRegs[N_P2_READABLE_REGISTERS];

static PCHAR szReadableRegistersP2[] = {
    "StartXDom",
    "dXDom",
    "StartXSub",
    "dXSub",
    "StartY",
    "dY",               
    "Count",            
    "RasterizerMode",   
    "YLimits",
    "XLimits",
    "ScissorMode",
    "ScissorMinXY",
    "ScissorMaxXY",
    "ScreenSize",
    "AreaStippleMode",
    "WindowOrigin",
    "AreaStipplePattern0",
    "AreaStipplePattern1",
    "AreaStipplePattern2",
    "AreaStipplePattern3",
    "AreaStipplePattern4",
    "AreaStipplePattern5",
    "AreaStipplePattern6",
    "AreaStipplePattern7",
    "TextureAddressMode",
    "SStart",
    "dSdx",
    "dSdyDom",
    "TStart",
    "dTdx",
    "dTdyDom",
    "QStart",
    "dQdx",
    "dQdyDom",
    
    "TextureBaseAddress",
    "TextureMapFormat",
    "TextureDataFormat",
    "Texel0",
    "TextureReadMode",
    "TexelLUTMode",
    "TextureColorMode",
    "FogMode",
    "FogColor",
    "FStart",
    "dFdx",
    "dFdyDom",
    "KsStart",
    "dKsdx",
    "dKsdyDom",
    "KdStart",
    "dKddx",
    "dKddyDom",
    "RStart",
    "dRdx",
    "dRdyDom",
    "GStart",
    "dGdx",
    "dGdyDom",
    "BStart",
    "dBdx",
    "dBdyDom",
    "AStart",
    "ColorDDAMode",
    "ConstantColor",
    "AlphaBlendMode",
    "DitherMode",
    "FBSoftwareWriteMask",
    "LogicalOpMode",
    "LBReadMode",
    "LBReadFormat",
    "LBSourceOffset",
    "LBWindowBase",
    "LBWriteMode",
    "LBWriteFormat",
    "TextureDownloadOffset",
    "Window",
    "StencilMode",
    "StencilData",
    "Stencil",
    "DepthMode",
    "Depth",
    "ZStartU",
    "ZStartL",
    "dZdxU",
    "dZdxL",
    "dZdyDomU",
    "dZdyDomL",
    "FBReadMode",
    "FBSourceOffset",
    "FBPixelOffset",
    "FBWindowBase",
    "FBWriteMode",
    "FBHardwareWriteMask",
    "FBBlockColor",
    "FBReadPixel",
    "FilterMode",
    "StatisticMode",
    "MinRegion",
    "MaxRegion",
    "FBBlockColorU",
    "FBBlockColorL",
    "FBSourceBase",
    "TexelLUT0",
    "TexelLUT1",
    "TexelLUT2",
    "TexelLUT3",
    "TexelLUT4",
    "TexelLUT5",
    "TexelLUT6",
    "TexelLUT7",
    "TexelLUT8",
    "TexelLUT9",
    "TexelLUT10",
    "TexelLUT11",
    "TexelLUT12",
    "TexelLUT13",
    "TexelLUT14",
    "TexelLUT15",
    "YUVMode",
    "ChromaUpperBound",
    "ChromaLowerBound",
    "AlphaMapUpperBound",
    "AlphaMapLowerBound",

    // delta tag values. must be at the end of this array

    // v0/1/2 fixed are not used and for that reason not in the context
    
    "V0FloatS",
    "V0FloatT",
    "V0FloatQ",
    "V0FloatKs",
    "V0FloatKd",
    "V0FloatR",
    "V0FloatG",
    "V0FloatB",
    "V0FloatA",
    "V0FloatF",
    "V0FloatX",
    "V0FloatY",
    "V0FloatZ",
    
    "V1FloatS",
    "V1FloatT",
    "V1FloatQ",
    "V1FloatKs",
    "V1FloatKd",
    "V1FloatR",
    "V1FloatG",
    "V1FloatB",
    "V1FloatA",
    "V1FloatF",
    "V1FloatX",
    "V1FloatY",
    "V1FloatZ",
    
    "V2FloatS",
    "V2FloatT",
    "V2FloatQ",
    "V2FloatKs",
    "V2FloatKd",
    "V2FloatR",
    "V2FloatG",
    "V2FloatB",
    "V2FloatA",
    "V2FloatF",
    "V2FloatX",
    "V2FloatY",
    "V2FloatZ",
    
    "DeltaMode"
    };


VOID PrintAllP2Registers( ULONG ulDebugLevel, PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);
    INT i;

    SYNC_WITH_PERMEDIA;

    DISPDBG((ulDebugLevel,"dumping P2 register set"));

    for (i=0;i<N_P2_READABLE_REGISTERS;i++)
    {
        DWORD lValue=READ_FIFO_REG(readableRegistersP2[i]); 
        DISPDBG((ulDebugLevel," %-25s, 0x%08lx",szReadableRegistersP2[i],lValue));
    }
}

VOID SaveAllP2Registers( PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);
    INT i;

    SYNC_WITH_PERMEDIA;

    for (i=0;i<N_P2_READABLE_REGISTERS;i++)
    {
        P2SaveRegs[i]=READ_FIFO_REG(readableRegistersP2[i]);        
    }
}

VOID PrintDifferentP2Registers(ULONG ulDebugLevel, PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);
    INT i;

    SYNC_WITH_PERMEDIA;

    DISPDBG((ulDebugLevel,"dumping P2 register set"));

    for (i=0;i<N_P2_READABLE_REGISTERS;i++)
    {
        DWORD dwValue=READ_FIFO_REG(readableRegistersP2[i]);        
        if (P2SaveRegs[i]!=dwValue)
        {
            DISPDBG((ulDebugLevel," %-25s, 0x%08lx was 0x%08lx",
                szReadableRegistersP2[i], dwValue, P2SaveRegs[i]));
        }
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\debug.h ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: debug.h
*
* Debugging support interfaces.    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

extern
VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );


#if DBG

// In order to enable per component debugging, DebugFilter will
// contain the bit pattern that will turn on messages for them.
// Debug messages with a debuglevel of 0 will be printed regardless
// of the filter in effect.The DWORD in which the DebugFilter is
// stored and the patterns of the filter masks will allow up to
// 4 separate components to be tracked, each one with 8 separate
// subcomponents.

// Note: During the transition phase to this new functionality, a 
// filter of 0 will print ALL messages, but will later be switched 
// to print NONE (expect of course , those at level 0)

extern DWORD DebugFilter;
extern DWORD DebugPrintFilter;

#define DEBUG_FILTER_D3D   0x000000FF
#define DEBUG_FILTER_DD    0x0000FF00
#define DEBUG_FILTER_GDI   0x00FF0000

#define MINOR_DEBUG

#define DISPDBG(arg) DebugPrint arg

#define DBG_COMPONENT(arg, component)        \
{       DebugPrintFilter = component;        \
        DebugPrint arg ;                     \
        DebugPrintFilter = 0;                \
}

#define DBG_D3D(arg)        DBG_COMPONENT(arg,DEBUG_FILTER_D3D)
#define DBG_DD(arg)         DBG_COMPONENT(arg,DEBUG_FILTER_DD)
#define DBG_GDI(arg)        DBG_COMPONENT(arg,DEBUG_FILTER_GDI)

#define RIP(x) { DebugPrint(-1000, x); DebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)

extern VOID __cdecl DebugMsg(PCHAR DebugMessage, ...);
extern void DumpSurface(LONG Level, LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, LPDDSURFACEDESC lpDDSurfaceDesc);
extern void DecodeBlend(LONG Level, DWORD i );

#define DUMPSURFACE(a, b, c) DumpSurface(a, b, c); 
#define DECODEBLEND(a, b) DecodeBlend(a, b);

#define PRINTALLP2REGISTER    PrintAllP2Registers  
#define PRINTDIFFP2REGISTER   PrintDifferentP2Registers
#define SAVEALLP2REGISTER     SaveAllP2Registers  

VOID PrintAllP2Registers( ULONG ulDebugLevel, PPDev ppdev);
VOID SaveAllP2Registers( PPDev ppdev);
VOID PrintDifferentP2Registers(ULONG ulDebugLevel, PPDev ppdev);

#if TRACKMEMALLOC
//------------------------------------------------------------------------------
//
//  Memory Tracker
//
//------------------------------------------------------------------------------




VOID MemTrackerAddInstance();
VOID MemTrackerRemInstance();
PVOID MemTrackerAllocateMem(PVOID p, 
                           LONG lSize, 
                           PCHAR pModule, 
                           LONG lLineNo, 
                           BOOL bStopWhenFreed);
VOID MemTrackerFreeMem( VOID *p);
VOID MemTrackerDebugChk();

#define MEMTRACKERADDINSTANCE MemTrackerAddInstance
#define MEMTRACKERREMINSTANCE MemTrackerRemInstance
#define MEMTRACKERALLOCATEMEM MemTrackerAllocateMem
#define MEMTRACKERFREEMEM     MemTrackerFreeMem
#define MEMTRACKERDEBUGCHK    MemTrackerDebugChk

#else

#define MEMTRACKERADDINSTANCE / ## /
#define MEMTRACKERREMINSTANCE / ## /
#define MEMTRACKERALLOCATEMEM / ## /
#define MEMTRACKERFREEMEM     / ## /
#define MEMTRACKERDEBUGCHK    / ## /

#endif

//------------------------------------------------------------------------------
//
// THUNK_LAYER
//
// By Setting THUNK_LAYER equal to 1 you are adding a wrapper call on top of
// all DDI rendering functions.  In this thunk layer of wrapper calls
// several usefull debugging features are enabled.
//
// Surface checks--which can help catch errant rendering routines
// Event logging---which can record rendering evernts to a log file
//
//------------------------------------------------------------------------------


#define THUNK_LAYER 0

#if THUNK_LAYER

BOOL
xDrvBitBlt(SURFOBJ*  psoDst,
          SURFOBJ*  psoSrc,
          SURFOBJ*  psoMsk,
          CLIPOBJ*  pco,
          XLATEOBJ* pxlo,
          RECTL*    prclDst,
          POINTL*   pptlSrc,
          POINTL*   pptlMsk,
          BRUSHOBJ* pbo,
          POINTL*   pptlBrush,
          ROP4      rop4);

BOOL
xDrvCopyBits(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc);

BOOL 
xDrvTransparentBlt(
   SURFOBJ *    psoDst,
   SURFOBJ *    psoSrc,
   CLIPOBJ *    pco,
   XLATEOBJ *   pxlo,
   RECTL *      prclDst,
   RECTL *      prclSrc,
   ULONG        iTransColor,
   ULONG        ulReserved);

BOOL xDrvAlphaBlend(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   RECTL    *prclSrc,
   BLENDOBJ *pBlendObj);

BOOL
xDrvGradientFill(
   SURFOBJ      *psoDst,
   CLIPOBJ      *pco,
   XLATEOBJ     *pxlo,
   TRIVERTEX    *pVertex,
   ULONG        nVertex,
   PVOID        pMesh,
   ULONG        nMesh,
   RECTL        *prclExtents,
   POINTL       *pptlDitherOrg,
   ULONG        ulMode
   );

BOOL
xDrvTextOut(SURFOBJ*     pso,
           STROBJ*      pstro,
           FONTOBJ*     pfo,
           CLIPOBJ*     pco,
           RECTL*       prclExtra,
           RECTL*       prclOpaque,
           BRUSHOBJ*    pboFore,
           BRUSHOBJ*    pboOpaque,
           POINTL*      pptlBrush, 
           MIX          mix);

BOOL
xDrvFillPath(
    SURFOBJ*    pso,
    PATHOBJ*    ppo,
    CLIPOBJ*    pco,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    MIX         mix,
    FLONG       flOptions);

BOOL
xDrvLineTo(
    SURFOBJ*  pso,
    CLIPOBJ*  pco,
    BRUSHOBJ* pbo,
    LONG      x1,
    LONG      y1,
    LONG      x2,
    LONG      y2,
    RECTL*    prclBounds,
    MIX       mix);

BOOL
xDrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix);

#endif

#else

#define DISPDBG(arg)
#define DBG_D3D(arg)
#define DBG_DD(arg)
#define DBG_GDI(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define DUMPSURFACE(a, b, c)
#define DECODEBLEND(a, b)

#define MEMTRACKERADDINSTANCE / ## /
#define MEMTRACKERREMINSTANCE / ## /
#define MEMTRACKERALLOCATEMEM / ## /
#define MEMTRACKERFREEMEM     / ## /
#define MEMTRACKERDEBUGCHK    / ## /

#define PRINTALLP2REGISTER      / ## /  
#define PRINTDIFFP2REGISTER     / ## /
#define SAVEALLP2REGISTER       / ## /

#endif

#define DebugBreak              EngDebugBreak

#define MAKE_BITMAPS_OPAQUE 0

//@@BEGIN_DDKSPLIT
#if GDI_TEST
//
// GDI debug functions
//
void vPuntAfter(ULONG flags, SURFOBJ * psoSrc, SURFOBJ * psoDst);

ULONG vPuntBefore(SURFOBJ * psoSrc, SURFOBJ * psoDst);
#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\directx.h ===
/******************************Module*Header**********************************\
*
*                           ***********************
*                           * DIRECTX SAMPLE CODE *
*                           ***********************
*
* Module Name: directx.h
*
* Content:     useful constants and definitions for DirectDraw and Direct3d
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __directx__
#define __directx__

//
//  switch to DirectDraw context if necessary.
//  must be used in any DDraw blt function

#define DDCONTEXT  if (ppdev->permediaInfo->pCurrentCtxt != (ppdev->pDDContext)) \
                   {     P2SwitchContext(ppdev, ppdev->pDDContext); }


//
// fourcc codes supported in the driver for blts
#define FOURCC_YUV422     0x32595559    

//  
//  constants for surface privatedata structure
#define P2_CANPATCH                1
#define P2_PPVALID                 2
#define P2_CKVALID                 4
#define P2_SURFACE_FORMAT_VALID    8
#define P2_SURFACE_PRIMARY        16
#define P2_EMULATED_16BITZ        32
#define P2_ISPATCHED              64
#define P2_SURFACE_FORMAT_PALETTE 256
#define P2_SURFACE_NEEDUPDATE   0x00000200  //indicating managed 
                                            //surface content is obsolete

//
//  this magic no. tells us if the surface has already been initialized
#define SURF_MAGIC_NO 0xd3d10110
#define CHECK_P2_SURFACEDATA_VALIDITY(ptr)    \
    ( ((ptr) != NULL) && ((ptr)->MagicNo == SURF_MAGIC_NO) )

// Permedia specific settings for surfaces.
// A pointer to this structure is stored in 
// each surface (in lpGbl->dwReserved1)
typedef struct _permedia_surface_type {
    int PixelSize;              // 
    int PixelShift;
    int PixelMask;
    int FBReadPixel;
    int logPixelSize;
    
    int Format;                 // format description according to 
                                // Permedia 2 manual
    int FormatExtension;        // format extension...
    int ColorComponents;
    int ColorOrder;             // BGR=0, RGB=1
    int Texture16BitMode;

    DWORD RedMask;              // masks of surface, copied from DDPIXELFORMAT
    DWORD GreenMask;
    DWORD BlueMask;
    DWORD AlphaMask;

    BOOL bAlpha;                // surface contains alpha pixels
    BOOL bPreMult;              // surface contains premultiplied alpha !!
} PERMEDIA_SURFACE;

//
//  complete private structure of a surface
typedef struct tagPermediaSurfaceData
{
    DWORD                       MagicNo;    // Magic number to ensure 
                                            // structure is valid
    DWORD                       dwFlags;    // Private flags

    ULONG                       ulPackedPP; // PP values for surface pitch
    
    PERMEDIA_SURFACE            SurfaceFormat;            
    FLATPTR                     fpVidMem;   // store the real vidmem 
                                            // for managed textures
    VIDEOMEMORY*                pvmHeap;    // heap pointer for the managed 
                                            // video texture
    DWORD                       dwPaletteHandle;    
                                            //for video memory surface use
} PermediaSurfaceData;

//
// these constants are used in the PERMEDIA_SURFACE structure,
// Format and FormatExtension
#define PERMEDIA_4BIT_PALETTEINDEX 15
#define PERMEDIA_4BIT_PALETTEINDEX_EXTENSION 0
#define PERMEDIA_8BIT_PALETTEINDEX 14
#define PERMEDIA_8BIT_PALETTEINDEX_EXTENSION 0
#define PERMEDIA_332_RGB 5
#define PERMEDIA_332_RGB_EXTENSION 0
#define PERMEDIA_2321_RGB 9
#define PERMEDIA_2321_RGB_EXTENSION 0
#define PERMEDIA_5551_RGB 1
#define PERMEDIA_5551_RGB_EXTENSION 0
#define PERMEDIA_565_RGB 0
#define PERMEDIA_565_RGB_EXTENSION 1
#define PERMEDIA_8888_RGB 0
#define PERMEDIA_8888_RGB_EXTENSION 0
#define PERMEDIA_888_RGB 4
#define PERMEDIA_888_RGB_EXTENSION 1
#define PERMEDIA_444_RGB 2
#define PERMEDIA_444_RGB_EXTENSION 0
#define PERMEDIA_YUV422 3
#define PERMEDIA_YUV422_EXTENSION 1
#define PERMEDIA_YUV411 2
#define PERMEDIA_YUV411_EXTENSION 1


// 
// Color formating helper defines
// they convert an RGB value in a certain format to a RGB 32 bit value
#define FORMAT_565_32BIT(val) \
( (((val & 0xF800) >> 8) << 16) |\
 (((val & 0x7E0) >> 3) << 8) |\
 ((val & 0x1F) << 3) )

#define FORMAT_565_32BIT_BGR(val)   \
    ( ((val & 0xF800) >> 8) |           \
      (((val & 0x7E0) >> 3) << 8) |     \
      ((val & 0x1F) << 19) )

#define FORMAT_5551_32BIT(val)      \
( (((val & 0x8000) >> 8) << 24) |\
 (((val & 0x7C00) >> 7) << 16) |\
 (((val & 0x3E0) >> 2) << 8) | ((val & 0x1F) << 3) )

#define FORMAT_5551_32BIT_BGR(val)  \
( (((val & 0x8000) >> 8) << 24) |       \
  ((val & 0x7C00) >> 7) |               \
  (((val & 0x3E0) >> 2) << 8) |         \
  ((val & 0x1F) << 19) )

#define FORMAT_4444_32BIT(val)          \
( ((val & 0xF000) << 16) |\
 (((val & 0xF00) >> 4) << 16) |\
 ((val & 0xF0) << 8) | ((val & 0xF) << 4) )

#define FORMAT_4444_32BIT_BGR(val)  \
( ((val & 0xF000) << 16) |              \
  ((val & 0xF00) >> 4) |                \
  ((val & 0xF0) << 8) |                 \
  ((val & 0xF) << 20) )

#define FORMAT_332_32BIT(val)           \
( ((val & 0xE0) << 16) |\
 (((val & 0x1C) << 3) << 8) |\
 ((val & 0x3) << 6) ) 

#define FORMAT_332_32BIT_BGR(val)   \
( (val & 0xE0) |                        \
  (((val & 0x1C) << 3) << 8) |          \
  ((val & 0x3) << 22) )

#define FORMAT_2321_32BIT(val)          \
( ((val & 0x80) << 24) | ((val & 0x60) << 17) |\
 (((val & 0x1C) << 3) << 8) | ((val & 0x3) << 6) ) 

#define FORMAT_2321_32BIT_BGR(val)      \
( ((val & 0x80) << 24) |                \
  ((val & 0x60) << 1) |                 \
  (((val & 0x1C) << 3) << 8) |          \
  ((val & 0x3) << 22) )

#define FORMAT_8888_32BIT_BGR(val)  \
( (val & 0xFF00FF00) | ( ((val & 0xFF0000) >> 16) | ((val & 0xFF) << 16) ) )

#define FORMAT_888_32BIT_BGR(val)   \
( (val & 0xFF00FF00) | ( ((val & 0xFF0000) >> 16) | ((val & 0xFF) << 16) ) )

#define CHROMA_UPPER_ALPHA(val) \
    (val | 0xFF000000)

#define CHROMA_LOWER_ALPHA(val) \
    (val & 0x00FFFFFF)

#define CHROMA_332_UPPER(val) \
    (val | 0x001F1F3F)

#define FORMAT_PALETTE_32BIT(val) \
    ( (val & 0xFF) | ((val & 0xFF) << 8) | ((val & 0xFF) << 16))


//
// Direct Draw related functions
//

VOID 
SetupPrivateSurfaceData(PPDev ppdev, 
                        PermediaSurfaceData* pPrivateData, 
                        LPDDRAWI_DDRAWSURFACE_LCL pSurface);


//-----------------------------------------------------------------------------
//                             AGP related declarations
//-----------------------------------------------------------------------------

//@@BEGIN_DDKSPLIT
//  TODO: implement 32MB AGP heap
//
//@@END_DDKSPLIT

#define P2_AGP_HEAPSIZE     8
#define DD_AGPSURFBASEOFFSET(psurf) \
        (psurf->fpHeapOffset - psurf->lpVidMemHeap->fpStart)

#define DD_AGPSURFACEPHYSICAL(psurf) \
        (ppdev->dwGARTDevBase + DD_AGPSURFBASEOFFSET(psurf))

#define DD_P2AGPCAPABLE(ppdev) \
        (ppdev->dwChipConfig & PM_CHIPCONFIG_AGPCAPABLE)


//@@BEGIN_DDKSPLIT
#if MULTITHREADED
//-----------------------------------------------------------------------------
//
// WRAPMTDXCALLBACK
//
// Generate multithread protected wrapper for Dx callbacks
//
//-----------------------------------------------------------------------------

#define WRAPMTDXCALLBACK(component, name, type, ptr, ppdevaccess)           \
    DWORD CALLBACK                                                          \
    Mt##name( type ptr )                                                    \
    {                                                                       \
        PPDev       ppdev = (PPDev)ppdevaccess;                             \
        DWORD       dwRet;                                                  \
                                                                            \
        if(ppdev->ulLockCount)                                              \
        {                                                                   \
             DBG_##component((MT_LOG_LEVEL,                                 \
                     "Mt" #name ": re-entry! %d", ppdev->ulLockCount));     \
        }                                                                   \
        EngAcquireSemaphore(ppdev->hsemLock);                               \
        ppdev->ulLockCount++;                                               \
                                                                            \
        dwRet = name(ptr);                                                  \
                                                                            \
        ppdev->ulLockCount--;                                               \
        EngReleaseSemaphore(ppdev->hsemLock);                               \
                                                                            \
        return dwRet;                                                       \
    }

#endif  MULTITHREADED
//@@END_DDKSPLIT


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\draw.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: draw.c
*
* Contains the DrvFillPath routine. Permedia P2 optimised functions
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"

//-----------------------------------------------------------------------------
//
// void vAlphaBlendDownload(GFNPB * ppb)
//
// Doing an alpha blend on a source surface which is in a pre-multiplied alpha
// 32bpp "BGRA" format; that is, the surface type is BMF_32BPP and the palette
// type is BI_RGB.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psoSrc------Pointer to source SURFOBJ
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  ucAlpha-----Alpha value
//
//-----------------------------------------------------------------------------
VOID
vAlphaBlendDownload(GFNPB * ppb)
{
    PDev*       ppdev = ppb->ppdev;
    Surf*       psurfDst = ppb->psurfDst;
    RECTL*      prcl = ppb->pRects;
    LONG        c = ppb->lNumRects;
    RECTL*      prclDst = ppb->prclDst;
    RECTL*      prclSrc = ppb->prclSrc;
    DWORD       dwRenderDirection;
    UCHAR       ucAlpha = ppb->ucAlpha;
    SURFOBJ*    psoSrc = ppb->psoSrc;
    ULONG*      pBuffer;

    DBG_GDI((6, "vAlphaBlendDownload called"));

    ASSERTDD(ppdev->cPelSize != 0,
        "vAlphaBlend: expect not to be in 8bpp mode");

    ASSERTDD(psoSrc->iBitmapFormat == BMF_32BPP,
        "vAlphaBlend: expect source bitmap format to be 32bpp");

    InputBufferReserve(ppdev, 20, &pBuffer);

    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[2] = __Permedia2TagAlphaBlendMode;
    pBuffer[3] = (1 << PM_ALPHABLENDMODE_BLENDTYPE) | // ramp
                 (1 << PM_ALPHABLENDMODE_COLORORDER) | // RGB
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (81 << PM_ALPHABLENDMODE_OPERATION) | // PreMult
                 (ppdev->ulPermFormat << PM_ALPHABLENDMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_ALPHABLENDMODE_COLORFORMATEXTENSION);
    
    // Reject range
    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] =  psurfDst->ulPixOffset;
   
    // set no read of source.
    pBuffer[6] = __Permedia2TagFBReadMode;
    pBuffer[7] =   0x400 | psurfDst->ulPackedPP;

    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    
    pBuffer[10] = __Permedia2TagTextureColorMode;
    pBuffer[11] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB 
                 (0 << 1) ; // Modulate

    pBuffer[12] = __Permedia2TagTextureDataFormat;
    pBuffer[13] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                 (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                 (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  1;

    pBuffer[16] = __Permedia2TagConstantColor;
    pBuffer[17] = ucAlpha << 24 | ucAlpha << 16 | ucAlpha << 8 | ucAlpha;

    pBuffer[18] = __Permedia2TagTextureReadMode;
    pBuffer[19] = PM_TEXREADMODE_ENABLE(__PERMEDIA_DISABLE);

    pBuffer += 20;
    
    InputBufferCommit(ppdev, pBuffer);
    
    while(c--)
    {
        
        InputBufferReserve(ppdev, 12, &pBuffer);
        
        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  prcl->left << 16;
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] =  prcl->right << 16;
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] =     prcl->top << 16;
        pBuffer[6] = __Permedia2TagdY;
        pBuffer[7] =         1 << 16;
        pBuffer[8] = __Permedia2TagCount;
        pBuffer[9] =      prcl->bottom - prcl->top;
        pBuffer[10] = __Permedia2TagRender;
        pBuffer[11] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE
                    | __RENDER_SYNC_ON_HOST_DATA;

        pBuffer += 12;
        
        InputBufferCommit(ppdev, pBuffer);

        // download data

        {
            LONG    xOffset = prclSrc->left + (prcl->left - prclDst->left);
            LONG    yOffset = prclSrc->top + (prcl->top - prclDst->top);
            ULONG * pulTexel = (ULONG *) psoSrc->pvScan0;
            ULONG   ulWidth = prcl->right - prcl->left;
            ULONG   ulHeight = prcl->bottom - prcl->top;
            LONG    ulPixDelta = psoSrc->lDelta >> 2;
            LONG    ulScanSkip = ulPixDelta - ulWidth;
            ULONG*  pulSentinel;

            ASSERTDD(psoSrc->pvScan0 != NULL, "pvScan0 is null");
            ASSERTDD((psoSrc->lDelta & 3) == 0, "lDelta not multiple of four");
            ASSERTDD(xOffset >= 0, "xOffset is negative");
            ASSERTDD(yOffset >= 0, "yOffset is negative");
            ASSERTDD(ulWidth < MAX_INPUT_BUFFER_RESERVATION,
                        "vAlphaBlendDownload: width is too large");

            pulTexel += xOffset;
            pulTexel += ulPixDelta * yOffset;

            while(ulHeight--)
            {
                 pulSentinel = pulTexel + ulWidth;

                 InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                 *pBuffer++ = __Permedia2TagTexel0 | ((ulWidth - 1) << 16);

                 while(pulTexel < pulSentinel)
                 {
                     ULONG  texel = *pulTexel++;

                     *pBuffer++ =  SWAP_BR(texel);
                 }

                 InputBufferCommit(ppdev, pBuffer);

                 pulTexel += ulScanSkip;
            }
                
        }

        prcl++;

    }

    //
    // Always restore default state
    //
    InputBufferReserve(ppdev, 16, &pBuffer);
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] =  __PERMEDIA_DISABLE;
    pBuffer[12] = __Permedia2TagAlphaBlendMode;
    pBuffer[13] =  __PERMEDIA_DISABLE;
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  __PERMEDIA_DISABLE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

}// vAlphaBlend()

//-----------------------------------------------------------------------------
//
// void vConstantAlphaBlend(GFNPB * ppb)
//
// Using constant blend factor to apply to the entire source surface
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  ucAlpha-----Alpha value
//
//-----------------------------------------------------------------------------
VOID
vConstantAlphaBlend(GFNPB * ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*  psurfSrc = ppb->psurfSrc;
    Surf*  psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    RECTL*  prclSrc = ppb->prclSrc;
    DWORD   dwRenderDirection;
    UCHAR   alpha = ppb->ucAlpha;
    ULONG*  pBuffer;
     

    DBG_GDI((6,"vConstantAlphaBlend called"));

    ASSERTDD(ppdev->cPelSize != 0,
        "vAlphaBlend: expect not to be in 8bpp mode");

    // setup loop invariant state

    InputBufferReserve(ppdev, 26, &pBuffer);
    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[2] = __Permedia2TagAlphaBlendMode;
    pBuffer[3] = ppdev->ulPermFormat << 8 |
                 ppdev->ulPermFormatEx << 16 |
                 ( 1 << 0 ) | // enable blending
                 ( 1 << 13) | // color order: BGR=0, RGB=1
                 ( 1 << 14) | // BlendType: RGB=0, Ramp=1
                 (84 << 1);   // Operation: Blend=84, PreMult=81
        

    
    // Reject range
    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] =  psurfDst->ulPixOffset;
    
    // set no read of source.
    pBuffer[6] = __Permedia2TagFBReadMode;
    pBuffer[7] =  0x400   // read destination enable
               | psurfDst->ulPackedPP;
    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    
    // set base of source
    pBuffer[10] = __Permedia2TagTextureBaseAddress;
    pBuffer[11] =  psurfSrc->ulPixOffset;
    pBuffer[12] = __Permedia2TagTextureAddressMode;
    pBuffer[13] = (1 << PM_TEXADDRESSMODE_ENABLE);
    
    pBuffer[14] = __Permedia2TagTextureColorMode;
    pBuffer[15] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (0 << 1);  // Modulate
    
    pBuffer[16] = __Permedia2TagTextureReadMode;
    pBuffer[17] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                 PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                 PM_TEXREADMODE_WIDTH(11) |
                 PM_TEXREADMODE_HEIGHT(11);
    
    pBuffer[18] = __Permedia2TagTextureDataFormat;
    pBuffer[19] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                 (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                 (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER) |
                 (1 << 4); // no alpha
    
    pBuffer[20] = __Permedia2TagTextureMapFormat;
    pBuffer[21] = (psurfSrc->ulPackedPP) | 
                 (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);


    pBuffer[22] = __Permedia2TagColorDDAMode;
    pBuffer[23] =  1;
    pBuffer[24] = __Permedia2TagConstantColor;
    pBuffer[25] =  alpha << 24 | 0xffffff ;

    pBuffer += 26;

    InputBufferCommit(ppdev, pBuffer);

    while(c--)
    {
        
        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        
        rSrc.left = prclSrc->left + (rDest.left - prclDst->left);
        rSrc.top = prclSrc->top + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }
        
//@@BEGIN_DDKSPLIT
        // TODO: remove some of the magic values
//@@END_DDKSPLIT
        if (psurfSrc->ulPixOffset != psurfDst->ulPixOffset)
        {
            dwRenderDirection = 1;
        }
        else
        {
            if(rSrc.top < rDest.top)
            {
                dwRenderDirection = 0;
            }
            else if(rSrc.top > rDest.top)
            {
                dwRenderDirection = 1;
            }
            else if(rSrc.left < rDest.left)
            {
                dwRenderDirection = 0;
            }
            else dwRenderDirection = 1;
        }
        
        InputBufferReserve(ppdev, 24, &pBuffer);
        
        // Left -> right, top->bottom
        if (dwRenderDirection)
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.left << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     rSrc.top << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       1 << 20;
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    1 << 20;
        
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.left << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.right << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     rDest.top << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         1 << 16;
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }
        else
        // right->left, bottom->top
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.right << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     (rSrc.bottom - 1) << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       (DWORD)(-1 << 20);
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    (DWORD)(-1 << 20);
        
            // Render right to left, bottom to top
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.right << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.left << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     (rDest.bottom - 1) << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         (DWORD)(-1 << 16);
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }

        pBuffer += 24;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;

    }

    InputBufferReserve(ppdev, 20, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] =  __PERMEDIA_DISABLE;
    pBuffer[12] = __Permedia2TagAlphaBlendMode;
    pBuffer[13] =  __PERMEDIA_DISABLE;
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  __PERMEDIA_DISABLE;
    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] =  __PERMEDIA_DISABLE;
    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] =  __PERMEDIA_DISABLE;

    pBuffer += 20;

    InputBufferCommit(ppdev, pBuffer);

}// vConstantAlphaBlend()

//-----------------------------------------------------------------------------
//
// void vAlphaBlend(GFNPB * ppb)
//
// Doing an alpha blend on a source surface which is in a pre-multiplied alpha
// 32bpp "BGRA" format; that is, the surface type is BMF_32BPP and the palette
// type is BI_RGB.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  ucAlpha-----Alpha value
//
//-----------------------------------------------------------------------------
VOID
vAlphaBlend(GFNPB * ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfSrc = ppb->psurfSrc;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    RECTL*  prclSrc = ppb->prclSrc;
    DWORD   dwRenderDirection;
    UCHAR   ucAlpha = ppb->ucAlpha;
    ULONG*      pBuffer;

    DBG_GDI((6, "vAlphaBlend called"));
    
    DBG_GDI((7,"vAlphaBlend"));

    ASSERTDD(ppdev->cPelSize != 0,
        "vAlphaBlend: expect not to be in 8bpp mode");

    InputBufferReserve(ppdev, 26, &pBuffer);

    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[2] = __Permedia2TagAlphaBlendMode;
    pBuffer[3] = (1 << PM_ALPHABLENDMODE_BLENDTYPE) | // ramp
                 (1 << PM_ALPHABLENDMODE_COLORORDER) | // RGB
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (81 << PM_ALPHABLENDMODE_OPERATION) | // PreMult
                 (ppdev->ulPermFormat << PM_ALPHABLENDMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_ALPHABLENDMODE_COLORFORMATEXTENSION);
    
    // Reject range
    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] =  psurfDst->ulPixOffset;
    
    // set no read of source.
    pBuffer[6] = __Permedia2TagFBReadMode;
    pBuffer[7] =   0x400 | psurfDst->ulPackedPP;
    
    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    
    // set base of source
    pBuffer[10] = __Permedia2TagTextureBaseAddress;
    pBuffer[11] =  psurfSrc->ulPixOffset;
    
    pBuffer[12] = __Permedia2TagTextureAddressMode;
    pBuffer[13] = (1 << PM_TEXADDRESSMODE_ENABLE);
    
    pBuffer[14] = __Permedia2TagTextureColorMode;
    pBuffer[15] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (0 << 1);  // Modulate
    
    pBuffer[16] = __Permedia2TagTextureReadMode;
    pBuffer[17] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                  PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                  PM_TEXREADMODE_WIDTH(11) |
                  PM_TEXREADMODE_HEIGHT(11);
    
    pBuffer[18] = __Permedia2TagTextureDataFormat;
    pBuffer[19] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                  (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                  (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[20] = __Permedia2TagTextureMapFormat;
    pBuffer[21] = (psurfSrc->ulPackedPP) | 
                  (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);
    
    pBuffer[22] = __Permedia2TagColorDDAMode;
    pBuffer[23] =  1;

    pBuffer[24] = __Permedia2TagConstantColor;
    pBuffer[25] = ucAlpha << 24 | ucAlpha << 16 | ucAlpha << 8 | ucAlpha;

    pBuffer += 26;

    InputBufferCommit(ppdev, pBuffer);
    
    while(c--)
    {
        
        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        
        rSrc.left = prclSrc->left + (rDest.left - prclDst->left);
        rSrc.top = prclSrc->top + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }
        
//@@BEGIN_DDKSPLIT
        // TODO: use continuation to save permedia writes

        // TODO: remove some of the magic values
//@@END_DDKSPLIT
        if (psurfSrc->ulPixOffset != psurfDst->ulPixOffset)
        {
            dwRenderDirection = 1;
        }
        else
        {
            if(rSrc.top < rDest.top)
            {
                dwRenderDirection = 0;
            }
            else if(rSrc.top > rDest.top)
            {
                dwRenderDirection = 1;
            }
            else if(rSrc.left < rDest.left)
            {
                dwRenderDirection = 0;
            }
            else dwRenderDirection = 1;
        }
        
        /*
         * Render the rectangle
         */
        
        InputBufferReserve(ppdev, 24, &pBuffer);
        
        // Left -> right, top->bottom
        if (dwRenderDirection)
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.left << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     rSrc.top << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       1 << 20;
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    1 << 20;
        
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.left << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.right << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     rDest.top << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         1 << 16;
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }
        else
        // right->left, bottom->top
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] =     rSrc.right << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] =     (rSrc.bottom - 1) << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] =       (DWORD)(-1 << 20);
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] =    0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] =       0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] =    (DWORD)(-1 << 20);
        
            // Render right to left, bottom to top
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] =  rDest.right << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] =  rDest.left << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] =     (rDest.bottom - 1) << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] =         (DWORD)(-1 << 16);
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] =      rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                        | __RENDER_TEXTURED_PRIMITIVE;
        }
        
        pBuffer += 24;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;

    }

    //
    // Always restore default state
    //
    InputBufferReserve(ppdev, 16, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] =  __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] =  __PERMEDIA_DISABLE;
    pBuffer[12] = __Permedia2TagAlphaBlendMode;
    pBuffer[13] =  __PERMEDIA_DISABLE;
    pBuffer[14] = __Permedia2TagColorDDAMode;
    pBuffer[15] =  __PERMEDIA_DISABLE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

}// vAlphaBlend()

//-----------------------------------------------------------------------------
//
// VOID vCopyBlt(GFNPB* ppb)
//
// Does a screen-to-screen copy blt of a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------

VOID
vCopyBlt(GFNPB* ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*  psurfSrc = ppb->psurfSrc;
    Surf*  psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    DWORD   renderBits = __RENDER_TRAPEZOID_PRIMITIVE;
    DWORD   offset;
    LONG    sourceOffset;
    DWORD   windowBase;
    LONG    windowOffset;
    ULONG   DestPitch = psurfDst->ulPixDelta;
    ULONG   SourcePitch = psurfSrc->ulPixDelta;
    BOOL    bEnablePacked = TRUE;
    ULONG   ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);

    DBG_GDI((6, "vCopyBlt called"));

    windowBase = psurfDst->ulPixOffset;
    windowOffset = (LONG) (psurfSrc->ulPixOffset - psurfDst->ulPixOffset);

    
    // BUGFIX: Permedia hardware bug
    // We can not enable if we have an overlapping blt with not vertical shift
    // and a horizontal shift less or equal to ppdev->dwBppMask
    if (psurfSrc == psurfDst && prclDst->top == pptlSrc->y)
    {
        LONG    xShift = prclDst->left - pptlSrc->x;

        if(xShift >= 0 && xShift <= (LONG) ppdev->dwBppMask)
            bEnablePacked = FALSE;
    }

    // BUGFIX: Permedia hardware bug???
    // We have intermittent failures of the copy operation
    // when going from the screen to offscreen where the first
    // four bytes (when in 8bpp) of every row are not copied.
    // For now, I'm disabling until we can talk with the permedia folks.
    bEnablePacked = FALSE;

    // setup loop invariant state
    ULONG*  pBuffer;

    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = windowBase;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    while(c--) {

        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;

        rSrc.left = pptlSrc->x + (rDest.left - prclDst->left);
        rSrc.top = pptlSrc->y + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }

        if(bEnablePacked)
        {
            offset = (((rDest.left & ppdev->dwBppMask) 
                        - (rSrc.left & ppdev->dwBppMask)) & 7);
            sourceOffset = windowOffset 
              + ((rSrc.top * SourcePitch) + (rSrc.left & ~(ppdev->dwBppMask)))
              - ((rDest.top * DestPitch) + (rDest.left & ~(ppdev->dwBppMask)))
              + ((DestPitch - SourcePitch) * rDest.top);
       }
        else
        {
            offset = 0;
            sourceOffset = windowOffset + ((rSrc.top * SourcePitch) + rSrc.left)
                                       - ((rDest.top * DestPitch) + rDest.left)
                                      + ((DestPitch - SourcePitch) * rDest.top);
        }
        
//        P2_DEFAULT_FB_DEPTH;

        ULONG readMode = PM_FBREADMODE_PARTIAL(psurfSrc->ulPackedPP) |
                         PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)   |
                         PM_FBREADMODE_RELATIVEOFFSET(offset) |
                         LogicopReadDest[ulLogicOP];

        ULONG writeConfig = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP) |
                          PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)   |
                          PM_FBREADMODE_RELATIVEOFFSET(offset) |
                          LogicopReadDest[ulLogicOP];
                           

        if(bEnablePacked)
        {
            readMode |= PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE);
            writeConfig |= PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE);
        }
    
        // Render the rectangle

        ULONG startXDom;
        ULONG startXSub;
        ULONG packedDataLimits;
        ULONG startY;
        ULONG dy;
    
        if (sourceOffset >= 0) {
            // Use left to right and top to bottom

            if(bEnablePacked)
            {
                startXDom = (rDest.left >> ppdev->bBppShift) << 16;
                startXSub = ((rDest.right >> ppdev->bBppShift) 
                          + ppdev->dwBppMask) << 16;
            
                packedDataLimits = PM_PACKEDDATALIMITS_OFFSET(offset)     |
                                   PM_PACKEDDATALIMITS_XSTART(rDest.left) |
                                   PM_PACKEDDATALIMITS_XEND(rDest.right);
            }
            else
            {
                startXDom = rDest.left  << 16;
                startXSub = rDest.right << 16;
            }

            startY =  rDest.top << 16;
            dy = 1 << 16;
        }
        else
        {
            // Use right to left and bottom to top

            if(bEnablePacked)
            {
                startXDom = (((rDest.right) >> ppdev->bBppShift) 
                          + ppdev->dwBppMask) << 16; 
                startXSub = (rDest.left >> ppdev->bBppShift) << 16;
                packedDataLimits = PM_PACKEDDATALIMITS_OFFSET(offset) |
                                   PM_PACKEDDATALIMITS_XSTART(rDest.right) |
                                   PM_PACKEDDATALIMITS_XEND(rDest.left);
            }
            else
            {
                startXDom =  rDest.right << 16; 
                startXSub = rDest.left << 16;
            }
            
            startY = (rDest.bottom - 1) << 16;
            dy = (DWORD)((-1) << 16);
        }
    
        ULONG count = rDest.bottom - rDest.top; 
        
        InputBufferReserve(ppdev, 18, &pBuffer);

        pBuffer[0] = __Permedia2TagFBSourceOffset;
        pBuffer[1] =  sourceOffset;
        pBuffer[2] = __Permedia2TagFBReadMode;
        pBuffer[3] =  readMode;
        pBuffer[4] = __Permedia2TagFBWriteConfig;
        pBuffer[5] =  writeConfig;
        pBuffer[6] = __Permedia2TagStartXDom;
        pBuffer[7] =  startXDom;
        pBuffer[8] = __Permedia2TagStartXSub;
        pBuffer[9] =  startXSub;
        
#if 0        
        if(bEnablePacked)
        {
            pBuffer[0] = __Permedia2TagPackedDataLimits;
            pBuffer[1] =  packedDataLimits;
        }
#endif
        pBuffer[10] = __Permedia2TagStartY;
        pBuffer[11] =  startY;
        pBuffer[12] = __Permedia2TagdY;
        pBuffer[13] =  dy;
        pBuffer[14] = __Permedia2TagCount;
        pBuffer[15] =  count;
        pBuffer[16] = __Permedia2TagRender;
        pBuffer[17] =  renderBits;

        pBuffer += 18;

        InputBufferCommit(ppdev, pBuffer);


        prcl++;
    }

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] = INTtoFIXED(1);

    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);

}// vCopyBlt()

//-----------------------------------------------------------------------------
//
// VOID vCopyBltNative(GFNPB* ppb)
//
// Does a screen-to-screen copy blt of a list of rectangles.
//
// Note: The difference between this function and vCopyBlt() is that this
// function will be called only when the source and dest has the same pitch
// size. The reason is that we are using the Permedia2 packed data feature to
// do a 32 bits copy. Unfortunately when the source and dest has the different
// pitch, the hardware has some problems to implement it right. So in
// vCopyBlt(), we have to disable PackedData copy which slows down a lot
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------
VOID
vCopyBltNative(GFNPB* ppb)
{
    PDev*   ppdev = ppb->ppdev;
    
    Surf*   psurfDst = ppb->psurfDst;
    Surf*   psurfSrc = ppb->psurfSrc;
    
    RECTL*  prcl = ppb->pRects;
    RECTL*  prclDst = ppb->prclDst;
    
    POINTL* pptlSrc = ppb->pptlSrc;
    
    LONG    lNumRects = ppb->lNumRects;
    LONG    lSourceOffset;
    LONG    lWindowOffset;
    
    DWORD   dwOffset;
    ULONG   ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);
    ULONG   ulPitch = psurfDst->ulPixDelta;

    DBG_GDI((6, "vCopyBltNative called, ulPitch=%d", ulPitch));

    lWindowOffset = (LONG)(psurfSrc->ulPixOffset - psurfDst->ulPixOffset);

    //
    // Setup loop invariant state
    //
    ULONG*  pBuffer;

    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = psurfDst->ulPixOffset;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    while( lNumRects-- )
    {
        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        rSrc.left = pptlSrc->x + (rDest.left - prclDst->left);
        rSrc.top = pptlSrc->y + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if ( rSrc.top < 0 )
        {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }

        if ( rSrc.left < 0 )
        {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }

        dwOffset = (((rDest.left & ppdev->dwBppMask)
                 - (rSrc.left & ppdev->dwBppMask)) & 7);
        lSourceOffset = lWindowOffset
                      + ( (rSrc.top - rDest.top) * ulPitch )
                      + ( rSrc.left & ~(ppdev->dwBppMask) )
                      - ( rDest.left & ~(ppdev->dwBppMask) );

        //
        // Render the rectangle
        //
        ULONG ulStartXDom;
        ULONG ulStartXSub;
        ULONG ulPackedDataLimits;
        ULONG ulStartY;
        ULONG ulDY;

        DBG_GDI((6, "lSourceOffset=%d", lSourceOffset));

        if ( lSourceOffset >= 0 )
        {
            //
            // Use left to right and top to bottom
            //
            ulStartXDom = (rDest.left >> ppdev->bBppShift) << 16;
            ulStartXSub = ((rDest.right >> ppdev->bBppShift)
                        + ppdev->dwBppMask) << 16;

            ulPackedDataLimits = PM_PACKEDDATALIMITS_OFFSET(dwOffset)
                               | (rDest.left << 16)
                               | (rDest.right);

            ulStartY =  rDest.top << 16;
            ulDY = 1 << 16;
        }// if ( lSourceOffset >= 0 )
        else
        {
            //
            // Use right to left and bottom to top
            //
            ulStartXDom = (((rDest.right) >> ppdev->bBppShift)
                        + ppdev->dwBppMask) << 16;
            ulStartXSub = (rDest.left >> ppdev->bBppShift) << 16;
            ulPackedDataLimits = PM_PACKEDDATALIMITS_OFFSET(dwOffset)
                               | (rDest.right << 16)
                               | (rDest.left);

            ulStartY = (rDest.bottom - 1) << 16;
            ulDY = (DWORD)((-1) << 16);
        }// if ( lSourceOffset < 0 )

        InputBufferReserve(ppdev, 18, &pBuffer);

        pBuffer[0] = __Permedia2TagFBSourceOffset;
        pBuffer[1] = lSourceOffset;
        pBuffer[2] = __Permedia2TagFBReadMode;
        pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfSrc->ulPackedPP)
                   | PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)
                   | PM_FBREADMODE_RELATIVEOFFSET(dwOffset)
                   | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)
                   | LogicopReadDest[ulLogicOP];
        pBuffer[4] = __Permedia2TagPackedDataLimits;
        pBuffer[5] = ulPackedDataLimits;
        pBuffer[6] = __Permedia2TagStartXDom;
        pBuffer[7] = ulStartXDom;
        pBuffer[8] = __Permedia2TagStartXSub;
        pBuffer[9] = ulStartXSub;
        pBuffer[10] = __Permedia2TagStartY;
        pBuffer[11] = ulStartY;
        pBuffer[12] = __Permedia2TagdY;
        pBuffer[13] = ulDY;
        pBuffer[14] = __Permedia2TagCount;
        pBuffer[15] = rDest.bottom - rDest.top;
        pBuffer[16] = __Permedia2TagRender;
        pBuffer[17] = __RENDER_TRAPEZOID_PRIMITIVE;

        pBuffer += 18;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;
    }// while( lNumRects-- )

    //
    // Restore dY register value
    //
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] = INTtoFIXED(1);

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);
}// vCopyBltNative()

//-----------------------------------------------------------------------------
//
// VOID vRop2Blt
//
// Does a screen-to-screen blt of a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//  usRop4------Rop4
//
//-----------------------------------------------------------------------------

VOID
vRop2Blt(GFNPB * ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfSrc = ppb->psurfSrc;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    ULONG   ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);
    ULONG*  pBuffer;
    
//    PERMEDIA_DECL_VARS;
//    PERMEDIA_DECL_INIT;


    ASSERTDD(psurfSrc != psurfDst, "vRop2Blt: unexpected psurfSrc == psurfDst");

    InputBufferReserve(ppdev, 32, &pBuffer);
    
    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  psurfDst->ulPixOffset;
    
    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] =  P2_ENABLED_LOGICALOP(ulLogicOP);
    
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    
    pBuffer[6] = __Permedia2TagFBWriteConfig;
    pBuffer[7] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    
    pBuffer[8] = __Permedia2TagDitherMode;
    pBuffer[9] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[10] = __Permedia2TagTextureAddressMode;
    pBuffer[11] = (1 << PM_TEXADDRESSMODE_ENABLE);
    
    pBuffer[12] = __Permedia2TagTextureColorMode;
    pBuffer[13] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (3 << 1);  // Copy
    
    pBuffer[14] = __Permedia2TagTextureReadMode;
    pBuffer[15] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                 PM_TEXREADMODE_WIDTH(11) |
                 PM_TEXREADMODE_HEIGHT(11);
    
    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                 (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                 (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] = (psurfSrc->ulPackedPP) | 
                 (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);
    pBuffer[20] = __Permedia2TagSStart;
    pBuffer[21] =  0;
    pBuffer[22] = __Permedia2TagTStart;
    pBuffer[23] =  0;
    
    pBuffer[24] = __Permedia2TagdSdx;
    pBuffer[25] =       1 << 20;
    pBuffer[26] = __Permedia2TagdSdyDom;
    pBuffer[27] =    0;
    pBuffer[28] = __Permedia2TagdTdx;
    pBuffer[29] =       0;
    pBuffer[30] = __Permedia2TagdTdyDom;
    pBuffer[31] =    1 << 20;

    pBuffer += 32;

    InputBufferCommit(ppdev, pBuffer);
    
    while(c--) {

        // Render the rectangle

        ULONG ulSrcOffset = psurfSrc->ulPixOffset
                          + pptlSrc->x + (prcl->left - prclDst->left)
                          + (pptlSrc->y + (prcl->top - prclDst->top))
                            * psurfSrc->ulPixDelta;

        InputBufferReserve(ppdev, 12, &pBuffer);

        pBuffer[0] = __Permedia2TagTextureBaseAddress;
        pBuffer[1] =  ulSrcOffset;
        pBuffer[2] = __Permedia2TagStartXDom;
        pBuffer[3] =  prcl->left  << 16;
        pBuffer[4] = __Permedia2TagStartXSub;
        pBuffer[5] =  prcl->right << 16;
        pBuffer[6] = __Permedia2TagStartY;
        pBuffer[7] =  prcl->top << 16;
        pBuffer[8] = __Permedia2TagCount;
        pBuffer[9] =  prcl->bottom - prcl->top;
        pBuffer[10] = __Permedia2TagRender;
        pBuffer[11] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE;

        pBuffer += 12;
        
        InputBufferCommit(ppdev, pBuffer);
        
        prcl++;
    }

    // Restore default state
    InputBufferReserve(ppdev, 8, &pBuffer);
    
    pBuffer[0] = __Permedia2TagDitherMode;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagTextureAddressMode;
    pBuffer[3] =  __PERMEDIA_DISABLE;
    pBuffer[4] = __Permedia2TagTextureColorMode;
    pBuffer[5] =  __PERMEDIA_DISABLE;
    pBuffer[6] = __Permedia2TagTextureReadMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;

    pBuffer += 8;

    InputBufferCommit(ppdev, pBuffer);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\download.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: download.c
*
* Contains the upload and download routines.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"

//-----------------------------------------------------------------------------
//
// VOID vDownloadNative(GFNPB* ppb)
//
// Does a download of a native surface for a list of rectangles.
// Note: this download takes the advantage of Permedia 2 packed data read.
//      Because of the permedia 2 hardware limitation, we can only use the
//      packedData download when the logic OP is SRC_COPY or the destination
//      is aligned to the packed data being downloaded. This will typically be
//      when the surface is 32 bpp. Otherwise, we just do the regular download
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------
VOID
vDownloadNative(GFNPB* ppb)
{
    PDev*       ppdev = ppb->ppdev;
    Surf*       psurfDst = ppb->psurfDst;
    SURFOBJ*    pSrcSurface = ppb->psoSrc;

    RECTL*      pRects = ppb->pRects;
    RECTL*      prclDst = ppb->prclDst;
    
    POINTL*     pptlSrc = ppb->pptlSrc;
    
    BOOL        bEnablePacked;
    
    DWORD       dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                             | __RENDER_SYNC_ON_HOST_DATA;
    LONG        lNumRects = ppb->lNumRects;
    LONG        lSrcStride;
    LONG        lXOffset = pptlSrc->x - prclDst->left;
    LONG        lYOffset = pptlSrc->y - prclDst->top;

    ULONG       ulLogicOP = ulRop2ToLogicop(ppb->ulRop4 & 0xf);
    ULONG*      pBuffer;

    //
    // Note: Due to the hardware limitation, we can take the advantage of
    // Permedia 2 PackedData copy only when the logic OP is SRC_COPY, or
    // the destination is aligned to the packed data being downloaded.
    // This will typically be when the surface is 32 bpp.
    //
    if ( (ulLogicOP == K_LOGICOP_COPY)
       ||(pSrcSurface->iBitmapFormat == BMF_32BPP) )
    {
        bEnablePacked = TRUE;
    }
    else
    {
        bEnablePacked = FALSE;
    }

    DBG_GDI((6, "vDownloadNative called, logicop=%d", ulLogicOP));

    DBG_GDI((6, "source SURFOBJ=0x%x", pSrcSurface));
    DBG_GDI((6, "pptlSrc(x, y)(%d, %d) logicop=%d",
             pptlSrc->x, pptlSrc->y, ulLogicOP));
    DBG_GDI((6, "prclDst(left, right, top, bottom)(%d, %d, %d, %d)",
             prclDst->left, prclDst->right, prclDst->top, prclDst->bottom));
    DBG_GDI((6, "lXOffset=%d, lYOffset=%d", lXOffset, lYOffset));

    vCheckGdiContext(ppdev);

    InputBufferReserve(ppdev, 10, &pBuffer);

    //
    // Setup loop invariant state
    //
    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = psurfDst->ulPixOffset;
    pBuffer[4] = __Permedia2TagFBPixelOffset;
    pBuffer[5] = 0;
    pBuffer[6] = __Permedia2TagFBReadPixel;
    pBuffer[7] = ppdev->cPelSize;
    pBuffer[8] =  __Permedia2TagdY;
    pBuffer[9] = INTtoFIXED(1);

    pBuffer += 10;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Loop all the rectangles to render
    //
    while( lNumRects-- )
    {
        ULONG   ulMask = ppdev->dwBppMask;
        DWORD   dwReadMode = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                           | LogicopReadDest[ulLogicOP];
        
        ULONG   ulStartXDom;
        ULONG   ulStartXSub;
        
        LONG    lSrcLeft = lXOffset + pRects->left;
        
        //
        // Calculate the 3 bit 2's compliment shift that is required to align
        // the source pixels with the destination. This relative offset can be
        // used to shift the downloaded data to the 32 bit destination alignment
        // that packing requires. This enables you to read DWORD aligned data
        // on the host despite the data not being aligned correctly for the
        // packing.
        //
        ULONG   ulOffset = ( (pRects->left & ulMask)
                           - (lSrcLeft & ulMask)) & 0x7;
        
        DBG_GDI((6, "ulOffset = 0x%x", ulOffset));
        DBG_GDI((6, "pRects(left, right, top, bottom)(%d, %d, %d, %d)",
                 pRects->left, pRects->right, pRects->top, pRects->bottom));

        if ( (bEnablePacked == FALSE) && (ulOffset == 0) )
        {
            //
            // As long as the source and dest are aligned, then we can still use
            // the packed data copy, even with logic OPs
            //
            DBG_GDI((6, "Turn packed data on when src and dst are aligned"));
            bEnablePacked = TRUE;
        }

        ULONG   ulWidth = pRects->right - pRects->left;
        ULONG   ulHeight = pRects->bottom - pRects->top;
        
        ULONG   ulDstLeft;
        ULONG   ulDstRight;
        ULONG   ulDstWidth;        
        LONG    lSrcRight;
        ULONG   ulSrcWidth;
        ULONG   ulExtra;
        
        if ( bEnablePacked == TRUE )
        {
            ULONG   ulShift = ppdev->bBppShift;
            
            ulDstLeft = pRects->left >> ulShift;
            ulDstRight = (pRects->right + ulMask) >> ulShift;
            ulDstWidth = ulDstRight - ulDstLeft;
        
            lSrcRight = (lSrcLeft + ulWidth + ulMask) >> ulShift;
        
            lSrcLeft >>= ulShift;
        
            ulSrcWidth = (ULONG)(lSrcRight - lSrcLeft);
        
            //
            // We need to convert from pixel coordinates to ULONG coordinates.
            // Also, we need to set the destination width to the greater of the
            // source width or destination width.  If destination width is
            // greater then the source width, we need to remember this so that
            // we can download an additional dummy value without reading past
            // the end of the source data (which could result in an access
            // fault).
            //
            if( ulDstWidth <= ulSrcWidth )
            {
                ulExtra = 0;
                ulWidth = ulSrcWidth;
            }
            else
            {
                ulWidth = ulDstWidth;
                ulExtra = 1;
            }
        
            dwReadMode |= (PM_FBREADMODE_RELATIVEOFFSET(ulOffset)
                         | PM_FBREADMODE_READSOURCE(__PERMEDIA_DISABLE)
                         | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE) );
            ulStartXDom = INTtoFIXED(ulDstLeft);
            ulStartXSub = INTtoFIXED(ulDstLeft + ulWidth);
        }
        else
        {
            dwReadMode |= PM_FBREADMODE_RELATIVEOFFSET(0);

            ulStartXDom = INTtoFIXED(pRects->left);
            ulStartXSub = INTtoFIXED(pRects->right);
        }

        InputBufferReserve(ppdev, 14, &pBuffer);
        
        pBuffer[0] = __Permedia2TagFBReadMode;
        pBuffer[1] = dwReadMode;
        pBuffer[2] = __Permedia2TagStartXDom;
        pBuffer[3] = ulStartXDom;
        pBuffer[4] = __Permedia2TagStartXSub;
        pBuffer[5] = ulStartXSub;

        //
        // Test result shows that it won't hurt if we are doing non-packed
        // download and setting this register. If we move this settings
        // inside the "bEnablePacked == TRUE" case, then we need the extra
        // InputBufferReserve/InputBufferCommit for packed data download
        // which will hurt performance
        //
        pBuffer[6] = __Permedia2TagPackedDataLimits;
        pBuffer[7] = PM_PACKEDDATALIMITS_OFFSET(ulOffset)
                   |(INTtoFIXED(pRects->left)
                   | pRects->right);
        pBuffer[8] = __Permedia2TagStartY;
        pBuffer[9] = INTtoFIXED(pRects->top);
        pBuffer[10] = __Permedia2TagCount;
        pBuffer[11] = ulHeight;
        pBuffer[12] = __Permedia2TagRender;
        pBuffer[13] = dwRenderBits;
        pBuffer += 14;

        InputBufferCommit(ppdev, pBuffer);
        
        if ( bEnablePacked == TRUE )
        {
            ULONG*  pulSrcStart = (ULONG*)(pSrcSurface->pvScan0);
            lSrcStride = pSrcSurface->lDelta >> 2;

            ULONG* pulSrc = (ULONG*)(pulSrcStart
                                     + ((lYOffset + pRects->top) * lSrcStride)
                                     + lSrcLeft);        
            ULONG*  pulData = pulSrc;

            while ( ulHeight-- )
            {
                ULONG   ulTemp = ulSrcWidth;
                ULONG*  pulSrcTemp = pulData;

                InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                pBuffer[0] = __Permedia2TagColor | ((ulWidth - 1) << 16);
                pBuffer +=1;

                while ( ulTemp-- )
                {
                    *pBuffer++ = *pulSrcTemp++;
                }

                if ( ulExtra )
                {
                    *pBuffer++ = 0;
                }

                InputBufferCommit(ppdev, pBuffer);

                pulData += lSrcStride;
            }// while ( ulHeight-- )
        }// PackedEnabled case
        else if ( pSrcSurface->iBitmapFormat == BMF_16BPP )
        {
            USHORT* psSrcStart = (USHORT*)(pSrcSurface->pvScan0);
            lSrcStride = pSrcSurface->lDelta >> 1;

            USHORT* psSrc = (USHORT*)(psSrcStart
                                      + ((lYOffset + pRects->top) * lSrcStride)
                                      + lSrcLeft);
            USHORT*  psData = psSrc;

            while ( ulHeight-- )
            {
                ULONG   ulTemp = ulWidth;
                USHORT* psSrcTemp = psData;

                InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                pBuffer[0] = __Permedia2TagColor | ((ulWidth - 1) << 16);
                pBuffer +=1;

                while ( ulTemp-- )
                {
                    *pBuffer++ = (ULONG)(*psSrcTemp++);
                }

                InputBufferCommit(ppdev, pBuffer);

                psData += lSrcStride;
            }// while ( ulHeight-- )
        }// 16 bpp non-packed case
        else if ( pSrcSurface->iBitmapFormat == BMF_8BPP )
        {
            BYTE*   pcSrcStart = (BYTE*)(pSrcSurface->pvScan0);
            lSrcStride = pSrcSurface->lDelta;

            BYTE* pcSrc = (BYTE*)(pcSrcStart
                                  + ((lYOffset + pRects->top) * lSrcStride)
                                  + lSrcLeft);        
            BYTE*  pcData = pcSrc;

            while ( ulHeight-- )
            {
                ULONG   ulTemp = ulWidth;
                BYTE*   pcSrcTemp = pcData;

                InputBufferReserve(ppdev, ulWidth + 1, &pBuffer);

                pBuffer[0] = __Permedia2TagColor | ((ulWidth - 1) << 16);
                pBuffer +=1;

                while ( ulTemp-- )
                {
                    *pBuffer++ = (ULONG)(*pcSrcTemp++);
                }

                InputBufferCommit(ppdev, pBuffer);

                pcData += lSrcStride;
            }// while ( ulHeight-- )
        }// 8 bpp non-packed case
        else
        {
            //
            // Since we have a check in DrvBitBlt
            // if(psoSrc->iBitmapFormat == pb.ppdev->iBitmapFormat) before we
            // allow it to call this function, so this ASSERT should never
            // be hit. It will if we implement 24 bpp download late.
            //
            ASSERTDD(0, "we don't handle it for now");
        }

        //
        // Next rectangle
        //
        pRects++;
    }// while( lNumRects-- )
}// vDownloadNative()

//-----------------------------------------------------------------------------
//
// VOID vDowload4Bpp(GFNPB* ppb)
//
// Does a download of a 4bpp surface for a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------

ULONG   gDownload4BppEnabled = 1;

#if 0
VOID
vDownload4Bpp(GFNPB* ppb)
{
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    DWORD   dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_SYNC_ON_HOST_DATA;
    BYTE*   pbSrcStart = (BYTE *) ppb->psoSrc->pvScan0;
    LONG    lSrcStride = ppb->psoSrc->lDelta;
    ULONG   ulOffset = ((pptlSrc->x & 1) -
                        (prclDst->left & ppdev->dwBppMask)) & 0x7;

    if(!gDownload4BppEnabled) return;

    PERMEDIA_DECL_VARS;
    PERMEDIA_DECL_INIT;
    VALIDATE_GDI_CONTEXT;
    
//    P2_CHECK_STATE;

    P2_DEFAULT_FB_DEPTH;

    // setup loop invariant state
    WAIT_INPUT_FIFO(4);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    if(ppdev->cPelSize < 2)
    {
        SEND_PERMEDIA_DATA(FBReadMode, psurfDst->ulPackedPP |
                                      PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE) |
                                      PM_FBREADMODE_RELATIVEOFFSET(ulOffset));
    }
    else
    {
        // Do we even need this at all???
        SEND_PERMEDIA_DATA(FBReadMode, psurfDst->ulPackedPP);
    }

    SEND_PERMEDIA_DATA(FBWindowBase, psurfDst->ulPixOffset);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    DEXE_INPUT_FIFO();

    while(c--) {

        LONG    lSrcLeft = pptlSrc->x + (prcl->left - prclDst->left);
        LONG    lSrcTop = pptlSrc->y + (prcl->top - prclDst->top);

        ASSERTDD(lSrcLeft >= 0, "ugh");
        ASSERTDD(lSrcTop >= 0, "ugh");

        // Render the rectangle

        ULONG left = prcl->left >> ppdev->bBppShift;
        ULONG right = (prcl->right + ppdev->dwBppMask) >> ppdev->bBppShift;
        ULONG width = right - left;
        ULONG count = prcl->bottom - prcl->top; 

        WAIT_INPUT_FIFO((ppdev->cPelSize < 2 ? 6 : 5));
        
        SEND_PERMEDIA_DATA(StartXDom, left << 16);
        SEND_PERMEDIA_DATA(StartXSub, right << 16);
        if(ppdev->cPelSize < 2)
        {
            SEND_PERMEDIA_DATA(PackedDataLimits,
                                    PM_PACKEDDATALIMITS_OFFSET(ulOffset) 
                                  | (prcl->left << 16) | prcl->right);
        }
        SEND_PERMEDIA_DATA(StartY, prcl->top << 16);
        SEND_PERMEDIA_DATA(Count, count);
        SEND_PERMEDIA_DATA(Render, dwRenderBits);

        DEXE_INPUT_FIFO();

        BYTE *  srcScan = (BYTE *)(pbSrcStart + (lSrcTop * lSrcStride))
                    + (lSrcLeft >> 1);
        ULONG*  aulXlate = ppb->pxlo->pulXlate;

        while(count--)
        {
            LONG    remaining = width;
            ULONG*  lp = pPermedia->GetDMAPtr(width+1);
            BYTE*   src = srcScan;

            *lp++ = __Permedia2TagColor | ((width-1) << 16);
            
            switch(ppdev->cPelSize)
            {
            case 0:

                while(remaining-- > 0)
                {
    
                    *lp++ = aulXlate[src[0] & 0x0F] |
                           (aulXlate[(src[0] & 0xF0) >> 4] << 8) |
                           (aulXlate[src[1] & 0xf] << 16) |
                           (aulXlate[(src[1] & 0xf0) >> 4] << 24);

                    src += 2;
                }

                break;

            case 1:
            
                while(remaining >= 8)
                {
                    remaining -= 8;
                    lp[0] = aulXlate[src[0] & 0x0F] | (aulXlate[(src[0] & 0xF0) >> 4] << 16);
                    lp[1] = aulXlate[src[1] & 0x0F] | (aulXlate[(src[1] & 0xF0) >> 4] << 16);
                    lp[2] = aulXlate[src[2] & 0x0F] | (aulXlate[(src[2] & 0xF0) >> 4] << 16);
                    lp[3] = aulXlate[src[3] & 0x0F] | (aulXlate[(src[3] & 0xF0) >> 4] << 16);
                    lp[4] = aulXlate[src[4] & 0x0F] | (aulXlate[(src[4] & 0xF0) >> 4] << 16);
                    lp[5] = aulXlate[src[5] & 0x0F] | (aulXlate[(src[5] & 0xF0) >> 4] << 16);
                    lp[6] = aulXlate[src[6] & 0x0F] | (aulXlate[(src[6] & 0xF0) >> 4] << 16);
                    lp[7] = aulXlate[src[7] & 0x0F] | (aulXlate[(src[7] & 0xF0) >> 4] << 16);
                    lp+=8;
                    src+=8;
                }

                while(remaining-- > 0)
                {
                    *lp++ = aulXlate[src[0] & 0x0F] | (aulXlate[(src[0] & 0xF0) >> 4] << 16);
                    src++;
                }
                
                break;
            
            case 2:
            
                if(lSrcLeft & 1)
                {
                    *lp++ = aulXlate[(src[0] & 0xf0) >> 4];
                    src++;
                    remaining--;
                }

                while(remaining >= 8)
                {
                    remaining -= 8;
                    lp[0] = aulXlate[src[0] & 0x0F];
                    lp[1] = aulXlate[(src[0] & 0xf0) >> 4];
                    lp[2] = aulXlate[src[1] & 0x0F];
                    lp[3] = aulXlate[(src[1] & 0xf0) >> 4];
                    lp[4] = aulXlate[src[2] & 0x0F];
                    lp[5] = aulXlate[(src[2] & 0xf0) >> 4];
                    lp[6] = aulXlate[src[3] & 0x0F];
                    lp[7] = aulXlate[(src[3] & 0xf0) >> 4];

                    src+=4;
                    lp += 8;
                }
                
                while(remaining > 1)
                {
                    remaining -= 2;
                    *lp++ = aulXlate[src[0] & 0x0F];
                    *lp++ = aulXlate[(src[0] & 0xf0) >> 4];

                    src++;
                }

                if(remaining)
                {
                    *lp++ = aulXlate[src[0] & 0xf];
                }
                
                break;
            
            }

            srcScan += lSrcStride;

            pPermedia->DoneDMAPtr();

        }
                
        prcl++;
    }

}// vDownload4Bpp()
#endif

//-----------------------------------------------------------------------------
//
// VOID vDowload4Bpp(GFNPB* ppb)
//
// Does a download of a 4bpp surface for a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------

VOID
vDownload24Bpp(GFNPB* ppb)
{
#if 0
    PDev*   ppdev = ppb->ppdev;
    Surf*   psurfDst = ppb->psurfDst;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclDst = ppb->prclDst;
    POINTL* pptlSrc = ppb->pptlSrc;
    DWORD   dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                       | __RENDER_SYNC_ON_HOST_DATA;
    BYTE*   pbSrcStart = (BYTE*)ppb->psoSrc->pvScan0;
    LONG    lSrcStride = ppb->psoSrc->lDelta;
    ULONG   ulOffset = ((pptlSrc->x & ppdev->dwBppMask)
                     - (prclDst->left & ppdev->dwBppMask)) & 0x7;

    PERMEDIA_DECL_VARS;
    PERMEDIA_DECL_INIT;
    VALIDATE_GDI_CONTEXT;
    
    P2_CHECK_STATE;

    P2_DEFAULT_FB_DEPTH;

    // setup loop invariant state
    WAIT_INPUT_FIFO(4);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBReadMode, psurfDst->ulPackedPP |
                                  PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE) |
                                  PM_FBREADMODE_RELATIVEOFFSET(ulOffset));
    SEND_PERMEDIA_DATA(FBWindowBase, psurfDst->ulPixOffset);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    DEXE_INPUT_FIFO();

    while(c--)
    {
        LONG    lSrcLeft = pptlSrc->x + (prcl->left - prclDst->left);
        LONG    lSrcTop = pptlSrc->y + (prcl->top - prclDst->top);

        ASSERTDD(lSrcLeft >= 0, "ugh");
        ASSERTDD(lSrcTop >= 0, "ugh");

        // Render the rectangle

        ULONG left = prcl->left >> ppdev->bBppShift;
        ULONG right = (prcl->right + ppdev->dwBppMask) >> ppdev->bBppShift;
        ULONG width = right - left;
        ULONG count = prcl->bottom - prcl->top; 

        WAIT_INPUT_FIFO(6);
        
        SEND_PERMEDIA_DATA(StartXDom, left << 16);
        SEND_PERMEDIA_DATA(StartXSub, right << 16);
        SEND_PERMEDIA_DATA(PackedDataLimits,
                                PM_PACKEDDATALIMITS_OFFSET(ulOffset) 
                              | (prcl->left << 16) | prcl->right);
        SEND_PERMEDIA_DATA(StartY, prcl->top << 16);
        SEND_PERMEDIA_DATA(Count, count);
        SEND_PERMEDIA_DATA(Render, dwRenderBits);

        DEXE_INPUT_FIFO();

        ULONG * src = (ULONG *) (pbSrcStart + (lSrcTop * lSrcStride)
                    + ((lSrcLeft & ~(ppdev->dwBppMask)) << ppdev->cPelSize));

        #if 0
        BLKLD_INPUT_FIFO_LINES(__Permedia2TagColor, src, width, count, lSrcStride); 
        #else
        while(count--)
        {
            ULONG   i;
            for(i=0; i<width; i++)
            {
                WAIT_INPUT_FIFO(1);
                SEND_PERMEDIA_DATA(Color, 0);
                EXE_INPUT_FIFO();
            }
        }
        #endif
        
        prcl++;
    }
#endif
}// vDownload24Bpp()

//-----------------------------------------------------------------------------
//
// VOID vUploadNative
//
// Does a VM-to-SM copy of a list of rectangles.
//
// Argumentes needed from function block (GFNPB)
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  lNumRects---Number of rectangles to fill
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pptlSrc-----Original unclipped source point
//
//-----------------------------------------------------------------------------
VOID
vUploadNative(GFNPB* ppb)
{
    PDev*       ppdev = ppb->ppdev;
    POINTL*     pptlSrc = ppb->pptlSrc;
    RECTL*      prclDst = ppb->prclDst;
    RECTL*      pRects = ppb->pRects;
    Surf*       psurfSrc = ppb->psurfSrc;
    SURFOBJ*    psoDst = ppb->psoDst;
    
    BYTE*       pbDst;
    BYTE*       pbDstStart = (BYTE*)psoDst->pvScan0;
    BYTE*       pbSrc;
    BYTE*       pbSrcStart = (BYTE*)ppdev->pjScreen + psurfSrc->ulByteOffset;
    
    LONG        lDstStride = psoDst->lDelta;
    LONG        lNumRects = ppb->lNumRects;
    LONG        lSrcStride = psurfSrc->lDelta;

    InputBufferSync(ppdev);
    DBG_GDI((6, "vUploadNative called"));

    while( lNumRects-- )
    {
        LONG    lWidthInBytes = (pRects->right - pRects->left) 
                              << ppdev->cPelSize;
        LONG    lHeight = pRects->bottom - pRects->top;
        LONG    lSrcX = pptlSrc->x + (pRects->left - prclDst->left);
        LONG    lSrcY = pptlSrc->y + (pRects->top - prclDst->top);

        if( (lWidthInBytes != 0) && (lHeight != 0) )
        {
            pbSrc = pbSrcStart + (lSrcX << ppdev->cPelSize); // Offset in Bytes
            pbSrc += (lSrcY * lSrcStride);               // Add vertical offset
            pbDst = pbDstStart + (pRects->left << ppdev->cPelSize);
            pbDst += (pRects->top * lDstStride);

            //
            // Up to this point, "pbSrc" points to the beginning of the bits
            // needs to be copied and "pbDst" points to the position for the
            // receiving bits
            //
            // Now copy it row by row, vertically
            //
            while( lHeight-- )
            {
                LONG    lCount = lWidthInBytes;

                //
                // If the source address is not DWORD aligned,
                // (pbSrc & 0x3 != 0), then we copy these bytes first until
                // it reaches DWORD aligned condition
                //
                // The reason we are doing alignment is unaligned DWORD reads
                // are twice as expensive as aligned reads
                //
                while( (((ULONG_PTR)pbSrc & 0x3)) && (lCount > 0) )
                {
                    *pbDst++ = *pbSrc++;
                    lCount--;
                }

                //
                // Up to this point, the source should be DWORD aligned. So we
                // can start to do uploading at DWORD level till there are less
                // than bytes left
                //
                ULONG* pulSrc = (ULONG*)pbSrc;
                ULONG* pulDst = (ULONG*)pbDst;

                while( lCount >= 4 )
                {
                    *(ULONG UNALIGNED*)pulDst++ = *pulSrc++;
                    lCount -= 4;
                }

                //
                // Now copy the last several left over bytes
                //
                pbSrc = (BYTE*)pulSrc;
                pbDst = (BYTE*)pulDst;

                while( lCount > 0 )
                {
                    *pbDst++ = *pbSrc++;
                    lCount--;
                }

                //
                // Move onto next line
                //
                pbSrc += (lSrcStride - lWidthInBytes);
                pbDst += (lDstStride - lWidthInBytes);
            }// while( lHeight-- )
        }// if( (lWidthInBytes != 0) && (lHeight != 0) )

        pRects++;
    }// while( lNumRects-- )
}// vUploadNative
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\driver.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* Contains definitions and typedefs common to all driver
* components.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __DRIVER__H__
#define __DRIVER__H__

typedef struct _PDev PDev;          // Handy forward declaration
typedef struct _Surf Surf;          // Handy forward declaration
typedef struct _GFNPB GFNPB;        // Handy forward declaration

typedef VOID (GFN)(GFNPB*);
typedef BOOL (GFNLINE)(PDev*, LONG, LONG, LONG, LONG);
typedef BOOL (GFNINIS)(PDev*, ULONG, DWORD, RECTL*);
typedef VOID (GFNRSTS)(PDev*);

typedef struct _P2DMA P2DMA;
typedef struct tagP2CtxtRec *P2CtxtPtr;
typedef struct _hw_data *HwDataPtr;

// Four byte tag used for tracking memory allocations on a per source
// file basis. (characters are in reverse order). Note if you add any
// new files which call ENGALLOCMEM remember to update this list. This also
// applies if you want to make the allocation tagging more granular than
// file level.

#define ALLOC_TAG_3D2P '3d2p'  // Allocations from d3d.c
#define ALLOC_TAG_6D2P '6d2p'  // Allocations from d3ddx6.c 
#define ALLOC_TAG_SD2P 'sd2p'  // Allocations from d3dstate.c
#define ALLOC_TAG_TD2P 'td2p'  // Allocations from d3dtxman.c
#define ALLOC_TAG_US2P 'us2p'  // Allocations from ddsurf.c
#define ALLOC_TAG_ED2P 'ed2p'  // Allocations from debug.c
#define ALLOC_TAG_NE2P 'ne2p'  // Allocations from enable.c
#define ALLOC_TAG_IF2P 'if2p'  // Allocations from fillpath.c
#define ALLOC_TAG_EH2P 'eh2p'  // Alloactions from heap.c
#define ALLOC_TAG_WH2P 'wh2p'  // Allocations from hwinit.c
#define ALLOC_TAG_XC2P 'xc2p'  // Allocations from p2ctxt.c
#define ALLOC_TAG_AP2P 'ap2p'  // Allocations from palette.c
#define ALLOC_TAG_EP2P 'ep2p'  // Allocations from permedia.c
#define ALLOC_TAG_XT2P 'xt2p'  // Allocations from textout.c


//
// Miscellaneous shared stuff
//
#define DLL_NAME                L"perm2dll" // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "PERM2DLL: "// All debug output is prefixed
                                            // by this string

#define DRIVER_EXTRA_SIZE       0   // Size of the DriverExtra information in
                                    // the DEVMODE structure
#define TMP_BUFFER_SIZE        8192 // Size in bytes of 'pvTmpBuffer'.
                                    // Has to be at least enough to store an
                                    // entire scan line (i.e., 6400 for
                                    // 1600x1200x32).

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


#define INPUT_BUFFER_SIZE (1024 * 64)   // Size in bytes

//@@BEGIN_DDKSPLIT

#define MULTITHREADED   0
#define MT_LOG_LEVEL    6

#if MULTITHREADED && DBG
#define ASSERTLOCK(xppdev, func)                                    \
    {                                                               \
        EngAcquireSemaphore((xppdev)->hsemLock);                      \
        if ((xppdev)->ulLockCount < 1)                                  \
        {                                                           \
            DebugPrint(-1000, __FILE__ ":%d:" #func ": bad lock count", __LINE__); \
            EngDebugBreak();                                        \
        }                                                           \
        EngReleaseSemaphore((xppdev)->hsemLock);                      \
    }                                                       
#else
#define ASSERTLOCK(xppdev, func)
#endif
//@@END_DDKSPLIT

//
// Status flags
//
typedef enum
{
    // STAT_* indicates that the resource actually exists
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
    STAT_DEV_BITMAPS        = 0x0004,   // Device Bitmaps are allowed

    // ENABLE_* indicates whether resource is currently available
    ENABLE_BRUSH_CACHE      = 0x0020,   // Brush cache disabled
    ENABLE_DEV_BITMAPS      = 0x0040,   // Device Bitmaps disabled

} /*STATUS*/;
typedef int Status;

//
// The Physical Device data structure
//
typedef struct  _PDev
{
    BYTE*       pjScreen;           // Points to base screen address
    ULONG       iBitmapFormat;      // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                    //   (our current colour depth)
    CAPS        flCaps;             // Capabilities flags
    Status      flStatus;           // Status flags
    BOOL        bEnabled;           // In graphics mode (not full-screen)

    HANDLE      hDriver;            // Handle to \Device\Screen
    HDEV        hdevEng;            // Engine's handle to PDev
    HSURF       hsurfScreen;        // Engine's handle to screen surface
    Surf*       pdsurfScreen;       // Our private DSURF for the screen
    Surf*       pdsurfOffScreen;    // Our private DSURF for the back buffer

    LONG        cxScreen;           // Visible screen width
    LONG        cyScreen;           // Visible screen height
    LONG        cxMemory;           // Width of Video RAM
    LONG        cyMemory;           // Height of Video RAM
    ULONG       ulMode;             // Mode the mini-port driver is in.
    LONG        lDelta;             // Distance from one scan to the next.

    FLONG       flHooks;            // What we're hooking from GDI

    LONG        cjPelSize;          // 4/2/1 for 32/16/8 bpp
    LONG        cPelSize;           // 2/1/0 for 32/16/8 bpp
    DWORD       bPixShift;          // 2/1/0 for 32/16/8 bpp
    DWORD       bBppShift;          // 0/1/2 for 32/16/8 bpp
    DWORD       dwBppMask;          // 0/1/3 for 32/16/8 bpp

    ULONG       ulWhite;            // 0xff if 8bpp, 0xffff if 16bpp,
                                    // 0xffffffff if 32bpp
    ULONG*      pulCtrlBase[2];     // Mapped control registers for this PDEV
                                    // 2 entries to support Dual-TX
    ULONG*      pulDenseCtrlBase;   // Dense mapping for direct draw
    ULONG*      pulRamdacBase;      // Mapped control registers for the RAMDAC
    VOID*       pvTmpBuffer;        // General purpose temporary buffer,
                                    // TMP_BUFFER_SIZE bytes in size
                                    // (Remember to synchronize if you use this
                                    // for device bitmaps or async pointers)
    LONG        lVidMemHeight;      // Height of Video RAM available to
                                    // DirectDraw heap (cyScreen <= cyHeap
                                    // <= cyMemory), including primary surface
    LONG        lVidMemWidth;       // Width, in pixel, of Video RAM available
                                    // to DDraw heap, including primary surface
    LONG        cBitsPerPel;        // Bits per pel (8, 15, 16, 24 or 32)
    UCHAR*      pjIoBase;           // Mapped IO port base for this PDEV
    
    ULONG       ulPermFormat;       // permedia format type of primary
    ULONG       ulPermFormatEx;     // permedia extended format bit of primary
    
    DWORD       dwAccelLevel;       // Acceleration level setting
    POINTL      ptlOrigin;          // Origin of desktop in multi-mon dev space

    //
    // Palette stuff:
    //
    PALETTEENTRY* pPal;             // The palette if palette managed
    HPALETTE    hpalDefault;        // GDI handle to the default palette.
    FLONG       flRed;              // Red mask for 16/32bpp bitfields
    FLONG       flGreen;            // Green mask for 16/32bpp bitfields
    FLONG       flBlue;             // Blue mask for 16/32bpp bitfields

    //
    // Heap stuff for DDRAW managed off-screen memory
    //
    VIDEOMEMORY* pvmList;           // Points to the video-memory heap list
                                    //   as supplied by DirectDraw, needed
                                    //   for heap allocations
    ULONG       cHeaps;             // Count of video-memory heaps
    ULONG       iHeapUniq;          // Incremented every time room is freed
                                    //   in the off-screen heap

    Surf*       psurfListHead;      // Dbl Linked list of discardable bitmaps,
    Surf*       psurfListTail;      //   in order of oldest to newest

    //
    // Pointer stuff
    //

    LONG        xPointerHot;        // xHot of current hardware pointer
    LONG        yPointerHot;        // yHot of current hardware pointer

    ULONG       ulHwGraphicsCursorModeRegister_45;
                                    // Default value for index 45
    PtrFlags    flPointer;          // Pointer state flags
    VOID*       pvPointerData;      // Points to ajPointerData[0]
    BYTE        ajPointerData[POINTER_DATA_SIZE];
                                    // Private work area for downloaded
                                    //   miniport pointer code

    BOOL        bPointerInitialized;// Flag to indicate if HW pointer has been
                                    // initizlized
    
    // Brush stuff:
    
    BOOL        bRealizeTransparent;// Hint to DrvRealizeBrush for whether
                                    // the brush should be realized as
                                    // transparent or not
    LONG        cPatterns;          // Count of bitmap patterns created
    LONG        lNextCachedBrush;   // Index for next brush to be allocated
    LONG        cBrushCache;        // Total number of brushes cached
    BrushEntry  abeMono;            // Keeps track of area stipple brush
    BrushEntry  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    HBITMAP     ahbmPat[HS_DDI_MAX];// Engine handles to standard patterns

    ULONG       ulBrushPackedPP;    // Stride of brush as partial products
    VIDEOMEMORY*pvmBrushHeap;       // Heap from which brush cached was alloced
    ULONG       ulBrushVidMem;      // Poitner to start of brush cache
    
    // Hardware pointer cache stuff:

    HWPointerCache  HWPtrCache;     // The cache data structure itself
    LONG        HWPtrLastCursor;    // The index of the last cursor that we drew
    LONG        HWPtrPos_X;         // The last X position of the cursor
    LONG        HWPtrPos_Y;         // The last Y position of the cursor

    HwDataPtr   permediaInfo;       // info about the interface to permedia2

    LONG        FrameBufferLength;  // Length of framebuffer in bytes

    // rendering routines

    GFN*        pgfnAlphaBlend;
    GFN*        pgfnConstantAlphaBlend;
    GFN*        pgfnCopyBlt;
    GFN*        pgfnCopyBltWithRop;
    GFN*        pgfnGradientFillTri;
    GFN*        pgfnGradientFillRect;
    GFN*        pgfnMonoOffset;
    GFN*        pgfnMonoPatFill;
    GFN*        pgfnPatFill;
    GFN*        pgfnPatRealize;
    GFN*        pgfnSolidFill;
    GFN*        pgfnSolidFillWithRop;
    GFN*        pgfnSourceFillRect;
    GFN*        pgfnTransparentBlt;
    GFN*        pgfnXferImage;
    GFN*        pgfnInvert;


    // support for DrvStroke
    // TODO: remove use of this implicit parameter passing
    Surf*       psurf;     //  this is an implicit parameter passed to various
                           //  calls ... this needs to be removed.

    // Direct draw stuff

    P2CtxtPtr   pDDContext;            // DDRAW context

    // Virtual address of start of screen
    UINT_PTR    dwScreenStart;

    // DDraw/D3D DMA shared memory block
    P2DMA      *pP2dma;

    // Current pixel format of display
    DDPIXELFORMAT   ddpfDisplay;

    // Some P2 specific information
    DWORD       dwChipConfig;           // image of P2 chip configuration        
                                        // some virtual addresses of the P2 
                                        // registers
    ULONG      *pCtrlBase;              //  
    ULONG      *pCoreBase;              //
    ULONG      *pGPFifo;                //

    // DirectDraw callbacks
    DDHAL_DDCALLBACKS           DDHALCallbacks;
    DDHAL_DDSURFACECALLBACKS    DDSurfCallbacks;

    DWORD dwNewDDSurfaceOffset;

    BOOL        bDdExclusiveMode;       // TRUE if DDraw is in ExclusiveMode
    BOOL        bDdStereoMode;          // TRUE if flip has switched us 
                                        // to stereo mode
    BOOL        bCanDoStereo;           // This mode can do stereo

    // These have to live here, as we could be running on 2 different cards
    // on two different displays...!
    UINT_PTR pD3DDriverData32;
    UINT_PTR pD3DHALCallbacks32;
    
    // Linear allocator defines
    UINT_PTR       dwGARTLin;       // Linear address of Base of AGP Memory
    UINT_PTR       dwGARTDev;       // High Linear address of Base of AGP Memory
    UINT_PTR       dwGARTLinBase;   // The Linear base address passed into
                                    // UpdateNonLocalVidMem 
    UINT_PTR       dwGARTDevBase;   // The High Linear base address passed into
                                    // UpdateNonLocalVidMem

    // HAL info structure.
    DDHALINFO   ddhi32;

    PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand;

    // New Input FIFO cached information

    PULONG          pulInFifoPtr;
    PULONG          pulInFifoStart;
    PULONG          pulInFifoEnd;
    
    ULONG*          dmaBufferVirtualAddress;
    LARGE_INTEGER   dmaBufferPhysicalAddress;
    ULONG           dmaCurrentBufferOffset;
    ULONG           dmaActiveBufferOffset;

    ULONG*          pulInputDmaCount;
    ULONG*          pulInputDmaAddress;
    ULONG*          pulFifo;
    ULONG*          pulOutputFifoCount;
    ULONG*          pulInputFifoCount;

    BOOL            bGdiContext;

    BOOL            bNeedSync;
    BOOL            bForceSwap;

#if DBG
    ULONG           ulReserved;
#endif

    //
    // On NT4.0 The psoScreen is the locked screen Surf we EngLockSurface
    // on to in DrvEnableSurface which we EngUnlockSurface in
    // DrvDisableSurface. On NT5.0 this should be NULL.
    //
    SURFOBJ     *psoScreen;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    HSEMAPHORE      hsemLock;
    ULONG           ulLockCount;
#endif
//@@END_DDKSPLIT

} PDev, *PPDev;


/*****************************************************************************\
*                                                                             *
* NT 5.0  -> NT 4.0 single binary support:                                    *
*                                                                             *
\*****************************************************************************/

// Are we running on NT40 system

extern BOOL g_bOnNT40;

// Function to load thunks for new NT5.0 functionality. Called in
// DrvEnableDriver and implemented in thunks.c

extern BOOL bEnableThunks();
 

#endif // __DRIVER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\fastfill.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: fastfill.c
 *
 * Draws fast solid-coloured, unclipped, non-complex rectangles.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"

//-----------------------------------------------------------------------------
//
// BOOL bFillPolygon()
//
// Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
// having only two edges that are monotonic increasing in 'y'. That is,
// the polygon cannot have more than one disconnected segment on any given
// scan. Note that the edges of the polygon can self-intersect, so hourglass
// shapes are permissible. This restriction permits this routine to run two
// simultaneous DDAs(Digital Differential Analyzer), and no sorting of the
// edges is required.
//
// Note that NT's fill convention is different from that of Win 3.1 or 4.0.
// With the additional complication of fractional end-points, our convention
// is the same as in 'X-Windows'.
//
// This routine handles patterns only when the Permedia2 area stipple can be
// used.  The reason for this is that once the stipple initialization is
// done, pattern fills appear to the programmer exactly the same as solid
// fills (with the slight difference of an extra bit in the render command).
//
// We break each polygon down to a sequenze of screen aligned trapeziods, which
// the Permedia2 can handle.
//
// Optimisation list follows ....
//
// This routine is in no way the ultimate convex polygon drawing routine
// Some obvious things that would make it faster:
//
//    1) Write it in Assembler
//
//    2) Make the non-complex polygon detection faster.  If I could have
//       modified memory before the start of after the end of the buffer,
//       I could have simplified the detection code.  But since I expect
//       this buffer to come from GDI, I can't do that.  Another thing
//       would be to have GDI give a flag on calls that are guaranteed
//       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
//       the buffer would still have to be scanned to find the top-most
//       point.
//
//    3) Implement support for a single sub-path that spans multiple
//       path data records, so that we don't have to copy all the points
//       to a single buffer like we do in 'fillpath.c'.
//
//    4) Use 'ebp' and/or 'esp' as a general register in the inner loops
//       of the Asm loops, and also Pentium-optimize the code.  It's safe
//       to use 'esp' on NT because it's guaranteed that no interrupts
//       will be taken in our thread context, and nobody else looks at the
//       stack pointer from our context.
//
//    5) When we get to a part of the polygon where both vertices are of 
//       equal height, the algorithm essentially starts the polygon again.
//       Using the Permedia2 Continue message could speed things up in certain
//       cases.
//       
// Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
//
// Note: the point data (POINTFX) GDI passed to us in 28.4 format. Permedia 2
//       hardware uses 12.15 format. So most of the time, we need to do a
//       x = (x + 15) >> 4 to bring it back to normal interger format and then
//       convert it to 12.15 format when we set the register value
//
// Parameters:
//  ppdev-------Pointer to PDev
//  pSurfDst----Destination surface
//  lEdges------Number of edges, includes close figure edge
//  pptfxFirst--Pointer to the first point in the data buffer. There are total
//              "lEdges" points
//  iSolidColor-Solid color fill
//  ulRop4------ROP4
//  pco---------Clip Object. 
//  prb---------Realized brush
//  pptlBrush---Pattern alignment    
//
//-----------------------------------------------------------------------------
BOOL
bFillPolygon(PDev*      ppdev,
             Surf*      pSurfDst,
             LONG       lEdges,
             POINTFIX*  pptfxFirst,
             ULONG      ulSolidColor,
             ULONG      ulRop4,
             CLIPOBJ*   pco,
             RBrush*    prb,
             POINTL*    pptlBrush)
{
    POINTFIX*   pptfxLast;      // Points to the last point in the polygon
                                // array
    POINTFIX*   pptfxTop;       // Points to the top-most point in the polygon
    POINTFIX*   pptfxScan;      // Current edge pointer for finding pptfxTop
    POINTFIX*   aPtrFixTop[2];  // DDA terms and stuff
    POINTFIX*   aPtrFixNext[2]; // DDA terms and stuff
    
    BOOL        bRC = FALSE;    // Return code for this function
    BOOL        bSingleColor;   // Only one color pass
    BOOL        bTrivialClip;   // Trivial Clip or not
    
    ClipEnum*   pClipRegion = (ClipEnum*)(ppdev->pvTmpBuffer);
                                // Buffer for storing clipping region
    DWORD       dwAsMode[2];    // The area stipple mode and the color for that
                                // pass
    DWORD       dwColorMode;    // Current color mode
    DWORD       dwColorReg;     // Current color register mode
    DWORD       dwLogicMode;    // Current logic op mode
    DWORD       dwReadMode;     // Current register read mode
    DWORD       dwRenderBits;   // Current render bits
    
    LONG        lCount;         // Number of scan lines to render
    LONG        alDX[2];         // 
    LONG        alDY[2];
    LONG        lNumOfPass;     // Number of passes required to render
    LONG        lScanEdges;     // Number of edges scanned to find pptfxTop
                                // (doesn't include the closefigure edge)
    
    LONG        alDxDy[2];
    
    RECTL*      pClipList;      // List of clip rects
    
    ULONG       ulBgColor;      // Background color
    ULONG       ulBgLogicOp = ulRop3ToLogicop(ulRop4 >> 8);
    ULONG       ulBrushColor = ulSolidColor;
                                // Current fill color
    ULONG       ulColor[2];     // On multiple color passes we need to know how
                                // to set up
    ULONG       ulFgColor;      // Foreground color
    ULONG       ulFgLogicOp = ulRop3ToLogicop(ulRop4 & 0xFF);
    ULONG       ulOrX;          // We do logic OR for all values to eliminate
    ULONG       ulOrY;          // complex polygons

    GFNPB       pb;             // Functional block for lower level function

    ULONG*      pBuffer;

    PERMEDIA_DECL;
    

    pb.ppdev = ppdev;

    DBG_GDI((6, "bFillPolygon called, rop4 = %x, fg ulFgLogicOp =%d, bg = %d",
             ulRop4, ulFgLogicOp, ulBgLogicOp));
    ASSERTDD(lEdges > 1, "Polygon with less than 2 edges");

    //
    // See if the polygon is 'non-complex'
    // Assume for now that the first point in path is the top-most
    //
    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;
    pptfxLast = pptfxFirst + lEdges - 1;
    
    //
    // Initialize our logic OR op counters
    //
    ulOrX = pptfxScan->x;
    ulOrY = pptfxScan->y;

    //
    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'lScanEdges' will be the number of edges remaining, including
    // the current one, but not counting close figure
    //
    lScanEdges = lEdges - 1;

    //
    // First phase: Velidate input point data to see if we can handle it or not
    //
    // Check if the 2nd edge point is lower than current edge point
    //
    // Note: the (0,0) is at the up-left corner in this coordinate system
    // So the bigger the Y value, the lower the point
    //
    if ( (pptfxScan + 1)->y > pptfxScan->y )
    {
        //
        // The edge goes down, that is, the 2nd point is lower than the 1st
        // point. Collect all downs: that is, collect all the X and Y until
        // the edge goes up
        //
        do
        {
            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;

            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y >= pptfxScan->y );

        //
        // From this point, the edge goes up, that is, the next point is higher
        // than current point
        // Collect all ups: Collect all the X and Y until the edge goes down
        //
        do
        {
            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFillingCheck;
            }
        } while ( (pptfxScan + 1)->y <= pptfxScan->y );

        //
        // Reset pptfxTop to the current point which is at top again compare
        // with the next point
        // Collect all downs:
        //
        pptfxTop = pptfxScan;

        do
        {
            //
            // If the next edge point is lower than the 1st point, stop
            //
            if ( (pptfxScan + 1)->y > pptfxFirst->y )
            {
                break;
            }

            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;

            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y >= pptfxScan->y );

        //
        // If we fallen here, it means we are given down-up-down polygon.
        // We can't handle it and return FALSE to let GDI do it.
        //
        DBG_GDI((7, "Reject: can't fill down-up-down polygon"));

        goto ReturnBack;
    }// if ( (pptfxScan + 1)->y>pptfxScan->y ), 2nd point is lower than 1st one
    else
    {
        //
        // The edge goes up, that is, the 2nd point is higher than the 1st
        // point. Collect all ups: that is, collect all the X and Y until
        // the edge goes down.
        // Note: we keeps changing the value of "pptfxTop" so that after
        // this "while" loop, "pptfxTop" points to the TOPEST point
        //
        do
        {
            ulOrY |= (++pptfxTop)->y;    // We increment this now because we
            ulOrX |= pptfxTop->x;        //  want it to point to the very last
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxTop + 1)->y <= pptfxTop->y );

        //
        // Form this point, the edge goes down, that is, the next point is
        // lower than current point. Collect all downs: that is, collect all
        // the X and Y until the edge goes up
        // Note: here we keep changing "pptfxScan" so that after this loop,
        // "pptfxScan" points to the current scan line, which also is the
        // lowest point
        //
        pptfxScan = pptfxTop;
        
        do
        {
            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y >= pptfxScan->y );

        //
        // Up to this point, the edge is about to go up again.
        // Collect all ups:
        //
        do
        {
            //
            // If the edge going down again, just qute because we can't
            // fill up-down-up polygon
            // 
            if ( (pptfxScan + 1)->y < pptfxFirst->y )
            {
                break;
            }

            ulOrY |= (++pptfxScan)->y;
            ulOrX |= pptfxScan->x;
            
            //
            // If no more edge left, we are done
            //
            if ( --lScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while ( (pptfxScan + 1)->y <= pptfxScan->y );

        //
        // If we fallen here, it means we are given up-down-up polygon.
        // We can't handle it and return FALSE to let GDI do it.
        //
        DBG_GDI((7, "Reject: Can't fill up-down-up polygon"));
        
        goto ReturnBack;
    }// if (pptfxScan + 1)->y<=pptfxScan->y), 2nd point is higher than 1st one
    
    //
    // Phase 2: Now we have validated the input point and think we can fill it
    //
SetUpForFillingCheck:
    
    //
    // We check to see if the end of the current edge is higher than the top
    // edge we've found so far. If yes, then let pptfxTop point to the end of
    // current edge which is the highest.
    // 
    //
    if ( pptfxScan->y < pptfxTop->y )
    {
        pptfxTop = pptfxScan;
    }

SetUpForFilling:
    
    //
    // Can only use block fills for trivial clip so work it out here
    //
    bTrivialClip = (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL);

    if ( (ulOrY & 0xffffc00f) || (ulOrX & 0xffff8000) )
    {
        ULONG   ulNeg;
        ULONG   ulPosX;
        ULONG   ulPosY;

        //
        // Fractional Y must be done as spans
        //
        if ( ulOrY & 0xf )
        {
            bRC = bFillSpans(ppdev, pSurfDst, lEdges, pptfxFirst,
                             pptfxTop, pptfxLast,
                             ulSolidColor, ulRop4, pco, prb, pptlBrush);
            goto ReturnBack;
        }

        //
        // Run through all the vertices and check that none of them
        // have a negative component less than -256.
        //
        ulNeg = 0;
        ulPosX = 0;
        ulPosY = 0;

        for ( pptfxScan = pptfxFirst; pptfxScan <= pptfxLast; ++pptfxScan )
        {
            if ( pptfxScan->x < 0 )
            {
                ulNeg |= -pptfxScan->x;
            }
            else
            {
                ulPosX |= pptfxScan->x;
            }

            if ( pptfxScan->y < 0 )
            {
                ulNeg |= -pptfxScan->y;
            }
            else
            {
                ulPosY |= pptfxScan->y;
            }
        }

        //
        // We don't want to handle any polygon with a negative vertex
        // at <= -256 in either coordinate.
        //
        if ( ulNeg & 0xfffff000 )
        {
            DBG_GDI((1, "Coords out of range for fast fill"));
            goto ReturnBack;
        }

        if ( (ulPosX > 2047) || (ulPosY > 1023) )
        {
            DBG_GDI((1, "Coords out of range for Permedia2 fast fill"));
            goto ReturnBack;
        }
    }// if ( (ulOrY & 0xffffc00f) || (ulOrX & 0xffff8000) )

    //
    // Now we are ready to fill
    //

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  pSurfDst->ulPixOffset;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "bFillPolygon: Polygon is renderable. Go ahead and render"));

    if ( ulFgLogicOp == K_LOGICOP_COPY )
    {
        dwColorMode = __PERMEDIA_DISABLE;
        dwLogicMode = __PERMEDIA_CONSTANT_FB_WRITE;
        dwReadMode  = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                  | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

        //
        // Check to see if it is a non-solid fill brush fill
        //
        if ( (ulBrushColor == 0xffffffff)
           ||(!bTrivialClip) )
        {
            //
            // Non-solid brush, not too much we can do
            //
            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
            dwColorReg   = __Permedia2TagFBWriteData;
        }// Non-solid brush
        else
        {
            //
            // For solid brush, We can use fast fills, so load the fb block
            // color register.
            //
            dwColorReg = __Permedia2TagFBBlockColor;
            dwRenderBits = __RENDER_FAST_FILL_ENABLE
                       | __RENDER_TRAPEZOID_PRIMITIVE;

            //
            // Setup color data based on current color mode we are in
            //
            if ( ppdev->cPelSize == 1 )
            {
                //
                // We are in 16 bit packed mode. So the color data must be
                // repeated in both halves of the FBBlockColor register
                //
                ASSERTDD((ulSolidColor & 0xFFFF0000) == 0,
                         "bFillPolygon: upper bits are not zero");
                ulSolidColor |= (ulSolidColor << 16);
            }
            else if ( ppdev->cPelSize == 0 )
            {
                //
                // We are in 8 bit packed mode. So the color data must be
                // repeated in all 4 bytes of the FBBlockColor register
                //
                ASSERTDD((ulSolidColor & 0xFFFFFF00) == 0,
                         "bFillPolygon: upper bits are not zero");
                ulSolidColor |= ulSolidColor << 8;
                ulSolidColor |= ulSolidColor << 16;
            }

            //
            // Ensure that the last access was a write before loading
            // BlockColor
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = __Permedia2TagFBBlockColor;
            pBuffer[1] =  ulSolidColor;
            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);

        }// Solid brush case
    }// LOGICOP_COPY
    else
    {
        dwColorReg = __Permedia2TagConstantColor;
        dwColorMode = __COLOR_DDA_FLAT_SHADE;
        dwLogicMode = P2_ENABLED_LOGICALOP(ulFgLogicOp);
        dwReadMode = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                   | LogicopReadDest[ulFgLogicOp];
        dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
    }// Non-COPY LogicOP

    //
    // Determine how many passes we need to draw all the clip rects
    //
    if ( bTrivialClip )
    {
        //
        // Just draw, no clipping to perform.
        //
        pClipList = NULL;                       // Indicate no clip list
        lNumOfPass = 1;
    }
    else
    {
        if ( pco->iDComplexity == DC_RECT )
        {
            //
            // For DC_RECT, we can do it in one pass
            //
            lNumOfPass = 1;
            pClipList = &pco->rclBounds;
        }
        else
        {
            //
            // It may be slow to render the entire polygon for each clip rect,
            // especially if the object is very complex. An arbitary limit of
            // up to CLIP_LIMIT regions will be rendered by this function.
            // Return false if more than CLIP_LIMIT regions.
            //
            lNumOfPass = CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY,
                                      CLIP_LIMIT);
            if ( lNumOfPass == -1 )
            {
                goto ReturnBack; // More than CLIP_LIMIT.
            }

            //
            // Put the regions into our clip buffer
            //
            if ( (CLIPOBJ_bEnum(pco, sizeof(ClipEnum), (ULONG*)pClipRegion))
               ||(pClipRegion->c != lNumOfPass) )
            {
                DBG_GDI((7, "CLIPOBJ_bEnum inconsistency. %d = %d",
                         pClipRegion->c, lNumOfPass));
            }

            pClipList = &(pClipRegion->arcl[0]);
        }// Non-DC_RECT case

        //
        // For non-trivial clipping, we can use SCISSOR to implement it
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] =  SCREEN_SCISSOR_DEFAULT  | USER_SCISSOR_ENABLE;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }// Non-trivial clipping

    bSingleColor = TRUE;
    if ( ulBrushColor != 0xFFFFFFFF )
    {
        //
        // Solid brush case, just set the color register as the color
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = dwColorReg;
        pBuffer[1] = ulSolidColor;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }// Solid brush case
    else
    {
        //
        // For non-solid brush, we need to realize brush first
        //
        BrushEntry* pbe;

        //
        // Turn on the area stipple.
        //
        dwRenderBits |= __RENDER_AREA_STIPPLE_ENABLE;

        //
        // If anything has changed with the brush we must re-realize it. If the
        // brush has been kicked out of the area stipple unit we must fully
        // realize it. If only the alignment has changed we can simply update
        // the alignment for the stipple.
        //
        pbe = prb->pbe;
        
        pb.prbrush = prb;
        pb.pptlBrush = pptlBrush;
        
        if ( (pbe == NULL) || (pbe->prbVerify != prb) )
        {
            DBG_GDI((7, "full brush realize"));
            vPatRealize(&pb);
        }
        else if ( (prb->ptlBrushOrg.x != pptlBrush->x)
                ||(prb->ptlBrushOrg.y != pptlBrush->y) )
        {
            DBG_GDI((7, "changing brush offset"));
            vMonoOffset(&pb);
        }

        ulFgColor = prb->ulForeColor;
        ulBgColor = prb->ulBackColor;

        if (  (ulBgLogicOp == K_LOGICOP_NOOP)
            ||((ulFgLogicOp == K_LOGICOP_XOR) && (ulBgColor == 0)) )
        {
            //
            // Either we have a transparent bitmap or it can be assumed to be
            // transparent (XOR with bg=0) 
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulFgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] =  prb->areaStippleMode;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }// Transparent bitmap
        else if ( (ulFgLogicOp == K_LOGICOP_XOR) && (ulFgColor == 0) )
        {
            //
            // We have a transparent foreground! (XOR with fg=0) 
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulBgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] = prb->areaStippleMode  | AREA_STIPPLE_INVERT_PAT;
            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }// Transparent foreground
        else
        {
            //
            // Not using a transparent pattern
            //
            bSingleColor = FALSE;
            ulColor[0] = ulFgColor;
            ulColor[1] = ulBgColor;
            dwAsMode[0] = prb->areaStippleMode;
            dwAsMode[1] = dwAsMode[0] | AREA_STIPPLE_INVERT_PAT;

            //
            // Double the number of passes, one for fg one for bg
            //
            lNumOfPass <<= 1;
        }// No transparent
    }// if ( ulBrushColor == 0xFFFFFFFF ), non-solid brush

    InputBufferReserve(ppdev, 6, &pBuffer);

    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] =  dwColorMode;
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] =  dwReadMode;
    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] =  dwLogicMode;

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "Rendering Polygon in %d passes. with %s",
             lNumOfPass, bSingleColor ? "Single Color" : "Two Color"));

    lNumOfPass--;
    
    while ( 1 )
    {
        //
        // Per pass initialization
        //
        if ( bSingleColor )
        {
            //
            // Need to set up clip rect each pass
            //
            if ( pClipList )
            {
                InputBufferReserve(ppdev, 4, &pBuffer);

                pBuffer[0] = __Permedia2TagScissorMinXY;
                pBuffer[1] = ((pClipList->left)<< SCISSOR_XOFFSET)
                           | ((pClipList->top)<< SCISSOR_YOFFSET);
                pBuffer[2] = __Permedia2TagScissorMaxXY;
                pBuffer[3] = ((pClipList->right)<< SCISSOR_XOFFSET)
                           | ((pClipList->bottom)<< SCISSOR_YOFFSET);

                pBuffer += 4;

                InputBufferCommit(ppdev, pBuffer);
                pClipList++;
            }
        }// Single color
        else
        {
            //
            // Need to set up clip rect every other pass and change color and
            // inversion mode every pass
            //
            if ( (pClipList) && (lNumOfPass & 1) )
            {
                InputBufferReserve(ppdev, 4, &pBuffer);

                pBuffer[0] = __Permedia2TagScissorMinXY;
                pBuffer[1] = ((pClipList->left)<< SCISSOR_XOFFSET)
                           | ((pClipList->top)<< SCISSOR_YOFFSET);
                pBuffer[2] = __Permedia2TagScissorMaxXY;
                pBuffer[3] = ((pClipList->right)<< SCISSOR_XOFFSET)
                           | ((pClipList->bottom)<< SCISSOR_YOFFSET);
                
                pBuffer += 4;

                InputBufferCommit(ppdev, pBuffer);

                pClipList++;
            }

            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulColor[lNumOfPass & 1];
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] =  dwAsMode[lNumOfPass & 1];

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }// Non-single color mode

        //
        // Initialize left and right points (current) to top point.
        //
        aPtrFixNext[LEFT]  = pptfxTop;
        aPtrFixNext[RIGHT] = pptfxTop;

        while ( 1 )
        {
            //
            // aPtrFixNext[] is always the valid point to draw from
            //
            do
            {
                aPtrFixTop[LEFT] = aPtrFixNext[LEFT];
                aPtrFixNext[LEFT] = aPtrFixTop[LEFT] - 1;

                if ( aPtrFixNext[LEFT] < pptfxFirst )
                {
                    aPtrFixNext[LEFT] = pptfxLast;
                }

                //
                // Special case of flat based polygon, need to break now as
                // polygon is finished
                //
                if ( aPtrFixNext[LEFT] == aPtrFixNext[RIGHT] )
                {
                    goto FinishedPolygon;
                }

                DBG_GDI((7, "LEFT: aPtrFixTop %x aPtrFixNext %x",
                         aPtrFixTop[LEFT], aPtrFixNext[LEFT]));
                DBG_GDI((7, "FIRST %x LAST %x",
                         pptfxFirst, pptfxLast));
                DBG_GDI((7, "X %x Y %x Next: X %x Y %x",
                         aPtrFixTop[LEFT]->x, aPtrFixTop[LEFT]->y,
                         aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y));
            } while ( aPtrFixTop[LEFT]->y == aPtrFixNext[LEFT]->y );

            do
            {
                aPtrFixTop[RIGHT] = aPtrFixNext[RIGHT];
                aPtrFixNext[RIGHT] = aPtrFixTop[RIGHT] + 1;     

                if ( aPtrFixNext[RIGHT] > pptfxLast )
                {
                    aPtrFixNext[RIGHT] = pptfxFirst;
                }

                DBG_GDI((7, "RIGHT: aPtrFixTop %x aPtrFixNext %x FIRST %x",
                         aPtrFixTop[RIGHT], aPtrFixNext[RIGHT], pptfxFirst));
                DBG_GDI((7, " LAST %x X %x Y %x Next: X %x Y %x",
                         pptfxLast, aPtrFixTop[RIGHT]->x, aPtrFixTop[RIGHT]->y,
                         aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));
            } while ( aPtrFixTop[RIGHT]->y == aPtrFixNext[RIGHT]->y );

            //
            // Start up new rectangle. Whenever we get to this code, both
            // points should have equal y values, and need to be restarted.
            // Note: To get correct results, we need to add on nearly one to
            // each X coordinate.
            //
            DBG_GDI((7, "New: Top: x: %x y: %x x: %x y: %x",
                     aPtrFixTop[LEFT]->x, aPtrFixTop[LEFT]->y,
                     aPtrFixTop[RIGHT]->x, aPtrFixTop[RIGHT]->y));
            DBG_GDI((7, " Next: x: %x y: %x x: %x y: %x",
                     aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y,
                     aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));

            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  FIXtoFIXED(aPtrFixTop[LEFT]->x) + NEARLY_ONE;
            pBuffer[2] = __Permedia2TagStartXSub;
            pBuffer[3] =  FIXtoFIXED(aPtrFixTop[RIGHT]->x)+ NEARLY_ONE;
            pBuffer[4] = __Permedia2TagStartY;
            pBuffer[5] =  FIXtoFIXED(aPtrFixTop[RIGHT]->y);

            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);

            //
            // We have 2 15.4 coordinates. We need to divide them and change
            // them into a 15.16 coordinate. We know the y coordinate is not
            // fractional, so we do not loose precision by shifting right by 4
            //
            alDX[LEFT] = (aPtrFixNext[LEFT]->x - aPtrFixTop[LEFT]->x) << 12;
            alDY[LEFT] = (aPtrFixNext[LEFT]->y - aPtrFixTop[LEFT]->y) >> 4;

            //
            // Need to ensure we round delta down. divide rounds towards zero
            //
            if ( alDX[LEFT] < 0 )
            {
                alDX[LEFT] -= alDY[LEFT] - 1;
            }

            alDxDy[LEFT] = alDX[LEFT] / alDY[LEFT];

            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagdXDom;
            pBuffer[1] =  alDxDy[LEFT];

            alDX[RIGHT] = (aPtrFixNext[RIGHT]->x - aPtrFixTop[RIGHT]->x) << 12;
            alDY[RIGHT] = (aPtrFixNext[RIGHT]->y - aPtrFixTop[RIGHT]->y) >> 4;

            //
            // Need to ensure we round delta down. divide rounds towards zero
            //
            if ( alDX[RIGHT] < 0 )
            {
                alDX[RIGHT] -= alDY[RIGHT] - 1;
            }

            alDxDy[RIGHT] = alDX[RIGHT] / alDY[RIGHT];
            pBuffer[2] = __Permedia2TagdXSub;
            pBuffer[3] =  alDxDy[RIGHT];

            //
            // Work out number of scanlines to render
            //
            if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
            {
                lCount = alDY[LEFT];
            }
            else
            {
                lCount = alDY[RIGHT];
            }

            pBuffer[4] = __Permedia2TagCount;
            pBuffer[5] =  lCount;
            pBuffer[6] = __Permedia2TagRender;
            pBuffer[7] =  dwRenderBits;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            //
            // With lots of luck, top trapezoid should be drawn now!
            // Repeatedly draw more trapezoids until points are equal
            // If y values are equal, then we can start again from
            // scratch. 
            //
            while ( (aPtrFixNext[LEFT] != aPtrFixNext[RIGHT])
                  &&(aPtrFixNext[LEFT]->y != aPtrFixNext[RIGHT]->y) )
            {
                //
                // Some continues are required for next rectangle
                //
                if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
                {
                    //
                    // We have reached aPtrFixNext[LEFT]. aPtrFixNext[RIGHT]
                    // is still ok
                    //
                    do
                    {
                        aPtrFixTop[LEFT] = aPtrFixNext[LEFT];
                        aPtrFixNext[LEFT] = aPtrFixTop[LEFT] - 1;   

                        if ( aPtrFixNext[LEFT] < pptfxFirst )
                        {
                            aPtrFixNext[LEFT] = pptfxLast;
                        }
                    }  while ( aPtrFixTop[LEFT]->y == aPtrFixNext[LEFT]->y );

                    //
                    // We have a new aPtrFixNext[LEFT] now.
                    //
                    DBG_GDI((7, "Dom: Top: x: %x y: %x",
                             aPtrFixTop[LEFT]->x, aPtrFixTop[LEFT]->y));
                    DBG_GDI((7, "Next: x: %x y: %x x: %x y: %x",
                             aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y,
                             aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));

                    alDX[LEFT] = (aPtrFixNext[LEFT]->x
                               - aPtrFixTop[LEFT]->x) << 12;
                    alDY[LEFT] = (aPtrFixNext[LEFT]->y
                               - aPtrFixTop[LEFT]->y) >> 4;

                    //
                    // Need to ensure we round delta down. Divide rounds
                    // towards zero
                    //
                    if ( alDX[LEFT] < 0 )
                    {
                        alDX[LEFT] -= alDY[LEFT] - 1;
                    }

                    alDxDy[LEFT] = alDX[LEFT] / alDY[LEFT];

                    if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
                    {
                        lCount = alDY[LEFT];
                    }
                    else
                    {
                        lCount = (abs(aPtrFixNext[RIGHT]->y
                                      - aPtrFixTop[LEFT]->y)) >> 4;
                    }

                    InputBufferReserve(ppdev, 6, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXDom;
                    pBuffer[1] =  FIXtoFIXED(aPtrFixTop[LEFT]->x) + NEARLY_ONE;
                    pBuffer[2] = __Permedia2TagdXDom;
                    pBuffer[3] =  alDxDy[LEFT];
                    pBuffer[4] = __Permedia2TagContinueNewDom;
                    pBuffer[5] =  lCount;

                    pBuffer += 6;

                    InputBufferCommit(ppdev, pBuffer);

                }// if ( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
                else
                {
                    //
                    // We have reached aPtrFixNext[RIGHT]. aPtrFixNext[LEFT]
                    // is still ok
                    //
                    do
                    {
                        aPtrFixTop[RIGHT] = aPtrFixNext[RIGHT];
                        aPtrFixNext[RIGHT] = aPtrFixTop[RIGHT] + 1;     

                        if ( aPtrFixNext[RIGHT] > pptfxLast )
                        {
                            aPtrFixNext[RIGHT] = pptfxFirst;
                        }
                    } while ( aPtrFixTop[RIGHT]->y == aPtrFixNext[RIGHT]->y );

                    //
                    // We have a new aPtrFixNext[RIGHT] now.
                    //
                    DBG_GDI((7, "Sub: Top: x: %x y: %x",
                             aPtrFixTop[RIGHT]->x, aPtrFixTop[RIGHT]->y));
                    DBG_GDI((7, "Next: x: %x y: %x x: %x y: %x",
                             aPtrFixNext[LEFT]->x, aPtrFixNext[LEFT]->y,
                             aPtrFixNext[RIGHT]->x, aPtrFixNext[RIGHT]->y));

                    alDX[RIGHT] = (aPtrFixNext[RIGHT]->x
                                - aPtrFixTop[RIGHT]->x) << 12;
                    alDY[RIGHT] = (aPtrFixNext[RIGHT]->y
                                - aPtrFixTop[RIGHT]->y) >> 4;

                    //
                    // Need to ensure we round delta down. divide rounds
                    // towards zero
                    //
                    if ( alDX[RIGHT] < 0 )
                    {
                        alDX[RIGHT] -= alDY[RIGHT] - 1;
                    }
                    alDxDy[RIGHT] = alDX[RIGHT] / alDY[RIGHT];

                    if ( aPtrFixNext[RIGHT]->y < aPtrFixNext[LEFT]->y )
                    {
                        lCount = alDY[RIGHT];
                    }
                    else
                    {
                        lCount = (abs(aPtrFixNext[LEFT]->y
                                      - aPtrFixTop[RIGHT]->y)) >> 4;
                    }
                    InputBufferReserve(ppdev, 6, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXSub;
                    pBuffer[1] =  FIXtoFIXED(aPtrFixTop[RIGHT]->x) + NEARLY_ONE;
                    pBuffer[2] = __Permedia2TagdXSub;
                    pBuffer[3] =  alDxDy[RIGHT];
                    pBuffer[4] = __Permedia2TagContinueNewSub;
                    pBuffer[5] =  lCount;

                    pBuffer += 6;

                    InputBufferCommit(ppdev, pBuffer);
                }// if !( aPtrFixNext[LEFT]->y < aPtrFixNext[RIGHT]->y )
            }// Loop through next trapezoids

            //
            // Repeatedly draw more trapezoids until points are equal
            // If y values are equal, then we can start again from
            // scratch. 
            //
            if ( aPtrFixNext[LEFT] == aPtrFixNext[RIGHT] )
            {
                break;
            }
        }// loop through all the trapezoids

FinishedPolygon:

        if ( !lNumOfPass-- )
        {
            break;
        }
    }// Loop through all the polygons

    if ( pClipList )
    {
        //
        // Reset scissor mode to its default state.
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] =  SCREEN_SCISSOR_DEFAULT;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

    DBG_GDI((6, "bFillPolygon: returning TRUE"));

    bRC = TRUE;

ReturnBack:

    InputBufferReserve(ppdev, 12, &pBuffer);

    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] =  __PERMEDIA_DISABLE;
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  INTtoFIXED(1);
    pBuffer[4] = __Permedia2TagContinue;
    pBuffer[5] =  0;
    pBuffer[6] = __Permedia2TagContinueNewDom;
    pBuffer[7] =  0;
    pBuffer[8] = __Permedia2TagdXDom;
    pBuffer[9] =   0;
    pBuffer[10] = __Permedia2TagdXSub;
    pBuffer[11] =   0;

    pBuffer += 12;

    InputBufferCommit(ppdev, pBuffer);

    return bRC;
}// bFillPolygon()

//-----------------------------------------------------------------------------
//
// BOOL bFillSpan()
//
// This is the code to break the polygon into spans.
//
// Parameters:
//  ppdev-------Pointer to PDev
//  pSurfDst----Destination surface
//  lEdges------Number of edges, includes close figure edge
//  pptfxFirst--Pointer to the first point in the data buffer. There are total
//              "lEdges" points
//  pptfxTop----Pointer to the toppest point in the polygon array.
//  pptfxLast---Pointer to the last point in the polygon array.
//  iSolidColor-Solid color fill
//  ulRop4------ROP4
//  pco---------Clip Object. 
//  prb---------Realized brush
//  pptlBrush---Pattern alignment    
//
//-----------------------------------------------------------------------------
BOOL
bFillSpans(PDev*      ppdev,
           Surf*      pSurfDst,
           LONG       lEdges,
           POINTFIX*  pptfxFirst,
           POINTFIX*  pptfxTop,
           POINTFIX*  pptfxLast,
           ULONG      ulSolidColor,
           ULONG      ulRop4,
           CLIPOBJ*   pco,
           RBrush*    prb,
           POINTL*    pptlBrush)
{
    GFNPB       pb;             // Parameter block
    
    POINTFIX*   pptfxOld;       // Start point in current edge
    
    EDGEDATA    aEd[2];         // Left and right edge
    EDGEDATA    aEdTmp[2];      // DDA terms and stuff
    EDGEDATA*   pEdgeData;
    
    BOOL        bTrivialClip;   // Trivial Clip or not
    
    DWORD       dwAsMode[2];    // The area stipple mode and the color for that
                                // pass
    DWORD       dwColorMode;    // Current color mode
    DWORD       dwColorReg;     // Current color register mode
    DWORD       dwContinueMsg = 0;
                                // Current "Continue" register settings
    DWORD       dwLogicMode;    // Current logic op mode
    DWORD       dwRenderBits;   // Current render bits
    DWORD       dwReadMode;     // Current register read mode
    

    LONG        lCurrentSpan;   // Current Span
    LONG        lDX;            // Edge delta in FIX units in x direction
    LONG        lDY;            // Edge delta in FIX units in y direction
    LONG        lNumColors;     // Number of colors
    LONG        lNumOfPass;     // Number of passes required to render
    LONG        lNumScan;       // Number of scans in current trapezoid
    LONG        lQuotient;      // Quotient
    LONG        lRemainder;     // Remainder
    LONG        lStartY;        // y-position of start point in current edge
    LONG        lTempNumScan;   // Temporary variable for number of spans
    LONG        lTmpLeftX;      // Temporary variable
    LONG        lTmpRightX;     // Temporary variable
    
    ULONG       ulBgColor;      // Background color
    ULONG       ulBgLogicOp = ulRop3ToLogicop(ulRop4 >> 8);
    ULONG       ulBrushColor = ulSolidColor;
    ULONG       ulColor[2];     // On multiple color passes we need to know how
                                // to set up
    ULONG       ulFgColor;      // Foreground color
    ULONG       ulFgLogicOp = ulRop3ToLogicop(ulRop4 & 0xFF);
    ULONG*      pBuffer;

    PERMEDIA_DECL;
    
    bTrivialClip = (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL);

    pb.ppdev = ppdev;

    //
    // This span code cannot handle a clip list yet!
    //
    if ( !bTrivialClip )
    {
        return FALSE;
    }

    DBG_GDI((7, "Starting Spans Code"));

    //
    // Setup window base first
    //
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  pSurfDst->ulPixOffset;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Some Initialization. First trapezoid starts from the topest point
    // which is pointed by "pptfxTop".
    // Here we convert it from 28.4 to normal interger
    //
    lCurrentSpan = (pptfxTop->y + 15) >> 4;

    //
    // Make sure we initialize the DDAs appropriately:
    //
    aEd[LEFT].lNumOfScanToGo  = 0;  // Number of scans to go for this left edge
    aEd[RIGHT].lNumOfScanToGo = 0;  // Number of scans to go for this right edge

    //
    // For now, guess as to which is the left and which is the right edge
    //
    aEd[LEFT].lPtfxDelta  = -(LONG)sizeof(POINTFIX); // Delta (in bytes) from
    aEd[RIGHT].lPtfxDelta = sizeof(POINTFIX);        // pptfx to next point

    aEd[LEFT].pptfx  = pptfxTop;                // Points to start of
    aEd[RIGHT].pptfx = pptfxTop;                // current edge

    DBG_GDI((7, "bFillPolygon: Polygon is renderable. Go render"));

    if ( ulFgLogicOp == K_LOGICOP_COPY )
    {
        dwColorMode = __PERMEDIA_DISABLE;
        dwLogicMode = __PERMEDIA_CONSTANT_FB_WRITE;
        dwReadMode  = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                    | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

        //
        // If block fills not available or using the area stipple for mono
        // pattern, then use constant color.
        //
        if ( ulBrushColor == 0xffffffff )
        {
            dwColorReg   = __Permedia2TagFBWriteData;
            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
        } // Non-solid brush
        else
        {
            //
            // We can use fast fills, so load the fb block color register.
            //
            dwColorReg = __Permedia2TagFBBlockColor;
            dwRenderBits = __RENDER_FAST_FILL_ENABLE
                         | __RENDER_TRAPEZOID_PRIMITIVE;

            //
            // Replicate colour for block fill colour.
            //
            if ( ppdev->cPelSize < 2 )
            {
                ulSolidColor |= ulSolidColor << 16;
                if ( ppdev->cPelSize == 0 )
                {
                    ulSolidColor |= ulSolidColor << 8;
                }
            }

            //
            // Ensure that the last access was a write before loading
            // BlockColor
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = __Permedia2TagFBBlockColor;
            pBuffer[1] =  ulSolidColor;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);
        }// Solid brush 
    }// K_LOGICOP_COPY
    else
    {
        dwColorMode = __COLOR_DDA_FLAT_SHADE;
        dwLogicMode = P2_ENABLED_LOGICALOP(ulFgLogicOp);
        dwReadMode = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP)
                   | LogicopReadDest[ulFgLogicOp];
        dwColorReg = __Permedia2TagConstantColor;
        dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE;
    }// NON_COPY

    //
    // To get correct results, we need to add on nearly one to each X
    // coordinate. 
    //
    if ( ulBrushColor != 0xFFFFFFFF )
    {
        //
        // This is a solid brush
        //
        lNumColors = 1;

        if ( dwColorMode == __PERMEDIA_DISABLE )
        {
            //
            // This is from LOGICOP_COPY mode according to the dwColorMode we
            // set above
            //
            // Note: ColorDDAMode is DISABLED at initialisation time so
            // there is no need to re-load it here.
            //
            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagFBReadMode;
            pBuffer[1] =  dwReadMode;
            pBuffer[2] = __Permedia2TagLogicalOpMode;
            pBuffer[3] =  dwLogicMode;
            pBuffer[4] = dwColorReg;
            pBuffer[5] = ulSolidColor;

            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);
        }// Disable color DDA, LOGIC_COPY
        else
        {
            //
            // This is from NON-COPY logicop mode according to the dwColorMode
            // we set above
            //
            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagColorDDAMode;
            pBuffer[1] =  dwColorMode;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] =  dwReadMode;
            pBuffer[4] = __Permedia2TagLogicalOpMode;
            pBuffer[5] =  dwLogicMode;
            pBuffer[6] = dwColorReg;
            pBuffer[7] = ulSolidColor;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);    

        }// Enable colorDDA, NON-COPY mode
    }// Solid brush case
    else
    {
        //
        // For non-solid brush case, we need to realize brush
        //
        BrushEntry* pbe;

        //
        // Turn on the area stipple.
        //
        dwRenderBits |= __RENDER_AREA_STIPPLE_ENABLE;

        //
        // If anything has changed with the brush we must re-realize it. If
        // the brush has been kicked out of the area stipple unit we must
        // fully realize it. If only the alignment has changed we can
        // simply update the alignment for the stipple.
        //
        DBG_GDI((7, "Brush found"));
        ASSERTDD(prb != NULL,
                 "Caller should pass in prb for non-solid brush");
        pbe = prb->pbe;

        pb.prbrush = prb;
        pb.pptlBrush = pptlBrush;

        if ( (pbe == NULL) || (pbe->prbVerify != prb) )
        {
            DBG_GDI((7, "full brush realize"));
            vPatRealize(&pb);
        }
        else if ( (prb->ptlBrushOrg.x != pptlBrush->x)
                ||(prb->ptlBrushOrg.y != pptlBrush->y) )
        {
            DBG_GDI((7, "changing brush offset"));
            vMonoOffset(&pb);
        }

        ulFgColor = prb->ulForeColor;
        ulBgColor = prb->ulBackColor;

        if ( dwColorMode == __PERMEDIA_DISABLE )
        {
            //
            // ColorDDAMode is DISABLED at initialisation time so there is
            // no need to re-load it here.
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = __Permedia2TagFBReadMode;
            pBuffer[1] =  dwReadMode;
            pBuffer[2] = __Permedia2TagLogicalOpMode;
            pBuffer[3] =  dwLogicMode;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
        else
        {
            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagColorDDAMode;
            pBuffer[1] =  dwColorMode;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] =  dwReadMode;
            pBuffer[4] = __Permedia2TagLogicalOpMode;
            pBuffer[5] =  dwLogicMode;

            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);
        }

        if ( (ulBgLogicOp == K_LOGICOP_NOOP)
           ||((ulFgLogicOp == K_LOGICOP_XOR) && (ulBgColor == 0)) )
        {
            //
            // Either we have a transparent bitmap or it can be assumed to
            // be transparent (XOR with bg=0) 
            //
            DBG_GDI((7, "transparant bg"));

            lNumColors = 1;

            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulFgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] =  prb->areaStippleMode;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
        else if ( (ulFgLogicOp == K_LOGICOP_XOR) && (ulFgColor == 0) )
        {
            //
            // We have a transparent foreground! (XOR with fg=0)
            //
            DBG_GDI((7, "transparant fg"));
            lNumColors = 1;
            
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = dwColorReg;
            pBuffer[1] = ulBgColor;
            pBuffer[2] = __Permedia2TagAreaStippleMode;
            pBuffer[3] = prb->areaStippleMode |AREA_STIPPLE_INVERT_PAT;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
        else
        {
            //
            // Not using a transparent pattern
            //
            DBG_GDI((7, "2 color"));
            lNumColors = 2;
            ulColor[0] = ulFgColor;
            ulColor[1] = ulBgColor;
            dwAsMode[0] = prb->areaStippleMode;
            dwAsMode[1] = dwAsMode[0] | AREA_STIPPLE_INVERT_PAT;
        }
    }// Non-solid brush case

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagCount;
    pBuffer[1] =  0;     

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    //
    // dxDom, dXSub and dY are initialised to 0, 0, and 1, so we don't need 
    // to re-load them here.
    //
    DBG_GDI((7, "Rendering Polygon. %d Colors", lNumColors));

NewTrapezoid:

    DBG_GDI((7, "New Trapezoid"));

    //
    // DDA initialization
    // Here we start with LEFT(1) edge and then RIGHT(0) edge
    //
    for ( int iEdge = 1; iEdge >= 0; --iEdge )
    {
        pEdgeData = &aEd[iEdge];
        if ( pEdgeData->lNumOfScanToGo == 0 )
        {
            //
            // No more scan lines left to go. Need a new DDA
            // loop until we have some scan lines to go
            //
            do
            {
                lEdges--;
                if ( lEdges < 0 )
                {
                    //
                    //  This is the only return point for this
                    // "BreakIntoSpans", that is, we return TRUE when there
                    // is no more edge left. We are done.
                    //
                    DBG_GDI((7, "bFillPolygon: returning TRUE"));
                    
                    return TRUE;
                }// if no more edge left

                //
                // Find the next left edge, accounting for wrapping. Before
                // that, save the old edge in "pptfxOld"
                //
                pptfxOld = pEdgeData->pptfx;

                //
                // Get next point
                //
                pEdgeData->pptfx = (POINTFIX*)((BYTE*)pEdgeData->pptfx
                                               + pEdgeData->lPtfxDelta);

                //
                // Checking the end point cases
                //
                if ( pEdgeData->pptfx < pptfxFirst )
                {
                    pEdgeData->pptfx = pptfxLast;
                }
                else if ( pEdgeData->pptfx > pptfxLast )
                {
                    pEdgeData->pptfx = pptfxFirst;
                }

                //
                // Have to find the edge that spans lCurrentSpan.
                // Note: we need to convert it to normal interger first
                //
                pEdgeData->lNumOfScanToGo = ((pEdgeData->pptfx->y + 15) >> 4)
                                          - lCurrentSpan;

                //
                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one
                //
            } while ( pEdgeData->lNumOfScanToGo <= 0 );

            //
            // 'pEdgeData->pptfx' now points to the end point of the edge
            //  spanning the scan 'lCurrentSpan'.
            // Calculate dx(lDX) and dy(lDY)
            //
            lDY = pEdgeData->pptfx->y - pptfxOld->y;
            lDX = pEdgeData->pptfx->x - pptfxOld->x;

            ASSERTDD(lDY > 0, "Should be going down only");

            //
            // Compute the DDA increment terms
            //
            if ( lDX < 0 )
            {
                //
                // X is moving from right to left because it is negative
                //
                lDX = -lDX;
                if ( lDX < lDY )                            // Can't be '<='
                {
                    pEdgeData->lXAdvance = -1;
                    pEdgeData->lErrorUp = lDY - lDX;
                }
                else
                {
                    QUOTIENT_REMAINDER(lDX, lDY, lQuotient, lRemainder);

                    pEdgeData->lXAdvance = -lQuotient;      // - lDX / lDY
                    pEdgeData->lErrorUp = lRemainder;       // lDX % lDY

                    if ( pEdgeData->lErrorUp > 0 )
                    {
                        pEdgeData->lXAdvance--;
                        pEdgeData->lErrorUp = lDY - pEdgeData->lErrorUp;
                    }
                }
            }// lDX is negative
            else
            {
                //
                // X is moving from left to right
                //
                if ( lDX < lDY )                            // Can't be '<='
                {
                    pEdgeData->lXAdvance = 0;
                    pEdgeData->lErrorUp = lDX;
                }
                else
                {
                    QUOTIENT_REMAINDER(lDX, lDY, lQuotient, lRemainder);

                    pEdgeData->lXAdvance = lQuotient;       // lDX / lDY
                    pEdgeData->lErrorUp = lRemainder;       // lDX % lDY
                }
            } // lDX is positive

            pEdgeData->lErrorDown = lDY; // DDA limit

            //
            // Error is initially zero (add lDY -1 for the ceiling, but
            // subtract off lDY so that we can check the sign instead of
            // comparing to lDY)
            //
            pEdgeData->lError     = -1;

            //
            // Current edge X starting point
            //
            pEdgeData->lCurrentXPos = pptfxOld->x;

            //
            // Current edge Y starting point
            //
            lStartY = pptfxOld->y;

            //
            // Check if the floating part of the Y coordinate is 0
            // Note: lStartY is still in 28.4 format
            //
            if ( (lStartY & 15) != 0 )
            {
                //
                // Advance to the next integer y coordinate
                // Note: here "pEdgeData->x += pEdgeData->lXAdvance" only
                // increase its fraction part
                //
                for ( int i = 16 - (lStartY & 15); i != 0; --i )
                {
                    pEdgeData->lCurrentXPos += pEdgeData->lXAdvance;
                    pEdgeData->lError += pEdgeData->lErrorUp;

                    if ( pEdgeData->lError >= 0 )
                    {
                        pEdgeData->lError -= pEdgeData->lErrorDown;
                        pEdgeData->lCurrentXPos++;
                    }
                }
            }// Handle fraction part of the coordinate

            if ( (pEdgeData->lCurrentXPos & 15) != 0 )
            {
                //
                // We'll want the ceiling in just a bit...
                //
                pEdgeData->lError -= pEdgeData->lErrorDown
                                   * (16 - (pEdgeData->lCurrentXPos & 15));
                pEdgeData->lCurrentXPos += 15;
            }

            //
            // Chop off those fractional bits, convert to regular format
            //
            pEdgeData->lCurrentXPos = pEdgeData->lCurrentXPos >> 4;
            pEdgeData->lError >>= 4;

            //
            // Convert to Permedia2 format positions and deltas
            // Note: all the data in pEdgeData, aEd are in Permedia2 format now
            //
            pEdgeData->lCurrentXPos = INTtoFIXED(pEdgeData->lCurrentXPos)
                                    + NEARLY_ONE;
            pEdgeData->lXAdvance = INTtoFIXED(pEdgeData->lXAdvance);
        }// If there is no more scan line left
    }// Looping throught the LEFT and RIGHT edges

    //
    // Number of scans in this trap
    // Note: here aEd[LEFT].lNumOfScanToGo and aEd[RIGHT].lNumOfScanToGo are
    // already in normal interger mode since we have done:
    // pEdgeData->lNumOfScanToGo = ((pEdgeData->pptfx->y + 15) >> 4)
    //                           - lCurrentSpan; above
    //
    lNumScan = min(aEd[LEFT].lNumOfScanToGo, aEd[RIGHT].lNumOfScanToGo);
    aEd[LEFT].lNumOfScanToGo  -= lNumScan;
    aEd[RIGHT].lNumOfScanToGo -= lNumScan;
    lCurrentSpan  += lNumScan;        // Top scan in next trap

    //
    // If the left and right edges are vertical, simply output as a rectangle
    //
    DBG_GDI((7, "Generate spans"));

    lNumOfPass = 0;
    while ( ++lNumOfPass <= lNumColors )
    {
        DBG_GDI((7, "Pass %d lNumColors %d", lNumOfPass, lNumColors));

        if ( lNumColors == 2 )
        {
            //
            // Two colours, so we need to save and restore aEd values
            // and set the color and stipple mode.
            //
            InputBufferReserve(ppdev, 4, &pBuffer);

            if ( lNumOfPass == 1 )
            {
                //
                // Pass 1, set color reg as foreground color
                //
                aEdTmp[LEFT]  = aEd[LEFT];
                aEdTmp[RIGHT] = aEd[RIGHT];
                lTempNumScan = lNumScan;

                pBuffer[0] = dwColorReg;
                pBuffer[1] = ulColor[0];
                pBuffer[2] = __Permedia2TagAreaStippleMode;
                pBuffer[3] =  dwAsMode[0];

                DBG_GDI((7, "Pass 1, Stipple set"));
            }
            else
            {
                //
                // Pass 2, set color reg as background color
                //
                aEd[LEFT]  = aEdTmp[LEFT];
                aEd[RIGHT] = aEdTmp[RIGHT];
                lNumScan = lTempNumScan;

                pBuffer[0] = dwColorReg;
                pBuffer[1] = ulColor[1];
                pBuffer[2] = __Permedia2TagAreaStippleMode;
                pBuffer[3] =  dwAsMode[1];

                DBG_GDI((7, "Pass 2, Stipple set, New trap started"));
            }

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }// if (nColor == 2)

        InputBufferReserve(ppdev, 8, &pBuffer);

        //
        // Reset render position to the top of the trapezoid.
        // Note: here aEd[RIGHT].x etc. are alreadu in 12.15 mode since
        // we have done
        // "pEdgeData->x  = INTtoFIXED(pEdgeData->x);" and
        // "pEdgeData->lXAdvance = INTtoFIXED(pEdgeData->lXAdvance);" above
        //
        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  aEd[RIGHT].lCurrentXPos;
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] =  aEd[LEFT].lCurrentXPos;
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] =  INTtoFIXED(lCurrentSpan - lNumScan);
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  dwRenderBits;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        dwContinueMsg = __Permedia2TagContinue;

        if ( ((aEd[LEFT].lErrorUp | aEd[RIGHT].lErrorUp) == 0)
           &&((aEd[LEFT].lXAdvance| aEd[RIGHT].lXAdvance) == 0)
           &&(lNumScan > 1) )
        {
            //
            // Vertical-edge special case
            //
            DBG_GDI((7, "Vertical Edge Special Case"));

            //
            // Tell the hardware that we have "lNumScan" scan lines
            // to fill
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = dwContinueMsg;
            pBuffer[1] = lNumScan;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);
            continue;
        }

        while ( TRUE )
        {
            //
            // Run the DDAs
            //
            DBG_GDI((7, "Doing a span 0x%x to 0x%x, 0x%x scans left.Continue%s",
                     aEd[LEFT].lCurrentXPos, aEd[RIGHT].lCurrentXPos, lNumScan,
                     (dwContinueMsg == __Permedia2TagContinueNewDom) ? "NewDom":
                     ((dwContinueMsg == __Permedia2TagContinue)? "":"NewSub")));

            //
            // Tell the hardware that we have "1" scan lines to fill
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = dwContinueMsg;
            pBuffer[1] = 1;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);

            //
            // We have finished this trapezoid. Go get the next one
            //
            // Advance the right wall
            //
            lTmpRightX = aEd[RIGHT].lCurrentXPos;
            aEd[RIGHT].lCurrentXPos += aEd[RIGHT].lXAdvance;
            aEd[RIGHT].lError += aEd[RIGHT].lErrorUp;

            if ( aEd[RIGHT].lError >= 0 )
            {
                aEd[RIGHT].lError -= aEd[RIGHT].lErrorDown;
                aEd[RIGHT].lCurrentXPos += INTtoFIXED(1);
            }

            //
            // Advance the left wall
            //
            lTmpLeftX = aEd[LEFT].lCurrentXPos;
            aEd[LEFT].lCurrentXPos += aEd[LEFT].lXAdvance;
            aEd[LEFT].lError += aEd[LEFT].lErrorUp;

            if ( aEd[LEFT].lError >= 0 )
            {
                aEd[LEFT].lError -= aEd[LEFT].lErrorDown;
                aEd[LEFT].lCurrentXPos += INTtoFIXED(1);
            }

            if ( --lNumScan == 0 )
            {
                break;
            }

            //
            // Setup the X registers if we have changed either end.
            //
            if ( lTmpRightX != aEd[RIGHT].lCurrentXPos )
            {
                if ( lTmpLeftX != aEd[LEFT].lCurrentXPos )
                {
                    InputBufferReserve(ppdev, 6, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXSub;
                    pBuffer[1] =  aEd[LEFT].lCurrentXPos;
                    pBuffer[2] = __Permedia2TagContinueNewSub;
                    pBuffer[3] =  0;
                    pBuffer[4] = __Permedia2TagStartXDom;
                    pBuffer[5] =  aEd[RIGHT].lCurrentXPos;

                    pBuffer += 6;

                    InputBufferCommit(ppdev, pBuffer);
                }
                else
                {
                    InputBufferReserve(ppdev, 2, &pBuffer);

                    pBuffer[0] = __Permedia2TagStartXDom;
                    pBuffer[1] =  aEd[RIGHT].lCurrentXPos;

                    pBuffer += 2;

                    InputBufferCommit(ppdev, pBuffer);
                }

                dwContinueMsg = __Permedia2TagContinueNewDom;             
            }
            else if ( lTmpLeftX != aEd[LEFT].lCurrentXPos )
            {
                InputBufferReserve(ppdev, 2, &pBuffer);

                pBuffer[0] = __Permedia2TagStartXSub;
                pBuffer[1] =  aEd[LEFT].lCurrentXPos;

                pBuffer += 2;

                InputBufferCommit(ppdev, pBuffer);
                dwContinueMsg = __Permedia2TagContinueNewSub;
            }
        }// while ( TRUE )
    }// while ( ++lNumOfPass <= lNumColors )

    DBG_GDI((7, "Generate spans done"));
    goto NewTrapezoid;
}// bFillSpans()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\escape.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: escape.c
 *
 * Contains private escape calls for driver.
 *
 *
 *
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *****************************************************************************/
#include "precomp.h"

#include "log.h"                                   
                                   
#define ESCAPE_OPEN_LOG     1024
#define ESCAPE_CLOSE_LOG    1025

ULONG APIENTRY DrvEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
   )
{
    PPDev   ppdev = (PPDev) pso->dhpdev;
    ULONG   ulResult;

    switch(iEsc)
    {

    case ESCAPE_OPEN_LOG:
        ulResult = ulLogOpen(L"\\??\\E:\\puntinfo.txt", 1024 * 1024 * 32);
        if(!ulResult)
        {
            DBG_GDI((0, "DrvEscape: failed to open log file")); 
        }
        else
        {
            DBG_GDI((0, "DrvEscape: opened log file"));
        }

        break;

    case ESCAPE_CLOSE_LOG:
        ulResult = ulLogClose();
        if(!ulResult)
        {
            DBG_GDI((0, "DrvEscape: failed to close log file"));
        }
        else
        {
            DBG_GDI((0, "DrvEscape: close log file"));
        }

        break;

    default:
        DBG_GDI((3, "DrvEscape: unknown escape %d", iEsc));
        ulResult = 0;
    }

    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\enable.c ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/
#include "precomp.h"
#include "directx.h"

#include "gdi.h"
#include "text.h"
#include "heap.h"  
#include "dd.h"
#define ALLOC_TAG ALLOC_TAG_NE2P  
PVOID    pCounterBlock;  // some macros need this

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

//----------------------------Public*Structure---------------------------------
//
// GDIINFO ggdiDefault
//
// This contains the default GDIINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//-----------------------------------------------------------------------------
GDIINFO ggdiDefault =
{
    0x5000,                 // Major OS Ver 5, Minor Ver 0, Driver Ver 0
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)
    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)
    TC_RA_ABLE,             // flTextCaps
    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)
    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)
    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long
    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize
    256,                    // ulNumPalReg
    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.
    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },
    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};// GDIINFO ggdiDefault

//-----------------------------Public*Structure--------------------------------
//
// DEVINFO gdevinfoDefault
//
// This contains the default DEVINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//-----------------------------------------------------------------------------
DEVINFO gdevinfoDefault =
{
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_DIRECTDRAW       |
     GCAPS_GRAY16           |       // we handle anti-aliased text
     GCAPS_COLOR_DITHER),
                                    // flGraphicsFlags
    SYSTM_LOGFONT,                  // lfDefaultFont
    HELVE_LOGFONT,                  // lfAnsiVarFont
    COURI_LOGFONT,                  // lfAnsiFixFont
    0,                              // cFonts
    BMF_8BPP,                       // iDitherFormat
    8,                              // cxDither
    8,                              // cyDither
    0,                              // hpalDefault (filled in later)
    GCAPS2_SYNCTIMER |
    GCAPS2_SYNCFLUSH
}; // DEVINFO gdevinfoDefault

//-----------------------------Public*Structure--------------------------------
//
// DFVFN gadrvfn[]
//
// Build the driver function table gadrvfn with function index/address
// pairs.  This table tells GDI which DDI calls we support, and their
// location (GDI does an indirect call through this table to call us).
//
// Why haven't we implemented DrvSaveScreenBits?  To save code.
//
// When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
// the-fly by creating a temporary device-format-bitmap, and explicitly
// calling DrvCopyBits to save/restore the bits.  Since we already hook
// DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
// the bits anyway (which would have been the main reason for implementing
// DrvSaveScreenBits).  So we may as well save some working set.
//
//-----------------------------------------------------------------------------
DRVFN gadrvfnOne[] =
{
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode            },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV          },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap    },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap    },
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface         },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont           },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw     },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV           },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver         },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface        },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw      },
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface         },
    {   INDEX_DrvEscape,                (PFN) DrvEscape                },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo     },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes              },
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer           },
    {   INDEX_DrvNotify,                (PFN) DrvNotify                },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush          },
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV             },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette            },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape       },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt            },
    {   INDEX_DrvSynchronizeSurface,    (PFN) DrvSynchronizeSurface    },
#if THUNK_LAYER
    {   INDEX_DrvAlphaBlend,            (PFN) xDrvAlphaBlend           },
    {   INDEX_DrvBitBlt,                (PFN) xDrvBitBlt               },
    {   INDEX_DrvCopyBits,              (PFN) xDrvCopyBits             },
    {   INDEX_DrvFillPath,              (PFN) xDrvFillPath             },
    {   INDEX_DrvGradientFill,          (PFN) xDrvGradientFill         },
    {   INDEX_DrvLineTo,                (PFN) xDrvLineTo               },
    {   INDEX_DrvStrokePath,            (PFN) xDrvStrokePath           },
    {   INDEX_DrvTextOut,               (PFN) xDrvTextOut              },
    {   INDEX_DrvTransparentBlt,        (PFN) xDrvTransparentBlt       },
#else
    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend            },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits              },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath              },
    {   INDEX_DrvGradientFill,          (PFN) DrvGradientFill          },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath            },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut               },
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt        },
#endif                                        
    {   INDEX_DrvResetDevice,           (PFN) DrvResetDevice           },
};// DRVFN gadrvfnOne[]

// Number of driver callbacks for after NT5.
#define NON_NT5_FUNCTIONS   1


//
// Driver Function array we use when running on NT40. Notice the INDEX_Drv
// calls which we have commneted out implying we dont support these
// calls on NT4.0

DRVFN gadrvfnOne40[] =
{
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode            },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV          },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap    },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap    },
//    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface         },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw     },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV           },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver         },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface        },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw      },
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface         },
    {   INDEX_DrvEscape,                (PFN) DrvEscape                },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo     },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes              },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer           },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush          },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette            },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape       },
//    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp },
//    {   INDEX_DrvNotify,                (PFN) DrvNotify                },
//    {   INDEX_DrvSynchronizeSurface,    (PFN) DrvSynchronizeSurface    },
#if THUNK_LAYER
    {   INDEX_DrvBitBlt,                (PFN) xDrvBitBlt                },
    {   INDEX_DrvCopyBits,              (PFN) xDrvCopyBits              },
    {   INDEX_DrvTextOut,               (PFN) xDrvTextOut               },
//    {   INDEX_DrvAlphaBlend,            (PFN) xDrvAlphaBlend            },
//    {   INDEX_DrvGradientFill,          (PFN) xDrvGradientFill          },
//    {   INDEX_DrvTransparentBlt,        (PFN) xDrvTransparentBlt        },
    {   INDEX_DrvLineTo,                (PFN) xDrvLineTo                },
    {   INDEX_DrvFillPath,              (PFN) xDrvFillPath              },
    {   INDEX_DrvStrokePath,            (PFN) xDrvStrokePath            },
#else
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits              },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut               },
//    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend            },
//    {   INDEX_DrvGradientFill,          (PFN) DrvGradientFill          },
//    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt        },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo                },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath              },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath            },
#endif                                        
};// DRVFN gadrvfnOne40[]

ULONG gcdrvfnOne = sizeof(gadrvfnOne) / sizeof(DRVFN);

//
// Special setup for NT4.0 runtime behaviour
//
ULONG gcdrvfnOne40 = sizeof(gadrvfnOne40) / sizeof(DRVFN);
//
// We initialize this to TRUE and set it to FALSE in 
// DrvEnablePDEV when on NT5.0. We do this using the iEngineVersion passed on
// to us in that call.
//
BOOL g_bOnNT40 = TRUE;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
HSEMAPHORE gLock = NULL;
ULONG gLockCount = 0;
#endif
//@@END_DDKSPLIT

//
// Local prototypes
//
BOOL    bAssertModeHardware(PDev* ppdev, BOOL bEnable);
BOOL    bEnableHardware(PDev* ppdev);
BOOL    bInitializeModeFields(PDev* ppdev, GDIINFO* pgdi,
                              DEVINFO* pdi, DEVMODEW* pdm);
DWORD   getAvailableModes(HANDLE hDriver,
                          PVIDEO_MODE_INFORMATION* modeInformation,
                          DWORD* cbModeSize);
VOID    vDisableHardware(PDev* ppdev);

#define SETUP_LOG_LEVEL  2

//-------------------------------Public*Routine--------------------------------
//
// BOOL DrvEnableDriver
//
// DrvEnableDriver is the initial driver entry point exported by the driver
// DLL. It fills a DRVENABLEDATA structure with the driver version number and
// calling addresses of functions supported by the driver
//
// Parameters:
//  iEngineVersion--Identifies the version of GDI that is currently running.
//  cj--------------Specifies the size in bytes of the DRVENABLEDATA structure.
//                  If the structure is larger than expected, extra members
//                  should be left unmodified. 
//  pded------------Points to a DRVENABLEDATA structure. GDI zero-initializes
//                  cj bytes before the call. The driver fills in its own data.
//
// Return Value
//  The return value is TRUE if the specified driver is enabled. Otherwise, it
//  is FALSE, and an error code is logged.
//
//-----------------------------------------------------------------------------
BOOL
DrvEnableDriver(ULONG          iEngineVersion,
                ULONG          cj,
                DRVENABLEDATA* pded)
{
    ULONG   gcdrvfn;
    DRVFN*  gadrvfn;
    ULONG   DriverVersion;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableDriver: iEngineVersion = 0x%lx\n",
            iEngineVersion, cj, pded));

    // Set up g_bOnNT40 based on the value in iEngineVersion
    if(iEngineVersion >= DDI_DRIVER_VERSION_NT5)
        g_bOnNT40 = FALSE;

    if(g_bOnNT40 == FALSE)
    {
        // Since this driver is backwards compatible,
        // report highest driver version this was built
        // against that the Engine will also recognize.
    
        // Ordered list of supported DDI versions
        ULONG SupportedVersions[] = {
            DDI_DRIVER_VERSION_NT5,
            DDI_DRIVER_VERSION_NT5_01,
        };
        LONG i = sizeof(SupportedVersions)/sizeof(SupportedVersions[0]);

        // Look for highest version also supported by engine
        while (--i >= 0)
        {
            if (SupportedVersions[i] <= iEngineVersion) break;
        }

        // Fail if there isn't common support
        if (i < 0) return FALSE;

        DriverVersion = SupportedVersions[i];

        gadrvfn = gadrvfnOne;
        gcdrvfn = gcdrvfnOne;
        if (iEngineVersion < DDI_DRIVER_VERSION_NT5_01)
        {
            // Trim new DDI hooks since NT5.0
            gcdrvfn -= NON_NT5_FUNCTIONS;
        }

        if(!bEnableThunks())
        {
            ASSERTDD(0,"DrvEnableDriver: bEnableThunks Failed\n");
            return FALSE;
        }
    }
    else
    {
        DriverVersion = DDI_DRIVER_VERSION_NT4;
        gadrvfn = gadrvfnOne40;
        gcdrvfn = gcdrvfnOne40;
    }

    //
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.
    // Fill in as much as we can.
    //
    if ( cj >= (sizeof(ULONG) * 3) )
    {
        pded->pdrvfn = gadrvfn;
    }

    //
    // Tell GDI what are the functions this driver can do
    //
    if ( cj >= (sizeof(ULONG) * 2) )
    {
        pded->c = gcdrvfn;
    }

    //
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.
    //
    if ( cj >= sizeof(ULONG) )
    {
        DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableDriver: iDriverVersion = 0x%lx",
                DriverVersion));
        pded->iDriverVersion = DriverVersion;
    }

    //
    //  add instance to memory tracker if enabled
    //
    MEMTRACKERADDINSTANCE();    

    return(TRUE);
}// DrvEnableDriver()

//-------------------------------Public*Routine--------------------------------
//
// VOID DrvDisableDriver
//
// This function is used by GDI to notify a driver that it no longer requires
// the driver and is ready to unload it.
//
// Comments
//  The driver should free all allocated resources and return the device to the
//  state it was in before the driver loaded.
//
//  DrvDisableDriver is required for graphics drivers.
//
//-----------------------------------------------------------------------------
VOID
DrvDisableDriver(VOID)
{
    //
    // Do nothing
    //

    //
    //  except cleanup memory tracker, if enabled.
    //  also show memory usage
    //
    MEMTRACKERDEBUGCHK();
    MEMTRACKERREMINSTANCE();
   
    return;
}// DrvDisableDriver()

//-------------------------------Public*Routine--------------------------------
//
// DHPDEV DrvEnablePDEV
//
// This function returns a description of the physical device's characteristics
// to GDI. 
//
// It initializes a bunch of fields for GDI, based on the mode we've been asked
// to do.  This is the first thing called after DrvEnableDriver, when GDI wants
// to get some information about the driver.
//
// Parameters
//
//  pdm-------------Points to a DEVMODEW structure that contains driver data. 
//
//  pwszLogAddress--Will always be null and can be ignored
//
//  cPat------------No longer used by GDI and can be ignored 
//
//  phsurfPatterns--No longer used by GDI and can be ignored 
//
//  cjCaps----------Specifies the size of the buffer pointed to by pdevcaps.
//                  The driver must not access memory beyond the end of the
//                  buffer. 
//
//  pdevcaps--------Points to a GDIINFO structure that will be used to describe
//                  device capabilities. GDI zero-initializes this structure
//                  calling DrvEnablePDEV. 
//
//  cjDevInfo-------Specifies the number of bytes in the DEVINFO structure
//                  pointed to by pdi. The driver should modify no more than
//                  this number of bytes in the DEVINFO. 
//
//  pdi-------------Points to the DEVINFO structure, which describes the driver
//                  and the physical device. The driver should only alter the
//                  members it understands. GDI fills this structure with zeros
//                  before a call to DrvEnablePDEV.
//
//  hdev------------Is a GDI-supplied handle to the display driver device that
//                  is being enabled.  The device is in the process of being
//                  created and thus can not be used for Eng calls thus making
//                  this paramter practially useless.  The one exception to this
//                  rule is the use of hdev for calls to EngGetDriverName.  No
//                  other Eng calls are gaurenteed to work.
//
//  pwszDeviceName--Device driver file name stored as a zero terminated ASCII
//                  string
//
//  hDriver---------Identifies the kernel-mode driver that supports the device.
//                  We will use this to make EngDeviceIoControl calls to our
//                  corresponding mini-port driver.
//
//  Returns upon success a handle to the driver-defined device instance
//  information upon success.  Otherwise it returns NULL.
//
//-----------------------------------------------------------------------------
DHPDEV
DrvEnablePDEV(DEVMODEW*   pdm,
              PWSTR       pwszLogAddr,
              ULONG       cPat,
              HSURF*      phsurfPatterns,
              ULONG       cjCaps,
              ULONG*      pdevcaps,
              ULONG       cjDevInfo,
              DEVINFO*    pdi,
              HDEV        hdev,
              PWSTR       pwszDeviceName,
              HANDLE      hDriver)
{
    PDev*   ppdev = NULL;
    GDIINFO gdiinfo;
    DEVINFO devinfo;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnablePDEV(...)"));

    //
    // Invalidate input parameters
    // Note: here we use "<" to check the size of the structure is to ensure
    // that the driver can be used in the future version of NT, in which case
    // that the structure size might go larger

    //
    // GDIINFO and DEVINFO are larger on NT50. On NT40 they are smaller.
    // To make NT50 built driver binary work on NT40, we use temporary copies of
    // GDIINFO and DEVINFO and only copy what cjCaps and cjDevInfo indicate
    // into these structures.

    RtlZeroMemory(&gdiinfo, sizeof(GDIINFO));
    RtlCopyMemory(&gdiinfo, pdevcaps, __min(cjCaps, sizeof(GDIINFO)));
    
    RtlZeroMemory(&devinfo, sizeof(DEVINFO));
    RtlCopyMemory(&devinfo, pdi, __min(cjDevInfo, sizeof(DEVINFO)));

    //
    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:
    //
    ppdev = (PDev*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(PDev), ALLOC_TAG);
    if ( ppdev == NULL )
    {
        DBG_GDI((0, "DrvEnablePDEV: failed memory allocation"));
        goto errExit;
    }

    ppdev->hDriver = hDriver;

    //
    // Initialize status field.
    //    
    ppdev->flStatus = ENABLE_BRUSH_CACHE; 

    // NT50 -> NT40 compat:
    // We dont do Device Bitamps on NT40.
    //
    if(!g_bOnNT40)
        ppdev->flStatus |= STAT_DEV_BITMAPS;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->hsemLock = EngCreateSemaphore();

    if(ppdev->hsemLock == NULL)
    {
        DBG_GDI((0, "DrvEnablePDEV: failed to create semaphore"));
        goto errExit;
    }
#endif
//@@END_DDKSPLIT
    
    //
    // We haven't initialized the pointer yet
    //
    ppdev->bPointerInitialized = FALSE;

    //
    // Get the current screen mode information. Set up device caps and devinfo
    //
    if ( !bInitializeModeFields(ppdev, &gdiinfo, &devinfo, pdm) )
    {
        goto errExit;
    }

    RtlCopyMemory(pdevcaps, &gdiinfo, cjCaps);
    RtlCopyMemory(pdi, &devinfo, cjDevInfo);

    //
    // Initialize palette information.
    //
    if ( !bInitializePalette(ppdev, pdi) )
    {
        goto errExit;
    }

    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnablePDEV(...) returning %lx", ppdev));
    
    return((DHPDEV)ppdev);

errExit:
    
    if( ppdev != NULL )
    {
        DrvDisablePDEV((DHPDEV)ppdev);
    }

    DBG_GDI((0, "Failed DrvEnablePDEV"));

    return(0);
}// DrvEnablePDEV()

//-------------------------------Public*Routine--------------------------------
//
// DrvDisablePDEV
//
// This function is used by GDI to notify a driver that the specified PDEV is
// no longer needed
//
// Parameters
//  dhpdev------Pointer to the PDEV that describes the physical device to be
//              disabled. This value is the handle returned by DrvEnablePDEV.
//
// Comments
//  If the physical device has an enabled surface, GDI calls DrvDisablePDEV
//  after calling DrvDisableSurface. The driver should free any memory and
//  resources used by the PDEV.
//
// DrvDisablePDEV is required for graphics drivers.
//
// Note: In an error, we may call this before DrvEnablePDEV is done.
//
//-----------------------------------------------------------------------------
VOID
DrvDisablePDEV(DHPDEV  dhpdev)
{
    PDev*   ppdev = (PDev*)dhpdev;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvDisablePDEV(%lx)",  ppdev));

    vUninitializePalette(ppdev);
    

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if( ppdev->hsemLock != NULL)
    {
        EngDeleteSemaphore(ppdev->hsemLock);
        ppdev->hsemLock = NULL;
    }
#endif
//@@END_DDKSPLIT

    
    ENGFREEMEM(ppdev);
}// DrvDisablePDEV()

//-------------------------------Public*Routine--------------------------------
//
// DrvResetPDEV
//
// This function is used by GDI to allow a driver to pass state information
// from one driver instance to the next.
//
// Parameters
//  dhpdevOld---Pointer to the PDEV that describes the physical device to be
//              disabled. This value is the handle returned by DrvEnablePDEV.
//  dhpdevNew---Pointer to the PDEV that describes the physical device to be
//              enabled. This value is the handle returned by DrvEnablePDEV.
//
//  
// Return Value
//  TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL
DrvResetPDEV(DHPDEV  dhpdevOld,
             DHPDEV  dhpdevNew)
{
    PDev*   ppdevOld = (PDev*)dhpdevOld;
    PDev*   ppdevNew = (PDev*)dhpdevNew;
    BOOL    bResult = TRUE;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvResetPDEV(%lx,%lx)",  ppdevOld, ppdevNew));

    // pass state information here:

    // sometimes the new ppdev has already some DeviceBitmaps assigned...
    if (ppdevOld->bDdExclusiveMode)
    {
        bResult = bDemoteAll(ppdevNew);
    }

    // pass information if DirectDraw is in exclusive mode
    // to next active PDEV
    
    if(bResult)
    {
        ppdevNew->bDdExclusiveMode=ppdevOld->bDdExclusiveMode;
    }


    return bResult;

}// DrvResetPDEV()

//-------------------------------Public*Routine--------------------------------
//
// VOID DrvCompletePDEV
//
// This function stores the GDI handle (hdev) of the physical device in dhpdev.
// The driver should retain this handle for use when calling GDI services.
//
// Parameters
//  dhpdev------Identifies the physical device by its handle, which was
//              returned to GDI when it called DrvEnablePDEV. 
//  hdev--------Identifies the physical device that has been installed. This is
//              the GDI handle for the physical device being created. The
//              driver should use this handle when calling GDI functions.
//
// Comments
//  DrvCompletePDEV is called by GDI when its installation of the physical
//  device is complete. It also provides the driver with a handle to the PDEV
//  to be used when requesting GDI services for the device. This function is
//  required for graphics drivers; when GDI calls DrvCompletePDEV, it cannot
//  fail.
//
//-----------------------------------------------------------------------------
VOID
DrvCompletePDEV(DHPDEV dhpdev,
                HDEV   hdev)
{
    PDev*       ppdev = (PDev*)dhpdev;
    
    DBG_GDI((SETUP_LOG_LEVEL, "DrvCompletePDEV(%lx, %lx)", dhpdev, hdev));

    ppdev->hdevEng = hdev;

    if(!g_bOnNT40)
    {
        //
        // Retrieve acceleration level before the surface is enabled.
        //
        EngQueryDeviceAttribute(hdev,
                                QDA_ACCELERATION_LEVEL,
                                NULL,
                                0,
                                (PVOID)&ppdev->dwAccelLevel,
                                sizeof(ppdev->dwAccelLevel));
    }
    DBG_GDI((6, "acceleration level %d", ppdev->dwAccelLevel));
}// DrvCompletePDEV()

//-------------------------------Public*Routine--------------------------------
//
// HSURF DrvEnableSurface
//
// This function sets up a surface to be drawn on and associates it with a
// given PDEV and initializes the hardware.  This is called after DrvEnablePDEV
// and performs the final device initialization.
//
// Parameters
//  dhpdev------Identifies a handle to a PDEV. This value is the return value
//              of DrvEnablePDEV. The PDEV describes the physical device for
//              which a surface is to be created. 
//
// Return Value
//  The return value is a handle that identifies the newly created surface.
//  Otherwise, it is zero, and an error code is logged.
//
// Comments
//  Depending on the device and circumstances, the driver can do any of the
//  following to enable the surface: 
//
//  If the driver manages its own surface, the driver can call
//  EngCreateDeviceSurface to get a handle for the surface.
//  GDI can manage the surface completely if the device has a surface that
//  resembles a standard-format bitmap. The driver can obtain a bitmap handle
//  for the surface by calling EngCreateBitmap with a pointer to the buffer for
//  the bitmap. 
//  GDI can collect the graphics directly onto a GDI bitmap. The driver should
//  call EngCreateBitmap, allowing GDI to allocate memory for the bitmap. This
//  function is generally used only by printer devices. 
//  Any existing GDI bitmap handle is a valid surface handle.
//
//  Before defining and returning a surface, a graphics driver must associate
//  the surface with the physical device using EngAssociateSurface. This GDI
//  function allows the driver to specify which graphics output routines are
//  supported for standard-format bitmaps. A call to this function can only be
//  made when no surface exists for the given physical device.
//
//-----------------------------------------------------------------------------
HSURF
DrvEnableSurface(DHPDEV dhpdev)
{
    PDev*       ppdev;
    HSURF       hsurf;
    SIZEL       sizl;
    Surf*       psurf;
    VOID*       pvTmpBuffer;
    BYTE*       pjScreen;
    LONG        lDelta;
    FLONG       flHooks;
    ULONG       DIBHooks;
    
    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableSurface(%lx)", dhpdev));

    ppdev = (PDev*)dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvEnableSurface: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    if ( !bEnableHardware(ppdev) )
    {
        goto errExit;
    }

    //
    // Initializes the off-screen heap
    //
    if ( !bEnableOffscreenHeap(ppdev) )
    {
        goto errExit;
    }

    //
    // The DSURF for the screen is special.
    //
    // It is custom built here as opposed to being allocated via the
    // heap management calls.
    //
    // NOTE: The video memory for  the screen is reserved up front starting
    //    at zero and thus we do not need to allocate this memory from the
    //    video memory heap.
    //
    // NOTE: The DSURF will not be among the list of all of the other DSURFs
    //    which are allocated dynamically.
    //
    // NIT: remove the dynamic allocation of the DSURF.  Instead, just
    //       declare pdsurfScreen as a DSURF instead of a DSURF*.
    //

    psurf = (Surf*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(Surf), ALLOC_TAG);
    if ( psurf == NULL )
    {
        DBG_GDI((0, "DrvEnableSurface: failed pdsurf memory allocation"));
        goto errExit;
    }

    ppdev->pdsurfScreen = psurf;

    psurf->flags       = SF_VM;
    psurf->ppdev       = ppdev;
    psurf->ulByteOffset= 0;
    psurf->ulPixOffset = 0;
    psurf->lDelta      = ppdev->lDelta;
    psurf->ulPixDelta  = ppdev->lDelta >> ppdev->cPelSize;
    vCalcPackedPP(ppdev->lDelta >> ppdev->cPelSize, NULL, &psurf->ulPackedPP);

    //
    // Create screen SURFOBJ.
    //

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    //
    // On NT4.0 we create a GDI managed bitmap as the primay surface. But
    // on NT5.0 we create a device managed primary.
    //
    // On NT4.0 we still use our driver's accleration capabilities by
    // doing a trick with EngLockSurface on the GDI managed primary.
    //

    if(g_bOnNT40)
    {
        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        (ppdev->lDelta > 0) ? BMF_TOPDOWN : 0,
                                        (PVOID)(ppdev->pjScreen));
    }
    else
    {
        hsurf = (HSURF)EngCreateDeviceSurface((DHSURF)psurf, sizl,
                                              ppdev->iBitmapFormat);
    }
 
    if ( hsurf == 0 )
    {
        DBG_GDI((0, "DrvEnableSurface: failed EngCreateDeviceBitmap"));
        goto errExit;
    }

    //
    // On NT5.0 we call EngModifSurface to expose our device surface to
    // GDI. We cant do this on NT4.0 hence we call EngAssociateSurface.
    //
     
    if(g_bOnNT40)
    {
        //
        // We have to associate the surface we just created with our physical
        // device so that GDI can get information related to the PDEV when
        // it's drawing to the surface (such as, for example, the length of 
        // styles on the device when simulating styled lines).
        //

        //
        // On NT4.0 we dont want to be called to Synchronize Access
        //
        SURFOBJ *psoScreen;
        LONG myflHooks = ppdev->flHooks;
        myflHooks &= ~HOOK_SYNCHRONIZE;

        if (!EngAssociateSurface(hsurf, ppdev->hdevEng, myflHooks))
        {
            DBG_GDI((0, "DrvEnableSurface: failed EngAssociateSurface"));
            goto errExit; 
        }

        //
        // Jam in the value of dhsurf into screen SURFOBJ. We do this to
        // make sure the driver acclerates Drv calls we hook and not
        // punt them back to GDI as the SURFOBJ's dhsurf = 0. 
        //
        ppdev->psoScreen = EngLockSurface(hsurf);
        if(ppdev->psoScreen == 0)
        {
            DBG_GDI((0, "DrvEnableSurface: failed EngLockSurface"));
            goto errExit; 
        }

        ppdev->psoScreen->dhsurf = (DHSURF)psurf;

    }
    else
    {
        //
        // Tell GDI about the screen surface.  This will enable GDI to render
        // directly to the screen.
        //

        if ( !EngModifySurface(hsurf,
                               ppdev->hdevEng,
                               ppdev->flHooks,
                               MS_NOTSYSTEMMEMORY,
                               (DHSURF)psurf,
                               ppdev->pjScreen,
                               ppdev->lDelta,
                               NULL))
        {
            DBG_GDI((0, "DrvEnableSurface: failed EngModifySurface"));
            goto errExit;
        }
    }

    if(MAKE_BITMAPS_OPAQUE)
    {
        SURFOBJ*    surfobj = EngLockSurface(hsurf);

        ASSERTDD(surfobj->iType == STYPE_BITMAP,
                    "expected STYPE_BITMAP");

        surfobj->iType = STYPE_DEVBITMAP;

        EngUnlockSurface(surfobj);
    }


    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    //
    // Allocate some pageable memory for temp space.  This will save
    // us from having to allocate and free the temp space inside high
    // frequency calls.
    //
    pvTmpBuffer = ENGALLOCMEM(0, TMP_BUFFER_SIZE, ALLOC_TAG);

    if ( pvTmpBuffer == NULL )
    {
        DBG_GDI((0, "DrvEnableSurface: failed TmpBuffer allocation"));
        goto errExit;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    //
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...
    //

    if ( !bInitializeHW(ppdev) )
    {
        goto errExit;
    }

    //
    // On NT5.0 bEnablePointer call is made in DrvNotify. On NT4.0 we wont
    // get called with DrvNotify and hence we have to call bInitializePointer
    // now.
    //

    if(g_bOnNT40)
    { 
        if ( !bEnablePointer(ppdev) )
        {
            goto errExit;
        }
    }

    if ( !bEnablePalette(ppdev) )
    {
        goto errExit;
    }

    if (!bEnableText(ppdev))
    {
        goto errExit;
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    DBG_GDI((7, "DrvEnableSurface: done with hsurf=%x", hsurf));
    DBG_GDI((6, "DrvEnableSurface: done with dhpdev = %lx", dhpdev));
    
    DBG_GDI((SETUP_LOG_LEVEL, "DrvEnableSurface(..) return hsurf = %lx", hsurf));
    
    return(hsurf);

errExit:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    DrvDisableSurface((DHPDEV) ppdev);

    DBG_GDI((0, "DrvEnableSurface: failed"));

    
    return(0);
}// DrvEnableSurface()

//-------------------------------Public*Routine--------------------------------
//
// VOID DrvDisableSurface
//
// This function is used by GDI to notify a driver that the surface created
// by DrvEnableSurface for the current device is no longer needed
//
// Parameters
//  dhpdev------Handle to the PDEV that describes the physical device whose
//              surface is to be released. 
//
// Comments
//  The driver should free any memory and resources used by the surface
//  associated with the PDEV as soon as the physical device is disabled.
//
//  If the driver has been disabled by a call to DrvAssertMode, the driver
//  cannot access the hardware during DrvDisablePDEV because another active
//  PDEV might be in use. Any necessary hardware changes should have been
//  performed during the call to DrvAssertMode. A driver should keep track of
//  whether or not it has been disabled by DrvAssertMode so that it can perform
//  proper cleanup operations in DrvDisablePDEV.
//
//  If the physical device has an enabled surface, GDI calls DrvDisableSurface
//  before calling DrvDisablePDEV.
//
//  DrvDisableSurface is required for graphics drivers
//
// Note: In an error case, we may call this before DrvEnableSurface is
//       completely done.
//
//-----------------------------------------------------------------------------
VOID
DrvDisableSurface(DHPDEV dhpdev)
{
    PDev*   ppdev = (PDev*)dhpdev;
    Surf*   psurf = ppdev->pdsurfScreen;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvDisableSurface(%lx)", ppdev));

    //
    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.
    //
    vDisableText(ppdev);
    vDisableHW(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    ENGFREEMEM(ppdev->pvTmpBuffer);

    if(g_bOnNT40)
        EngUnlockSurface(ppdev->psoScreen);

    EngDeleteSurface(ppdev->hsurfScreen);
    ppdev->hsurfScreen = NULL;

    ENGFREEMEM(psurf);
}// DrvDisableSurface()

//-------------------------------Public*Routine--------------------------------
//
// BOOL DrvAssertMode
//
// This function sets the mode of the specified physical device to either the
// mode specified when the PDEV was initialized or to the default mode of the
// hardware.
//
// Parameters
//
//  dhpdev------Identifies the PDEV describing the hardware mode that should be
//              set.
//  bEnable-----Specifies the mode to which the hardware is to be set. If this
//              parameter is TRUE, then the hardware is set to the original
//              mode specified by the initialized PDEV. Otherwise, the hardware
//              is set to its default mode so the video miniport driver can
//              assume control. 
//
// Comments
//  GDI calls DrvAssertMode when it is required to switch among multiple
//  desktops on a single display surface. To switch from one PDEV to another,
//  GDI calls DrvAssertMode with the bEnable parameter set to FALSE for one
//  PDEV, and TRUE for the other. To revert to the original PDEV, DrvAssertMode
//  is called with bEnable set to FALSE, followed by another call to
//  DrvAssertMode, with bEnable set to TRUE and dhpdev set to the original PDEV
//
//  If the physical device is palette-managed, GDI should call DrvSetPalette to
//  reset the device's palette. The driver does not then need to keep track of
//  the current pointer state because the Window Manager selects the correct
//  pointer shape and moves it to the current position. The Console Manager
//  ensures that desktops are properly redrawn.
//
//  DrvAssertMode is required for display drivers
//
//-----------------------------------------------------------------------------
BOOL
DrvAssertMode(DHPDEV  dhpdev,
              BOOL    bEnable)
{
    PDev*   ppdev = (PDev*)dhpdev;
    BOOL    bRet = FALSE;

    DBG_GDI((SETUP_LOG_LEVEL, "DrvAssertMode(%lx, %lx)", dhpdev, bEnable));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvAssertMode: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    if ( !bEnable )
    {
        //
        // bEnable == FALSE. The hardware is set to its default mode so the
        // video miniport driver can assume control.
        //
        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);
        vAssertModeText(ppdev, FALSE);

        if ( bAssertModeOffscreenHeap(ppdev, FALSE) )
        {
            vAssertModeHW(ppdev, FALSE);

            if ( bAssertModeHardware(ppdev, FALSE) )
            {
                ppdev->bEnabled = FALSE;
                bRet = TRUE;

                goto done;
            }

            //
            // We failed to switch to full-screen.  So undo everything:
            //
            vAssertModeHW(ppdev, TRUE);
        }                                           //   return code with TRUE

        bEnablePointer(ppdev);
        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);
    }// if ( !bEnable )
    else
    {
        //
        // bEnable == TRUE means the hardware is set to the original mode
        // specified by the initialized PDEV
        //
        // Switch back to graphics mode
        //
        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:
        //
        // NOTE: We defer the enabling of the brush and pointer cache
        //       to DrvNotify.  The direct draw heap is not valid
        //       at this point.
        //
        if ( bAssertModeHardware(ppdev, TRUE) )
        {
            vAssertModeHW(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            bRet = TRUE;
        }
    }// bEnable == TRUE

done:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    return(bRet);

}// DrvAssertMode()

//-------------------------------Public*Routine--------------------------------
//
// ULONG DrvGetModes
//
// This function lists the modes supported by the device.
//
// Parameters:
//
//  hDriver-----Specifies the handle to the kernel driver for which the modes
//              must be enumerated. This is the handle that is passed in the
//              hDriver parameter of the DrvEnablePDEV function. 
//  cjSize------Specifies the size, in bytes, of the buffer pointed to by pdm.
//  pdm---------Points to the buffer in which DEVMODEW structures will be
//              written. 
//
// Return Value
//  The return value is the count of bytes written to the buffer, or, if pdm is
//  null, the number of bytes required to hold all mode data. If an error
//  occurs, the return value is zero, and an error code is logged
//
//-----------------------------------------------------------------------------
ULONG
DrvGetModes(HANDLE      hDriver,
            ULONG       cjSize,
            DEVMODEW*   pdm)
{
    DWORD                   cModes;
    DWORD                   cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // How many MODEs the caller wants us to fill
    //
    DWORD                   cOutputModes = cjSize
                                    / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD                   cbModeSize;

    DBG_GDI((7, "DrvGetModes"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION*)&pVideoModeInformation,
                               &cbModeSize);
    if ( cModes == 0 )
    {
        DBG_GDI((0, "DrvGetModes: failed to get mode information"));
        return(0);
    }

    if ( pdm == NULL )
    {
        //
        // GDI only wants to know the number of bytes required to hold all
        // mode data at this moment
        //
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //
        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if ( pVideoTemp->Length != 0 )
            {
                //
                // If the caller's buffer is filled up, we should quit now
                //
                if ( cOutputModes == 0 )
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //
                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion = DM_SPECVERSION;
                pdm->dmDriverVersion = DM_SPECVERSION;

                //
                // We currently do not support Extra information in the driver
                //
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes
                                        * pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;
                pdm->dmPanningWidth     = pdm->dmPelsWidth;
                pdm->dmPanningHeight    = pdm->dmPelsHeight;

                pdm->dmFields           = DM_BITSPERPEL
                                        | DM_PELSWIDTH
                                        | DM_PELSHEIGHT
                                        | DM_DISPLAYFREQUENCY
                                        | DM_DISPLAYFLAGS;
                //
                // Go to the next DEVMODE entry in the buffer.
                //
                cOutputModes--;

                pdm = (LPDEVMODEW)(((UINT_PTR)pdm) + sizeof(DEVMODEW)
                                                   + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
            }// if ( pVideoTemp->Length != 0 )

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                         (((PUCHAR)pVideoTemp) + cbModeSize);
        } while (--cModes);
    }// pbm != NULL

    ENGFREEMEM(pVideoModeInformation);

    return(cbOutputSize);
}// DrvGetModes()

//-----------------------------------------------------------------------------
//
// BOOL bAssertModeHardware
//
// Sets the appropriate hardware state for graphics mode or full-screen.
//
//-----------------------------------------------------------------------------
BOOL
bAssertModeHardware(PDev* ppdev, BOOL  bEnable)
{
    DWORD                   dLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    
    PERMEDIA_DECL;

    DBG_GDI((6, "bAssertModeHardware: bEnable = %d", bEnable));

    if ( bEnable )
    {
        //
        // Call the miniport via an IOCTL to set the graphics mode.
        //
        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_SET_CURRENT_MODE,
                                &ppdev->ulMode,  // input buffer
                                sizeof(DWORD),
                                NULL,
                                0,
                                &dLength) )
        {
            DBG_GDI((0, "bAssertModeHardware: failed VIDEO_SET_CURRENT_MODE"));
            goto errExit;
        }

        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_CURRENT_MODE,
                                NULL,
                                0,
                                &VideoModeInfo,
                                sizeof(VideoModeInfo),
                                &dLength) )
        {
            DBG_GDI((0,"bAssertModeHardware: failed VIDEO_QUERY_CURRENT_MODE"));
            goto errExit;
        }

        //
        // The following variables are determined only after the initial
        // modeset
        // Note: here lVidMemWidth and lVidMemHeight are in "pixel" unit, not
        // bytes
        //
        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;        
        ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->lVidMemWidth = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->lVidMemHeight = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->lDelta = VideoModeInfo.ScreenStride;
        ppdev->flCaps = VideoModeInfo.DriverSpecificAttributeFlags;
        
        DBG_GDI((7, "bAssertModeHardware: Got flCaps 0x%x", ppdev->flCaps));

        DBG_GDI((7, "bAssertModeHardware: using %s pointer",
                 (ppdev->flCaps & CAPS_SW_POINTER) ?
                 "GDI Software Cursor":
                 (ppdev->flCaps & CAPS_TVP4020_POINTER) ?
                 "TI TVP4020" :
                 (ppdev->flCaps & CAPS_P2RD_POINTER) ?
                 "3Dlabs P2RD" : "unknown"));
    }
    else
    {
        //
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:
        //
        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_RESET_DEVICE,
                                NULL,
                                0,
                                NULL,
                                0,
                                &ulReturn) )
        {
            DBG_GDI((0, "bAssertModeHardware: failed reset IOCTL"));
            goto errExit;
        }
    }

    return(TRUE);

errExit:
    DBG_GDI((0, "bAssertModeHardware: failed"));

    return(FALSE);
}// bAssertModeHardware()

//-----------------------------------------------------------------------------
//
// BOOL bEnableHardware
//
// Puts the hardware in the requested mode and initializes it.
//
// Note: This function Should be called before any access is done to the
// hardware from the display driver
//
//-----------------------------------------------------------------------------
BOOL
bEnableHardware(PDev* ppdev)
{
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    DWORD                       dLength;    
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[3];
    
    DBG_GDI((7, "bEnableHardware"));

    //
    // Map control registers into virtual memory:
    //
    VideoMemory.RequestedVirtualAddress = NULL;

    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                            &VideoMemory,               // input buffer
                            sizeof(VIDEO_MEMORY),
                            &VideoAccessRange[0],       // output buffer
                            sizeof (VideoAccessRange),
                            &dLength) )
    {
        DBG_GDI((0,"bEnableHardware: query failed"));
        goto errExit;
    }

    ppdev->pulCtrlBase[0] = (ULONG*)VideoAccessRange[0].VirtualAddress;
    ppdev->pulCtrlBase[1] = (ULONG*)VideoAccessRange[1].VirtualAddress;
    ppdev->pulDenseCtrlBase = (ULONG*)VideoAccessRange[2].VirtualAddress;
        
    ppdev->pulInputDmaCount = ppdev->pulCtrlBase[0] + (PREG_INDMACOUNT>>2);
    ppdev->pulInputDmaAddress = ppdev->pulCtrlBase[0] + (PREG_INDMAADDRESS>>2);
    ppdev->pulFifo = ppdev->pulCtrlBase[0] + (PREG_FIFOINTERFACE>>2);
    ppdev->pulOutputFifoCount = ppdev->pulCtrlBase[0] + (PREG_OUTFIFOWORDS>>2);
    ppdev->pulInputFifoCount = ppdev->pulCtrlBase[0] + (PREG_INFIFOSPACE>>2);
    
    DBG_GDI((7, "bEnableHardware: mapped control registers[0] at 0x%x",
            ppdev->pulCtrlBase[0]));
    DBG_GDI((7, "                 mapped registers[1] at 0x%x",
            ppdev->pulCtrlBase[1]));
    DBG_GDI((7, "                 mapped dense control registers at 0x%x",
            ppdev->pulDenseCtrlBase));

    //
    // Get the linear memory address range.
    //
    VideoMemory.RequestedVirtualAddress = NULL;

    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                            &VideoMemory,      // input buffer
                            sizeof(VIDEO_MEMORY),
                            &VideoMemoryInfo,  // output buffer
                            sizeof(VideoMemoryInfo),
                            &dLength) )
    {
        DBG_GDI((0, "bEnableHardware: error mapping buffer address"));
        goto errExit;
    }

    DBG_GDI((7, "bEnableHardware: frameBufferBase addr = %lx",
              VideoMemoryInfo.FrameBufferBase));
    DBG_GDI((7, "                 frameBufferLength = %l",
              VideoMemoryInfo.FrameBufferLength));
    DBG_GDI((7, "                 videoRamBase addr = %lx",
              VideoMemoryInfo.VideoRamBase));
    DBG_GDI((7, "                 videoRamLength = %l",
              VideoMemoryInfo.VideoRamLength));

    //
    // Record the Frame Buffer Linear Address.
    //
    ppdev->pjScreen = (BYTE*)VideoMemoryInfo.FrameBufferBase;
    ppdev->FrameBufferLength = VideoMemoryInfo.FrameBufferLength;

    //
    // Set hardware states, like ppdev->lVidMemWidth, lVidMemHeight, cxMemory,
    // cyMemory etc
    //
    if ( !bAssertModeHardware(ppdev, TRUE) )
    {
        goto errExit;
    }

    DBG_GDI((7, "bEnableHardware: width = %li height = %li",
             ppdev->cxMemory, ppdev->cyMemory));

    DBG_GDI((7, "bEnableHardware: stride = %li flCaps = 0x%lx",
             ppdev->lDelta, ppdev->flCaps));
    
    return (TRUE);

errExit:

    DBG_GDI((0, "bEnableHardware: failed"));

    return (FALSE);
}// bEnableHardware()

//-----------------------------------------------------------------------------
//
// VOID vDisableHardware
//
// Undoes anything done in bEnableHardware.
//
// Note: In an error case, we may call this before bEnableHardware is
//       completely done.
//
//-----------------------------------------------------------------------------
VOID
vDisableHardware(PDev* ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[3];

    DBG_GDI((6, "vDisableHardware"));

    if (ppdev->pjScreen) 
    {
        VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;
        if ( EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                                &VideoMemory[0],
                                sizeof(VIDEO_MEMORY),
                                NULL,
                                0,
                                &ReturnedDataLength))
        {
            DBG_GDI((0, "vDisableHardware: failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->pulCtrlBase[0];
    VideoMemory[1].RequestedVirtualAddress = ppdev->pulCtrlBase[1];
    VideoMemory[2].RequestedVirtualAddress = ppdev->pulDenseCtrlBase;

    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                            &VideoMemory[0],
                            sizeof(VideoMemory),
                            NULL,
                            0,
                            &ReturnedDataLength) )
    {
        DBG_GDI((0, "vDisableHardware: failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }
}// vDisableHardware()

//-----------------------------------------------------------------------------
//
// ULONG ulLog2(ULONG ulVal)
//
// Returns the log base 2 of the given value.  The ulVal must be a power of
// two otherwise the return value is undefined.  If ulVal is zero the return
// value is undefined.
//
//-----------------------------------------------------------------------------
ULONG
ulLog2(ULONG ulVal)
{
    ULONG   ulLog2 = 0;
    ULONG   ulTemp = ulVal >> 1;

    while( ulTemp )
    {
        ulTemp >>= 1;
        ulLog2++;
    }

    ASSERTDD(ulVal == (1UL << ulLog2), "ulLog2: bad value given");

    return ulLog2;
}// ulLog2()

//-----------------------------------------------------------------------------
//
// BOOL bInitializeModeFields
//
// Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
// devinfo based on the requested mode.
//
//-----------------------------------------------------------------------------
BOOL
bInitializeModeFields(PDev*     ppdev,
                      GDIINFO*  pgdi,
                      DEVINFO*  pdi,
                      DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    VIDEO_MODE_INFORMATION  vmi;
    ULONG                   cbModeSize;
    BOOL                    bSelectDefault; // Used for NT4.0 compat only


    DBG_GDI((6, "bInitializeModeFields"));

    //
    // Call the miniport to get mode information, result will be in
    // "pVideoBuffer"
    //
    // Note: the lower level function allocates memory for us in "pVideoBuffer"
    // so we should take care of this later
    //
    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if ( cModes == 0 )
    {
        goto errExit;
    }

    //
    // Now see if the requested mode has a match in that table.
    //
    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if(g_bOnNT40)
    {
        if ( (pdm->dmPelsWidth        == 0)
           &&(pdm->dmPelsHeight       == 0)
           &&(pdm->dmBitsPerPel       == 0)
           &&(pdm->dmDisplayFrequency == 0) )
        {
            DBG_GDI((2, "bInitializeModeFields: default mode requested"));
            bSelectDefault = TRUE;
        }
        else
        {
            DBG_GDI((2, "bInitializeModeFields: Request width = %li height = %li",
                 pdm->dmPelsWidth, pdm->dmPelsHeight));
            DBG_GDI((2, "                               bpp = %li frequency = %li",
                 pdm->dmBitsPerPel, pdm->dmDisplayFrequency));

            bSelectDefault = FALSE;
        }
    }
    else
    {
        //
        // On NT5.0 we should never get an old sytle default mode request. 
        //
        ASSERTDD(pdm->dmPelsWidth        != 0 &&
                 pdm->dmPelsHeight       != 0 &&
                 pdm->dmBitsPerPel       != 0 &&
                 pdm->dmDisplayFrequency != 0,
                 "bInitializeModeFields: old style default mode request");
    }

    while ( cModes-- )
    {
        if ( pVideoTemp->Length != 0 )
        {
            DBG_GDI((7, "bInitializeModeFields: check width = %li height = %li",
                     pVideoTemp->VisScreenWidth,
                     pVideoTemp->VisScreenHeight));
            DBG_GDI((7, "                             bpp = %li freq = %li",
                     pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes,
                     pVideoTemp->Frequency));
            //
            // Handle old style default mode case only on NT4.0
            //
            if(g_bOnNT40 && bSelectDefault)
            {
                pVideoModeSelected = pVideoTemp;
                DBG_GDI((7, "bInitializeModeFields: found a mode match(default)"));
                break;
            }

            if ( (pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth)
              && (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight)
              && (pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes
                                                     == pdm->dmBitsPerPel)
              && (pVideoTemp->Frequency == pdm->dmDisplayFrequency) )
            {
                pVideoModeSelected = pVideoTemp;
                DBG_GDI((7, "bInitializeModeFields: found a mode match!"));
                break;
            }
        }//  if the video mode info structure buffer is not empty

        //
        // Move on to next video mode structure
        //
        pVideoTemp = (PVIDEO_MODE_INFORMATION)(((PUCHAR)pVideoTemp)
                                               + cbModeSize);
    }// while ( cModes-- )

    //
    // If no mode has been found, return an error
    //
    if ( pVideoModeSelected == NULL )
    {
        DBG_GDI((0, "bInitializeModeFields: couldn't find a mode match!"));
        ENGFREEMEM(pVideoBuffer);
        
        goto errExit;
    }

    //
    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.
    //
    vmi = *pVideoModeSelected;
    ENGFREEMEM(pVideoBuffer);

    //
    // Set up screen information from the mini-port:
    //
    ppdev->ulMode           = vmi.ModeIndex;
    ppdev->cxScreen         = vmi.VisScreenWidth;
    ppdev->cyScreen         = vmi.VisScreenHeight;
    ppdev->cBitsPerPel      = vmi.BitsPerPlane;

    DBG_GDI((7, "bInitializeModeFields: screenStride = %li", vmi.ScreenStride));

    ppdev->flHooks          = HOOK_SYNCHRONIZE
                            | HOOK_FILLPATH
                            | HOOK_STROKEPATH
                            | HOOK_LINETO                            
                            | HOOK_TEXTOUT
                            | HOOK_BITBLT
                            | HOOK_COPYBITS;

    if(!g_bOnNT40)
        ppdev->flHooks |=  HOOK_TRANSPARENTBLT |
                           HOOK_ALPHABLEND     |
                           HOOK_STRETCHBLT     |
                           HOOK_GRADIENTFILL;
    //
    // Fill in the GDIINFO data structure with the default 8bpp values:
    //
    *pgdi = ggdiDefault;

    //
    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:
    //
    pgdi->ulHorzSize        = vmi.XMillimeter;
    pgdi->ulVertSize        = vmi.YMillimeter;
    pgdi->ulHorzRes         = vmi.VisScreenWidth;
    pgdi->ulVertRes         = vmi.VisScreenHeight;
    pgdi->ulPanningHorzRes  = vmi.VisScreenWidth;
    pgdi->ulPanningVertRes  = vmi.VisScreenHeight;

    pgdi->cBitsPixel        = vmi.BitsPerPlane;
    pgdi->cPlanes           = vmi.NumberOfPlanes;
    pgdi->ulVRefresh        = vmi.Frequency;

    pgdi->ulDACRed          = vmi.NumberRedBits;
    pgdi->ulDACGreen        = vmi.NumberGreenBits;
    pgdi->ulDACBlue         = vmi.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    //
    // Fill in the devinfo structure with the default 8bpp values:
    //
    *pdi = gdevinfoDefault;

    //
    // Bytes per pel 4/2/1 for 32/16/8 bpp
    //

    ppdev->cjPelSize        = vmi.BitsPerPlane >> 3;

    //
    // Bytes per pel log 2  
    //

    ppdev->cPelSize         = ulLog2(ppdev->cjPelSize);
    
    //
    // = 2,1,0 for 32,16,8 depth.  Shifts needed to calculate bytes/pixel
    //
    ppdev->bPixShift = (BYTE) ppdev->cPelSize;

    //
    // = 0,1,2 for 32/16/8.
    //
    ppdev->bBppShift = 2 - ppdev->bPixShift;
    
    //
    // = 3,1,0 for 8,16,32 bpp
    //
    ppdev->dwBppMask = 3 >> ppdev->bPixShift;
    
    
    switch ( vmi.BitsPerPlane )
    {
        case 8:
            ppdev->iBitmapFormat   = BMF_8BPP;

            ASSERTDD(vmi.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN,
                     "bInitializeModeFields: unexpected non-palette 8bpp mode");
                
            ppdev->ulWhite         = 0xff;
            
            ppdev->ulPermFormat = PERMEDIA_8BIT_PALETTEINDEX;
            ppdev->ulPermFormatEx = PERMEDIA_8BIT_PALETTEINDEX_EXTENSION;

            if(g_bOnNT40)
                pdi->flGraphicsCaps &= ~GCAPS_COLOR_DITHER;

            // No AntiAliased text support in 8bpp mode. 
            pdi->flGraphicsCaps &= ~GCAPS_GRAY16;
            break;

        case 16:            
            ppdev->iBitmapFormat   = BMF_16BPP;
            ppdev->flRed           = vmi.RedMask;
            ppdev->flGreen         = vmi.GreenMask;
            ppdev->flBlue          = vmi.BlueMask;

            pgdi->ulNumColors      = (ULONG)-1;
            pgdi->ulNumPalReg      = 0;
            pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

            pdi->iDitherFormat     = BMF_16BPP;
            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

            // support gamma ramp changes
            pdi->flGraphicsCaps2  |= GCAPS2_CHANGEGAMMARAMP;

            ppdev->ulWhite         = vmi.RedMask
                                   | vmi.GreenMask
                                   | vmi.BlueMask;

            ppdev->ulPermFormat = PERMEDIA_565_RGB;
            ppdev->ulPermFormatEx = PERMEDIA_565_RGB_EXTENSION;

            break;

        case 32:            
            ppdev->iBitmapFormat   = BMF_32BPP;

            ppdev->flRed           = vmi.RedMask;
            ppdev->flGreen         = vmi.GreenMask;
            ppdev->flBlue          = vmi.BlueMask;            

            pgdi->ulNumColors      = (ULONG)-1;
            pgdi->ulNumPalReg      = 0;
            pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

            pdi->iDitherFormat     = BMF_32BPP;
            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

            //
            // Support gamma ramp changes
            //
            pdi->flGraphicsCaps2  |= GCAPS2_CHANGEGAMMARAMP;
            
            ppdev->ulWhite         = vmi.RedMask
                                   | vmi.GreenMask
                                   | vmi.BlueMask;
            
            ppdev->ulPermFormat = PERMEDIA_888_RGB;
            ppdev->ulPermFormatEx = PERMEDIA_888_RGB_EXTENSION;

            break;

        default:
            ASSERTDD(0, "bInitializeModeFields: bit depth not supported");
            goto errExit;
    }// switch on clor depth


    return(TRUE);

errExit:
    
    DBG_GDI((0, "bInitializeModeFields: failed"));

    return(FALSE);
}// bInitializeModeFields()

//-----------------------------------------------------------------------------
//
// DWORD getAvailableModes
//
// Calls the miniport to get the list of modes supported by the kernel driver.
// Prunes the list to only those modes supported by this driver.
//
// Returns the number of entries supported and returned in the
// modeInformation array.  If the return value is non-zero, then
// modeInformation was set to point to a valid mode information array. It is
// the responsibility of the caller to free this array when it is no longer
// needed.
//
//-----------------------------------------------------------------------------
DWORD
getAvailableModes(HANDLE                    hDriver,
                  PVIDEO_MODE_INFORMATION*  modeInformation,
                  DWORD*                    cbModeSize)
{
    ULONG                    ulTemp;
    VIDEO_NUM_MODES          modes;
    PVIDEO_MODE_INFORMATION  pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //
    if ( EngDeviceIoControl(hDriver,
                            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                            NULL,
                            0,
                            &modes,
                            sizeof(VIDEO_NUM_MODES),
                            &ulTemp) )
    {
        DBG_GDI((0, "getAvailableModes: failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //
    *modeInformation = (VIDEO_MODE_INFORMATION*)ENGALLOCMEM(FL_ZERO_MEMORY,
                                modes.NumModes  * modes.ModeInformationLength,
                                ALLOC_TAG);

    if ( *modeInformation == (PVIDEO_MODE_INFORMATION)NULL )
    {
        DBG_GDI((0, "getAvailableModes: fFailed memory allocation"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //
    if ( EngDeviceIoControl(hDriver,
                            IOCTL_VIDEO_QUERY_AVAIL_MODES,
                            NULL,
                            0,
                            *modeInformation,
                            modes.NumModes * modes.ModeInformationLength,
                            &ulTemp) )
    {
        DBG_GDI((0, "getAvailableModes: failed VIDEO_QUERY_AVAIL_MODES"));

        ENGFREEMEM(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION)NULL;

        return (0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // A non-supported mode is invalidated by setting the length to 0.
    //
    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16 or 32 bits per pel.
    //
    while ( ulTemp-- )
    {
        if ( (pVideoTemp->NumberOfPlanes != 1 )
           ||!(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS)
           ||(  (pVideoTemp->BitsPerPlane != 8)              
              &&(pVideoTemp->BitsPerPlane != 16)
              &&(pVideoTemp->BitsPerPlane != 32))
           || (pVideoTemp->VisScreenWidth > 2000)
           || (pVideoTemp->VisScreenHeight > 2000) )
        {
            DBG_GDI((2, "getAvailableModes: rejecting miniport mode"));
            DBG_GDI((2, "                   width = %li height = %li",
                     pVideoTemp->VisScreenWidth,
                     pVideoTemp->VisScreenHeight));
            DBG_GDI((2, "                   bpp = %li freq = %li",
                     pVideoTemp->BitsPerPlane * pVideoTemp->NumberOfPlanes,
                     pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
                     (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return (modes.NumModes);
}// getAvailableModes()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvNotify
//
//-----------------------------------------------------------------------------
VOID
DrvNotify(SURFOBJ*  pso,
          ULONG     iType,
          PVOID     pvData)
{
    PPDev   ppdev = (PPDev) pso->dhpdev;

    switch( iType )
    {   
        case DN_DEVICE_ORIGIN:
        {
            ppdev->ptlOrigin = *((POINTL*) pvData);
            
            DBG_GDI((6,"DrvNotify: origin at %ld, %ld",
                    ppdev->ptlOrigin.x, ppdev->ptlOrigin.y));
        }
            break;

        case DN_DRAWING_BEGIN:
        {
            bEnablePointer(ppdev);
            bEnableBrushCache(ppdev);
        }
            break;
    
        default:
            // do nothing
            break;
    }
}// DrvNotify()


//-----------------------------Public*Routine----------------------------------
//
// ULONG DrvResetDevice
//
// This function is used by GDI to request that the specified device be
// reset to an operational state.  Safe steps should be taken to keep
// data loss at a minimum.  It may be called anytime between DrvEnablePDEV
// and DrvDisablePDEV.
//
// Parameters
//  dhpdev------Identifies a handle to a PDEV. This value is the return value
//              of DrvEnablePDEV. The PDEV describes the physical device for
//              which a reset is requested. 
//
// Upon successful reset of the device DRD_SUCCESS should be returned.
// Otherwise return DRD_ERROR.
//
//-----------------------------------------------------------------------------

ULONG
DrvResetDevice(
    DHPDEV dhpdev,
    PVOID Reserved
    )
{
    DBG_GDI((0, "DrvResetDevice called."));

    // TODO: Place code to reset device here.

    return DRD_ERROR;
}// DrvResetDevice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\fillpath.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: fillpath.c
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved. 
\*****************************************************************************/
// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles

#include "precomp.h"
#include "log.h"
#include "gdi.h"
#include "clip.h"
#define ALLOC_TAG ALLOC_TAG_IF2P
//-----------------------------Public*Routine----------------------------------
//
// DrvFillPath
//
// This function fills the specified path with the specified brush and ROP.
// This function detects single convex polygons, and will call to separate
// faster convex polygon code for those cases.  This routine also detects
// polygons that are really rectangles, and handles those separately as well.
//
// Parameters
//  pso---------Points to a SURFOBJ structure that defines the surface on which
//              to draw. 
//  ppo---------Points to a PATHOBJ structure that defines the path to be filled
//              The PATHOBJ_Xxx service routines are provided to enumerate the
//              lines, Bezier curves, and other data that make up the path. 
//  pco---------Points to a CLIPOBJ structure. The CLIPOBJ_Xxx service routines
//              are provided to enumerate the clip region as a set of rectangles. 
//  pbo---------Points to a BRUSHOBJ structure that defines the pattern and
//              colors to fill with. 
//  pptlBrushOrg-Points to a POINTL structure that defines the brush origin,
//              which is used to align the brush pattern on the device. 
//  mix---------Defines the foreground and background raster operations to use
//              for the brush. 
//  flOptions---Specifies either FP_WINDINGMODE, indicating that a winding mode
//              fill should be performed, or FP_ALTERNATEMODE, indicating that
//              an alternating mode fill should be performed. All other flags
//              should be ignored. 
//
// Return Value
//  The return value is TRUE if the driver is able to fill the path. If the
//  path or clipping is too complex to be handled by the driver and should be
//  handled by GDI, the return value is FALSE, and an error code is not logged.
//  If the driver encounters an unexpected error, such as not being able to
//  realize the brush, the return value is DDI_ERROR, and an error code is
//  logged.
//
// Comments
//  GDI can call DrvFillPath to fill a path on a device-managed surface. When
//  deciding whether to call this function, GDI compares the fill requirements
//  with the following flags in the flGraphicsCaps member of the DEVINFO
//  structure: GCAPS_BEZIERS, GCAPS_ALTERNATEFILL, and GCAPS_WINDINGFILL.
//
//  The mix mode defines how the incoming pattern should be mixed with the data
//  already on the device surface. The MIX data type consists of two ROP2 values
//  packed into a single ULONG. The low-order byte defines the foreground raster
//  operation; the next byte defines the background raster operation.
//
//  Multiple polygons in a path cannot be treated as being disjoint; The fill
//  must consider all the points in the path.  That is, if the path contains
//  multiple polygons, you cannot simply draw one polygon after the other
//  (unless they don't overlap).
//
//  This function is an optional entry point for the driver. but is recommended
//  for good performance. To get GDI to call this function, not only do you
//  have to HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
//  GCAPS_WINDINGFILL.
//
//-----------------------------------------------------------------------------
BOOL
DrvFillPath(SURFOBJ*    pso,
            PATHOBJ*    ppo,
            CLIPOBJ*    pco,
            BRUSHOBJ*   pbo,
            POINTL*     pptlBrush,
            MIX         mix,
            FLONG       flOptions)
{
    GFNPB   pb;
    BYTE    jClipping;      // Clipping type
    EDGE*   pCurrentEdge;
    EDGE    AETHead;        // Dummy head/tail node & sentinel for Active Edge
                            // Table
    EDGE*   pAETHead;       // Pointer to AETHead
    EDGE    GETHead;        // Dummy head/tail node & sentinel for Global Edge
                            // Table
    EDGE*   pGETHead;       // Pointer to GETHead
    EDGE*   pFreeEdges = NULL; // Pointer to memory free for use to store edges
    ULONG   ulNumRects;     // # of rectangles to draw currently in rectangle
                            // list
    RECTL*  prclRects;      // Pointer to start of rectangle draw list
    INT     iCurrentY;      // Scan line for which we're currently scanning out
                            // the fill

    BOOL        bMore;
    PATHDATA    pd;
    RECTL       ClipRect;
    PDev*       ppdev;

    BOOL        bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL        bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG       flFirstRecord;
    POINTFIX*   pPtFxTmp;
    ULONG       ulPtFxTmp;
    POINTFIX    aptfxBuf[NUM_BUFFER_POINTS];
    ULONG       ulRop4;

    DBG_GDI((6, "DrvFillPath called"));

    pb.psurfDst = (Surf*)pso->dhsurf;

    pb.pco = pco;
    ppdev = pb.psurfDst->ppdev;
    pb.ppdev = ppdev;
    pb.ulRop4 = gaMix[mix & 0xFF] | (gaMix[mix >> 8] << 8);
    ulRop4 = pb.ulRop4;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvBitBlt: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(ppdev);

    //
    // There's nothing to do if there are only one or two points
    //
    if ( ppo->cCurves <= 2 )
    {
        goto ReturnTrue;
    }

    //
    // Pass the surface off to GDI if it's a device bitmap that we've uploaded
    // to the system memory.
    //    
    if ( pb.psurfDst->flags == SF_SM )
    {
        DBG_GDI((1, "dest surface is in system memory. Punt it back"));

//@@BEGIN_DDKSPLIT
        #if MULTITHREADED
            pb.ppdev->ulLockCount--;
            EngReleaseSemaphore(pb.ppdev->hsemLock);
        #endif
//@@END_DDKSPLIT
        
        return ( EngFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions));
    }

    //
    // Set up the clipping
    //
    if ( pco == (CLIPOBJ*)NULL )
    {
        //
        // No CLIPOBJ provided, so we don't have to worry about clipping
        //
        jClipping = DC_TRIVIAL;
    }
    else
    {
        //
        // Use the CLIPOBJ-provided clipping
        //
        jClipping = pco->iDComplexity;
    }
    
    //
    // Now we are sure the surface we are going to draw is in the video memory
    //
    // Set default fill as solid fill
    //
    pb.pgfn = vSolidFillWithRop;
    pb.solidColor = 0;    //Assume we don't need a pattern
    pb.prbrush = NULL;

    //
    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this
    //
    PATHOBJ_vEnumStart(ppo);
    bMore = PATHOBJ_bEnum(ppo, &pd);

    //
    // First we need to check if we need a pattern or not
    //
    if ( (((ulRop4 & 0xff00) >> 8) != (ulRop4 & 0x00ff))
      || ((((ulRop4 >> 4) ^ (ulRop4)) & 0xf0f) != 0) )
    {
        pb.solidColor = pbo->iSolidColor;

        //
        // Check to see if it is a non-solid brush (-1)
        //
        if ( pbo->iSolidColor == -1 )
        {
            //
            // Get the driver's realized brush
            //
            pb.prbrush = (RBrush*)pbo->pvRbrush;

            //
            // If it hasn't been realized, do it
            // Note: GDI will call DrvRealizeBrsuh to fullfill this task. So the
            // driver should have this function ready
            //
            if ( pb.prbrush == NULL )
            {
                DBG_GDI((7, "Realizing brush"));

                pb.prbrush = (RBrush*)BRUSHOBJ_pvGetRbrush(pbo);
                if ( pb.prbrush == NULL )
                {
                    //
                    // If we can't realize it, nothing we can do
                    //

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
                    pb.ppdev->ulLockCount--;
                    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

                    return(FALSE);
                }
                DBG_GDI((7, "Brsuh realizing done"));
            }// Realize brush

            pb.pptlBrush = pptlBrush;

            //
            // Check if brush pattern is 1 BPP or not
            // Note: This is set in DrvRealizeBrush
            //
            if ( pb.prbrush->fl & RBRUSH_2COLOR )
            {
                //
                // 1 BPP pattern. Do a Mono fill
                //
                pb.pgfn = vMonoPatFill;
            }
            else
            {
                //
                // Pattern is more than 1 BPP. Do color pattern fill
                //
                pb.pgfn = vPatFill;
                DBG_GDI((7, "Skip Fast Fill Color Pattern"));

                //
                // P2 can not handle fast filled patterns
                //
                goto SkipFastFill;
            }
        }// Handle non-solid brush
    }// Blackness check

    //
    // For solid brush, we can use FastFill
    //
    if ( bMore )
    {
        //
        // FastFill only knows how to take a single contiguous buffer
        // of points.  Unfortunately, GDI sometimes hands us paths
        // that are split over multiple path data records.  Convex
        // figures such as Ellipses, Pies and RoundRects are almost
        // always given in multiple records.  Since probably 90% of
        // multiple record paths could still be done by FastFill, for
        // those cases we simply copy the points into a contiguous
        // buffer...
        //
        // First make sure that the entire path would fit in the
        // temporary buffer, and make sure the path isn't comprised
        // of more than one subpath:
        //
        if ( (ppo->cCurves >= NUM_BUFFER_POINTS)
           ||(pd.flags & PD_ENDSUBPATH) )
        {
            goto SkipFastFill;
        }

        pPtFxTmp = &aptfxBuf[0];

        //
        // Copy one vertex over to pPtFxTmp from pd(path data)
        //
        RtlCopyMemory(pPtFxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

        //
        // Move the memory pointer over to next structure
        //
        pPtFxTmp     += pd.count;
        ulPtFxTmp     = pd.count;
        flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

        //
        // Loop to get all the vertex info. After the loop, all the vertex info
        // will be in array aptfxBuf[]
        //
        do
        {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            RtlCopyMemory(pPtFxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
            ulPtFxTmp += pd.count;
            pPtFxTmp += pd.count;
        } while ( !(pd.flags & PD_ENDSUBPATH) );

        //
        // Fake up the path data record
        //
        pd.pptfx  = &aptfxBuf[0];
        pd.count  = ulPtFxTmp;
        pd.flags |= flFirstRecord;

        //
        // If there's more than one subpath, we can't call FastFill
        //
        DBG_GDI((7, "More than one subpath!"));
        if ( bMore )
        {
            goto SkipFastFill;
        }
    }// if ( bMore )

    //
    // Fast polygon fill
    //
    if ( bFillPolygon(ppdev, (Surf*)pso->dhsurf, pd.count,
                      pd.pptfx, pb.solidColor,
                      ulRop4,
                      pco, pb.prbrush, pptlBrush) )
    {
        DBG_GDI((7, "Fast Fill Succeeded"));
        InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
        #if MULTITHREADED
            pb.ppdev->ulLockCount--;
            EngReleaseSemaphore(pb.ppdev->hsemLock);
        #endif
//@@END_DDKSPLIT

        return (TRUE);
    }

SkipFastFill:
    DBG_GDI((7, "Fast Fill Skipped"));
    if ( jClipping != DC_TRIVIAL )
    {
        if ( jClipping != DC_RECT )
        {
            DBG_GDI((7, "Complex Clipping"));

            //
            // There is complex clipping; let GDI fill the path
            //
            goto ReturnFalse;
        }

        //
        // Clip to the clip rectangle
        //
        ClipRect = pco->rclBounds;
    }
    else
    {
        //
        // So the y-clipping code doesn't do any clipping
        // We don't blow the values out when we scale up to GIQ
        //
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    //
    // Set up working storage in the temporary buffer, storage for list of
    // rectangles to draw
    // Note: ppdev->pvTmpBuffer is allocated in DrvEnableSurface() in enable.c
    // The purpose of using ppdev->pvTmpBuffer is to save us from having to
    // allocate and free the temp space inside high frequency calls. It was
    // allocated for TMP_BUFFER_SIZE bytes and will be freed in
    // DrvDeleteSurface()
    //
    prclRects = (RECTL*)ppdev->pvTmpBuffer;

    if ( !bMore )
    {
        RECTL*  pTmpRect;
        INT     cPoints = pd.count;

        //
        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges
        //
        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same.
        //
        // ??? we have already done the memcpy for the pd data. shall we use it
        //
        if ( ( cPoints == 4 )
           ||( ( cPoints == 5 )
             &&(pd.pptfx[0].x == pd.pptfx[4].x)
             &&(pd.pptfx[0].y == pd.pptfx[4].y) ) )
        {
            //
            // Get storage space for this temp rectangle
            //
            pTmpRect = prclRects;

            //
            // We have to start somewhere to assume that most
            // applications specify the top left point first
            // We want to check that the first two points are
            // either vertically or horizontally aligned.  If
            // they are then we check that the last point [3]
            // is either horizontally or  vertically  aligned,
            // and finally that the 3rd point [2] is  aligned
            // with both the first point and the  last  point
            //
            pTmpRect->top   = pd.pptfx[0].y - 1 & FIX_MASK;
            pTmpRect->left  = pd.pptfx[0].x - 1 & FIX_MASK;
            pTmpRect->right = pd.pptfx[1].x - 1 & FIX_MASK;

            //
            // Check if the first two points are vertically alligned
            //
            if ( pTmpRect->left ^ pTmpRect->right )
            {
                //
                // The first two points are not vertically alligned
                // Let's see if these two points are horizontal alligned
                //
                if ( pTmpRect->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK) )
                {
                    //
                    // The first two points are not horizontally alligned
                    // So it is not a rectangle
                    //
                    goto not_rectangle;
                }

                //
                // Up to now, the first two points are horizontally alligned,
                // but not vertically alligned. We need to check if the first
                // point vertically alligned with the 4th point
                //
                if ( pTmpRect->left ^ (pd.pptfx[3].x - 1 & FIX_MASK) )
                {
                    //
                    // The first point is not vertically alligned with the 4th
                    // point either. So this is not a rectangle
                    //
                    goto not_rectangle;
                }

                //
                // Check if the 2nd point and the 3rd point are vertically aligned
                //
                if ( pTmpRect->right ^ (pd.pptfx[2].x - 1 & FIX_MASK) )
                {
                    //
                    // The 2nd point and the 3rd point are not vertically aligned
                    // So this is not a rectangle
                    //
                    goto not_rectangle;
                }

                //
                // Check to see if the 3rd and 4th points are horizontally
                // alligned. If not, then it is not a rectangle
                //
                pTmpRect->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
                if ( pTmpRect->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }
            }// Check if the first two points are vertically alligned
            else
            {
                //
                // The first two points are vertically alligned. Now we need to
                // check if the 1st point and the 4th point are horizontally
                // aligned. If not, then this is not a rectangle
                //
                if ( pTmpRect->top ^ (pd.pptfx[3].y - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }

                //
                // Check if the 2nd point and the 3rd point are horizontally
                // aligned. If not, then this is not a rectangle
                //
                pTmpRect->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
                if ( pTmpRect->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }

                //
                // Check if the 3rd point and the 4th point are vertically
                // aligned. If not, then this is not a rectangle
                //
                pTmpRect->right = pd.pptfx[2].x - 1 & FIX_MASK;
                if ( pTmpRect->right ^ (pd.pptfx[3].x - 1 & FIX_MASK) )
                {
                    goto not_rectangle;
                }
            }

            //
            // We have a rectangle now. Do some adjustment here first
            // If the left is greater than the right then
            // swap them so the blt code won't have problem
            //
            if ( pTmpRect->left > pTmpRect->right )
            {
                FIX temp;

                temp = pTmpRect->left;
                pTmpRect->left = pTmpRect->right;
                pTmpRect->right = temp;
            }
            else
            {
                //
                // If left == right there's nothing to draw
                //
                if ( pTmpRect->left == pTmpRect->right )
                {
                    DBG_GDI((7, "Nothing to draw"));
                    goto ReturnTrue;
                }
            }// Adjust right and left edge

            //
            // Shift the values to get pixel coordinates
            //
            pTmpRect->left  = (pTmpRect->left  >> FIX_SHIFT) + 1;
            pTmpRect->right = (pTmpRect->right >> FIX_SHIFT) + 1;

            //
            // Adjust the top and bottom coordiantes if necessary
            //
            if ( pTmpRect->top > pTmpRect->bottom )
            {
                FIX temp;

                temp = pTmpRect->top;
                pTmpRect->top = pTmpRect->bottom;
                pTmpRect->bottom = temp;
            }
            else
            {
                if ( pTmpRect->top == pTmpRect->bottom )
                {
                    DBG_GDI((7, "Nothing to draw"));
                    goto ReturnTrue;
                }
            }

            //
            // Shift the values to get pixel coordinates
            //
            pTmpRect->top    = (pTmpRect->top    >> FIX_SHIFT) + 1;
            pTmpRect->bottom = (pTmpRect->bottom >> FIX_SHIFT) + 1;

            //
            // Finally, check for clipping
            //
            if ( jClipping == DC_RECT )
            {
                //
                // Clip to the clip rectangle
                //
                if ( !bIntersect(pTmpRect, &ClipRect, pTmpRect) )
                {
                    //
                    // Totally clipped, nothing to do
                    //
                    DBG_GDI((7, "Nothing to draw"));
                    goto ReturnTrue;
                }
            }

            //
            // If we get here then the polygon is a rectangle,
            // set count to 1 and goto bottom to draw it
            //
            ulNumRects = 1;
            goto draw_remaining_rectangles;
        }// Check to see if it is a rectangle

not_rectangle:
        ;
    }// if ( !bMore )

    //
    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure????
    //
    if ( ppo->cCurves > MAX_EDGES )
    {
        //
        // Try to allocate enough memory
        //
        pFreeEdges = (EDGE*)ENGALLOCMEM(0, (ppo->cCurves * sizeof(EDGE)),
                                        ALLOC_TAG);
        if ( pFreeEdges == NULL )
        {
            DBG_GDI((1, "Can't allocate memory for %d edges", ppo->cCurves));

            //
            // Too many edges; let GDI fill the path
            //
            goto ReturnFalse;
        }
        else
        {
            //
            // Set a flag to indicate that we have allocate the memory so that
            // we can free it later
            //
            bMemAlloced = TRUE;
        }
    }// if ( ppo->cCurves > MAX_EDGES )
    else
    {
        //
        // If the total number of edges doesn't exceed the MAX_EDGES, then just
        // use our handy temporary buffer (it's big enough)
        //
        pFreeEdges = (EDGE*)((BYTE*)ppdev->pvTmpBuffer + RECT_BYTES);
    }

    //
    // Initialize an empty list of rectangles to fill
    //
    ulNumRects = 0;

    //
    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    //
    pGETHead = &GETHead;
    if ( !bConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect) )
    {
        DBG_GDI((7, "Outside Range"));
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    //
    // Create an empty AET with the head node also a tail sentinel
    //
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;       // Mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;         // This is greater than any valid X value, so
                                    // searches will always terminate

    //
    // Top scan of polygon is the top of the first edge we come to
    //
    iCurrentY = ((EDGE*)GETHead.pNext)->Y;

    //
    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    //
    while ( 1 )
    {
        //
        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        //
        if ( AETHead.pNext != pAETHead )
        {
            vAdvanceAETEdges(pAETHead);
        }

        //
        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        //
        if ( AETHead.pNext == pAETHead )
        {
            if ( GETHead.pNext == pGETHead )
            {
                //
                // Done if there are no edges in either the AET or the GET
                //
                break;
            }

            //
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            //
            iCurrentY = ((EDGE*)GETHead.pNext)->Y;
        }
        else
        {
            //
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            //
            if ( ((EDGE*)AETHead.pNext)->pNext != pAETHead )
            {
                vXSortAETEdges(pAETHead);
            }
        }

        //
        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        //
        if ( ((EDGE*)GETHead.pNext)->Y == iCurrentY )
        {
            vMoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        //
        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        //
        pCurrentEdge = (EDGE*)AETHead.pNext;   // point to the first edge
        do
        {
            INT iLeftEdge;

            //
            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            //
            iLeftEdge = pCurrentEdge->X;

            //
            // Find the matching right edge according to the current fill rule
            //
            if ( (flOptions & FP_WINDINGMODE) != 0 )
            {

                INT iWindingCount;

                //
                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                //
                iWindingCount = pCurrentEdge->iWindingDirection;
                do
                {
                    pCurrentEdge = (EDGE*)pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while ( iWindingCount != 0 );
            }
            else
            {
                //
                // Odd-even fill; the next edge is the matching right edge
                //
                pCurrentEdge = (EDGE*)pCurrentEdge->pNext;
            }

            //
            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            //
            if ( iLeftEdge < pCurrentEdge->X )
            {
                //
                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                //
                if ( ulNumRects >= MAX_PATH_RECTS )
                {
                    //
                    // No more room; draw the rectangles in the list and reset
                    // it to empty
                    //
                    pb.lNumRects = ulNumRects;
                    pb.pRects = prclRects;

                    pb.pgfn(&pb);

                    //
                    // Reset the list to empty
                    //
                    ulNumRects = 0;
                }

                //
                // Add the rectangle representing the current edge pair
                //
                if ( jClipping == DC_RECT )
                {
                    //
                    // Clipped
                    // Clip to left
                    //
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);

                    //
                    // Clip to right
                    //
                    prclRects[ulNumRects].right =
                                        min(pCurrentEdge->X, ClipRect.right);

                    //
                    // Draw only if not fully clipped
                    //
                    if ( prclRects[ulNumRects].left
                       < prclRects[ulNumRects].right )
                    {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY + 1;
                        ulNumRects++;
                    }
                }
                else
                {
                    //
                    // Unclipped
                    //
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY + 1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ( (pCurrentEdge = (EDGE*)pCurrentEdge->pNext) != pAETHead );

        iCurrentY++;                        // next scan
    }// Loop through all the scans in the polygon

    //
    // Draw the remaining rectangles, if there are any
    //
draw_remaining_rectangles:

    if ( ulNumRects > 0 )
    {
        pb.lNumRects = ulNumRects;
        pb.pRects = prclRects;
        
        pb.pgfn(&pb);
    }

ReturnTrue:
    DBG_GDI((7, "Drawn"));
    bRetVal = TRUE;                         // done successfully

ReturnFalse:
    //
    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.
    //
    if ( bMemAlloced )
    {
        //
        // We did allocate memory, so release it
        //
        ENGFREEMEM(pFreeEdges);
    }

    DBG_GDI((6, "Returning %s", bRetVal ? "True" : "False"));

    InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (bRetVal);
}// DrvFillPath()

//-----------------------------------------------------------------------------
//
// void vAdvanceAETEdges(EDGE* pAETHead)
//
// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
//
//-----------------------------------------------------------------------------
VOID
vAdvanceAETEdges(EDGE* pAETHead)
{
    EDGE*   pLastEdge;
    EDGE*   pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = (EDGE*)pLastEdge->pNext;
    do
    {
        //
        // Count down this edge's remaining scans
        //
        if ( --pCurrentEdge->iScansLeft == 0 )
        {
            //
            // We've done all scans for this edge; drop this edge from the AET
            //
            pLastEdge->pNext = pCurrentEdge->pNext;
        }
        else
        {
            //
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            //
            pCurrentEdge->X += pCurrentEdge->iXWhole;

            //
            // Advance the error term and see if we got one extra pixel this
            // time
            //
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;

            if ( pCurrentEdge->iErrorTerm >= 0 )
            {
                //
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                //
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = (EDGE *)pLastEdge->pNext) != pAETHead);
}// vAdvanceAETEdges()

//-----------------------------------------------------------------------------
//
// VOID vXSortAETEdges(EDGE* pAETHead)
//
// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
//
//-----------------------------------------------------------------------------
VOID
vXSortAETEdges(EDGE *pAETHead)
{
    BOOL    bEdgesSwapped;
    EDGE*   pLastEdge;
    EDGE*   pCurrentEdge;
    EDGE*   pNextEdge;

    do
    {
        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = (EDGE *)pLastEdge->pNext;
        pNextEdge = (EDGE *)pCurrentEdge->pNext;

        do
        {
            if ( pNextEdge->X < pCurrentEdge->X )
            {
                //
                // Next edge is to the left of the current edge; swap them
                //
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;

                //
                // Continue sorting before the edge we just swapped; it might
                // move farther yet
                //
                pCurrentEdge = pNextEdge;
            }
            
            pLastEdge = pCurrentEdge;
            pCurrentEdge = (EDGE *)pLastEdge->pNext;
        } while ( (pNextEdge = (EDGE*)pCurrentEdge->pNext) != pAETHead );
    } while ( bEdgesSwapped );
}// vXSortAETEdges()

//-----------------------------------------------------------------------------
//
// VOID vMoveNewEdges(EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY)
//
// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
//
//-----------------------------------------------------------------------------
VOID
vMoveNewEdges(EDGE* pGETHead,
              EDGE* pAETHead,
              INT   iCurrentY)
{
    EDGE*   pCurrentEdge = pAETHead;
    EDGE*   pGETNext = (EDGE*)pGETHead->pNext;

    do
    {
        //
        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        //
        while ( pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X )
        {
            pCurrentEdge = (EDGE*)pCurrentEdge->pNext;
        }

        //
        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        //
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = (EDGE*)pGETHead->pNext;
    } while (pGETNext->Y == iCurrentY);
}// vMoveNewEdges()

//-----------------------------------------------------------------------------
//
// BOOL (EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY)
//
// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.
//
//-----------------------------------------------------------------------------
BOOL
bConstructGET(EDGE*     pGETHead,
              EDGE*     pFreeEdges,
              PATHOBJ*  ppo,
              PATHDATA* pd,
              BOOL      bMore,
              RECTL*    pClipRect)
{
    POINTFIX pfxPathStart;    // point that started the current subpath
    POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              // starts the current edge

    //
    // Create an empty GET with the head node also a tail sentinel
    //
    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                // Searches will always terminate

    //
    // Note: PATHOBJ_vEnumStart is implicitly  performed by engine
    // already and first path is enumerated by the caller 
    // so here we don't need to call it again.
    //
next_subpath:

    //
    // Make sure the PATHDATA is not empty (is this necessary)???
    //
    if ( pd->count != 0 )
    {
        //
        // If first point starts a subpath, remember it as such
        // and go on to the next point, so we can get an edge
        //
        if ( pd->flags & PD_BEGINSUBPATH )
        {
            //
            // The first point starts the subpath; Remember it
            //
            pfxPathStart    = *pd->pptfx; // the subpath starts here
            pfxPathPrevious = *pd->pptfx; // this point starts the next edge
            pd->pptfx++;                  // advance to the next point
            pd->count--;                  // count off this point
        }

        //
        // Add edges in PATHDATA to GET, in Y-X sorted order
        //
        while ( pd->count-- )
        {
            if ( (pFreeEdges =
                  pAddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                pd->pptfx, pClipRect)) == NULL )
            {
                goto ReturnFalse;
            }

            pfxPathPrevious = *pd->pptfx; // current point becomes previous
            pd->pptfx++;                  // advance to the next point
        }// Loop through all the points

        //
        // If last point ends the subpath, insert the edge that
        // connects to first point  (is this built in already?)
        //
        if ( pd->flags & PD_ENDSUBPATH )
        {
            if ( (pFreeEdges = pAddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                            &pfxPathStart, pClipRect)) == NULL )
            {
                goto ReturnFalse;
            }
        }
    }// if ( pd->count != 0 )

    //
    // The initial loop conditions preclude a do, while or for
    //
    if ( bMore )
    {
        bMore = PATHOBJ_bEnum(ppo, pd);
        goto next_subpath;
    }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}// bConstructGET()

//-----------------------------------------------------------------------------
//
// EDGE* pAddEdgeToGET(EDGE* pGETHead, EDGE* pFreeEdge, POINTFIX* ppfxEdgeStart,
//                     POINTFIX* ppfxEdgeEnd, RECTL* pClipRect)
//
// Adds the edge described by the two passed-in points to the Global Edge
// Table (GET), if the edge spans at least one pixel vertically.
//
//-----------------------------------------------------------------------------
EDGE*
pAddEdgeToGET(EDGE*     pGETHead,
              EDGE*     pFreeEdge,
              POINTFIX* ppfxEdgeStart,
              POINTFIX* ppfxEdgeEnd,
              RECTL*    pClipRect)
{
    int iYStart;
    int iYEnd;
    int iXStart;
    int iXEnd;
    int iYHeight;
    int iXWidth;
    int yJump;
    int yTop;

    //
    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    //
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;

    if ( iYHeight == 0 )
    {
        //
        // Zero height; ignore this edge
        //
        return(pFreeEdge);
    }
    else if ( iYHeight > 0 )
    {
        //
        // Top-to-bottom
        //
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;

        pFreeEdge->iWindingDirection = 1;
    }
    else
    {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        
        pFreeEdge->iWindingDirection = -1;
    }

    if ( iYHeight & 0x80000000 )
    {
        //
        // Too large; outside 2**27 GDI range
        //
        return(NULL);
    }

    //
    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    //
    iXWidth = iXEnd - iXStart;
    if ( iXWidth >= 0 )
    {
        //
        // Left to right, so we change X as soon as we move at all
        //
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    }
    else
    {
        //
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        //
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if ( iXWidth & 0x80000000 )
    {
        //
        // Too large; outside 2**27 GDI range
        //
        return(NULL);
    }

    if ( iXWidth >= iYHeight )
    {
        //
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        //
        pFreeEdge->iXWhole = iXWidth / iYHeight;

        //
        // Add sign back into base run length if going right to left
        //
        if ( pFreeEdge->iXDirection == -1 )
        {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }

        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    }
    else
    {
        //
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        //
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }

    pFreeEdge->iErrorAdjustDown = iYHeight;

    //
    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping
    //
    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    //
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);

    //
    // Initial scan line on which to fill edge
    //
    pFreeEdge->Y = yTop >> 4;

    //
    // Calculate # of scans to actually fill, accounting for clipping
    //
    if ( (pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
         - pFreeEdge->Y) <= 0 )
    {
        //
        // No pixels at all are spanned, so we can ignore this edge
        //
        return(pFreeEdge);
    }

    //
    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed
    //
    if ( iYStart != yTop )
    {
        //
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        //
        yJump = yTop - iYStart;

        //
        // Advance x the minimum amount for the number of scans traversed
        //
        iXStart += pFreeEdge->iXWhole * yJump;

        vAdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }

    //
    // Turn the calculations into pixel rather than GIQ calculations
    //
    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    //
    // LATER adjust only if needed (if prestepped above)?
    //
    if ( pFreeEdge->iXDirection == 1 )
    {
        //
        // Left to right
        //
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown
                               * (((iXStart + 15) & ~0x0F) - iXStart);
    }
    else
    {
        //
        // Right to left
        //
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown
                               * ((iXStart - 1) & 0x0F);
    }

    //
    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    //
    pFreeEdge->iErrorTerm >>= 4;

    //
    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    //
    while (  (pFreeEdge->Y > ((EDGE*)pGETHead->pNext)->Y)
           ||( (pFreeEdge->Y == ((EDGE*)pGETHead->pNext)->Y)
             &&(pFreeEdge->X > ((EDGE*)pGETHead->pNext)->X) ) )
    {
        pGETHead = (EDGE*)pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    //
    // Point to the next edge storage location for next time
    //
    return(++pFreeEdge);
}// pAddEdgeToGET()

//-----------------------------------------------------------------------------
//
// void vAdjustErrorTerm(int *pErrorTerm, int iErrorAdjustUp,
//                       int iErrorAdjustDown, int yJump, int *pXStart,
//                       int iXDirection)
// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.
//
//-----------------------------------------------------------------------------
void
vAdjustErrorTerm(int*   pErrorTerm,
                 int    iErrorAdjustUp,
                 int    iErrorAdjustDown,
                 int    yJump,
                 int*   pXStart,
                 int    iXDirection)

{
#if defined(_X86_) || defined(i386)
    //
    // Adjust the error term up by the number of y coordinates we'll skip
    // *pErrorTerm += iErrorAdjustUp * yJump;
    //
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    //
    // See if the error term turned over even once while skipping
    //
    _asm    js  short NoErrorTurnover

    //
    // # of times we'll turn over the error term and step an extra x
    // coordinate while skipping
    // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
    //
    _asm    div iErrorAdjustDown
    _asm    inc eax

    //
    // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
    // the error term ends up ultimately
    //
    // Advance x appropriately for the # of times the error term
    // turned over
    // if (iXDirection == 1)
    // {
    //     *pXStart += NumAdjustDowns;
    // }
    // else
    // {
    //     *pXStart -= NumAdjustDowns;
    // }
    //
    _asm    mov ecx,pXStart
    _asm    cmp iXDirection,1
    _asm    jz  short GoingRight
    _asm    neg eax
GoingRight:
    _asm    add [ecx],eax

    // Adjust the error term down to its proper post-skip value
    // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    _asm    sub edx,iErrorAdjustDown
    _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
NoErrorTurnover:
    _asm    mov [ebx],eax

#else
    //
    // LONGLONGS are 64 bit integers (We hope!) as the multiply could
    // overflow 32 bit integers. If 64 bit ints are unsupported, the
    // LONGLONG will end up as a double. Hopefully there will be no
    // noticable difference in accuracy.
    LONGLONG NumAdjustDowns;
    LONGLONG tmpError = *pErrorTerm;

    //
    // Adjust the error term up by the number of y coordinates we'll skip
    //
    tmpError += (LONGLONG)iErrorAdjustUp * (LONGLONG)yJump;

    //
    // See if the error term turned over even once while skipping
    //
    if ( tmpError >= 0 )
    {
        //
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        //
        NumAdjustDowns = (tmpError / (LONGLONG)iErrorAdjustDown) + 1;

        //
        // Advance x appropriately for the # of times the error term
        // turned over
        //
        if ( iXDirection == 1 )
        {
            *pXStart += (LONG)NumAdjustDowns;
        }
        else
        {
            *pXStart -= (LONG) NumAdjustDowns;
        }

        //
        // Adjust the error term down to its proper post-skip value
        //
        tmpError -= (LONGLONG)iErrorAdjustDown * NumAdjustDowns;
    }
    *pErrorTerm = (LONG)tmpError;

#endif  // X86
}// vAdjustErrorTerm()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\heap.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.h
*
* This module contains all the definitions for heap related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __HEAP__H__
#define __HEAP__H__

//
// This function is called whenever we switch in or out of full-screen mode
//
BOOL    bAssertModeOffscreenHeap(PDev*, BOOL);

//
// Off-screen heap initialization
//
BOOL    bEnableOffscreenHeap(PDev*);

//
// Move the oldest memory block out of video memory
//
BOOL    bMoveOldestBMPOut(PDev* ppdev);

//
// Create a DSURF* in video memory
//
Surf*   pCreateSurf(PDev* ppdev, LONG lWidth, LONG lHeight);

//
// Video memory allocation
//
ULONG   ulVidMemAllocate(PDev* ppdev, LONG lWidth, LONG lHeight, LONG lPelSize, LONG* plDelta,
                         VIDEOMEMORY** ppvmHeap, ULONG* pulPackedPP, BOOL bDiscardable);

//
// Blank the screen
//
VOID    vBlankScreen(PDev*   ppdev);

//
// Adds the surface to the surface list
//
VOID    vAddSurfToList(PPDev ppdev, Surf* psurf);


//
// Frees any resources allocated by the off-screen heap
//
VOID    vDisableOffscreenHeap(PDev*);

//
// Removes the surface from the surface list
//
VOID    vRemoveSurfFromList(PPDev ppdev, Surf* psurf);

//
// Shifts the surface from its current position in the surface list to the
// end of surface list
//
VOID    vShiftSurfToListEnd(PPDev ppdev, Surf* psurf);

//
// Informs the heap manager that the surface has been accessed
//
VOID    vSurfUsed(PPDev ppdev, Surf* psurf);

//
// Free a DSURF structure
//
void    vDeleteSurf(Surf* psurf);

//
// Moves the surface from VM to SM
//

BOOL    bDemote(Surf* psurf);

//
// Attempts to move the surface from SM to VM
//

void    vPromote(Surf* psurf);

//
// Move all surfaces to SM
//

BOOL    bDemoteAll(PPDev ppdev);

#endif // __HEAP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\heap.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.c
*
* This module contains the routines for an off-screen video heap manager.
* It is used primarily for allocating space for device-format-bitmaps in
* off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"
#include "log.h"
#include "heap.h"
#define ALLOC_TAG ALLOC_TAG_EH2P
//-----------------------------------------------------------------------------
//
// void vRemoveSurfFromList(Surf* psurf)
//
// Removes the surface from the surface list
//
//-----------------------------------------------------------------------------
VOID
vRemoveSurfFromList(PPDev ppdev, Surf* psurf)
{
    DBG_GDI((3, "vRemoveSurfFromList removing psruf=0x%x", psurf));

//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vRemoveSurfFromList);
//@@END_DDKSPLIT
    
    if ( psurf != NULL && psurf->flags & SF_LIST)
    {
        Surf* pHead = ppdev->psurfListHead;
        Surf* pTail = ppdev->psurfListTail;

        if ( psurf == pHead )
        {
            DBG_GDI((3, "vRemoveSurfFromList removing 1st one"));

            //
            // Remove the first one in the list
            //
            Surf* pNextSurf = psurf->psurfNext;

            if ( pNextSurf != NULL )
            {
                pNextSurf->psurfPrev = NULL;
                ppdev->psurfListHead = pNextSurf;

                DBG_GDI((3, "Move head to 0x%x", ppdev->psurfListHead));
            }
            else
            {
                //
                // This is the only psurf in our list. Let head and tail all
                // point to NULL after removal
                //
                DBG_GDI((3, "vRemoveSurfFromList: the only one in list"));
                ppdev->psurfListHead = NULL;
                ppdev->psurfListTail = NULL;
            }
        }// The psurf happens to be the first one in the list
        else if ( psurf == pTail )
        {
            DBG_GDI((3, "vRemoveSurfFromList removing last one"));

            //
            // Remove the last one in the list
            //
            ppdev->psurfListTail = psurf->psurfPrev;
            ppdev->psurfListTail->psurfNext = NULL;
        }// The psurf happens to be the last one in the list
        else
        {
            //
            // Normal case, the psurf is in the middle of a list
            //
            Surf*   psurfPrev = psurf->psurfPrev;
            Surf*   psurfNext = psurf->psurfNext;

            DBG_GDI((3, "vRemoveSurfFromList removing middle one"));
            psurfPrev->psurfNext = psurfNext;
            psurfNext->psurfPrev = psurfPrev;
        }

        psurf->psurfNext = NULL;
        psurf->psurfPrev = NULL;
        psurf->flags &= ~SF_LIST;

    }// if ( psurf != NULL )
}// vRemoveSurfFromList()

//-----------------------------------------------------------------------------
//
// void vAddSurfToList(PPDev ppdev, Surf* psurf)
//
// Adds the surface to the surface list
//
// Note: We always add the surface to the end of the list.
//
//-----------------------------------------------------------------------------
VOID
vAddSurfToList(PPDev ppdev, Surf* psurf)
{
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vAddSurfToList);
//@@END_DDKSPLIT
    
    if ( ppdev->psurfListHead == NULL )
    {
        DBG_GDI((3, "vAddSurfToList add psurf=0x%x as 1st one", psurf));

        //
        // First time add a pdsurf to the surface list
        //
        ppdev->psurfListHead = psurf;
        ppdev->psurfListTail = psurf;
        psurf->psurfPrev = NULL;
        psurf->psurfNext = NULL;
        DBG_GDI((6, "vAddSurfToList set pHead as 0x%x", ppdev->psurfListHead));
    }
    else
    {
        Surf* pTail = ppdev->psurfListTail;

        DBG_GDI((3, "vAddSurfToList add psurf=0x%x as the tail", psurf));

        //
        // Add this psurf to the end
        //
        pTail->psurfNext = psurf;
        psurf->psurfPrev = pTail;
        ppdev->psurfListTail = psurf;

        DBG_GDI((6, "vAddSurfToList done: psurf->psurfPrev=0x%x",
                 psurf->psurfPrev));
    }

    psurf->flags |= SF_LIST;

}// vAddSurfToList()

//-----------------------------------------------------------------------------
//
// void vShiftSurfToListEnd(PPDev ppdev, Surf* psurf)
//
// Shifts the surface from its current position in the surface list to the
// end of surface list
//
//-----------------------------------------------------------------------------
VOID
vShiftSurfToListEnd(PPDev ppdev, Surf* psurf)
{
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vShiftSurfToListEnd);
//@@END_DDKSPLIT
    
    Surf* pTail = ppdev->psurfListTail;
    
    DBG_GDI((6, "vShiftSurfToListEnd psurf=0x%x, pTail=0x%x", psurf, pTail));

    //
    // We don't need to shift a NULL psurf or the psurf is already at the end
    // of our surface list
    //
    if ( (psurf != NULL) && (psurf != pTail) )
    {
        Surf* pHead = ppdev->psurfListHead;

        DBG_GDI((6, "vShiftSurfToListEnd pHead=0x%x, pTail=0x%x",
                 pHead, pTail));
        if ( psurf == pHead )
        {
            //
            // The surf is the first one in our list.
            // So, first we shift the head and let it points to the next one
            // in the list
            //
            ppdev->psurfListHead = psurf->psurfNext;
            ppdev->psurfListHead->psurfPrev = NULL;

            //
            // Let the tail point to this psurf
            //
            pTail->psurfNext = psurf;
            psurf->psurfPrev = pTail;
            psurf->psurfNext = NULL;
            ppdev->psurfListTail = psurf;

            DBG_GDI((6,"1st shifted. New pHead=0x%x", ppdev->psurfListHead));
        }// psurf is the 1st one in the list
        else
        {
            //
            // The surface is in the middle of the surface list
            //
            Surf* psurfPrev = psurf->psurfPrev;
            Surf* psurfNext = psurf->psurfNext;

            DBG_GDI((6, "vShiftSurfToListEnd psurfPrev=0x%x, psurfNext=0x%x",
                    psurfPrev, psurfNext));
            psurfPrev->psurfNext = psurfNext;
            psurfNext->psurfPrev = psurfPrev;

            //
            // Add this psurf to the end
            //
            pTail->psurfNext = psurf;
            psurf->psurfPrev = pTail;
            psurf->psurfNext = NULL;
            ppdev->psurfListTail = psurf;
        }// Normal position
    }// psurf is NULL or already at the end
}// vShiftSurfToListEnd()

//-----------------------------------------------------------------------------
//
// void vSurfUsed
//
// Informs the heap manager that the surface has been accessed.
//
// Surface access patterns are the only hint that the heap manager receives
// about the usage pattern of surfaces.  From this limited  information, the
// heap manager must decide what surfaces to throw out of video memory when
// the amount of available video memory reaches zero.
//
// For now, we will implement a LRU algorithm by placing any accessed
// surfaces at the tail of the surface list.
//
//-----------------------------------------------------------------------------
VOID
vSurfUsed(PPDev ppdev, Surf* psurf)
{

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "vSurfUsed: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    if( psurf->flags & SF_LIST )
    {
        // shift any surface that we have allocated to the end of the
        // list
        vShiftSurfToListEnd(ppdev, psurf);
    }
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    
}// vSurfUsed()

//-----------------------------------------------------------------------------
//
// This function copies the bits from off-screen memory to the DIB
//
// Parameters
//  ppdev-----------PPDEV
//  pvSrc-----------Source pointer in the off-screen bitmap
//  lBytesToUpLoad--Number of bytes to upload
//  pvDst-----------Destination pointer in the DIB
//
//-----------------------------------------------------------------------------
VOID
vUpload(PPDev   ppdev,
        void*   pvSrc,
        LONG    lBytesToUpLoad,
        void*   pvDst)
{
    LONG        lBytesAvailable;    
    DWORD       srcData;    
    BYTE*       pBitmapByte;
    USHORT*     pBitmapShort;
    ULONG*      pBitmapLong;
    LONG        lNumOfPixel;

    PERMEDIA_DECL;

    DBG_GDI((7, "vUploadRect called"));    
    DBG_GDI((3, "%ld bytes need to be uploaded at %x\n",
             lBytesToUpLoad, pvSrc));

//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, vUpload);
#if MULTITHREADED && DBG
    ppdev->pP2dma->ppdev = ppdev;
#endif
//@@END_DDKSPLIT

#if !defined(DMA_NOTWORKING)
    if(ppdev->bGdiContext)
    {
        InputBufferSync(ppdev);
    }
    else
    {
        vSyncWithPermedia(ppdev->pP2dma);
    }
    memcpy(pvDst, pvSrc, lBytesToUpLoad);
#else
    
    P2_DEFAULT_FB_DEPTH;

    //
    // Set up the relevant units correctly
    // ColorDDAMode is DISABLED at initialisation time so there is no need
    // to re-load it here.
    //
    WAIT_INPUT_FIFO(3);
    SEND_TAG_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_TAG_DATA(FBWriteMode, __PERMEDIA_DISABLE); // In "read" mode
    SEND_TAG_DATA(FBReadMode, (permediaInfo->FBReadMode
                                        |__FB_READ_DESTINATION
                                        |__FB_COLOR));

    //
    // Enable filter mode so we can get Sync and color messages on the output
    // FIFO
    //
    data.Word = 0;
    data.FilterMode.Synchronization = __PERMEDIA_FILTER_TAG;
    data.FilterMode.Color           = __PERMEDIA_FILTER_DATA;
    SEND_TAG_DATA(FilterMode, data.Word);
    DEXE_INPUT_FIFO();    

    DBG_GDI((7, "pvDst = %x", pvDst));

    switch ( ppdev->cPelSize )
    {
        case 0:
            //
            // Initialise current pointer
            //
            pBitmapByte = (BYTE*)pvDst;            
            lNumOfPixel = lPixelsToUpLoad;

            //
            // Loop to read in all the "lNumOfPixel" bytes
            //
            while ( lNumOfPixel > 0 )
            {
                //
                // Get number of bytes available in the FIFO
                //
                WAIT_OUTPUT_FIFO_NOT_EMPTY(lBytesAvailable);

                //
                // Decrease the total number of bytes we need to read
                //
                lNumOfPixel -= lBytesAvailable;

                //
                // We don't want to over read. Reset "lBytesAvailable" if we
                // have more available in the FIFO than we required
                //
                if ( lNumOfPixel < 0 )
                {
                    lBytesAvailable += lNumOfPixel;
                }

                //
                // Read in "lBytesAvailable" bytes
                //
                while ( --lBytesAvailable >= 0 )
                {
                    READ_OUTPUT_FIFO(srcData);
                    *pBitmapByte++ = (BYTE)srcData;
                }
            }// while ( lNumOfPixel > 0 )                    

            break;

        case 1:               
            //
            // Initialise current pointer
            //
            pBitmapShort = (USHORT*)pvDst;

            lNumOfPixel = lPixelsToUpLoad;
            while ( lNumOfPixel > 0 )
            {
                WAIT_OUTPUT_FIFO_NOT_EMPTY(lBytesAvailable);
                lNumOfPixel -= lBytesAvailable;
                if ( lNumOfPixel < 0 )
                {
                    lBytesAvailable += lNumOfPixel;
                }

                while ( --lBytesAvailable >= 0 )
                {
                    READ_OUTPUT_FIFO(srcData);
                    *pBitmapShort++ = (USHORT)srcData;
                }
            }                    

            break;

        case 2:
            //
            // True color mode, use DWORD as reading UNIT, here pBitmapLong
            // points to the destination address, that is, the BMP data address
            // in main memory
            //            
            pBitmapLong = (ULONG*)pvDst;

            lNumOfPixel = lPixelsToUpLoad;

            //
            // Loop until we upload all the pixels
            //
            while ( lNumOfPixel > 0 )
            {
                //
                // Wait until we have something to read
                //
                WAIT_OUTPUT_FIFO_NOT_EMPTY(lBytesAvailable);

                //
                // Check here to guarntee that we don't read more than we
                // asked for
                //
                lNumOfPixel -= lBytesAvailable;
                if ( lNumOfPixel < 0 )
                {
                    lBytesAvailable += lNumOfPixel;
                }

                //
                // Read all these available BYTES, READ_OUTPUT_FIFO, in FIFO
                // to main memory
                //
                while ( --lBytesAvailable >= 0 )
//                while ( lBytesAvailable > 0 )
                {
                    READ_OUTPUT_FIFO(*pBitmapLong);                    
                    ++pBitmapLong;
//                    lBytesAvailable -= 4;
                }
            }

            break;
    }// switch ( ppdev->cPelSize )        

    //
    // Don't bother with a WAIT_INPUT_FIFO, as we know FIFO is empty.
    // We need to reset the chip back to its standard state. This
    // means: enable FB writes and set the filter mode back to allow
    // only syncs through.
    //
    WAIT_INPUT_FIFO(2);
    SEND_TAG_DATA(FBWriteMode, permediaInfo->FBWriteMode);
    SEND_TAG_DATA(FilterMode, 0);
    EXE_INPUT_FIFO();

    DBG_GDI((7, "vUploadRectNative: done"));
#endif
}// vUpload()

//---------------------------------------------------------------------------
//
// ULONG ulVidMemAllocate
//
// This function allocates "lWidth" by "lHeight" bytes of video memory
//
// Parameters:
//  ppdev----------PPDEV
//  lWidth---------Width of the memory to allocate
//  lHeight--------Height of the memory to allocate
//  lPelSize-------Pixel Size of memory chunk
//  plDelta--------lDelta of this memory chunk
//  ppvmHeap-------Pointer to a video memory heap, local or non-local etc.
//  pulPackedPP----Packed products
//  bDiscardable---TRUE if the surface can be discarded if needed
//
//--------------------------------------------------------------------------
ULONG
ulVidMemAllocate(PDev*           ppdev,
                 LONG            lWidth,
                 LONG            lHeight,
                 LONG            lPelSize,
                 LONG*           plDelta,
                 VIDEOMEMORY**   ppvmHeap,
                 ULONG*          pulPackedPP,
                 BOOL            bDiscardable )
{
    ULONG               iHeap;
    VIDEOMEMORY*        pvmHeap;
    ULONG               ulByteOffset;
    LONG                lDelta;
    LONG                lNewDelta;
    ULONG               packedPP;
    SURFACEALIGNMENT    alignment;  // DDRAW heap management allignment stru

    //
    // Dont allocate any video memory on NT40, just let GDI do all the
    // allocating.
    //
    if(g_bOnNT40)
        return 0;

    memset(&alignment, 0, sizeof(alignment));

    //
    // Calculate lDelta and partical products based on lWidth
    // The permedia has surface width restrictions that must be met
    //
    vCalcPackedPP(lWidth, &lDelta, &packedPP);
    lDelta <<= lPelSize;

    //
    // Set alignment requirements
    //   - must start at an pixel address
    //   - pitch needs to be lDelta
    //

    alignment.Linear.dwStartAlignment = ppdev->cjPelSize;
    alignment.Linear.dwPitchAlignment = lDelta;

    //
    // Indicate that this allocation can be discarded if a DDraw/D3D
    // app really needs the memory
    //

    if( bDiscardable )
    {
        alignment.Linear.dwFlags = SURFACEALIGN_DISCARDABLE;
    }

    //
    // Loop through all the heaps to find available memory
    // Note: This ppdev->cHeap info was set in DrvGetDirectDrawInfo
    // when the driver is initialized
    //
    for ( iHeap = 0; iHeap < ppdev->cHeaps; iHeap++ )
    {
        pvmHeap = &ppdev->pvmList[iHeap];

        //
        // Since we are using DDRAW run time heap management code. It is
        // possible that the heap hasn't been initialized. For example, if
        // we fail in DrvEnableDirectDraw(), then the system won't initialize
        // the heap for us
        //
        if ( pvmHeap == NULL )
        {
            DBG_GDI((1, "Video memory hasn't been initialzied"));
            return 0;
        }

        //
        // AGP memory could be potentially used for device-bitmaps, with
        // two very large caveats:
        //
        // 1. No kernel-mode view is made for the AGP memory (would take
        //    up too many PTEs and too much virtual address space).
        //    No user-mode view is made either unless a DirectDraw
        //    application happens to be running.  Consequently, neither
        //    GDI nor the driver can use the CPU to directly access the
        //    bits.  (It can be done through the accelerator, however.)
        //
        // 2. AGP heaps never shrink their committed allocations.  The
        //    only time AGP memory gets de-committed is when the entire
        //    heap is empty.  And don't forget that committed AGP memory
        //    is non-pageable.  Consequently, if you were to enable a
        //    50 MB AGP heap for DirectDraw, and were sharing that heap
        //    for device bitmap allocations, after running a D3D game
        //    the system would never be able to free that 50 MB of non-
        //    pageable memory until every single device bitmap was deleted!
        //    Just watch your Winstone scores plummet if someone plays
        //    a D3D game first.
        //
        if ( !(pvmHeap->dwFlags & VIDMEM_ISNONLOCAL) )
        {
            //
            // Ask DDRAW heap management to allocate memory for us
            //
            ulByteOffset = (ULONG)HeapVidMemAllocAligned(pvmHeap,
                                                         lDelta,
                                                         lHeight,
                                                         &alignment,
                                                         &lNewDelta);
            
            DBG_GDI((3, "allocate %d bytes----got memory offset %ld real %x",
                     lWidth * ppdev->cjPelSize * lHeight,
                     ulByteOffset, (VOID*)(ppdev->pjScreen + ulByteOffset)));

            if ( ulByteOffset != 0 )
            {
                ASSERTDD(lDelta == lNewDelta,
                         "ulVidMemAllocate: deltas don't match");

                *ppvmHeap    = pvmHeap;
                *plDelta     = lDelta;
                *pulPackedPP = packedPP;

                //
                // We are done
                //
                return (ulByteOffset);
            }// if ( pdsurf != NULL )
        }// if (!(pvmHeap->dwFlags & VIDMEM_ISNONLOCAL))
    }// loop through all the heaps to see if we can find available memory

    return 0;
}// ulVidMemAllocate()

//---------------------------------------------------------------------------
//
// VOID vDeleteSurf(DSURF* pdsurf)
//
// This routine frees a DSURF structure and the video or system memory inside
// this DSURF
//
//----------------------------------------------------------------------------
VOID
vDeleteSurf(Surf* psurf)
{
    DBG_GDI((6, "vDeleteSurf called with pdsurf =0x%x", psurf));

    //
    // Validate input parameters
    //
    if ( psurf == NULL )
    {
        DBG_GDI((3, "vDeleteSurf do nothing because pdsurf is NULL\n"));
        return;
    }

    //
    // Note: we don't need to call EngDeleteSurface(psurf->hsurf) to delete
    // the HBITMAP we created in DrvCreateDeviceBitmap() or DrvDeriveSurface()
    // because GDI will take care of this when it call DrvDeleteDeviceBitmap
    //

    if ( psurf->flags & SF_ALLOCATED )
    {
        if( psurf->flags & SF_SM )
        {
            ENGFREEMEM(psurf->pvScan0);
        }
        else
        {
            ASSERTDD(psurf->flags & SF_VM, "expected video memeory surface");

            //
            // Update the uniqueness to show that space has been freed, so
            // that we may decide to see if some DIBs can be moved back into
            // off-screen memory:
            //
            psurf->ppdev->iHeapUniq++;
        
            //
            // Free the video memory by specifing which heap and the pointer
            // to the chunk of video memory
            //
            DBG_GDI((3, "Free offset %ld from video mem\n", psurf->ulByteOffset));
            VidMemFree(psurf->pvmHeap->lpHeap, (FLATPTR)psurf->ulByteOffset);
        }// It is video memory
    }

    //
    // Free the GDI wrap around video memory
    //
    ENGFREEMEM(psurf);

    return;
}// vDeleteSurf()

//--------------------------------------------------------------------------
//
// pCreateSurf(PDEV* ppdev, LONG lWidth, LONG lHeight)
// This routine returns allocates a chunk of video memory and returns a DSURF*
//
// Parameters:
//  ppdev-------PDEV*
//  lWidth------Width of the bitmap to be allocated
//  lHeight-----Height of the bitmap to be allocated
//
//--------------------------------------------------------------------------
Surf*
pCreateSurf(PDev*   ppdev,
             LONG    lWidth,
             LONG    lHeight)
{
    ULONG         ulByteOffset;
    Surf*         psurf;
    LONG          lDelta;
    ULONG         ulPackedPP;
    VIDEOMEMORY*  pvmHeap;

    //
    // First, try to get video memory
    //
    ulByteOffset = ulVidMemAllocate(ppdev, 
                                    lWidth, lHeight, ppdev->cPelSize,
                                    &lDelta, &pvmHeap, &ulPackedPP, TRUE);

    if ( ulByteOffset != 0 )
    {
        //
        // Use system memory to allocate a wrap (DSURF) so that gdi
        // can track all the info later
        //
        psurf = (Surf*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(Surf),
                                     ALLOC_TAG);
        if ( psurf != NULL )
        {
            DBG_GDI((3, "pdsurf is %x\n", psurf));

            //
            // Fill up the DSURF structure and our job is done
            //
            psurf->flags         = SF_VM | SF_ALLOCATED;
            psurf->ppdev         = ppdev;
            psurf->cx            = lWidth;
            psurf->cy            = lHeight;
            psurf->ulByteOffset  = ulByteOffset;
            psurf->pvmHeap       = pvmHeap;
            psurf->lDelta        = lDelta;
            psurf->ulPackedPP    = ulPackedPP;
            psurf->ulPixOffset   = (ULONG)(ulByteOffset >> ppdev->cPelSize);
            psurf->ulPixDelta    = lDelta >> ppdev->cPelSize;
            psurf->psurfNext     = NULL;
            psurf->psurfPrev     = NULL;
            
            //
            // We are done
            //
            return(psurf);
        }// if ( pdsurf != NULL )

        //
        // Something weird happened that we can't get memory from
        // the system. We should free the video memory before quit
        //
        VidMemFree(pvmHeap->lpHeap, (FLATPTR)ulByteOffset);
    }// if ( ulByteOffset != 0 )

    return (NULL);
}// pCreateSurf()

//---------------------------------------------------------------------------
//
// BOOL bMoveOldestBMPOut
//
// This routine moves the oldest DFB in the video memory to the system memory
// and store it as a DIB
//
//---------------------------------------------------------------------------
BOOL
bMoveOldestBMPOut(PDev* ppdev)
{
    BOOL bResult = FALSE;

    if(ppdev->psurfListHead != NULL)
        bResult = bDemote(ppdev->psurfListHead);

    return bResult;

}// bMoveOldestBMPOut()

//--------------------------Public*Routine-------------------------------------
//
// HBITMAP DrvCreateDeviceBitmap
//
// Function called by GDI to create a device-format-bitmap (DFB).  We will
// always try to allocate the bitmap in off-screen; if we can't, we simply
// fail the call and GDI will create and manage the bitmap itself.
//
// Note: We do not have to zero the bitmap bits.  GDI will automatically
//       call us via DrvBitBlt to zero the bits (which is a security
//       consideration).
//
// Parameters:
// dhpdev---Identifies the PDEV that describes the physical device that an
//          application has designated as the primary target for a bitmap. The
//          format of the bitmap must be compatible with this physical device. 
// sizl-----Specifies the height and width of the desired bitmap, in pixels. 
// iFormat--Specifies the bitmap format, which indicates the required number of
//          bits of color information per pixel. This value can be one of the
//          following: Value         Meaning 
//                     BMF_1BPP    Monochrome. 
//                     BMF_4BPP   4 bits per pixel. 
//                     BMF_8BPP   8 bits per pixel. 
//                     BMF_16BPP 16 bits per pixel. 
//                     BMF_24BPP 24 bits per pixel. 
//                     BMF_32BPP 32 bits per pixel. 
//                     BMF_4RLE   4 bits per pixel; run length encoded. 
//                     BMF_8RLE   8 bits per pixel; run length encoded. 
//
// Return Value:
//   The return value is a handle that identifies the created bitmap if the
//   function is successful. If the driver chooses to let GDI create and manage
//   the bitmap, the return value is zero. If an error occurs, the return value
//   is 0xFFFFFFFF, and GDI logs an error code.
//
//------------------------------------------------------------------------------
HBITMAP
DrvCreateDeviceBitmap(DHPDEV  dhpdev,
                      SIZEL   sizl,
                      ULONG   iFormat)
{
    PDev*   ppdev = (PDev*)dhpdev;
    Surf*   psurf;
    HBITMAP hbmDevice = NULL;
    BYTE*   pjSurface;    

    PERMEDIA_DECL;

    DBG_GDI((6, "DrvCreateDeviceBitmap()called"));

    //
    // First check If we're in full-screen mode ( ppdev->bEnabled = FALSE )
    // If yes, we hardly have any off-screen memory in which to allocate a DFB.
    // LATER: We could still allocate an OH node and put the bitmap on the DIB
    // DFB list for later promotion.
    // Also check that off-screen DFBs are configured ( STAT_DEV_BITMAPS). This
    // flag is turned off in bCheckHighResolutionCapability() (enable.c) when
    // the resolution is too high for the accelerator
    //
//    if ( !ppdev->bEnabled || !(ppdev->flStatus & STAT_DEV_BITMAPS) )
    if ( !ppdev->bEnabled )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap(): return 0, full screen mode"));
        
        return (0);
    }

    //
    // Second check If we're in DirectDraw exclusive mode 
    //
    if ( ppdev->bDdExclusiveMode )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap(): return 0, DirectDraw exclusive mode"));
        
        return (0);
    }

    //
    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.
    //
    if ( iFormat != ppdev->iBitmapFormat )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap(): can't create bmp of format %d size(%d,%d)",
                 iFormat, sizl.cx, sizl.cy));
        DBG_GDI((2, "only bitmaps of format %d supported!",
                 ppdev->iBitmapFormat));

        return (0);
    }

    //
    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:
    //
    // Note if you're tempted to extend this philosophy to surfaces
    // larger than 8x8: in NT5, software cursors will use device-bitmaps
    // when possible, which is a big win when they're in video-memory
    // because we avoid the horrendous reads from video memory whenever
    // the cursor has to be redrawn.  But the problem is that these
    // are small!  (Typically 16x16 to 32x32.)
    //
    if ( (sizl.cx <= 8) && (sizl.cy <= 8) )
    {
        DBG_GDI((2, "DrvCreateDeviceBitmap rtn 0 because BMP size is small"));
        return (0);
    }
    else if ( ((sizl.cx >= 2048) || (sizl.cy >= 1024)) )
    {
        //
        // On Permedia don't create anything bigger than we can rasterize
        // because the rasteriser cannot handle coordinates higher than these
        //        
        DBG_GDI((2, "DrvCreateDeviceBitmap rtn 0 for BMP too large %d %d",
                 sizl.cx, sizl.cy));
        return (0);
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvCreateDeviceBitmap: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    //
    // Allocate a chunk of video memory for storing this bitmap
    //
    do
    {
        psurf = pCreateSurf(ppdev, sizl.cx, sizl.cy);

        if ( psurf != NULL )
        {
            //
            // Create a GDI wrap of a device managed bitmap
            //
            hbmDevice = EngCreateDeviceBitmap((DHSURF)psurf, sizl, iFormat);
            if ( hbmDevice != NULL )
            {
                //
                // Since we're running on a card that can map all of off-screen
                // video-memory, give a pointer to the bits to GDI so that
                // it can draw directly on the bits when it wants to.
                //
                // Note that this requires that we hook DrvSynchronize and
                // set HOOK_SYNCHRONIZE.
                //
                pjSurface = psurf->ulByteOffset + ppdev->pjScreen;                                

                DBG_GDI((3, "width=%ld pel=%ld, pjSurface=%x",
                         sizl.cy, ppdev->cjPelSize, pjSurface));

                ULONG   flags = MS_NOTSYSTEMMEMORY;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
                flags |= MS_SHAREDACCESS;
#endif
//@@END_DDKSPLIT

                if ( EngModifySurface((HSURF)hbmDevice,
                                      ppdev->hdevEng,
                                      ppdev->flHooks,
                                      flags,
                                      (DHSURF)psurf,
                                      pjSurface,
                                      psurf->lDelta,
                                      NULL))
                {
                    psurf->hsurf = (HSURF)hbmDevice;

                    vAddSurfToList(ppdev, psurf);
                    
                    DBG_GDI((6, "DrvCteDeviceBmp succeed, hsurf=%x, dsurf=%x",
                             hbmDevice, psurf));

                    vLogSurfCreated(psurf);

                    break;

                }// if ( EngAssociateSurface() )

                DBG_GDI((0, "DrvCreateDeviceBitmap,EngModifySurface failed"));
                //
                // Since associate surface failed, we should delete the surface
                //
                EngDeleteSurface((HSURF)hbmDevice);
                hbmDevice = NULL;

            }// if ( hbmDevice != NULL )

            //
            // Failed in CreateDeviceBitmap, we should free all the memory
            //
            vDeleteSurf(psurf);

            DBG_GDI((0, "DrvCreateDeviceBitmap,EngCreateDeviceBitmap failed"));
            break;

        }// if ( pdsurf != NULL )
    } while (bMoveOldestBMPOut(ppdev));

#if DBG
    if(hbmDevice == NULL)
    {
        DBG_GDI((1, "DrvCreateDeviceBitmap failed, no memory"));
    }
#endif

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (hbmDevice);

}// DrvCreateDeviceBitmap()

//--------------------------Public*Routine-------------------------------------
//
// VOID DrvDeleteDeviceBitmap()
//
// This function deletes a device bitmap created by DrvCreateDeviceBitmap
//
// Parameters
//  dhsurf------Identifies the bitmap to be deleted. This handle identifies the
//              bitmap created by DrvCreateDeviceBitmap. 
//
// Comments
//  A display driver must implement DrvDeleteDeviceBitmap if it supplies
//  DrvCreateDeviceBitmap.
//
//  GDI will never pass this function a DHSURF which is the same as the
//  screen (Surf*)
//
//-----------------------------------------------------------------------------
VOID
DrvDeleteDeviceBitmap(DHSURF dhsurf)
{
    Surf*  psurf;
    PDev*  ppdev;
    Surf*  pCurrent;        
    
    psurf = (Surf*)dhsurf;
    ppdev = psurf->ppdev;

    DBG_GDI((6, "DrvDeleteDeviceBitamp(%lx)", psurf));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvDeleteDeviceBitmap: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vRemoveSurfFromList(ppdev, psurf);
    vLogSurfDeleted(psurf);
    
    vDeleteSurf(psurf);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

}// DrvDeleteDeviceBitmap()

//-----------------------------------------------------------------------------
//
// VOID vBlankScreen(PDev*   ppdev)
//
// This function balnk the screen by setting the memory contents to zero
//
//-----------------------------------------------------------------------------
VOID
vBlankScreen(PDev*   ppdev)
{
    //
    // Synchronize the hardware first
    //
    if( ppdev->bGdiContext )
    {
        InputBufferSync(ppdev);
    }
    else
    {
#if MULTITHREADED && DBG
        ppdev->pP2dma->ppdev = ppdev;
#endif
        vSyncWithPermedia(ppdev->pP2dma);
    }

    //
    // Set the video memory contents, screen portion, to zero
    //
    memset(ppdev->pjScreen, 0x0,
           ppdev->cyScreen * ppdev->lDelta);
}// vBlankScreen()

//-----------------------------------------------------------------------------
//
// BOOL bAssertModeOffscreenHeap
//
// This function is called whenever we switch in or out of full-screen
// mode.  We have to convert all the off-screen bitmaps to DIBs when
// we switch to full-screen (because we may be asked to draw on them even
// when in full-screen, and the mode switch would probably nuke the video
// memory contents anyway).
//
//-----------------------------------------------------------------------------
BOOL
bAssertModeOffscreenHeap(PDev*   ppdev,
                         BOOL    bEnable)
{
    BOOL    bResult = TRUE;

    if ( !bEnable )
    {
        bResult = bDemoteAll(ppdev);
    
        //
        // We need to clean the screen. bAssertModeOffscreenHeap() is called
        // when DrvAssertMode(FALSE), which means we either switch to a full
        // screen DOS window or this PDEV will be deleted.
        //
        if ( bResult )
        {
            vBlankScreen(ppdev);
        }
    }

    return bResult;
}// bAssertModeOffscreenHeap()

//-----------------------------------------------------------------------------
//
// VOID vDisableOffscreenHeap
//
// Frees any resources allocated by the off-screen heap.
//
//-----------------------------------------------------------------------------
VOID
vDisableOffscreenHeap(PDev* ppdev)
{
#if 0
    ASSERTDD(ppdev->psurfListHead == NULL,
             "vDisableOffscreenHeap: expected surface list to be empty");

    ASSERTDD(ppdev->psurfListTail == NULL,
             "vDisableOffscreenHeap: expected surface list to be empty");
#endif

}// vDisableOffscreenHeap()

//-----------------------------------------------------------------------------
//
// BOOL bEnableOffscreenHeap
//
// Off-screen heap initialization
//
//-----------------------------------------------------------------------------
BOOL
bEnableOffscreenHeap(PDev* ppdev)
{
    DBG_GDI((6, "bEnableOffscreenHeap called"));

    ppdev->psurfListHead = NULL;
    ppdev->psurfListTail = NULL;
    
    return TRUE;
}// bEnableOffscreenHeap()

//-----------------------------------------------------------------------------
//
// BOOL bDownLoad
//
// Download a GDI owned bmp (GOB) to the video memory if we have room on the
// video off-screen heap
//
// Returns: FALSE if there wasn't room, TRUE if successfully downloaded.
//
//-----------------------------------------------------------------------------
#if defined(AFTER_BETA3)
BOOL
bDownLoad(PDev*   ppdev,
          Surf*   psurf)
{
    ULONG         ulByteOffset;
    LONG          lDelta;
    ULONG         ulPackedPP;
    VIDEOMEMORY*  pvmHeap;

    DBG_GDI((6, "bDownLoad called with psurf 0x%x", psurf));

    ASSERTDD(psurf->flags & SF_SM,
             "Can't move a bitmap off-screen when it's already off-screen");

    if ( !(psurf->flags & SF_ALLOCATED) )
    {
        return (FALSE);
    }
    //
    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:
    //
    if ( !ppdev->bEnabled )
    {
        return(FALSE);
    }
    //
    // If we're in DirectDraw exclusive mode, we can't move anything to 
    // off-screen memory:
    //
    if ( ppdev->bDdExclusiveMode )
    {
        return(FALSE);
    }
    //
    // Allocate video memory first
    //
    ulByteOffset = ulVidMemAllocate(ppdev, psurf->cx, psurf->cy, ppdev->cPelSize,
                                    &lDelta, &pvmHeap, &ulPackedPP, TRUE);

    if ( ulByteOffset == 0 )
    {
        //
        // No more free video memory, we have to return
        //
        DBG_GDI((1, "No more free video memory"));
        return(FALSE);
    }

    ULONG   flags = MS_NOTSYSTEMMEMORY;   // It's video-memory

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    flags |= MS_SHAREDACCESS;
#endif
//@@END_DDKSPLIT

    if ( !EngModifySurface(psurf->hsurf,
                           ppdev->hdevEng,
                           ppdev->flHooks,                                     
                           flags,
                           (DHSURF)psurf,
                           ulByteOffset + ppdev->pjScreen,
                           lDelta,
                           NULL))
    {
        //
        // Failed in EngModifySurface, we should free the video memory we got
        //
        VidMemFree(psurf->pvmHeap->lpHeap, (FLATPTR)ulByteOffset);
        return(FALSE);
    }

    //
    // Download BMP from system memory to video memory
    //
    memcpy((void*)(ppdev->pjScreen + psurf->ulByteOffset),
           psurf->pvScan0, lDelta * psurf->cy);

    //
    // Free the system memory
    //
    ENGFREEMEM(psurf->pvScan0);

    //
    // Change the attributes for this PDSURF data structures
    //
    psurf->flags  &= ~SF_SM;
    psurf->flags  |= SF_VM;
    psurf->ulByteOffset = ulByteOffset;
    psurf->pvmHeap  = pvmHeap;
    psurf->lDelta   = lDelta;
    psurf->ulPackedPP = ulPackedPP;
    psurf->ulPixOffset = (ULONG)(ulByteOffset >> ppdev->cPelSize);
    psurf->ulPixDelta = lDelta >> ppdev->cPelSize;
    psurf->psurfNext = NULL;
    psurf->psurfPrev = NULL;

    vAddSurfToList(ppdev, psurf);
    
    return (TRUE);
}// bDownLoad()
#endif

//--------------------------Public Routine-------------------------------------
//
// HBITMAP DrvDeriveSurface
//
// This function derives and creates a GDI surface from the specified
// DirectDraw surface.
//
// Parameters
//  pDirectDraw-----Points to a DD_DIRECTDRAW_GLOBAL structure that describes
//                  the DirectDraw object. 
//  pSurface--------Points to a DD_SURFACE_LOCAL structure that describes the
//                  DirectDraw surface around which to wrap a GDI surface.
//
// Return Value
//  DrvDeriveSurface returns a handle to the created GDI surface upon success.
//  It returns NULL if the call fails or if the driver cannot accelerate GDI
//  drawing to the specified DirectDraw surface.
//
// Comments
//  DrvDeriveSurface allows the driver to create a GDI surface around a
//  DirectDraw video memory or AGP surface object in order to allow accelerated
//  GDI drawing to the surface. If the driver does not hook this call, all GDI
//  drawing to DirectDraw surfaces is done in software using the DIB engine.
//
//  GDI calls DrvDeriveSurface with RGB surfaces only.
//
//  The driver should call DrvCreateDeviceBitmap to create a GDI surface of the
//  same size and format as that of the DirectDraw surface. Space for the
//  actual pixels need not be allocated since it already exists.
//
//-----------------------------------------------------------------------------
HBITMAP
DrvDeriveSurface(DD_DIRECTDRAW_GLOBAL*  pDirectDraw,
                 DD_SURFACE_LOCAL*      pSurface)
{
    PDev*               ppdev;
    Surf*               psurf;
    HBITMAP             hbmDevice;
    DD_SURFACE_GLOBAL*  pSurfaceGlobal;
    SIZEL               sizl;

    DBG_GDI((6, "DrvDeriveSurface: with pDirectDraw 0x%x, pSurface 0x%x",
             pDirectDraw, pSurface));

    ppdev = (PDev*)pDirectDraw->dhpdev;

    pSurfaceGlobal = pSurface->lpGbl;

    //
    // GDI should never call us for a non-RGB surface, but let's assert just
    // to make sure they're doing their job properly.
    //
    ASSERTDD(!(pSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC),
             "GDI called us with a non-RGB surface!");


    // The GDI driver does not accelerate surfaces in AGP memory,
    // thus we fail the call

    if (pSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        DBG_GDI((6, "DrvDeriveSurface return NULL, surface in AGP memory"));
        return 0;
    }

    // The GDI driver does not accelerate managed surface,
    // thus we fail the call
    if (pSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        DBG_GDI((6, "DrvDeriveSurface return NULL, surface is managed"));
        return 0;
    }

    //
    // The rest of our driver expects GDI calls to come in with the same
    // format as the primary surface.  So we'd better not wrap a device
    // bitmap around an RGB format that the rest of our driver doesn't
    // understand.  Also, we must check to see that it is not a surface
    // whose pitch does not match the primary surface.
    //
    // NOTE: Most surfaces created by this driver are allocated as 2D surfaces
    // whose lPitch's are equal to the screen pitch.  However, overlay surfaces
    // are allocated such that there lPitch's are usually different then the
    // screen pitch.  The hardware can not accelerate drawing operations to
    // these surfaces and thus we fail to derive these surfaces.
    //

    if ( (pSurfaceGlobal->ddpfSurface.dwRGBBitCount
          == (DWORD)ppdev->cjPelSize * 8) )
    {
        psurf = (Surf*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(Surf), ALLOC_TAG);
        if ( psurf != NULL )
        {
            sizl.cx = pSurfaceGlobal->wWidth;
            sizl.cy = pSurfaceGlobal->wHeight;

            hbmDevice = EngCreateDeviceBitmap((DHSURF)psurf,
                                              sizl,
                                              ppdev->iBitmapFormat);
            if ( hbmDevice != NULL )
            {
                VOID*   pvScan0;
                if (pSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                {
                    // this actually is in user memory, so don't add offset
                    pvScan0 = (VOID *)pSurfaceGlobal->fpVidMem; 
                }
                else
                {
                    pvScan0 = ppdev->pjScreen + pSurfaceGlobal->fpVidMem;
                }
                //
                // Note that HOOK_SYNCHRONIZE must always be hooked when we
                // give GDI a pointer to the bitmap bits. We don't need to
                // do it here since HOOK_SYNCHRONIZE is always set in our
                // pdev->flHooks
                //

                ULONG   flags = MS_NOTSYSTEMMEMORY;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
                flags |= MS_SHAREDACCESS;
#endif
//@@END_DDKSPLIT

                if ( EngModifySurface((HSURF)hbmDevice,
                                      ppdev->hdevEng,
                                      ppdev->flHooks,
                                      flags,
                                      (DHSURF)psurf,
                                      pvScan0,
                                      pSurfaceGlobal->lPitch,
                                      NULL) )
                {
                    ULONG   ulPackedPP;
                    LONG    lDelta;

                    psurf->hsurf       = (HSURF)hbmDevice;
                    psurf->flags       = SF_DIRECTDRAW | SF_VM;
                    psurf->ppdev       = ppdev;
                    psurf->cx          = pSurfaceGlobal->wWidth;
                    psurf->cy          = pSurfaceGlobal->wHeight;
                    psurf->ulByteOffset= (ULONG)(pSurfaceGlobal->fpVidMem);
                    psurf->pvmHeap     = pSurfaceGlobal->lpVidMemHeap;
                    psurf->psurfNext   = NULL;
                    psurf->psurfPrev   = NULL;
                    psurf->lDelta      = pSurfaceGlobal->lPitch;

                    vCalcPackedPP(psurf->cx, &lDelta, &ulPackedPP);

                    psurf->ulPackedPP  = ulPackedPP;
                    psurf->ulPixOffset = (ULONG)(psurf->ulByteOffset
                                                  >> ppdev->cPelSize);
                    psurf->ulPixDelta  = psurf->lDelta
                                                  >> ppdev->cPelSize;

                    DBG_GDI((6, "DrvDeriveSurface return succeed"));

                    vLogSurfCreated(psurf);

                    if(MAKE_BITMAPS_OPAQUE)
                    {
                        SURFOBJ*    surfobj = EngLockSurface((HSURF) hbmDevice);

                        ASSERTDD(surfobj->iType == STYPE_BITMAP,
                                    "expected STYPE_BITMAP");

                        surfobj->iType = STYPE_DEVBITMAP;

                        EngUnlockSurface(surfobj);
                    }

                    return(hbmDevice);
                }// EngModifySurface succeed

                DBG_GDI((0, "DrvDeriveSurface: EngModifySurface failed"));
                EngDeleteSurface((HSURF)hbmDevice);
            }

            DBG_GDI((0, "DrvDeriveSurface: EngAllocMem failed"));
            ENGFREEMEM(psurf);
        }// if ( pdsurf != NULL ) 
    }// Check surface format

    DBG_GDI((6, "DrvDeriveSurface return NULL"));
    DBG_GDI((6,"pSurfaceGlobal->ddpfSurface.dwRGBBitCount = %d, lPitch =%ld",
            pSurfaceGlobal->ddpfSurface.dwRGBBitCount,pSurfaceGlobal->lPitch));
    DBG_GDI((6, "ppdev->cjPelSize * 8 = %d, lDelta =%d",
             ppdev->cjPelSize * 8, ppdev->lDelta));
      
    return(0);
}// DrvDeriveSurface()

//-----------------------------------------------------------------------------
//
// VOID vDemote
//
// Attempt to move the given surface from VM to SM 
//
//-----------------------------------------------------------------------------
BOOL
bDemote(Surf * psurf)
{
    LONG    lDelta;
    VOID*   pvScan0;
    BOOL    bResult = FALSE;
    
    ASSERTDD( psurf->flags & SF_VM, "source to be VM");
    ASSERTDD( psurf->flags & SF_ALLOCATED, "source must have been allocated");

    //
    // Make the system-memory scans quadword aligned:
    //

    lDelta = (psurf->lDelta + 7) & ~7;

    DBG_GDI((7, "Allocate %ld bytes in Eng, lDelta=%ld\n",
            lDelta * psurf->cy, lDelta));
    
    //
    // Allocate system memory to hold the bitmap
    // Note: there's no point in zero-initializing this memory:
    //
    pvScan0 = ENGALLOCMEM(0, lDelta * psurf->cy, ALLOC_TAG);

    if ( pvScan0 != NULL )
    {
        //
        // The following 'EngModifySurface' call tells GDI to
        // modify the surface to point to system-memory for
        // the bits, and changes what Drv calls we want to
        // hook for the surface.
        //
        // By specifying the surface address, GDI will convert the
        // surface to an STYPE_BITMAP surface (if necessary) and
        // point the bits to the memory we just allocated.  The
        // next time we see it in a DrvBitBlt call, the 'dhsurf'
        // field will still point to our 'pdsurf' structure.
        //
        // Note that we hook only CopyBits and BitBlt when we
        // convert the device-bitmap to a system-memory surface.
        // This is so that we don't have to worry about getting
        // DrvTextOut, DrvLineTo, etc. calls on bitmaps that
        // we've converted to system-memory -- GDI will just
        // automatically do the drawing for us.
        //
        // However, we are still interested in seeing DrvCopyBits
        // and DrvBitBlt calls involving this surface, because
        // in those calls we take the opportunity to see if it's
        // worth putting the device-bitmap back into video memory
        // (if some room has been freed up).
        //
        if ( EngModifySurface(psurf->hsurf,
                              psurf->ppdev->hdevEng,
                              HOOK_COPYBITS | HOOK_BITBLT,
                              0,                    // It's system-memory
                              (DHSURF)psurf,
                              pvScan0,
                              lDelta,
                              NULL))
        {
            //
            // First, copy the bits from off-screen memory to the DIB
            //
            DBG_GDI((3, "Free %d bytes, offset %ld real %x",
                    lDelta * psurf->cy, psurf->ulByteOffset,
                    (VOID*)(psurf->ppdev->pjScreen + psurf->ulByteOffset)));

            vUpload(psurf->ppdev, (void*)(psurf->ppdev->pjScreen + psurf->ulByteOffset),
                    lDelta * psurf->cy, pvScan0);

            DBG_GDI((6, "bMoveOldest() free vidmem %ld",
                     psurf->ulByteOffset));

            //
            // Now free the off-screen memory:
            //
            VidMemFree(psurf->pvmHeap->lpHeap,
                       (FLATPTR)psurf->ulByteOffset);

            vRemoveSurfFromList(psurf->ppdev, psurf);

            //
            // Setup the pdsurf properly because it is a DIB now
            //
            psurf->flags &= ~SF_VM;
            psurf->flags |= SF_SM;
            psurf->pvScan0 = pvScan0;

            vLogSurfMovedToSM(psurf);

            bResult = TRUE;

        }// EngModifySurface()
        else
        {

            //
            // Somehow, EngModifySurface() failed. Free the memory
            //
            ENGFREEMEM(pvScan0);
            ASSERTDD(0, "bMoveOldest() EngModifySurface failed\n");
        }

    }// if ( pvScan0 != NULL )

    return bResult;

}

//-----------------------------------------------------------------------------
//
// VOID vPromote
//
// Attempt to move the given surface from SM to VM 
//
//-----------------------------------------------------------------------------
VOID
vPromote(Surf * psurf)
{
    ASSERTDD( psurf->flags & SF_VM, "source to be VM");
    ASSERTDD( psurf->flags & SF_ALLOCATED, "source must have been allocated");
    ASSERTDD(!psurf->ppdev->bDdExclusiveMode, 
        "cannot promote when DirectDraw is in exclusive mode");
    

    // nothing for now
}

//-----------------------------------------------------------------------------
//
// BOOL bDemoteAll
//
// Attempts to move all surfaces to SM
//
//-----------------------------------------------------------------------------
BOOL
bDemoteAll(PPDev ppdev)
{
    BOOL    bRet;
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    while (ppdev->psurfListHead != NULL)
        if(!bDemote(ppdev->psurfListHead))
            break;

    bRet = (ppdev->psurfListHead == NULL);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\gdi.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: gdi.h
*
* Contains all the gdi related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __GDI__H__
#define __GDI__H__

typedef struct _PDev PDev;

#define CLIP_LIMIT              50  // We'll take 800 bytes of stack space

typedef struct _ClipEnum
{
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];       // Space for enumerating complex clipping
} ClipEnum;                         /* ce, pce */

//
// Text stuff. Specifies foreground and background colours for faking a 1bpp
// XLATEOBJ
//
typedef struct _XlateColors
{       
    ULONG   iBackColor;
    ULONG   iForeColor;
} XlateColors;

#define SF_VM           0x01        // kept in video memory
#define SF_SM           0x02        // kept in system memory
#define SF_AGP          0x04        // kept in AGP memory
#define SF_LIST         0x08        // in surface list
#define SF_ALLOCATED    0x10        // surface memory allocated by us
#define SF_DIRECTDRAW   0x20        // wrapper of a Direct Draw surface

typedef ULONG SurfFlags;

typedef struct _Surf
{
    SurfFlags       flags;          // Type (video memory or system memory)

    PDev*           ppdev;          // Need this for deleting the bitmap

    struct _Surf*   psurfNext;
    struct _Surf*   psurfPrev;
    
    ULONG           cBlt;           // Counts down the number of blts necessary
                                    // at the current uniqueness before we'll
                                    // consider putting the DIB back into
                                    // off-screen memory
    ULONG           iUniq;          // Tells us whether there have been any
                                    // heap 'free's since the last time we
                                    // looked at
    LONG            cx;             // Bitmap width in pixels
    LONG            cy;             // Bitmap height in pixels
    union
    {
        ULONG       ulByteOffset;   // Offset from start of video memory if
                                    // DT_VM
        VOID*       pvScan0;        // pointer to system memory if DT_SM
    };
    LONG            lDelta;         // Stride in bytes for this bitmap
    VIDEOMEMORY*    pvmHeap;        // DirectDraw heap this was allocated from
    HSURF           hsurf;          // Handle to associated GDI surface (if any)
                                    // this DIB

    // New fields to support linear heap allocation of surface
    // Only valid if dt == DT_VM
    ULONG           ulPackedPP;     // padcked partial products needed by
                                    // Permedia hardware for given surface
                                    // lDelta
    ULONG           ulPixOffset;    // Pixel Offset from start of video memory
    ULONG           ulPixDelta;     // stride in pixels

    ULONG           ulChecksum;

} Surf;                             // dsurf, pdsurf

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill
#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

//
// Maximum number of rects we'll fill per call to the fill code
//
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

#define RIGHT 0
#define LEFT  1
#define NEARLY_ONE              0x0000FFFF

//
// Describe a single non-horizontal edge of a path to fill.
//
typedef struct _EDGE
{
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

typedef struct _EDGEDATA
{
    LONG      lCurrentXPos;     // Current x position
    LONG      lXAdvance;        // Number of pixels to advance x on each scan
    LONG      lError;           // Current DDA error
    LONG      lErrorUp;         // DDA error increment on each scan
    LONG      lErrorDown;       // DDA error adjustment
    POINTFIX* pptfx;            // Points to start of current edge
    LONG      lPtfxDelta;       // Delta (in bytes) from pptfx to next point
    LONG      lNumOfScanToGo;   // Number of scans to go for this edge
} EDGEDATA;                     // Ed, pEd

//
//
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

//
// Rendering constant definition
//
#define __RENDER_TEXTURE_ENABLE             (1 << 13)

#define __FX_TEXREADMODE_SWRAP_REPEAT       (1 << 1)
#define __FX_TEXREADMODE_TWRAP_REPEAT       (1 << 3)
#define __FX_TEXREADMODE_8HIGH              (3 << 13)
#define __FX_TEXREADMODE_8WIDE              (3 << 9)
#define __FX_TEXREADMODE_2048HIGH           (11 << 13)
#define __FX_TEXREADMODE_2048WIDE           (11 << 9)

#define __FX_TEXTUREREADMODE_PACKED_DATA    (1 << 24)

#define __FX_8x8REPEAT_TEXTUREREADMODE      ( __PERMEDIA_ENABLE               \
                                            | __FX_TEXREADMODE_TWRAP_REPEAT   \
                                            | __FX_TEXREADMODE_SWRAP_REPEAT   \
                                            | __FX_TEXREADMODE_8HIGH          \
                                            | __FX_TEXREADMODE_8WIDE)

#define __FX_TEXTUREDATAFORMAT_32BIT_RGBA   0x00
#define __FX_TEXTUREDATAFORMAT_32BIT        0x10
#define __FX_TEXTUREDATAFORMAT_8BIT         0xe
#define __FX_TEXTUREDATAFORMAT_16BIT        0x11
#define __FX_TEXTUREDATAFORMAT_4BIT         0xf

#define __P2_TEXTURE_DATAFORMAT_FLIP        (1 << 9)

#define __FX_TEXLUTMODE_DIRECT_ENTRY        (1 << 1)
#define __FX_TEXLUTMODE_4PIXELS_PER_ENTRY   (2 << 10)   //log2
#define __FX_TEXLUTMODE_2PIXELS_PER_ENTRY   (1 << 10)   //log2
#define __FX_TEXLUTMODE_1PIXEL_PER_ENTRY    0           //log2

#define STRETCH_MAX_EXTENT 32767

//
//-----------------------Function***Prototypes--------------------------------
//
// Low-level blt function prototypes
//
//----------------------------------------------------------------------------
typedef struct _GFNPB
{
    VOID (*pgfn)(struct _GFNPB *); // pointer to graphics function

    PDev *      ppdev;      // driver ppdev
    
    Surf *      psurfDst;   // destination surface
    RECTL *     prclDst;    // original unclipped destination rectangle
    
    Surf *      psurfSrc;   // source surface
    RECTL *     prclSrc;    // original unclipped source rectangle
    POINTL *    pptlSrc;    // original unclipped source point
                            // NOTE: pdsurfSrc must be null if
                            // there is no source.  If there is
                            // a source either (pptlSrc must be
                            // valid) or (pptlSrc is NULL and prclSrc
                            // is valid).
    
    RECTL *     pRects;     // rectangle list
    LONG        lNumRects;  // number of rectangles in list
    ULONG       colorKey;   // colorKey for transparent operations
    ULONG       solidColor; // solid color used in fills
    RBrush *    prbrush;    // pointer to brush
    POINTL *    pptlBrush;  // brush origin
    CLIPOBJ *   pco;        // clipping object
    XLATEOBJ *  pxlo;       // color translatoin object
    POINTL *    pptlMask;   // original uncliped mask origin
    ULONG       ulRop4;     // original rop4
    UCHAR       ucAlpha;    // alpha value for constant blends
    TRIVERTEX * ptvrt;      // verticies used for gradient fills
    ULONG       ulNumTvrt;  // number of verticies
    PVOID       pvMesh;     // connectivity for gradient fills
    ULONG       ulNumMesh;  // number of connectivity elements
    ULONG       ulMode;     // drawing mode
    SURFOBJ *   psoSrc;     // GDI managed surface source
    SURFOBJ *   psoDst;     // GDI managed surface destination
} GFNPB;

long flt_to_fix_1_30(float f);

BOOL    bConstructGET(EDGE*     pGETHead,
                      EDGE*     pFreeEdges,
                      PATHOBJ*  ppo,
                      PATHDATA* pd,
                      BOOL      bMore,
                      RECTL*    pClipRect);

EDGE*   pAddEdgeToGET(EDGE*     pGETHead,
                      EDGE*     pFreeEdge,
                      POINTFIX* ppfxEdgeStart,
                      POINTFIX* ppfxEdgeEnd,
                      RECTL*    pClipRect);

void    vAdjustErrorTerm(INT*   pErrorTerm,
                         INT    iErrorAdjustUp,
                         INT    iErrorAdjustDown,
                         INT    yJump,
                         INT*   pXStart,
                         INT    iXDirection);

VOID    vAdvanceAETEdges(EDGE* pAETHead);

VOID    vMoveNewEdges(EDGE* pGETHead,
                      EDGE* pAETHead,
                      INT   iCurrentY);

VOID    vXSortAETEdges(EDGE* pAETHead);

//
// Prototypes for lower level rendering functions
//
BOOL    bFillPolygon(PDev*      ppdev,
                     Surf*      pSurfDst,
                     LONG       lEdges,
                     POINTFIX*  pptfxFirst,
                     ULONG      ulSolidColor,
                     ULONG      ulRop4,
                     CLIPOBJ*   pco,
                     RBrush*    prb,
                     POINTL*    pptlBrush);

BOOL    bFillSpans(PDev*      ppdev,
                   Surf*      pSurfDst,
                   LONG       lEdges,
                   POINTFIX*  pptfxFirst,
                   POINTFIX*  pptfxTop,
                   POINTFIX*  pptfxLast,
                   ULONG      ulSolidColor,
                   ULONG      ulRop4,
                   CLIPOBJ*   pco,
                   RBrush*    prb,
                   POINTL*    pptlBrush);

BOOL    bInitializeStrips(PDev*     ppdev,
                          ULONG     iSolidColor,
                          DWORD     logicop,
                          RECTL*    prclClip);

void    vAlphaBlend(GFNPB * ppb);
void    vAlphaBlendDownload(GFNPB * ppb);
void    vConstantAlphaBlend(GFNPB * ppb);
void    vConstantAlphaBlendDownload(GFNPB * ppb);
void    vCopyBlt(GFNPB * ppb);
void    vCopyBltNative(GFNPB * ppb);
void    vGradientFillRect(GFNPB * ppb);
void    vGradientFillTri(GFNPB * ppb);
void    vImageDownload(GFNPB * ppb);
void    vInvert(GFNPB * ppb);
void    vMonoDownload(GFNPB * ppb);
void    vMonoOffset(GFNPB * ppb);
void    vMonoPatFill(GFNPB * ppb);
void    vPatFill(GFNPB * ppb);
void    vPatternFillRects(GFNPB * ppb);
void    vPatRealize(GFNPB * ppb);
void    vResetStrips(PDev* ppdev);
void    vRop2Blt(GFNPB * ppb);
void    vSolidFill(GFNPB * ppb);
void    vSolidFillWithRop(GFNPB * ppb);
void    vTransparentBlt(GFNPB * ppb);

//
// Text stuff
//
BOOL    bEnableText(PDev* ppdev);
VOID    vDisableText(PDev* ppdev);
VOID    vAssertModeText(PDev* ppdev, BOOL bEnable);

//
// Palette stuff
//
BOOL    bEnablePalette(PDev* ppdev);
BOOL    bInitializePalette(PDev* ppdev, DEVINFO* pdi);
VOID    vDisablePalette(PDev* ppdev);
VOID    vUninitializePalette(PDev* ppdev);

//
// Upload and download functions
//
VOID    vDownloadNative(GFNPB* ppb);
VOID    vUploadNative(GFNPB* ppb);

//
// StretchBlt stuff
//
DWORD   dwGetPixelSize(ULONG    ulBitmapFormat,
                       DWORD*   pdwFormatBits,
                       DWORD*   pdwFormatExtention);

BOOL    bStretchInit(SURFOBJ*    psoDst,
                     SURFOBJ*    psoSrc);

VOID    vStretchBlt(SURFOBJ*    psoDst,
                    SURFOBJ*    psoSrc,
                    RECTL*      rDest,
                    RECTL*      rSrc,
                    RECTL*      prclClip);

VOID    vStretchReset(PDev* ppdev);

//
// Work in progress
//

VOID    vCheckGdiContext(PPDev ppdev);
VOID    vOldStyleDMA(PPDev ppdev);
VOID    vNewStyleDMA(PPDev ppdev);

// Input buffer access methods

//
// InputBufferStart/InputBufferContinue/InputBufferCommit
//
//     This method is used when the caller does not know
//     the upper limit of the amount of space that needs to be reserved
//     or needs to reserve space that exceeds that maximum allowed to
//     be reserved MAX_FIFO_RESERVATION.
//
//     InputBufferStart() is used to get a pointer to the first available entry in
//     the input fifo, a pointer to the end of the reservation and
//     a pointer to the end of the usable area of the buffer.
//
//     InputBufferContinue() is called to extend the current reservation.
//
//     InputBufferCommit() is called when the caller is done using the reserved space.
//
//     Please see textout.c for an example usage of these methods.
//
// InputBufferReserve/InputBufferCommit
//
//     This method is used when the caller needs to make only one
//     reservation of some small known quantity.
//
//     InputBufferReserve() is called to establish the reservation.
//
//     InputBufferCommit() is called when the caller is done using the reserved space.
//
//     Please see textout.c for the usage of InputBufferReserve/InputBufferCommit. 
//
// A caller is free to use these access methods at any time.  Once either
// InputBufferStart or InputBufferReserve is called, the caller must pair the
// call with either a InputBufferFinish or a InputBufferCommit before making
// another reservation.
//
// A caller is free to use either of these methods at any time.
//
// Before calling any of the CPermedia class access methods, the caller
// must call InputBufferFlush (see below).  Because of this, a caller must
// call InputBufferFlush or InputBufferExecute before returning to GDI.
//
// When the caller is done and wishes to initial the transmission of what
// has been placed in the input fifo, the caller can call InputBufferExecute
// (see below).
// 
// InputBufferFlush
//
//      InputBufferFlush is a neccessary evil only as long as these macros are not
//      part of the official input buffer access schemes.  Flush is really
//      the means we sync up our copy of the input buffer state to the
//      CPermedia class.  If these methods were instead part of the fundamental
//      input fifo mechanism, then we could do away with the need for Flush.
//
// InputBufferExecute
//
//      Flush is a neccessary evil only as long as these macros are not
//      part of the official input buffer access schemes.  If and when these
//      new access schemes are made part of the official input fifo buffer
//      mechanism, then it can be replaced by that mechanism's input fifo
//      execute method.
//
//
// InputBufferMakeSpace
//
//      This is a private call and no one should find need to call it directly.
//
//
// Other Notes:
//
// We will play with making the access routines inline functions instead
// of macros taking a look at the code generated.  If acceptable,
// these macros may turn into function calls in the non-Debug build.
//
// The InputBufferStart/InputBufferContinue mechansism keeps state on the stack
// to avoid the dereferences to ppdev freeing up a register in cases where ppdev
// references are not needed in the inner loop that contains InputBufferContinue.
//

// MAX_IN_FIFO_RESERVATION should be bumped up considerably when we add an
// emulation buffer for the non-DMA case

#define MAX_INPUT_BUFFER_RESERVATION (INPUT_BUFFER_SIZE>>3) // in longs

#if DBG
extern
void InputBufferStart(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd);

extern
void InputBufferContinue(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd);

extern
void InputBufferReserve(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer);

extern
void InputBufferCommit(
    PPDev   ppdev,
    PULONG  pulBuffer);

#else
#define InputBufferStart(ppdev, ulLongs, ppulBuffer, ppulBufferEnd, ppulReservationEnd) \
{ \
    *(ppulBuffer) = ppdev->pulInFifoPtr; \
    *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs; \
    *(ppulBufferEnd) = ppdev->pulInFifoEnd; \
    if(*(ppulReservationEnd) > *(ppulBufferEnd)) \
    { \
        InputBufferSwap(ppdev); \
        *(ppulBuffer) = ppdev->pulInFifoPtr; \
        *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs; \
        *(ppulBufferEnd) = ppdev->pulInFifoEnd; \
    } \
}

#define InputBufferContinue(ppdev, ulLongs, ppulBuffer, ppulBufferEnd, ppulReservationEnd) \
{ \
    *(ppulReservationEnd) = *(ppulBuffer) + ulLongs; \
    if(*(ppulReservationEnd) > *(ppulBufferEnd)) \
    { \
        ppdev->pulInFifoPtr = *(ppulBuffer); \
        InputBufferSwap(ppdev); \
        *(ppulBuffer) = ppdev->pulInFifoPtr; \
        *(ppulReservationEnd) = *(ppulBuffer) + ulLongs; \
        *(ppulBufferEnd) = ppdev->pulInFifoEnd; \
    } \
}

#define InputBufferReserve(ppdev, ulLongs, ppulBuffer) \
{ \
    if(ppdev->pulInFifoPtr + ulLongs > ppdev->pulInFifoEnd) \
    { \
        InputBufferSwap(ppdev); \
    } \
    *(ppulBuffer) = ppdev->pulInFifoPtr; \
}

#define InputBufferCommit(ppdev, pulBuffer) ppdev->pulInFifoPtr = pulBuffer

#endif

void FASTCALL InputBufferFlush(PPDev ppdev);
void FASTCALL InputBufferSwap(PPDev ppdev);

void InputBufferSync(PPDev ppdev);

extern BOOL bGdiContext;

#endif // __GDI__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\hwmisc.c ===
/******************************Module*Header***********************************\
* Module Name: hwmisc.c
*
* Hardware specific support routines and structures.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "tvp4020.h"


// table to determine which logicops need read dest turned on in FBReadMode
DWORD   LogicopReadDest[] = {
    0,                                                  /* 00 */
    __FB_READ_DESTINATION,                              /* 01 */
    __FB_READ_DESTINATION,                              /* 02 */
    0,                                                  /* 03 */
    __FB_READ_DESTINATION,                              /* 04 */
    __FB_READ_DESTINATION,                              /* 05 */
    __FB_READ_DESTINATION,                              /* 06 */
    __FB_READ_DESTINATION,                              /* 07 */
    __FB_READ_DESTINATION,                              /* 08 */
    __FB_READ_DESTINATION,                              /* 09 */
    __FB_READ_DESTINATION,                              /* 10 */
    __FB_READ_DESTINATION,                              /* 11 */
    0,                                                  /* 12 */
    __FB_READ_DESTINATION,                              /* 13 */
    __FB_READ_DESTINATION,                              /* 14 */
    0,                                                  /* 15 */
};


// table to determine which logicops need read dest turned on in Config
DWORD   ConfigReadDest[] = {
    0,                                                  /* 00 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 01 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 02 */
    0,                                                  /* 03 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 04 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 05 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 06 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 07 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 08 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 09 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 10 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 11 */
    0,                                                  /* 12 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 13 */
    __PERMEDIA_CONFIG_FBREAD_DST,                          /* 14 */
    0,                                                  /* 15 */
};

//
// Partial products array for width multiples of 32:
// Use GET_PPCODE macro to access this
//

const PPCODE aPartialProducts[] =
{
        0,              (0 << 6) | (0 << 3) | 0,
        32,             (0 << 6) | (0 << 3) | 1,
        64,             (0 << 6) | (1 << 3) | 1,
        96,             (1 << 6) | (1 << 3) | 1,
        128,    (1 << 6) | (1 << 3) | 2,
        160,    (1 << 6) | (2 << 3) | 2,
        192,    (2 << 6) | (2 << 3) | 2,
        224,    (1 << 6) | (2 << 3) | 3,
        256,    (2 << 6) | (2 << 3) | 3,
        288,    (1 << 6) | (3 << 3) | 3,

        320,    (2 << 6) | (3 << 3) | 3,
        384,    (3 << 6) | (3 << 3) | 3, // 352 = 384
        384,    (3 << 6) | (3 << 3) | 3,
        416,    (1 << 6) | (3 << 3) | 4,
        448,    (2 << 6) | (3 << 3) | 4,
        512,    (3 << 6) | (3 << 3) | 4, // 480 = 512
        512,    (3 << 6) | (3 << 3) | 4,
        544,    (1 << 6) | (4 << 3) | 4,
        576,    (2 << 6) | (4 << 3) | 4,
        640,    (3 << 6) | (4 << 3) | 4, // 608 = 640

        640,    (3 << 6) | (4 << 3) | 4,
        768,    (4 << 6) | (4 << 3) | 4, // 672 = 768
        768,    (4 << 6) | (4 << 3) | 4, // 704 = 768
        768,    (4 << 6) | (4 << 3) | 4, // 736 = 768
        768,    (4 << 6) | (4 << 3) | 4,
        800,    (1 << 6) | (4 << 3) | 5,
        832,    (2 << 6) | (4 << 3) | 5,
        896,    (3 << 6) | (4 << 3) | 5, // 864 = 896
        896,    (3 << 6) | (4 << 3) | 5,
        1024,   (4 << 6) | (4 << 3) | 5, // 928 = 1024

        1024,   (4 << 6) | (4 << 3) | 5, // 960 = 1024
        1024,   (4 << 6) | (4 << 3) | 5, // 992 = 1024
        1024,   (4 << 6) | (4 << 3) | 5,
        1056,   (1 << 6) | (5 << 3) | 5,
        1088,   (2 << 6) | (5 << 3) | 5,
        1152,   (3 << 6) | (5 << 3) | 5, // 1120 = 1152
        1152,   (3 << 6) | (5 << 3) | 5,
        1280,   (4 << 6) | (5 << 3) | 5, // 1184 = 1280
        1280,   (4 << 6) | (5 << 3) | 5, // 1216 = 1280
        1280,   (4 << 6) | (5 << 3) | 5, // 1248 = 1280

        1280,   (4 << 6) | (5 << 3) | 5,
        1536,   (5 << 6) | (5 << 3) | 5, // 1312 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1344 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1376 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1408 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1440 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1472 = 1536
        1536,   (5 << 6) | (5 << 3) | 5, // 1504 = 1536
        1536,   (5 << 6) | (5 << 3) | 5,
        2048,   (5 << 6) | (5 << 3) | 6, // 1568 = 2048

        2048,   (5 << 6) | (5 << 3) | 6, // 1600 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1632 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1664 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1696 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1728 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1760 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1792 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1824 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1856 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1888 = 2048

        2048,   (5 << 6) | (5 << 3) | 6, // 1920 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1952 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 1984 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 2016 = 2048
        2048,   (5 << 6) | (5 << 3) | 6, // 2048 = 2048
};

//------------------------------------------------------------------------------
// VOID vCheckDefaultState
//
// Checks that the default state of the hardware is set.
//
//------------------------------------------------------------------------------

VOID vCheckDefaultState(PPDev * ppdev)
{
#if 0
    // Make sure we sync before checking
    vInputBufferSync(ppdev);

    ASSERTDD(READ_FIFO_REG(__Permedia2TagdY) == INTtoFIXED(1),
        "vCheckDefaultState: dY is not 1.0");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagTextureAddressMode) 
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: TextureAddressMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagTextureColorMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: TextureColorMode is not disabled");

//    ASSERTDD(P2_READ_FIFO_REG(__Permedia2TagTextureReadMode)
//                == __PERMEDIA_DISABLE,
//        "vCheckDefaultState: TextureReadMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagAlphaBlendMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: AlphaBlendMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagColorDDAMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: ColorDDAMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagDitherMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: DitherMode is not disabled");

    ASSERTDD(READ_FIFO_REG(__Permedia2TagYUVMode)
                == __PERMEDIA_DISABLE,
        "vCheckDefaultState: YUVMode is not disabled");
#endif
}

//-----------------------------------------------------------------------------
//
// VOID vCalcPackedPP
//
// Function:
//   Calculate the packed partial products for the given width.
//   If outPitch is not NULL, then return the pitch in pixels
//   for the passed back packed partial product.
//
//-----------------------------------------------------------------------------
VOID
vCalcPackedPP(LONG      width,
              LONG*     outPitch,
              ULONG*    outPackedPP)
{
    LONG    pitch =  (width + 31) & ~31;
    LONG    pp[4];
    LONG    ppn;
    LONG    j;

    do
    {
        ppn = pp[0] = pp[1] = pp[2] = pp[3] = 0;
        if ( pitch >= MAX_PARTIAL_PRODUCT_P2 )
        {
            ppn = pitch >> (MAX_PARTIAL_PRODUCT_P2);
            for ( j = 0; j < ppn; j++ )
            {
                pp[j] = 1 + MAX_PARTIAL_PRODUCT_P2 - MIN_PARTIAL_PRODUCT_P2;
            }
        }
        for ( j = MIN_PARTIAL_PRODUCT_P2 ; j < MAX_PARTIAL_PRODUCT_P2 ; j++ )
        {
            if ( pitch & (1 << j) )
            {
                if ( ppn < 4 )
                    pp[ppn] = j + 1 - MIN_PARTIAL_PRODUCT_P2;
                ppn++;
            }
        }
        pitch += 32;            // Add 32 to the pitch just in case we have
                                // too many pps.
    } while ( ppn > 3 );        // We have to loop until we get a pitch
                                // with < 4 pps

    pitch -= 32;                // Pitch is now the correct number of words


    if (outPitch != NULL)
    {
        *outPitch = pitch;
    }
    else
    {
        // if outPitch is null, then caller expects calculated pitch to be
        // the same as the width
        ASSERTDD(pitch == width, "vCalcPackedPP: pitch does not equal width");
    }

    *outPackedPP = pp[0] | (pp[1] << 3) | (pp[2] << 6);
}// vCalcPackedPP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\hwinit.c ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: hwinit.c
*
* This module contains the functions that enable and disable the hardware
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/

#include "precomp.h"
#include "gdi.h"
#include "p2ctxt.h"
#include "tvp4020.h"
#include "p2rd.h"
#define ALLOC_TAG ALLOC_TAG_WH2P
//-----------------------------------------------------------------------------
//
//  vInitCoreRegisters
//
//  set all core Permedia registers to a known state
//
//-----------------------------------------------------------------------------

VOID
vInitCoreRegisters(PPDev ppdev)
{
    PERMEDIA_DECL;
    PERMEDIA_DEFS(ppdev);

    // tracks FBWindowBase for off-screen bitmaps
    permediaInfo->PixelOffset = 0; 
    permediaInfo->TextureAddressMode = __PERMEDIA_ENABLE;
    permediaInfo->TextureReadMode = __PERMEDIA_DISABLE;
                                    /*__FX_TEXREADMODE_2048HIGH |
                                    __FX_TEXREADMODE_2048WIDE |
                                    __FX_TEXREADMODE_TWRAP_REPEAT | 
                                    __FX_TEXREADMODE_SWRAP_REPEAT |
                                    __PERMEDIA_ENABLE;*/
    RESERVEDMAPTR( 41);
    SEND_PERMEDIA_DATA(DeltaMode, 0);
    SEND_PERMEDIA_DATA(ColorDDAMode, 0);
    SEND_PERMEDIA_DATA(ScissorMode, 0);
    SEND_PERMEDIA_DATA(TextureColorMode, 0);
    SEND_PERMEDIA_DATA(FogMode, 0);
    SEND_PERMEDIA_DATA(Window, 0);
    SEND_PERMEDIA_DATA(StencilMode, 0);
    SEND_PERMEDIA_DATA(DepthMode, 0);
    SEND_PERMEDIA_DATA(AlphaBlendMode, 0);
    SEND_PERMEDIA_DATA(DitherMode, 0);
    SEND_PERMEDIA_DATA(LBReadMode, 0);
    SEND_PERMEDIA_DATA(LBWriteMode, 0);
    SEND_PERMEDIA_DATA(RasterizerMode, 0);
    SEND_PERMEDIA_DATA(WindowOrigin, 0);
    SEND_PERMEDIA_DATA(StatisticMode, 0);
    SEND_PERMEDIA_DATA(FBSoftwareWriteMask, -1);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, -1);
    SEND_PERMEDIA_DATA(FilterMode, 0);
    SEND_PERMEDIA_DATA(FBWindowBase, 0);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);
    SEND_PERMEDIA_DATA(FBReadMode, 0);
    SEND_PERMEDIA_DATA(dXDom, 0);
    SEND_PERMEDIA_DATA(dXSub, 0);
    SEND_PERMEDIA_DATA(dY, INTtoFIXED(1));
    SEND_PERMEDIA_DATA(TextureAddressMode, 0);
    SEND_PERMEDIA_DATA(TextureReadMode, 0);
    SEND_PERMEDIA_DATA(TexelLUTMode, 0);
    SEND_PERMEDIA_DATA(Texel0, 0);
    SEND_PERMEDIA_DATA(YUVMode, 0);
    SEND_PERMEDIA_DATA(FBReadPixel, __PERMEDIA_32BITPIXEL);      // 32 bit pixels
    SEND_PERMEDIA_DATA(SStart, 0);
    SEND_PERMEDIA_DATA(dSdx, 1 << 20);
    SEND_PERMEDIA_DATA(dSdyDom, 0);
    SEND_PERMEDIA_DATA(TStart, 0);
    SEND_PERMEDIA_DATA(dTdx, 0);
    SEND_PERMEDIA_DATA(dTdyDom, 0);
    SEND_PERMEDIA_DATA(TextureDataFormat, __FX_TEXTUREDATAFORMAT_32BIT_RGBA | 
                                          __P2_TEXTURE_DATAFORMAT_FLIP);
    SEND_PERMEDIA_DATA(TextureColorMode, 
                    (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION) 
                    | __PERMEDIA_ENABLE); // ignored by texture glyph rendering
    SEND_PERMEDIA_DATA(TextureAddressMode, permediaInfo->TextureAddressMode);
    SEND_PERMEDIA_DATA(TextureReadMode, permediaInfo->TextureReadMode);
    COMMITDMAPTR();
    FLUSHDMA();
}

//-----------------------------------------------------------------------------
//
//  bInitializeHW
//
//  Called to load the initial values into the chip. We assume the hardware
//  has been mapped. All the relevant stuff should be hanging off ppdev. We
//  also sort out all the hardware capabilities etc.
//
//-----------------------------------------------------------------------------

BOOL
bInitializeHW(PPDev ppdev)
{
    HwDataPtr permediaInfo;
    Surf*     psurf;
    LONG      i, j;
    ULONG     width;
    ULONG     ulValue;
    BOOL      bExists;
    ULONG     ulLength;
    ULONG     dmaBufferSize;
    PERMEDIA_DEFS(ppdev);

    DBG_GDI((7, "bInitializeHW: fbsize: 0x%x", ppdev->FrameBufferLength));

    // allocate and initialize ppdev->permediaInfo. We store hardware specific
    // stuff in this structure.
    //
    permediaInfo = (HwDataPtr)
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(HwDataRec), ALLOC_TAG); 
    if ( permediaInfo == NULL )
    {
        DBG_GDI((0, "cannot allocate memory for permediaInfo struct"));
        return (FALSE);
    }
    
    ppdev->permediaInfo = permediaInfo;
    permediaInfo->pGDICtxt = NULL;
    permediaInfo->pCurrentCtxt = NULL;

    // retrieve the PCI configuration information and local buffer size
    ulLength = sizeof(Hw_Device_Info);
    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_QUERY_DEVICE_INFO,
                            NULL,
                            0,
                            (PVOID)&(permediaInfo->deviceInfo),
                            ulLength,
                            &ulLength) )
    {
        DBG_GDI((1, "QUERY_DEVICE_INFO failed."));
        return (FALSE);
    }

    ulLength = sizeof(PINTERRUPT_CONTROL_BLOCK);
    if ( EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF,
                            NULL,
                            0,
                            (PVOID)&pP2dma,
                            ulLength,
                            &ulLength) )
    {
        DBG_GDI((1, "MAP_INTERRUPT_CMD_BUF failed."));
        return FALSE;
    }

    //
    // On NT4.0 the above IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF will fail and
    // pP2dma will be NULL. Hence we allocate it via ENGALLOCMEM.
    //
    if(g_bOnNT40)
    {
        ASSERTDD(pP2dma == 0, "bInitializeHW: pP2dma != 0");
        pP2dma = (P2DMA*) ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(_P2DMA), ALLOC_TAG);
    }

    // Even if IOCtrl call succeeded, 
    // the allocation can still fail.
    if (pP2dma==NULL)
    {
        DBG_GDI((0,"allocation of memory for P2DMA from miniport failed"));
        return FALSE;
    }

    // store away shared memory area for later use in ppdev
    ppdev->pP2dma=pP2dma;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED && DBG
    pP2dma->ppdev = ppdev;
#endif
//@@END_DDKSPLIT

    DBG_GDI((7, "deviceInfo: VendorId: 0x%x, DevId %d, DeltaId 0x%x,"
                "RevId %d, SubId %d, SubVId %d, lbuf len 0x%x, lbuf width %d",
             permediaInfo->deviceInfo.VendorId,
             permediaInfo->deviceInfo.DeviceId,
             permediaInfo->deviceInfo.DeltaRevId,
             permediaInfo->deviceInfo.RevisionId,
             permediaInfo->deviceInfo.SubsystemId,
             permediaInfo->deviceInfo.SubsystemVendorId,
             permediaInfo->deviceInfo.LocalbufferLength,
             permediaInfo->deviceInfo.LocalbufferWidth));

    // collect flags as we initialize so zero it here
    permediaInfo->flags = 0;

    // set up default pointers to our low level rendering functions
    //
    ppdev->pgfnAlphaBlend           = vAlphaBlend;
    ppdev->pgfnConstantAlphaBlend   = vConstantAlphaBlend;
    ppdev->pgfnCopyBlt              = vCopyBlt;
    ppdev->pgfnGradientFillRect     = vGradientFillRect;
    ppdev->pgfnPatFill              = vPatFill;
    ppdev->pgfnMonoPatFill          = vMonoPatFill;
    ppdev->pgfnMonoOffset           = vMonoOffset;
    ppdev->pgfnPatRealize           = vPatRealize;
    ppdev->pgfnSolidFill            = vSolidFill;
    ppdev->pgfnSolidFillWithRop     = vSolidFillWithRop;
    ppdev->pgfnTransparentBlt       = vTransparentBlt;
    ppdev->pgfnInvert               = vInvert;

    ppdev->pulRamdacBase = (ULONG*) ppdev->pulCtrlBase[0] 
                         + P2_EXTERNALVIDEO / sizeof(ULONG);

    // safe pointers to Permedia 2 registers for later use
    //
    ppdev->pCtrlBase   = ((ULONG *)ppdev->pulCtrlBase[0])+CTRLBASE/sizeof(ULONG);
    ppdev->pGPFifo     = ((ULONG *)ppdev->pulCtrlBase[0])+GPFIFO/sizeof(ULONG);
    ppdev->pCoreBase   = ((ULONG *)ppdev->pulCtrlBase[0])+COREBASE/sizeof(ULONG);

    DBG_GDI((5, "Initialize: pCtrlBase=0x%p", ppdev->pCtrlBase));
    DBG_GDI((5, "Initialize: pGPFifo=0x%p", ppdev->pGPFifo));
    DBG_GDI((5, "Initialize: pCoreBase=0x%p", ppdev->pCoreBase));

    if (!bInitializeP2DMA( pP2dma,
                           ppdev->hDriver,
                           (ULONG *)ppdev->pulCtrlBase[0],
                           ppdev->dwAccelLevel,
                           TRUE
                         ))
    {
        DBG_GDI((0, "P2DMA initialization failed."));
        return FALSE;
    }

    // keep a copy of Permedia 2 ChipConfig, so we know
    // if we are running on a AGP card or not
    ppdev->dwChipConfig = P2_READ_CTRL_REG(PREG_CHIPCONFIG);

    //
    // If we have a gamma ramp saved in the registry then use that. Otherwise,
    // initialize the LUT with a gamma of 1.0
    //
    if ( !bRegistryRetrieveGammaLUT(ppdev, &permediaInfo->gammaLUT) ||
         !bInstallGammaLUT(ppdev, &permediaInfo->gammaLUT) )
    {
        vSetNewGammaValue(ppdev, 0x10000);
    }

    //
    // fill in the permediaInfo capability flags and block fill size.
    //
    permediaInfo->flags |= GLICAP_NT_CONFORMANT_LINES;

    //
    // reset all core registers
    //
    vInitCoreRegisters(ppdev);

    //
    // now initialize the non-zero core registers
    //
    RESERVEDMAPTR(20);    // reserve a reasonable amount until the all is setup

    // Rasterizer Mode
    // Fraction and Bias are used by the line drawing code. MirrorBitMask
    // is set as all the bits we download are interpreted from bit 31 to bit 0

    permediaInfo->RasterizerMode = __PERMEDIA_START_BIAS_ZERO << 4 |
                                   __PERMEDIA_FRACTION_ADJUST_ALMOST_HALF << 2 |
                                   __PERMEDIA_ENABLE << 0 | // mirror bit mask
                                   __PERMEDIA_ENABLE << 18; // limits enabled

    SEND_PERMEDIA_DATA(RasterizerMode, permediaInfo->RasterizerMode);

//@@BEGIN_DDKSPLIT
    // TODO: we should not enable limit checking
//@@END_DDKSPLIT
    SEND_PERMEDIA_DATA(YLimits, 2047 << 16);
    SEND_PERMEDIA_DATA(XLimits, 2047 << 16);
    
    // Disable screen scissor
    SEND_PERMEDIA_DATA(ScissorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ScreenSize, ppdev->cyScreen << 16 | ppdev->cxScreen);

    ULONG ulPackedPP;

    DBG_GDI((7, "assuming screen stride is %d pixels\n", ppdev->cxMemory));
    vCalcPackedPP( ppdev->cxMemory, NULL, &ulPackedPP);

    // initialize FBReadMode for our default stride
    SEND_PERMEDIA_DATA(FBReadMode, ulPackedPP);

    // FB Write Mode
    permediaInfo->FBWriteMode = 1 | ((32/*permediaInfo->fastFillBlockSz*/ >> 4) << 1);

    SEND_PERMEDIA_DATA(FBWriteMode, permediaInfo->FBWriteMode);
    DBG_GDI((7, "setting FBWriteMode to 0x%x", (DWORD)permediaInfo->FBWriteMode));

    SEND_PERMEDIA_DATA(FBReadPixel, ppdev->cPelSize);

    //
    // do a probe to see if we support hardware writemasks. use the bottom
    // 8 bits only so the same code works for all depths. We also query a
    // registry variable which, if set, forces the use of software masking.
    //
    bExists = bRegistryQueryUlong(  ppdev,
                                    REG_USE_SOFTWARE_WRITEMASK,
                                    &ulValue);

    if ( !bExists || (ulValue == 0) )
    {
        // this code works as everything is little endian. i.e. the byte we
        // test is always at the lowest address regardless of the pixel depth.
        //
        WRITE_SCREEN_ULONG(ppdev->pjScreen, 0);   // quickest way to clear a pixel!!

        SEND_PERMEDIA_DATA(LogicalOpMode,       __PERMEDIA_CONSTANT_FB_WRITE);
        SEND_PERMEDIA_DATA(FBWriteData,         0xff);
        SEND_PERMEDIA_DATA(StartXDom,           0);
        SEND_PERMEDIA_DATA(StartY,              0);
        SEND_PERMEDIA_DATA(FBHardwareWriteMask, 0xa5);
        SEND_PERMEDIA_DATA(Render,              __RENDER_POINT_PRIMITIVE);
        COMMITDMAPTR();

        SYNC_WITH_PERMEDIA;

        ulValue = READ_SCREEN_ULONG(ppdev->pjScreen);
        if ( (ulValue & 0xff) == 0xa5 )
            permediaInfo->flags |= GLICAP_HW_WRITE_MASK;

        RESERVEDMAPTR(3);
    }

    DBG_GDI((7, "mode registers initialized"));

    SEND_PERMEDIA_DATA(FBHardwareWriteMask, -1);
    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    COMMITDMAPTR();
    FLUSHDMA();
  
    // Initialize out InFifo cached information

    dmaBufferSize = INPUT_BUFFER_SIZE;

#if defined(_X86_) || defined(_IA64_)
    if(!g_bOnNT40 && !pP2dma->bDMAEmulation)
    {
        AllocateDMABuffer(ppdev->hDriver, 
                          (LONG *) &dmaBufferSize,
                          &ppdev->dmaBufferVirtualAddress,
                          &ppdev->dmaBufferPhysicalAddress);

        if(ppdev->dmaBufferVirtualAddress != NULL
           && dmaBufferSize < INPUT_BUFFER_SIZE)
        {
            FreeDMABuffer(ppdev->hDriver, ppdev->dmaBufferVirtualAddress);
            ppdev->dmaBufferVirtualAddress = NULL;
        }
    }
    else
    {
        ppdev->dmaBufferVirtualAddress = NULL;
    }
#else
    ppdev->dmaBufferVirtualAddress = NULL;
#endif

    if(ppdev->dmaBufferVirtualAddress != NULL)
    {
        ppdev->pulInFifoStart = ppdev->dmaBufferVirtualAddress;
        ppdev->pulInFifoEnd = ppdev->dmaBufferVirtualAddress 
                            + (INPUT_BUFFER_SIZE>>3);
        ppdev->dmaCurrentBufferOffset = 0;
    }
    else
    {
        ppdev->pulInFifoStart = (ULONG*) ENGALLOCMEM(0, INPUT_BUFFER_SIZE>>1, ALLOC_TAG);

        if(ppdev->pulInFifoStart == NULL)
        {
            DBG_GDI((0, "bInitializeHW: unable to allocate scratch buffer"));
            pP2dma->bEnabled = FALSE;
            goto errExit;
        }
        
        ppdev->pulInFifoEnd = ppdev->pulInFifoStart + (INPUT_BUFFER_SIZE>>3);
    }

    ppdev->pulInFifoPtr = ppdev->pulInFifoStart;

#if DBG
    ppdev->ulReserved = 0;
#endif
    
    //
    // We are done setting up the GDI context state.
    //

    //
    // Allocate a hardware context for this PDEV saving the current context.
    //
    DBG_GDI((7, "allocating new context"));
    permediaInfo->pGDICtxt = P2AllocateNewContext(ppdev,
                                                    NULL,
                                                    0,
                                                    P2CtxtWriteOnly
                                                    );            

    if ( permediaInfo->pGDICtxt == NULL )
    {
        DBG_GDI((1, "failed to allocate Permedia context for display driver/GDI"));
        pP2dma->bEnabled = FALSE;
        return (FALSE);
    }

    DBG_GDI((7, "got context id 0x%x for GDI context", permediaInfo->pGDICtxt));
    P2SwitchContext(ppdev, permediaInfo->pGDICtxt);

    return (TRUE);

errExit:
    return FALSE;

}// bInitializeHW()

//-----------------------------------------------------------------------------
//
//  vDisableHW
//
//  do whatever needs to be done to disable the hardware and free resources
//  allocated in bInitializeHW
//
//-----------------------------------------------------------------------------

VOID
vDisableHW(PPDev ppdev)
{
    Surf*  psurf;
    PERMEDIA_DECL;

    if ( !permediaInfo )
    {
        return;
    }

    if(ppdev->dmaBufferVirtualAddress != NULL)
        FreeDMABuffer( ppdev->hDriver, ppdev->dmaBufferVirtualAddress);
    else if(ppdev->pulInFifoStart) // No DMA case..we allocated via ENGALLOCMEM
        ENGFREEMEM(ppdev->pulInFifoStart);

    //
    // Free up any contexts we allocated
    //
    if ( permediaInfo->pGDICtxt != NULL )
    {
        P2FreeContext(ppdev, permediaInfo->pGDICtxt);
        permediaInfo->pGDICtxt = NULL;
    }

    if ( permediaInfo->ContextTable )
    {
        ENGFREEMEM(permediaInfo->ContextTable);
    }
    permediaInfo->ContextTable=NULL;

    vFree(ppdev->pP2dma);
    ppdev->pP2dma = NULL;

    ENGFREEMEM(permediaInfo);

}// vDisableHW()

//-----------------------------------------------------------------------------
//
// VOID vAssertModeHW
//
// We're about to switch to/from full screen mode so do whatever we need to
// to save context etc.
//
//-----------------------------------------------------------------------------

VOID
vAssertModeHW(PPDev ppdev, BOOL bEnable)
{
    PERMEDIA_DECL;

    if (!permediaInfo)
        return;

    if (!bEnable)
    {
        
        if(ppdev->permediaInfo->pCurrentCtxt != NULL)
            P2SwitchContext(ppdev, NULL);
    
        //
        // Disable DMA
        //

        ASSERTDD(ppdev->pP2dma->bEnabled,
                 "vAssertModeHW: expected dma to be enabled");

        vSyncWithPermedia(ppdev->pP2dma);
        ppdev->pP2dma->bEnabled = FALSE;
    }
    else
    {
        //
        // Enable DMA
        //
        if (!bInitializeP2DMA( ppdev->pP2dma,
                               ppdev->hDriver,
                               (ULONG *)ppdev->pulCtrlBase[0],
                               ppdev->dwAccelLevel,
                               FALSE
                             ))
        {
            RIP("vAssertModeHW: Cannot restore DMA");
        }

        ASSERTDD(ppdev->permediaInfo->pCurrentCtxt == NULL,
                 "vAssertModeHW: expected no active context");

        //
        // Restore the current gamma LUT.
        //
        bInstallGammaLUT(ppdev, &permediaInfo->gammaLUT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\lines.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: lines.c
 *
 * Contains the code for drawing short fractional endpoint lines and
 * longer lines with strips.
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}
#define ABS(a)              ((a) < 0 ? -(a) : (a))

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V 
                                       //                   | FL_FLIP_D
};

BOOL bIntegerLine(PDev*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDev*, POINTFIX*, POINTFIX*);

//------------------------------------------------------------------------------
//
// BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
//             prclClip, apfn[], flStart)
// 
// Computes the DDA for the line and gets ready to draw it.  Puts the
// pixel data into an array of strips, and calls a strip routine to
// do the actual drawing.
// 
// Doing Lines Right
// -----------------
// 
// In NT, all lines are given to the device driver in fractional
// coordinates, in a 28.4 fixed point format.  The lower 4 bits are
// fractional for sub-pixel positioning.
// 
// Note that you CANNOT! just round the coordinates to integers
// and pass the results to your favorite integer Bresenham routine!!
// (Unless, of course, you have such a high resolution device that
// nobody will notice -- not likely for a display device.)  The
// fractions give a more accurate rendering of the line -- this is
// important for things like our Bezier curves, which would have 'kinks'
// if the points in its polyline approximation were rounded to integers.
// 
// Unfortunately, for fractional lines there is more setup work to do
// a DDA than for integer lines.  However, the main loop is exactly
// the same (and can be done entirely with 32 bit math).
// 
// If You've Got Hardware That Does Bresenham
// ------------------------------------------
// 
// A lot of hardware limits DDA error terms to 'n' bits.  With fractional
// coordinates, 4 bits are given to the fractional part, letting
// you draw in hardware only those lines that lie entirely in a 2^(n-4)
// by 2^(n-4) pixel space.
// 
// And you still have to correctly draw those lines with coordinates
// outside that space!  Remember that the screen is only a viewport
// onto a 28.4 by 28.4 space -- if any part of the line is visible
// you MUST render it precisely, regardless of where the end points lie.
// So even if you do it in software, somewhere you'll have to have a
// 32 bit DDA routine.
// 
// Our Implementation
// ------------------
// 
// We employ a run length slice algorithm: our DDA calculates the
// number of pixels that are in each row (or 'strip') of pixels.
// 
// We've separated the running of the DDA and the drawing of pixels:
// we run the DDA for several iterations and store the results in
// a 'strip' buffer (which are the lengths of consecutive pixel rows of
// the line), then we crank up a 'strip drawer' that will draw all the
// strips in the buffer.
// 
// We also employ a 'half-flip' to reduce the number of strip
// iterations we need to do in the DDA and strip drawing loops: when a
// (normalized) line's slope is more than 1/2, we do a final flip
// about the line y = (1/2)x.  So now, instead of each strip being
// consecutive horizontal or vertical pixel rows, each strip is composed
// of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
// (128, 128) would generate only one strip.
// 
// We also always draw only left-to-right.
// 
// Style lines may have arbitrary style patterns.  We specially
// optimize the default patterns (and call them 'masked' styles).
// 
// The DDA Derivation
// ------------------
// 
// Here is how I like to think of the DDA calculation.
// 
// We employ Knuth's "diamond rule": rendering a one-pixel-wide line
// can be thought of as dragging a one-pixel-wide by one-pixel-high
// diamond along the true line.  Pixel centers lie on the integer
// coordinates, and so we light any pixel whose center gets covered
// by the "drag" region (John D. Hobby, Journal of the Association
// for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
// 
// We must define which pixel gets lit when the true line falls
// exactly half-way between two pixels.  In this case, we follow
// the rule: when two pels are equidistant, the upper or left pel
// is illuminated, unless the slope is exactly one, in which case
// the upper or right pel is illuminated.  (So we make the edges
// of the diamond exclusive, except for the top and left vertices,
// which are inclusive, unless we have slope one.)
// 
// This metric decides what pixels should be on any line BEFORE it is
// flipped around for our calculation.  Having a consistent metric
// this way will let our lines blend nicely with our curves.  The
// metric also dictates that we will never have one pixel turned on
// directly above another that's turned on.  We will also never have
// a gap; i.e., there will be exactly one pixel turned on for each
// column between the start and end points.  All that remains to be
// done is to decide how many pixels should be turned on for each row.
// 
// So lines we draw will consist of varying numbers of pixels on
// successive rows, for example:
// 
//       ******
//             *****
//                  ******
//                        *****
// 
// We'll call each set of pixels on a row a "strip".
// 
// (Please remember that our coordinate space has the origin as the
// upper left pixel on the screen; postive y is down and positive x
// is right.)
// 
// Device coordinates are specified as fixed point 28.4 numbers,
// where the first 28 bits are the integer coordinate, and the last
// 4 bits are the fraction.  So coordinates may be thought of as
// having the form (x, y) = (M/F, N/F) where F is the constant scaling
// factor F = 2^4 = 16, and M and N are 32 bit integers.
// 
// Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
// left-to-right and whose slope is in the first octant, and let
// dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
// 
// Since the slope of the line is less than 1, the edges of the
// drag region are created by the top and bottom vertices of the
// diamond.  At any given pixel row y of the line, we light those
// pixels whose centers are between the left and right edges.
// 
// Let mL(n) denote the line representing the left edge of the drag
// region.  On pixel row j, the column of the first pixel to be
// lit is
// 
//       iL(j) = ceiling( mL(j * F) / F)
// 
// Since the line's slope is less than one:
// 
//       iL(j) = ceiling( mL([j + 1/2] F) / F )
// 
// Recall the formula for our line:
// 
//       n(m) = (dN / dM) (m - M0) + N0
// 
//       m(n) = (dM / dN) (n - N0) + M0
// 
// Since the line's slope is less than one, the line representing
// the left edge of the drag region is the original line offset
// by 1/2 pixel in the y direction:
// 
//       mL(n) = (dM / dN) (n - F/2 - N0) + M0
// 
// From this we can figure out the column of the first pixel that
// will be lit on row j, being careful of rounding (if the left
// edge lands exactly on an integer point, the pixel at that
// point is not lit because of our rounding convention):
// 
//       iL(j) = floor( mL(j F) / F ) + 1
// 
//             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
// 
//             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
// 
//                      F dM j - [ dM (N0 + F/2) - dN M0 ]
//             = floor( ---------------------------------- ) + 1
//                                   F dN
// 
//                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
//             = floor( ------------------------------------ ) + 1       (1)
//                                     dN
// 
//             = floor( (dM j + alpha) / dN ) + 1
// 
// where
// 
//       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
// 
// We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
// pixels in row j.  Because we are always calculating iL(j) for
// integer quantities of j, we note that the only fractional term
// is constant, and so we can 'throw away' the fractional bits of
// alpha:
// 
//       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
// 
// so
// 
//       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
// 
// for integers j.
// 
// Note if iR(j) is the line's rightmost pixel on row j, that
// iR(j) = iL(j + 1) - 1.
// 
// Similarly, rewriting equation (1) as a function of column i,
// we can determine, given column i, on which pixel row j is the line
// lit:
// 
//                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
//       j(i) = ceiling( ------------------------------------ ) - 1
//                                       dM
// 
// Floors are easier to compute, so we can rewrite this:
// 
//                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
//       j(i) = floor( ----------------------------------------------- ) - 1
//                                       dM
// 
//                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
//            = floor( ---------------------------------------------------- )
//                                       dM
// 
//                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
//            = floor( ---------------------------------------- )
//                                       dM
// 
// We can once again wave our hands and throw away the fractional bits
// of the remainder term:
// 
//       j(i) = floor( (dN i + gamma) / dM )                             (4)
// 
// where
// 
//       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
// 
// We now note that
// 
//       beta = -gamma - 1 = ~gamma                                      (6)
// 
// To draw the pixels of the line, we could evaluate (3) on every scan
// line to determine where the strip starts.  Of course, we don't want
// to do that because that would involve a multiply and divide for every
// scan.  So we do everything incrementally.
// 
// We would like to easily compute c , the number of pixels on scan j:
//                                  j
// 
//    c  = iL(j + 1) - iL(j)
//     j
// 
//       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
// 
// This may be rewritten as
// 
//    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
//     j          j+1    j+1                j    j
// 
// where i , i    are integers and r  < dN, r    < dN.
//        j   j+1                   j        j+1
// 
// Rewriting (7) again:
// 
//    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
//     j          j    j                          j    j
// 
// 
//       = floor((r  + dM) / dN) - floor(r  / dN)
//                 j                      j
// 
// This may be rewritten as
// 
//    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
//     j                j                      j
// 
// where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
// 
// r  is the remainder (or "error") term in the DDA loop: r  / dN
//  j                                                      j
// is the exact fraction of a pixel at which the strip ends.  To go
// on to the next scan and compute c    we need to know r   .
//                                  j+1                  j+1
// 
// So in the main loop of the DDA:
// 
//    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
//     j                j                  j+1     j
// 
// and we know r  < dN, r    < dN, and dR < dN.
//              j        j+1
// 
// We have derived the DDA only for lines in the first octant; to
// handle other octants we do the common trick of flipping the line
// to the first octant by first making the line left-to-right by
// exchanging the end-points, then flipping about the lines y = 0 and
// y = x, as necessary.  We must record the transformation so we can
// undo them later.
// 
// We must also be careful of how the flips affect our rounding.  If
// to get the line to the first octant we flipped about x = 0, we now
// have to be careful to round a y value of 1/2 up instead of down as
// we would for a line originally in the first octant (recall that
// "In the case where two pels are equidistant, the upper or left
// pel is illuminated...").
// 
// To account for this rounding when running the DDA, we shift the line
// (or not) in the y direction by the smallest amount possible.  That
// takes care of rounding for the DDA, but we still have to be careful
// about the rounding when determining the first and last pixels to be
// lit in the line.
// 
// Determining The First And Last Pixels In The Line
// -------------------------------------------------
// 
// Fractional coordinates also make it harder to determine which pixels
// will be the first and last ones in the line.  We've already taken
// the fractional coordinates into account in calculating the DDA, but
// the DDA cannot tell us which are the end pixels because it is quite
// happy to calculate pixels on the line from minus infinity to positive
// infinity.
// 
// The diamond rule determines the start and end pixels.  (Recall that
// the sides are exclusive except for the left and top vertices.)
// This convention can be thought of in another way: there are diamonds
// around the pixels, and wherever the true line crosses a diamond,
// that pel is illuminated.
// 
// Consider a line where we've done the flips to the first octant, and the
// floor of the start coordinates is the origin:
// 
//        +-----------------------> +x
//        |
//        | 0                     1
//        |     0123456789abcdef
//        |
//        |   0 00000000?1111111
//        |   1 00000000 1111111
//        |   2 0000000   111111
//        |   3 000000     11111
//        |   4 00000    ** 1111
//        |   5 0000       ****1
//        |   6 000           1***
//        |   7 00             1  ****
//        |   8 ?                     ***
//        |   9 22             3         ****
//        |   a 222           33             ***
//        |   b 2222         333                ****
//        |   c 22222       3333                    **
//        |   d 222222     33333
//        |   e 2222222   333333
//        |   f 22222222 3333333
//        |
//        | 2                     3
//        v
//        +y
// 
// If the start of the line lands on the diamond around pixel 0 (shown by
// the '0' region here), pixel 0 is the first pel in the line.  The same
// is true for the other pels.
// 
// A little more work has to be done if the line starts in the
// 'nether-land' between the diamonds (as illustrated by the '*' line):
// the first pel lit is the first diamond crossed by the line (pixel 1 in
// our example).  This calculation is determined by the DDA or slope of
// the line.
// 
// If the line starts exactly half way between two adjacent pixels
// (denoted here by the '?' spots), the first pixel is determined by our
// round-down convention (and is dependent on the flips done to
// normalize the line).
// 
// Last Pel Exclusive
// ------------------
// 
// To eliminate repeatedly lit pels between continuous connected lines,
// we employ a last-pel exclusive convention: if the line ends exactly on
// the diamond around a pel, that pel is not lit.  (This eliminates the
// checks we had in the old code to see if we were re-lighting pels.)
// 
// The Half Flip
// -------------
// 
// To make our run length algorithm more efficient, we employ a "half
// flip".  If after normalizing to the first octant, the slope is more
// than 1/2, we subtract the y coordinate from the x coordinate.  This
// has the effect of reflecting the coordinates through the line of slope
// 1/2.  Note that the diagonal gets mapped into the x-axis after a half
// flip.
// 
// How Many Bits Do We Need, Anyway?
// ---------------------------------
// 
// Note that if the line is visible on your screen, you must light up
// exactly the correct pixels, no matter where in the 28.4 x 28.4 device
// space the end points of the line lie (meaning you must handle 32 bit
// DDAs, you can certainly have optimized cases for lesser DDAs).
// 
// We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
// calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
// are in the first octant, so dM >= dN.  Then we know that gamma can
// be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
// valid lines will have dM and dN values at most 31 bits (unsigned)
// of significance.  So gamma requires 33 bits of significance (we store
// this as a 64 bit number for convenience).
// 
// When running through the DDA loop, r  + dR can have a value in the
//                                     j
// range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
//             j
// 
// Testing Lines
// -------------
// 
// To be NT compliant, a display driver must exactly adhere to GIQ,
// which means that for any given line, the driver must light exactly
// the same pels as does GDI.  This can be tested using the Guiman tool
// provided elsewhere in the DDK, and 'ZTest', which draws random lines
// on the screen and to a bitmap, and compares the results.
// 
// If You've Got Line Hardware
// ---------------------------
// 
// If your hardware already adheres to GIQ, you're all set.  Otherwise
// you'll want to look at the S3 sample code and read the following:
// 
// 1) You'll want to special case integer-only lines, since they require
//    less processing time and are more common (CAD programs will probably
//    only ever give integer lines).  GDI does not provide a flag saying
//    that all lines in a path are integer lines; consequently, you will
//    have to explicitly check every line.
// 
// 2) You are required to correctly draw any line in the 28.4 device
//    space that intersects the viewport.  If you have less than 32 bits
//    of significance in the hardware for the Bresenham terms, extremely
//    long lines would overflow the hardware.  For such (rare) cases, you
//    can fall back to strip-drawing code, of which there is a C version in
//    the S3's lines.cxx (or if your display is a frame buffer, fall back
//    to the engine).
// 
// 3) If you can explicitly set the Bresenham terms in your hardware, you
//    can draw non-integer lines using the hardware.  If your hardware has
//    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
//    pels long (4 bits are required for the fractional part, and one bit is
//    used as a sign bit).  Note that integer lines don't require the 4
//    fractional bits, so if you special case them as in 1), you can do
//    integer lines that are up to 2^(n - 1) pels long.  See the S3's
//    fastline.asm for an example.
// 
//------------------------------------------------------------------------------
BOOL
bLines(PDev*      ppdev,
       POINTFIX*  pptfxFirst,  // Start of first line
       POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
       RUN*       prun,        // Pointer to runs if doing complex clipping
       ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                               // in prun
       LINESTATE* pls,         // Colour and style info
       RECTL*     prclClip,    // Pointer to clip rectangle if doing simple
                               // clipping
       PFNSTRIP   apfn[],      // Array of strip functions
       FLONG      flStart)     // Flags for each line

{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx - 1; // Last point in path record
    STYLEPOS  spThis;                             // Style pos for this line

    LONG xmask  = 0xffff800f;
    LONG ymask  = 0xffffc00f;
    LONG xmask1 = 0xffff8000;
    LONG ymask1 = 0xffffc000;
    PERMEDIA_DECL;

    do
    {
        //
        // Start the DDA calculations
        //
        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        //
        // Check for non-complex-clipped, non-styled integer endpoint lines
        // Essentially, we allow rendering of any line which 'looks' like an
        // unclipped solid line. Initialization of hardware will cause the
        // correct results to appear
        //
        if ((fl & (FL_COMPLEX_CLIP | FL_STYLED))  == 0 )
        {
            LONG orx = (LONG) (M0 | dM);
            LONG ory = (LONG) (N0 | dN);

            if (orx < 0)
            {
                // At least one point was negative. Compute using abs points.
                orx = ABS((LONG)M0) | ABS((LONG)dM);
            }
            if (ory < 0)
            {
                // At least one point was negative. Compute using abs points.
                ory = ABS((LONG)N0) | ABS((LONG)dN);
            }

            DBG_GDI((7, "Lines: Trying Fast Integer %x %x %x %x", 
                     M0, N0, dM, dN));

            // Call fast integer line routines it integer coordinates
            if (((orx & xmask) == 0) && ((ory & ymask) == 0))
            {
                if (bFastIntegerLine(ppdev, M0, N0, dM, dN))
                {

                    if ((fl & FL_READ))
                    {
                        // If we have a logical op which requires reading from
                        // the frame buffer, we cannot guarantee 
                        // ContinueNewLine's behaviour when overwriting pixels.
                        // Also, avoid ContinueNewLine on an MX.
                        pptfxFirst = pptfxBuf;
                        pptfxBuf++;
                        continue;
                    }
                    else
                    {
                        // This is an optimization to use continue new line
                        // to draw any subequent integer lines. The loop is
                        // essentially the same as the outer loop, however, we
                        // dont need to check for a lot of things that we already
                        // know. We need to be able to fall out to the standard
                        // outer loop if we cant handle a line though.

                        while (TRUE)
                        {
                            // Have we reached the end of the list of points.
                            if (pptfxBuf == pptfxBufEnd)
                                return(TRUE);

                            pptfxFirst = pptfxBuf;
                            pptfxBuf++;

                            M0 = dM;
                            N0 = dN;
                            dM = (LONG) pptfxBuf->x;
                            dN = (LONG) pptfxBuf->y;

                            // We know M0 and N0 satisfy our criteria for a
                            // continue new line. Therefore, we just have to
                            // check the new coordinates
                            orx = (LONG) dM;
                            ory = (LONG) dN;

                            if (orx < 0)
                            {
                                // At least one point was negative.
                                // Recompute or using abs.
                                orx = ABS((LONG)dM);
                            }
                            if (ory < 0)
                            {
                                // At least one point was negative.
                                // Recompute or using abs.
                                ory = ABS((LONG)dN);
                            }

                            // We need to call the routine to continue
                            // the line now.  If the line is not a fast integer
                            // line, then we need to break out and try non
                            // integer lines. In this case, or will still be 
                            // valid, because we know M0, N0 are integer coords
                            // that Permedia2 can handle.
                            DBG_GDI((7, "Lines: Trying %x %x %x %x",
                                     M0, N0, dM, dN));
                            if (((orx & xmask) != 0) ||
                                ((ory & ymask) != 0) ||
                                (!bFastIntegerContinueLine(
                                                          ppdev, M0, N0, dM, dN)))
                                // Either we cant draw the line or the strip
                                //  drawer failed.
                                break;
                        }
                    }
                }
            }

            // Call fast non integer line routines.
            if (((orx & xmask1) == 0) && ((ory & ymask1) == 0))
            {
                if (bFastLine(ppdev, M0, N0, dM, dN))
                {
                    // This line done, do next line.
                    pptfxFirst = pptfxBuf;
                    pptfxBuf++;
                    continue;
                }
            }
        }

        DBG_GDI((7, "Lines: Slow Lines %x %x %x %x", M0, N0, dM, dN));

        if ((LONG) M0 > (LONG) dM)
        {
            // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

        // Compute the delta dx.  The DDI says we can never have a valid delta
        // with a magnitude more than 2^31 - 1, but GDI never actually checks
        // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
            // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;
        if ((LONG) dN < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

        // We now have a line running left-to-right, top-to-bottom from (M0, N0)
        // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
                // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
                // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        //
        // Convert M0 and N0 from 28.4 format to normal interger
        //
        x = LFLOOR((LONG)M0);
        y = LFLOOR((LONG)N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

        // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = Int32x32To64(dM, N0 + FBITS/2) - Int32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

        //
        // Figure out which pixels are at the ends of the line.
        //

        // The toughest part of GIQ is determining the start and end pels.
        //
        // Our approach here is to calculate x0 and x1 (the inclusive start
        // and end columns of the line respectively, relative to our normalized
        // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
        // start point is easily calculated by plugging x0 into our line equation
        // (which takes care of whether y = 1/2 rounds up or down in value)
        // getting y0, and then undoing the normalizing flips to get back
        // into device space.
        //
        // We look at the fractional parts of the coordinates of the start and
        // end points, and call them (M0, N0) and (M1, N1) respectively, where
        // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
        // to determine x0:
        //
        //   +-----------------------> +x
        //   |
        //   | 0                     1
        //   |     0123456789abcdef
        //   |
        //   |   0 ........?xxxxxxx
        //   |   1 ..........xxxxxx
        //   |   2 ...........xxxxx
        //   |   3 ............xxxx
        //   |   4 .............xxx
        //   |   5 ..............xx
        //   |   6 ...............x
        //   |   7 ................
        //   |   8 ................
        //   |   9 ......**........
        //   |   a ........****...x
        //   |   b ............****
        //   |   c .............xxx****
        //   |   d ............xxxx    ****
        //   |   e ...........xxxxx        ****
        //   |   f ..........xxxxxx
        //   |
        //   | 2                     3
        //   v
        //
        //   +y
        //
        // This grid accounts for the appropriate rounding of GIQ and last-pel
        // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
        // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // For the end point, if (M1, N1) lands on an 'x', x1 =
        // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
        // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // Lines of exactly slope one require a special case for both the start
        // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
        // the line has gone exactly through (8, 0) -- which may be considered
        // to be part of 'x' because of rounding!  So slopes of exactly slope
        // one going through (8, 0) must also be considered as belonging in 'x'.
        //
        // For lines that go left-to-right, we have the following grid:
        //
        //   +-----------------------> +x
        //   |
        //   | 0                     1
        //   |     0123456789abcdef
        //   |
        //   |   0 xxxxxxxx?.......
        //   |   1 xxxxxxx.........
        //   |   2 xxxxxx..........
        //   |   3 xxxxx...........
        //   |   4 xxxx............
        //   |   5 xxx.............
        //   |   6 xx..............
        //   |   7 x...............
        //   |   8 x...............
        //   |   9 x.....**........
        //   |   a xx......****....
        //   |   b xxx.........****
        //   |   c xxxx............****
        //   |   d xxxxx...........    ****
        //   |   e xxxxxx..........        ****
        //   |   f xxxxxxx.........
        //   |
        //   | 2                     3
        //   v
        //
        //   +y
        //
        // This grid accounts for the appropriate rounding of GIQ and last-pel
        // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
        // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // For the end point, if (M1, N1) lands on an 'x', x1 =
        // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
        // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
        // depending on what flips have been done to normalize the line.
        //
        // Lines of exactly slope one must be handled similarly to the right-to-
        // left case.

        {

            // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            //
            // Store normal integer in x1, not 28.4 format
            //
            x1 = LFLOOR(M0 + dM);

            if (fl & FL_FLIP_H)
            {
                // Line runs right-to-left:  <----

                // Compute x1:

                if (N1 == 0)
                {
                    if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                    {
                        x1++;
                    }
                }
                else if (ABS((LONG) (N1 - FBITS/2)) + M1 > FBITS)
                {
                    x1++;
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    == (FL_FLIP_SLOPE_ONE))
                {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                    if ((N1 > 0) && (M1 == N1 + 8))
                        x1++;

                    if ((N0 > 0) && (M0 == N0 + 8))
                    {
                        x0      = 2;
                        ulDelta = dN;
                        goto right_to_left_compute_y0;
                    }
                }

                // Compute x0:

                x0      = 1;
                ulDelta = 0;
                if (N0 == 0)
                {
                    if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }
                }
                else if (ABS((LONG) (N0 - FBITS/2)) + M0 > FBITS)
                {
                    x0      = 2;
                    ulDelta = dN;
                }

                // Compute y0:

                right_to_left_compute_y0:

                y0 = 0;
                ll = llGamma + (LONGLONG) ulDelta;

                if (ll >= (LONGLONG) (2 * dM - dN))
                    y0 = 2;
                else if (ll >= (LONGLONG) (dM - dN))
                    y0 = 1;
            }
            else
            {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                x1--;

                if (M1 > 0)
                {
                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                            x1++;
                    }
                    else if (ABS((LONG) (N1 - FBITS/2)) <= (LONG) M1)
                    {
                        x1++;
                    }
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                    if ((M1 > 0) && (N1 == M1 + 8))
                        x1--;

                    if ((M0 > 0) && (N0 == M0 + 8))
                    {
                        x0 = 0;
                        goto left_to_right_compute_y0;
                    }
                }

                // Compute x0:

                x0 = 0;
                if (M0 > 0)
                {
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                            x0 = 1;
                    }
                    else if (ABS((LONG) (N0 - FBITS/2)) <= (LONG) M0)
                    {
                        x0 = 1;
                    }
                }

                // Compute y0:

                left_to_right_compute_y0:

                y0 = 0;
                if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                {
                    y0 = 1;
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

        //
        // Complex clipping.                                                     *
        //

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

            Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
                // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
                // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

            // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

            // No overflow since large integer math is used.  Both values
            // will be positive:

            dl = Int32x32To64(x0, dN) + llGamma;

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

        //
        // Simple rectangular clipping.
        //

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

            // Note that y0 and y1 are actually the lower and upper bounds,
            // respectively, of the y coordinates of the line (the line may
            // have actually shrunk due to first/last pel clipping).
            //
            // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

            // Normalize to the same point we've normalized for the DDA
            // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
                Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

            // We have to know the correct y1, which we haven't bothered to
            // calculate up until now.  This multiply and divide is quite
            // expensive; we could replace it with code similar to that which
            // we used for computing y0.
            //
            // The reason why we need the actual value, and not an upper
            // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
            // careful when calculating x(y) that y0 <= y <= y1, otherwise
            // we can overflow on the divide (which, needless to say, is very
            // bad).

            dl = Int32x32To64(x1, dN) + llGamma;

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = Int32x32To64(y1, dM) + llBeta;

                x1 = UInt64Div32To32(dl, dN);
            }

            // At this point, we've taken care of calculating the intercepts
            // with the right and bottom edges.  Now we work on the left and
            // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = Int32x32To64(x0, dN) + llGamma;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = Int32x32To64(y0, dM) + llBeta;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

        //
        // Done clipping.  Unflip if necessary.
        //

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

        // Style calculations.

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_ARBITRARYSTYLED, "Oops");

                // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                    // The modulus of a negative number is not well-defined
                    // in C -- if it's negative we'll adjust it so that it's
                    // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

                // Since we always draw the line left-to-right, but styling is
                // always done in the direction of the original line, we have
                // to figure out where we are in the style array for the left
                // edge of this line.

                if (fl & FL_FLIP_H)
                {
                    // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                    // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                         "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED) &&
            !(fl & FL_DONT_DO_HALF_FLIP))
        {
            // Do a half flip!  Remember that we may doing this on the
            // same line multiple times for complex clipping (meaning the
            // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

        // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

        // Now calculate the DDA variables needed to figure out how many pixels
        // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
            ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = Int32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

            //
            // Run the DDA!                                                          *
            //
            while (TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }
    } while (pptfxBuf <= pptfxBufEnd);

    return(TRUE);
}// bLines()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\hw.h ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: hw.h
*
* All the hardware defines and typedefs.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#ifndef _HW_H_
#define _HW_H_

#include "p2def.h"

//
// Texture memory allocation macros and structures are in 3DPrivTx.h
//
//
// Definition of handle to a memory region
//
typedef  LONG HMEMREGION;
typedef  LONG HMEMCACHE;
typedef enum
{
    RESIDENCY_NOTLOADED,
    RESIDENCY_PERMANENT,
    RESIDENCY_TRANSIENT,
    RESIDENCY_HOST
} MEM_MGR_RESIDENCY;

//
// Extern declarations
//
extern DWORD    LogicopReadDest[];      // Indicates which logic ops need dest
                                        // read turned on
extern DWORD    ConfigReadDest[];
extern UCHAR    LBWidthBits[];

//
// Definition of counter data area for performance counters (PERFCTR)
//
extern PVOID    pCounterBlock;

//
// Values for flags in HwDataRec
//
typedef enum
{
    GLICAP_NT_CONFORMANT_LINES    = 0x00000001, // draw NT conformant lines
    GLICAP_HW_WRITE_MASK          = 0x00000002, // hardware planemasking
};

typedef int PERMEDIA2_CAPS;

//
// SCISSOR stuff
//
#define SCREEN_SCISSOR_DEFAULT  (0 << 1)
#define SCISSOR_MAX 2047            // Maximum scissor size in P2

//
// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the miniport drivers permedia.h
//
typedef struct _Hw_Device_Info
{
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    LONG  LocalbufferWidth;
    ULONG ActualDacId;
} Hw_Device_Info;


typedef struct tagP2CtxtRec *P2CtxtPtr;

typedef struct _hw_data
{
    DWORD       renderBits;         // Saved render bits set by setup routines
    DWORD       FBWriteMode;        // Software copy of FBWriteMode register
    DWORD       RasterizerMode;     // Software copy of the rasterizer mode
    DWORD       FBPacking;          // Software copy of FBModeSel
    DWORD       FBBlockColor;       // Software copy of FBBlockColor (P1 only)
    DWORD       TextureAddressMode; // Software copy of TextureAddressMode
                                    // (P2 only)
    DWORD       TextureReadMode;    // Software copy of TextureReadMode
                                    // (P2 only)

    ULONG       currentCSbuffer;    // Color space buffer being displayed
    PERMEDIA2_CAPS  flags;          // Various flags

    P2CtxtPtr   pGDICtxt;           // id of the display driver's context for
                                    // this board
    LONG        PixelOffset;        // Last DFB pixel offset

    ULONG       PerfScaleShift;

    PVOID       ContextTable;       // Array of extant contexts
    P2CtxtPtr   pCurrentCtxt;       // id of this board's current context

    union
    {
        UCHAR       _clutBuffer[MAX_CLUT_SIZE];
        VIDEO_CLUT  gammaLUT;       // Saved gamma LUT contents
    };

    //
    // PCI configuration id information
    //
    Hw_Device_Info deviceInfo;
} HwDataRec, *HwDataPtr;


#define TRANSLATE_ADDR_ULONG(a) (a)     //TODO: should be removed in pointer.c

//
// If we have a sparsely mapped framebuffer then we use the xx_REGISTER_ULONG()
// macros, otherwise we just access the framebuffer.
//
#define READ_SCREEN_ULONG(a)\
    ((ppdev->flCaps & CAPS_SPARSE_SPACE) ?\
      (READ_REGISTER_ULONG(a)) : *((ULONG volatile *)(a)))

#define WRITE_SCREEN_ULONG(a,d)\
    ((ppdev->flCaps & CAPS_SPARSE_SPACE) ?\
      (WRITE_REGISTER_ULONG(a,d)) : (*((ULONG volatile *)(a)) = (d)))

//
// Generic macros to access Permedia 2 FIFO and non-FIFO control registers.
// We do nothing sophisticated for the Alpha. We just MEMORY_BARRIER
// everything.
//

#define LD_PERMEDIA_REG(x,y) \
{   \
    WRITE_REGISTER_ULONG(&(ppdev->pCtrlBase[x/sizeof(ULONG)]),y); \
    MEMORY_BARRIER();\
}
    
#define READ_PERMEDIA_REG(x) \
    READ_REGISTER_ULONG(&(ppdev->pCtrlBase[x/sizeof(ULONG)]))

#define READ_PERMEDIA_FIFO_REG(uiTag, d) \
    ((d) = READ_REGISTER_ULONG(&(ppdev->pCoreBase[uiTag*2])))

#define READ_FIFO_REG(uiTag)\
    READ_REGISTER_ULONG(&ppdev->pCoreBase[uiTag*2])

//
// Local variables for all functions that access PERMEDIA 2. Generally we
// use PERMEDIA_DECL. Sometimes we have to split it up if ppdev isn't
// passed into the routine.
//
#define PERMEDIA_DECL_VARS \
    HwDataPtr permediaInfo;

#define PERMEDIA_DECL_INIT \
    permediaInfo = (HwDataPtr)(ppdev->permediaInfo);

#define PERMEDIA_DECL \
    PERMEDIA_DECL_VARS; \
    PERMEDIA_DECL_INIT

// TODO: move to debug???
#if DBG
    VOID vCheckDefaultState(P2DMA * pP2dma);

    #define P2_CHECK_STATE vCheckDefaultState(ppdev->pP2dma)
#else
    #define P2_CHECK_STATE
#endif

//
// Pointer interrupts not enabled so just provide stub definitions
//
#define SYNCHRONOUS_WRITE_ULONG(var, value)
#define SYNCHRONOUS_WRITE_INDIRECT_ULONG(pvar, value)
#define GET_INTR_CMD_BLOCK_MUTEX
#define RELEASE_INTR_CMD_BLOCK_MUTEX

//
// FIFO functions
//
#define MAX_P2_FIFO_ENTRIES         256


#define P2_DEFAULT_FB_DEPTH  P2_SET_FB_DEPTH(ppdev->cPelSize)
#define P2DEPTH8             0
#define P2DEPTH16            1
#define P2DEPTH32            2

//
// External interface to the context switching code. The caller can allocate and
// free a context or ask for a switch to a new context. vSwitchContext
// should not be called except through the given macro. The macro assumes
// that ppdev has been defined.
//
typedef enum
{
    P2CtxtReadWrite,
    P2CtxtWriteOnly,
    P2CtxtUserFunc
} P2CtxtType;

P2CtxtPtr P2AllocateNewContext(PPDev ppdev, 
                          DWORD *pReglist, 
                          LONG lEntries, 
                          P2CtxtType dwCtxtType=P2CtxtReadWrite
                          );

VOID P2FreeContext  (PPDev, P2CtxtPtr);
VOID P2SwitchContext(PPDev, P2CtxtPtr);

//
// Macro used by display driver to validate its context
//
#define VALIDATE_GDI_CONTEXT                                                 \
    P2_VALIDATE_CONTEXT(permediaInfo->pGDICtxt)

//
// Useful macros not defined in standard Permedia 2 header files. Generally, for
// speed we don't want to use the bitfield structures so we define the bit
// shifts to get at the various fields.
//
#define INTtoFIXED(i)   ((i) << 16)         // int to 16.16 fixed format
#define FIXEDtoINT(i)   ((i) >> 16)         // 16.16 fixed format to int
#define INTofFIXED(i)   ((i) & 0xffff0000)  // int part of 16.16
#define FRACTofFIXED(i) ((i) & 0xffff)      // fractional part of 16.16

#define FIXtoFIXED(i)   ((i) << 12)         // 12.4 to 16.16
#define FIXtoINT(i)     ((i) >> 4)          // 28.4 to 28

#define __PERMEDIA_CONSTANT_FB_WRITE   (1 << (4+1))
#define __COLOR_DDA_FLAT_SHADE      (__PERMEDIA_ENABLE | \
                                        (__PERMEDIA_FLAT_SHADE_MODE << 1))
#define __COLOR_DDA_GOURAUD_SHADE   (__PERMEDIA_ENABLE | \
                                        (__PERMEDIA_GOURAUD_SHADE_MODE << 1))

#define INVERT_BITMASK_BITS         (1 << 1)
#define BYTESWAP_BITMASK            (3 << 7)
#define FORCE_BACKGROUND_COLOR      (1 << 6)    // Permedia only

//
// Bits in the Render command
//
#define __RENDER_INCREASE_Y             (1 << 22)
#define __RENDER_INCREASE_X             (1 << 21)
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_REUSE_BIT_MASK         (1 << 17)
#define __RENDER_TEXTURE_ENABLE         (1 << 13)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_RECTANGLE_PRIMITIVE    (__PERMEDIA_RECTANGLE_PRIMITIVE << 6)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__PERMEDIA_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__PERMEDIA_LINE_PRIMITIVE << 6)
#define __RENDER_POINT_PRIMITIVE        (__PERMEDIA_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)

//
// Bits in the ScissorMode register
//
#define USER_SCISSOR_ENABLE             (1 << 0)
#define SCREEN_SCISSOR_ENABLE           (1 << 1)
#define SCISSOR_XOFFSET                 0
#define SCISSOR_YOFFSET                 16

//
// Bits in the FBReadMode register
//
#define __FB_READ_SOURCE                (1 << 9)
#define __FB_READ_DESTINATION           (1 << 10)
#define __FB_COLOR                      (1 << 15)
#define __FB_WINDOW_ORIGIN              (1 << 16)
#define __FB_PACKED_DATA                (1 << 19)

//
// Extra bits in PERMEDIA FBReadMode
//
#define __FB_RELATIVE_OFFSET            20

//
// P2 also provides a version of Relative Offset in the PackedDataLimits
// register
//
#define __PDL_RELATIVE_OFFSET           29

//
// Bits in the LBReadMode register
//
#define __LB_READ_SOURCE                (1 << 9)
#define __LB_READ_DESTINATION           (1 << 10)
#define __LB_STENCIL                    (1 << 16)
#define __LB_DEPTH                      (1 << 17)
#define __LB_WINDOW_ORIGIN              (1 << 18)
#define __LB_READMODE_PATCH             (1 << 19)
#define __LB_SCAN_INTERVAL_2            (1 << 20)

//
// Bits in the DepthMode register
//
#define __DEPTH_ENABLE                  1
#define __DEPTH_WRITE_ENABLE            (1<<1)
#define __DEPTH_REGISTER_SOURCE         (2<<2)
#define __DEPTH_MSG_SOURCE              (3<<2)
#define __DEPTH_ALWAYS                  (7<<4)

//
// Bits in the LBReadFormat/LBWriteFormat registers
//
#define __LB_FORMAT_DEPTH32             2

//
// Macros to load indexed tags more efficiently than using __HwDMATag struct
//
#define P2_TAG_MAJOR(x)              ((x) & 0xff0)
#define P2_TAG_MINOR(x)              ((x) & 0x00f)

#define P2_TAG_MAJOR_INDEXED(x)                                          \
    ((__PERMEDIA_TAG_MODE_INDEXED << (5+4+1+4)) | P2_TAG_MAJOR(x))
#define P2_TAG_MINOR_INDEX(x)                                            \
    (1 << (P2_TAG_MINOR(x) + 16))

//
// Macro to take a permedia2 logical op and return the enabled LogcialOpMode bits
//
#define P2_ENABLED_LOGICALOP(op)     (((op) << 1) | __PERMEDIA_ENABLE)

#define RECTORIGIN_YX(y,x)              (((y) << 16) | ((x) & 0xFFFF))

//
// Area stipple shifts and bit defines
//
#define AREA_STIPPLE_XSEL(x)            ((x) << 1)
#define AREA_STIPPLE_YSEL(y)            ((y) << 4)
#define AREA_STIPPLE_XOFF(x)            ((x) << 7)
#define AREA_STIPPLE_YOFF(y)            ((y) << 12)
#define AREA_STIPPLE_INVERT_PAT         (1 << 17)
#define AREA_STIPPLE_MIRROR_X           (1 << 18)
#define AREA_STIPPLE_MIRROR_Y           (1 << 19)

//
// We always use 8x8 monochrome brushes.
//
#define AREA_STIPPLE_8x8_ENABLE                                             \
    (__PERMEDIA_ENABLE |                                                    \
    AREA_STIPPLE_XSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN) |            \
    AREA_STIPPLE_YSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN))

//
// RasteriserMode values
//
#define BIAS_NONE                  (__PERMEDIA_START_BIAS_ZERO << 4)
#define BIAS_HALF                  (__PERMEDIA_START_BIAS_HALF << 4)
#define BIAS_NEARLY_HALF           (__PERMEDIA_START_BIAS_ALMOST_HALF << 4)

#define FRADJ_NONE                 (__PERMEDIA_FRACTION_ADJUST_NONE << 2)
#define FRADJ_ZERO                 (__PERMEDIA_FRACTION_ADJUST_TRUNC << 2)
#define FRADJ_HALF                 (__PERMEDIA_FRACTION_ADJUST_HALF << 2)
#define FRADJ_NEARLY_HALF          (__PERMEDIA_FRACTION_ADJUST_ALMOST_HALF << 2)


//
// Some constants
//
#define ONE                         0x00010000
#define MINUS_ONE                   0xFFFF0000
#define PLUS_ONE                    ONE
#define NEARLY_ONE                  0x0000FFFF
#define HALF                        0x00008000
#define NEARLY_HALF                 0x00007FFF

//
// Max length of GIQ conformant lines that Permedia2 can draw
// Permedia has only 15 bits of fraction so reduce the lengths.
//
#define MAX_LENGTH_CONFORMANT_NONINTEGER_LINES  (16/2)
#define MAX_LENGTH_CONFORMANT_INTEGER_LINES     (194/2)

//
// We need to byte swap monochrome bitmaps. On 486 we can do this with
// fast assembler.
//
#if defined(_X86_)
//
// This only works on a 486 so the driver won't run on a 386.
//
#define LSWAP_BYTES(dst, pSrc)                                              \
{                                                                           \
    __asm mov eax, pSrc                                                     \
    __asm mov eax, [eax]                                                    \
    __asm bswap eax                                                         \
    __asm mov dst, eax                                                      \
}
#else
#define LSWAP_BYTES(dst, pSrc)                                              \
{                                                                           \
    ULONG   _src = *(ULONG *)pSrc;                                           \
    dst = ((_src) >> 24) |                                                   \
          ((_src) << 24) |                                                   \
          (((_src) >> 8) & 0x0000ff00) |                                     \
          (((_src) << 8) & 0x00ff0000);                                      \
}

#endif

// macro to swap the Red and Blue component of a 32 bit dword
//

#define SWAP_BR(a) ((a & 0xff00ff00l) | \
                   ((a&0xff0000l)>> 16) | \
                   ((a & 0xff) << 16))

//
// min. and max. values for Permedia PP register
#define MAX_PARTIAL_PRODUCT_P2          10
#define MIN_PARTIAL_PRODUCT_P2          5

//
// Permedia2 DMA definitions
//
#include "mini.h"
// structure definitions passed in by the application for mapping and
// unmapping DMA buffers.
//

//
// Registry variable names
//
#define REG_USE_SOFTWARE_WRITEMASK      L"UseSoftwareWriteMask"

//
// Function declarations
//
VOID  vDoMonoBitsDownload(PPDev, BYTE*, LONG, LONG, LONG, LONG);
BOOL bInitializeHW(PPDev);
VOID vDisableHW(PPDev);
VOID vAssertModeHW(PPDev, BOOL);
VOID vP2ChangeFBDepth(PPDev, ULONG);

//
// Calculate the packed partial products
//
VOID    vCalcPackedPP(LONG width, LONG * outPitch, ULONG * outPackedPP);

VOID        vSetNewGammaValue(PPDev ppdev, ULONG ulgvFIX16_16);
BOOL        bInstallGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut);

//
// The following structures and macros define the memory map for the Permedia2
// control registers. We don't use this memory map to access Permedia2 registers
// since on Alpha machines we want to precompute the addresses. So we do
// a TRANSLATE_ADDR_ULONG on all the addresses here and save them into a
// P2RegAddrRec. We use that to obtain the addresses for the different
// registers.
//
typedef struct
{
    ULONG   reg;
    ULONG   pad;
} RAMDAC_REG;

//
// Macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The
// id is irrelevant as long as it's different from every other id used in the
// same struct. It's a pity pad##__LINE__ doesn't work.
//
//#define PAD(id, n)              UCHAR   pad##id[n]


//
// Interrupt status bits
//
typedef enum
{
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
} INTERRUPT_CONTROL;

extern DWORD    LogicopReadDest[];  // Indicates which logic ops need dest read
                                    // turned on

#define INTtoFIXED(i)               ((i) << 16)    // int to 16.16 fixed format
#define FIXEDtoINT(i)               ((i) >> 16)    // 16.16 fixed format to int

#define __PERMEDIA_CONSTANT_FB_WRITE                                        \
    (1 << (4+1))
#define __COLOR_DDA_FLAT_SHADE                                              \
    (__PERMEDIA_ENABLE | (__PERMEDIA_FLAT_SHADE_MODE << 1))
#define __COLOR_DDA_GOURAUD_SHADE                                           \
    (__PERMEDIA_ENABLE | (__PERMEDIA_GOURAUD_SHADE_MODE << 1))

#define INVERT_BITMASK_BITS    (1 << 1)

//
// Bits in the Render command
//
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__PERMEDIA_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__PERMEDIA_LINE_PRIMITIVE << 6)
#define __RENDER_POINT_PRIMITIVE        (__PERMEDIA_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)
#define __RENDER_TEXTURED_PRIMITIVE     (1 << 13)

//
// Bits in the ScissorMode register
//
#define USER_SCISSOR_ENABLE             (1 << 0)
#define SCREEN_SCISSOR_ENABLE           (1 << 1)
#define SCISSOR_XOFFSET                 0
#define SCISSOR_YOFFSET                 16

//
// Bits in the FBReadMode register
//
#define __FB_READ_SOURCE                (1 << 9)
#define __FB_READ_DESTINATION           (1 << 10)
#define __FB_COLOR                      (1 << 15)
#define __FB_WINDOW_ORIGIN              (1 << 16)
#define __FB_USE_PACKED                 (1 << 19)

//
// Bits in the LBReadMode register
//
#define __LB_READ_SOURCE                (1 << 9)
#define __LB_READ_DESTINATION           (1 << 10)
#define __LB_STENCIL                    (1 << 16)
#define __LB_DEPTH                      (1 << 17)
#define __LB_WINDOW_ORIGIN              (1 << 18)

//
// Area stipple shifts and bit defines
//
#define AREA_STIPPLE_XSEL(x)            ((x) << 1)
#define AREA_STIPPLE_YSEL(y)            ((y) << 4)
#define AREA_STIPPLE_XOFF(x)            ((x) << 7)
#define AREA_STIPPLE_YOFF(y)            ((y) << 12)
#define AREA_STIPPLE_INVERT_PAT         (1 << 17)
#define AREA_STIPPLE_MIRROR_X           (1 << 18)
#define AREA_STIPPLE_MIRROR_Y           (1 << 19)

// we always use 8x8 monochrome brushes.
#define AREA_STIPPLE_8x8_ENABLE \
        (__PERMEDIA_ENABLE | \
         AREA_STIPPLE_XSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN) | \
         AREA_STIPPLE_YSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN))

#define DEFAULTWRITEMASK 0xffffffffl


// *******************************************************************
// Permedia Bit Field Macros

// FBReadMode 
#define PM_FBREADMODE_PARTIAL(a)           ((a) << 0)
#define PM_FBREADMODE_READSOURCE(a)        ((a) << 9)
#define PM_FBREADMODE_READDEST(a)          ((a) << 10)
#define PM_FBREADMODE_PATCHENABLE(a)       ((a) << 18)
#define PM_FBREADMODE_PACKEDDATA(a)        ((a) << 19)
#define PM_FBREADMODE_RELATIVEOFFSET(a)    ((a) << 20)
#define PM_FBREADMODE_PATCHMODE(a)         ((a) << 25)

// Texture read mode
#define PM_TEXREADMODE_ENABLE(a)         ((a) << 0)
#define PM_TEXREADMODE_WIDTH(a)          ((a) << 9)
#define PM_TEXREADMODE_HEIGHT(a)         ((a) << 13)
#define PM_TEXREADMODE_FILTER(a)         ((a) << 17)

// PackedDataLimits
#define PM_PACKEDDATALIMITS_OFFSET(a)    ((a) << 29)
#define PM_PACKEDDATALIMITS_XSTART(a)    ((a) << 16)
#define PM_PACKEDDATALIMITS_XEND(a)      ((a) << 0)

// Window Register
#define PM_WINDOW_LBUPDATESOURCE(a)      ((a) << 4)
#define PM_WINDOW_DISABLELBUPDATE(a)     ((a) << 18)

// Colors
#define PM_BYTE_COLOR(a) ((a) << 15)

// Config register
#define PM_CHIPCONFIG_AGPCAPABLE (1 << 9)


static __inline int log2(int s)
{
    int d = 1, iter = -1;
    do {
         d *= 2;
         iter++;
    } while (d <= s);
    return iter;
}

VOID
P2DisableAllUnits(PPDev ppdev);

#if DBG && TRACKMEMALLOC
#define ENGALLOCMEM( opt, size, tag)\
    MEMTRACKERALLOCATEMEM( EngAllocMem( opt, size, tag), size, __FILE__, __LINE__, FALSE)
#define ENGFREEMEM( obj)\
    { MEMTRACKERFREEMEM(obj); EngFreeMem( obj);}
#else
#define ENGALLOCMEM( opt, size, tag)\
    EngAllocMem( opt, size, tag)
#define ENGFREEMEM( obj)\
    EngFreeMem( obj)
#endif
    

#endif  // _HW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\lineto.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: lineto.c
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "rops.h"
#include "log.h"

//-----------------------------------------------------------------------------
// BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
//
// DrvLineTo() is an optimised, integer co-ordinate, API call that doesn't
// support styling. The integer-line code in Strips.c is called to do the 
// hard work.
//
//
//-----------------------------------------------------------------------------

BOOL
DrvLineTo(
    SURFOBJ*  pso,
    CLIPOBJ*  pco,
    BRUSHOBJ* pbo,
    LONG      x1,
    LONG      y1,
    LONG      x2,
    LONG      y2,
    RECTL*    prclBounds,
    MIX       mix)
{
    PDev*     ppdev;
    Surf*     psurf;
    BOOL      bResetHW;
    DWORD     logicOp;
    RECTL*    prclClip = (RECTL*)NULL;
    BOOL      retVal;
    ULONG     iSolidColor = pbo->iSolidColor;
    BOOL      bResult;

    //
    // PUnt call to engine if not in video memory
    //
    psurf = (Surf*)pso->dhsurf;
    
    if (psurf->flags & SF_SM)
    {
        goto puntIt;
    }

    if (pco != NULL)
    {
        if( pco->iDComplexity == DC_COMPLEX)
        {
            // hardware does not support complex clipping
            goto puntIt;
        }
        else if(pco->iDComplexity == DC_RECT)
        {
            prclClip = &(pco->rclBounds);
        }
    }

    ppdev = (PDev*) pso->dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvLineTo: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(ppdev);

    ppdev->psurf = psurf;

    // Get the logic op.
    logicOp = ulRop3ToLogicop(gaMix[mix & 0xff]);

    // Need to set up Permedia2 modes and colors appropriately for the line.
    bResetHW = bInitializeStrips(ppdev, iSolidColor, logicOp, prclClip);

    // bFastIntegerLine expects co-ords in 28.4 format
    bResult = bFastIntegerLine (ppdev, x1 << 4, y1 << 4, x2 << 4, y2 << 4);

    // If we have to restore the state then... do it.
    if (bResetHW)
        vResetStrips(ppdev);

    InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    if(bResult)
        return TRUE;
    
    // we failed to draw above, fall through thus punting to engine

puntIt:
//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG   flags = vPuntBefore(NULL, pso);
#endif
//@@END_DDKSPLIT

    bResult = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, NULL, pso);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;
    
}// DrvLineTo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\lines.h ===
/******************************Module*Header**********************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __LINES__
#define __LINES__

typedef struct _PDev PDev;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)
#define MIN_INTEGER_BOUND  (-512)

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00000100L     // .... ...1 .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_MASKSTYLED           0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED | FL_MASKSTYLED)
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000C00L
#define FL_STYLE_SHIFT          10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Logical operation which requires a read (for hardware)
#define FL_READ                 0x00008000L     // 1... .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + FBITS/2 - ((flRoundDown) > 0)) >> 4)
#define FBITS                 16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (FBITS - 1))

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;              // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawing prototype:

typedef VOID (FNSTRIP)(PDev*, STRIP*, LINESTATE*);
typedef FNSTRIP * PFNSTRIP;

// Strip drawing routines
FNSTRIP vSolidHorizontalLine;
FNSTRIP vSolidVerticalLine;
FNSTRIP vSolidDiagonalHorizontalLine;
FNSTRIP vSolidDiagonalVerticalLine;
FNSTRIP vStyledHorizontalLine;
FNSTRIP vStyledVerticalLine;

// Line drawering routines
GFNLINE bFastIntegerLine;
GFNLINE bFastIntegerContinueLine;
GFNLINE bFastLine;

// External calls:

BOOL bLines(PDev*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);

#endif // __LINES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\log.c ===
/******************************Module*Header*******************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: log.c
 *
 *
 * Copyright (c) 1992-1999 Microsoft Corporation.   All rights reserved.
 **************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "log.h"

// Logging support
#define MAX_LOG_FILE_NAME_SIZE  80

#define LF_PUNTED               0x1
#define LF_DSTVM                0x2
#define LF_SRCVM                0x4
#define LF_CALLDEPTHMASK        0xf0

#define LE_NULL                 0
#define LE_BITBLT               1
#define LE_COPYBITS             2
#define LE_SURFCREATED          3
#define LE_SURFMOVEDTOSM        4
#define LE_SURFMOVEDTOVM        5
#define LE_LOGOPENED            6
#define LE_LOGCLOSED            7
#define LE_ALPHABLEND           8
#define LE_TRANSPARENTBLT       9
#define LE_TEXTOUT              10
#define LE_FILLPATH             11
#define LE_STROKEPATH           12
#define LE_LINETO               13
#define LE_SURFDELETED          14
#define LE_GRADIENTFILL         15

typedef struct LogEntry
{
    USHORT      elapsedTime;
    BYTE        flags;
    BYTE        event;
    ULONG_PTR   src;            // format or pdsurf
    ULONG_PTR   dst;            // format or pdsurf
    USHORT      rop4;
} LogEntry;

LogEntry *  gLog = NULL;    // pointer to mapped log file
ULONG_PTR   giFile = NULL;
LogEntry *  gLogPos;        // current position in log file
LogEntry *  gLogSentinel;   // end of log file
wchar_t     gLogFileName[MAX_LOG_FILE_NAME_SIZE+1];
BOOL        gPunted = FALSE;

ULONG ulLogOpen(LPWSTR pwsz, ULONG ulSize)
{

    ULONG   ulResult = 0;

    // Make sure the log the log will be big enough to store atleast the log
    // open and the log close events
    
    if(gLog == NULL && ulSize >= (sizeof(LogEntry) * 2))
    {
        if(wcslen(pwsz) <= MAX_LOG_FILE_NAME_SIZE)
        {
            wcscpy(gLogFileName, pwsz);
            
            gLog = (LogEntry *) EngMapFile(gLogFileName, ulSize, &giFile);
            if (gLog != NULL)
            {
                // NOTE: we subtract one to save room for the close event
                gLogSentinel = gLog + ((ulSize / sizeof(LogEntry)) - 1);
                memset(gLog, 0, ulSize);
                gLogPos = gLog;
                
                gLogPos->event = LE_LOGOPENED;
                {
                    LONGLONG    frequency;
                    EngQueryPerformanceFrequency(&frequency);
                    if(frequency < 0xFFFFFFFF)
                        gLogPos->dst = (ULONG) (frequency & 0xFFFFFFFF);
                }
                gLogPos++;

                ulResult = TRUE;
            }
        }
    }

    return ulResult;
}

ULONG ulLogClose(void)
{
    ULONG   ulResult = 0;

    if(gLog != NULL)
    {
        // there is always room for the closed event
        gLogPos->event = LE_LOGCLOSED;

        ulResult = (ULONG) EngUnmapFile((ULONG_PTR) giFile);
    }
    
    gLog = NULL;

    return ulResult;
}

void vLogPunt(void)
{
    if(gLog != NULL)
        gLogPos->flags |= LF_PUNTED;
}

void
vLogBitBlt(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMsk,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    POINTL*   pptlMsk,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4,
    LONGLONG  elapsedTime,
    ULONG     ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }
        
        gLogPos->rop4 = (USHORT) rop4;
        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_BITBLT;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;
    }
}

void
vLogCopyBits(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    LONGLONG  elapsedTime,
    ULONG     ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_COPYBITS;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogTransparentBlt(
    SURFOBJ *    psoDst,
    SURFOBJ *    psoSrc,
    CLIPOBJ *    pco,
    XLATEOBJ *   pxlo,
    RECTL *      prclDst,
    RECTL *      prclSrc,
    ULONG        iTransColor,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_TRANSPARENTBLT;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogAlphaBlend(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    RECTL    *prclSrc,
    BLENDOBJ *pBlendObj,
    LONGLONG  elapsedTime,
    ULONG     ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        if(psoSrc != NULL)
        {
            if(psoSrc->dhsurf != NULL)
            {
                Surf *  surf = (Surf *) psoSrc->dhsurf;

                gLogPos->src = (ULONG_PTR) surf;

                if(surf->flags & SF_VM)
                    gLogPos->flags |= LF_SRCVM;
            }
            else
            {
                gLogPos->src = (ULONG_PTR) psoSrc->iBitmapFormat;
            }
        }
        else
        {
            gLogPos->src = 0;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_ALPHABLEND;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogGradientFill(
    SURFOBJ      *psoDst,
    CLIPOBJ      *pco,
    XLATEOBJ     *pxlo,
    TRIVERTEX    *pVertex,
    ULONG        nVertex,
    PVOID        pMesh,
    ULONG        nMesh,
    RECTL        *prclExtents,
    POINTL       *pptlDitherOrg,
    ULONG        ulMode,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_GRADIENTFILL;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogTextOut(
    SURFOBJ*     psoDst,
    STROBJ*      pstro,
    FONTOBJ*     pfo,
    CLIPOBJ*     pco,
    RECTL*       prclExtra,
    RECTL*       prclOpaque,
    BRUSHOBJ*    pboFore,
    BRUSHOBJ*    pboOpaque,
    POINTL*      pptlBrush, 
    MIX          mix,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM)
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_TEXTOUT;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogLineTo(
    SURFOBJ*     psoDst,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    LONG         x1,
    LONG         y1,
    LONG         x2,
    LONG         y2,
    RECTL*       prclBounds,
    MIX          mix,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM )
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_LINETO;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogFillPath(
    SURFOBJ*     psoDst,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    MIX          mix,
    FLONG        flOptions,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM )
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_FILLPATH;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogStrokePath(
    SURFOBJ*     psoDst,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    XFORMOBJ*    pxo,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    LINEATTRS*   pla,
    MIX          mix,
    LONGLONG     elapsedTime,
    ULONG        ulCallDepth)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        if(psoDst->dhsurf != NULL)
        {
            Surf *  surf = (Surf *) psoDst->dhsurf;

            gLogPos->dst = (ULONG_PTR) surf;

            if(surf->flags & SF_VM )
                gLogPos->flags |= LF_DSTVM;
        }
        else
        {
            gLogPos->dst = (ULONG) psoDst->iBitmapFormat;
        }

        gLogPos->elapsedTime = (elapsedTime > 0xFFFF ? 0xFFFF 
                                                     : (USHORT) elapsedTime);
        gLogPos->event = LE_STROKEPATH;
        gLogPos->flags |=(ulCallDepth >= 15 ? 0xF0 : (BYTE) (ulCallDepth << 4));
        gLogPos++;

    }
}

void
vLogSurfMovedToVM(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFMOVEDTOVM;
        gLogPos++;

    }
}

void
vLogSurfMovedToSM(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFMOVEDTOSM;
        gLogPos++;

    }
}

void
vLogSurfCreated(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFCREATED;
        gLogPos++;

    }
}

void
vLogSurfDeleted(
    Surf*        psurf)
{
    if(gLog != NULL && gLogPos < gLogSentinel)
    {
        gLogPos->dst = (ULONG_PTR) psurf;
        gLogPos->event = LE_SURFDELETED;
        gLogPos++;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\log.h ===
/******************************Module*Header*******************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: log.h
 *
 *
 * Copyright (c) 1992-1999 Microsoft Corporation.   All rights reserved.
 **************************************************************************/
#ifndef __LOG__
#define __LOG__

//extern char *  gLog;           // pointer to mapped log file
//extern char *  gLogPos;        // current position in log file
//extern char *  gLogSentinel;   // end of log file

ULONG ulLogOpen(LPWSTR pwsz, ULONG ulSize);
ULONG ulLogClose(void);

void
vLogPunt(void);

void
vLogBitBlt(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMsk,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    POINTL*   pptlMsk,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4,
    LONGLONG  llElapsedTicks,
    ULONG     ulCallDepth);

void
vLogCopyBits(
    SURFOBJ*  psoDst,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDst,
    POINTL*   pptlSrc,
    LONGLONG  llElapsedTicks,
    ULONG     ulCallDepth);

void
vLogTransparentBlt(
    SURFOBJ *    psoDst,
    SURFOBJ *    psoSrc,
    CLIPOBJ *    pco,
    XLATEOBJ *   pxlo,
    RECTL *      prclDst,
    RECTL *      prclSrc,
    ULONG        iTransColor,
    LONGLONG    llElapsedTicks,
    ULONG       ulCallDepth);

void
vLogAlphaBlend(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    RECTL    *prclSrc,
    BLENDOBJ *pBlendObj,
    LONGLONG  llElapsedTicks,
    ULONG     ulCallDepth);

void
vLogGradientFill(
    SURFOBJ      *psoDst,
    CLIPOBJ      *pco,
    XLATEOBJ     *pxlo,
    TRIVERTEX    *pVertex,
    ULONG        nVertex,
    PVOID        pMesh,
    ULONG        nMesh,
    RECTL        *prclExtents,
    POINTL       *pptlDitherOrg,
    ULONG        ulMode,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);
void
vLogTextOut(
    SURFOBJ*     pso,
    STROBJ*      pstro,
    FONTOBJ*     pfo,
    CLIPOBJ*     pco,
    RECTL*       prclExtra,
    RECTL*       prclOpaque,
    BRUSHOBJ*    pboFore,
    BRUSHOBJ*    pboOpaque,
    POINTL*      pptlBrush, 
    MIX          mix,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogLineTo(
    SURFOBJ*     pso,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    LONG         x1,
    LONG         y1,
    LONG         x2,
    LONG         y2,
    RECTL*       prclBounds,
    MIX          mix,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogFillPath(
    SURFOBJ*     pso,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    MIX          mix,
    FLONG        flOptions,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogStrokePath(
    SURFOBJ*     pso,
    PATHOBJ*     ppo,
    CLIPOBJ*     pco,
    XFORMOBJ*    pxo,
    BRUSHOBJ*    pbo,
    POINTL*      pptlBrush,
    LINEATTRS*   pla,
    MIX          mix,
    LONGLONG     llElapsedTicks,
    ULONG        ulCallDepth);

void
vLogSurfMovedToVM(
    Surf*        psurf);

void
vLogSurfMovedToSM(
    Surf*        psurf);

void
vLogSurfCreated(
    Surf*        psurf);

void
vLogSurfDeleted(
    Surf*        psurf);

#endif // __LOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\p2ctxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name:  p2ctxt.c
*
* Content:      Context switching for Permedia 2. Used to create and swap 
*               contexts in and out.
*               The GDI, DDraw and D3D part each have another context.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "p2ctxt.h"
#include "gdi.h"
#define ALLOC_TAG ALLOC_TAG_XC2P
static DWORD readableRegistersP2[] = {
    __Permedia2TagStartXDom,
    __Permedia2TagdXDom,
    __Permedia2TagStartXSub,
    __Permedia2TagdXSub,
    __Permedia2TagStartY,
    __Permedia2TagdY,               
    __Permedia2TagCount,            
    __Permedia2TagRasterizerMode,   
    __Permedia2TagYLimits,
    __Permedia2TagXLimits,
    __Permedia2TagScissorMode,
    __Permedia2TagScissorMinXY,
    __Permedia2TagScissorMaxXY,
    __Permedia2TagScreenSize,
    __Permedia2TagAreaStippleMode,
    __Permedia2TagWindowOrigin,
    __Permedia2TagAreaStipplePattern0,
    __Permedia2TagAreaStipplePattern1,
    __Permedia2TagAreaStipplePattern2,
    __Permedia2TagAreaStipplePattern3,
    __Permedia2TagAreaStipplePattern4,
    __Permedia2TagAreaStipplePattern5,
    __Permedia2TagAreaStipplePattern6,
    __Permedia2TagAreaStipplePattern7,
    __Permedia2TagTextureAddressMode,
    __Permedia2TagSStart,
    __Permedia2TagdSdx,
    __Permedia2TagdSdyDom,
    __Permedia2TagTStart,
    __Permedia2TagdTdx,
    __Permedia2TagdTdyDom,
    __Permedia2TagQStart,
    __Permedia2TagdQdx,
    __Permedia2TagdQdyDom,
    // texellutindex..transfer are treated seperately
    __Permedia2TagTextureBaseAddress,
    __Permedia2TagTextureMapFormat,
    __Permedia2TagTextureDataFormat,
    __Permedia2TagTexel0,
    __Permedia2TagTextureReadMode,
    __Permedia2TagTexelLUTMode,
    __Permedia2TagTextureColorMode,
    __Permedia2TagFogMode,
    __Permedia2TagFogColor,
    __Permedia2TagFStart,
    __Permedia2TagdFdx,
    __Permedia2TagdFdyDom,
    __Permedia2TagKsStart,
    __Permedia2TagdKsdx,
    __Permedia2TagdKsdyDom,
    __Permedia2TagKdStart,
    __Permedia2TagdKddx,
    __Permedia2TagdKddyDom,
    __Permedia2TagRStart,
    __Permedia2TagdRdx,
    __Permedia2TagdRdyDom,
    __Permedia2TagGStart,
    __Permedia2TagdGdx,
    __Permedia2TagdGdyDom,
    __Permedia2TagBStart,
    __Permedia2TagdBdx,
    __Permedia2TagdBdyDom,
    __Permedia2TagAStart,
    __Permedia2TagColorDDAMode,
    __Permedia2TagConstantColor,
    __Permedia2TagAlphaBlendMode,
    __Permedia2TagDitherMode,
    __Permedia2TagFBSoftwareWriteMask,
    __Permedia2TagLogicalOpMode,
    __Permedia2TagLBReadMode,
    __Permedia2TagLBReadFormat,
    __Permedia2TagLBSourceOffset,
    __Permedia2TagLBWindowBase,
    __Permedia2TagLBWriteMode,
    __Permedia2TagLBWriteFormat,
    __Permedia2TagTextureDownloadOffset,
    __Permedia2TagWindow,
    __Permedia2TagStencilMode,
    __Permedia2TagStencilData,
    __Permedia2TagStencil,
    __Permedia2TagDepthMode,
    __Permedia2TagDepth,
    __Permedia2TagZStartU,
    __Permedia2TagZStartL,
    __Permedia2TagdZdxU,
    __Permedia2TagdZdxL,
    __Permedia2TagdZdyDomU,
    __Permedia2TagdZdyDomL,
    __Permedia2TagFBReadMode,
    __Permedia2TagFBSourceOffset,
    __Permedia2TagFBPixelOffset,
    __Permedia2TagFBWindowBase,
    __Permedia2TagFBWriteMode,
    __Permedia2TagFBHardwareWriteMask,
    __Permedia2TagFBBlockColor,
    __Permedia2TagFBReadPixel,
    __Permedia2TagFilterMode,
    __Permedia2TagStatisticMode,
    __Permedia2TagMinRegion,
    __Permedia2TagMaxRegion,
    __Permedia2TagFBBlockColorU,
    __Permedia2TagFBBlockColorL,
    __Permedia2TagFBSourceBase,
    __Permedia2TagTexelLUT0,
    __Permedia2TagTexelLUT1,
    __Permedia2TagTexelLUT2,
    __Permedia2TagTexelLUT3,
    __Permedia2TagTexelLUT4,
    __Permedia2TagTexelLUT5,
    __Permedia2TagTexelLUT6,
    __Permedia2TagTexelLUT7,
    __Permedia2TagTexelLUT8,
    __Permedia2TagTexelLUT9,
    __Permedia2TagTexelLUT10,
    __Permedia2TagTexelLUT11,
    __Permedia2TagTexelLUT12,
    __Permedia2TagTexelLUT13,
    __Permedia2TagTexelLUT14,
    __Permedia2TagTexelLUT15,

    __Permedia2TagYUVMode,
    __Permedia2TagChromaUpperBound,
    __Permedia2TagChromaLowerBound,
    __Permedia2TagAlphaMapUpperBound,
    __Permedia2TagAlphaMapLowerBound,

    // delta tag values. must be at the end of this array

    // v0/1/2 fixed are not used and for that reason not in the context
    
    __Permedia2TagV0FloatS,
    __Permedia2TagV0FloatT,
    __Permedia2TagV0FloatQ,
    __Permedia2TagV0FloatKs,
    __Permedia2TagV0FloatKd,
    __Permedia2TagV0FloatR,
    __Permedia2TagV0FloatG,
    __Permedia2TagV0FloatB,
    __Permedia2TagV0FloatA,
    __Permedia2TagV0FloatF,
    __Permedia2TagV0FloatX,
    __Permedia2TagV0FloatY,
    __Permedia2TagV0FloatZ,
    
    __Permedia2TagV1FloatS,
    __Permedia2TagV1FloatT,
    __Permedia2TagV1FloatQ,
    __Permedia2TagV1FloatKs,
    __Permedia2TagV1FloatKd,
    __Permedia2TagV1FloatR,
    __Permedia2TagV1FloatG,
    __Permedia2TagV1FloatB,
    __Permedia2TagV1FloatA,
    __Permedia2TagV1FloatF,
    __Permedia2TagV1FloatX,
    __Permedia2TagV1FloatY,
    __Permedia2TagV1FloatZ,
    
    __Permedia2TagV2FloatS,
    __Permedia2TagV2FloatT,
    __Permedia2TagV2FloatQ,
    __Permedia2TagV2FloatKs,
    __Permedia2TagV2FloatKd,
    __Permedia2TagV2FloatR,
    __Permedia2TagV2FloatG,
    __Permedia2TagV2FloatB,
    __Permedia2TagV2FloatA,
    __Permedia2TagV2FloatF,
    __Permedia2TagV2FloatX,
    __Permedia2TagV2FloatY,
    __Permedia2TagV2FloatZ,
    
    __Permedia2TagDeltaMode

};

#define N_READABLE_TAGSP2 (sizeof(readableRegistersP2) / sizeof(readableRegistersP2[0]))

//-----------------------------------------------------------------------------
//
// P2AllocateNewContext:
//
// allocate a new context. If all registers are to be saved in the context then
// pTag is passed as null. 
// ppdev--------ppdev
// pTag---------user can supply list of registers to save and restore on 
//              context switch. NULL defaults to all registers.
//              Holds pointer to user function if dwCtxtType==P2CtxtUserFunc
// lTags--------number of tags in user supplied register list
// dwCtxtType---P2CtxtReadWrite (default) 
//                  on a context switch, all Permedia 2 registers are 
//                  saved and restored.
//              P2CtxtWriteOnly
//                  registers of context will be saved once at the first
//                  context switch. After that they will always be restored
//                  to the state ate the very beginning. This method avoids
//                  readback of registers when switching away from context.
//              P2CtxtUserFunc
//                  User can supply a user function to set context to a known
//                  state, to avoid readback when switching away from context.
//
//-----------------------------------------------------------------------------

P2CtxtPtr
P2AllocateNewContext(PPDev   ppdev,
                     DWORD  *pTag,
                     LONG    lTags,
                     P2CtxtType dwCtxtType
                     )
{
    P2CtxtTablePtr pCtxtTable, pNewCtxtTable;
    P2CtxtPtr      pEntry;
    P2CtxtData    *pData;
    LONG           lEntries;
    LONG           lExtraSize;
    LONG           lSize;
    LONG           lCtxtId;
    PERMEDIA_DECL;
    PERMEDIA_DEFS(ppdev);

    // first time round allocate the context table of pointers. We will
    // grow this table as required.
    //
    if (permediaInfo->ContextTable == NULL)
    {
        DISPDBG((7, "creating context table"));
        lSize = sizeof(P2CtxtTableRec);
        pCtxtTable = (P2CtxtTableRec *)
            ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(P2CtxtTableRec), ALLOC_TAG);

        if (pCtxtTable == NULL)
        {
            DISPDBG((0, "failed to allocate Permedia2 context table. out of memory"));
            return(NULL);
        }
        pCtxtTable->lEntries = CTXT_CHUNK;
        pCtxtTable->lSize = lSize;
        permediaInfo->ContextTable = pCtxtTable;
        permediaInfo->pCurrentCtxt  = NULL;
    }
    
    // find an empty entry in the table
    // I suppose if we have hundreds of contexts this could be a bit slow but then
    // allocating the context isn't time critical, swapping in and out is.
    //

    pCtxtTable = (P2CtxtTablePtr) permediaInfo->ContextTable;
    lEntries = pCtxtTable->lEntries;
    
    for (lCtxtId = 0; lCtxtId < lEntries; ++lCtxtId)
        if(pCtxtTable->pEntry[lCtxtId] == NULL)
            break;

    // if we found no free entries try to grow the table
    if (lCtxtId == lEntries) {
        DISPDBG((1, "context table full so enlarging"));
        lSize = pCtxtTable->lSize + (CTXT_CHUNK * sizeof(P2CtxtPtr));
        pNewCtxtTable = 
            (P2CtxtTablePtr) ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(BYTE)*lSize, ALLOC_TAG);

        if (pNewCtxtTable == NULL) {
            DISPDBG((0, "failed to increase Permedia 2 context table. out of memory"));
            return(NULL);
        }

        // copy the old table to the new one
        RtlCopyMemory(pNewCtxtTable, pCtxtTable, pCtxtTable->lSize);
        pNewCtxtTable->lSize = lSize;
        pNewCtxtTable->lEntries = lEntries + CTXT_CHUNK;
        permediaInfo->ContextTable = (PVOID)pNewCtxtTable;
        
        // first of the newly allocated entries is next free one
        lCtxtId = lEntries;
        
        // free the old context table and reassign some variables
        
        ENGFREEMEM(pCtxtTable);

        pCtxtTable = pNewCtxtTable;
        lEntries = pCtxtTable->lEntries;
    }
    
    // if pTag is passed as null then we are to add all readable registers to the
    // context.
    lExtraSize = 0;
    if (dwCtxtType != P2CtxtUserFunc)
    {
        if (pTag == 0)
        {
            DISPDBG((7, "adding all readable registers to the context"));
            DISPDBG((7, "Using PERMEDIA 2 register set for other context switch"));
            pTag = readableRegistersP2;
            lTags = N_READABLE_TAGSP2;
        }
    } else
    {
        lTags = 1;
    }
    
    // now allocate space for the new entry. We are given the number of tags to save
    // when context switching. Allocate twice this much memory as we have to hold the
    // data values as well.

    DISPDBG((7, "Allocating space for context. lTags = %d", lTags));

    lSize = sizeof(P2CtxtRec) + (lTags-1) * sizeof(P2CtxtData);

    pEntry = (P2CtxtPtr) 
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(BYTE)*(lSize+lExtraSize), ALLOC_TAG);

    if (pEntry == NULL) {
        DISPDBG((0, "out of memory trying to allocate space for new context"));
        return(NULL);
    }

    DISPDBG((7, "Got pEntry 0x%x", pEntry));

    pCtxtTable->pEntry[lCtxtId] = pEntry;

    // allocate enough space for the Texel LUT: 256 entries
    pEntry->dwCtxtType=dwCtxtType;
    pEntry->bInitialized=FALSE;
    pEntry->pTexelLUTCtxt = (PULONG)
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(ULONG)*256, ALLOC_TAG);
    if (pEntry->pTexelLUTCtxt!=0)
    {
        pEntry->ulTexelLUTEntries = 256;
    } else
    {
        pEntry->ulTexelLUTEntries = 0;
    }

    pEntry->lNumOfTags = lTags;
    pEntry->P2UserFunc = NULL;
    pData = pEntry->pData;
   
    if (dwCtxtType != P2CtxtUserFunc)
    {
        // we must initialize the new context to something reasonable. We choose to
        // initialize to the current state of the chip. We can't leave it uninitialized
        // since the first thing the caller will do when he wants to draw is validate
        // the new context which will load junk into the chip. At some point we
        // should define a reasonable starting context which would mean we wouldn't
        // have to do this readback.
    
        // copy the tags and read the data back from the chip. We don't sync since we are
        // only initialising the context to something reasonable. i.e. we don't care if
        // the FIFO is still draining while we do this.

        DISPDBG((7, "Reading current chip context back"));
        while (--lTags >= 0) {
            pData->dwTag = *pTag++;
            READ_PERMEDIA_FIFO_REG(pData->dwTag, pData->dwData);
            ++pData;
        }
    
        // save the texel LUT
        if(pEntry->ulTexelLUTEntries && 
           pEntry->pTexelLUTCtxt!=NULL)
        {
            ULONG *pul;
            INT   i=0;

            lEntries = pEntry->ulTexelLUTEntries;
            pul = pEntry->pTexelLUTCtxt;

            //special mechanism: reset readback index to 0
            READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTIndex, i); 

            for(i = 0; i < lEntries; ++i, ++pul)
            {
                READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTData, *pul);
            }
        }
        
    } else
    {
        pEntry->P2UserFunc = (PCtxtUserFunc) pTag;
    }

    DISPDBG((1, "Allocated context %lx", pEntry));

    return(pEntry);
}   // P2AllocateNewContext


//-----------------------------------------------------------------------------
//
//  P2FreeContext:
//
//  free a previously allocated context.
//
//-----------------------------------------------------------------------------

VOID
P2FreeContext(  PPDev       ppdev,
                P2CtxtPtr   pEntry)
{
    PERMEDIA_DECL;
    P2CtxtTablePtr pCtxtTable;
    ULONG          lCtxtId;
    
    pCtxtTable = (P2CtxtTablePtr) permediaInfo->ContextTable;

    for (lCtxtId = 0; lCtxtId < pCtxtTable->lEntries; ++lCtxtId)
        if(pCtxtTable->pEntry[lCtxtId] == pEntry)
            break;

    ASSERTDD(lCtxtId != pCtxtTable->lEntries, "P2FreeContext: context not found");
    
    // free LUT Table
    if(pEntry->pTexelLUTCtxt)
    {
        ENGFREEMEM( pEntry->pTexelLUTCtxt);
    }
    
    ENGFREEMEM( pEntry);

    pCtxtTable->pEntry[lCtxtId] = NULL;

    // if this was the current context, mark the current context as invalid so we
    // force a reload next time.

    if (permediaInfo->pCurrentCtxt == pEntry)
    {
        permediaInfo->pCurrentCtxt = NULL;
    }

    DISPDBG((1, "Released context %lx", pEntry));
}

//-----------------------------------------------------------------------------
//
//  VOID P2SwitchContext:
//
//  load a new context into the hardware. We assume that this call is
//  protected by a test that the given context is not the current one - 
//  hence the assertion. 
//  The code would work but the driver should never try to load an already 
//  loaded context so we trap it as an error.
//
//-----------------------------------------------------------------------------

VOID
P2SwitchContext(
                    PPDev        ppdev,
                    P2CtxtPtr    pEntry)
{
    P2CtxtTablePtr  pCtxtTable;
    P2CtxtData     *pData;
    P2CtxtPtr       pOldCtxt;
    LONG            lTags;
    LONG            i;
    ULONG          *pul;
    LONG            lEntries;
    PERMEDIA_DECL;
    PERMEDIA_DEFS(ppdev);
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    EngAcquireSemaphore(ppdev->hsemLock);
    ASSERTDD(ppdev->ulLockCount, "P2SwitchContext: ulLockCount = 0\n Context could change as caller is NOT protected!");
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    pCtxtTable = (P2CtxtTablePtr)permediaInfo->ContextTable;
    ASSERTDD(pCtxtTable, "Can't perform context switch: no contexts have been created!");
    
    pOldCtxt = permediaInfo->pCurrentCtxt;
    
    DISPDBG((3, "swapping from context %d to context %d", pOldCtxt, pEntry));
    
    if(pOldCtxt == permediaInfo->pGDICtxt)
    {
        DISPDBG((6, "Switching from GDI context"));

        ASSERTDD(ppdev->bNeedSync || 
                (ppdev->pulInFifoPtr == ppdev->pulInFifoStart),
                "P2SwitchContext: bNeedSync flag is wrong");

        InputBufferSync(ppdev);

        ppdev->bGdiContext = FALSE;
        ppdev->pP2dma->bEnabled = TRUE;

    }

    // for each register in the old context, read it back
    if (pOldCtxt != NULL) {

        //
        // P2CtxtWriteOnly will only be readback once after context initialization
        //
        if ((pOldCtxt->dwCtxtType==P2CtxtReadWrite) ||
            (pOldCtxt->dwCtxtType==P2CtxtWriteOnly && !pOldCtxt->bInitialized)
           )
        {
            // sync with the chip before reading back the current state. The flag
            // is used to control context manipulation on lockup recovery.

            SYNC_WITH_PERMEDIA;

            pData = pOldCtxt->pData;
            lTags = pOldCtxt->lNumOfTags;
            while (--lTags >= 0) {
                READ_PERMEDIA_FIFO_REG(pData->dwTag, pData->dwData);
                ++pData;
            }
        
            // save the texel LUT
            if(pOldCtxt->ulTexelLUTEntries &&
               pOldCtxt->pTexelLUTCtxt!=NULL)
            {
                lEntries = pOldCtxt->ulTexelLUTEntries;
                pul = pOldCtxt->pTexelLUTCtxt;

                //special mechanism: reset readback index to 0
                READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTIndex, i); 
            
                for(i = 0; i < lEntries; ++i, ++pul)
                {
                    READ_PERMEDIA_FIFO_REG(__Permedia2TagTexelLUTData, *pul);
                }
            }

            pOldCtxt->bInitialized=TRUE;
        }
    }
    
    // load the new context. We allow -1 to be passed so that we can force a
    // save of the current context and force the current context to be
    // undefined.
    //
    if (pEntry != NULL)
    {

        if (pEntry->dwCtxtType==P2CtxtUserFunc)
        {
            ASSERTDD(pEntry->P2UserFunc!=NULL,"supplied user function not initialized");
            (*pEntry->P2UserFunc)(ppdev);
        } else
        if (pEntry->dwCtxtType==P2CtxtWriteOnly ||
            pEntry->dwCtxtType==P2CtxtReadWrite)
        {
            lTags = pEntry->lNumOfTags;
            pData = pEntry->pData;
        
            while (lTags > 0) {
                lEntries = MAX_P2_FIFO_ENTRIES;
                lTags -= lEntries;
                if (lTags < 0)
                    lEntries += lTags;
                RESERVEDMAPTR(lEntries);
                while (--lEntries >= 0) {
                    LD_INPUT_FIFO(pData->dwTag, pData->dwData);
                    DISPDBG((20, "loading tag 0x%x, data 0x%x", pData->dwTag, pData->dwData));
                    ++pData;
                }
                COMMITDMAPTR();
            }
        
            // restore the texel LUT
            if(pEntry->ulTexelLUTEntries &&
               pEntry->pTexelLUTCtxt!=NULL )
            {
                lEntries = pEntry->ulTexelLUTEntries;
                pul = pEntry->pTexelLUTCtxt;
            
                RESERVEDMAPTR(lEntries+1);
                LD_INPUT_FIFO(__Permedia2TagTexelLUTIndex, 0);
            
                for(i = 0; i < lEntries; ++i, ++pul)
                {
                    LD_INPUT_FIFO(__Permedia2TagTexelLUTData, *pul);
                }
                COMMITDMAPTR();   
                FLUSHDMA();
            }

        } else
        {
            ASSERTDD( FALSE, "undefined state for entry in context table");
        }
    }

    if(pEntry == permediaInfo->pGDICtxt)
    {
        DISPDBG((6, "Switching to GDI context"));

        // 
        //  we have to do a full sync here, because GDI and DDraw
        //  share the same DMA buffer. To make sure nothing will be 
        //  overridden, we do a complete sync
        //
        SYNC_WITH_PERMEDIA;

        //
        // Turn off permedia interrupt handler
        //

        WRITE_CTRL_REG( PREG_INTENABLE, 0);

        ppdev->bGdiContext = TRUE;
        ppdev->pP2dma->bEnabled = FALSE;
    
        // invalidate the mono brush cache entry
        // stipple unit was restored to default values

        ppdev->abeMono.prbVerify = NULL;

    }
    
    DISPDBG((6, "context %lx now current", pEntry));
    permediaInfo->pCurrentCtxt = pEntry;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\math64.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: math64.h
*
* Additional support for 64 bit math.
*
* Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#ifndef __MATH64__
#define __MATH64__

//------------------------------------------------------------------------------
//
// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
// 
//  Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//       two 32-bit LONGs to produce a 64-bit LONGLONG result.
// 
//  UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//       a 32-bit ULONG to produce a 32-bit ULONG result.
// 
//  UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//       a 32-bit ULONG to produce a 32-bit ULONG result.
// 
//------------------------------------------------------------------------------

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))


//------------------------------------------------------------------------------
// Type conversion functions
//------------------------------------------------------------------------------
static __inline void myFtoi(int *result, float f)
{
#if defined(_X86_)
    __asm {
        fld f
        mov   eax,result
        fistp dword ptr [eax]
    }
#else
    *result = (int)f;
#endif
}

static __inline void myFtoui(unsigned long *result, float f)
{
    *result = (unsigned long)f;
}


#endif  // __MATH64__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\mini.h ===
/******************************Module*Header**********************************\
*
*                           *****************
*                           *  SAMPLE CODE  *
*                           *****************
*
* Module Name: mini.h
*
* Content:     structures and constants for communication with minidriver
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef _MINI_H_
#define _MINI_H_

//-----------------------------------------------------------------------------
//
//   structures used in IOCTL calls to miniport
//
//-----------------------------------------------------------------------------

typedef struct tagLINE_DMA_BUFFER {           //
    LARGE_INTEGER       physAddr;           // physical address of DMA buffer
    PVOID               virtAddr;           // mapped virtual address
    ULONG               size;               // size in bytes
    BOOLEAN             cacheEnabled;       // Whether buffer is cached 
} LINE_DMA_BUFFER, *PLINE_DMA_BUFFER;

//-----------------------------------------------------------------------------
//
//   shared structures used display driver and miniport
//
//-----------------------------------------------------------------------------

#define P2_ICB_MAGICNUMBER 0xbadabe01

typedef struct tagINTERRUPT_CONTROL_BLOCK {

    ULONG           ulMagicNo;

    volatile ULONG  ulControl;
    volatile ULONG  ulIRQCounter;

    LARGE_INTEGER   liDMAPhysAddr;        // physical start address of DMA buffer
    ULONG          *pDMABufferStart;      // virtual buffer start  
    ULONG          *pDMABufferEnd;        // virtual buffer end  
    volatile ULONG *pDMAActualBufferEnd;  // virtual actual buffer end
    volatile ULONG *pDMAWriteEnd;         // end for next write operation
    volatile ULONG *pDMAPrevStart;        // previous start address of a DMA
    volatile ULONG *pDMANextStart;        // next start address of a DMA
    volatile ULONG *pDMAWritePos;         // current write pointer

    // these flags lock the miniport interrupts and the display driver access
    // to these data structures. Use InterlockedExchange to lock to make
    // sure it works on multiprocessing environments
    volatile ULONG ulICBLock;               // this lock is set by the display driver

    volatile ULONG ulVSIRQCounter;          // VS IRQ Counter (if enabled)

    volatile ULONG ulLastErrorFlags;        // miniport saves value of last Error Interrupt
    volatile ULONG ulErrorCounter;          // counter for number of errors

    // the following variables are only used in the display driver



}INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;

//-----------------------------------------------------------------------------
//
// interrupt status bits set by minidriver IRQ service routine
//
//-----------------------------------------------------------------------------

enum {
    DMA_IRQ_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_IRQ_AVAILABLE  = 0x02, // can use VBLANK interrupts
};

//-----------------------------------------------------------------------------
//
//   IOCTL codes for minidriver calls
//
//-----------------------------------------------------------------------------

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_STALL_EXECUTION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_LUT_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDB, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_LUT_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDC, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_SAME_VIDEO_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDD, METHOD_BUFFERED, FILE_ANY_ACCESS)

//-----------------------------------------------------------------------------
//
//   functions provided by minidriver
//
//-----------------------------------------------------------------------------

BOOL 
AllocateDMABuffer( HANDLE hDriver, 
                   PLONG  plSize, 
                   PULONG *ppVirtAddr, 
                   LARGE_INTEGER *pPhysAddr);

BOOL 
FreeDMABuffer( HANDLE hDriver, PVOID pVirtAddr);
VOID
StallExecution( HANDLE hDriver, ULONG ulMicroSeconds);
#if defined(_X86_)
PVOID
GetPInterlockedExchange( HANDLE hDriver);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\p2ctxt.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name: p2ctxt.h
*
* Content:    
* Context switching for P2. Used to create and swap contexts in and out.
* The GDI, DDraw and D3D part each have another context.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __p2ctxt__
#define __p2ctxt__

// each time round allocate this many entries
#define CTXT_CHUNK  8

typedef VOID(*PCtxtUserFunc)(PPDev);

// each context consists of a set of tags and the corresponding data. so after
// ntags we have 2*ntags*sizeof(DWORD) bytes of memory.
typedef struct tagP2CtxtData {
    DWORD   dwTag;
    DWORD   dwData;
} P2CtxtData;

typedef struct tagP2CtxtRec {
    BOOL        bInitialized;
    P2CtxtType  dwCtxtType;
    LONG        lNumOfTags;
    ULONG       ulTexelLUTEntries;      // number of registers to save for the Texel LUT context
    ULONG       *pTexelLUTCtxt;         // Texel LUT context array
    PCtxtUserFunc P2UserFunc;
    P2CtxtData   pData[1];
    // more follows in memory
} P2CtxtRec;

typedef struct tagP2CtxtTableRec {
    ULONG      lSize;       // in bytes of the table
    ULONG      lEntries;
    P2CtxtPtr  pEntry[CTXT_CHUNK];
    // more to be allocated in memory if needed
} P2CtxtTableRec, *P2CtxtTablePtr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\mini.c ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: mini.c
*
*  Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

//-----------------------------------------------------------------------------
//
//  AllocateDMABuffer
//
//  Allocate physical continous memory for DMA operation. This function returns
//  a pointer to a previously allocated DMA buffer if there is still an unfreed
//  allocation left. That way the reallocation of continous memory can be 
//  avoided when a new ppdev is created on lets say a mode switch, since 
//  allocation of continous memory cannot be guaranteed. The memory is only
//  physically freed after all allocations have called a FreeDMABuffer.
//
//  Calls to AllocateDMABuffer and FreeDMABuffer should be paired, otherwise
//  the usage count logic in the miniport driver gets confused!
//
//  The VideoPort currently restricts the size of a DMA buffer to 256kb.
//
//  hDriver-------videoport driver handle
//  plSize--------pointer to LONG size of requested DMA buffer. Returns size
//                of allocated DMA buffer 
//                (return value can be smaller than requested size)
//  ppVirtAddr----returns virtual address of requested DMA buffer.
//  pPhysAddr-----returns physical address of DMA buffer as seen from graphics
//                device.   
//
//  return        TRUE, allocation successful
//                FALSE, allocation failed
//
//-----------------------------------------------------------------------------

BOOL 
AllocateDMABuffer( HANDLE hDriver, 
                   PLONG  plSize, 
                   PULONG *ppVirtAddr, 
                   LARGE_INTEGER *pPhysAddr)
{

    LINE_DMA_BUFFER ldb;
    ldb.size = *plSize;          
    ldb.virtAddr = 0;

    ldb.cacheEnabled = TRUE;            

    *ppVirtAddr=0;      
    pPhysAddr->HighPart=
    pPhysAddr->LowPart=0;

    ULONG ulLength = sizeof(LINE_DMA_BUFFER);

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER,
                            (PVOID)&ldb,
                            ulLength,
                            (PVOID)&ldb,
                            ulLength,
                            &ulLength))
    {
        return(FALSE);
    }

    *ppVirtAddr=(PULONG)ldb.virtAddr;

    if (ldb.virtAddr!=NULL)
    {
        *pPhysAddr=ldb.physAddr;
        *plSize=ldb.size;          

        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//
//  FreeDMABuffer
//
//  free continous buffer previously allocated by AllocateDMABuffer.
//
//-----------------------------------------------------------------------------

BOOL 
FreeDMABuffer( HANDLE hDriver, 
               PVOID pVirtAddr)
{
    LINE_DMA_BUFFER ldb;
    ldb.size = 0;
    ldb.virtAddr = pVirtAddr;

    ULONG ulLength = sizeof(LINE_DMA_BUFFER);

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER,
                            (PVOID)&ldb,
                            ulLength,
                            NULL,
                            0,
                            &ulLength))
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
//  StallExecution
//
//  calls VideoPortStallExecution in the miniport for defined delay when
//  polling Permedia registers. VideoPortStallexecution does not yield
//  to another process and should only be used in rare cases.
//
//  hDriver--------handle to videoport
//  ulMicroSeconds-number of microseconds to stall CPU execution
//
//-----------------------------------------------------------------------------

VOID
StallExecution( HANDLE hDriver, ULONG ulMicroSeconds)
{
    ULONG Length = 0;
    EngDeviceIoControl(hDriver,
                         IOCTL_VIDEO_STALL_EXECUTION,
                         &ulMicroSeconds,
                         sizeof(ULONG),
                         NULL,
                         0,
                         &Length);
}


//-----------------------------------------------------------------------------
//
//  GetPInterlockedExchange
//
//  We need to call the same InterlockedExchange function from the display 
//  driver and the miniport to make sure they work properly. The miniport
//  will give us a pointer to the function which we will call directly...
//  On Alpha and Risc machines, InterlockedExchange compiles as inline and
//  we don't need to call in the kernel.
//
//  note: the InterlockedExchange function exported from ntoskrnl has calling
//  convention __fastcall.
//
//-----------------------------------------------------------------------------

#if defined(_X86_)
PVOID
GetPInterlockedExchange( HANDLE hDriver)
{
    ULONG Length = 0;
    PVOID pWorkPtr=NULL;

    if (EngDeviceIoControl( hDriver,
                            IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE,
                            NULL,
                            0,
                            &pWorkPtr,
                            sizeof(pWorkPtr),
                            &Length))
    {
        return NULL;
    }

    return pWorkPtr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\p2def.h ===
/******************************Module*Header**********************************\
*
*
* Module Name: p2def.h
*
* Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef _P2DEF_H
#define _P2DEF_H

// Texture operations
#define _P2_TEXTURE_MODULATE         0
#define _P2_TEXTURE_DECAL            1
#define _P2_TEXTURE_SPECULAR         4
#define _P2_TEXTURE_COPY             3

#define _P2_TEXTURE_CLAMP            0
#define _P2_TEXTURE_MIRROR           2
#define _P2_TEXTURE_REPEAT           1

/*-----------------------------------------------------*/
/* Permedia Register Fields */
/* --------------------- */

/* Common */
#define __PERMEDIA_ENABLE                         1
#define __PERMEDIA_DISABLE                        0

// From FBReadMode
#define __PERMEDIA_PATCH          0
#define __PERMEDIA_SUBPATCH       1
#define __PERMEDIA_SUBPATCHPACK   2

#define __PERMEDIA_8BITPIXEL      0
#define __PERMEDIA_16BITPIXEL     1
#define __PERMEDIA_32BITPIXEL     2
#define __PERMEDIA_4BITPIXEL      3
#define __PERMEDIA_24BITPIXEL     4

/* Host In */
#define __PERMEDIA_TAG_MODE_HOLD      0
#define __PERMEDIA_TAG_MODE_INCREMENT 1
#define __PERMEDIA_TAG_MODE_INDEXED   2
#define __PERMEDIA_TAG_MODE_RESERVED  3

/* Host out (Filter) options. */

#define __PERMEDIA_FILTER_TAG           0x1
#define __PERMEDIA_FILTER_DATA          0x2
#define __PERMEDIA_FILTER_TAG_AND_DATA  0x3

#define __PERMEDIA_STATS_COMPARE_INSIDE_REGION    0
#define __PERMEDIA_STATS_COMPARE_OUTSIDE_REGION   1
#define __PERMEDIA_STATS_EXCLUDE_PASSIVE_STEPS    0
#define __PERMEDIA_STATS_INCLUDE_PASSIVE_STEPS    1
#define __PERMEDIA_STATS_EXCLUDE_ACTIVE_STEPS     0
#define __PERMEDIA_STATS_INCLUDE_ACTIVE_STEPS     1
#define __PERMEDIA_STATS_TYPE_PICKING             0
#define __PERMEDIA_STATS_TYPE_EXTENT              1

/* Rasterization */

#define __PERMEDIA_LINE_PRIMITIVE                  0
#define __PERMEDIA_TRAPEZOID_PRIMITIVE             1
#define __PERMEDIA_POINT_PRIMITIVE                 2
#define __PERMEDIA_RECTANGLE_PRIMITIVE             3

#define __PERMEDIA_FLAT_SHADE_MODE                 0
#define __PERMEDIA_GOURAUD_SHADE_MODE              1

#define __PERMEDIA_FRACTION_ADJUST_NONE         0
#define __PERMEDIA_FRACTION_ADJUST_TRUNC        1
#define __PERMEDIA_FRACTION_ADJUST_HALF         2
#define __PERMEDIA_FRACTION_ADJUST_ALMOST_HALF  3

#define __PERMEDIA_START_BIAS_ZERO              0
#define __PERMEDIA_START_BIAS_HALF              1
#define __PERMEDIA_START_BIAS_ALMOST_HALF       2

/* Scissor */

/* Stipple */

#define __PERMEDIA_RESET_STIPPLE_COUNTERS         0
#define __PERMEDIA_LOAD_STIPPLE_COUNTERS          1
/* specifies pattern size as number of address bits less 1 */
#define __PERMEDIA_AREA_STIPPLE_2_PIXEL_PATTERN   0
#define __PERMEDIA_AREA_STIPPLE_4_PIXEL_PATTERN   1
#define __PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN   2
#define __PERMEDIA_AREA_STIPPLE_16_PIXEL_PATTERN  3
#define __PERMEDIA_AREA_STIPPLE_32_PIXEL_PATTERN  4

/* Chroma Test Mode */
#define __PERMEDIA_CHROMA_FBSOURCE      0
#define __PERMEDIA_CHROMA_FBDATA        1
#define __PERMEDIA_CHROMA_INPUT_COLOR   2
#define __PERMEDIA_CHROMA_OUTPUT_COLOR  3
#define __PERMEDIA_CHROMA_INCLUDE       0
#define __PERMEDIA_CHROMA_EXCLUDE       1

/* Texture Filter Mode */
#define __PERMEDIA_TEXTUREFILTER_ALPHAMAPSENSE_INCLUDE    0
#define __PERMEDIA_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE    1

/* Local buffer read */

#define __PERMEDIA_PPCODE0  0
#define __PERMEDIA_PPCODE1  1
#define __PERMEDIA_PPCODE2  2
#define __PERMEDIA_PPCODE3  3
#define __PERMEDIA_PPCODE4  4
#define __PERMEDIA_PPCODE5  5
#define __PERMEDIA_PPCODE6  6
#define __PERMEDIA_PPCODE7  7

#define __PERMEDIA_LBDEFAULT      0
#define __PERMEDIA_LBSTENCIL      1
#define __PERMEDIA_LBDEPTH        2

#define __PERMEDIA_FBDEFAULT       0
#define __PERMEDIA_FBCOLOR         1

#define __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN       0
#define __PERMEDIA_BOTTOM_LEFT_WINDOW_ORIGIN    1

#define __PERMEDIA_DEPTH_WIDTH_16      0
#define __PERMEDIA_DEPTH_WIDTH_24      1
#define __PERMEDIA_DEPTH_WIDTH_32      2

#define __PERMEDIA_STENCIL_WIDTH_0     0
#define __PERMEDIA_STENCIL_WIDTH_4     1
#define __PERMEDIA_STENCIL_WIDTH_8     2

#define __PERMEDIA_STENCIL_POSITION_16    0
#define __PERMEDIA_STENCIL_POSITION_20    1 
#define __PERMEDIA_FRAMECOUNT_POSITION_24    2
#define __PERMEDIA_FRAMECOUNT_POSITION_28    3
#define __PERMEDIA_FRAMECOUNT_POSITION_32    4
#define __PERMEDIA_FRAMECOUNT_POSITION_36    5
#define __PERMEDIA_FRAMECOUNT_POSITION_40    6

#define __PERMEDIA_GID_WIDTH_0        0
#define __PERMEDIA_GID_WIDTH_4        1
#define __PERMEDIA_GID_POSITION_16    0
#define __PERMEDIA_GID_POSITION_20    1
#define __PERMEDIA_GID_POSITION_24    2
#define __PERMEDIA_GID_POSITION_28    3
#define __PERMEDIA_GID_POSITION_32    4
#define __PERMEDIA_GID_POSITION_36    5
#define __PERMEDIA_GID_POSITION_40    6
#define __PERMEDIA_GID_POSITION_44    7
#define __PERMEDIA_GID_POSITION_48    8

/* FBReadMode */
#define __PERMEDIA_FBREAD_FBDEFAULT             0
#define __PERMEDIA_FBREAD_FBCOLOR               1
#define __PERMEDIA_FBREAD_ORIGINTOPLEFT         0
#define __PERMEDIA_FBREAD_ORIGINBOTTOMLEFT      1
#define __PERMEDIA_FBREAD_FBSOURCE_CONSTANT     0
#define __PERMEDIA_FBREAD_FBSOURCE_INDEX        1
#define __PERMEDIA_FBREAD_FBSOURCE_COORDINATE   2


/* Pixel ownership */
#define __PERMEDIA_GID_COMPARE_ALWAYS       0
#define __PERMEDIA_GID_COMPARE_NEVER        1
#define __PERMEDIA_GID_COMPARE_EQUAL        2
#define __PERMEDIA_GID_COMPARE_NOT_EQUAL    3
#define __PERMEDIA_GID_LBUPDATE_LBDATA      0
#define __PERMEDIA_GID_LBUPDATE_REGISTER    1

/* Stencil Test */

#define __PERMEDIA_STENCIL_BUFFER_WIDTH_4            0
#define __PERMEDIA_STENCIL_BUFFER_WIDTH_8            1
#define __PERMEDIA_STENCIL_BUFFER_WIDTH_1            2

#define __PERMEDIA_STENCIL_SOURCE_TEST_LOGIC        0
#define __PERMEDIA_STENCIL_SOURCE_STENCIL_MSG       1
#define __PERMEDIA_STENCIL_SOURCE_SOURCE_STENCIL    2
#define __PERMEDIA_STENCIL_SOURCE_LBSOURCEDATA_MSG  3

#define __PERMEDIA_STENCIL_COMPARE_MODE_NEVER               0
#define __PERMEDIA_STENCIL_COMPARE_MODE_LESS                1
#define __PERMEDIA_STENCIL_COMPARE_MODE_EQUAL               2
#define __PERMEDIA_STENCIL_COMPARE_MODE_LESS_OR_EQUAL       3
#define __PERMEDIA_STENCIL_COMPARE_MODE_GREATER             4
#define __PERMEDIA_STENCIL_COMPARE_MODE_NOT_EQUAL           5
#define __PERMEDIA_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL    6
#define __PERMEDIA_STENCIL_COMPARE_MODE_ALWAYS              7

#define __PERMEDIA_STENCIL_METHOD_KEEP          0
#define __PERMEDIA_STENCIL_METHOD_ZERO          1
#define __PERMEDIA_STENCIL_METHOD_REPLACE       2
#define __PERMEDIA_STENCIL_METHOD_INCR          3
#define __PERMEDIA_STENCIL_METHOD_DECR          4
#define __PERMEDIA_STENCIL_METHOD_INVERT        5


/* Depth Test */

#define __PERMEDIA_DEPTH_SOURCE_DDA                 0
#define __PERMEDIA_DEPTH_SOURCE_SOURCE_DEPTH        1
#define __PERMEDIA_DEPTH_SOURCE_DEPTH_MSG           2
#define __PERMEDIA_DEPTH_SOURCE_LBSOURCEDATA_MSG    3

#define __PERMEDIA_DEPTH_COMPARE_MODE_NEVER             0
#define __PERMEDIA_DEPTH_COMPARE_MODE_LESS              1
#define __PERMEDIA_DEPTH_COMPARE_MODE_EQUAL             2
#define __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL     3
#define __PERMEDIA_DEPTH_COMPARE_MODE_GREATER           4
#define __PERMEDIA_DEPTH_COMPARE_MODE_NOT_EQUAL         5
#define __PERMEDIA_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL  6
#define __PERMEDIA_DEPTH_COMPARE_MODE_ALWAYS            7

/* Local buffer write */

#define __PERMEDIA_WRITEMODE_NORMAL         0
#define __PERMEDIA_WRITEMODE_DOWRITE        1
#define __PERMEDIA_WRITEMODE_CANCELWRITE    2

#define __PERMEDIA_UPLOADDATA_NONE          0
#define __PERMEDIA_UPLOADDATA_LBDEPTH       1
#define __PERMEDIA_UPLOADDATA_LBSTENCIL     2

/* Texture / Fog  */

#define __PERMEDIA_TEXTURE_FILTER_NEAREST     0
#define __PERMEDIA_TEXTURE_FILTER_LINEAR2     1
#define __PERMEDIA_TEXTURE_FILTER_TRILINEAR4  2
#define __PERMEDIA_TEXTURE_FILTER_LINEAR4     3
#define __PERMEDIA_TEXTURE_FILTER_TRILINEAR8  4

/* Texture AddressMode */
#define __PERMEDIA_TEXADDRESS_WRAP_CLAMP        0
#define __PERMEDIA_TEXADDRESS_WRAP_REPEAT       1
#define __PERMEDIA_TEXADDRESS_WRAP_MIRROR       2
#define __PERMEDIA_TEXADDRESS_OPERATION_2D      0
#define __PERMEDIA_TEXADDRESS_OPERATION_3D      1
#define __PERMEDIA_TEXADDRESS_TEXMAP_1D         0
#define __PERMEDIA_TEXADDRESS_TEXMAP_2D         1

/* Texture ReadMode */
#define __PERMEDIA_TEXTUREREAD_FILTER_NEAREST           0
#define __PERMEDIA_TEXTUREREAD_FILTER_LINEAR            1
#define __PERMEDIA_TEXTUREREAD_FILTER_NEARMIPNEAREST    2
#define __PERMEDIA_TEXTUREREAD_FILTER_NEARMIPLINEAR     3
#define __PERMEDIA_TEXTUREREAD_FILTER_LINEARMIPNEAREST  4
#define __PERMEDIA_TEXTUREREAD_FILTER_LINEARMIPLINEAR   5
#define __PERMEDIA_TEXTUREREAD_WRAP_CLAMP               0
#define __PERMEDIA_TEXTUREREAD_WRAP_REPEAT              1
#define __PERMEDIA_TEXTUREREAD_WRAP_MIRROR              2
#define __PERMEDIA_TEXTUREREAD_TEXMAP_1D                0
#define __PERMEDIA_TEXTUREREAD_TEXMAP_2D                1
#define __PERMEDIA_TEXTUREREAD_FBSOURCE_NONE            0
#define __PERMEDIA_TEXTUREREAD_FBSOURCE_INDEX           1
#define __PERMEDIA_TEXTUREREAD_FBSOURCE_COORDINATE      2

/* Texture Format */
#define __PERMEDIA_TEXTUREFORMAT_LITTLE_ENDIAN              0
#define __PERMEDIA_TEXTUREFORMAT_BIG_ENDIAN                 1
#define __PERMEDIA_TEXTUREFORMAT_COMPONENTS_RGB             2
#define __PERMEDIA_TEXTUREFORMAT_COMPONENTS_RGBA            3
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_TEXEL               0
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_COLOR               1
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_BITMASK             2
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_ONECOMP_LUMA        0
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_ONECOMP_ALPHA       1
#define __PERMEDIA_TEXTUREFORMAT_OUTPUT_ONECOMP_INTESITY    2


/* Texture Color Mode */
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_ALPHA       0
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_LUMA        1
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_LUMA_ALPHA  2
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_INTENSITY   3
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_RGB         4
#define __PERMEDIA_TEXCOLORMODE_BASEFORMAT_RGBA        5

#define __PERMEDIA_TEXCOLORMODE_APPLICATION_MODULATE 0
#define __PERMEDIA_TEXCOLORMODE_APPLICATION_DECAL    1
#define __PERMEDIA_TEXCOLORMODE_APPLICATION_BLEND    2
#define __PERMEDIA_TEXCOLORMODE_APPLICATION_COPY     3

/* Frame buffer read */
#define __PERMEDIA_FBDATA    0
#define __PERMEDIA_FBCOLOR  1


// Config - combined mode register for P2
#define __PERMEDIA_CONFIG_FBREAD_SRC     0x00000001
#define __PERMEDIA_CONFIG_FBREAD_DST     0x00000002
#define __PERMEDIA_CONFIG_PACKED_DATA    0x00000004
#define __PERMEDIA_CONFIG_FBWRITE        0x00000008
#define __PERMEDIA_CONFIG_COLOR_DDA  0x00000010
#define __PERMEDIA_CONFIG_LOGICOP(x)    (0x00000020 | ((x & 0xF) << 6))

/* Antialias */

#define __PERMEDIA_COLOR_MODE_RGBA                  0
#define __PERMEDIA_COLOR_MODE_CI                    1


/* Alpha Blend */

#define __PERMEDIA_BLEND_FUNC_ZERO                      0
#define __PERMEDIA_BLEND_FUNC_ONE                       1
#define __PERMEDIA_BLEND_FUNC_SRC_ALPHA                 4
#define __PERMEDIA_BLEND_FUNC_ONE_MINUS_SRC_ALPHA       5

#define __PERMEDIA_BLENDOP_ONE_AND_ONE                  0x11
#define __PERMEDIA_BLENDOP_SRCALPHA_AND_INVSRCALPHA     0x54
#define __PERMEDIA_BLENDOP_ONE_AND_INVSRCALPHA          0x51
#define __PERMEDIA_BLENDOP_ONE_AND_ZERO                 0x01

/* Dither */

#define __PERMEDIA_COLOR_FORMAT_RGBA_8888            0
#define __PERMEDIA_COLOR_FORMAT_RGBA_5555            1
#define __PERMEDIA_COLOR_FORMAT_RGBA_4444            2
#define __PERMEDIA_COLOR_FORMAT_RGBA_4444_FRONT      3
#define __PERMEDIA_COLOR_FORMAT_RGBA_4444_BACK       4
#define __PERMEDIA_COLOR_FORMAT_RGB_332_FRONT        5
#define __PERMEDIA_COLOR_FORMAT_RGB_332_BACK         6
#define __PERMEDIA_COLOR_FORMAT_RGB_121_FRONT        7
#define __PERMEDIA_COLOR_FORMAT_RGB_121_BACK         8

#define __PERMEDIA_COLOR_FORMAT_CI_8                14
#define __PERMEDIA_COLOR_FORMAT_CI_4                15

#define __PERMEDIA_COLOR_ORDER_BGR                   0
#define __PERMEDIA_COLOR_ORDER_RGB                   1

/* Logical Ops/Write mask */

#define K_LOGICOP_CLEAR                   0
#define K_LOGICOP_AND                     1
#define K_LOGICOP_AND_REVERSE             2
#define K_LOGICOP_COPY                    3
#define K_LOGICOP_AND_INVERTED            4
#define K_LOGICOP_NOOP                    5
#define K_LOGICOP_XOR                     6
#define K_LOGICOP_OR                      7
#define K_LOGICOP_NOR                     8
#define K_LOGICOP_EQUIV                   9
#define K_LOGICOP_INVERT                 10
#define K_LOGICOP_OR_REVERSE             11
#define K_LOGICOP_COPY_INVERT            12
#define K_LOGICOP_OR_INVERT              13
#define K_LOGICOP_NAND                   14
#define K_LOGICOP_SET                    15

#define __PERMEDIA_ALL_WRITEMASKS_SET             0xFFFFFFFF

/* FB Write */

#define __PERMEDIA_BLOCK_WIDTH_8    0
#define __PERMEDIA_BLOCK_WIDTH_16   1
#define __PERMEDIA_BLOCK_WIDTH_32   2

/*-----------------------------------------------------*/
#define __PERMEDIA_3D_CONTEXT  1
#define __PERMEDIA_2D_CONTEXT  2

#define __PERMEDIA_ALPHA_FUNC_SCALE         255.0

#define __PERMEDIA_MIN_SUB_SCAN_LINES       4
#define __PERMEDIA_MAX_SUB_SCAN_LINES       8
/* converts diameter into number of subscanlines in radius */
#define __PERMEDIA_FASTEST_SMOOTH_POINT_RADIUS (__PERMEDIA_MIN_SUB_SCAN_LINES >> 1)
#define __PERMEDIA_NICEST_SMOOTH_POINT_RADIUS  (__PERMEDIA_MAX_SUB_SCAN_LINES >> 1)

#define __PERMEDIA_POINT_TABLE_LONGS  4

#define __PERMEDIA_MAX_PPC_ENTRIES  3

#define __PERMEDIA_PPCODE0_SHIFT  0
#define __PERMEDIA_PPCODE1_SHIFT  5
#define __PERMEDIA_PPCODE2_SHIFT  6
#define __PERMEDIA_PPCODE3_SHIFT  7
#define __PERMEDIA_PPCODE4_SHIFT  8
#define __PERMEDIA_PPCODE5_SHIFT  9
#define __PERMEDIA_PPCODE6_SHIFT  10
#define __PERMEDIA_PPCODE7_SHIFT  11



// Tags
// group 0
#define __Permedia2TagStartXDom                  0
#define __Permedia2TagdXDom                      0x1
#define __Permedia2TagStartXSub                  0x2
#define __Permedia2TagdXSub                      0x3
#define __Permedia2TagStartY                     0x4
#define __Permedia2TagdY                         0x5
#define __Permedia2TagCount                      0x6
#define __Permedia2TagRender                     0x7
#define __Permedia2TagContinueNewLine            0x8
#define __Permedia2TagContinueNewDom             0x9
#define __Permedia2TagContinueNewSub             0xa
#define __Permedia2TagContinue                   0xb
#define __Permedia2TagBitMaskPattern             0xd

// group 1
#define __Permedia2TagRasterizerMode             0x14
#define __Permedia2TagYLimits                    0x15
#define __Permedia2TagWaitForCompletion          0x17
#define __Permedia2TagXLimits                    0x19
#define __Permedia2TagRectangleOrigin            0x1a
#define __Permedia2TagRectangleSize              0x1b

//group 2
#define __Permedia2TagPackedDataLimits           0x2a

//group 3
#define __Permedia2TagScissorMode                0x30
#define __Permedia2TagScissorMinXY               0x31
#define __Permedia2TagScissorMaxXY               0x32
#define __Permedia2TagScreenSize                 0x33
#define __Permedia2TagAreaStippleMode            0x34
#define __Permedia2TagWindowOrigin               0x39

// group 4
#define __Permedia2TagAreaStipplePattern0        0x40
#define __Permedia2TagAreaStipplePattern1        0x41
#define __Permedia2TagAreaStipplePattern2        0x42
#define __Permedia2TagAreaStipplePattern3        0x43
#define __Permedia2TagAreaStipplePattern4        0x44
#define __Permedia2TagAreaStipplePattern5        0x45
#define __Permedia2TagAreaStipplePattern6        0x46
#define __Permedia2TagAreaStipplePattern7        0x47

// group 7
#define __Permedia2TagTextureAddressMode         0x70
#define __Permedia2TagSStart                     0x71
#define __Permedia2TagdSdx                       0x72
#define __Permedia2TagdSdyDom                    0x73
#define __Permedia2TagTStart                     0x74
#define __Permedia2TagdTdx                       0x75
#define __Permedia2TagdTdyDom                    0x76
#define __Permedia2TagQStart                     0x77
#define __Permedia2TagdQdx                       0x78
#define __Permedia2TagdQdyDom                    0x79

// group 9
#define __Permedia2TagTexelLUTIndex              0x98
#define __Permedia2TagTexelLUTData               0x99
#define __Permedia2TagTexelLUTAddress            0x9a
#define __Permedia2TagTexelLUTTransfer           0x9b

// group b
#define __Permedia2TagTextureBaseAddress         0xb0
#define __Permedia2TagTextureMapFormat           0xb1
#define __Permedia2TagTextureDataFormat          0xb2

// group c
#define __Permedia2TagTexel0                     0xc0
#define __Permedia2TagTextureReadMode            0xce
#define __Permedia2TagTexelLUTMode               0xcf

// group d
#define __Permedia2TagTextureColorMode           0xd0
#define __Permedia2TagFogMode                    0xd2
#define __Permedia2TagFogColor                   0xd3
#define __Permedia2TagFStart                     0xd4
#define __Permedia2TagdFdx                       0xd5
#define __Permedia2TagdFdyDom                    0xd6
#define __Permedia2TagKsStart                    0xd9
#define __Permedia2TagdKsdx                      0xda
#define __Permedia2TagdKsdyDom                   0xdb
#define __Permedia2TagKdStart                    0xdc
#define __Permedia2TagdKddx                      0xdd
#define __Permedia2TagdKddyDom                   0xde

// group f
#define __Permedia2TagRStart                     0xf0
#define __Permedia2TagdRdx                       0xf1
#define __Permedia2TagdRdyDom                    0xf2
#define __Permedia2TagGStart                     0xf3
#define __Permedia2TagdGdx                       0xf4
#define __Permedia2TagdGdyDom                    0xf5
#define __Permedia2TagBStart                     0xf6
#define __Permedia2TagdBdx                       0xf7
#define __Permedia2TagdBdyDom                    0xf8
#define __Permedia2TagAStart                     0xf9
#define __Permedia2TagColorDDAMode               0xfc
#define __Permedia2TagConstantColor              0xfd
#define __Permedia2TagColor                      0xfe

// group 0x10
#define __Permedia2TagAlphaBlendMode             0x102
#define __Permedia2TagDitherMode                 0x103
#define __Permedia2TagFBSoftwareWriteMask        0x104
#define __Permedia2TagLogicalOpMode              0x105
// undocumented reg:
#define __Permedia2TagFBWriteData                0x106

// group 0x11
#define __Permedia2TagLBReadMode                 0x110
#define __Permedia2TagLBReadFormat               0x111
#define __Permedia2TagLBSourceOffset             0x112
#define __Permedia2TagLBData                     0x113
#define __Permedia2TagLBStencil                  0x115
#define __Permedia2TagLBDepth                    0x116
#define __Permedia2TagLBWindowBase               0x117
#define __Permedia2TagLBWriteMode                0x118
#define __Permedia2TagLBWriteFormat              0x119
#define __Permedia2TagTextureData                0x11d
#define __Permedia2TagTextureDownloadOffset      0x11e

//group 0x13
#define __Permedia2TagWindow                     0x130
#define __Permedia2TagStencilMode                0x131
#define __Permedia2TagStencilData                0x132
#define __Permedia2TagStencil                    0x133
#define __Permedia2TagDepthMode                  0x134
#define __Permedia2TagDepth                      0x135
#define __Permedia2TagZStartU                    0x136
#define __Permedia2TagZStartL                    0x137
#define __Permedia2TagdZdxU                      0x138
#define __Permedia2TagdZdxL                      0x139
#define __Permedia2TagdZdyDomU                   0x13a
#define __Permedia2TagdZdyDomL                   0x13b

// group 0x15
#define __Permedia2TagFBReadMode                 0x150
#define __Permedia2TagFBSourceOffset             0x151
#define __Permedia2TagFBPixelOffset              0x152
#define __Permedia2TagFBColor                    0x153
#define __Permedia2TagFBData                     0x154
#define __Permedia2TagFBSourceData               0x155
#define __Permedia2TagFBWindowBase               0x156
#define __Permedia2TagFBWriteMode                0x157
#define __Permedia2TagFBHardwareWriteMask        0x158
#define __Permedia2TagFBBlockColor               0x159
#define __Permedia2TagFBReadPixel                0x15a
// undocumented register, but used (see packed blt)
#define __Permedia2TagFBWriteConfig              0x15d

// group 0x18
#define __Permedia2TagFilterMode                 0x180
#define __Permedia2TagStatisticMode              0x181
#define __Permedia2TagMinRegion                  0x182
#define __Permedia2TagMaxRegion                  0x183
#define __Permedia2TagResetPickResult            0x184
#define __Permedia2TagMinHitRegion               0x185
#define __Permedia2TagMaxHitRegion               0x186
#define __Permedia2TagPickResult                 0x187
#define __Permedia2TagSync                       0x188
#define __Permedia2TagFBBlockColorU              0x18d
#define __Permedia2TagFBBlockColorL              0x18e
#define __Permedia2TagSuspendUntilFrameBlank     0x18f

// group 0x1b
#define __Permedia2TagFBSourceBase               0x1b0
#define __Permedia2TagFBSourceDelta              0x1b1
#define __Permedia2TagConfig                     0x1b2

// group 0x1d
#define __Permedia2TagTexelLUT0                  0x1d0
#define __Permedia2TagTexelLUT1                  0x1d1
#define __Permedia2TagTexelLUT2                  0x1d2
#define __Permedia2TagTexelLUT3                  0x1d3
#define __Permedia2TagTexelLUT4                  0x1d4
#define __Permedia2TagTexelLUT5                  0x1d5
#define __Permedia2TagTexelLUT6                  0x1d6
#define __Permedia2TagTexelLUT7                  0x1d7
#define __Permedia2TagTexelLUT8                  0x1d8
#define __Permedia2TagTexelLUT9                  0x1d9
#define __Permedia2TagTexelLUT10                 0x1da
#define __Permedia2TagTexelLUT11                 0x1db
#define __Permedia2TagTexelLUT12                 0x1dc
#define __Permedia2TagTexelLUT13                 0x1dd
#define __Permedia2TagTexelLUT14                 0x1de
#define __Permedia2TagTexelLUT15                 0x1df

// group 0x1e
#define __Permedia2TagYUVMode                    0x1e0
#define __Permedia2TagChromaUpperBound           0x1e1
#define __Permedia2TagChromaLowerBound           0x1e2
#define __Permedia2TagAlphaMapUpperBound         0x1e3
#define __Permedia2TagAlphaMapLowerBound         0x1e4
#define __Permedia2TagTextureID                  0x1ee
#define __Permedia2TagTexelLUTID                 0x1ef

// group 0x20..
#define __Permedia2TagV0FixedS                   0x200
#define __Permedia2TagV0FixedT                   0x201
#define __Permedia2TagV0FixedQ                   0x202
#define __Permedia2TagV0FixedKs                  0x203
#define __Permedia2TagV0FixedKd                  0x204
#define __Permedia2TagV0FixedR                   0x205
#define __Permedia2TagV0FixedG                   0x206
#define __Permedia2TagV0FixedB                   0x207
#define __Permedia2TagV0FixedA                   0x208
#define __Permedia2TagV0FixedF                   0x209
#define __Permedia2TagV0FixedX                   0x20a
#define __Permedia2TagV0FixedY                   0x20b
#define __Permedia2TagV0FixedZ                   0x20c
#define __Permedia2TagV0FixedW                   0x20d
#define __Permedia2TagV1FixedS                   0x210
#define __Permedia2TagV1FixedT                   0x211
#define __Permedia2TagV1FixedQ                   0x212
#define __Permedia2TagV1FixedKs                  0x213
#define __Permedia2TagV1FixedKd                  0x214
#define __Permedia2TagV1FixedR                   0x215
#define __Permedia2TagV1FixedG                   0x216
#define __Permedia2TagV1FixedB                   0x217
#define __Permedia2TagV1FixedA                   0x218
#define __Permedia2TagV1FixedF                   0x219
#define __Permedia2TagV1FixedX                   0x21a
#define __Permedia2TagV1FixedY                   0x21b
#define __Permedia2TagV1FixedZ                   0x21c
#define __Permedia2TagV1FixedW                   0x21d
#define __Permedia2TagV2FixedS                   0x220
#define __Permedia2TagV2FixedT                   0x221
#define __Permedia2TagV2FixedQ                   0x222
#define __Permedia2TagV2FixedKs                  0x223
#define __Permedia2TagV2FixedKd                  0x224
#define __Permedia2TagV2FixedR                   0x225
#define __Permedia2TagV2FixedG                   0x226
#define __Permedia2TagV2FixedB                   0x227
#define __Permedia2TagV2FixedA                   0x228
#define __Permedia2TagV2FixedF                   0x229
#define __Permedia2TagV2FixedX                   0x22a
#define __Permedia2TagV2FixedY                   0x22b
#define __Permedia2TagV2FixedZ                   0x22c
#define __Permedia2TagV2FixedW                   0x22d
#define __Permedia2TagV0FloatS                   0x230
#define __Permedia2TagV0FloatT                   0x231
#define __Permedia2TagV0FloatQ                   0x232
#define __Permedia2TagV0FloatKs                  0x233
#define __Permedia2TagV0FloatKd                  0x234
#define __Permedia2TagV0FloatR                   0x235
#define __Permedia2TagV0FloatG                   0x236
#define __Permedia2TagV0FloatB                   0x237
#define __Permedia2TagV0FloatA                   0x238
#define __Permedia2TagV0FloatF                   0x239
#define __Permedia2TagV0FloatX                   0x23a
#define __Permedia2TagV0FloatY                   0x23b
#define __Permedia2TagV0FloatZ                   0x23c
#define __Permedia2TagV0FloatW                   0x23d
#define __Permedia2TagV1FloatS                   0x240
#define __Permedia2TagV1FloatT                   0x241
#define __Permedia2TagV1FloatQ                   0x242
#define __Permedia2TagV1FloatKs                  0x243
#define __Permedia2TagV1FloatKd                  0x244
#define __Permedia2TagV1FloatR                   0x245
#define __Permedia2TagV1FloatG                   0x246
#define __Permedia2TagV1FloatB                   0x247
#define __Permedia2TagV1FloatA                   0x248
#define __Permedia2TagV1FloatF                   0x249
#define __Permedia2TagV1FloatX                   0x24a
#define __Permedia2TagV1FloatY                   0x24b
#define __Permedia2TagV1FloatZ                   0x24c
#define __Permedia2TagV1FloatW                   0x24d
#define __Permedia2TagV2FloatS                   0x250
#define __Permedia2TagV2FloatT                   0x251
#define __Permedia2TagV2FloatQ                   0x252
#define __Permedia2TagV2FloatKs                  0x253
#define __Permedia2TagV2FloatKd                  0x254
#define __Permedia2TagV2FloatR                   0x255
#define __Permedia2TagV2FloatG                   0x256
#define __Permedia2TagV2FloatB                   0x257
#define __Permedia2TagV2FloatA                   0x258
#define __Permedia2TagV2FloatF                   0x259
#define __Permedia2TagV2FloatX                   0x25a
#define __Permedia2TagV2FloatY                   0x25b
#define __Permedia2TagV2FloatZ                   0x25c
#define __Permedia2TagV2FloatW                   0x25d
#define __Permedia2TagDeltaMode                  0x260
#define __Permedia2TagDrawTriangle               0x261
#define __Permedia2TagRepeatTriangle             0x262
#define __Permedia2TagDrawLine01                 0x263
#define __Permedia2TagDrawLine10                 0x264
#define __Permedia2TagRepeatLine                 0x265
// special define???
// #define __Permedia2TagBroadcastMask              0x26f
// #define __MaximumPermediaTagValue  __Permedia2TagBroadcastMask

#define __Permedia2TagAreaStipplePattern(i)     (0x040+(i))

typedef long __Permedia2Tag ;

/*-----------------------------------------------------*/
#define __PERMEDIA_MAX_YSAMPLES 8  

#define __PERMEDIA_SAMPLES 4

#if __PERMEDIA_SAMPLES == 8

#define __PERMEDIA_SUBSAMPLES  64
#define __PERMEDIA_XSUBSAMPLES 8
#define __PERMEDIA_YSUBSAMPLES 8
#define __PERMEDIA_COLOR_SCALE 4

#define __PERMEDIA_SAMPLENORM  0.015625
#define __PERMEDIA_SPANNORM    0.125

#define __PERMEDIA_XSUBPIXSCALE 8
#define __PERMEDIA_XSUBPIXBITS  3
#define __PERMEDIA_XSUBPIXSHIFT 3
#define __PERMEDIA_XSUBPIXMASK  7
#define __PERMEDIA_XFRACSHIFT   0

#define __PERMEDIA_YSUBPIXSCALE __PERMEDIA_XSUBPIXSCALE
#define __PERMEDIA_YSUBPIXBITS  __PERMEDIA_XSUBPIXBITS
#define __PERMEDIA_YSUBPIXSHIFT __PERMEDIA_XSUBPIXSHIFT
#define __PERMEDIA_YSUBPIXMASK  __PERMEDIA_XSUBPIXMASK

#elif __PERMEDIA_SAMPLES == 4

#define __PERMEDIA_SUBSAMPLES  16
#define __PERMEDIA_XSUBSAMPLES 4
#define __PERMEDIA_YSUBSAMPLES 4
#define __PERMEDIA_COLOR_SCALE 16

#define __PERMEDIA_SAMPLENORM   0.0625 
#define __PERMEDIA_SPANNORM     0.25  

#define __PERMEDIA_XSUBPIXSCALE 8
#define __PERMEDIA_XSUBPIXBITS  3 
#define __PERMEDIA_XSUBPIXSHIFT 3 
#define __PERMEDIA_XSUBPIXMASK  7 
#define __PERMEDIA_XFRACSHIFT   1

#define __PERMEDIA_YSUBPIXSCALE 4
#define __PERMEDIA_YSUBPIXBITS  2  
#define __PERMEDIA_YSUBPIXSHIFT 2  
#define __PERMEDIA_YSUBPIXMASK  3 

#elif __PERMEDIA_SAMPLES == 2

"NOT SUPPORTED YET"

#else  /* __PERMEDIA_SAMPLES == 1 Alias Case */

#define __PERMEDIA_SUBSAMPLES  1
#define __PERMEDIA_XSUBSAMPLES 1
#define __PERMEDIA_YSUBSAMPLES 1
#define __PERMEDIA_COLOR_SCALE 255

#define __PERMEDIA_SAMPLENORM   1
#define __PERMEDIA_SPANNORM     1

#define __PERMEDIA_XSUBPIXSCALE 8
#define __PERMEDIA_XSUBPIXBITS  3
#define __PERMEDIA_XSUBPIXSHIFT 3
#define __PERMEDIA_XSUBPIXMASK  7
 
#define __PERMEDIA_XFRACSHIFT   3

#define __PERMEDIA_YSUBPIXSCALE 1
#define __PERMEDIA_YSUBPIXBITS  0
#define __PERMEDIA_YSUBPIXSHIFT 0
#define __PERMEDIA_YSUBPIXMASK  ~0
#endif

/*-----------------------------------------------------*/
#define __PERMEDIA_POS_Z_FIXED_PT_SCALE  2147483647.0    /* 2**31 - 1*/
#define __PERMEDIA_NEG_Z_FIXED_PT_SCALE  1073741824.0    /* 2**30 */

#define __PERMEDIA_POS_Z_FIXED_PT_SCALE_RECIP  (1.0/2147483647.0)   
#define __PERMEDIA_NEG_Z_FIXED_PT_SCALE_RECIP  (1.0/1073741824.0)

#define RGB_MODE         1
#define COLOR_MODE       1 /* 0=BGR, 1=RGB */
#define DITHER_XOFFSET   0
#define DITHER_YOFFSET   0
#define DITHER_ENABLE    __PERMEDIA_ENABLE
#define MS_BIT_MASK             0x80000000l

// Shifts to enable units
// DepthMode
#define __PERMEDIA_DEPTHMODE_ENABLE 0
#define __PERMEDIA_DEPTHMODE_WRITEMASK 1
#define __PERMEDIA_DEPTHMODE_SOURCEDEPTH 2
#define __PERMEDIA_DEPTHMODE_COMPARISON 4

/* sync_mode definitions for the SuspendUntilFramBlank tag */

#define EXT_VIDEO_WAITFOR_FB     0
#define EXT_VIDEO_IMMEDIATE      1
#define VTG_FRAMEROW_WAITFOR_FB  2
#define VTG_FRAMEROW_IMMEDIATE   3

typedef struct PartialProductCode
{
    ULONG   cxDelta;
    ULONG   ulPartialProducts;
}
PPCODE;

extern const PPCODE aPartialProducts[];

#define GET_PPCODE(cxTextureWidth, cxTextureDelta, pp) \
{ \
    int i = (cxTextureWidth + 31) / 32; \
    cxTextureDelta  = aPartialProducts[i].cxDelta; \
    pp              = aPartialProducts[i].ulPartialProducts; \
}

// Color component order
#define INV_COLOR_MODE   0 /* 0=RGB, 1=BGR */


#endif /* _P2DEF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\p2rd.h ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: p2rd.h
 *
 * This module contains constants for the P2 internal Ramdac
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
//
// 3Dlabs P2RD RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _p2rd_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;
} P2RDRAMDAC, *pP2RDRAMDAC;

//
// structure containing the mapped addresses for each of the P2RD registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _p2rd_data
{
    //
    // Register addresses
    //
    ULONG_PTR   RDPaletteWriteAddress;
    ULONG_PTR   RDPaletteData;
    ULONG_PTR   RDPixelMask;
    ULONG_PTR   RDPaletteAddressRead;
    ULONG_PTR   RDIndexLow;
    ULONG_PTR   RDIndexHigh;
    ULONG_PTR   RDIndexedData;
    ULONG_PTR   RDIndexControl;

    //
    // RAMDAC state info
    //
    ULONG       cursorModeOff;      // cursor disabled
    ULONG       cursorModeCurrent;  // disabled 32/64 mode cursor 
    ULONG       cursorControl;      // x & y zoom, etc.
    ULONG       cursorSize;         // see P2RD_CURSOR_SIZE_*
    ULONG       x, y;
} P2RDData, *pP2RDData;

//
// Macro declared by any function wishing to use the P2ST internal RAMDAC .
// MUST be declared after PERMEDIA_DECL.
//
#define P2RD_DECL_VARS pP2RDData pP2RDinfo
#define P2RD_DECL_INIT pP2RDinfo = (pP2RDData)ppdev->pvPointerData

#define P2RD_DECL \
            P2RD_DECL_VARS; \
            P2RD_DECL_INIT

//
// use the following macros as the address to pass to the
// WRITE_P2RDREG_ULONG function
//
//  Palette Access
#define P2RD_PAL_WR_ADDR            (pP2RDinfo->RDPaletteWriteAddress)
#define P2RD_PAL_RD_ADDR            (pP2RDinfo->RDPaletteAddressRead)
#define P2RD_PAL_DATA               (pP2RDinfo->RDPaletteData)

// Pixel mask
#define P2RD_PIXEL_MASK             (pP2RDinfo->RDPixelMask)

// Access to the indexed registers
#define P2RD_INDEX_ADDR_LO          (pP2RDinfo->RDIndexLow)
#define P2RD_INDEX_ADDR_HI          (pP2RDinfo->RDIndexHigh)
#define P2RD_INDEX_DATA             (pP2RDinfo->RDIndexedData)
#define P2RD_INDEX_CONTROL          (pP2RDinfo->RDIndexControl)


// Bit field definitions for the direct access registers
#define P2RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// Indexed register definitions accessed via P2RD_LOAD_INDEX_REG() and
// P2RD_READ_INDEX_REG()
#define P2RD_MISC_CONTROL               0x0000
#define P2RD_SYNC_CONTROL               0x0001
#define P2RD_DAC_CONTROL                0x0002
#define P2RD_PIXEL_SIZE                 0x0003
#define P2RD_COLOR_FORMAT               0x0004
#define P2RD_CURSOR_MODE                0x0005
#define P2RD_CURSOR_CONTROL             0x0006
#define P2RD_CURSOR_X_LOW               0x0007
#define P2RD_CURSOR_X_HIGH              0x0008
#define P2RD_CURSOR_Y_LOW               0x0009
#define P2RD_CURSOR_Y_HIGH              0x000a
#define P2RD_CURSOR_HOTSPOT_X           0x000b
#define P2RD_CURSOR_HOTSPOT_Y           0x000c
#define P2RD_OVERLAY_KEY                0x000d
#define P2RD_PAN                        0x000e
#define P2RD_SENSE                      0x000f
#define P2RD_CHECK_CONTROL              0x0018
#define P2RD_CHECK_PIXEL_RED            0x0019
#define P2RD_CHECK_PIXEL_GREEN          0x001a
#define P2RD_CHECK_PIXEL_BLUE           0x001b
#define P2RD_CHECK_LUT_RED              0x001c
#define P2RD_CHECK_LUT_GREEN            0x001d
#define P2RD_CHECK_LUT_BLUE             0x001e
#define P2RD_DCLK_SETUP_1               0x01f0
#define P2RD_DCLK_SETUP_2               0x01f1
#define P2RD_MCLK_SETUP_1               0x01f2
#define P2RD_MCLK_SETUP_2               0x01f3
#define P2RD_DCLK_CONTROL               0x0200
#define P2RD_DCLK0_PRE_SCALE            0x0201
#define P2RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P2RD_DCLK0_POST_SCALE           0x0203
#define P2RD_DCLK1_PRE_SCALE            0x0204
#define P2RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P2RD_DCLK1_POST_SCALE           0x0206
#define P2RD_DCLK2_PRE_SCALE            0x0207
#define P2RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P2RD_DCLK2_POST_SCALE           0x0209
#define P2RD_DCLK3_PRE_SCALE            0x020a
#define P2RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P2RD_DCLK3_POST_SCALE           0x020c
#define P2RD_MCLK_CONTROL               0x020d
#define P2RD_MCLK_PRE_SCALE             0x020e
#define P2RD_MCLK_FEEDBACK_SCALE        0x020f
#define P2RD_MCLK_POST_SCALE            0x0210
#define P2RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P2RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P2RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P2RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00

#define P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P2RD_PIXEL_SIZE_8BPP            0x00
#define P2RD_PIXEL_SIZE_16BPP           0x01
#define P2RD_PIXEL_SIZE_24_BPP          0x04
#define P2RD_PIXEL_SIZE_32BPP           0x02

#define P2RD_COLOR_FORMAT_CI8           0x0e
#define P2RD_COLOR_FORMAT_8BPP          0x05
#define P2RD_COLOR_FORMAT_15BPP         0x01
#define P2RD_COLOR_FORMAT_16BPP         0x10
#define P2RD_COLOR_FORMAT_32BPP         0x00
#define P2RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P2RD_CURSOR_MODE_REVERSE        0x40
#define P2RD_CURSOR_MODE_WINDOWS        0x00
#define P2RD_CURSOR_MODE_X              0x10
#define P2RD_CURSOR_MODE_3COLOR         0x20
#define P2RD_CURSOR_MODE_15COLOR        0x30
#define P2RD_CURSOR_MODE_64x64          0x00
#define P2RD_CURSOR_MODE_P0_32x32x2     0x02
#define P2RD_CURSOR_MODE_P1_32x32x2     0x04
#define P2RD_CURSOR_MODE_P2_32x32x2     0x06
#define P2RD_CURSOR_MODE_P3_32x32x2     0x08
#define P2RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P2RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P2RD_CURSOR_MODE_ENABLED        0x01

#define P2RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P2RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P2RD_CURSOR_CONTROL_DOUBLE_X        0x01

#define P2RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_DCLK_CONTROL_ENABLED   0x01

#define P2RD_MCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_MCLK_CONTROL_ENABLED   0x01

#define P2RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}

#define P2RD_SYNC_WITH_PERMEDIA

//
// generic read/write routines for P2RD registers
//

#define WRITE_P2RDREG_ULONG(r, d) \
{ \
    WRITE_REGISTER_ULONG((PULONG)(r), d); \
    MEMORY_BARRIER(); \
}

#define READ_P2RDREG_ULONG(r)    READ_REGISTER_ULONG((PULONG)(r))

//
// Macro to load a given data value into an internal P2RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P2RD_INDEX_REG(index) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
}

#define P2RD_LOAD_DATA(data) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

#define P2RD_LOAD_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

#define P2RD_READ_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    data = READ_P2RDREG_ULONG(P2RD_INDEX_DATA) & 0xff;   \
}

#define P2RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_LO, (ULONG)(index));  \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA,    (ULONG)(data));   \
}

//
// Macros to load a given RGB triple into the P2RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P2RD_PALETTE_START and multiple P2RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P2RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P2RD_PALETTE_START_WR(index) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_WR_ADDR,     (ULONG)(index));    \
}

#define P2RD_PALETTE_START_RD(index) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_RD_ADDR,     (ULONG)(index));    \
}

#define P2RD_LOAD_PALETTE(red, green, blue) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(red));      \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(green));    \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(blue));     \
}

#define P2RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PAL_WR_ADDR, (ULONG)(index));    \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(red));      \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(green));    \
    WRITE_P2RDREG_ULONG(P2RD_PAL_DATA,    (ULONG)(blue));     \
}

//
// Macro to read back a given RGB triple from the P2RD palette. Use after
// a call to P2RD_PALETTE_START_RD
//
#define P2RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_P2RDREG_ULONG(P2RD_PAL_DATA) & 0xff);        \
    green = (UCHAR)(READ_P2RDREG_ULONG(P2RD_PAL_DATA) & 0xff);        \
    blue  = (UCHAR)(READ_P2RDREG_ULONG(P2RD_PAL_DATA) & 0xff);        \
}

//
// Macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P2RD_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_PIXEL_MASK,  (ULONG)(mask)); \
}

#define P2RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = READ_P2RDREG_ULONG(P2RD_PIXEL_MASK) & 0xff; \
}

//
// Windows format byte-packed cursor data: each byte represents 4 consecutive
// pixels
//
#define P2RD_CURSOR_2_COLOR_BLACK           0x00
#define P2RD_CURSOR_2_COLOR_WHITE           0x55
#define P2RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P2RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF
#define P2RD_CURSOR_3_COLOR_TRANSPARENT     0x00
#define P2RD_CURSOR_15_COLOR_TRANSPARENT    0x00

//
// Macros to load values into the cursor array usage is
// P2RD_CURSOR_ARRAR_START() followed by n iterations of P2RD_LOAD_CURSOR_ARRAY()
// or P2RD_READ_CURSOR_ARRAY()
//
#define P2RD_CURSOR_ARRAY_START(offset) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_LO,(ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) & 0xff));\
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) >> 8));    \
}

#define P2RD_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_DATA, (ULONG)(data)); \
}

#define P2RD_READ_CURSOR_ARRAY(data) \
{ \
    data = READ_P2RDREG_ULONG(P2RD_INDEX_DATA) & 0xff; \
}

// macro to move the cursor
//
#define P2RD_MOVE_CURSOR(x, y) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI, (ULONG)0);              \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P2RD_CURSOR_HOTSPOT(x, y) \
{ \
    WRITE_P2RDREG_ULONG(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
    
// cursor sizes
#define P2RD_CURSOR_SIZE_64_MONO    0
#define P2RD_CURSOR_SIZE_32_MONO    1
#define P2RD_CURSOR_SIZE_64_3COLOR  0 
#define P2RD_CURSOR_SIZE_32_3COLOR  1
#define P2RD_CURSOR_SIZE_32_15COLOR 5

#define P2RD_CURSOR_SEL(cursorSize, cursorIndex) (((cursorSize + cursorIndex) & 7) << 1)

//
// exported functions from pointer.c. Anything which is P2RD specific goes
// in this file as well as real pointer stuff.
//
extern BOOL  bP2RDCheckCSBuffering(PPDev);
extern BOOL  bP2RDSwapCSBuffers(PPDev, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\p2regs.h ===
/******************************Module*Header**********************************\
*
*
* Module Name: p2regs.h
*
* Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef P2REG_H
#define P2REG_H

#if (defined(_MSDOS)/* mr || defined(__cplusplus)*/)
typedef unsigned long unsigned32;
typedef signed long   signed32;
#else
typedef unsigned int unsigned32;
typedef signed int   signed32;
#endif

typedef unsigned short unsigned16;
typedef signed short   signed16;

typedef unsigned char unsigned8;
typedef signed char   signed8;

typedef long __Permedia2SignedIntegerFmat;
typedef unsigned32 __Permedia2UnsignedIntegerFmat;

/*
** Generic signed 16 + signed 16 format
*/

#if BIG_ENDIAN == 1 
typedef struct {
  signed32 hi:             16;
  signed32 lo:             16;
} __Permedia2S16S16Fmat;
#else
typedef struct {
  signed32 lo:             16;
  signed32 hi:             16;
} __Permedia2S16S16Fmat;
#endif 

/*
** Delta Registers
*/

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      13;
  unsigned32 ColorOrder:                1;
  unsigned32 BackfaceCull:              1;
  unsigned32 FillDirection:             1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 ClampEnable:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 DiamondExit:               1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DepthEnable:               1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 DepthFormat:               2;
  unsigned32 TargetChip:                2;
} __Permedia2DeltaModeFmat;
#else
typedef struct {
  unsigned32 TargetChip:                2;
  unsigned32 DepthFormat:               2;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 DepthEnable:               1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiamondExit:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 ClampEnable:               1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 FillDirection:             1;
  unsigned32 BackfaceCull:              1;
  unsigned32 ColorOrder:                1;
  unsigned32 pad:                      13;
} __Permedia2DeltaModeFmat;
#endif

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad2:                     11;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad1:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad0:                      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 CoverageEnable:            1;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 UsePointTable:             1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 AntialiasEnable:           1;
  unsigned32 PrimitiveType:             2;
  unsigned32 reserved:                  2;
  unsigned32 FastFillEnable:            1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 AreaStippleEnable:         1;
} __Permedia2DeltaDrawFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:         1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 FastFillEnable:            1;
  unsigned32 reserved:                  2;
  unsigned32 PrimitiveType:             2;
  unsigned32 AntialiasEnable:           1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 UsePointTable:             1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 CoverageEnable:            1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 pad0:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad1:                      1;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad2:                     11;
} __Permedia2DeltaDrawFmat;
#endif

#ifdef BIG_ENDIAN
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 pad:                     8;
    unsigned32 Val:                    24; /* 2.22s */
  } K;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.30us */
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.31us */
  } Z;
} __Permedia2DeltaFixedFmat;
#else 
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 Val:                    24; /* 2.22s */
    unsigned32 pad:                     8;
  } K;
  struct {
    unsigned32 Val:                    31; /* 1.30us */
    unsigned32 pad:                     1;
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 Val:                    31; /* 1.31us */
    unsigned32 pad:                     1;
  } Z;
} __Permedia2DeltaFixedFmat;
#endif

#define N_P2_DELTA_BROADCAST_MASK_BITS 4 

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      32 - N_P2_DELTA_BROADCAST_MASK_BITS;
  unsigned32 Mask:	               N_P2_DELTA_BROADCAST_MASK_BITS ;
} __Permedia2DeltaBroadcastMaskFmat;
#else
typedef struct {
  unsigned32 Mask:                     N_P2_DELTA_BROADCAST_MASK_BITS ;
  unsigned32 pad:                      32 - N_P2_DELTA_BROADCAST_MASK_BITS ;
} __Permedia2DeltaBroadcastMaskFmat;
#endif

/*
** Permedia 2 Host In Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Mask:         16;
  unsigned32 Mode:          2;
  unsigned32 pad0:          5;
  unsigned32 MajorGroup:    5;
  unsigned32 Offset:        4;
} __Permedia2DMADataFmat;
#else
typedef struct {
  unsigned32 Offset:        4;
  unsigned32 MajorGroup:    5;
  unsigned32 pad0:          5;
  unsigned32 Mode:          2;
  unsigned32 Mask:         16;
} __Permedia2DMADataFmat;
#endif

/*
**  Permedia 2 Rasterizer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __Permedia2StartXDomFmat,
  __Permedia2dXDomFmat,
  __Permedia2StartXSubFmat,
  __Permedia2dXSubFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __Permedia2StartXDomFmat,
  __Permedia2dXDomFmat,
  __Permedia2StartXSubFmat,
  __Permedia2dXSubFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __Permedia2StartYFmat,
  __Permedia2dYFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __Permedia2StartYFmat,
  __Permedia2dYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         20;
  unsigned32 Val:          12;
} __Permedia2CountFmat,
  __Permedia2ContinueNewLineFmat,
  __Permedia2ContinueNewDomFmat,
  __Permedia2ContinueNewSubFmat,
  __Permedia2ContinueFmat;
#else
typedef struct {
  unsigned32 Val:          12;
  unsigned32 pad0:         20;
} __Permedia2CountFmat,
  __Permedia2ContinueNewLineFmat,
  __Permedia2ContinueNewDomFmat,
  __Permedia2ContinueNewSubFmat,
  __Permedia2ContinueFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad5:                     9;
  unsigned32 IncreaseY:                1;
  unsigned32 IncreaseX:                1;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 pad4:                     2;
  unsigned32 ReuseBitMask:             1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 pad3:                     1;
  unsigned32 FogEnable:                1;
  unsigned32 TextureEnable:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 pad2:                     3;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad1:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad0:                     2;
  unsigned32 AreaStippleEnable:        1;
} __Permedia2RenderFmat,
  __Permedia2PrepareToRenderFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:        1;
  unsigned32 pad0:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad1:                     2;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad2:                     3;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 TextureEnable:            1;
  unsigned32 FogEnable:                1;
  unsigned32 pad3:                     1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 ReuseBitMask:             1;
  unsigned32 pad4:                     2;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 IncreaseX:                1;
  unsigned32 IncreaseY:                1;
  unsigned32 pad5:                     9;
} __Permedia2RenderFmat,
  __Permedia2PrepareToRenderFmat;
#endif 

typedef __Permedia2UnsignedIntegerFmat __Permedia2BitMaskPatternFmat;

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad1:                12;
  unsigned32 BitMaskRelative:      1;
  unsigned32 LimitsEnable:         1;
  unsigned32 pad0:                 1;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 BitMaskOffset:        5;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BiasCoordinates:      2;
  unsigned32 FractionAdjust:       2;
  unsigned32 InvertBitMask:        1;
  unsigned32 MirrorBitMask:        1;
} __Permedia2RasterizerModeFmat;
#else
typedef struct {
  unsigned32 MirrorBitMask:        1;
  unsigned32 InvertBitMask:        1;
  unsigned32 FractionAdjust:       2;
  unsigned32 BiasCoordinates:      2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskOffset:        5;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 pad0:                 1;
  unsigned32 LimitsEnable:         1;
  unsigned32 BitMaskRelative:      1;
  unsigned32 pad1:                12;
} __Permedia2RasterizerModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Max:             12;
  unsigned32 pad0:           4;
  signed32 Min:             12;
} __Permedia2YLimitsFmat, __Permedia2XLimitsFmat;
#else
typedef struct {
  signed32 Min:             12;
  unsigned32 pad0:           4;
  signed32 Max:             12;
  unsigned32 pad1:           4;
} __Permedia2YLimitsFmat, __Permedia2XLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2StepFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2StepFmat;
#endif

typedef __Permedia2StepFmat __Permedia2ActiveStepXFmat;
typedef __Permedia2StepFmat __Permedia2ActiveStepYDomEdgeFmat;
typedef __Permedia2StepFmat __Permedia2PassiveStepXFmat;
typedef __Permedia2StepFmat __Permedia2PassiveStepYDomEdgeFmat;
typedef __Permedia2StepFmat __Permedia2FastBlockFillFmat;
typedef __Permedia2StepFmat __Permedia2RectangleOriginFmat;
typedef __Permedia2StepFmat __Permedia2RectangleSizeFmat;
typedef __Permedia2StepFmat __Permedia2FBSourceDeltaFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __Permedia2UnsignedStepFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __Permedia2UnsignedStepFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 XRight:         12;
  unsigned32 pad0:          4;
  signed32 XLeft:          12;
} __Permedia2FastBlockLimitsFmat;
#else
typedef struct {
  signed32 XLeft:          12;
  unsigned32 pad0:          4;
  signed32 XRight:         12;
  unsigned32 pad1:          4;
} __Permedia2FastBlockLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          27;
  unsigned32 Sign:           1;
  unsigned32 Magnitude:      4;
} __Permedia2SubPixelCorrectionFmat;
#else
typedef struct {
  unsigned32 Magnitude:      4;
  unsigned32 Sign:           1;
  unsigned32 pad0:          27;
} __Permedia2SubPixelCorrectionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 RelativeOffset:  3;
  unsigned32 pad1:          1;
  signed32 XStart:         12;
  unsigned32 pad0:          4;
  signed32 XEnd:           12;
} __Permedia2PackedDataLimitsFmat;
#else
typedef struct {
  signed32 XEnd:           12;
  unsigned32 pad0:          4;
  signed32 XStart:         12;
  unsigned32 pad1:          1;
  signed32 RelativeOffset:  3;
} __Permedia2PackedDataLimitsFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2SpanMaskFmat;

/*
**  Permedia 2 Scissor and Stipple Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                30;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 UserScissorEnable:    1;
} __Permedia2ScissorModeFmat;
#else
typedef struct {
  unsigned32 UserScissorEnable:    1;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 pad0:                30;
} __Permedia2ScissorModeFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                 11;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 MirrorY:               1;
  unsigned32 MirrorX:               1;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 pad2:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 XOffset:               3;
  unsigned32 pad0:                  6;
  unsigned32 UnitEnable:            1;
} __Permedia2AreaStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 pad0:                  6;
  unsigned32 XOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad2:                  2;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 MirrorX:               1;
  unsigned32 MirrorY:               1;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 pad3:                 11;
} __Permedia2AreaStippleModeFmat;
#endif

typedef __Permedia2StepFmat __Permedia2ScreenRegionFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2ScissorMinXYFmat, __Permedia2ScissorMaxXYFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2ScissorMinXYFmat, __Permedia2ScissorMaxXYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2WindowOriginFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2WindowOriginFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __Permedia2ScreenSizeFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __Permedia2ScreenSizeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         24;
  unsigned32 Pattern:       8;
} __Permedia2AreaStipplePatternFmat;
#else
typedef struct {
  unsigned32 Pattern:       8;
  unsigned32 pad0:         24;
} __Permedia2AreaStipplePatternFmat;
#endif

/*
**  Permedia 2 Color DDA Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __Permedia2CStartFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __Permedia2CStartFmat;
#endif

typedef __Permedia2CStartFmat __Permedia2RStartFmat;
typedef __Permedia2CStartFmat __Permedia2GStartFmat;
typedef __Permedia2CStartFmat __Permedia2BStartFmat;
typedef __Permedia2CStartFmat __Permedia2AStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __Permedia2dCdxFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __Permedia2dCdxFmat;
#endif

typedef __Permedia2dCdxFmat __Permedia2dRdxFmat;
typedef __Permedia2dCdxFmat __Permedia2dGdxFmat;
typedef __Permedia2dCdxFmat __Permedia2dBdxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __Permedia2dCdyDomFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __Permedia2dCdyDomFmat;
#endif

typedef __Permedia2dCdyDomFmat __Permedia2dRdyDomFmat;
typedef __Permedia2dCdyDomFmat __Permedia2dGdyDomFmat;
typedef __Permedia2dCdyDomFmat __Permedia2dBdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:            8;
  unsigned32 Blue:             8;
  unsigned32 Green:            8;
  unsigned32 Red:              8;
} __Permedia2ColorFmat;
#else
typedef struct {
  unsigned32 Red:              8;
  unsigned32 Green:            8;
  unsigned32 Blue:             8;
  unsigned32 Alpha:            8;
} __Permedia2ColorFmat;
#endif

typedef __Permedia2ColorFmat __Permedia2ConstantColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 AlphaInteger:     5;
  unsigned32 AlphaFraction:    3;
  unsigned32 BlueInteger:      5;
  unsigned32 BlueFraction:     3;
  unsigned32 GreenInteger:     5;
  unsigned32 GreenFraction:    3;
  unsigned32 RedInteger:       5;
  unsigned32 RedFraction:      3;
} __Permedia2FractionalColorFmat;
#else
typedef struct {
  unsigned32 RedFraction:      3;
  unsigned32 RedInteger:       5;
  unsigned32 GreenFraction:    3;
  unsigned32 GreenInteger:     5;
  unsigned32 BlueFraction:     3;
  unsigned32 BlueInteger:      5;
  unsigned32 AlphaFraction:    3;
  unsigned32 AlphaInteger:     5;
} __Permedia2FractionalColorFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             30;
  unsigned32 ShadeMode:         1;
  unsigned32 UnitEnable:        1;
} __Permedia2ColorDDAModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 ShadeMode:         1;
  unsigned32 pad0:             30;
} __Permedia2ColorDDAModeFmat;
#endif

/*
**  Permedia 2 Texture Application, Fog and 
**       Alpha Blend Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          8;  
  signed32 Integer:         2;
  unsigned32 Fraction:     19;
  unsigned32 pad0:          3;           
} __Permedia2FogFmat;
#else
typedef struct {
  unsigned32 pad0:          3;           
  unsigned32 Fraction:     19;
  signed32 Integer:         2;
  unsigned32 pad1:          8;  
} __Permedia2FogFmat;
#endif

typedef __Permedia2FogFmat __Permedia2FStartFmat;
typedef __Permedia2FogFmat __Permedia2dFdxFmat;
typedef __Permedia2FogFmat __Permedia2dFdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:            29;
  unsigned32 FogTest:          1;
  unsigned32 pad0:             1;
  unsigned32 FogEnable:        1;
} __Permedia2FogModeFmat;
#else
typedef struct {
  unsigned32 FogEnable:        1;
  unsigned32 pad0:             1;
  unsigned32 FogTest:          1;
  unsigned32 pad1:            29;
} __Permedia2FogModeFmat;
#endif

typedef __Permedia2ColorFmat __Permedia2FogColorFmat;
typedef __Permedia2ColorFmat __Permedia2TexelFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            25;
  unsigned32 KsDDA:            1;
  unsigned32 KdDDA:            1;
  unsigned32 TextureType:      1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureEnable:    1;
} __Permedia2TextureColorModeFmat;
#else
typedef struct {
  unsigned32 TextureEnable:    1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureType:      1;
  unsigned32 KdDDA:            1;
  unsigned32 KsDDA:            1;
  unsigned32 pad0:            25;
} __Permedia2TextureColorModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                13;
  unsigned32 AlphaConversion:      1;
  unsigned32 ColorConversion:      1;
  unsigned32 ColorFormatExtension: 1;
  unsigned32 pad1:                 1;
  unsigned32 BlendType:            1;
  unsigned32 ColorOrder:           1;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorFormat:          4;
  unsigned32 DestinationBlend:	   3;
  unsigned32 SourceBlend:		   4;
  unsigned32 AlphaBlendEnable:     1;
} __Permedia2AlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 AlphaBlendEnable:     1;
  unsigned32 SourceBlend:          4;
  unsigned32 DestinationBlend:	   3;
  unsigned32 ColorFormat:          4;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorOrder:           1;
  unsigned32 BlendType:            1;
  unsigned32 pad1:                 1;
  unsigned32 ColorFormatExtension: 1; 
  unsigned32 ColorConversion:      1;
  unsigned32 AlphaConversion:      1;
  unsigned32 pad2:                13;
} __Permedia2AlphaBlendModeFmat;
#endif

/*
**  Permedia 2 Texture Address Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:         12;
  unsigned32 Fraction:      18;
  unsigned32 pad1:           2;
} __Permedia2STFmat;
#else
typedef struct {
  unsigned32 pad1:           2;
  unsigned32 Fraction:      18;
  signed32 Integer:         12;
} __Permedia2STFmat;
#endif

typedef __Permedia2STFmat __Permedia2SStartFmat;
typedef __Permedia2STFmat __Permedia2TStartFmat;
typedef __Permedia2STFmat __Permedia2dSdxFmat;
typedef __Permedia2STFmat __Permedia2dTdxFmat;
typedef __Permedia2STFmat __Permedia2dSdyDomFmat;
typedef __Permedia2STFmat __Permedia2dTdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:          2;
  unsigned32 Fraction:      27;
  unsigned32 pad0:           3;
} __Permedia2QFmat;
#else
typedef struct {
  unsigned32 pad0:           3;
  unsigned32 Fraction:      27;
  signed32 Integer:          2;
} __Permedia2QFmat;
#endif

typedef __Permedia2QFmat __Permedia2QStartFmat;
typedef __Permedia2QFmat __Permedia2dQdxFmat;
typedef __Permedia2QFmat __Permedia2dQdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TLoMagnitude:    12;
  unsigned32 SSign:            1;
  unsigned32 SMagnitude:      19;
} __Permedia2TextureAddressFmat0;
#else
typedef struct {
  unsigned32 SMagnitude:      19;
  unsigned32 SSign:            1;
  unsigned32 TLoMagnitude:    12;
} __Permedia2TextureAddressFmat0;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            24;
  unsigned32 TSign:            1;
  unsigned32 THiMagnitude:     7;
} __Permedia2TextureAddressFmat1;
#else
typedef struct {
  unsigned32 THiMagnitude:     7;
  unsigned32 TSign:            1;
  unsigned32 pad0:            24;
} __Permedia2TextureAddressFmat1;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                    28;
  unsigned32 DeltaFormat:              1;
  unsigned32 Fast:                     1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Enable:                   1;
} __Permedia2TextureAddrModeFmat;
#else
typedef struct {
  unsigned32 Enable:                   1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Fast:                     1;
  unsigned32 DeltaFormat:              1;
  unsigned32 pad0:                    28;
} __Permedia2TextureAddrModeFmat;
#endif

/*
**  Permedia 2 Texture Read Registers
*/

typedef struct {
#if BIG_ENDIAN == 1
    unsigned32 TCoeff :      8;
    unsigned32 Pad1 :        7;
    unsigned32 SwapT :       1;
    unsigned32 SCoeff :      8;
    unsigned32 Pad0 :        7;
    unsigned32 SwapS :       1;
#else
    unsigned32 SwapS :       1;
    unsigned32 Pad0 :        7;
    unsigned32 SCoeff :      8;
    unsigned32 SwapT :       1;
    unsigned32 Pad1 :        7;
    unsigned32 TCoeff :      8;
#endif
} __Permedia2TextureReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                7;
  unsigned32 PackedData:          1;
  unsigned32 pad1:                6;
  unsigned32 FilterMode:          1;
  unsigned32 Height:              4;
  unsigned32 Width:               4;
  unsigned32 pad0:                4;
  unsigned32 TWrapMode:           2;
  unsigned32 SWrapMode:           2;
  unsigned32 Enable:              1;
} __Permedia2TextureReadModeFmat;
#else
typedef struct {
  unsigned32 Enable:              1;
  unsigned32 SWrapMode:           2;
  unsigned32 TWrapMode:           2;
  unsigned32 pad0:                4;
  unsigned32 Width:               4;
  unsigned32 Height:              4;
  unsigned32 FilterMode:          1;
  unsigned32 pad1:                6;
  unsigned32 PackedData:          1;
  unsigned32 pad2:                7;
} __Permedia2TextureReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:             10;
  unsigned32 TexelSize:         3;
  unsigned32 pad1:              1;
  unsigned32 SubPatchMode:      1;
  unsigned32 WindowOrigin:      1;
  unsigned32 pad0:              7;
  unsigned32 PackedPP:          9;
} __Permedia2TextureMapFormatFmat;
#else
typedef struct {
  unsigned32 PackedPP:          9;
  unsigned32 pad0:              7;
  unsigned32 WindowOrigin:      1;
  unsigned32 SubPatchMode:      1;
  unsigned32 pad1:              1;
  unsigned32 TexelSize:         3;
  unsigned32 pad2:             10;
} __Permedia2TextureMapFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   22;
  unsigned32 SpanFormat:              1;
  unsigned32 AlphaMap:                2;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 ColorOrder:              1;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 TextureFormat:           4;
} __Permedia2TextureDataFormatFmat;
#else
typedef struct {
  unsigned32 TextureFormat:           4;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 ColorOrder:              1;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 AlphaMap:                2;
  unsigned32 SpanFormat:              1;
  unsigned32 pad0:                   22;
} __Permedia2TextureDataFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __Permedia2TexelLUTAddressFmat, __Permedia2TexelLUTID;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __Permedia2TexelLUTAddressFmat, __Permedia2TexelLUTID;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              1;
  unsigned32 Access:            1;
  unsigned32 pad1:              6;
  unsigned32 Addr:             24;
} __Permedia2TextureBaseAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad1:              6;
  unsigned32 Access:            1;
  unsigned32 pad0:              1;
} __Permedia2TextureBaseAddressFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2RawDataFmat[2];

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:             8;
  unsigned32 V:                 8;
  unsigned32 U:                 8;
  unsigned32 Y:                 8;
} __Permedia2TexelYUVFmat;
#else
typedef struct {
  unsigned32 Y:                 8;
  unsigned32 U:                 8;
  unsigned32 V:                 8;
  unsigned32 Alpha:             8;
} __Permedia2TexelYUVFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           20;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 LUTOffset:       8;
  unsigned32 DirectIndex:     1;
  unsigned32 Enable:          1;
} __Permedia2TexelLUTModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 DirectIndex:     1;
  unsigned32 LUTOffset:       8;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 pad0:           20;
} __Permedia2TexelLUTModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TCoeff:            8;
  unsigned32 pad1:              7;
  unsigned32 SwapT:             1;
  unsigned32 SCoeff:            8;
  unsigned32 pad0:              7;
  unsigned32 SwapS:             1;
} __Permedia2Interp0Fmat;
#else
typedef struct {
  unsigned32 SwapS:             1;
  unsigned32 pad0:              7;
  unsigned32 SCoeff:            8;
  unsigned32 SwapT:             1;
  unsigned32 pad1:              7;
  unsigned32 TCoeff:            8;
} __Permedia2Interp0Fmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             24;
  unsigned32 Offset:            8;
} __Permedia2TexelLUTIndexFmat;
#else
typedef struct {
  unsigned32 Offset:            8;
  unsigned32 pad0:             24;
} __Permedia2TexelLUTIndexFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             15;
  unsigned32 Count:             9;
  unsigned32 Index:             8;
} __Permedia2TexelLUTTransferFmat;
#else
typedef struct {
  unsigned32 Index:             8;
  unsigned32 Count:             9;
  unsigned32 pad0:             15;
} __Permedia2TexelLUTTransferFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Valid:             1;
  unsigned32 pad0:              7;
  unsigned32 Address:          24;
} __Permedia2TextureIDFmat;
#else
typedef struct {
  unsigned32 Address:          24;
  unsigned32 pad0:              7;
  unsigned32 Valid:             1;
} __Permedia2TextureIDFmat;
#endif

typedef __Permedia2ColorFmat __Permedia2AlphaMapUpperBoundFmat;
typedef __Permedia2ColorFmat __Permedia2AlphaMapLowerBoundFmat;

/*
**  Permedia 2 YUV-REG Registers
*/

typedef __Permedia2ColorFmat __Permedia2ChromaUpperBoundFmat;
typedef __Permedia2ColorFmat __Permedia2ChromaLowerBoundFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           26;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 RejectTexel:     1;
  unsigned32 TestData:        1;
  unsigned32 TestMode:        2;
  unsigned32 Enable:          1;
} __Permedia2YUVModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 TestMode:        2;
  unsigned32 TestData:        1;
  unsigned32 RejectTexel:     1;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 pad0:           26;
} __Permedia2YUVModeFmat;
#endif

/*
**  Permedia 2 Localbuffer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           15;
  unsigned32 Stencil:         1;
  unsigned32 Depth:          16;
} __Permedia2LBDataFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 Stencil:         1;
  unsigned32 pad0:           15;
} __Permedia2LBDataFmat;
#endif

typedef __Permedia2LBDataFmat __Permedia2LBWriteDataFmat;
typedef __Permedia2LBDataFmat __Permedia2LBSourceDataFmat;
typedef __Permedia2LBDataFmat __Permedia2LBCancelWriteFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           28;
  unsigned32 StencilWidth:    2;
  unsigned32 DepthWidth:      2;
} __Permedia2LBFormatFmat;
#else
typedef struct {
  unsigned32 DepthWidth:      2;
  unsigned32 StencilWidth:    2;
  unsigned32 pad0:           28;
} __Permedia2LBFormatFmat;
#endif

typedef __Permedia2LBFormatFmat __Permedia2LBReadFormatFmat;
typedef __Permedia2LBFormatFmat __Permedia2LBWriteFormatFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 12;
  unsigned32 PatchMode:             1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              2;
  unsigned32 pad0:                  5;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PackedPP:              9;
} __Permedia2LBReadModeFmat;
#else
typedef struct {
  unsigned32 PackedPP:              9;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 pad0:                  5;
  unsigned32 DataType:              2;
  unsigned32 WindowOrigin:          1;
  unsigned32 PatchMode:             1;
  unsigned32 pad1:                 12;
} __Permedia2LBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           12;
  unsigned32 PatchMode:       1;
  unsigned32 WindowOrigin:    1;
  unsigned32 pad0:            9;
  unsigned32 PackedPP:        9;
} __Permedia2LBWriteConfigFmat;
#else
typedef struct {
  unsigned32 PackedPP:        9;
  unsigned32 pad0:            9;
  unsigned32 WindowOrigin:    1;
  unsigned32 PatchMode:       1;
  unsigned32 pad1:           12;
} __Permedia2LBWriteConfigFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2LBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 WriteEnable:     1;
} __Permedia2LBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:     1;
  unsigned32 pad0:           31;
} __Permedia2LBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            8;
  unsigned32 Addr:           24;
} __Permedia2LBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:           24;
  unsigned32 pad0:            8;
} __Permedia2LBAddressFmat;
#endif

typedef __Permedia2LBAddressFmat __Permedia2LBWindowBaseFmat;
typedef __Permedia2LBAddressFmat __Permedia2LBSourceOffsetFmat;
typedef __Permedia2LBAddressFmat __Permedia2LBWriteBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 Stencil:         1;
} __Permedia2LBStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:         1;
  unsigned32 pad0:           31;
} __Permedia2LBStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           16;
  unsigned32 Depth:          16;
} __Permedia2LBDepthFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 pad0:           16;
} __Permedia2LBDepthFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              31;
  unsigned32 Data:               1;
} __Permedia2StencilFmat;
#else
typedef struct {
  unsigned32 Data:               1;
  unsigned32 pad0:              31;
} __Permedia2StencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              16;
  unsigned32 Data:              16;
} __Permedia2DepthFmat;
#else
typedef struct {
  unsigned32 Data:              16;
  unsigned32 pad0:              16;
} __Permedia2DepthFmat;
#endif

/*
**  Permedia 2 Depth and Stencil Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad1:                 13;
  unsigned32 LBUpdateSource:        1;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 pad0:                  3;
} __Permedia2WindowFmat;
#else
typedef struct {
  unsigned32 pad0:                  3;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 LBUpdateSource:        1;
  unsigned32 pad1:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad2:                 13;
} __Permedia2WindowFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 15;
  unsigned32 WriteMask:             1;
  unsigned32 pad1:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad0:                  7;
  unsigned32 ReferenceValue:        1;
} __Permedia2StencilDataFmat;
#else
typedef struct {
  unsigned32 ReferenceValue:        1;
  unsigned32 pad0:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad1:                  7;
  unsigned32 WriteMask:             1;
  unsigned32 pad2:                 15;
} __Permedia2StencilDataFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                17;
  unsigned32 StencilSource:        2;
  unsigned32 CompareFunction:      3;
  unsigned32 SFail:                3;
  unsigned32 DPFail:               3;
  unsigned32 DPPass:               3;
  unsigned32 UnitEnable:           1;
} __Permedia2StencilModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:           1;
  unsigned32 DPPass:               3;
  unsigned32 DPFail:               3;
  unsigned32 SFail:                3;
  unsigned32 CompareFunction:      3;
  unsigned32 StencilSource:        2;
  unsigned32 pad0:                17;
} __Permedia2StencilModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              25;
  unsigned32 CompareMode:        3;
  unsigned32 NewDepthSource:     2;
  unsigned32 WriteMask:          1;
  unsigned32 UnitEnable:         1;
} __Permedia2DepthModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:         1;
  unsigned32 WriteMask:          1;
  unsigned32 NewDepthSource:     2;
  unsigned32 CompareMode:        3;
  unsigned32 pad0:              25;
} __Permedia2DepthModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              15;
  signed32 Z:                   17;
} __Permedia2ZUFmat;
#else
typedef struct {
  signed32 Z:                   17;
  unsigned32 pad0:              15;
} __Permedia2ZUFmat;
#endif

typedef __Permedia2ZUFmat __Permedia2ZStartUFmat;
typedef __Permedia2ZUFmat __Permedia2dZdxUFmat;
typedef __Permedia2ZUFmat __Permedia2dZdyDomUFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Z:                 11;
  unsigned32 pad0:              21;
} __Permedia2ZLFmat;
#else
typedef struct {
  unsigned32 pad0:              21;
  unsigned32 Z:                 11;
} __Permedia2ZLFmat;
#endif

typedef __Permedia2ZLFmat __Permedia2ZStartLFmat;
typedef __Permedia2ZLFmat __Permedia2dZdxLFmat;
typedef __Permedia2ZLFmat __Permedia2dZdyDomLFmat;

/*
**  Permedia 2 Framebuffer Registers
*/

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __Permedia2FBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __Permedia2FBAddressFmat;
#endif

typedef __Permedia2FBAddressFmat __Permedia2FBBaseAddressFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBPixelOffsetFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBSourceOffsetFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBWindowBaseFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBWriteBaseFmat;
typedef __Permedia2FBAddressFmat __Permedia2FBSourceBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 TexelInhibit:           1;
  unsigned32 WindowOrigin:           1;
  unsigned32 DataType:               1;
  unsigned32 pad0:                   4;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 PackedPP:               9;
} __Permedia2FBReadModeFmat;
#else
typedef struct {
  unsigned32 PackedPP:               9;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 pad0:                   4;
  unsigned32 DataType:               1;
  unsigned32 WindowOrigin:           1;
  unsigned32 TexelInhibit:           1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __Permedia2FBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct { 
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 pad1:                   1;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad0:                   7;
  unsigned32 PackedPP:               9;
} __Permedia2FBWriteConfigFmat;
#else
typedef struct { 
  unsigned32 PackedPP:               9;
  unsigned32 pad0:                   7;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad1:                   1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __Permedia2FBWriteConfigFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             29;
  unsigned32 PixelSize:         3;
} __Permedia2FBPixelFmat;
#else
typedef struct {
  unsigned32 PixelSize:         3;
  unsigned32 pad1:             29;
} __Permedia2FBPixelFmat;
#endif

typedef __Permedia2FBPixelFmat __Permedia2FBReadPixelFmat;
typedef __Permedia2FBPixelFmat __Permedia2FBWritePixelFmat;

typedef __Permedia2UnsignedIntegerFmat __Permedia2FBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             28;
  unsigned32 UpLoadData:        1;
  unsigned32 pad0:              2;
  unsigned32 UnitEnable:        1;
} __Permedia2FBWriteModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 pad0:              2;
  unsigned32 UpLoadData:        1;
  unsigned32 pad1:             28;
} __Permedia2FBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             28;
  signed32 RelativeOffset:      3;
  unsigned32 DataPacking:       1;
} __Permedia2FBPackedDataModeFmat;
#else
typedef struct {
  unsigned32 DataPacking:       1;
  signed32 RelativeOffset:      3;
  unsigned32 pad0:             28;
} __Permedia2FBPackedDataModeFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2FBFmat;

typedef __Permedia2FBFmat __Permedia2FBColorFmat;
typedef __Permedia2FBFmat __Permedia2FBDataFmat;
typedef __Permedia2FBFmat __Permedia2FBSourceDataFmat;

typedef __Permedia2UnsignedIntegerFmat __Permedia2FBHardwareWriteMaskFmat;
typedef __Permedia2UnsignedIntegerFmat __Permedia2FBBlockColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 10;
  unsigned32 Offset:               22;
} __Permedia2TextureDownloadOffsetFmat;
#else
typedef struct {
  unsigned32 Offset:               22;
  unsigned32 pad0:                 10;
} __Permedia2TextureDownloadOffsetFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                         22;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 LogicOpEnable:               1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModeReadSource:        1;
} __Permedia2ConfigFmat;
#else
typedef struct {
  unsigned32 FBReadModeReadSource:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 LogicOpEnable:               1;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 pad:                         22;
} __Permedia2ConfigFmat;
#endif

/*
**  Permedia 2 Dither Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad0:                  2;
  unsigned32 ForceAlpha:            2;
  unsigned32 DitherMethod:          1;
  unsigned32 ColorOrder:            1;
  unsigned32 YOffset:               2;
  unsigned32 XOffset:               2;
  unsigned32 ColorFormat:           4;
  unsigned32 DitherEnable:          1;
  unsigned32 UnitEnable:            1;
} __Permedia2DitherModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 DitherEnable:          1;
  unsigned32 ColorFormat:           4;
  unsigned32 XOffset:               2;
  unsigned32 YOffset:               2;
  unsigned32 ColorOrder:            1;
  unsigned32 DitherMethod:          1;
  unsigned32 ForceAlpha:            2;
  unsigned32 pad0:                  2;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad1:                 15;
} __Permedia2DitherModeFmat;
#endif

/*
**  Permedia 2 Logic Ops and WriteMask Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   26;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 LogicalOp:               4;
  unsigned32 LogicalOpEnable:         1;
} __Permedia2LogicalOpModeFmat;
#else
typedef struct {
  unsigned32 LogicalOpEnable:         1;
  unsigned32 LogicalOp:               4;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 pad0:                   26;
} __Permedia2LogicalOpModeFmat;
#endif

typedef __Permedia2FBFmat __Permedia2FBWriteDataFmat;
typedef __Permedia2FBFmat __Permedia2FBSoftwareWriteMaskFmat;

/*
**  Permedia 2 Host Out Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                16;
  unsigned32 Remainder:            2;
  unsigned32 Statistics:           2;
  unsigned32 Synchronization:      2;
  unsigned32 Color:                2;
  unsigned32 Stencil:              2;
  unsigned32 Depth:                2;
  unsigned32 Passive:              2;
  unsigned32 Active:               2;
} __Permedia2FilterModeFmat;
#else
typedef struct {
  unsigned32 Active:               2;
  unsigned32 Passive:              2;
  unsigned32 Depth:                2;
  unsigned32 Stencil:              2;
  unsigned32 Color:                2;
  unsigned32 Synchronization:      2;
  unsigned32 Statistics:           2;
  unsigned32 Remainder:            2;
  unsigned32 pad0:                16;
} __Permedia2FilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                26;
  unsigned32 Spans:                1;
  unsigned32 CompareFunction:      1;
  unsigned32 PassiveSteps:         1;
  unsigned32 ActiveSteps:          1;
  unsigned32 StatType:             1;
  unsigned32 Enable:               1;
} __Permedia2StatisticModeFmat;
#else
typedef struct {
  unsigned32 Enable:               1;
  unsigned32 StatType:             1;
  unsigned32 ActiveSteps:          1;
  unsigned32 PassiveSteps:         1;
  unsigned32 CompareFunction:      1;
  unsigned32 Spans:                1;
  unsigned32 pad0:                26;
} __Permedia2StatisticModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 InterruptEnable:      1;
  unsigned32 pad0:                31;
} __Permedia2SyncFmat;
#else
typedef struct {
  unsigned32 pad0:                31;
  unsigned32 InterruptEnable:      1;
} __Permedia2SyncFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __Permedia2MinRegionFmat,
  __Permedia2MaxRegionFmat,
  __Permedia2MinHitRegionFmat,
  __Permedia2MaxHitRegionFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __Permedia2MinRegionFmat,
  __Permedia2MaxRegionFmat,
  __Permedia2MinHitRegionFmat,
  __Permedia2MaxHitRegionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 30;
  unsigned32 BusyFlag:              1;
  unsigned32 PickFlag:              1;
} __Permedia2PickResultFmat;
#else
typedef struct {
  unsigned32 PickFlag:              1;
  unsigned32 BusyFlag:              1;
  unsigned32 pad0:                 30;
} __Permedia2PickResultFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 12;
  unsigned32 screenbase:           20;
} __Permedia2SuspendUntilFrameBlankFmat;
#else
typedef struct {
  unsigned32 screenbase:           20;
  unsigned32 pad0:                 12;
} __Permedia2SuspendUntilFrameBlankFmat;
#endif

typedef __Permedia2UnsignedIntegerFmat __Permedia2ResetPickResultFmat;

#if BIG_ENDIAN == 1
typedef struct {
    unsigned32 pad:                31;
    unsigned32 value:               1;
} __Permedia2PCITextureCacheFmat;
#else
typedef struct {
    unsigned32 value:               1;
    unsigned32 pad:                31;
} __Permedia2PCITextureCacheFmat;
#endif

typedef __Permedia2PCITextureCacheFmat __Permedia2PCIReadTextureCacheFmat;
typedef __Permedia2PCITextureCacheFmat __Permedia2PCIWriteTextureCacheFmat;

#endif /* P2REG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\patnfill.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: patnfill.c
*
* Contains all the pattern fill routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"

//-----------------------------Note--------------------------------------------
//
// A Note on brushes
//
// Out cached brushes are 64x64.  Here is the reason.  The minimum brush
// size that we can use as a pattern is 32.
//
// Now, we need to be able to offset the pattern when rendering in x and y
// by as much as 7 pixels in either direction.  The P2
// hardware does not have a simple x/Y pattern offset mechanism.  Instead
// we are forced to offset the origin by offsetting the base address of the
// pattern.  This requires that we store in memory a pattern that is 
// 39 pixels wide.  However, the stride still needs to be acceptable to the
// texture address generation hardware.  The next valid stride is 64.
//
// That's why we have 64x64 pattern brushes in our cache.
//
// Note also that we over do it when caching duplicating the brush to fill
// up the entire 64x64 even though we only use 39x39.  We might change
// this in the near future.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// VOID vMonoOffset(GFNPB* ppb)
//
// Update the offset to be used in the area stipple unit. We do this for a
// mono brush which is realized in the hardware but whose alignment has simply
// changed. This avoids a full scale realization.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  prbrush-----Pointer to the RBrush structure
//  pptlBrush---Pointer to pointer brush structure
//
//-----------------------------------------------------------------------------
VOID
vMonoOffset(GFNPB* ppb)
{
    PPDev   ppdev = ppb->ppdev;
    
    DWORD   dwMode;
    POINTL* pptlBrush = ppb->pptlBrush;
    RBrush* prb = ppb->prbrush;

    PERMEDIA_DECL;

    DBG_GDI((6, "vMonoOffset started"));

    //
    // Construct the AreaStippleMode value. It contains the pattern size,
    // the offset for the brush origin and the enable bit. Remember the
    // offset so we can later check if it changes and update the hardware.
    // Remember the mode so we can do a mirrored stipple easily.
    //
    prb->ptlBrushOrg.x = pptlBrush->x;
    prb->ptlBrushOrg.y = pptlBrush->y;
    
    dwMode = __PERMEDIA_ENABLE
           | AREA_STIPPLE_XSEL(__PERMEDIA_AREA_STIPPLE_32_PIXEL_PATTERN)
           | AREA_STIPPLE_YSEL(__PERMEDIA_AREA_STIPPLE_8_PIXEL_PATTERN)
           | AREA_STIPPLE_MIRROR_X
           | AREA_STIPPLE_XOFF(8 - (prb->ptlBrushOrg.x & 7))
           | AREA_STIPPLE_YOFF(8 - (prb->ptlBrushOrg.y & 7));

    prb->areaStippleMode = dwMode;

    DBG_GDI((7, "setting new area stipple offset to %d, %d",
             8 - (prb->ptlBrushOrg.x & 7), 8 - (prb->ptlBrushOrg.y & 7)));

    ULONG* pBuffer;

    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagAreaStippleMode;
    pBuffer[1] = dwMode;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

}// vMonoOffset()

//-----------------------------------------------------------------------------
//
// VOID vPatRealize(GFNPB* ppb)
//
// This routine transfers an 8x8 pattern to off-screen display memory, and
// duplicates it to make a 32x32 cached realization which is then used by
// vPatFill.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  prbrush-----Pointer to the RBrush structure
//
//-----------------------------------------------------------------------------
VOID
vPatRealize(GFNPB* ppb)
{
    PDev*       ppdev = ppb->ppdev;
    RBrush*     prb = ppb->prbrush; // Points to brush realization structure
    BrushEntry* pbe = prb->pbe;
    
    BYTE*       pcSrc;
    LONG        lNextCachedBrush;
    LONG        lTemp;
    LONG        lPelSize;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;

//    VALIDATE_GDI_CONTEXT;

    DBG_GDI((6, "vPatRealize started"));

    if ( (pbe == NULL) || (pbe->prbVerify != prb) )
    {
        //
        // Mono brushes are realized into the area stipple unit. For this we
        // have a set of special BRUSHENTRYs, one for each board.
        //
        if ( prb->fl & RBRUSH_2COLOR )
        {
            //
            // 1 BPP patten
            //
            DBG_GDI((7, "loading mono brush into cache"));
            pbe = &ppdev->abeMono;
            pbe->prbVerify = prb;
            prb->pbe = pbe;
        }
        else
        {
            //
            // We have to allocate a new off-screen cache brush entry for
            // the brush
            //
            lNextCachedBrush = ppdev->lNextCachedBrush; // Get the next index
            pbe = &ppdev->abe[lNextCachedBrush];        // Get the brush entry

            //
            // Check if this index is out of the total brush stamps cached
            // If yes, rotate to the 1st one
            //
            lNextCachedBrush++;
            if ( lNextCachedBrush >= ppdev->cBrushCache )
            {
                lNextCachedBrush = 0;
            }

            //
            // Reset the next brush to be allocated
            //
            ppdev->lNextCachedBrush = lNextCachedBrush;

            //
            // Update our links:
            //
            pbe->prbVerify = prb;
            prb->pbe = pbe;
            DBG_GDI((7, "new cache entry allocated for color brush"));
        }// Get cached brush entry depends on its color depth
    }// If the brush is not cached

    //
    // We're going to load mono patterns into the area stipple and set the
    // start offset to the brush origin. WARNING: we assume that we are
    // running little endian. I believe this is always true for NT.
    //
    if ( prb->fl & RBRUSH_2COLOR )
    {
        //
        // 1 BPP patten
        //
        DWORD*  pdwSrc = &prb->aulPattern[0];

        //
        // This function loads the stipple offset into the hardware. We also
        // call this function on its own if the brush is realized but its
        // offset changes. In that case we don't have to go through a complete
        // realize again.
        //
        ppb->prbrush = prb;

        (*ppdev->pgfnMonoOffset)(ppb);
        
        DBG_GDI((7, "area stipple pattern:"));
        
        InputBufferReserve(ppdev, 16, &pBuffer);

        for ( lTemp = 0; lTemp < 8; ++lTemp, ++pdwSrc )
        {
            pBuffer[0] = __Permedia2TagAreaStipplePattern0 + lTemp;
            pBuffer[1] = *pdwSrc;
            pBuffer += 2;
        }

        InputBufferCommit(ppdev, pBuffer);
        
        DBG_GDI((7, "area stipple downloaded. vPatRealize done"));

        return;
    }// 1 BPP case

    lPelSize = ppdev->cPelSize;
    pcSrc = (BYTE*)&prb->aulPattern[0];        // Copy from brush buffer


    InputBufferReserve(ppdev, 12 + 65, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  pbe->ulPixelOffset;
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] =  PM_FBREADMODE_PARTIAL(ppdev->ulBrushPackedPP);
    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] =   __PERMEDIA_DISABLE;

    pBuffer[6] = __Permedia2TagRectangleOrigin;
    pBuffer[7] = 0;
    pBuffer[8] = __Permedia2TagRectangleSize;
    pBuffer[9] = (8 << 16) | 8;
	pBuffer[10] = __Permedia2TagRender;
    pBuffer[11] = __RENDER_RECTANGLE_PRIMITIVE
                | __RENDER_SYNC_ON_HOST_DATA
                | __RENDER_INCREASE_Y
                | __RENDER_INCREASE_X;

	pBuffer += 12;

    *pBuffer++ = (63 << 16) | __Permedia2TagColor;
    
    switch( lPelSize )
    {
        case 0:
            for ( lTemp = 0; lTemp < 64; ++lTemp )
            {
                *pBuffer++ =  pcSrc[lTemp];
            }
            break;

        case 1:    
            for ( lTemp = 0; lTemp < 64; ++lTemp )
            {
                *pBuffer++ =  ((USHORT *) pcSrc)[lTemp];
            }
            break;

        case 2:
            for ( lTemp = 0; lTemp < 64; ++lTemp )
            {
                *pBuffer++ =  ((ULONG *) pcSrc)[lTemp];
            }
            break;
    }

    InputBufferCommit(ppdev, pBuffer);


    // 
    // 012   We now have an 8x8 colour-expanded copy of
    //  the pattern sitting in off-screen memory,
    // 5       represented here by square '0'.
    //        
    //         We're now going to expand the pattern to
    //         64x64 by repeatedly copying larger rectangles
    //         in the indicated order, and doing a 'rolling'
    //         blt to copy vertically.
    //        
    // 

    InputBufferReserve(ppdev, 36, &pBuffer);

    pBuffer[0] = __Permedia2TagFBReadMode;
    pBuffer[1] = PM_FBREADMODE_PARTIAL(ppdev->ulBrushPackedPP)
               | __FB_READ_SOURCE;
    pBuffer[2] = __Permedia2TagStartXDom;
    pBuffer[3] =  INTtoFIXED(8);
    pBuffer[4] = __Permedia2TagStartXSub;
    pBuffer[5] =  INTtoFIXED(16);
    pBuffer[6] = __Permedia2TagFBSourceOffset;
    pBuffer[7] =  -8;
    pBuffer[8] = __Permedia2TagRender;
    pBuffer[9] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer[10] = __Permedia2TagStartXDom;
    pBuffer[11] =  INTtoFIXED(16);
    pBuffer[12] = __Permedia2TagStartXSub;
    pBuffer[13] =  INTtoFIXED(32);
    pBuffer[14] = __Permedia2TagFBSourceOffset;
    pBuffer[15] =  -16;
    pBuffer[16] = __Permedia2TagRender;
    pBuffer[17] =  __RENDER_TRAPEZOID_PRIMITIVE;
    
    pBuffer[18] = __Permedia2TagStartXDom;
    pBuffer[19] =  INTtoFIXED(32);
    pBuffer[20] = __Permedia2TagStartXSub;
    pBuffer[21] =  INTtoFIXED(64);
    pBuffer[22] = __Permedia2TagFBSourceOffset;
    pBuffer[23] =  -32;
    pBuffer[24] = __Permedia2TagRender;
    pBuffer[25] =  __RENDER_TRAPEZOID_PRIMITIVE;
    
    //
    // Now rolling copy downward.
    //
    pBuffer[26] = __Permedia2TagStartXDom;
    pBuffer[27] =  INTtoFIXED(0);
    pBuffer[28] = __Permedia2TagStartY;
    pBuffer[29] =  INTtoFIXED(8);
    pBuffer[30] = __Permedia2TagFBSourceOffset;
    pBuffer[31] =  -(CACHED_BRUSH_WIDTH << 3);
    pBuffer[32] = __Permedia2TagCount;
    pBuffer[33] =  CACHED_BRUSH_HEIGHT - 8;
    pBuffer[34] = __Permedia2TagRender;
    pBuffer[35] =  __RENDER_TRAPEZOID_PRIMITIVE;

	pBuffer += 36;

	InputBufferCommit(ppdev, pBuffer);

}// vPatRealize()

//-----------------------------------------------------------------------------
//
// VOID vMonoPatFill(GFNPB* ppb)
//
// Fill a series of rectangles with a monochrome pattern previously loaded
// into the area stipple unit. If bTransparent is false we must do each
// rectangle twice, inverting the stipple pattern in the second go.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  ucFgRop3----Foreground Logic OP for the fill
//  ucBgRop3----Background Logic OP for the fill
//  prbrush-----Pointer to the RBrush structure
//  pptlBrush---Structure for brush origin
//  
//-----------------------------------------------------------------------------
VOID
vMonoPatFill(GFNPB* ppb)
{
    PPDev           ppdev = ppb->ppdev;
    Surf*           psurf = ppb->psurfDst;

    RBrush*         prb = ppb->prbrush;
    POINTL*         pptlBrush = ppb->pptlBrush;
    BrushEntry*     pbe = prb->pbe;             // Brush entry
    RECTL*          pRect = ppb->pRects;        // List of rectangles to be
                                                // filled in relative
                                                // coordinates
    ULONG*      pBuffer;
    
    DWORD           dwColorMode;
    DWORD           dwColorReg;
    DWORD           dwLogicMode;
    DWORD           dwReadMode;
    LONG            lNumPass;
    LONG            lNumRects;                  // Can't be zero
//    ULONG           ulBgLogicOp = ulRop3ToLogicop(ppb->ucBgRop3);
    ULONG           ulBgLogicOp = ulRop3ToLogicop(ppb->ulRop4 >> 8);
                                                // Not used (unless the brush
                                                // has a mask, in which case it
                                                // is the background mix mode)
//    ULONG           ulFgLogicOp = ulRop3ToLogicop(ppb->ucFgRop3);
    ULONG           ulFgLogicOp = ulRop3ToLogicop(ppb->ulRop4 & 0xFF);
                                                // Hardware mix mode
                                                // (foreground mix mode if
                                                // the brush has a mask)
    ULONG           ulBgColor = prb->ulBackColor;
    ULONG           ulFgColor = prb->ulForeColor;
    ULONG           ulCurrentFillColor;
    ULONG           ulCurrentLogicOp;

    PERMEDIA_DECL;
    
    DBG_GDI((6, "vMonoPatFill called: %d rects. ulRop4 = %x",
             ppb->lNumRects, ppb->ulRop4));
//    DBG_GDI((6, "ulFgLogicOp = 0x%x, ulBgLogicOp = 0x%x",
//             ulFgLogicOp, ulBgLogicOp));

    DBG_GDI((6, "ulFgColor 0x%x, ulBgColor 0x%x", ulFgColor, ulBgColor));

    //
    // If anything has changed with the brush we must re-realize it. If the
    // brush has been kicked out of the area stipple unit we must fully realize
    // it. If only the alignment has changed we can simply update the alignment
    // for the stipple.
    //
    if ( (pbe == NULL) || (pbe->prbVerify != prb) )
    {
        DBG_GDI((7, "full brush realize"));
        (*ppdev->pgfnPatRealize)(ppb);
    }
    else if ( (prb->ptlBrushOrg.x != pptlBrush->x)
            ||(prb->ptlBrushOrg.y != pptlBrush->y) )
    {
        DBG_GDI((7, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppb);
    }

    //
    // We get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.
    //
    if ( ((ulFgLogicOp == K_LOGICOP_AND) && (ulFgColor == ppdev->ulWhite))
       ||((ulFgLogicOp == K_LOGICOP_XOR) && (ulFgColor == 0)) )
    {
        DBG_GDI((7, "Set FgLogicOp to NOOP"));
        ulFgLogicOp = K_LOGICOP_NOOP;        
    }

    //
    // Same for background
    //
    if ( ((ulBgLogicOp == K_LOGICOP_AND) && (ulBgColor == ppdev->ulWhite))
       ||((ulBgLogicOp == K_LOGICOP_XOR) && (ulBgColor == 0)) )
    {
        DBG_GDI((7, "Set BgLogicOp to NOOP"));
        ulBgLogicOp = K_LOGICOP_NOOP;
    }

    //
    // Try to do the background as a solid fill. lNumPass starts at 1 rather
    // than 2 because we want to do all comparisons with zero. This is faster.
    // We also do a trick with its value to avoid an extra WAIT_FIFO on the
    // first pass.
    //
    if ( (ulBgLogicOp == K_LOGICOP_COPY)
       &&(ulFgLogicOp == K_LOGICOP_COPY) )
    {
        DBG_GDI((7, "FgLogicOp and BgLogicOp are COPY"));

        //
        // For PatCopy case, we can use solid fill to fill the background first
        // Note: we do not need to set FBWindowBase, it will be set by
        // the solid fill
        //
        ppb->solidColor = ulBgColor;
        (*ppdev->pgfnSolidFill)(ppb);

        //
        // We've done the background so we only want to go round the stipple
        // loop once. So set the lNumPass counter up for only one loop and set
        // the ulCurrentLogicOp and color to the foreground values.
        //
        lNumPass           = 0;
        ulCurrentFillColor = ulFgColor;
        ulCurrentLogicOp   = ulFgLogicOp;

        //
        // Do this here in case the solid fill changed the packing.
        //

// brh not needed
//        P2_DEFAULT_FB_DEPTH;
    }
    else
    {
        //
        // For non-PATCOPY cases, we have to do 2 passes. Fill the background
        // first and then fill the foreground
        //
        lNumPass           = 1;
        ulCurrentFillColor = ulBgColor;
        ulCurrentLogicOp   = ulBgLogicOp;

        //
        // Note: In this case, dxDom, dXSub and dY are initialised to 0, 0,
        // and 1, so we don't need to re-load them here. But we need to set
        // WindowBase here
        //

        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagFBWindowBase;
        pBuffer[1] =   psurf->ulPixOffset;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }// if-else for LOGICOP_COPY case

    //
    // Do 2 passes loop or single loop depends on "lNumPass"
    //
    while ( TRUE )
    {
        if ( ulCurrentLogicOp != K_LOGICOP_NOOP )
        {
            dwReadMode  = psurf->ulPackedPP;

            if ( ulCurrentLogicOp == K_LOGICOP_COPY )
            {
                DBG_GDI((7, "Current logicOP is COPY"));
                dwColorReg  = __Permedia2TagFBWriteData;
                dwColorMode = __PERMEDIA_DISABLE;
                dwLogicMode = __PERMEDIA_CONSTANT_FB_WRITE;
            }
            else
            {
                DBG_GDI((7, "Current logicOP is NOT-COPY"));
                dwColorReg  = __Permedia2TagConstantColor;
                dwColorMode = __COLOR_DDA_FLAT_SHADE;
                dwLogicMode = P2_ENABLED_LOGICALOP(ulCurrentLogicOp);
                dwReadMode |= LogicopReadDest[ulCurrentLogicOp];
            }

            //
            // On the bg fill pass, we have to invert the sense of the
            // download bits. On the first pass, lNumPass == 1; on the second
            // pass, lNumPass == 0, so we get our WAIT_FIFO sums correct!!
            //
            InputBufferReserve(ppdev, 10, &pBuffer);

            if ( lNumPass > 0 )
            {
                pBuffer[0] = __Permedia2TagAreaStippleMode;
                pBuffer[1] = (prb->areaStippleMode
                           | AREA_STIPPLE_INVERT_PAT);
                pBuffer += 2;

            }

            pBuffer[0] = __Permedia2TagColorDDAMode;
            pBuffer[1] =   dwColorMode;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] =     dwReadMode;
            pBuffer[4] = __Permedia2TagLogicalOpMode;
            pBuffer[5] =  dwLogicMode;

            pBuffer[6] = dwColorReg,
            pBuffer[7] = ulCurrentFillColor;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            //
            // Fill rects one by one
            //
            lNumRects = ppb->lNumRects;

            while ( TRUE )
            {
                DBG_GDI((7, "mono pattern fill to rect (%d,%d) to (%d,%d)",
                        pRect->left,
                        pRect->top,
                        pRect->right,
                        pRect->bottom));

                InputBufferReserve(ppdev, 12, &pBuffer);

                //
                // Render the rectangle
                //
                pBuffer[0] = __Permedia2TagStartXDom;
                pBuffer[1] =  pRect->left << 16;
                pBuffer[2] = __Permedia2TagStartXSub;
                pBuffer[3] =  pRect->right << 16;
                pBuffer[4] = __Permedia2TagStartY;
                pBuffer[5] =  pRect->top << 16;
                pBuffer[6] = __Permedia2TagdY;
                pBuffer[7] =  1 << 16;
                pBuffer[8] = __Permedia2TagCount;
                pBuffer[9] =  pRect->bottom - pRect->top;

                pBuffer[10] = __Permedia2TagRender;
                pBuffer[11] = __RENDER_TRAPEZOID_PRIMITIVE
                           |__RENDER_AREA_STIPPLE_ENABLE;

                pBuffer += 12;

                InputBufferCommit(ppdev, pBuffer);

                if ( --lNumRects == 0 )
                {
                    break;
                }

                pRect++;
            }// loop through all the rectangles

            //
            // Reset our pixel values.
            //
            InputBufferReserve(ppdev, 2, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] =  __PERMEDIA_DISABLE;

            pBuffer += 2;

            InputBufferCommit(ppdev, pBuffer);

            //
            // We must reset the area stipple mode for the foreground pass. if
            // there's no foreground pass we must reset it anyway.
            //
            if ( lNumPass > 0 )
            {
                InputBufferReserve(ppdev, 2, &pBuffer);

                pBuffer[0] = __Permedia2TagAreaStippleMode;
                pBuffer[1] =  prb->areaStippleMode;

                pBuffer += 2;

                InputBufferCommit(ppdev, pBuffer);
            }
        }// if ( ulCurrentLogicOp != K_LOGICOP_NOOP )

        if ( --lNumPass < 0 )
        {
            break;
        }

        //
        // We need to the 2nd pass. So reset the rectangle info, color mode
        // and logicop status
        //
        pRect              = ppb->pRects;
        ulCurrentFillColor = ulFgColor;
        ulCurrentLogicOp   = ulFgLogicOp;
    }// Loop through all the passes

    if ( dwColorMode != __PERMEDIA_DISABLE )
    {
        InputBufferReserve(ppdev, 2, &pBuffer);

        //
        // Restore ColorDDAMode
        //
        pBuffer[0] = __Permedia2TagColorDDAMode;
        pBuffer[1] =  __PERMEDIA_DISABLE;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

    DBG_GDI((6, "vMonoPatFill returning"));

}// vMonoPatFill()

//-----------------------------------------------------------------------------
//
// VOID vPatFill(GFNPB* ppb)
//
// Function to fill a set of rectangles with a given pattern. Colored patterns
// only. Monochrome patterns are handled in a different routine. This routine
// only handles patterns which were not rotated in memory and which have been
// replicated in X to cope with different alignments.
//
// Parameter block arguments
//
//  ppdev-------Valid
//  lNumRects---Number of rects pointed to by pRects
//  pRects------Of destination rectangles to be filled
//  ucFgRop3----Valid Pattern fill rop3 code (source invariant)
//  pptlBrush---Origin of brush
//  pdsurfDst---Destination surface
//  prbrush-----ponter to RBRUSH
//
//-----------------------------------------------------------------------------
VOID
vPatFill(GFNPB* ppb)
{
    PPDev       ppdev = ppb->ppdev;
    LONG        lNumRects = ppb->lNumRects;
    RECTL*      prcl = ppb->pRects;
    POINTL*     pptlBrush = ppb->pptlBrush;
    Surf*       psurf = ppb->psurfDst;
    RBrush*     prbrush = ppb->prbrush;
    
    BrushEntry* pbe = prbrush->pbe;
    DWORD       dwRenderBits;    
    ULONG       ulBrushX;
    ULONG       ulBrushY;
    ULONG       ulBrushOffset;
//    ULONG       ulLogicOP = ulRop3ToLogicop(ppb->ucFgRop3);
    ULONG       ulLogicOP = ulRop3ToLogicop(ppb->ulRop4 & 0xFF);
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;

    ASSERTDD(lNumRects > 0, "vPatFill: unexpected rectangle lNumRects <= 0");

    if ( (pbe == NULL) || (pbe->prbVerify != ppb->prbrush) )
    {
        vPatRealize(ppb);
        
        pbe = prbrush->pbe;
        ASSERTDD(pbe != NULL, "vPatFill: unexpected null pattern brush entry");
    }

    dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                 | __RENDER_TEXTURED_PRIMITIVE;
    
    InputBufferReserve(ppdev, 34, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =   psurf->ulPixOffset;
    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] =  P2_ENABLED_LOGICALOP(ulLogicOP);
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    pBuffer[6] = __Permedia2TagFBWriteConfig; 
    pBuffer[7] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP)
               | LogicopReadDest[ulLogicOP];
    pBuffer[8] = __Permedia2TagFBSourceOffset;
    pBuffer[9] =  0;

    //
    // Setup the texture unit with the pattern
    //    
    pBuffer[10] = __Permedia2TagDitherMode;
    pBuffer[11] = (COLOR_MODE << PM_DITHERMODE_COLORORDER)
               | (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT)
               | (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION)
               | (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[12] = __Permedia2TagTextureAddressMode;
    pBuffer[13] = (1 << PM_TEXADDRESSMODE_ENABLE);
    pBuffer[14] = __Permedia2TagTextureColorMode;
    pBuffer[15] = (1 << PM_TEXCOLORMODE_ENABLE)
               | (0 << 4)       // RGB
               | (3 << 1);     // Copy

    
    pBuffer[16] = __Permedia2TagTextureReadMode;
    pBuffer[17] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE)
               | PM_TEXREADMODE_WIDTH(CACHED_BRUSH_WIDTH_LOG2 - 1)
               | PM_TEXREADMODE_HEIGHT(CACHED_BRUSH_HEIGHT_LOG2 - 1)
               | (1 << 1)       // repeat S 
               | (1 << 3);      // repeat T
    
    pBuffer[18] = __Permedia2TagTextureDataFormat;
    pBuffer[19] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT)
               | (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION)
               | (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[20] = __Permedia2TagTextureMapFormat;
    pBuffer[21] = (ppdev->ulBrushPackedPP)
               | (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);

//@@BEGIN_DDKSPLIT
    // TODO: use SStart and TStart to avoid having to offset the pattern using
    //       ulBrushOffset.  This will also allow us to save some space in the
    //       pattern cache (we have to make it 7 pixels wider and taller due to
    //       our need to set different origins).
//@@END_DDKSPLIT
    pBuffer[22] = __Permedia2TagSStart;
    pBuffer[23] =  0;
    pBuffer[24] = __Permedia2TagTStart;
    pBuffer[25] =  0;
    pBuffer[26] = __Permedia2TagdSdx;
    pBuffer[27] =       1 << 20;
    pBuffer[28] = __Permedia2TagdSdyDom;
    pBuffer[29] =    0;
    pBuffer[30] = __Permedia2TagdTdx;
    pBuffer[31] =       0;
    pBuffer[32] = __Permedia2TagdTdyDom;
    pBuffer[33] =    1 << 20;

    pBuffer += 34;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Render rectangles
    //
    do
    {
        //
        // Caclulate brush offset taking into account the brush origin
        // NOTE: that the texture unit places the origin of the texture
        //       at the upper left of the destination rectangle
        //
        ulBrushX = (prcl->left - ppb->pptlBrush->x) & 7;
        ulBrushY = (prcl->top - ppb->pptlBrush->y) & 7;
        ulBrushOffset = pbe->ulPixelOffset 
                      + ulBrushX
                      + (ulBrushY * CACHED_BRUSH_WIDTH);

        InputBufferReserve(ppdev, 12, &pBuffer);

        pBuffer[0] = __Permedia2TagTextureBaseAddress;
        pBuffer[1] =  ulBrushOffset;
        pBuffer[2] = __Permedia2TagStartXDom;
        pBuffer[3] =  INTtoFIXED(prcl->left);
        pBuffer[4] = __Permedia2TagStartXSub;
        pBuffer[5] =  INTtoFIXED(prcl->right);
        pBuffer[6] = __Permedia2TagStartY;
        pBuffer[7] =  INTtoFIXED(prcl->top);
        pBuffer[8] = __Permedia2TagCount;
        pBuffer[9] =  (prcl->bottom - prcl->top);
        pBuffer[10] = __Permedia2TagRender;
        pBuffer[11] =  dwRenderBits;

        pBuffer += 12;

        InputBufferCommit(ppdev, pBuffer);

        prcl++;    

    } while (--lNumRects != 0);

    //
    // Restore defaults
    //
    InputBufferReserve(ppdev, 8, &pBuffer);

    pBuffer[0] = __Permedia2TagTextureAddressMode;
    pBuffer[1] = (0 << PM_TEXADDRESSMODE_ENABLE);
    pBuffer[2] = __Permedia2TagTextureColorMode;
    pBuffer[3] =  (0 << PM_TEXCOLORMODE_ENABLE);
    pBuffer[4] = __Permedia2TagDitherMode;
    pBuffer[5] =  (0 << PM_DITHERMODE_ENABLE);
    pBuffer[6] = __Permedia2TagTextureReadMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;

    pBuffer += 8;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((6, "vPatternFillRects done"));
}// vPatFill
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\permedia.c ===
/******************************Module*Header*********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: Permedia.c
*
* Content:     This module implements basic access to the Permedia chip and
*              DMA transport. It shows also how to implement synchronization
*              between a display driver and the miniport interrupt by using
*              a shared buffer.
*
*              
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#define ALLOC_TAG ALLOC_TAG_EP2P
//----------------------------------------------------------------------------
// 
//  here some notes to the transport of data to the Permedia Fifo
//  via standard CPU writes or DMA:
//
//  The Permedia 2 chip allows to download data via three methods:
//      1. program registers by writing once to a specific address
//      2. writing an address and a data tag to a special area on the chip
//      3. writing an address and a data tag to a DMA buffer, then
//          download via DMA
//
//  The third method is preferred, because the CPU writes fastest to memory
//  and the DMA does not stall the CPU. Also many commands can be queued 
//  in a buffer while the graphic processor continues to render 
//  independently. Methods one and two need to read the space in the Input
//  Fifo before data can be written to the Fifo. The disconnect mode of the 
//  chip should not be used, because it can stall the CPU in PCI Disconnect/Retry
//  cycles, where the CPU is not even able to acknoledge an interrupt.
//  On the other hand writing to a DMA buffer introduces a latency compared
//  to write directly to the chip registers. The more data is queued in the
//  DMA buffer, the higher will be the latency. 
//
//  Methods one and two force the CPU to access the chip, which costs more 
//  PCI/AGP bus bandwidth than a DMA burst. Also sequential writes using
//  method one are less efficient, because only accesses to consecutive
//  addresses can be combined to a burst. 
//  The special FIFO area on the chip which is used for method two is 2kb
//  wide and can be written by using a memory copy. These copies can be 
//  combined to bursts by the PCI-Bridge. On processors implementing writeback
//  caches also normal writes to this area are combined to bursts. 
//  (in this driver the "Fifo" memory area on the 
//  chip is not marked as write combined, because writes to the Fifo
//  need to preserve the order). Also the data 
//  format which is written to the chip is exactly the same as in the DMA case. 
//  For that reason a very simple fallback mechanism can be implemented in case
//  the DMA doesn't work on the target system. This could be due to low memory,
//  problems in sharing interrupts, incompatible PCI devices etc.  
//
//  here is a typical piece of code sending some data to the chip:
//  
//  RESERVEDMAPTR(2);     //  wait until two entries are left in Fifo
//  LD_INPUT_FIFO(__Permedia2TagFogMode,0);    // write data        
//  LD_INPUT_FIFO(__Permedia2TagScissorMode,0);
//  COMMITDMAPTR();       //  commit write pointer for next DMA flush
//  FLUSHDMA();           //  do the actual flush (optional)
//
//  Here is a brief description of the DMA memory model:
//
//  There is one huge DMA buffer. It is organized as a ring and is typically
//  between 32kb and 256kb big. There are three main pointers  and one helper
//  handling the DMA operation. They reside in the shared memory section
//  (nonpaged) of the interrupt handler and the display driver.      
//
//
//            pulDMAPrevStart;        // start address of previous DMA
//            pulDMANextStart;        // start address of next DMA
//            pulDMAWritePos;         // address of current write pointer
//
//            pulDMAWriteEnd;         // helper address for reserve function
//
//  In the idle case all three pointers have the same value. In the above sample
//  the write pointer is incremented by two and the execute command would start
//  a 2 command long DMA and setting NextStart to the current value of WritePos and
//  PrevStart to the previous NextStart. Since there can only be one DMA active
//  at a time, a check is necessary if subsequent DMAs have finished before 
//  starting a new one. As long as there are no unfinished DMAs pending, the
//  current implementation does not use interrupts to save CPU time.
//  In the case there is still a DMA pending, a mechanism for flushing the buffer
//  is necessary without stalling the CPU. Interrupts are enabled in this case to 
//  ensure the buffer flush. The interrupt handler in the miniport can also access
//  the current pointer positions in the shared memory area. Updates to these
//  pointers have to be done carefully and synchronization between the interrupt 
//  thread and the display driver thread is necessary for some operations.
//  On multiprocessor systems, special care has to be taken to handle cases where
//  both CPUs access the shared memory area at the same time.
//
//  The access to the shared memory area is secured by calls to
//  InterlockedExchange on a variable in this area. Pointer updates like
//  the "CommitDMAPtr", which are only done one at a time by one thread
//  need not to be secured (as long as they are atomic)
//  Since the call to InterlockedExchange in the kernel
//  is also very expensive, different versions of the FlushDMA function are 
//  provided for single processor and multiprocessor environments.
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//  here are some hints of how to vary parameters of the CPermedia class:
//
//      the DMA buffer size can be changed between
//      8kb and 256kb by setting:
//
//      #define DMA_BUFFERSIZE   0x40000 // set size between 8kb and 256kb
//
//      The 256kb allocation limit is set by VideoPortGetCommonBuffer.
//      Also the Permedia2 can only transfer 256 kb in one piece.
//      On the Alpha processor we have a limit of 8kb, because some alpha 
//      machines cannot handle DMAs which pass a 8kb page limit.
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//  on x86 machines we need to call InterlockedExchange in ntoskrnl, but 
//  the display driver is only allowed to import EngXXX functions. So the 
//  VideoPort maps the function for us and we call it directly. On other 
//  platforms InterlockedExchange is implemented as inline. (in fact we 
//  are calling VideoPortInterlockedExchange)
//
#if defined(_X86_)
#define InterlockedExchange(a,b) (*pP2dma->pInterlockedExchange)(a, b)
#endif


//----------------------------------------------------------------------------
//
//  vFree()
//
//  frees allocated DMA buffer, instance count to DMA buffer will be 
//  decremented by one. if usage counts gets down to zero, 
//  the DMA buffer(s) will be freed.
//
//----------------------------------------------------------------------------

VOID vFree(P2DMA *pP2dma)
{
    ULONG   MagicNum;

    pP2dma->uiInstances--;
    if (pP2dma->uiInstances==0)
    {
        ASSERTDD(pP2dma->bEnabled == FALSE,
                 "vFree: Trying to free enabled DMA");

        if (pP2dma->pSharedDMABuffer != NULL)
        {
            FreeDMABuffer(pP2dma->hDriver, pP2dma->pSharedDMABuffer);
        }

        if (pP2dma->pEmulatedDMABuffer != NULL)
        {
            ENGFREEMEM(pP2dma->pEmulatedDMABuffer);
        }

        // Back to zeroed state retaining magic number
        MagicNum = pP2dma->ICB.ulMagicNo;
        RtlZeroMemory(pP2dma, sizeof(P2DMA));
        pP2dma->ICB.ulMagicNo = MagicNum;
    }
}

//----------------------------------------------------------------------------
//
//  bInitializeP2DMA
//
//  Initialize chip registers for use with display driver and decide if we
//  will use DMA. DMA will only be used if:
//      - the acceleration level is zero (full acc.)
//      - the miniport can map at least 8kb of DMA memory for us
//      - we get the receipt from the IRQ handler after starting a DMA
//      - x86 only: if we get the pointer to the InterlockedExchange function
//          in the videoport
//
//  TODO: parameters
//
//----------------------------------------------------------------------------

BOOL bInitializeP2DMA(P2DMA *pP2dma,
                      HANDLE hDriver, 
                      ULONG *pChipBase, 
                      DWORD dwAccelLevel,
                      BOOL NewReference
                     )
{
    ASSERTDD(pP2dma->bEnabled == FALSE,
                "bInitializeP2DMA: DMA already enabled");

    if (NewReference)
    {
        // increment usage count
        // we rely here on the fact that the videport initializes the shared
        // memory section to zero at start of day

        pP2dma->uiInstances++;

        if (pP2dma->uiInstances == 1)
        {
            ASSERTDD(pP2dma->pSharedDMABuffer == NULL,
                     "Shared DMA Buffer already allocated");
            ASSERTDD(pP2dma->pEmulatedDMABuffer == NULL,
                     "Emulated DMA Buffer already allocated");
        }
    }
    else
    {
        ASSERTDD(pP2dma->uiInstances != 0, "bInitializeP2DMA: DMA hasn't been initialized");
    }

    // save pointers to Permedia 2 registers for later use
    //
    pP2dma->pCtrlBase   = pChipBase+CTRLBASE/sizeof(ULONG);
    pP2dma->pGPFifo     = pChipBase+GPFIFO/sizeof(ULONG);

    DISPDBG((5, "Initialize: pCtrlBase=0x%p\n", pP2dma->pCtrlBase));
    DISPDBG((5, "Initialize: pGPFifo=0x%p\n", pP2dma->pGPFifo));

    BOOL bUseDMA=FALSE;

    // read number of processors we are running on:
    // If we are on a multiprocessing environment we have to take special care
    // about the synchronization of the interrupt 
    // service routine and the display driver
    
    ULONG ulNumberOfProcessors = 1; // Init to 1 by default.
    if(!g_bOnNT40)
        EngQuerySystemAttribute(EngNumberOfProcessors,
            (ULONG *)&ulNumberOfProcessors);
    DISPDBG((1,"running on %ld processor machine", 
        ulNumberOfProcessors));

    //
    // Allow DMA initialization only at full acceleration level (0) on NT5.0
    // and when the magic number of the miniport is the same as ours
    // Otherwise the miniport could use a different version of data structures
    // where the synchronization would probably fail. The magic no. is the 
    // first entry in the shared memory data structure.
    //
    if ( dwAccelLevel==0 && 
        (pP2dma->ICB.ulMagicNo==P2_ICB_MAGICNUMBER) &&
        !g_bOnNT40)
    {
        bUseDMA=TRUE;
    }

    pP2dma->hDriver=hDriver;

    //
    // On x86 machines the InterlockedExchange routine is implemented different
    // in the single- and multiprocessor versions of the kernel. So we have to
    // make sure we call the same function as the interrupt service routine in 
    // the miniport.
    // The miniport returns us a pointer to his InterlockedExchange function, 
    // which is implemented as __fastcall. Otherwise the lock could also be 
    // implemented using an x86 assembler xchg instruction, which is 
    // multiprocessor safe.
    //
    // On the Alpha architecture the compiler generates inline code for 
    // InterlockedExchange and the pointer to this function is not needed.
    //
#if defined(_X86_)
    // get pointer to InterlockedExchange in kernel
    pP2dma->pInterlockedExchange=
        (PInterlockedExchange) GetPInterlockedExchange(hDriver);
    if (pP2dma->pInterlockedExchange==NULL)
    {
        bUseDMA=FALSE;
    }
#endif

    // set DMA control status to default
    //
    WRITE_CTRL_REG(PREG_DMACONTROL,0);

    //  disable all interrupts
    //
    WRITE_CTRL_REG(PREG_INTENABLE, 0);

    // We turn the register on by default, so no entries written to the Fifo can
    // be lost. But the code checks the number of available entries anyway,
    // because when the CPU ends up in a PCI Disconnect-Retry cycle because of an
    // Fifo overflow, it would not even allow an interrupt to come through.
    WRITE_CTRL_REG(PREG_FIFODISCON, DISCONNECT_INPUT_FIFO_ENABLE);

    pP2dma->bDMAEmulation=FALSE;

    pP2dma->lDMABufferSize=0;

    pP2dma->ICB.pDMAActualBufferEnd = 
    pP2dma->ICB.pDMAWriteEnd =
    pP2dma->ICB.pDMAPrevStart=
    pP2dma->ICB.pDMANextStart=
    pP2dma->ICB.pDMAWritePos = NULL;
    pP2dma->ICB.pDMABufferEnd = 
    pP2dma->ICB.pDMABufferStart=NULL;

    //
    //  the following code first tries to allocate a reasonably sized DMA 
    //  buffer, does some initialization and fires off a DMA transfer to see 
    //  if the systems responds as expected. If the system doesn't, it falls 
    //  back to DMA emulation.
    //
    if (bUseDMA) 
    {
        //
        // preset flush and Check function pointers first
        //

//@@BEGIN_DDKSPLIT
#if !MULTITHREADED
//@@END_DDKSPLIT
        if (ulNumberOfProcessors==1)
        {
            pP2dma->pgfnFlushDMA= vFlushDMA;
            pP2dma->pgfnCheckEOB= vCheckForEOB;
        } else
//@@BEGIN_DDKSPLIT
#endif !MULTITHREADED
//@@END_DDKSPLIT
        {   
            pP2dma->pgfnFlushDMA= vFlushDMAMP;
            pP2dma->pgfnCheckEOB= vCheckForEOBMP;
        }

        // Allocate the DMA buffer shared with videoport
        // if we haven't previously allocated one.
        if (pP2dma->pSharedDMABuffer == NULL)
        {
            // allocate a buffer between 8kb and 256kb
            pP2dma->lSharedDMABufferSize = DMACMDSIZE;

            //
            //  allocate the DMA buffer in the videoport
            //
            if (AllocateDMABuffer(  pP2dma->hDriver, 
                                    &pP2dma->lSharedDMABufferSize, 
                                    &pP2dma->pSharedDMABuffer,
                                    &pP2dma->ICB.liDMAPhysAddr))
            {
                // for now we limit DMA Buffer size on alpha to 8kb, because
                // of hardware problems on some Miata machines
#if defined(_ALPHA_)
                ASSERTDD(pP2dma->lSharedDMABufferSize<=0x2000,
                         "DMA Buffer too big for alpha, fix constants!");
#endif
                if (pP2dma->lSharedDMABufferSize < DMACMDMINSIZE)
                {
                    DISPDBG((0,"allocated %ld bytes for DMA, not enough! No DMA!", 
                             pP2dma->lSharedDMABufferSize));

                    FreeDMABuffer(  pP2dma->hDriver, 
                                    pP2dma->pSharedDMABuffer);

                    pP2dma->pSharedDMABuffer = NULL;
                }
            }
            else
            {
                DISPDBG((0,"couldn't allocate memory for DMA"));
                pP2dma->pSharedDMABuffer = NULL;
            }
        }

        // Make sure we have a shared DMA buffer
        if (pP2dma->pSharedDMABuffer == NULL)
        {
            bUseDMA=FALSE;
        }
        else
        {
            // we always do "ULONG" arithmetics in the DMA routines
            pP2dma->lDMABufferSize=pP2dma->lSharedDMABufferSize/sizeof(ULONG);

            pP2dma->ICB.ulControl=0;

            pP2dma->ICB.pDMABufferStart = pP2dma->pSharedDMABuffer;
            pP2dma->ICB.pDMAActualBufferEnd = 
            pP2dma->ICB.pDMABufferEnd = 
                pP2dma->ICB.pDMABufferStart+
                pP2dma->lDMABufferSize;

            pP2dma->ICB.pDMAWriteEnd =
                pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=
            pP2dma->ICB.pDMANextStart=
            pP2dma->ICB.pDMAWritePos =
                pP2dma->ICB.pDMABufferStart;


            // check if we get an interrupt...
            // clear the flags before we check for a DMA
            WRITE_CTRL_REG( PREG_ERRORFLAGS, 0xffffffffl);

            //
            // clear DMA, VSync and Error interrupt flags
            //
            WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_DMA|
                                           PREG_INTFLAGS_VS|
                                           PREG_INTFLAGS_ERROR);
            //
            //  enable DMA interrupts
            //
            WRITE_CTRL_REG( PREG_INTENABLE, PREG_INTFLAGS_DMA);

            BOOL bIRQsOk=FALSE;
            DWORD dwTimeOut=5;

            // send a small sequence and see if we get a response 
            // by the interrupt handler
            //
            pP2dma->bEnabled = TRUE;

            PULONG pTmp=ReserveDMAPtr(pP2dma,10);
            LD_INPUT_FIFO(__Permedia2TagDeltaMode, 0);
            LD_INPUT_FIFO(__Permedia2TagColorDDAMode, 0);
            LD_INPUT_FIFO(__Permedia2TagScissorMode, 0);
            LD_INPUT_FIFO(__Permedia2TagTextureColorMode, 0);
            LD_INPUT_FIFO(__Permedia2TagFogMode, 0);
            CommitDMAPtr(pP2dma,pTmp);
            vFlushDMAMP(pP2dma);

            pP2dma->bEnabled = FALSE;

            //
            //  The videoport IRQ service routine marks ulControl
            //  on a DMA Interrupt
            //
            while (!(pP2dma->ICB.ulControl & DMA_INTERRUPT_AVAILABLE))
            {
                // wait for some Vsyncs here, then continue
                // 
                if (READ_CTRL_REG( PREG_INTFLAGS) & PREG_INTFLAGS_VS)
                {
                    WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_VS);

                    if (--dwTimeOut==0) 
                        break;
                }
            } 

            // interrupt service is ok if the IRQ handler marked the flag
            //
            bIRQsOk=pP2dma->ICB.ulControl & DMA_INTERRUPT_AVAILABLE;

            if (!bIRQsOk)
            {
                // disable IRQs and go back to emulation...
                // 
                WRITE_CTRL_REG( PREG_INTENABLE, 0);
                bUseDMA=FALSE;

                pP2dma->lDMABufferSize=0;

                pP2dma->ICB.pDMAActualBufferEnd = 
                pP2dma->ICB.pDMAWriteEnd =
                pP2dma->ICB.pDMAPrevStart=
                pP2dma->ICB.pDMANextStart=
                pP2dma->ICB.pDMAWritePos = NULL;
                pP2dma->ICB.pDMABufferEnd = 
                pP2dma->ICB.pDMABufferStart=NULL;

                DISPDBG((0,"no interrupts available...no DMA available"));
            }
            else
            {
                // VS IRQs can be turned off for now.
                // but enable DMA and Error interrupts
                pP2dma->ulIntFlags=PREG_INTFLAGS_DMA|PREG_INTFLAGS_ERROR;
                WRITE_CTRL_REG(PREG_INTENABLE, pP2dma->ulIntFlags);
                WRITE_CTRL_REG(PREG_INTFLAGS, PREG_INTFLAGS_ERROR);

                DISPDBG((2,"allocated %ld bytes for DMA, interrupts ok", 
                    pP2dma->lDMABufferSize*4));
            }

        }

    }

    if (!bUseDMA)
    {
        // DMA didn't work, then try to allocate memory for DMA emulation
        pP2dma->pgfnFlushDMA= vFlushDMAEmulation;
        pP2dma->pgfnCheckEOB= vCheckForEOBEmulation;

        if (pP2dma->pEmulatedDMABuffer == NULL)
        {
            pP2dma->lEmulatedDMABufferSize=DMACMDMINSIZE;

            pP2dma->pEmulatedDMABuffer=
                (ULONG *)ENGALLOCMEM( 0, 
                                      pP2dma->lEmulatedDMABufferSize, 
                                      ALLOC_TAG);

            if (pP2dma->pEmulatedDMABuffer == NULL)
            {
                DISPDBG((0,"failed to run in DMA emulation mode"));
                return FALSE;
            }
        }

        DISPDBG((0,"running in DMA emulation mode"));

        pP2dma->bDMAEmulation=TRUE;

        pP2dma->lDMABufferSize = pP2dma->lEmulatedDMABufferSize/sizeof(ULONG);

        pP2dma->ICB.pDMABufferStart = pP2dma->pEmulatedDMABuffer;
        pP2dma->ICB.pDMAActualBufferEnd = 
        pP2dma->ICB.pDMABufferEnd = 
            pP2dma->ICB.pDMABufferStart+
            pP2dma->lDMABufferSize;

        pP2dma->ICB.pDMAWriteEnd = 
            pP2dma->ICB.pDMABufferEnd;
        pP2dma->ICB.pDMAPrevStart=
        pP2dma->ICB.pDMANextStart=
        pP2dma->ICB.pDMAWritePos = 
            pP2dma->ICB.pDMABufferStart;

    }

    pP2dma->bEnabled = TRUE;
    
    return TRUE;
}



//----------------------------------------------------------------------------
//
//  vSyncWithPermedia
//
//  Send a sync tag through the Permedia and make sure all pending reads and 
//  writes are flushed from the graphics pipeline. 
//
//  MUST be called before accessing the Frame Buffer directly
//
//----------------------------------------------------------------------------

VOID vSyncWithPermedia(P2DMA *pP2dma)
{ 
    PULONG pTmp;        // pointer for pTmp in macros

    ASSERTDD(pP2dma->bEnabled, "vSyncWithPermedia: not enabled");

    pTmp=ReserveDMAPtr(pP2dma,6);

    // let the filter tag walk through the whole core
    // by setting the filter mode to passthrough
    //
    LD_INPUT_FIFO(__Permedia2TagFilterMode, 0x400);
    LD_INPUT_FIFO(__Permedia2TagSync, 0L); 
    LD_INPUT_FIFO(__Permedia2TagFilterMode, 0x0); 

    CommitDMAPtr(pP2dma,pTmp);

    (pP2dma->pgfnFlushDMA)(pP2dma);

    vWaitDMAComplete(pP2dma);

    ULONG   ulSync; 

    //
    // now wait until the sync tag has walked through the
    // graphic core and shows up at the output
    //
    do { 
        if (lWaitOutputFifoReady(pP2dma)==0) break; 
        ulSync=READ_CTRL_REG(PREG_FIFOINTERFACE);
    } while (ulSync != __Permedia2TagSync); 

}


//----------------------------------------------------------------------------
//
//  vWaitDMAComplete
//
//  Flush the DMA Buffer and wait until all data is at least sent to the chip.
//  Does not wait until the graphics pipeline is idle.
//
//----------------------------------------------------------------------------

VOID vWaitDMAComplete(P2DMA *pP2dma)
{
    while ( READ_CTRL_REG(PREG_INDMACOUNT)!=0 || 
            pP2dma->ICB.pDMAWritePos!=pP2dma->ICB.pDMANextStart || 
            pP2dma->ICB.pDMAPrevStart!=pP2dma->ICB.pDMANextStart)
    {

        if (READ_CTRL_REG(PREG_INDMACOUNT)!=0) 
        {
            // stall for 1 us
            // we shouldn't access the P2 chip here too often, because
            // reading from the DMA register too often would stall an
            // ongoing DMA transfer. So we better wait for a microsecond.
            // Also we eat up less PCI bus bandwidth by polling only every
            // 1 microsecond.
            // 
            StallExecution( pP2dma->hDriver, 1);
        }
        (pP2dma->pgfnFlushDMA)(pP2dma);
    }

}


//----------------------------------------------------------------------------
//
//  vBlockLoadInputFifo
//
//  pP2dma-----shared 
//  uiTag------register tag to write the data to
//  pImage-----pointer to data
//  lWords-----number of pixels to transfer
//
//  download a block of data with lWords pixels
//  to register uiTag from buffer at pImage. The size of the source pixels
//  are DWORDS.
//
//----------------------------------------------------------------------------


VOID vBlockLoadInputFifo( P2DMA *pP2dma, ULONG uiTag, ULONG *pImage, LONG lWords)
{
    ASSERTDD(pP2dma->bEnabled, "vBlockLoadInputFifo: not enabled");
    
    while (lWords>0)
    {
        PULONG pTmp=ReserveDMAPtr(pP2dma,MAXINPUTFIFOLENGTH);
        LONG lBufferEntries=GetFreeEntries(pP2dma)-1;

        if (lWords < lBufferEntries)
        {
            lBufferEntries = lWords;
        }

        *pTmp++ = uiTag | ((lBufferEntries-1) << 16);

        lWords -= lBufferEntries;

        while (lBufferEntries--)
        {
            *pTmp++=*pImage++;
        }

        CommitDMAPtr(pP2dma,pTmp);
        (pP2dma->pgfnFlushDMA)(pP2dma);
    }
}


//----------------------------------------------------------------------------
//
//  lWaitOutputFifoReady
//
//  return---number of words ready in output fifo
//
//  Wait until some data appears at the output Fifo of the P2. Flush DMA 
//  if necessary. 
//
//----------------------------------------------------------------------------

LONG lWaitOutputFifoReady(P2DMA *pP2dma)
{
    ULONG    x=1000000L;    // equals a timeout of 1s
    ULONG   uiResult;
    while ((uiResult=READ_CTRL_REG(PREG_OUTFIFOWORDS)) == 0)
    {
        if (x-- == 0) 
        {
            // we will end up here if nothing shows up at the output
            // Usually a download operation did not provide the right
            // amount of data if we end up here
            ASSERTDD( FALSE, "chip output fifo timed out");

            break;
        }

        // Make sure we do not read from the control register too often
        // when waiting. Permanent reading from the chip can stall DMA
        // downloads
        if (READ_CTRL_REG(PREG_INDMACOUNT)!=0)
            StallExecution( pP2dma->hDriver, 1);  // stall 1us if DMA still busy
        else
            (pP2dma->pgfnFlushDMA)(pP2dma);  // make sure buffer is flushed

    }
    return uiResult;
}


//----------------------------------------------------------------------------
//
//  vFlushDMA
//
//      single processor version of FlushDMA
//
//  vFlushDMAMP
//
//      multiprocessor version of FlushDMA
//
//  vFlushDMAEmulation
//
//      buffer flush using DMA emulation, where the normal DMA doesn't work
//
//  This routine really kicks off DMAs and handles synchronization with the
//  miniport interrupt service routine.
//
//  several scenarios can happen:
//      1.) DMA is inactive, then just kick off the data currently in the 
//          buffer
//          a) WritePos > NextStart, kick off DMA
//          a) otherwise we wrap around, just flush to buffer end
//
//      2.) DMA still active, make sure interrupts are started and let
//          the interrupt handler 
//
//  The synchronization between this routine and the miniport is essential
//  for our DMA model to work on Multiprocessor machines. The display driver
//  is single threaded, but the miniport interrupt handler can be called 
//  any time and be processed by another CPU. For that reason we loop with 
//  InterlockedExchange until we get the lock. The interrupt handler behaves 
//  a bit different. Since we don't want an interrupt being stalled, it just
//  falls through doing nothing when it cannot get the lock, since then the
//  DMA start will be handled by the display driver anyway. 
//
//  For the single processor case InterlockedExchange needs not to be called.
//  A simple assignment instead of the lock is enough.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  VOID vFlushDMAMP()
//
//  multiprocessor safe version of FlushDMA. Its basically the same as the single
//  processor version, but we are calling here the expensive InterlockedExchange
//  functions to lock the shared memory section    
//
//----------------------------------------------------------------------------

VOID vFlushDMAMP(P2DMA *pP2dma)
{
    ASSERTDD(pP2dma->bEnabled, "vFlushDMAMP: not enabled");
    
    ASSERTDD(!pP2dma->bDMAEmulation, "FlushDMA called with DMA mode disabled");
    ASSERTDD(pP2dma->ICB.pDMAWritePos<=
        pP2dma->ICB.pDMABufferEnd,"Index exceeds buffer limit");
    ASSERTDD(pP2dma->ICB.pDMANextStart<=
        pP2dma->ICB.pDMABufferEnd,"NextStart exceeds buffer limit!");

    // lock the access to the shared memory section first
    while (InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,TRUE))
        ;
 
    // check if DMA channel is still busy, count is zero if not
    if (READ_CTRL_REG(PREG_INDMACOUNT)==0)
    {
        // this code is called frequently. To help the processors branch
        // prediction the most common case should be reached 
        // without a cond. jump

        if (pP2dma->ICB.pDMAWritePos>pP2dma->ICB.pDMANextStart)
        {
            // This is the most common case for DMA start
            // set Permedia 2 DMA unit to fire the DMA
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                           (pP2dma->ICB.liDMAPhysAddr.LowPart+
                            (pP2dma->ICB.pDMANextStart-
                             pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAWritePos-
                            pP2dma->ICB.pDMANextStart));

            // in this case we always continue to fill to buffer end,
            // iterate the other pointers
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMAWritePos;

            // free the shared memory lock
            InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

            return;

        } else if (pP2dma->ICB.pDMAWritePos<pP2dma->ICB.pDMANextStart)       
        {
            // wraparound case: the write pointer already wrapped around 
            // to the beginning and we finish up to the end of the buffer.
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                           (pP2dma->ICB.liDMAPhysAddr.LowPart+
                           (pP2dma->ICB.pDMANextStart-
                            pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAActualBufferEnd-
                            pP2dma->ICB.pDMANextStart));

            // reset buffer size back to full length for next round
            pP2dma->ICB.pDMAActualBufferEnd=pP2dma->ICB.pDMABufferEnd;
            
            // in this case we don't want the write pointer 
            // to catch up to last start...
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMANextStart-1;

            // iterate last and next start pointer:
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;

            // free the shared memory lock
            InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

            return;

        } else     // nothing to do
        {
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
        }

        // free the shared memory lock
        InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

        return;

    } else
    {
        // the index pointer has been passed to IRQ service routine, nothing more to do..
        // 

        // unlock shared section, 
        InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

        // now we are filling the DMA buffer faster than the hardware
        // can follow up and we want to make sure that the DMA channel
        // keeps being busy and start the interrupt handler
       
        WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_DMA);
        WRITE_CTRL_REG( PREG_INTENABLE, pP2dma->ulIntFlags );

        return;
    } 
}


//----------------------------------------------------------------------------
//
//  VOID vFlushDMA()
//
//  single processor version of FlushDMA.
//
//----------------------------------------------------------------------------

VOID vFlushDMA(P2DMA *pP2dma)
{
    ASSERTDD(pP2dma->bEnabled, "vFlushDMA: not enabled");
    ASSERTDD(!pP2dma->bDMAEmulation, "FlushDMA called with DMA mode disabled");
    ASSERTDD(pP2dma->ICB.pDMAWritePos<=
        pP2dma->ICB.pDMABufferEnd,"Index exceeds buffer limit");
    ASSERTDD(pP2dma->ICB.pDMANextStart<=
        pP2dma->ICB.pDMABufferEnd,"NextStart exceeds buffer limit!");

    // lock the access to the shared memory section first
    pP2dma->ICB.ulICBLock=TRUE;
 
    // check if DMA channel is still busy, count is zero if not
    if (READ_CTRL_REG(PREG_INDMACOUNT)==0)
    {
        // this code is called frequently. To help the processors branch
        // prediction the most common case should be reached 
        // without a cond. jump

        if (pP2dma->ICB.pDMAWritePos>pP2dma->ICB.pDMANextStart)
        {
            // This is the most common case for DMA start
            // set Permedia 2 DMA unit to fire the DMA
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                            (pP2dma->ICB.liDMAPhysAddr.LowPart+
                             (pP2dma->ICB.pDMANextStart-
                              pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAWritePos-
                            pP2dma->ICB.pDMANextStart));

            // in this case we always continue to fill to buffer end,
            // iterate the other pointers
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMAWritePos;

            // free the shared memory lock
            pP2dma->ICB.ulICBLock=FALSE;

            return;

        } else if (pP2dma->ICB.pDMAWritePos<pP2dma->ICB.pDMANextStart)       
        {
            // wraparound case: the write pointer already wrapped around 
            // to the beginning and we finish up to the end of the buffer.
            WRITE_CTRL_REG( PREG_INDMAADDRESS, (ULONG)
                           (pP2dma->ICB.liDMAPhysAddr.LowPart+
                           (pP2dma->ICB.pDMANextStart-
                            pP2dma->ICB.pDMABufferStart)*sizeof(ULONG)));
            WRITE_CTRL_REG( PREG_INDMACOUNT, (ULONG)
                           (pP2dma->ICB.pDMAActualBufferEnd-
                            pP2dma->ICB.pDMANextStart));

            // reset buffer size back to full length for next round
            pP2dma->ICB.pDMAActualBufferEnd=pP2dma->ICB.pDMABufferEnd;
            
            // in this case we don't want the write pointer 
            // to catch up to last start...
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMANextStart-1;

            // iterate last and next start pointer:
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;

            // free the shared memory lock
            pP2dma->ICB.ulICBLock=FALSE;

            return;

        } else     // nothing to do
        {
            pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
            pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMANextStart;
        }

        // free the shared memory lock
        pP2dma->ICB.ulICBLock=FALSE;

        return;

    } else
    {
        // the index pointer has been passed to IRQ service routine, nothing more to do..
        // 

        // unlock shared section, 
        pP2dma->ICB.ulICBLock=FALSE;

        // now we are filling the DMA buffer faster than the hardware
        // can follow up and we want to make sure that the DMA channel
        // keeps being busy and start the interrupt handler
       
        WRITE_CTRL_REG( PREG_INTFLAGS, PREG_INTFLAGS_DMA);
        WRITE_CTRL_REG( PREG_INTENABLE, pP2dma->ulIntFlags );

        return;
    } 
}


//----------------------------------------------------------------------------
// 
//  vFlushDMAEmulation
//
//  this version of FlushDMA emulates the DMA copy and 
//  lets the CPU copy the data
//
//----------------------------------------------------------------------------

VOID vFlushDMAEmulation(P2DMA *pP2dma)
{
    ASSERTDD(pP2dma->bEnabled, "vFlushDMAEmulation: not enabled");
    DISPDBG((10,"Emu::FlushDMA: Write: %04lx Next: %04lx Prev: %04lx End: %04lx",
        pP2dma->ICB.pDMAWritePos, pP2dma->ICB.pDMANextStart,
        pP2dma->ICB.pDMAPrevStart, pP2dma->ICB.pDMABufferEnd));
    ASSERTDD(pP2dma->bDMAEmulation, "FlushDMA called with DMA mode disabled");

    ULONG *pData=pP2dma->ICB.pDMABufferStart;
    ULONG *pDst;
    LONG   lWords=(LONG)(pP2dma->ICB.pDMAWritePos-pP2dma->ICB.pDMABufferStart);

    while (lWords > 0)
    {
        LONG lFifoSpace=(LONG)READ_CTRL_REG(PREG_INFIFOSPACE);
        if (lWords<lFifoSpace) lFifoSpace=lWords;
        lWords -= lFifoSpace;
        pDst = pP2dma->pGPFifo;
        while (lFifoSpace--)
        {
            WRITE_REGISTER_ULONG(pDst++,*pData++); 
            MEMORY_BARRIER();
        }
    }    

    pP2dma->ICB.pDMAWritePos=pP2dma->ICB.pDMANextStart=
        pP2dma->ICB.pDMAPrevStart=pP2dma->ICB.pDMABufferStart;
    pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMABufferEnd;
}

//----------------------------------------------------------------------------
//
//  bDrawEngineBusy
//
//  check if P2 is still busy drawing. 
//
//  return----  TRUE  P2 is still busy
//              FALSE P2 has finished drawing and is not busy anymore
//
//----------------------------------------------------------------------------

BOOL bDrawEngineBusy(P2DMA *pP2dma)
{
    if (READ_CTRL_REG(PREG_INDMACOUNT)!=0) return TRUE;   

    if (READ_CTRL_REG(PREG_FIFODISCON) & PREG_FIFODISCON_GPACTIVE)
    {
        return TRUE;
    }

    return FALSE;
}



//----------------------------------------------------------------------------
//
//  bInVerticalRetrace
//
//  Return----- TRUE if beam position is within current vertical sync.
//              FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL bInVerticalRetrace(PPDev ppdev)
{
    return P2_READ_CTRL_REG(PREG_LINECOUNT) < P2_READ_CTRL_REG(PREG_VBEND);
}

//----------------------------------------------------------------------------
//
//  lCurrentLine
//
//  returns current line of beam on display
//
//----------------------------------------------------------------------------

LONG lCurrentLine(PPDev ppdev)
{
    LONG lScanline=P2_READ_CTRL_REG(PREG_LINECOUNT)-P2_READ_CTRL_REG(PREG_VBEND);
    if (lScanline<0) return 0;
    return lScanline;
}

//----------------------------------------------------------------------------
//
//  vCheckFOREOB (End of Buffer)
//
//  Check if buffer end would be overrun and adjust actual buffer size.
//  The buffer size will be restored when the DMA handler passes the wrap 
//  around.
//
//----------------------------------------------------------------------------

VOID vCheckForEOBEmulation( P2DMA *pP2dma, LONG lEntries)
{
    vFlushDMAEmulation(pP2dma);
}

//
//  multiprocessor safe version of vCheckForEOB
//

VOID vCheckForEOBMP( P2DMA *pP2dma, LONG lEntries)
{
    // check for overrun condition over the buffer end:
    // if we would exceed the current buffer size, 
    // LastStart has already wrapped around (LastStart<=writepos)
    // but is not at the wraparound position
    // and the buffer size was already reset to the full size

    if (pP2dma->ICB.pDMAWritePos+lEntries >= pP2dma->ICB.pDMABufferEnd && 
        pP2dma->ICB.pDMAPrevStart<=pP2dma->ICB.pDMAWritePos &&            
        pP2dma->ICB.pDMAPrevStart!=pP2dma->ICB.pDMABufferStart)   
    {
        DISPDBG((10,"wrap condition before: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));

        while (InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,TRUE))
            ;

        if (pP2dma->ICB.pDMAWritePos==pP2dma->ICB.pDMANextStart)
        {
            // special case one:
            // NextStart equals LastStart, so we just reset Index and Next
            // to the buffer start and see if we have enough space
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;
        } else
        {
            // index exceeds buffer end on the next block, but there is
            // a DMA pending to the current position of Index. Set Buffer
            // end temporarily to the current index.
            pP2dma->ICB.pDMAActualBufferEnd = pP2dma->ICB.pDMAWritePos; 
        }

        // wrap index around and see if there are enought free entries
        pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMAPrevStart-1;
        pP2dma->ICB.pDMAWritePos=pP2dma->ICB.pDMABufferStart;

        InterlockedExchange((PLONG)&pP2dma->ICB.ulICBLock,FALSE);

        DISPDBG((10,"wrap condition after: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));
    }
    vFlushDMAMP(pP2dma);
}

VOID vCheckForEOB( P2DMA *pP2dma, LONG lEntries)
{
    // check for overrun condition over the buffer end:
    // if we would exceed the current buffer size, 
    // LastStart has already wrapped around (LastStart<=writepos)
    // but is not at the wraparound position
    // and the buffer size was already reset to the full size

    if (pP2dma->ICB.pDMAWritePos+lEntries >= pP2dma->ICB.pDMABufferEnd && 
        pP2dma->ICB.pDMAPrevStart<=pP2dma->ICB.pDMAWritePos &&            
        pP2dma->ICB.pDMAPrevStart!=pP2dma->ICB.pDMABufferStart)   
    {
        DISPDBG((10,"wrap condition before: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));

        pP2dma->ICB.ulICBLock=TRUE;

        if (pP2dma->ICB.pDMAWritePos==pP2dma->ICB.pDMANextStart)
        {
            // special case one:
            // NextStart equals LastStart, so we just reset Index and Next
            // to the buffer start and see if we have enough space
            pP2dma->ICB.pDMANextStart=pP2dma->ICB.pDMABufferStart;
        } else
        {
            // index exceeds buffer end on the next block, but there is
            // a DMA pending to the current position of Index. Set Buffer
            // end temporarily to the current index.
            pP2dma->ICB.pDMAActualBufferEnd = pP2dma->ICB.pDMAWritePos; 
        }

        // wrap index around and see if there are enought free entries
        pP2dma->ICB.pDMAWriteEnd=pP2dma->ICB.pDMAPrevStart-1;
        pP2dma->ICB.pDMAWritePos=pP2dma->ICB.pDMABufferStart;

        pP2dma->ICB.ulICBLock=FALSE;

        DISPDBG((10,"wrap condition after: %04lx %04lx %04lx", 
            pP2dma->ICB.pDMAWritePos, 
            pP2dma->ICB.pDMANextStart, 
            pP2dma->ICB.pDMAPrevStart));
    }
    vFlushDMA(pP2dma);
}

#if DBG

//----------------------------------------------------------------------------
//
//  ReserveDMAPtr
//
//  return a pointer to current position in DMA buffer. The function guarantees
//  that there are at least lEntries available in the buffer.
//  Otherwise the caller can ask GetFreeEntries and adjust the download to 
//  batch more entries. The caller MUST call CommitDMAPtr after a call to
//  to ReserveDMAPtr to readjust the Index pointer.
//
//----------------------------------------------------------------------------

ULONG *ReserveDMAPtr(P2DMA *pP2dma, const LONG lEntries)
{
    ASSERTDD(pP2dma->bEnabled, "ReserveDMAPtr: not enabled");
    ASSERTDD(pP2dma->lDBGState==0,
        "ReserveDMAPtr called, but previous called was not closed");
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ASSERTDD(pP2dma->ppdev != NULL, "ReserveDMAPtr: pP2dma->ppdev = NULL");
#endif
    ASSERTLOCK(pP2dma->ppdev, ReserveDMAPtr);
//@@END_DDKSPLIT

    pP2dma->lDBGState=2;

    while (pP2dma->ICB.pDMAWritePos+lEntries>=
           pP2dma->ICB.pDMAWriteEnd)
    {
        (*pP2dma->pgfnCheckEOB)(pP2dma,lEntries);
    }   

    if (lEntries<MAXINPUTFIFOLENGTH)
        pP2dma->pDBGReservedEntries=
            (ULONG *)(lEntries+pP2dma->ICB.pDMAWritePos);
    else
        pP2dma->pDBGReservedEntries=NULL;

    return (ULONG *)pP2dma->ICB.pDMAWritePos;  
}


//----------------------------------------------------------------------------
//
//  CommitDMAPtr
//
//  pDMAPtr----DMA buffer address to which the caller has written to.
//
//  Readjust write pointer after being reserved by ReserveDMAPtr. 
//  By committing the pointer a DMA to the committed position could already
//  be started by interrupt handler!
//
//----------------------------------------------------------------------------

VOID CommitDMAPtr(P2DMA *pP2dma,ULONG *pDMAPtr)
{
    ASSERTDD(pP2dma->bEnabled, "CommitDMAPtr: not enabled");
    ASSERTDD(pP2dma->lDBGState==2,
        "CommitDMAPtr called, but previous without calling Reserve before");
    pP2dma->lDBGState=0;
    if (pDMAPtr==NULL) return;

    pP2dma->ICB.pDMAWritePos=pDMAPtr;

    ASSERTDD(pP2dma->ICB.pDMAWritePos<=
        pP2dma->ICB.pDMABufferEnd,"CommitDMAPtr: DMA buffer overrun");

    if (pP2dma->pDBGReservedEntries!=NULL)
    {
        ASSERTDD(pP2dma->ICB.pDMAWritePos<=pP2dma->pDBGReservedEntries, 
            "reserved not enough entries in ReserveDMAPtr");
    }
}


//----------------------------------------------------------------------------
//
//  GetFreeEntries
//
//  Get free entries available for consecutive writing to the DMA buffer.
//  The maximum number of returned entries is now MAXBLKSIZE.
// 
//  returns---number of available entries in ULONGS
//
//----------------------------------------------------------------------------

LONG  GetFreeEntries(P2DMA *pP2dma)
{   
    LONG EntriesAvailable;
    ASSERTDD(pP2dma->bEnabled, "GetFreeEntries: not enabled");
    EntriesAvailable = (LONG)(pP2dma->ICB.pDMAWriteEnd - pP2dma->ICB.pDMAWritePos);
    return min(MAXBLKSIZE,EntriesAvailable);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\pmdef.h ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: pmdef.h
*
* Content:     bitfield definitions for Permedia2 registers
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifndef __pmdef__
#define __pmdef__

// Texture unit bit fields
// Texture color mode
#define PM_TEXCOLORMODE_ENABLE 0
#define PM_TEXCOLORMODE_APPLICATION 1
#define PM_TEXCOLORMODE_TEXTURETYPE 4

// Texture address mode
#define PM_TEXADDRESSMODE_ENABLE 0
#define PM_TEXADDRESSMODE_PERSPECTIVE 1
#define PM_TEXADDRESSMODE_FAST 2

// Texture map format
#define PM_TEXMAPFORMAT_PP0 0
#define PM_TEXMAPFORMAT_PP1 3
#define PM_TEXMAPFORMAT_PP2 6
#define PM_TEXMAPFORMAT_TEXELSIZE 19

// Texture data format
#define PM_TEXDATAFORMAT_ALPHAMAP_EXCLUDE 2
#define PM_TEXDATAFORMAT_ALPHAMAP_INCLUDE 1
#define PM_TEXDATAFORMAT_ALPHAMAP_DISABLE 0

#define PM_TEXDATAFORMAT_FORMAT 0
#define PM_TEXDATAFORMAT_NOALPHAPIXELS 4
#define PM_TEXDATAFORMAT_FORMATEXTENSION 6
#define PM_TEXDATAFORMAT_COLORORDER 5

// Dither unit bit fields
#define PM_DITHERMODE_ENABLE 0
#define PM_DITHERMODE_DITHERENABLE 1
#define PM_DITHERMODE_COLORFORMAT 2
#define PM_DITHERMODE_XOFFSET 6
#define PM_DITHERMODE_YOFFSET 8
#define PM_DITHERMODE_COLORORDER 10
#define PM_DITHERMODE_DITHERMETHOD 11
#define PM_DITHERMODE_FORCEALPHA 12
#define PM_DITHERMODE_COLORFORMATEXTENSION 16

// Alpha Blend unit bit fields
#define PM_ALPHABLENDMODE_ENABLE 0
#define PM_ALPHABLENDMODE_OPERATION 1
#define PM_ALPHABLENDMODE_COLORFORMAT 8
#define PM_ALPHABLENDMODE_COLORORDER 13
#define PM_ALPHABLENDMODE_BLENDTYPE 14
#define PM_ALPHABLENDMODE_COLORFORMATEXTENSION 16

// Window register
#define PM_WINDOW_LBUPDATESOURCE_LBSOURCEDATA 0
#define PM_WINDOW_LBUPDATESOURCE_REGISTERS 1

// Texture unit YUV mode
#define PM_YUVMODE_CHROMATEST_DISABLE       0
#define PM_YUVMODE_CHROMATEST_PASSWITHIN    1
#define PM_YUVMODE_CHROMATEST_FAILWITHIN    2
#define PM_YUVMODE_TESTDATA_INPUT   0
#define PM_YUVMODE_TESTDATA_OUTPUT  1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\permedia.h ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: Permedia.h
*
* Content:     various definitions for the Permedia DMA and FIFO interface
*              and the Permedia class
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __permedia__
#define __permedia__

#include "mini.h"

#define FASTCALL __fastcall

#if defined(_X86_)
typedef LONG __fastcall _InterlockedExchange( IN OUT PLONG, IN LONG);
typedef _InterlockedExchange *PInterlockedExchange;
#endif

#if defined(_ALPHA_)
extern "C" VOID  __MB(VOID);
#endif

//
//  handy typedefs for FlushDMA and CheckForEOB function pointers
//
typedef VOID (GFNFLUSHDMA)(P2DMA*);
typedef VOID (GFNCHECKEOB)(P2DMA*, LONG);

// Some macros for DirectDraw
#define IN_VRETRACE(xppdev) bInVerticalRetrace(xppdev)
#define IN_DISPLAY(xppdev)  (!IN_VRETRACE(xppdev))
#define CURRENT_VLINE(xppdev) lCurrentLine(xppdev)
#define DRAW_ENGINE_BUSY    bDrawEngineBusy(pP2dma)
#define SYNC_WITH_PERMEDIA  vSyncWithPermedia(pP2dma)

#define READ_CTRL_REG(uiReg)\
    READ_REGISTER_ULONG(&pP2dma->pCtrlBase[uiReg/sizeof(ULONG)])

#define P2_READ_CTRL_REG(uiReg)\
    READ_REGISTER_ULONG(&ppdev->pCtrlBase[uiReg/sizeof(ULONG)])

#define WRITE_CTRL_REG(uiReg, uiValue)\
{   \
    WRITE_REGISTER_ULONG(&pP2dma->pCtrlBase[uiReg/sizeof(ULONG)],uiValue); \
    MEMORY_BARRIER();\
}


// For sending permedia tags.
#define SEND_PERMEDIA_DATA(tag,data)                                    \
    LD_INPUT_FIFO(__Permedia2Tag##tag, data)

#define SEND_PERMEDIA_DATA_OFFSET(tag,data, i)  \
    LD_INPUT_FIFO(__Permedia2Tag##tag+i, data)

#define COPY_PERMEDIA_DATA(tag,data)                            \
    LD_INPUT_FIFO( __Permedia2Tag##tag, *((unsigned long*) &(data)))

#define HOLD_CMD(tag, count) ( __Permedia2Tag##tag | ((count-1) << 16))

// use macros instead of inlines for Fifo downloads.

//@@BEGIN_DDKSPLIT
#if DBG && MULTITHREADED
#define PERMEDIA_DEFS(xppdev)       \
    P2DMA *pP2dma=xppdev->pP2dma;   \
    PULONG pTmp;                    \
    if (pP2dma != NULL) { pP2dma->ppdev = xppdev; }
#else
//@@END_DDKSPLIT

#define PERMEDIA_DEFS(xppdev)  \
    P2DMA *pP2dma=xppdev->pP2dma;\
    PULONG pTmp;

//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

//----------------------------------------------------------------------------
//
//  here are the API macros for DMA transport
//
//
//  RESERVEDMAPTR(n)                // reserve n entries for DMA 
//  n=GetFreeEntries()              // get number of free entries to fill
//                                      (optional)
//  up to n LD_INPUT_FIFO  
//  COMMITDMAPTR()                 // adjust DMA buffer pointer
//
//  FLUSHDMA();
//
//----------------------------------------------------------------------------

//@@BEGIN_DDKSPLIT
#if 1

#define RESERVEDMAWORDS(n) \
{ \
    ASSERTLOCK(pP2dma->ppdev, RESERVEDMAWORDS); \
    pTmp=ReserveDMAPtr(pP2dma,n); \
}

#define RESERVEDMAPTR(n) \
{ \
    ASSERTLOCK(pP2dma->ppdev, RESERVEDMAPTR); \
    pTmp=ReserveDMAPtr(pP2dma,2*n); \
}

#else
//@@END_DDKSPLIT

#define RESERVEDMAWORDS(n) \
{    pTmp=ReserveDMAPtr(pP2dma,n);}

#define RESERVEDMAPTR(n) \
{    pTmp=ReserveDMAPtr(pP2dma,2*n);}

//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

#define COMMITDMAPTR() \
{    CommitDMAPtr(pP2dma,pTmp);}

#define GETFREEENTRIES() \
    GetFreeEntries(pP2dma)

#define FLUSHDMA()    (pP2dma->pgfnFlushDMA)(pP2dma)

// compiler does not resolve C++ inlines until use of /Ob1,
// so write inline as a real macro
#define LD_INPUT_FIFO(uiTag, uiData) \
{   *pTmp++=(uiTag);\
    *pTmp++=(uiData);\
}    

#define LD_INPUT_FIFO_DATA(uiData)    \
    *pTmp++=(uiData); 




//-----------------------------------------------------------------------------
//
// define register file of Permedia 2 chip and other chip constants
//
//-----------------------------------------------------------------------------

#define PREG_RESETSTATUS  0x0
#define PREG_INTENABLE    0x8
#define PREG_INTFLAGS     0x10
#define PREG_INFIFOSPACE  0x18
#define PREG_OUTFIFOWORDS 0x20
#define PREG_INDMAADDRESS   0x28
#define PREG_INDMACOUNT     0x30
#define PREG_ERRORFLAGS   0x38
#define PREG_VCLKCTL      0x40
#define PERMEDIA_REG_TESTREGISTER 0x48
#define PREG_APERTUREONE  0x50
#define PREG_APERTURETWO  0x58
#define PREG_DMACONTROL   0x60
#define PREG_FIFODISCON   0x68
#define PREG_FIFODISCON_GPACTIVE   0x80000000L
#define PREG_CHIPCONFIG   0x70
#define PREG_OUTDMAADDRESS 0x80
#define PREG_OUTDMACOUNT     0x88
#define PREG_AGPTEXBASEADDRESS  0x90
#define PREG_BYDMAADDRESS   0xa0
#define PREG_BYDMASTRIDE    0xb8
#define PREG_BYDMAMEMADDR   0xc0
#define PREG_BYDMASIZE      0xc8
#define PREG_BYDMABYTEMASK  0xd0
#define PREG_BYDMACONTROL   0xd8
#define PREG_BYDMACOMPLETE  0xe8
#define PREG_FIFOINTERFACE  0x2000 

#define PREG_LINECOUNT      0x3070
#define PREG_VBEND          0x3040

#define PREG_SCREENBASE      0x3000
#define PREG_SCREENBASERIGHT 0x3080
#define PREG_VIDEOCONTROL    0x3058

#define PREG_VC_STEREOENABLE 0x800
// use this for stereo
#define PREG_VC_SCREENBASEPENDING 0xc180
#define PREG_VC_RIGHTFRAME   0x2000

// for non stereo modes
// #define PREG_VC_SCREENBASEPENDING 0x080

// GP video enabled/disabled bit of VideoControl
#define PREG_VC_VIDEO_ENABLE 0x0001

#define P2_EXTERNALVIDEO  0x4000

#define CTRLBASE    0
#define COREBASE    0x8000
#define GPFIFO      0x2000

#define MAXINPUTFIFOLENGTH 0x100

//-----------------------------------------------------------------------------
//
//  various register flags
//
//-----------------------------------------------------------------------------

#define PREG_INTFLAGS_DMA   1
#define PREG_INTFLAGS_VS    0x10
#define PREG_INTFLAGS_ERROR 0x8
#define PREG_INTFLAGS_SYNC  2

//
// DisconnectControl bits
//
#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)
#define DISCONNECT_INOUT_DISABLE        0x0

//-----------------------------------------------------------------------------
//
// Size of DMA buffer. Since we use only one wraparound DMA Buffer
// with continous physical memory, it should not be too long.
// We allocate this buffer at start of day and keep it forever, unless
// somebody forces an unload of the display driver. Selecting a larger
// size makes it more likely for the call to fail.
//
// The usage counter for the DMA memory is handled in the miniport, because
// the Permedia class gets unloaded on a mode switch.
//
//-----------------------------------------------------------------------------

// DMA command buffer stream size and minimum size
#define DMACMDSIZE     DMA_BUFFERSIZE
#define DMACMDMINSIZE  0x2000L
#define MAXBLKSIZE     0x1000       // limit block transfers to 16 kb per chunk
                                    // to have a good balance between download
                                    // speed and latencies
#define ALIGNFACTOR    0x400        // alignment factor (4kb page)

//-----------------------------------------------------------------------------
//
// shared memory section of P2 interrupt driven DMA handler
//
//-----------------------------------------------------------------------------

struct _P2DMA {
    INTERRUPT_CONTROL_BLOCK ICB;

    // these are the linear Permedia base addresses of the control registers
    // and the Fifo area
    ULONG *pCtrlBase;
    ULONG *pGPFifo;

    // handle to videoport of instance
    HANDLE hDriver;

    LONG  lDMABufferSize;         // size of DMA buffer in ULONGs

    ULONG uiInstances;            // currently active driver instances using 
                                  // the shared memory

    ULONG ulIntFlags;             // cache for interrupt flag register

#if defined(_X86_)
                                  // pointer to Interlockedexchange function in
                                  // the kernel.
    PInterlockedExchange pInterlockedExchange;
#endif

    BOOL bDMAEmulation;           // remember if we run in DMA emulation

    GFNCHECKEOB*pgfnCheckEOB;     // DMA CheckEOB buffer function pointer
    GFNFLUSHDMA*pgfnFlushDMA;     // DMA FlushDMA buffer function pointer

    ULONG *pSharedDMABuffer;      // virtual address of shared DMA buffer
    LONG   lSharedDMABufferSize;  // size of shared DMA buffer in BYTEs

    ULONG *pEmulatedDMABuffer;    // address of DMA emulation buffer
    LONG   lEmulatedDMABufferSize;// size of DMA emulation buffer in BYTEs

    BOOL bEnabled;                // check if the DMA code is enabled

#if DBG
    LONG lDBGState;               // keep track of state in debug version
                                  // 0:   idle
                                  // 2:   ReserveDMAPtr was called
    LONG bDBGIgnoreAssert;
    ULONG *pDBGReservedEntries;   // pointer to which we have reserved
                                  // for debugging checks
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    PPDev ppdev;                  // For checking multithreaded semaphore
#endif
//@@END_DDKSPLIT
#endif

} ;

//-----------------------------------------------------------------------------
//
//  definitions for functions which are different in non-DMA, DMA and 
//  multiprocessing DMA cases. bInitializeP2DMA will decide which ones to use
//  and preset the function pointers.
//
//-----------------------------------------------------------------------------

VOID vFlushDMA(P2DMA *pP2dma);
VOID vFlushDMAMP(P2DMA *pP2dma);
VOID vFlushDMAEmulation(P2DMA *pP2dma);

VOID vCheckForEOB(P2DMA *pP2dma,LONG lEntries);
VOID vCheckForEOBMP(P2DMA *pP2dma,LONG lEntries);
VOID vCheckForEOBEmulation(P2DMA *pP2dma,LONG lEntries);

//-----------------------------------------------------------------------------
//
//  more helper and blockdownload functions
//
//-----------------------------------------------------------------------------

VOID vWaitDMAComplete(P2DMA *pP2dma);
LONG lWaitOutputFifoReady(P2DMA *pP2dma);
BOOL bDrawEngineBusy(P2DMA *pP2dma);
BOOL bInVerticalRetrace(PPDev ppdev);
LONG lCurrentLine(PPDev ppdev);

VOID vBlockLoadInputFifoByte (P2DMA *pP2dma, 
                              ULONG uiTag, 
                              BYTE *pImage, 
                              LONG lWords);
VOID vBlockLoadInputFifo     (P2DMA *pP2dma, 
                              ULONG uiTag,
                              ULONG *pImage, 
                              LONG lWords);

//-----------------------------------------------------------------------------
//
// Basic reserve/commit Api functions. They are provided as inlines for free 
// builds and as functions with debug checks in checked builds.
//
//-----------------------------------------------------------------------------

ULONG *ReserveDMAPtr (P2DMA *pP2dma, const LONG nEntries);
VOID   CommitDMAPtr  (P2DMA *pP2dma, ULONG *pDMAPtr);
LONG   GetFreeEntries(P2DMA *pP2dma);


//
//  completely synchronize chip here 
//

VOID vSyncWithPermedia(P2DMA *pP2dma);

//
// initialization and cleanup routines
//
BOOL bInitializeP2DMA(  P2DMA *pP2dma,
                        HANDLE hDriver, 
                        ULONG *pChipBase, 
                        DWORD dwAccelerationLevel,
                        BOOL NewReference
                      );
VOID vFree(P2DMA *pP2dma);


#if !DBG

//----------------------------------------------------------------------------
//
//  ReserveDMAPtr
//
//  return a pointer to current position in DMA buffer. The function guarantees
//  that there are at least lEntries available in the buffer.
//  Otherwise the caller can ask GetFreeEntries and adjust the download to 
//  batch more entries. The caller MUST call CommitDMAPtr after a call to
//  to ReserveDMAPtr to readjust the Index pointer.
//
//----------------------------------------------------------------------------

inline ULONG *ReserveDMAPtr(P2DMA *pP2dma,const LONG lEntries)
{
    while (pP2dma->ICB.pDMAWritePos+lEntries>=
           pP2dma->ICB.pDMAWriteEnd)
    {
        (*pP2dma->pgfnCheckEOB)(pP2dma,lEntries);
    }   

    return (ULONG *)pP2dma->ICB.pDMAWritePos;  
}


//----------------------------------------------------------------------------
//
//  CommitDMAPtr
//
//  pDMAPtr----DMA buffer address to which the caller has written to.
//
//  Readjust write pointer after being reserved by ReserveDMAPtr. 
//  By committing the pointer a DMA to the committed position could already
//  be started by interrupt handler!
//
//----------------------------------------------------------------------------

inline VOID CommitDMAPtr(P2DMA *pP2dma,ULONG *pDMAPtr)
{
    pP2dma->ICB.pDMAWritePos=pDMAPtr;
}

//----------------------------------------------------------------------------
//
//  GetFreeEntries
//
//  Get free entries available for consecutive writing to the DMA buffer.
//  The maximum number of returned entries is now MAXBLKSIZE.
// 
//  returns---number of available entries in ULONGS
//
//----------------------------------------------------------------------------

inline LONG GetFreeEntries(P2DMA *pP2dma)
{   
    LONG EntriesAvailable = (LONG)(pP2dma->ICB.pDMAWriteEnd - pP2dma->ICB.pDMAWritePos);
    return min(MAXBLKSIZE,EntriesAvailable);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\palette.c ===
/******************************Module*Header***********************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/

#include "precomp.h"
#include <math.h>
#define ALLOC_TAG ALLOC_TAG_AP2P
// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};



//-----------------------------------------------------------------------------
// BOOL bInitializePalette
//
// Initializes default palette for PDEV.
//
//-----------------------------------------------------------------------------
BOOL
bInitializePalette(PDev*    ppdev,
                   DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    ULONG           ulMask;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    DBG_GDI((7, "bInitializePalette"));

    if ( ppdev->iBitmapFormat == BMF_8BPP )
    {
        //
        // Allocate our palette:
        //

        ppal = (PALETTEENTRY*)ENGALLOCMEM(FL_ZERO_MEMORY,
                                          sizeof(PALETTEENTRY) * 256,
                                          ALLOC_TAG);

        if (ppal == NULL)
        {
            goto ReturnFalse;
        }

        ppdev->pPal = ppal;

        //
        // Generate 256 (8*8*4) RGB combinations to fill the palette
        //

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;
        
        for ( ulLoop = 256; ulLoop != 0; --ulLoop )
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        //
        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.
        //
        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            //
            // First 10
            //
            ppal[ulLoop]       = gapalBase[ulLoop];

            //
            // Last 10
            //
            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        //
        // Create handle for palette.
        //
        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*)ppal, 0, 0, 0);
    }
    else
    {              
        DBG_GDI((7, "creating True Color palette, masks rgb = 0x%x, 0x%x,0x%x",
                 ppdev->flRed, ppdev->flGreen, ppdev->flBlue));

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if ( hpal == 0 )
    {
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:
    DBG_GDI((0, "Failed bInitializePalette"));
    return(FALSE);

}// bInitializePalette()

//-----------------------------------------------------------------------------
// VOID vUninitializePalette
//
// Frees resources allocated by bInitializePalette.
//
// Note: In an error case, this may be called before bInitializePalette.
//
//-----------------------------------------------------------------------------

VOID vUninitializePalette(PDev* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        ENGFREEMEM(ppdev->pPal);
}

//-----------------------------------------------------------------------------
// BOOL bEnablePalette
//
// Initialize the hardware's 8bpp palette registers.
//
//-----------------------------------------------------------------------------

BOOL bEnablePalette(PDev* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       ulMask;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        RtlCopyMemory(pScreenClut->LookupTable, ppdev->pPal,
                      sizeof(ULONG) * 256);

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DBG_GDI((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DBG_GDI((1, "Passed bEnablePalette"));

    return(TRUE);
}

//-----------------------------------------------------------------------------
// BOOL DrvSetPalette
//
// DDI entry point for manipulating the palette.
//
//-----------------------------------------------------------------------------

BOOL DrvSetPalette(
    DHPDEV  dhpdev,
    PALOBJ* ppalo,
    FLONG   fl,
    ULONG   iStart,
    ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDev*           ppdev;
    ULONG           ulMask;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDev*) dhpdev;

    DBG_GDI((3, "DrvSetPalette called"));

    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;    
    if (ulMask != 0)
    {
        DBG_GDI((1, "DrvSetPalette: trying to set true color palette"));
        return FALSE;
    }

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DBG_GDI((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

    while(cColors--)
        pScreenClutData[cColors].Unused = 0;

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         (PVOID)pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DBG_GDI((0, "DrvSetPalette failed DeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

//-----------------------------------------------------------------------------
// BOOL bInstallGammaLUT
//
// Load a given gamma LUT into the RAMDAC and also save it in the registry.
//
//-----------------------------------------------------------------------------

BOOL
bInstallGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut)
{
    ULONG ulReturnedDataLength;
    BOOL bRet;
    PERMEDIA_DECL;

    // only do this for 16 or 32 bpp.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == P2DEPTH8))
        return FALSE;

    if (pScreenClut->NumEntries == 0)
    {
        DBG_GDI((1, "bInstallGammaLUT: Empty LUT"));
        return TRUE;
    }

    // Set palette registers.

    bRet = !EngDeviceIoControl(
                        ppdev->hDriver,
                        IOCTL_VIDEO_SET_COLOR_REGISTERS,
                        pScreenClut,
                        MAX_CLUT_SIZE,
                        NULL,
                        0,
                        &ulReturnedDataLength);
    // if we succeeded save the ramp in the registry and locally
    if (bRet)
        bRegistrySaveGammaLUT(ppdev, pScreenClut);

    return(bRet);
}        

//-----------------------------------------------------------------------------
// VOID vSetNewGammaValue
//
// Loads up a true color palette with the specified gamma correction factor.
// This is straightforward for 24 bit true color. For 15 and 16 bpp we rely
// on the miniport having enabled the palette for sparse lookup. i.e. each
// 5 or 6 bit component is shifted left to create an 8 bit component before
// the lookup.
//
// Note: the display driver shouldn't really do anything with floats or
// doubles. I restrict their use to this function which is why the gamma
// value is presented as a 16.16 fixed point number. And this function must
// be called only from within an OPELGL escape. On NT 4 FP regs are saved
// and restored for OGL escapes only.
//
//-----------------------------------------------------------------------------

VOID
vSetNewGammaValue(PPDev ppdev, ULONG ulgv)
{
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       i;
    UCHAR       gc;
    double      gv;
    double      dcol;
    PERMEDIA_DECL;

    // gamma can't be zero or we blow up
    if (ulgv == 0)
    {
        DBG_GDI((1, "can't use gamma value of zero"));
        return;
    }

    // only do this for 16 or 32 bpp.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == P2DEPTH8))
        return;

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = 256;
    pScreenClut->FirstEntry = 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    //
    // special case gamma of 1.0 so we can load the LUT at startup without
    // needing any floating point calculations.
    //
    if (ulgv == 0x10000)
    {
        for (i = 0; i < 256; ++i)
        {
            pScreenClutData[i].Red    = (UCHAR)i;
            pScreenClutData[i].Green  = (UCHAR)i;
            pScreenClutData[i].Blue   = (UCHAR)i;
            pScreenClutData[i].Unused = 0;
        }
    }
    else
    {
        // pre-work out 1/gamma
        gv = (double)(ulgv >> 16) + (double)(ulgv & 0xffff) / 65536.0;
        gv = 1.0 / gv;

        for (i = 0; i < 256; ++i)
        {
            dcol = (double)i;
            gc = (UCHAR)(255.0 * pow((dcol/255.0), gv));

            pScreenClutData[i].Red    = gc;
            pScreenClutData[i].Green  = gc;
            pScreenClutData[i].Blue   = gc;
            pScreenClutData[i].Unused = 0;
        }
    }

    if (bInstallGammaLUT(ppdev, pScreenClut))
        RtlCopyMemory(&permediaInfo->gammaLUT, pScreenClut, MAX_CLUT_SIZE);
}

//-----------------------------------------------------------------------------
// BOOL DrvIcmSetDeviceGammaRamp
//
//@@BEGIN_DDKSPLIT
// TODO: provide description.
//@@END_DDKSPLIT
//
//-----------------------------------------------------------------------------

BOOL DrvIcmSetDeviceGammaRamp(
   DHPDEV dhpdev,
   ULONG iFormat,
   LPVOID lpRamp
   )
{
    PPDev           ppdev = (PPDev) dhpdev;
    GAMMARAMP *     pramp = (GAMMARAMP *) lpRamp;
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    ULONG           i;
    ULONG           ulReturnedDataLength;
    BOOL            bRet;
    PERMEDIA_DECL;

    DBG_GDI((3, "DrvIcmSetDeviceGammaRamp called"));

    if(iFormat != IGRF_RGB_256WORDS)
        return FALSE;


    // only do this for 16 or 32 bpp. Not 15/16 for RGB640.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == P2DEPTH8)) 
        return FALSE;

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = 256;
    pScreenClut->FirstEntry = 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));
   
    for (i = 0; i < 256; ++i)
    {
        pScreenClutData[i].Red    = (UCHAR)(pramp->Red[i] >> 8);
        pScreenClutData[i].Green  = (UCHAR)(pramp->Green[i] >> 8);
        pScreenClutData[i].Blue   = (UCHAR)(pramp->Blue[i] >> 8);
        pScreenClutData[i].Unused = 0;
   }
     
    bRet = !EngDeviceIoControl(
                        ppdev->hDriver,
                        IOCTL_VIDEO_SET_COLOR_REGISTERS,
                        pScreenClut,
                        MAX_CLUT_SIZE,
                        NULL,
                        0,
                        &ulReturnedDataLength);

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\pointer.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.h
*
* This module contains all the definitions for pointer related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef __POINTER__H__
#define __POINTER__H__

//
// Some size definition
//
#define POINTER_DATA_SIZE        128    // Number of bytes to allocate for the
                                        // miniport down-loaded pointer code
                                        // working space
#define HW_INVISIBLE_OFFSET        2    // Offset from 'ppdev->yPointerBuffer'
                                        // to the invisible pointer
#define HW_POINTER_DIMENSION      64    // Maximum dimension of default
                                        // (built-in) hardware pointer
#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
                                        // to define the hardware pointer

typedef enum
{
    PTR_HW_ACTIVE   = 1,                // The hardware pointer is active and
                                        // visible
    PTR_SW_ACTIVE   = 2,                // The software pointer is active
} ;
typedef int PtrFlags;

typedef struct _PDev PDev;

//
// 64 x 64 Hardware Pointer Caching data structures
//
#define SMALL_POINTER_MEM (32 * 4 * 2)  // Bytes read for 32x32 cursor
#define LARGE_POINTER_MEM (SMALL_POINTER_MEM * 4)
                                        // Bytes read for 64x64 cursor

// Hardware workaround.  We have had to stop using the hardware pointer
// cache due to problems with changing pointer shape.  Occasionaly it
// caused the pointer to jump around on the screen.  We don't currently
// have time to work with 3Dlabs to find out how we can stop this jumpyness
// so instead we will just not use the hardware pointer cache for the time
// being.
//#define SMALL_POINTER_MAX 4             // No. of cursors in cache
#define SMALL_POINTER_MAX 1             // Hardware pointer cache workaround

#define HWPTRCACHE_INVALIDENTRY (SMALL_POINTER_MAX + 1)
                                        // Well-known value

//
// Pointer cache item data structure, there is one of these for every cached
// pointer
//
typedef struct
{
    ULONG   ptrCacheTimeStamp;          // Timestamp used for LRU cache ageing
    ULONG   ulKey;                      // iUniq value of pointer mask surface
    HSURF   hsurf;                      // hsurf of the pointer mask surface
} HWPointerCacheItemEntry;

//
// The complete cache looks like this
//
typedef struct
{
    BYTE    cPtrCacheInUseCount;        // The no. of cache items used
    ULONG   ptrCacheCurTimeStamp;       // The date stamp used for LRU stuff
    ULONG   ptrCacheData[LARGE_POINTER_MEM / 4];
                                        // The cached pointer data
    HWPointerCacheItemEntry ptrCacheItemList [SMALL_POINTER_MAX];
                                        // The cache item list
} HWPointerCache;

//
// Capabilities flags
//
// These are private flags passed to us from the Permedia2 miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the Permedia2 miniport's
// 'permedia.h'!
//
typedef enum
{
    //
    // NT4 uses the DeviceSpecificAttributes field so the low word is available
    //
    CAPS_ZOOM_X_BY2         = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2         = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_SPARSE_SPACE       = 0x00000004,   // Framebuffer is sparsely mapped
                                            // (don't allow direct access).
                                            // The machine is probably an Alpha
    CAPS_SW_POINTER         = 0x00010000,   // No hardware pointer; use
                                            // software simulation
    CAPS_TVP4020_POINTER    = 0x20000000,   // Use Permedia2 builtin pointer
    CAPS_P2RD_POINTER       = 0x80000000    // Use the 3Dlabs P2RD RAMDAC
} /*CAPS*/;

typedef int CAPS;

//
// Initializes hardware pointer or software pointer
//
BOOL    bEnablePointer(PDev* ppdev);

//
// Determine whether we can do color space double buffering in the current mode
//
BOOL    bP2RDCheckCSBuffering(PDev* ppdev);

//
// Use the pixel read mask to perform color space double buffering
//
BOOL    bP2RDSwapCSBuffers(PDev* ppdev, LONG bufNo);

//
// Stores the 15-color cursor in the RAMDAC
//
BOOL    bSet15ColorPointerShapeP2RD(PDev* ppdev, SURFOBJ* psoMask, 
                                    SURFOBJ* psoColor,
                                    LONG        x,
                                    LONG        y,
                                    LONG        xHot,
                                    LONG        yHot);

//
// Stores the 3-color cursor in the RAMDAC
//
BOOL    bSet3ColorPointerShapeP2RD(PDev*    ppdev,
                                   SURFOBJ* psoMask,
                                   SURFOBJ* psoColor,
                                   LONG     x,
                                   LONG     y,
                                   LONG     xHot,
                                   LONG     yHot);

//
// Set pointer shape for P2RD
//
BOOL    bSetPointerShapeP2RD(PDev*      ppdev,
                             SURFOBJ*   pso,
                             SURFOBJ*   psoColor,
                             XLATEOBJ*  pxlo,
                             LONG       x,
                             LONG       y,
                             LONG       xHot,
                             LONG       yHot);

//
// Set the TI TVP4020 hardware pointer shape
//
BOOL    bSetPointerShapeTVP4020(PDev*       ppdev,
                                SURFOBJ*    pso,
                                SURFOBJ*    psoColor,
                                LONG        x,
                                LONG        y,
                                LONG        xHot,
                                LONG        yHot);


//
// Determine whether we can do color space double buffering in the current mode
//
BOOL    bTVP4020CheckCSBuffering(PDev* ppdev);

//
// Set cache index
//
LONG    HWPointerCacheCheckAndAdd(HWPointerCache*   ptrCache,
                                  HSURF             hsurf,
                                  ULONG             ulKey,
                                  BOOL*             isCached);

//
// Initialise the hardware pointer cache.
//
VOID    HWPointerCacheInit(HWPointerCache* ptrCache);

//
// Hardware pointer caching functions/macros.
//
#define HWPointerCacheInvalidate(ptrCache) (ptrCache)->cPtrCacheInUseCount = 0

//
// Enable everything but hide the pointer
//
VOID    vAssertModePointer(PDev* ppdev, BOOL bEnable);

//
// Get the hardware ready to use the 3Dlabs P2RD hardware pointer.
//
VOID    vEnablePointerP2RD(PDev* ppdev);

//
// Get the hardware ready to use the TI TVP4020 hardware pointer.
//
VOID    vEnablePointerTVP4020(PDev* ppdev);

//
// Move the 3Dlabs P2RD hardware pointer.
//
VOID    vMovePointerP2RD(PDev* ppdev, LONG x, LONG y);

//
// Move the TI TVP4020 hardware pointer.
//
VOID    vMovePointerTVP4020(PDev* ppdev, LONG x, LONG y);

//
// Show or hide the 3Dlabs P2RD hardware pointer.
//
VOID    vShowPointerP2RD(PDev* ppdev, BOOL bShow);

//
// Show or hide the TI TVP4020 hardware pointer.
//
VOID    vShowPointerTVP4020(PDev* ppdev, BOOL bShow);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\precomp.h ===
/******************************Module*Header***********************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/

#define __NTDDKCOMP__

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <d3d.h>
#include <winerror.h>
#include <wingdi.h>
#include <math.h>

#ifdef __cplusplus
extern "C" { 
#endif

/*****************************************************************************\
*                                                                             *
* NT 5.0  -> NT 4.0 single binary support:                                    *
*                                                                             *
\*****************************************************************************/

// The following macros thunk the corresponding APIs to Dynamically loaded ones
// when running on NT5 or later and no-ops on NT4.  This is because on NT5+ we
// use the direct draw heap and other newly added Eng function calls which are
// not available on NT4.  All the thunks are implemented in thunks.c.  The
// macros are defined prior to including winddi.h to insure correct typing.

// NT5.0 Thunks
#define EngAlphaBlend           THUNK_EngAlphaBlend
#define EngGradientFill         THUNK_EngGradientFill
#define EngTransparentBlt       THUNK_EngTransparentBlt
#define EngMapFile              THUNK_EngMapFile
#define EngUnmapFile            THUNK_EngUnmapFile
#define EngQuerySystemAttribute THUNK_EngQuerySystemAttribute
#define EngDitherColor          THUNK_EngDitherColor
#define EngModifySurface        THUNK_EngModifySurface
#define EngQueryDeviceAttribute THUNK_EngQueryDeviceAttribute
#define HeapVidMemAllocAligned  THUNK_HeapVidMemAllocAligned
#define VidMemFree              THUNK_VidMemFree

// NT5.1 Thunks
#define EngHangNotification     THUNK_EngHangNotification


#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#ifdef __cplusplus
}
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <dmemmgr.h>
#include "dx95type.h"

// define Size for DMA Buffer.
#if defined(_ALPHA_)
#define DMA_BUFFERSIZE 0x2000
#else
#define DMA_BUFFERSIZE 0x40000
#endif


// DX7 Stereo support
#define DX7_STEREO 1
//@@BEGIN_DDKSPLIT
// for now DX7_STEREO should only be enabled in the build,
// not in the DDK, because some defs are still missing.
#define DX7_ALPHABLT 0
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT
// enable GDI testing
#define GDI_TEST 0
//@@END_DDKSPLIT

// enable memory tracking
// to find leaking memory
#define TRACKMEMALLOC 0

#include "pointer.h"
#include "brush.h"
#include "driver.h"
#include "debug.h"
#include "permedia.h"
#include "hw.h"
#include "pmdef.h"
#include "lines.h"
#include "math64.h"
#include "rops.h"
#include "registry.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\pointer.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: pointer.c
 *
 * This module contains the hardware pointer support for the display driver.
 * We also have support for color space double buffering using the RAMDAC pixel
 * read mask.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "pointer.h"
#include "tvp4020.h"
#include "p2rd.h"
#include "gdi.h"
#include "heap.h"

//
// Look-up table for masking the right edge of the given pointer bitmap:
//
BYTE gajMask[] =
{
    0x00, 0x80, 0xC0, 0xE0,
    0xF0, 0xF8, 0xFC, 0xFE,
};

UCHAR nibbleToByteP2RD[] =
{
    0x00,   // 0000 --> 00000000
    0x80,   // 0001 --> 10000000
    0x20,   // 0010 --> 00100000
    0xA0,   // 0011 --> 10100000
    0x08,   // 0100 --> 00001000
    0x88,   // 0101 --> 10001000
    0x28,   // 0110 --> 00101000
    0xA8,   // 0111 --> 10101000
    0x02,   // 1000 --> 00000010
    0x82,   // 1001 --> 10000010
    0x22,   // 1010 --> 00100010
    0xA2,   // 1011 --> 10100010
    0x0A,   // 1100 --> 00001010
    0x8A,   // 1101 --> 10001010
    0x2A,   // 1110 --> 00101010
    0xAA,   // 1111 --> 10101010
};

//-----------------------------------------------------------------------------
//
// LONG HWPointerCacheInit()
//
// Initialise the hardware pointer cache.
//
//-----------------------------------------------------------------------------
VOID
HWPointerCacheInit(HWPointerCache* ptrCache)
{
    ptrCache->cPtrCacheInUseCount = 0;
    ptrCache->ptrCacheCurTimeStamp = 0;
}// HWPointerCacheInit()

//-----------------------------------------------------------------------------
//
// 64 x 64 Hardware Pointer Caching
// --------------------------------
// The code below implements hardware independent caching of pointers. It
// maintains a cache big enough to store ONE 64x64 cursor or FOUR 32x32
// cursors. The code will work with all RAMDACs that support this form of
// caching.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// LONG HWPointerCacheCheckAndAdd()
//
// This function does a byte-by-byte comparison of the supplied pointer data
// with each pointer that is in cache, if it finds a matching one then it
// returns the index of the item in the cache (0 to 3) otherwise it adds it to
// the cache and returns the index.
//
//-----------------------------------------------------------------------------
LONG
HWPointerCacheCheckAndAdd(HWPointerCache*   ptrCache,
                          HSURF             hsurf,
                          ULONG             ulKey,
                          BOOL*             isCached)
{
    BOOL pointerIsCached = FALSE;
    LONG i, j, z;
    LONG cacheItem;

    DBG_GDI((6, "HWPointerCacheCheckAndAdd called"));

    //
    // If there are entries in the cache and they are the same format as the
    // one that we are looking for then search the cache.
    //
    if (  ptrCache->cPtrCacheInUseCount )
    {
        DBG_GDI((6, "Found entry in cache with the same format"));

        //
        // Search the cache
        //
        LONG lTotalcached = ptrCache->cPtrCacheInUseCount;

        //
        // Examine all valid entries in the cache to see if they are the same
        // as the pointer that we've been handed based on its unique key number
        // and the surface handle.
        // Note: the reason we check "hsurf" here is that it is possible that
        // two surfaces has the same iUniq number since Every time the surface
        // changes this value is incremented
        //
        for ( z = 0; !pointerIsCached && z < lTotalcached; z++ )
        {
            if ( (ulKey == ptrCache->ptrCacheItemList[z].ulKey)
               &&(hsurf == ptrCache->ptrCacheItemList[z].hsurf) )
            {
                cacheItem = z;
                pointerIsCached = TRUE;
            }
        }// loop through all the cached items
    }// Found entry in cache with the same format

    DBG_GDI((6, "Found an entry in cache (%s)",  pointerIsCached?"YES":"NO"));

    //
    // If we couldn't find an entry in the pointer cache then add one to the
    // cache.
    //
    if ( !pointerIsCached )
    {
        //
        // Add the pointer to the cache
        //
        LONG  z2;

        //
        // If there are some spare entries then allocate a free entry, otherwise
        // find the least recently used entry and use that.
        //
        if ( ptrCache->cPtrCacheInUseCount < SMALL_POINTER_MAX )
        {
            cacheItem = ptrCache->cPtrCacheInUseCount++;
        }
        else
        {
            ULONG oldestValue = 0xFFFFFFFF;

            //
            // Look for the LRU entry
            //
            for ( z2 = 0, cacheItem = 0; z2 < SMALL_POINTER_MAX; z2++ )
            {
                if ( ptrCache->ptrCacheItemList[z2].ptrCacheTimeStamp
                     < oldestValue )
                {
                    cacheItem = z2;
                    oldestValue =
                        ptrCache->ptrCacheItemList[z2].ptrCacheTimeStamp;
                }
            }
        }// Determine cacheItem

        ptrCache->ptrCacheItemList[cacheItem].ulKey = ulKey;
        ptrCache->ptrCacheItemList[cacheItem].hsurf = hsurf;
    }// If not found entry, add one

    //
    // Set the timestamp
    //
    ptrCache->ptrCacheItemList[cacheItem].ptrCacheTimeStamp
            = ptrCache->ptrCacheCurTimeStamp++;

    //
    // Set up the return value to say whether the pointer was cached and return
    // the number of the current cached position
    //
    *isCached = pointerIsCached;

    DBG_GDI((6, "HWPointerCacheCheckAndAdd finished and return item %d",
             cacheItem));
    return(cacheItem);
}// HWPointerCacheCheckAndAdd()

//-----------------------------------------------------------------------------
//
// VOID vShowPointerP2RD()
//
// Show or hide the 3Dlabs P2RD hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vShowPointerP2RD(PDev*   ppdev,
                 BOOL    bShow)
{
    ULONG cmr;
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "vShowPointerP2RD (%s)", bShow ? "on" : "off"));
    if ( bShow )
    {
        //
        // No need to sync since this case is called only if we've just
        // moved the cursor and that will already have done a sync.
        //
        P2RD_LOAD_INDEX_REG(P2RD_CURSOR_MODE, (pP2RDinfo->cursorModeCurrent | P2RD_CURSOR_MODE_ENABLED));
        P2RD_MOVE_CURSOR (pP2RDinfo->x, pP2RDinfo->y);
    }
    else
    {
        //
        // move the cursor off screen
        //
        P2RD_LOAD_INDEX_REG(P2RD_CURSOR_Y_HIGH, 0xff);
    }
}// vShowPointerP2RD()

//-----------------------------------------------------------------------------
//
// VOID vMovePointerP2RD()
//
// Move the 3Dlabs P2RD hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vMovePointerP2RD(PDev*   ppdev,
                 LONG    x,
                 LONG    y)
{
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "vMovePointerP2RD to (%d, %d)", x, y));

    pP2RDinfo->x = x;
    pP2RDinfo->y = y;

    P2RD_SYNC_WITH_PERMEDIA;
    P2RD_MOVE_CURSOR(x, y);
}// vMovePointerP2RD()

//-----------------------------------------------------------------------------
//
// BOOL bSet3ColorPointerShapeP2RD()
//
// Stores the 3-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
// cursors are supported
//
//-----------------------------------------------------------------------------
BOOL
bSet3ColorPointerShapeP2RD(PDev*    ppdev,
                           SURFOBJ* psoMask,    // defines AND and MASK bits
                                                // for cursor
                           SURFOBJ* psoColor,   // we may handle some color
                                                // cursors at some point
                           LONG     x,          // If -1, pointer should be
                                                // created hidden
                           LONG     y,
                           LONG     xHot,
                           LONG     yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE    *pjAndMask, *pj;
    ULONG   *pulColor, *pul;
    LONG    cjAndDelta, cjColorDelta;
    LONG    iRow, iCol;
    BYTE    AndBit, AndByte;
    ULONG   CI2ColorIndex, CI2ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[3];
    LONG    Index, HighestIndex = 0;
    ULONG   r, g, b;
    
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "bSet3ColorPointerShapeP2RD started"));

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if ( cx <= 32 && cy <= 32 )
    {
        //
        // 32x32 cursor : we'll cache it in cursor partition 0 and scrub the
        // old cache
        //
        cxcyCache = 32;

        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_32_3COLOR;
        pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                   | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize, 0)
                                   | P2RD_CURSOR_MODE_3COLOR;

        //
        // We don't cache color cursors
        //
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else if ( cx <= 64 && cy <= 64 )
    {
        //
        // 64x64 cursor : we'll cache it in cursor partition 0 and scrub the
        // old cache
        //
        cxcyCache = 64;

        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_64_3COLOR;
        pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize, 0)
                                | P2RD_CURSOR_MODE_3COLOR;

        //
        // We don't cache color cursors
        //
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);          // cursor is too big to fit in the hardware
    }

    //
    // work out the remaining bytes in the cache (in x and y) that will need
    // clearing
    //
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    //
    // Set-up a pointer to the 1bpp AND mask bitmap
    //
    pjAndMask = (UCHAR*)psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    //
    // Set-up a pointer to the 32bpp color bitmap
    //
    pulColor = (ULONG*)psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    //
    // Hide the pointer
    //
    vShowPointerP2RD(ppdev, FALSE);

    //
    // Load the cursor array (we have auto-increment turned on so initialize
    // to entry 0 here)
    //
    P2RD_CURSOR_ARRAY_START(0);
    for ( iRow = 0;
          iRow < cy;
          ++iRow, pjAndMask += cjAndDelta,
          pulColor = (ULONG*)((BYTE*)pulColor+cjColorDelta) )
    {
        DBG_GDI((7, "bSet3ColorPointerShapeP2RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)",
                 iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI2ColorIndex = CI2ColorData = 0;

        for ( iCol = 0; iCol < cx; ++iCol, CI2ColorIndex += 2 )
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if ( AndBit == 7 )
            {
                //
                // We're onto the next byte of the and mask
                //
                AndByte = *pj++;
            }

            if ( CI2ColorIndex == 8 )
            {
                //
                // We've filled a byte with 4 CI2 colors
                //
                DBG_GDI((7, "bSet3ColorPointerShapeP2RD: writing cursor data %xh",
                         CI2ColorData));
                P2RD_LOAD_CURSOR_ARRAY(CI2ColorData);
                CI2ColorData = 0;
                CI2ColorIndex = 0;
            }

            //
            // Get the source pixel
            //
            if ( ppdev->cPelSize == P2DEPTH32 )
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT*)pul;
                pul = (ULONG*)((USHORT*)pul + 1);
            }

            DBG_GDI((7, "bSet3ColorPointerShapeP2RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)",
                     iCol, cx, AndByte, AndBit, ulColor));

            //
            // Figure out what to do with it:-
            // AND  Color   Result
            //  0     X             color
            //  1     0     transparent
            //  1     1     inverse
            //
            if ( AndByte & (1 << AndBit) )
            {
                //
                // Transparent or inverse
                //
                if ( ulColor == 0 )
                {
                    //
                    // color == black:
                    // transparent and seeing as the CI2ColorData is
                    // initialized to 0 we don't have to explicitly clear these
                    // bits - go on to the next pixel
                    //
                    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: transparent - ignore"));
                    continue;
                }

                if ( ulColor == ppdev->ulWhite )
                {
                    //
                    // color == white:
                    // inverse, but we don't support this. We've destroyed the
                    // cache for nothing
                    //
                    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }
            }

            //
            // Get the index for this color: first see if we've already indexed
            // it
            //
            DBG_GDI((7, "bSet3ColorPointerShapeP2RD: looking up color %08xh",
                     ulColor));

            for ( Index = 0;
                  Index < HighestIndex && aulColorsIndexed[Index] != ulColor;
                  ++Index );

            if ( Index == 3 )
            {
                //
                // Too many colors in this cursor
                //
                DBG_GDI((7, "bSet3ColorPointerShapeP2RD: failed - cursor has more than 3 colors"));
                return(FALSE);
            }
            else if ( Index == HighestIndex )
            {
                //
                // We've found another color: add it to the color index
                //
                DBG_GDI((7, "bSet3ColorPointerShapeP2RD: adding %08xh to cursor palette",
                         ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }

            //
            // Add this pixel's index to the CI2 cursor data. NB. Need Index+1
            // as 0 == transparent
            //
            CI2ColorData |= (Index + 1) <<  CI2ColorIndex;
        }

        //
        // End of the cursor row: save the remaining indexed pixels then blank
        // any unused columns
        //
        DBG_GDI((7, "bSet3ColorPointerShapeP2RD: writing remaining data for this row (%08xh) and %d trailing bytes",
                 CI2ColorData, cjCacheRemx));

        P2RD_LOAD_CURSOR_ARRAY(CI2ColorData);
        if ( cjCacheRemx )
        {
            for ( cj = cjCacheRemx; --cj >=0; )
            {
                P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_3_COLOR_TRANSPARENT);
            }
        }
    }

    //
    // End of cursor: blank any unused rows Nb. cjCacheRemy == cy blank
    // rows * cj bytes per row
    //
    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: writing %d trailing bytes for this cursor",
             cjCacheRemy));

    for ( cj = cjCacheRemy; --cj >= 0; )
    {
        //
        // 0 == transparent
        //
        P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_3_COLOR_TRANSPARENT);
    }

    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: setting up the cursor palette"));

    //
    // Now set-up the cursor palette
    //
    for ( iCol = 0; iCol < HighestIndex; ++iCol )
    {
        //
        // The cursor colors are at native depth, convert them to 24bpp
        //
        if ( ppdev->cPelSize == P2DEPTH32 )
        {
            //
            // 32bpp
            //
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else
        {
            //
            // (ppdev->cPelSize == P2DEPTH16)
            //
            if ( ppdev->ulWhite == 0xffff )
            {
                //
                // 16bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                //
                // 15bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }

        P2RD_CURSOR_PALETTE_CURSOR_RGB(iCol, r, g, b);
    }

    //
    // Enable the cursor
    //
    P2RD_CURSOR_HOTSPOT(xHot, yHot);
    if ( x != -1 )
    {
        vMovePointerP2RD (ppdev, x, y);
        //
        // Need to explicitly show the pointer if not using interrupts
        //
        vShowPointerP2RD(ppdev, TRUE);
    }

    DBG_GDI((6, "b3ColorSetPointerShapeP2RD done"));
    return(TRUE);
}// bSet3ColorPointerShapeP2RD()

//-----------------------------------------------------------------------------
//
// BOOL bSet15ColorPointerShapeP2RD
//
// Stores the 15-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
// cursors are supported
//
//-----------------------------------------------------------------------------
BOOL
bSet15ColorPointerShapeP2RD(PDev*       ppdev,
                            SURFOBJ*    psoMask,    // defines AND and MASK
                                                    // bits for cursor
                            SURFOBJ*    psoColor,   // we may handle some color
                                                    // cursors at some point
                            LONG        x,          // If -1, pointer should be
                                                    // created hidden
                            LONG        y,
                            LONG        xHot,
                            LONG        yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE*   pjAndMask;
    BYTE*   pj;
    ULONG*  pulColor;
    ULONG*  pul;
    LONG    cjAndDelta;
    LONG    cjColorDelta;
    LONG    iRow;
    LONG    iCol;
    BYTE    AndBit;
    BYTE    AndByte;
    ULONG   CI4ColorIndex;
    ULONG   CI4ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[15];
    LONG    Index;
    LONG    HighestIndex = 0;
    ULONG   r;
    ULONG   g;
    ULONG   b;

    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "bSet15ColorPointerShapeP2RD started"));

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if ( cx <= 32 && cy <= 32 )
    {
        //
        // 32x32 cursor : we'll cache it in cursor partition 0 and scrub the
        // old cache
        //
        cxcyCache = 32;

        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_32_15COLOR;
        pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                     | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize, 0)
                                     | P2RD_CURSOR_MODE_15COLOR;

        //
        // We don't cache color cursors
        //
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else if ( cx <= 64 && cy <= 64 )
    {
        //
        // It's too big to cache as a fifteen color cursor, but we might just
        // be able to cache it if it has 3 or fewer colors
        //
        BOOL bRet;

        bRet = bSet3ColorPointerShapeP2RD(ppdev, psoMask, psoColor, x, y, xHot,
                                          yHot);
        return(bRet);
    }
    else
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);          // cursor is too big to fit in the hardware
    }

    //
    // Work out the remaining bytes in the cache (in x and y) that will need
    // clearing
    //
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    //
    // Set-up a pointer to the 1bpp AND mask bitmap
    //
    pjAndMask = (UCHAR*)psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    //
    // Set-up a pointer to the 32bpp color bitmap
    //
    pulColor = (ULONG*)psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    //
    // Hide the pointer
    //
    vShowPointerP2RD(ppdev, FALSE);

    //
    // Load the cursor array (we have auto-increment turned on so initialize to
    // entry 0 here)
    //
    P2RD_CURSOR_ARRAY_START(0);
    for ( iRow = 0; iRow < cy;
         ++iRow, pjAndMask += cjAndDelta,
         pulColor = (ULONG*)((BYTE*)pulColor + cjColorDelta) )
    {
        DBG_GDI((7, "bSet15ColorPointerShapeP2RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)",
                 iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI4ColorIndex = CI4ColorData = 0;

        for ( iCol = 0; iCol < cx; ++iCol, CI4ColorIndex += 4 )
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if ( AndBit == 7 )
            {
                //
                // We're onto the next byte of the and mask
                //
                AndByte = *pj++;
            }
            if ( CI4ColorIndex == 8 )
            {
                //
                // We've filled a byte with 2 CI4 colors
                //
                DBG_GDI((7, "bSet15ColorPointerShapeP2RD: writing cursor data %xh",
                         CI4ColorData));
                P2RD_LOAD_CURSOR_ARRAY(CI4ColorData);
                CI4ColorData = 0;
                CI4ColorIndex = 0;
            }

            //
            // Get the source pixel
            //
            if ( ppdev->cPelSize == P2DEPTH32 )
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT *)pul;
                pul = (ULONG *)((USHORT *)pul + 1);
            }

            DBG_GDI((7, "bSet15ColorPointerShapeP2RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)",
                     iCol, cx, AndByte, AndBit, ulColor));

            //
            // figure out what to do with it:-
            // AND  Color   Result
            //  0     X             color
            //  1     0     transparent
            //  1     1     inverse
            if ( AndByte & (1 << AndBit) )
            {
                //
                // Transparent or inverse
                //
                if ( ulColor == 0 )
                {
                    //
                    // color == black:
                    // Transparent and seeing as the CI2ColorData is initialized
                    // to 0 we don't have to explicitly clear these bits - go on
                    // to the next pixel
                    //
                    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: transparent - ignore"));
                    continue;
                }

                if ( ulColor == ppdev->ulWhite )
                {
                    //
                    // color == white:
                    // Inverse, but we don't support this. We've destroyed the
                    // cache for nothing
                    //
                    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }
            }

            //
            // Get the index for this color: first see if we've already indexed
            // it
            //
            DBG_GDI((7, "bSet15ColorPointerShapeP2RD: looking up color %08xh",
                     ulColor));

            for ( Index = 0;
                  Index < HighestIndex && aulColorsIndexed[Index] != ulColor;
                  ++Index );

            if ( Index == 15 )
            {
                //
                // Too many colors in this cursor
                //
                DBG_GDI((7, "bSet15ColorPointerShapeP2RD: failed - cursor has more than 15 colors"));
                return(FALSE);
            }
            else if ( Index == HighestIndex )
            {
                //
                // We've found another color: add it to the color index
                //
                DBG_GDI((7, "bSet15ColorPointerShapeP2RD: adding %08xh to cursor palette",
                         ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }
            
            //
            // Add this pixel's index to the CI4 cursor data.
            // Note: Need Index+1 as 0 == transparent
            //
            CI4ColorData |= (Index + 1) << CI4ColorIndex;
        }

        //
        // End of the cursor row: save the remaining indexed pixels then blank
        // any unused columns
        //
        DBG_GDI((7, "bSet15ColorPointerShapeP2RD: writing remaining data for this row (%08xh) and %d trailing bytes", CI4ColorData, cjCacheRemx));

        P2RD_LOAD_CURSOR_ARRAY(CI4ColorData);
        if ( cjCacheRemx )
        {
            for ( cj = cjCacheRemx; --cj >=0; )
            {
                P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_15_COLOR_TRANSPARENT);
            }
        }
    }

    //
    // End of cursor: blank any unused rows Nb. cjCacheRemy == cy blank
    // rows * cj bytes per row
    //
    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: writing %d trailing bytes for this cursor", cjCacheRemy));
    for ( cj = cjCacheRemy; --cj >= 0; )
    {
        //
        // 0 == transparent
        //
        P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_15_COLOR_TRANSPARENT);
    }

    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: setting up the cursor palette"));

    // now set-up the cursor palette
    for ( iCol = 0; iCol < HighestIndex; ++iCol )
    {
        //
        // The cursor colors are at native depth, convert them to 24bpp
        //
        if ( ppdev->cPelSize == P2DEPTH32 )
        {
            //
            // 32bpp
            //
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else
        {
            //
            // (ppdev->cPelSize == P2DEPTH16)
            //
            if ( ppdev->ulWhite == 0xffff )
            {
                //
                // 16bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                //
                // 15bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }

        P2RD_CURSOR_PALETTE_CURSOR_RGB(iCol, r, g, b);
    }

    //
    // Enable the cursor
    //
    P2RD_CURSOR_HOTSPOT(xHot, yHot);
    if ( x != -1 )
    {
        vMovePointerP2RD (ppdev, x, y);
        
        //
        // need to explicitly show the pointer if not using interrupts
        //
        vShowPointerP2RD(ppdev, TRUE);
    }

    DBG_GDI((6, "b3ColorSetPointerShapeP2RD done"));
    return(TRUE);
}// bSet15ColorPointerShapeP2RD()

//-----------------------------------------------------------------------------
//
// VOID vShowPointerTVP4020
//
// Show or hide the TI TVP4020 hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vShowPointerTVP4020(PDev*   ppdev,
                    BOOL    bShow)
{
    ULONG ccr;
    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;
    TVP4020_DECL_INIT;

    DBG_GDI((6, "vShowPointerTVP4020 (%s)", bShow ? "on" : "off"));
    if ( bShow )
    {
        //
        // No need to sync since this case is called only if we've just moved
        // the cursor and that will already have done a sync.
        //
        ccr = (pTVP4020info->cursorControlCurrent | TVP4020_CURSOR_XGA);
    }
    else
    {
        ccr = pTVP4020info->cursorControlOff & ~TVP4020_CURSOR_XGA;
    }

    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, ccr);
}// vShowPointerTVP4020()

//-----------------------------------------------------------------------------
//
// VOID vMovePointerTVP4020
//
// Move the TI TVP4020 hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vMovePointerTVP4020(PDev*   ppdev,
                    LONG    x,
                    LONG    y)
{
    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;
    TVP4020_DECL_INIT;

    DBG_GDI((6, "vMovePointerTVP4020 to (%d, %d)", x, y));

    TVP4020_MOVE_CURSOR(x + ppdev->xPointerHot , y + ppdev->yPointerHot);
}// vMovePointerTVP4020()

//-----------------------------------------------------------------------------
//
// BOOL bSetPointerShapeTVP4020
//
// Set the TI TVP4020 hardware pointer shape.
//
// Parameters:
//  psoMask-----defines AND and MASK bits for cursor
//  psoColor----we may handle some color cursors at some point
//  x-----------If -1, pointer should be created hidden
//
//-----------------------------------------------------------------------------
BOOL
bSetPointerShapeTVP4020(PDev*       ppdev,
                        SURFOBJ*    psoMask,
                        SURFOBJ*    psoColor,
                        LONG        x,
                        LONG        y,
                        LONG        xHot,
                        LONG        yHot)
{
    ULONG   cx;
    ULONG   cy;
    ULONG   i, iMax;
    ULONG   j, jMax;
    BYTE    bValue;
    BYTE*   pjScan;
    LONG    lDelta;
    ULONG   cValid;
    ULONG   ulMask;
    ULONG   cursorRAMxOff;
    ULONG   cursorRAMyOff;
    BOOL    pointerIsCached;
    LONG    cacheItem;

    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;
    TVP4020_DECL_INIT;

    DBG_GDI((6, "bSetPointerShapeTVP4020 started"));

    cx = psoMask->sizlBitmap.cx;        // Note that 'sizlBitmap.cy' accounts
    cy = psoMask->sizlBitmap.cy >> 1;   // for the double height due to the
                                        // inclusion of both the AND masks
                                        // and the XOR masks.  We're
                                        // only interested in the true
                                        // pointer dimensions, so we divide
                                        // by 2.

    //
    // We currently don't handle colored cursors. Later, we could handle
    // cursors up to 64x64 with <= 3 colors. Checking this and setting it up
    // may be more trouble than it's worth.
    //
    if ( psoColor != NULL )
    {
        DBG_GDI((6, "bSetPointerShapeTVP4020: declining colored cursor"));
        return FALSE;
    }

    //
    // We only handle 32x32.
    //
    if ( (cx > 32) || (cy > 32) )
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    //
    // Check to see if the pointer is cached, add it to the cache if it isn't
    //
    DBG_GDI((6, "iUniq =%ld hsurf=0x%x", psoMask->iUniq, psoMask->hsurf));

    cacheItem = HWPointerCacheCheckAndAdd(&(ppdev->HWPtrCache),
                                          psoMask->hsurf,
                                          psoMask->iUniq,
                                          &pointerIsCached);

    DBG_GDI((7, "bSetPointerShapeTVP4020: Add Cache iscac %d item %d",
             (int)pointerIsCached, cacheItem));

    vMovePointerTVP4020(ppdev, 0, ppdev->cyScreen + 64);

    pTVP4020info->cursorControlCurrent = pTVP4020info->cursorControlOff
                                       | TVP4020_CURSOR_SIZE_32
                                       | TVP4020_CURSOR_32_SEL(cacheItem);

    //
    // Cursor slots 1 & 3 have an x offset of 8 bytes, cursor slots 2 & 3 have
    // a y offset of 256 bytes
    //
    cursorRAMxOff = (cacheItem & 1) << 2;
    cursorRAMyOff = (cacheItem & 2) << 7;

    //
    // If the pointer is not cached, then download the pointer data to the DAC
    //
    if ( !pointerIsCached )
    {
        //
        // Disable the pointer
        //
        TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL,
                                pTVP4020info->cursorControlCurrent);

        cValid = (cx + 7) / 8;
        ulMask = gajMask[cx & 0x07];
        if ( ulMask == 0 )
        {
            ulMask = 0xFF;
        }

        pjScan = (UCHAR*)psoMask->pvScan0;
        lDelta = psoMask->lDelta;

        iMax = 32;      // max rows for 32 x 32 cursor
        jMax = 4;       // max column bytes

        //
        // Send cursor plane 0 - in our case XOR
        //
        for ( i = 0; i < iMax; ++i )
        {
            TVP4020_CURSOR_ARRAY_START(CURSOR_PLANE0_OFFSET + cursorRAMyOff
                                       + (i * 8) + cursorRAMxOff);
            for ( j = 0; j < jMax; ++j )
            {
                if ( (j < cValid) && ( i < cy ) )
                {
                    bValue = *(pjScan + j + (i + cy) * lDelta);
                }
                else
                {
                    bValue = 0;
                }
                TVP4020_LOAD_CURSOR_ARRAY((ULONG)bValue);
            }
        }

        //
        // Send cursor plane 1 - in our case AND
        //
        for ( i = 0; i < iMax; ++i )
        {
            TVP4020_CURSOR_ARRAY_START(CURSOR_PLANE1_OFFSET + cursorRAMyOff
                                       + (i * 8) + cursorRAMxOff);
            for ( j = 0; j < jMax; ++j )
            {
                if ( (j < cValid) && ( i < cy ) )
                {
                    bValue = *(pjScan + j + i * lDelta);
                }
                else
                {
                    bValue = 0xFF;
                }
                TVP4020_LOAD_CURSOR_ARRAY((ULONG)bValue);
            }
        }
    }// If pointer is not cached

    //
    // If the new cursor is different to the last cursor then set up the hot
    // spot and other bits'n'pieces.
    //
    if ( ppdev->HWPtrLastCursor != cacheItem || !pointerIsCached )
    {
        //
        // Make this item the last item
        //
        ppdev->HWPtrLastCursor = cacheItem;

        ppdev->xPointerHot = 32 - xHot;
        ppdev->yPointerHot = 32 - yHot;
    }

    if ( x != -1 )
    {
        vShowPointerTVP4020(ppdev, TRUE);
        vMovePointerTVP4020(ppdev, x, y);

        // Enable the cursor:
    }

    DBG_GDI((6, "bSetPointerShapeTVP4020 done"));
    return(TRUE);
}// bSetPointerShapeTVP4020()

//-----------------------------------------------------------------------------
//
// VOID vEnablePointerTVP4020
//
// Get the hardware ready to use the TI TVP4020 hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vEnablePointerTVP4020(PDev* ppdev)
{
    pTVP4020RAMDAC      pRamdac;
    ULONG               ulMask;

    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;

    DBG_GDI((6, "vEnablePointerTVP4020 called"));
    ppdev->pvPointerData = &ppdev->ajPointerData[0];

    TVP4020_DECL_INIT;

    //
    // Get a pointer to the RAMDAC registers from the memory mapped
    // control register space.
    //
    pRamdac = (pTVP4020RAMDAC)(ppdev->pulRamdacBase);

    //
    // set up memory mapping for the control registers and save in the pointer
    // specific area provided in ppdev.
    //
    __TVP4020_PAL_WR_ADDR = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrWr));
    __TVP4020_PAL_RD_ADDR = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrRd));
    __TVP4020_PAL_DATA    = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->palData));
    __TVP4020_PIXEL_MASK  = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->pixelMask));
    __TVP4020_INDEX_DATA  = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->indexData));

    __TVP4020_CUR_RAM_DATA    = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->curRAMData));
    __TVP4020_CUR_RAM_WR_ADDR = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrWr));
    __TVP4020_CUR_RAM_RD_ADDR = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrRd));
    __TVP4020_CUR_COL_ADDR    = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->curColAddr));
    __TVP4020_CUR_COL_DATA    = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->curColData));
    __TVP4020_CUR_X_LSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorXLow));
    __TVP4020_CUR_X_MSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorXHigh));
    __TVP4020_CUR_Y_LSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorYLow));
    __TVP4020_CUR_Y_MSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorYHigh));

    //
    // Initialize Cursor Control register. disables cursor. save a copy for
    // enabling/disabling and setting the size. Then reset the cursor position,
    // hot spot and colors.
    //
    // ulMask is used to prepare initial cursor control register
    //
    ulMask = TVP4020_CURSOR_RAM_MASK
           | TVP4020_CURSOR_MASK
           | TVP4020_CURSOR_SIZE_MASK;

    //
    // Set the cursor control to default values.
    //
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL,
                           pTVP4020info->cursorControlOff);
    pTVP4020info->cursorControlOff &= ~ulMask;
    pTVP4020info->cursorControlOff |=  TVP4020_CURSOR_OFF;

    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL,
                            pTVP4020info->cursorControlOff);
    pTVP4020info->cursorControlCurrent = pTVP4020info->cursorControlOff;

    ppdev->xPointerHot = 0;
    ppdev->yPointerHot = 0;

    //
    // Zero the RGB colors for foreground and background. The mono cursor is
    // always black and white so we don't have to reload these values again.
    //
    TVP4020_SET_CURSOR_COLOR0(0, 0, 0);
    TVP4020_SET_CURSOR_COLOR1(0xFF, 0xFF, 0xFF);
}// vEnablePointerTVP4020()

//-----------------------------------------------------------------------------
//
// BOOL bTVP4020CheckCSBuffering
//
// Determine whether we can do color space double buffering in the current
// mode.
//
// Returns
//   TRUE if we can do the color space double buffering, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL
bTVP4020CheckCSBuffering(PDev* ppdev)
{
    return FALSE;
}

//-----------------------------------------------------------------------------
//
// BOOL bSetPointerShapeP2RD
//
// Set the P2RD hardware pointer shape.
//
//-----------------------------------------------------------------------------
BOOL
bSetPointerShapeP2RD(PDev*      ppdev,
                     SURFOBJ*   pso,       // defines AND and MASK bits for cursor
                     SURFOBJ*   psoColor,  // we may handle some color cursors at some point
                     XLATEOBJ*  pxlo,
                     LONG       x,          // If -1, pointer should be created hidden
                     LONG       y,
                     LONG       xHot,
                     LONG       yHot)
{
    ULONG   cx;
    ULONG   cy;
    LONG    i;
    LONG    j;
    ULONG   ulValue;
    BYTE*   pjAndScan;
    BYTE*   pjXorScan;
    BYTE*   pjAnd;
    BYTE*   pjXor;
    BYTE    andByte;
    BYTE    xorByte;
    BYTE    jMask;
    LONG    lDelta;
    LONG    cpelFraction;
    LONG    cjWhole;
    LONG    cClear;
    LONG    cRemPels;
    BOOL    pointerIsCached;
    LONG    cacheItem;
    LONG    cursorBytes;
    LONG    cursorRAMOff;

    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "bSetPointerShapeP2RD called"));

    if ( psoColor != NULL )
    {
        Surf*  psurfSrc = (Surf*)psoColor->dhsurf;

        //
        // It's a colored cursor
        //
        if ( (psoColor->dhsurf != NULL)
           ||(!(psoColor->iBitmapFormat == BMF_16BPP))
           ||(psoColor->iBitmapFormat == BMF_32BPP) )
        {
            //
            // Currently we only handle DIB cursors at 32bpp
            //
            DBG_GDI((2, "declining colored cursor - iType(%d) iBMPFormat(%d)",
                     psoColor->iType, psoColor->iBitmapFormat));
            return FALSE;
        }

        if ( pxlo != NULL )
        {
            if ( pxlo->flXlate != XO_TRIVIAL )
            {
                DBG_GDI((2, "declining colored cursor - flXlate(%xh)",
                         pxlo->flXlate));
                return FALSE;
            }
        }

        if ( !bSet15ColorPointerShapeP2RD(ppdev, pso, psoColor, x, y, xHot,
                                          yHot) )
        {
            DBG_GDI((2, "declining colored cursor"));
            return FALSE;
        }

        DBG_GDI((6, "bSetPointerShapeP2RD done"));
        return(TRUE);
    }// if ( psoColor != NULL )

    //
    // Note that 'sizlBitmap.cy' accounts for the double height due to the
    // inclusion of both the AND masks and the XOR masks. We're only
    // interested in the true pointer dimensions, so we divide by 2.
    //
    cx = pso->sizlBitmap.cx;
    cy = pso->sizlBitmap.cy >> 1;

    //
    // We can handle up to 64x64.  cValid indicates the number of bytes
    // occupied by cursor on one line
    //
    if ( cx <= 32 && cy <= 32 )
    {
        //
        // 32 horiz pixels: 2 bits per pixel, 1 horiz line per 8 bytes
        //
        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_32_MONO;
        cursorBytes = 32 * 32 * 2 / 8;
        cClear   = 8 - 2 * ((cx+7) / 8);
        cRemPels = (32 - cy) << 3;
    }
    else
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    //
    // Check to see if the pointer is cached, add it to the cache if it isn't
    //
    cacheItem = HWPointerCacheCheckAndAdd(&(ppdev->HWPtrCache),
                                          pso->hsurf,
                                          pso->iUniq,
                                          &pointerIsCached);

    DBG_GDI((7, "bSetPointerShapeP2RD: Add Cache iscac %d item %d",
             (int)pointerIsCached, cacheItem));

    pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                 | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize,
                                                   cacheItem);

    //
    // Hide the pointer
    //
    vShowPointerP2RD(ppdev, FALSE);

    if ( !pointerIsCached )
    {
        //
        // Now we're going to take the requested pointer AND masks and XOR
        // masks and interleave them by taking a nibble at a time from each,
        // expanding each out and or'ing together. Use the nibbleToByteP2RD
        // array to help this.
        //
        // 'psoMsk' is actually cy * 2 scans high; the first 'cy' scans
        // define the AND mask.
        //
        pjAndScan = (UCHAR*)pso->pvScan0;
        lDelta    = pso->lDelta;
        pjXorScan = pjAndScan + (cy * lDelta);

        cjWhole      = cx >> 3;     // Each byte accounts for 8 pels
        cpelFraction = cx & 0x7;    // Number of fractional pels
        jMask        = gajMask[cpelFraction];

        //
        // We've got auto-increment turned on so just point to the first entry
        // to write to in the array then write repeatedly until the cursor
        // pattern has been transferred
        //
        cursorRAMOff = cacheItem * cursorBytes;
        P2RD_CURSOR_ARRAY_START(cursorRAMOff);

        for ( i = cy; --i >= 0; pjXorScan += lDelta, pjAndScan += lDelta )
        {
            pjAnd = pjAndScan;
            pjXor = pjXorScan;

            //
            // Interleave nibbles from whole words. We are using Windows cursor
            // mode.
            // Note, the AND bit occupies the higher bit position for each
            // 2bpp cursor pel; the XOR bit is in the lower bit position.
            // The nibbleToByteP2RD array expands each nibble to occupy the bit
            // positions for the AND bytes. So when we use it to calculate the
            // XOR bits we shift the result right by 1.
            //
            for ( j = cjWhole; --j >= 0; ++pjAnd, ++pjXor )
            {
                andByte = *pjAnd;
                xorByte = *pjXor;
                ulValue = nibbleToByteP2RD[andByte >> 4]
                        | (nibbleToByteP2RD[xorByte >> 4] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP2RD[andByte]
                        | (nibbleToByteP2RD[xorByte] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            if ( cpelFraction )
            {
                andByte = *pjAnd & jMask;
                xorByte = *pjXor & jMask;
                ulValue = nibbleToByteP2RD[andByte >> 4]
                        | (nibbleToByteP2RD[xorByte >> 4] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP2RD[andByte]
                        | (nibbleToByteP2RD[xorByte] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            //
            // Finally clear out any remaining cursor pels on this line.
            //
            if ( cClear )
            {
                for ( j = 0; j < cClear; ++j )
                {
                    P2RD_LOAD_CURSOR_ARRAY (P2RD_CURSOR_2_COLOR_TRANSPARENT);
                }
            }
        }

        //
        // If we've loaded fewer than the full number of lines configured in
        // the cursor RAM, clear out the remaining lines. cRemPels is
        // precalculated to be the number of lines * number of pels per line.
        //
        if ( cRemPels > 0 )
        {
            do
            {
                P2RD_LOAD_CURSOR_ARRAY (P2RD_CURSOR_2_COLOR_TRANSPARENT);
            }
            while ( --cRemPels > 0 );
        }
    }// if ( !pointerIsCached )

    //
    // Now set-up the cursor colors
    //
    P2RD_CURSOR_PALETTE_CURSOR_RGB(0, 0x00, 0x00, 0x00);
    P2RD_CURSOR_PALETTE_CURSOR_RGB(1, 0xFF, 0xFF, 0xFF);

    //
    // If the new cursor is different to the last cursor then set up
    // the hot spot and other bits'n'pieces. As we currently only support
    // mono cursors we don't need to reload the cursor palette
    //
    if ( ppdev->HWPtrLastCursor != cacheItem || !pointerIsCached )
    {
        //
        // Make this item the last item
        //
        ppdev->HWPtrLastCursor = cacheItem;

        P2RD_CURSOR_HOTSPOT(xHot, yHot);
    }

    if ( x != -1 )
    {
        vMovePointerP2RD (ppdev, x, y);
        
        //
        // Need to explicitly show the pointer if not using interrupts
        //
        vShowPointerP2RD(ppdev, TRUE);
    }

    DBG_GDI((6, "bSetPointerShapeP2RD done"));
    return(TRUE);
}// bSetPointerShapeP2RD()

//-----------------------------------------------------------------------------
//
// VOID vEnablePointerP2RD
//
// Get the hardware ready to use the 3Dlabs P2RD hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vEnablePointerP2RD(PDev* ppdev)
{
    pP2RDRAMDAC pRamdac;
    ULONG       ul;

    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;

    DBG_GDI((6, "vEnablePointerP2RD called"));

    ppdev->pvPointerData = &ppdev->ajPointerData[0];

    P2RD_DECL_INIT;

    //
    // get a pointer to the RAMDAC registers from the memory mapped
    // control register space.
    //
    pRamdac = (pP2RDRAMDAC)(ppdev->pulRamdacBase);

    //
    // set up memory mapping for the control registers and save in the pointer
    // specific area provided in ppdev.
    //
    P2RD_PAL_WR_ADDR
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPaletteWriteAddress));
    P2RD_PAL_RD_ADDR
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPaletteAddressRead));
    P2RD_PAL_DATA
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPaletteData));
    P2RD_PIXEL_MASK
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPixelMask));
    P2RD_INDEX_ADDR_HI
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexHigh));
    P2RD_INDEX_ADDR_LO
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexLow));
    P2RD_INDEX_DATA
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexedData));
    P2RD_INDEX_CONTROL 
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexControl));

    //
    // Not used, but set-up zero anyway
    //
    ppdev->xPointerHot = 0;
    ppdev->yPointerHot = 0;

    //
    // Enable auto-increment
    //
    ul = READ_P2RDREG_ULONG(P2RD_INDEX_CONTROL);
    ul |= P2RD_IDX_CTL_AUTOINCREMENT_ENABLED;
    WRITE_P2RDREG_ULONG(P2RD_INDEX_CONTROL, ul);

    P2RD_READ_INDEX_REG(P2RD_CURSOR_CONTROL, pP2RDinfo->cursorControl);

    pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff = 0;
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_MODE, pP2RDinfo->cursorModeOff);

    P2RD_INDEX_REG(P2RD_CURSOR_X_LOW);
    P2RD_LOAD_DATA(0);      // cursor x low
    P2RD_LOAD_DATA(0);      // cursor x high
    P2RD_LOAD_DATA(0);      // cursor y low
    P2RD_LOAD_DATA(0xff);   // cursor y high
    P2RD_LOAD_DATA(0);      // cursor x hotspot
    P2RD_LOAD_DATA(0);      // cursor y hotspot
}// vEnablePointerP2RD()

//-----------------------------------------------------------------------------
//
// BOOL bP2RDCheckCSBuffering
//
// Determine whether we can do color space double buffering in the current mode
//
// Returns
//   TRUE if we can do the color space double buffering, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL
bP2RDCheckCSBuffering(PDev* ppdev)
{
    return (FALSE);
}// bP2RDCheckCSBuffering()

//-----------------------------------------------------------------------------
//
// BOOL bP2RDSwapCSBuffers
//
// Use the pixel read mask to perform color space double buffering. This is
// only called when we have 12bpp with interleaved nibbles. We do a polled
// wait for VBLANK before the swap. In the future we may do all this in the
// miniport via interrupts.
//
// Returns
//   We should never be called if this is inappropriate so return TRUE.
//
//-----------------------------------------------------------------------------
BOOL
bP2RDSwapCSBuffers(PDev*   ppdev,
                   LONG    bufNo)
{
    ULONG index;
    ULONG color;
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;
    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    //
    // Work out the RAMDAC read pixel mask for the buffer
    //
    DBG_GDI((6, "loading the palette to swap to buffer %d", bufNo));
    P2RD_PALETTE_START_WR (0);
    
    if ( bufNo == 0 )
    {
        for ( index = 0; index < 16; ++index )
            for ( color = 0; color <= 0xff; color += 0x11 )
                P2RD_LOAD_PALETTE (color, color, color);
    }
    else
    {
        for ( color = 0; color <= 0xff; color += 0x11 )
            for ( index = 0; index < 16; ++index )
                P2RD_LOAD_PALETTE (color, color, color);
    }

    return(TRUE);
}// bP2RDSwapCSBuffers()

//-------------------------------Public*Routine-------------------------------
//
// VOID DrvMovePointer
//
// This function moves the pointer to a new position and ensures that GDI does
// not interfere with the display of the pointer.
//
// Parameters:
// pso-------Points to a SURFOBJ structure that describes the surface of a
//           display device.
// x,y-------Specify the x and y coordinates on the display where the hot spot
//           of the pointer should be positioned.
//           A negative x value indicates that the pointer should be removed
//           from the display because drawing is about to occur where it is
//           presently located. If the pointer has been removed from the display
//           and the x value is nonnegative, the pointer should be restored.
//
//           A negative y value indicates that GDI is calling this function only
//           to notify the driver of the cursor's current position. The current
//           position can be computed as (x, y+pso->sizlBitmap.cy).
// prcl------Points to a RECTL structure defining an area that bounds all pixels
//           affected by the pointer on the display. GDI will not draw in this
//           rectangle without first removing the pointer from the screen. This
//           parameter can be null.
//
// NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
//       time, even while we're executing another drawing call!
//
//-----------------------------------------------------------------------------
VOID
DrvMovePointer(SURFOBJ* pso,
               LONG     x,
               LONG     y,
               RECTL*   prcl)
{
    PDev*   ppdev = (PDev*)pso->dhpdev;

    DBG_GDI((6, "DrvMovePointer called, dhpdev(%xh), to pos(%ld, %ld)",
             ppdev, x, y));

    //
    // A negative y value indicates that GDI is calling this function only to
    // notify the driver of the cursor's current position. So, at least, for
    // HW cursor, we don't need to move this pointer. Just return
    //
    if ( ( y < 0 ) && ( x > 0 ) )
    {
        DBG_GDI((6, "DrvMovePointer return because x and y both < 0"));
        return;
    }

    DBG_GDI((6, "DrvMovePointer really moves HW pointer"));

    //
    // Negative X indicates that the pointer should be removed from the display
    // because drawing is about to occur where it is presently located.
    //
    if ( x > -1 )
    {
        //
        // If we're doing any hardware zooming then the cusor position will
        // have to be doubled.
        //
        if ( (ppdev->flCaps & CAPS_P2RD_POINTER) == 0 )
        {
            if ( ppdev->flCaps & CAPS_ZOOM_Y_BY2 )
            {
                DBG_GDI((6,"HW zooming Y_BY2"));
                y *= 2;
            }
            if ( ppdev->flCaps & CAPS_ZOOM_X_BY2 )
            {
                DBG_GDI((6,"HW zooming X_BY2"));
                x *= 2;
            }
        }

        //
        // If they have genuinely moved the cursor, then move it
        //
        if ( (x != ppdev->HWPtrPos_X) || (y != ppdev->HWPtrPos_Y) )
        {
            if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
            {
                vMovePointerTVP4020(ppdev, x, y);
            }
            else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
            {
                vMovePointerP2RD(ppdev, x, y);
            }

            ppdev->HWPtrPos_X = x;
            ppdev->HWPtrPos_Y = y;
        }

        //
        // We may have to make the pointer visible:
        //
        if ( !(ppdev->flPointer & PTR_HW_ACTIVE) )
        {
            DBG_GDI((6, "Showing hardware pointer"));
            ppdev->flPointer |= PTR_HW_ACTIVE;

            if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
            {
                vShowPointerTVP4020(ppdev, TRUE);
            }
            else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
            {
                vShowPointerP2RD(ppdev, TRUE);
            }
        }
    }// if ( x > -1 )
    else if ( ppdev->flPointer & PTR_HW_ACTIVE )
    {
        //
        // The pointer is visible, and we've been asked to hide it
        //
        DBG_GDI((6, "Hiding hardware pointer"));
        ppdev->flPointer &= ~PTR_HW_ACTIVE;

        if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
        {
            DBG_GDI((7, "Showing hardware pointer"));
            vShowPointerTVP4020(ppdev, FALSE);
        }
        else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
        {
            vShowPointerP2RD(ppdev, FALSE);
        }
    }

    //
    // Note that we don't have to modify 'prcl', since we have a
    // NOEXCLUDE pointer...
    //
    DBG_GDI((6, "DrvMovePointer exited, dhpdev(%xh)", ppdev));
}// DrvMovePointer()

//---------------------------Public*Routine------------------------------------
//
// VOID DrvSetPointerShape
//
// This function is used to request the driver to:
//
// 1) Take the pointer off the display, if the driver has drawn it there.
// 2) Attempt to set a new pointer shape.
// 3) Put the new pointer on the display at a specified position.
//
// Parameters:
// psO-------Points to a SURFOBJ structure that describes the surface on which
//           TO draw.
// psoMask---Points to a SURFOBJ structure that defines the AND-XOR mask. (The
//           AND-XOR mask is described in Drawing Monochrome Pointers.) The
//           dimensions of this bitmap determine the size of the pointer. There
//           are no implicit constraints on pointer sizes, but optimal pointer
//           sizes are 32 x 32, 48 x 48, and 64 x 64 pixels. If this parameter
//           IS NULL, the pointer is transparent.
// psoColor--Points to a SURFOBJ structure that defines the colors for a color
//           pointer. If this parameter is NULL, the pointer is monochrome. The
//           pointer bitmap has the same width as psoMask and half the height.
// pxlo------Points to a XLATEOBJ structure that defines the colors in psoColor.
// xHot,yHot-Specify the x and y positions of the pointer's hot spot relative
//           to its upper-left pixel. The pixel indicated by the hot spot should
//           be positioned at the new pointer position.
// x, y------Specify the new pointer position.
// prcl------Is the location in which the driver should write a rectangle that
//           specifies a tight bound for the visible portion of the pointer.
// fl--------Specifies an extensible set of flags. The driver should decline the
//           call if any flags are set that it does not understand. This
//           parameter can be one or more of the following predefined values,
//           and one or more driver-defined values:
//   Flag Meaning
//   SPS_CHANGE----------The driver is requested to change the pointer shape.
//   SPS_ASYNCCHANGE-----This flag is obsolete. For legacy drivers, the driver
//                       should accept the change only if it is capable of
//                       changing the pointer shape in the hardware while other
//                       drawing is underway on the device. GDI uses this option
//                       only if the now obsolete GCAPS_ASYNCCHANGE flag is set
//                       in the flGraphicsCaps member of the DEVINFO structure.
//   SPS_ANIMATESTART----The driver should be prepared to receive a series of
//                       similarly-sized pointer shapes that will comprise an
//                       animated pointer effect.
//   SPS_ANIMATEUPDATE---The driver should draw the next pointer shape in the
//                       animated series.
//   SPS_ALPHA-----------The pointer has per-pixel alpha values.
//
// Return Value
//   The return value can be one of the following values:
//
//   Value Meaning
//   SPS_ERROR-----------The driver normally supports this shape, but failed for
//                       unusual reasons.
//   SPS_DECLINE---------The driver does not support the shape, so GDI must
//                       simulate it.
//   SPS_ACCEPT_NOEXCLUDE-The driver accepts the shape. The shape is supported
//                       in hardware and GDI is not concerned about other
//                       drawings overwriting the pointer.
//   SPS_ACCEPT_EXCLUDE--Is obsolete. GDI will disable the driver's pointer and
//                       revert to software simulation if the driver returns
//                       this value.
//
//-----------------------------------------------------------------------------
ULONG
DrvSetPointerShape(SURFOBJ*    pso,
                   SURFOBJ*    psoMsk,
                   SURFOBJ*    psoColor,
                   XLATEOBJ*   pxlo,
                   LONG        xHot,
                   LONG        yHot,
                   LONG        x,
                   LONG        y,
                   RECTL*      prcl,
                   FLONG       fl)
{
    PDev*   ppdev;
    BOOL    bAccept = FALSE;
    
    ppdev = (PDev*)pso->dhpdev;
    
    DBG_GDI((6, "DrvSetPointerShape called, dhpdev(%x)", ppdev));
    DBG_GDI((6, "DrvSetPointerShape psocolor (0x%x)", psoColor));

    //
    // When CAPS_SW_POINTER is set, we have no hardware pointer available,
    // so we always ask GDI to simulate the pointer for us, using
    // DrvCopyBits calls:
    //
    if ( ppdev->flCaps & CAPS_SW_POINTER )
    {
        DBG_GDI((6, "SetPtrShape: CAPS_SW_POINTER not set, rtn SPS_DECLINE"));
        return (SPS_DECLINE);
    }

    //
    // We're not going to handle flags that we don't understand.
    //
    if ( !(fl & SPS_CHANGE) )
    {
        DBG_GDI((6, "DrvSetPointerShape decline: Unknown flag =%x", fl));
        goto HideAndDecline;
    }

    //
    // Remove any pointer first.
    // We have a special x value for the software cursor to indicate that
    // it should be removed immediatly, not delayed. DrvMovePointer needs to
    // recognise it as remove for any pointers though.
    // Note: CAPS_{P2RD, TVP4020, SW}_POINTER should be set in miniport after
    // it detects the DAC type
    //
    if ( x != -1 )
    {
        if ( (ppdev->flCaps & CAPS_P2RD_POINTER) == 0 )
        {
            //
            // If we're doing any hardware zooming then the cusor position will
            // have to be doubled.
            //
            if ( ppdev->flCaps & CAPS_ZOOM_Y_BY2 )
            {
                y *= 2;
            }
            if ( ppdev->flCaps & CAPS_ZOOM_X_BY2 )
            {
                x *= 2;
            }
        }
    }

    DBG_GDI((6, "iUniq is %ld", psoMsk->iUniq));

    if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
    {
        DBG_GDI((6, "DrvSetPointerShape tring to set TVP4020 pointer"));
        bAccept = bSetPointerShapeTVP4020(ppdev, psoMsk, psoColor,
                                          x, y, xHot, yHot);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        bAccept = bSetPointerShapeP2RD(ppdev, psoMsk, psoColor, pxlo,
                                       x, y, xHot, yHot);
    }

    //
    // If we failed setup the hardware pointer shape, then return SPS_DECLINE
    // and let GDI handles it
    //
    if ( !bAccept )
    {
        DBG_GDI((6, "set hardware pointer shape failed"));
        return (SPS_DECLINE);
    }

    //
    // Set flag to indicate that we have initialized hardware pointer shape
    // so that in vAssertModePointer, we can do some clean up
    //
    ppdev->bPointerInitialized = TRUE;

    if ( x != -1 )
    {
        //
        // Save the X and Y values
        //
        ppdev->HWPtrPos_X = x;
        ppdev->HWPtrPos_Y = y;

        ppdev->flPointer |= PTR_HW_ACTIVE;
    }
    else
    {
        ppdev->flPointer &= ~PTR_HW_ACTIVE;
    }

    //
    // Since it's a hardware pointer, GDI doesn't have to worry about
    // overwriting the pointer on drawing operations (meaning that it
    // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
    // Since we're returning 'NOEXCLUDE', we also don't have to update
    // the 'prcl' that GDI passed us.
    //
    DBG_GDI((6, "DrvSetPointerShape return SPS_ACCEPT_NOEXCLUDE"));
    return (SPS_ACCEPT_NOEXCLUDE);

HideAndDecline:

    //
    // Remove whatever pointer is installed.
    //
    DrvMovePointer(pso, -2, -1, NULL);
    ppdev->flPointer &= ~PTR_SW_ACTIVE;
    DBG_GDI((6, "Cursor declined"));

    DBG_GDI((6, "DrvSetPointerShape exited (cursor declined)"));

    return (SPS_DECLINE);
}// DrvSetPointerShape()

//-----------------------------------------------------------------------------
//
// VOID vAssertModePointer
//
// Do whatever has to be done to enable everything but hide the pointer.
//
//-----------------------------------------------------------------------------
VOID
vAssertModePointer(PDev*   ppdev,
                   BOOL    bEnable)
{
    DBG_GDI((6, "vAssertModePointer called"));

    if ( (ppdev->bPointerInitialized == FALSE)
       ||(ppdev->flCaps & CAPS_SW_POINTER) )
    {
        //
        // With a software pointer, or the pointer hasn't been initialized,
        // we don't have to do anything.
        //

        return;
    }

    //
    // Invalidate the hardware pointer cache
    //
    HWPointerCacheInvalidate(&(ppdev->HWPtrCache));

    if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
    {
        vShowPointerTVP4020(ppdev, FALSE);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        vShowPointerP2RD(ppdev, FALSE);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        vEnablePointerP2RD(ppdev);
    }

    ppdev->flPointer &= ~(PTR_HW_ACTIVE | PTR_SW_ACTIVE);
}// vAssertModePointer()

//-----------------------------------------------------------------------------
//
// BOOL bEnablePointer(PDev* ppdev)
//
// This function initializes hardware pointer or software pointer depends on
// on the CAPS settinsg in ppdev->flCaps
//
// This function always returns TRUE
//
//-----------------------------------------------------------------------------
BOOL
bEnablePointer(PDev* ppdev)
{
    DBG_GDI((6, "bEnablePointer called"));

    //
    // Initialise the pointer cache.
    //
    HWPointerCacheInit(&(ppdev->HWPtrCache));

    //
    // Set the last cursor to something invalid
    //
    ppdev->HWPtrLastCursor = HWPTRCACHE_INVALIDENTRY;

    //
    // Initialise the X and Y values to something silly
    //
    ppdev->HWPtrPos_X = 1000000000;
    ppdev->HWPtrPos_Y = 1000000000;

    if ( ppdev->flCaps & CAPS_SW_POINTER )
    {
        // With a software pointer, we don't have to do anything.
    }
    else if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
    {
        vEnablePointerTVP4020(ppdev);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        vEnablePointerP2RD(ppdev);
    }

    return (TRUE);
}// bEnablePointer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\registry.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: registry.h
*
* utility routines to help with accessing the registry.
*
* Copyright (c) 1998 Microsoft Corporation. All rights reserved.
*
\**************************************************************************/
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

extern 	BOOL bRegistryRetrieveGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut);

extern 	BOOL bRegistrySaveGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut);

extern BOOL bRegistryQueryUlong(PPDev, LPWSTR, PULONG);

#endif // __REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\rops.h ===
/******************************Module*Header*******************************\
* Module Name: rops.h
*
* Utility defines and routines for manipulation of rop codes.
*
* Copyright (c) 1998 Microsoft Corporation
*
\**************************************************************************/

#ifndef __ROPS__
#define __ROPS__

//------------------------------------------------------------------------------
//
// ULONG MixToRop4(MIX mix) - Translates a MIX into a ROP3.
//
//------------------------------------------------------------------------------

extern ULONG gaMix[];

#define MixToRop4(mix) \
    (( gaMix[mix >> 8] << 8) | gaMix[mix & 0xf])


//------------------------------------------------------------------------------
//
// Some usefull ROP3 code defines
//
//------------------------------------------------------------------------------

#define ROP3_NOP            0xAA
#define ROP3_SRCCOPY        (SRCCOPY >> 16)     // 0xCC
#define ROP3_SRCPAINT       (SRCPAINT >> 16)    // 0xEE
#define ROP3_SRCAND         (SRCAND >> 16)      // 0x88
#define ROP3_SRCINVERT      (SRCINVERT >> 16)   // 0x66
#define ROP3_SRCERASE       (SRCERASE >> 16)    // 0x44
#define ROP3_NOTSRCCOPY     (NOTSRCCOPY >> 16)  // 0x33
#define ROP3_NOTSRCERASE    (NOTSRCERASE >> 16) // 0x11
#define ROP3_MERGECOPY      (MERGECOPY >> 16)   // 0xC0
#define ROP3_MERGEPAINT     (MERGEPAINT >> 16)  // 0xBB
#define ROP3_PATCOPY        (PATCOPY >> 16)     // 0xF0
#define ROP3_PATPAINT       (PATPAINT >> 16)    // 0xFB
#define ROP3_PATINVERT      (PATINVERT >> 16)   // 0x5A
#define ROP3_DSTINVERT      (DSTINVERT >> 16)   // 0x55
#define ROP3_BLACKNESS      (BLACKNESS >> 16)   // 0x00
#define ROP3_WHITENESS      (WHITENESS >> 16)   // 0xFF

//------------------------------------------------------------------------------
//
// Some usefull ROP4 code defines
//
//------------------------------------------------------------------------------

#define ROP4_SRCCOPY       (ROP3_SRCCOPY | (ROP3_SRCCOPY << 8))       // 0xCCCC
#define ROP4_NOTSRCCOPY    (ROP3_NOTSRCCOPY | (ROP3_NOTSRCCOPY << 8)) // 0x3333
#define ROP4_NOP           (ROP3_NOP | (ROP3_NOP << 8))               // 0xAAAA
#define ROP4_PATCOPY       (ROP3_PATCOPY | (ROP3_PATCOPY << 8))       // 0xFOFO
#define ROP4_BLACKNESS     (ROP3_BLACKNESS | (ROP3_BLACKNESS << 8))   // 0x0000
#define ROP4_WHITENESS     (ROP3_WHITENESS | (ROP3_WHITENESS << 8))   // 0xFFFF


//------------------------------------------------------------------------------
//
// ULONG ulRop3ToLogicop
//
//
// Convert a source invariant rop3 code into a hardware specific logical 
// operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

extern ULONG ulRop3ToLogicop(ULONG ucRop3);

//------------------------------------------------------------------------------
//
// ULONG ulRop2ToLogicop
//
// Convert a rop2 code into a hardware dependent logical operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

extern ULONG ulRop2ToLogicop(ULONG ucRop2);

#endif // __ROPS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\rops.c ===
/******************************Module*Header*******************************\
* Module Name: rops.c
*
*
* Utility routines to manilpulate rop codes.
*
* Copyright (c) 1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

//
// The gaMix table converts a mix code (1-16) and converts it to a rop3
// Note that we also define mix code 0 == code 16 to allow for the masking
// of the mix code by 0xff to produce the correct result.
// 

ULONG gaMix[] =
{
    ROP3_WHITENESS,     // (R2_WHITE & 0xff)
    ROP3_BLACKNESS,     // R2_BLACK
    0x05,               // R2_NOTMERGEPEN
    0x0A,               // R2_MASKNOTPEN
    0x0F,               // R2_NOTCOPYPEN
    0x50,               // R2_MASKPENNOT
    ROP3_DSTINVERT,     // R2_NOT
    ROP3_PATINVERT,     // R2_XORPEN
    0x5F,               // R2_NOTMASKPEN
    0xA0,               // R2_MASKPEN
    0xA5,               // R2_NOTXORPEN
    0xAA,               // R2_NOP
    0xAF,               // R2_MERGENOTPEN
    ROP3_PATCOPY,       // R2_COPYPEN
    0xF5,               // R2_MERGEPENNOT
    0xFA,               // R2_MERGEPEN
    ROP3_WHITENESS      // R2_WHITE
};

//
// Convert a rop2 code to a hardware specific logical operation code
//

ULONG gRop2ToLogicop[] =
{
    K_LOGICOP_CLEAR,        // 0
    K_LOGICOP_NOR,          // DSon
    K_LOGICOP_AND_INVERTED, // DSna
    K_LOGICOP_COPY_INVERT,  // Sn
    K_LOGICOP_AND_REVERSE,  // SDna
    K_LOGICOP_INVERT,       // Dn
    K_LOGICOP_XOR,          // DSx
    K_LOGICOP_NAND,         // DSan
    K_LOGICOP_AND,          // DSa
    K_LOGICOP_EQUIV,        // DSxn
    K_LOGICOP_NOOP,         // D
    K_LOGICOP_OR_INVERT,    // DSno
    K_LOGICOP_COPY,         // S
    K_LOGICOP_OR_REVERSE,   // SDno
    K_LOGICOP_OR,           // DSo
    K_LOGICOP_SET
};

//------------------------------------------------------------------------------
//
// ULONG ulRop3ToLogicop
//
//
// Convert a source invariant rop3 code into a hardware specific logical 
// operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

ULONG
ulRop3ToLogicop(ULONG ulRop3)
{
    ASSERTDD(ulRop3 <= 0xFF, "ulRop3ToLogicop: unexpected rop3 code");
    
    ULONG ulRop2;

    ulRop2 = ((ulRop3 & 0x3) | ((ulRop3 & 0xC0) >> 4));

    return gRop2ToLogicop[ulRop2];
}

//------------------------------------------------------------------------------
//
// ULONG ulRop2ToLogicop
//
// Convert a rop2 code into a hardware dependent logical operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

ULONG
ulRop2ToLogicop(ULONG ulRop2)
{
    ASSERTDD(ulRop2 <= 0xF, "ulRop2ToLogicop: unexpected rop2 code");

    return (ULONG)(gRop2ToLogicop[ulRop2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\solidfil.c ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: solidfil.c
*
* Contains grab bag collection of hardware acceleration entry points.
*
* Note, we will be moving several of the routines in this file to there
* modle leaving only the solid fill related entry points.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"

// The shift equations are a nuisance. We want x<<32 to be
// zero but some processors only use the bottom 5 bits
// of the shift value. So if we want to shift by n bits
// where we know that (32 >= n > 0), we do it in two parts.
// In some places the algorithm guarantees n < 32 so we can
// use a single shift.
#define SHIFT_LEFT(src, n)  (((src) << ((n)-1)) << 1)

VOID
vMonoBitsDownload(PPDev   ppdev,
                  BYTE*   pSrcBase,       // ptr to word containing first bit we want to download
                  LONG    lSrcDelta,      // offset in bytes from one scanline to the next
                  LONG    xOffset,        // offset of first bit to download in pSrcBase 
                  LONG    widthInBits,    // number of bits to download on each scanline
                  LONG    nScanLines)     // number of scanlines to download

{
    ULONG   bitWord;
    ULONG   bitMask;
    ULONG   bits;
    LONG    unused;
    LONG    nStart;
    LONG    nRemainder;
    LONG    nBits;
    ULONG   *pSrc;

    ULONG*          pBuffer;
    ULONG*          pReservationEnd;
    ULONG*          pBufferEnd;

    InputBufferStart(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                      &pBuffer, &pBufferEnd, &pReservationEnd);
    
    DBG_GDI((6, "vDoMonoBitsDownload called"));
    ASSERTDD(((INT_PTR)pSrcBase & 3) == 0,
             "vDoMonoBitsDownload: non-dword aligned source");

    //
    // Special case where the source width is a multiple of 32 bits.
    // This is true for many small resources such as icons.
    //
    if ( (xOffset | (widthInBits & 31)) == 0 )
    {

        //
        // Simplest case: one 32 bit word per scanline
        //
        if ( widthInBits == 32 )
        {
            
            *pBuffer++ = ((nScanLines - 1) << 16)
                       | __Permedia2TagBitMaskPattern;

            do
            {
                LSWAP_BYTES(bits, pSrcBase);
                *pBuffer++ = bits;
                if(pBuffer == pReservationEnd)
                {
                    InputBufferContinue(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                                      &pBuffer, &pBufferEnd, &pReservationEnd);
                }
                pSrcBase += lSrcDelta;
            } while ( --nScanLines > 0 );
            
            InputBufferCommit(ppdev, pBuffer);
            
            return;
        }

        //
        // Multiple 32 bit words per scanline. convert the delta to the
        // delta as we need it at the end of each line by subtracting the
        // width in bytes of the data we're downloading. Note, pSrcBase
        // is always 1 LONG short of the end of the line because we break
        // before adding on the last ULONG. Thus, we subtract sizeof(ULONG)
        // from the original adjustment.
        //

        LONG    widthInLongs = widthInBits >> 5;

        do {

            LONG    lLongs = widthInLongs;
            ULONG*  src = (ULONG *) pSrcBase;
            
            *pBuffer++ = ((lLongs - 1) << 16)
                       | __Permedia2TagBitMaskPattern;
            
            if(pBuffer == pReservationEnd)
            {
                InputBufferContinue(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                                  &pBuffer, &pBufferEnd, &pReservationEnd);
            }
            
            do
            {
                LSWAP_BYTES(bits, src);
                *pBuffer++ = bits;
                if(pBuffer == pReservationEnd)
                {
                    InputBufferContinue(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                                      &pBuffer, &pBufferEnd, &pReservationEnd);
                }
                src++;
            } while( --lLongs > 0);
            
            pSrcBase += lSrcDelta;

        } while(--nScanLines > 0);

        InputBufferCommit(ppdev, pBuffer);
        
        return;

    }

    //
    // Some common values at the start of each scanline:
    // bitWord: collect bits in this ulong and write out when full
    // unused: number of bits left to fill in bitWord
    // nStart = number of valid bits in the first longword
    // nRemainder = number of bits on scanline minus nStart
    //
    bitWord = 0;
    unused = 32;
    nStart = 32 - xOffset;
    nRemainder = widthInBits - nStart;

    //
    // We special case where the complete set of bits on a scanline
    // is contained in the first ulong.
    //
//@@BEGIN_DDKSPLIT
    //TODO: We should be able to clean this up a little.  It would be
    //      nice to be able to calculate the number of bit masks we
    //      will be sending enabling us to use the dma hold method
    //      for all cases.
//@@END_DDKSPLIT

    if ( nRemainder <= 0 )
    {
        nBits = -nRemainder;              // number of invalid bits on right
        bitMask = (1 << widthInBits) - 1; // widthInBits == 32 is handled above
        pSrc = (ULONG *)pSrcBase;
        
        while ( TRUE )
        {
            LSWAP_BYTES(bits, pSrc);
            bits = (bits >> nBits) & bitMask;
            unused -= widthInBits;
            if ( unused > 0 )
            {
                bitWord |= bits << unused;
            }
            else
            {
                bitWord |= bits >> -unused;
                
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;
                pBuffer += 2;
                
                unused += 32;
                bitWord = SHIFT_LEFT(bits, unused);
            }

            //
            // Break will generate an extra jump
            //
            if ( --nScanLines == 0 )
            {
                goto completeDownload;
            }

            pSrc = (ULONG *) (((UCHAR *)pSrc) + lSrcDelta);
        }
    }// if ( nRemainder <= 0 )
    else
    {
        //
        // Use bitMask to zero left edge bits in first long
        //
        bitMask = SHIFT_LEFT(1, nStart) - 1;
        while ( TRUE )
        {
            //
            // Read the first word from this scanline of the bitmap
            // and mask out the lefthand offset bits if any.
            //
            nBits = nRemainder;
            pSrc = (ULONG *)pSrcBase;

            LSWAP_BYTES(bits, pSrc);
            bits &= bitMask;

            //
            // Handle the left hand edge
            //
            unused -= nStart;
            if ( unused > 0 )
            {
                bitWord |= bits << unused;
            }
            else
            {
                bitWord |= bits >> -unused;
                
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;
                pBuffer += 2;
                
                unused += 32;
                bitWord = SHIFT_LEFT(bits, unused);
            }

            //
            // Handle all the full longs in the middle, if any
            //
            while ( nBits >= 32 )
            {
                ++pSrc;
                LSWAP_BYTES(bits, pSrc);
                bitWord |= bits >> (32 - unused);
                
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;
                pBuffer += 2;
                
                bitWord = SHIFT_LEFT(bits, unused);
                nBits -= 32;
            }

            //
            // Handle the right hand edge, if any
            //
            if ( nBits > 0 )
            {
                ++pSrc;
                LSWAP_BYTES(bits, pSrc);
                bits >>= (32 - nBits);
                unused -= nBits;
                if ( unused > 0 )
                {
                    bitWord |= bits << unused;
                }
                else
                {
                    bitWord |= bits >> -unused;

                    InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                    pBuffer[0] = __Permedia2TagBitMaskPattern;
                    pBuffer[1] = bitWord;
                    pBuffer += 2;

                    unused += 32;
                    bitWord = SHIFT_LEFT(bits, unused);
                }
            }

            if ( --nScanLines == 0 )
            {
                goto completeDownload;
            }

            //
            // go onto next scanline
            //
            pSrcBase += lSrcDelta;
        }
    }

completeDownload:
    
    //
    // Write out final, partial bitWord if any
    //
    if ( unused < 32 )
    {
        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
        pBuffer[0] = __Permedia2TagBitMaskPattern;
        pBuffer[1] = bitWord;
        pBuffer += 2;
    }

    InputBufferCommit(ppdev, pBuffer);

}// vDoMonoBitsDownload()

//-----------------------------------------------------------------------------
//
// void vMonoDownload(GFNPB * ppb)
//
// Dowload the monochrome source from system memory to video memory using
// provided source to destination rop2.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psoSrc------Source SURFOBJ
//  psurfDst----Destination Surf
//  lNumRects---Number of rectangles to fill
//  pptlSrc-----Source point
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  pxlo--------XLATEOBJ
//  usRop4------Rop to be performed
//
//-----------------------------------------------------------------------------

VOID
vMonoDownload(GFNPB * ppb)
{
    PDev*       ppdev = ppb->ppdev;
    RECTL*      prcl = ppb->pRects;
    LONG        count = ppb->lNumRects;
    SURFOBJ*    psoSrc = ppb->psoSrc;
    POINTL*     pptlSrc = ppb->pptlSrc;
    RECTL*      prclDst = ppb->prclDst;
    XLATEOBJ *  pxlo = ppb->pxlo;
    ULONG       logicop = ulRop2ToLogicop((unsigned char)(ppb->ulRop4 & 0xf));
    DWORD       dwBitMask;

    PERMEDIA_DECL_VARS;
    PERMEDIA_DECL_INIT;

    ASSERTDD(count > 0, "Can't handle zero rectangles");

    if ( ppb->ulRop4 == 0xB8B8 )
    {
        dwBitMask = permediaInfo->RasterizerMode
                  | INVERT_BITMASK_BITS;
        logicop = K_LOGICOP_COPY;
    }
    else if ( ppb->ulRop4 == 0xE2E2 )
    {
        dwBitMask = permediaInfo->RasterizerMode;
        logicop = K_LOGICOP_COPY;
    }
    else
    {
        dwBitMask = permediaInfo->RasterizerMode | FORCE_BACKGROUND_COLOR;
    }

    ULONG*          pBuffer;

    InputBufferReserve(ppdev, 14, &pBuffer);

    pBuffer[0] = __Permedia2TagFBReadMode;
    pBuffer[1] = PM_FBREADMODE_PARTIAL(ppb->psurfDst->ulPackedPP)
               | LogicopReadDest[logicop];
    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] = P2_ENABLED_LOGICALOP(logicop);
    pBuffer[4] = __Permedia2TagColorDDAMode;
    pBuffer[5] = __COLOR_DDA_FLAT_SHADE;
    pBuffer[6] = __Permedia2TagConstantColor;
    pBuffer[7] = pxlo->pulXlate[1];  
    pBuffer[8] = __Permedia2TagTexel0;
    pBuffer[9] = pxlo->pulXlate[0];  
    pBuffer[10] = __Permedia2TagFBWindowBase;
    pBuffer[11] = ppb->psurfDst->ulPixOffset;
    pBuffer[12] = __Permedia2TagRasterizerMode;
    pBuffer[13] = dwBitMask;

    pBuffer += 14;

    InputBufferCommit(ppdev, pBuffer);

    while (count--) {
        LONG    xOffset;
        BYTE*   pjSrc;

        // calc x pixel offset from origin
        xOffset = pptlSrc->x + (prcl->left - prclDst->left);
        
        // pjSrc is first dword containing a bit to download
        pjSrc = (BYTE*)((INT_PTR)((PUCHAR) psoSrc->pvScan0
              + ((pptlSrc->y  + (prcl->top - prclDst->top)) * psoSrc->lDelta)
              + ((xOffset >> 3) & ~3)));

        // pjSrc gets us to the first DWORD. Convert xOffset to be the offset
        // to the first pixel in the first DWORD
        xOffset &= 0x1f;

        InputBufferReserve(ppdev, 10, &pBuffer);
        
        // set up the destination rectangle
        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] = INTtoFIXED(prcl->left);
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] = INTtoFIXED(prcl->right);
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] = INTtoFIXED(prcl->top);
        pBuffer[6] = __Permedia2TagCount;
        pBuffer[7] = prcl->bottom - prcl->top;
        pBuffer[8] = __Permedia2TagRender;
        pBuffer[9] = __RENDER_TRAPEZOID_PRIMITIVE 
                   | __RENDER_SYNC_ON_BIT_MASK;

        pBuffer += 10;

        InputBufferCommit(ppdev, pBuffer);

        vMonoBitsDownload(
            ppdev, pjSrc, psoSrc->lDelta, xOffset, 
            prcl->right - prcl->left, prcl->bottom - prcl->top);

        prcl++;

    }

    InputBufferReserve(ppdev, 4, &pBuffer);
    
    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] = __PERMEDIA_DISABLE;
    pBuffer[2] = __Permedia2TagRasterizerMode;
    pBuffer[3] = permediaInfo->RasterizerMode;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);
}

//-----------------------------------------------------------------------------
//
// void vGradientFillRect(GFNPB * ppb)
//
// Shades the specified primitives.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  ulMode------Specifies the current drawing mode and how to interpret the
//              array to which pMesh points
//  ptvrt-------Points to an array of TRIVERTEX structures, with each entry
//              containing position and color information.
//  ulNumTvrt---Specifies the number of TRIVERTEX structures in the array to
//              which pVertex points
//  pvMesh------Points to an array of structures that define the connectivity
//              of the TRIVERTEX elements to which ptvrt points
//  ulNumMesh---Specifies the number of elements in the array to which pvMesh
//              points
//
//-----------------------------------------------------------------------------
VOID
vGradientFillRect(GFNPB * ppb)
{
    Surf *          psurfDst = ppb->psurfDst;
    RECTL*          prcl = ppb->pRects;
    LONG            c = ppb->lNumRects;
    PPDev           ppdev = psurfDst->ppdev;
    DWORD           windowBase = psurfDst->ulPixOffset;
    TRIVERTEX       *ptvrt = ppb->ptvrt;
    GRADIENT_RECT   *pgr;
    GRADIENT_RECT   *pgrSentinel = ((GRADIENT_RECT *) ppb->pvMesh)
                                 + ppb->ulNumMesh;
    LONG            xShift;
    LONG            yShift;
    ULONG*          pBuffer;

    DBG_GDI((10, "vGradientFillRect"));


    // setup loop invariant state

    InputBufferReserve(ppdev, 14, &pBuffer);


    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = __PERMEDIA_DISABLE;
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE) |
                 (1 << PM_DITHERMODE_DITHERENABLE);
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = PM_FBREADMODE_PARTIAL(ppb->psurfDst->ulPackedPP) |
                 PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
    pBuffer[6] = __Permedia2TagFBWindowBase;
    pBuffer[7] =  windowBase;
    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] = __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagColorDDAMode;
    pBuffer[11] = 3;
    pBuffer[12] = __Permedia2TagdY;
    pBuffer[13] = 1 << 16;

    pBuffer += 14;
//@@BEGIN_DDKSPLIT
    // TODO: This code can be cleaned up a little
    //       1. the delta values should not change with each rectangle
    //       2. we can use the render rectangle primitive
//@@END_DDKSPLIT    
    InputBufferCommit(ppdev, pBuffer);

    while(c--)
    {
        
        pgr = (GRADIENT_RECT *) ppb->pvMesh;

        while(pgr < pgrSentinel)
        {
            TRIVERTEX   *ptrvtLr = ptvrt + pgr->LowerRight;
            TRIVERTEX   *ptrvtUl = ptvrt + pgr->UpperLeft;
            LONG        rd;
            LONG        gd;
            LONG        bd;
            LONG        dx;
            LONG        dy;
            RECTL       rect;
            LONG        rdx;
            LONG        rdy;
            LONG        gdx;
            LONG        gdy;
            LONG        bdx;
            LONG        bdy;
            LONG        rs;
            LONG        gs;
            LONG        bs;
            LONG        lTemp;
            BOOL        bReverseH = FALSE;
            BOOL        bReverseV = FALSE;

            rect.left = ptrvtUl->x;
            rect.right = ptrvtLr->x;
            rect.top = ptrvtUl->y;
            rect.bottom = ptrvtLr->y;
            
            if ( rect.left > rect.right )
            {
                //
                // The fill is from right to left. So we need to swap
                // the rectangle coordinates
                //
                lTemp = rect.left;
                rect.left = rect.right;
                rect.right = lTemp;

                bReverseH = TRUE;
            }

            if ( rect.top > rect.bottom )
            {
                //
                // The coordinate is from bottom to top. So we need to swap
                // the rectangle coordinates
                //
                lTemp = rect.top;
                rect.top = rect.bottom;
                rect.bottom = lTemp;

                bReverseV = TRUE;
            }

            //
            // We need to set start color and color delta according to the
            // rectangle drawing direction
            //
            if( (ppb->ulMode == GRADIENT_FILL_RECT_H) && (bReverseH == TRUE)
              ||(ppb->ulMode == GRADIENT_FILL_RECT_V) && (bReverseV == TRUE) )
            {
                rd = (ptrvtUl->Red - ptrvtLr->Red) << 7;
                gd = (ptrvtUl->Green - ptrvtLr->Green) << 7;
                bd = (ptrvtUl->Blue - ptrvtLr->Blue) << 7;

                rs = ptrvtLr->Red << 7;
                gs = ptrvtLr->Green << 7;
                bs = ptrvtLr->Blue << 7;
            }
            else
            {
                rd = (ptrvtLr->Red - ptrvtUl->Red) << 7;
                gd = (ptrvtLr->Green - ptrvtUl->Green) << 7;
                bd = (ptrvtLr->Blue - ptrvtUl->Blue) << 7;

                rs = ptrvtUl->Red << 7;
                gs = ptrvtUl->Green << 7;
                bs = ptrvtUl->Blue << 7;
            }
            
            // quick clipping reject
            if(prcl->left >= rect.right ||
               prcl->right <= rect.left ||
               prcl->top >= rect.bottom ||
               prcl->bottom <= rect.top)
                goto nextPgr;

            dx = rect.right - rect.left;
            dy = rect.bottom - rect.top;

            if(ppb->ulMode == GRADIENT_FILL_RECT_H)
            {
                rdx = rd / dx;
                gdx = gd / dx;
                bdx = bd / dx;

                rdy = 0;
                gdy = 0;
                bdy = 0;
            }
            else
            {
                rdy = rd / dy;
                gdy = gd / dy;
                bdy = bd / dy;

                rdx = 0;
                gdx = 0;
                bdx = 0;
            }

            //
            // Convert from 9.15 to 9.11 format. The Permedia2
            // dRdx, dGdx etc. registers using 9.11 fixed format. The bottom 4
            // bits are not used.
            //
            rdx &= ~0xf;
            gdx &= ~0xf;
            bdx &= ~0xf;
            rdy &= ~0xf;
            gdy &= ~0xf;
            bdy &= ~0xf;

            // now perform some clipping adjusting start values as necessary
            xShift = prcl->left - rect.left;
            if(xShift > 0)
            {
                rs = rs + (rdx * xShift);
                gs = gs + (gdx * xShift);
                bs = bs + (bdx * xShift);
                rect.left = prcl->left;                
            }

            yShift = prcl->top - rect.top;
            if(yShift > 0)
            {
                rs = rs + (rdy * yShift);
                gs = gs + (gdy * yShift);
                bs = bs + (bdy * yShift);
                rect.top = prcl->top;
            }

            // just move up the bottom right as necessary
            if(prcl->right < rect.right)
                rect.right = prcl->right;

            if(prcl->bottom < rect.bottom)
                rect.bottom = prcl->bottom;
            
            InputBufferReserve(ppdev, 28, &pBuffer);
            
            pBuffer[0] = __Permedia2TagRStart;
            pBuffer[1] = rs;
            pBuffer[2] = __Permedia2TagGStart;
            pBuffer[3] = gs;
            pBuffer[4] = __Permedia2TagBStart;
            pBuffer[5] = bs;

            pBuffer[6] = __Permedia2TagdRdx;
            pBuffer[7] = rdx;
            pBuffer[8] = __Permedia2TagdRdyDom;
            pBuffer[9] = rdy;
            pBuffer[10] = __Permedia2TagdGdx;
            pBuffer[11] = gdx;
            pBuffer[12] = __Permedia2TagdGdyDom;
            pBuffer[13] = gdy;
            pBuffer[14] = __Permedia2TagdBdx;
            pBuffer[15] = bdx;
            pBuffer[16] = __Permedia2TagdBdyDom;
            pBuffer[17] = bdy;

            // NOTE: alpha is always constant


            // Render the rectangle

            pBuffer[18] = __Permedia2TagStartXDom;
            pBuffer[19] = rect.left << 16;
            pBuffer[20] = __Permedia2TagStartXSub;
            pBuffer[21] = rect.right << 16;
            pBuffer[22] = __Permedia2TagStartY;
            pBuffer[23] = rect.top << 16;
            pBuffer[24] = __Permedia2TagCount;
            pBuffer[25] = rect.bottom - rect.top;

            pBuffer[26] = __Permedia2TagRender;
            pBuffer[27] = __RENDER_TRAPEZOID_PRIMITIVE;


            pBuffer += 28;

            InputBufferCommit(ppdev, pBuffer);

        nextPgr:

            pgr++;
    
        }

        prcl++;

    }

    InputBufferReserve(ppdev, 6, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] = INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = 0;
    pBuffer[4] = __Permedia2TagColorDDAMode;
    pBuffer[5] = 0;
    
    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

}// vGradientFillRect()

//-----------------------------------------------------------------------------
//
// void vTransparentBlt(GFNPB * ppb)
//
// Provides bit-block transfer capabilities with transparency.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  colorKey----Specifies the transparent color in the source surface format.
//              It is a color index value that has been translated to the
//              source surface's palette.
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//
//-----------------------------------------------------------------------------
VOID
vTransparentBlt(GFNPB * ppb)
{
    Surf * psurfDst = ppb->psurfDst;
    Surf * psurfSrc = ppb->psurfSrc;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclSrc = ppb->prclSrc;
    RECTL*  prclDst = ppb->prclDst;
    DWORD   colorKey = ppb->colorKey;
    PPDev   ppdev = psurfDst->ppdev;
    DWORD   windowBase = psurfDst->ulPixOffset;
    LONG    sourceOffset = psurfSrc->ulPixOffset;
    DWORD   dwRenderDirection;
    DWORD   format = ppdev->ulPermFormat;
    DWORD   extension = ppdev->ulPermFormatEx;
    DWORD   dwLowerBound;
    DWORD   dwUpperBound;
    ULONG*  pBuffer;

    DBG_GDI((6, "vTransparentBlt"));

    ASSERTDD(prclSrc->right - prclSrc->left == (prclDst->right - prclDst->left),
                "vTransparentBlt: expect one-to-one blts only");
    
    ASSERTDD(prclSrc->bottom - prclSrc->top == (prclDst->bottom - prclDst->top),
                "vTransparentBlt: expect one-to-one blts only");
//@@BEGIN_DDKSPLIT
    // TODO: should call utility function to format color key
//@@END_DDKSPLIT
    if (format == PERMEDIA_8BIT_PALETTEINDEX)
    {
        colorKey = FORMAT_PALETTE_32BIT(colorKey);
        dwLowerBound = CHROMA_LOWER_ALPHA(colorKey);
        dwUpperBound = CHROMA_UPPER_ALPHA(colorKey);
    }
    else if(ppdev->ulPermFormat == PERMEDIA_565_RGB)
    {
        colorKey = FORMAT_565_32BIT_BGR(colorKey);
        dwLowerBound = CHROMA_LOWER_ALPHA(colorKey);
        dwUpperBound = CHROMA_UPPER_ALPHA(colorKey);
        dwLowerBound = dwLowerBound & 0xF8F8FCF8;
        dwUpperBound = dwUpperBound | 0x07070307;
    }
    else
    {
        colorKey = FORMAT_8888_32BIT_BGR(colorKey);
        dwLowerBound = CHROMA_LOWER_ALPHA(colorKey);
        dwUpperBound = CHROMA_UPPER_ALPHA(colorKey);
    }
    
    // setup loop invariant state

    InputBufferReserve(ppdev, 24, &pBuffer);
    
    // Reject range
    pBuffer[0] = __Permedia2TagYUVMode;
    pBuffer[1] = 0x2 << 1;
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = windowBase;

    // set no read of source.
    // add read src/dest enable
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = psurfDst->ulPackedPP;
    pBuffer[6] = __Permedia2TagLogicalOpMode;
    pBuffer[7] = __PERMEDIA_DISABLE;

     // set base of source
    pBuffer[8] = __Permedia2TagTextureBaseAddress;
    pBuffer[9] = sourceOffset;
    pBuffer[10] = __Permedia2TagTextureAddressMode;
    pBuffer[11] = 1 << PM_TEXADDRESSMODE_ENABLE;
    //
    // modulate & ramp??
    pBuffer[12] = __Permedia2TagTextureColorMode;
    pBuffer[13] = (1 << PM_TEXCOLORMODE_ENABLE) |
                  (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION);

    pBuffer[14] = __Permedia2TagTextureReadMode;
    pBuffer[15] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                  PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                  PM_TEXREADMODE_WIDTH(11) |
                  PM_TEXREADMODE_HEIGHT(11);

    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] = (format << PM_TEXDATAFORMAT_FORMAT) |
                  (extension << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                  (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);

    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] = (psurfSrc->ulPackedPP) | 
                  (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);


    pBuffer[20] = __Permedia2TagChromaLowerBound;
    pBuffer[21] = dwLowerBound;
    pBuffer[22] = __Permedia2TagChromaUpperBound;
    pBuffer[23] = dwUpperBound;
    
    pBuffer += 24;

    InputBufferCommit(ppdev, pBuffer);
    
    if (format != PERMEDIA_8BIT_PALETTEINDEX)
    {

        InputBufferReserve(ppdev, 2, &pBuffer);

        // Reject range
        pBuffer[0] = __Permedia2TagDitherMode;
        pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                     (format << PM_DITHERMODE_COLORFORMAT) |
                     (extension << PM_DITHERMODE_COLORFORMATEXTENSION) |
                     (1 << PM_DITHERMODE_ENABLE);

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }

    while(c--) {

        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        
        rSrc.left = prclSrc->left + (rDest.left - prclDst->left);
        rSrc.top = prclSrc->top + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }

        if ((psurfSrc->ulPixOffset) != (psurfDst->ulPixOffset))
        {
            dwRenderDirection = 1;
        }
        else
        {
            if(rSrc.top < rDest.top)
            {
                dwRenderDirection = 0;
            }
            else if(rSrc.top > rDest.top)
            {
                dwRenderDirection = 1;
            }
            else if(rSrc.left < rDest.left)
            {
                dwRenderDirection = 0;
            }
            else dwRenderDirection = 1;
        }
    
        InputBufferReserve(ppdev, 24, &pBuffer);

        
        // Left -> right, top->bottom
        if (dwRenderDirection)
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] = rSrc.left << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] = rSrc.top << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] = 1 << 20;
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] = 0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] = 0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] = 1 << 20;
    
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] = rDest.left << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] = rDest.right << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] = rDest.top << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] = 1 << 16;
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] = rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE |
                          __RENDER_TEXTURED_PRIMITIVE;
        }
        else
        // right->left, bottom->top
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] = rSrc.right << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] = (rSrc.bottom - 1) << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] = (DWORD) (-1 << 20);
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] = 0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] = 0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] = (DWORD)(-1 << 20);
    
            // Render right to left, bottom to top
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] = rDest.right << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] = rDest.left << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] = (rDest.bottom - 1) << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] = (DWORD)(-1 << 16);
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] = rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE |
                          __RENDER_TEXTURED_PRIMITIVE;
        }

        pBuffer += 24;
    
        InputBufferCommit(ppdev, pBuffer);

        prcl++;
    }

    // restore default state

    InputBufferReserve(ppdev, 12, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = 0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] = 0x0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] = __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] = __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] = __PERMEDIA_DISABLE;

    pBuffer += 12;

    InputBufferCommit(ppdev,pBuffer);

}// vTransparentBlt()

//-----------------------------------------------------------------------------
//
// void vSolidFill(GFNPB* ppb)
//
// Fill a set of rectangles with a solid color
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  solidColor--Fill color
//
//-----------------------------------------------------------------------------
VOID
vSolidFill(GFNPB * ppb)
{
    PPDev   ppdev = ppb->ppdev;
    ULONG   color = ppb->solidColor;
    RECTL * pRect = ppb->pRects;
    LONG    count = ppb->lNumRects;
    Surf*   psurf = ppb->psurfDst;
//@@BEGIN_DDKSPLIT    
    // TODO should call utility function to setup fill color
//@@END_DDKSPLIT

    //
    // Note: GDI guarantees that the unused bits are set to zero. We have
    // an assert in DrvBitBlt to check the color value for unused high bits
    // to make it sure that they are zero.
    //
    if (ppdev->cPelSize == 1)
    {
        color |= (color << 16);
    }
    else if (ppdev->cPelSize == 0)
    {
        color |= color << 8;
        color |= color << 16;
    }

    //
    // setup loop invariant state
    //
    ULONG*          pBuffer;
    ULONG*          pReservationEnd;
    ULONG*          pBufferEnd;

    InputBufferStart(ppdev, 8, &pBuffer, &pBufferEnd, &pReservationEnd);
    
    pBuffer[0] = __Permedia2TagFBBlockColor;
    pBuffer[1] = color;
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                 PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] = __PERMEDIA_CONSTANT_FB_WRITE;
    pBuffer[6] = __Permedia2TagFBWindowBase;
    pBuffer[7] = psurf->ulPixOffset;

    while(count--)
    {

        // Render the rectangle

        pBuffer = pReservationEnd;
        
        InputBufferContinue(ppdev, 6, &pBuffer, &pBufferEnd, &pReservationEnd);

        pBuffer[0] = __Permedia2TagRectangleOrigin;
        pBuffer[1] = pRect->top << 16 | pRect->left;
        pBuffer[2] = __Permedia2TagRectangleSize;
        pBuffer[3] = ((pRect->bottom - pRect->top) << 16) |
                     (pRect->right - pRect->left);
        pBuffer[4] = __Permedia2TagRender;
        pBuffer[5] = __RENDER_FAST_FILL_ENABLE | __RENDER_RECTANGLE_PRIMITIVE |
                    __RENDER_INCREASE_X | __RENDER_INCREASE_Y;

        pRect++;

    }

    pBuffer = pReservationEnd;

    InputBufferCommit(ppdev, pBuffer);

}// vSolidFill()

//-----------------------------------------------------------------------------
//
// VOID vInvert
//
// Fill a set of rectangles with a solid color 
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Pointer to device surface
//  lNumRects---Number of clipping rectangles
//  pRect-------Array of clipping rectangles
//
//-----------------------------------------------------------------------------
VOID
vInvert(GFNPB * ppb)
{
    PPDev   ppdev = ppb->ppdev;
    RECTL * pRect = ppb->pRects;
    LONG    count = ppb->lNumRects;
    Surf*   psurf = ppb->psurfDst;
    ULONG*  pBuffer;

    // setup loop invariant state

    InputBufferReserve(ppdev, 6, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] = psurf->ulPixOffset;
    
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                 PM_FBREADMODE_READDEST(__PERMEDIA_ENABLE);

    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] = P2_ENABLED_LOGICALOP(K_LOGICOP_INVERT);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    while(count--)
    {

        // Render the rectangle
    
        InputBufferReserve(ppdev, 6, &pBuffer);
        
        pBuffer[0] = __Permedia2TagRectangleOrigin;
        pBuffer[1] = (pRect->top << 16) | pRect->left;
        pBuffer[2] = __Permedia2TagRectangleSize;
        pBuffer[3] = ((pRect->bottom - pRect->top) << 16) 
                   | (pRect->right - pRect->left);
        pBuffer[4] = __Permedia2TagRender;
        pBuffer[5] = __RENDER_RECTANGLE_PRIMITIVE
                   | __RENDER_INCREASE_X
                   | __RENDER_INCREASE_Y;
    
        pBuffer += 6;
        
        InputBufferCommit(ppdev, pBuffer);

        pRect++;

    }

}// vInvert()

//-----------------------------------------------------------------------------
//
// void vSolidFillWithRop(GFNPB* ppb)
//
// Fill a set of rectangles with a solid color based on the given lLogicOP.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  solidColor--Fill color
//  ulRop4------Logic OP for the fill
//
//-----------------------------------------------------------------------------
//@@BEGIN_DDKSPLIT
        // TODO:  Some clean up: Why are we calculating lLeft andn lRight
        // but use pRcl->left and pRcl->right below.
//@@END_DDKSPLIT
VOID
vSolidFillWithRop(GFNPB* ppb)
{
    PPDev   ppdev = ppb->ppdev;
    Surf*   psurfDst = ppb->psurfDst;    
    
    DWORD   dwExtra = 0;
    DWORD   dwRenderBits;    
    DWORD   dwShift = 0;
    DWORD   dwWindowBase = psurfDst->ulPixOffset;
    
    LONG    lLeft;
    LONG    lNumOfRects = ppb->lNumRects;       // Number of rectangles
    LONG    lRight;
    
    RECTL*  pRcl = ppb->pRects;
    ULONG   ulColor = ppb->solidColor;          // Brush solid fill color
    ULONG   ulLogicOP = ulRop3ToLogicop(ppb->ulRop4 & 0xFF);
                                                // Hardware mix mode
                                                // (foreground mix mode if
                                                // the brush has a mask)
    ULONG*  pBuffer;


    DBG_GDI((6,"vSolidFillWithRop: numRects = %ld Rop4 = 0x%x",
            lNumOfRects, ppb->ulRop4));
    
    //
    // Setup logic OP invariant state
    //

    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] = dwWindowBase;
    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);
    
     switch ( ulLogicOP )
    {
        case K_LOGICOP_COPY:
            DBG_GDI((6,"vSolidFillWithRop: COPY"));

            //
            // For SRC_COPY, we can use fastfill
            //
            dwRenderBits = __RENDER_FAST_FILL_ENABLE
                         | __RENDER_TRAPEZOID_PRIMITIVE
                         | __RENDER_INCREASE_Y
                         | __RENDER_INCREASE_X;


            //
            // Setup color data based on current color mode we are in
            //
            if ( ppdev->cPelSize == 1 )
            {
                //
                // We are in 16 bit packed mode. So the color data must be
                // repeated in both halves of the FBBlockColor register
                //
                ASSERTDD((ulColor & 0xFFFF0000) == 0,
                          "vSolidFillWithRop: upper bits not zero");
                ulColor |= (ulColor << 16);
            }
            else if ( ppdev->cPelSize == 0 )
            {
                //
                // We are in 8 bit packed mode. So the color data must be
                // repeated in all 4 bytes of the FBBlockColor register
                //
                ASSERTDD((ulColor & 0xFFFFFF00) == 0,
                          "vSolidFillWithRop: upper bits not zero");
                ulColor |= ulColor << 8;
                ulColor |= ulColor << 16;
            }
                    
            //
            // Setup some loop invariant states
            //
            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_CONSTANT_FB_WRITE;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                       | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
            pBuffer[4] = __Permedia2TagFBBlockColor;
            pBuffer[5] = ulColor;
            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);

            break;

        case K_LOGICOP_INVERT:
            DBG_GDI((6,"vSolidFillWithRop: INVERT"));

            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                         | __RENDER_INCREASE_Y
                         | __RENDER_INCREASE_X;
            
            //
            // When using packed operations we have to convert the left and
            // right X coordinates into 32-bit-based quantities, we do this by
            // shifting. We also have to round up the right X co-ord if the
            // pixels don't fill a DWORD. Not a problem for 32BPP.
            //
            dwShift = 2 - (ppdev->cPelSize);

            if ( dwShift )
            {
                dwExtra = (dwShift << 1) - 1;
            }
            else
            {
                dwExtra = 0;
            }

            //
            // setup some loop invariant states
            //

            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_DISABLE;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                       | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
            pBuffer[4] = __Permedia2TagConfig;
            pBuffer[5] = __PERMEDIA_CONFIG_LOGICOP(ulLogicOP)
                                     | __PERMEDIA_CONFIG_FBWRITE
                                     | __PERMEDIA_CONFIG_PACKED_DATA
                                     | ConfigReadDest[ulLogicOP];
            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);

            break;

        default:

            DBG_GDI((6,"vSolidFillWithRop: numRects %ld, Rop4=0x%x color=0x%lx",
                lNumOfRects, ppb->ulRop4, ulColor));

            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                         | __RENDER_INCREASE_Y
                         | __RENDER_INCREASE_X;
            
            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_DISABLE;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP);
            pBuffer[4] = __Permedia2TagConstantColor;
            pBuffer[5] = ulColor;
            pBuffer[6] = __Permedia2TagConfig;
            pBuffer[7] = __PERMEDIA_CONFIG_LOGICOP(ulLogicOP)
                                     | __PERMEDIA_CONFIG_FBWRITE
                                     | __PERMEDIA_CONFIG_COLOR_DDA
                                     | ConfigReadDest[ulLogicOP];
            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            break;
    }// switch( ulLogicOP )   

    //
    // Loop through all the rectangles and fill them
    //
    for(;;) 
    {
        
        //
        // Calculate the left and right pixels from the rectangle.
        //
        lLeft = pRcl->left;
        lRight = pRcl->right;

        InputBufferReserve(ppdev, 12, &pBuffer);

        //
        // If we need to set up the packed data limits then do it, also convert
        // the left and right X coordinates to DWORD-based numbers, with a bit
        // of rounding
        //
        if ( ulLogicOP == K_LOGICOP_INVERT )
        {
            pBuffer[0] = __Permedia2TagPackedDataLimits;
            pBuffer[1] = (lLeft << 16) | lRight;

            pBuffer += 2;
            
            lLeft >>= dwShift;
            lRight = (lRight + dwExtra) >> dwShift;
        }

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] = pRcl->left << 16;
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] = pRcl->right << 16;
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] = pRcl->top << 16;
        pBuffer[6] = __Permedia2TagCount;
        pBuffer[7] = pRcl->bottom - pRcl->top;
        pBuffer[8] = __Permedia2TagRender;
        pBuffer[9] = dwRenderBits;

        pBuffer += 10;

        InputBufferCommit(ppdev, pBuffer);
        
        if ( --lNumOfRects == 0 )
        {
            break;
        }

        //
        // Move onto the next rectangle
        //
        ++pRcl;        
    } // for()

    //
    // Restore the DDA mode
    //
    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] = __PERMEDIA_DISABLE;
    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);
    
}// vSolidFillWithRop()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\registry.c ===
/******************************Module*Header***********************************\
* Module Name: registry.c
*
* Routines to initialize the registry and lookup string values.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#include "precomp.h"
                        
//------------------------------------------------------------------------------
//  BOOL bRegistryQueryUlong
// 
//  Take a string and look up its value in the registry. We assume that the
//  value fits into 4 bytes. Fill in the supplied DWORD pointer with the value.
// 
//  Returns:
//    TRUE if we found the string, FALSE if not. Note, if we failed to init
//    the registry the query funtion will simply fail and we act as though
//    the string was not defined.
// 
//------------------------------------------------------------------------------

BOOL
bRegistryQueryUlong(PPDev ppdev, LPWSTR valueStr, PULONG pData)
{
    ULONG ReturnedDataLength;
    ULONG inSize;
    ULONG outData;
    PWCHAR inStr;
    
    // get the string length including the NULL
    
    for (inSize = 2, inStr = valueStr; *inStr != 0; ++inStr, inSize += 2);

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_REGISTRY_DWORD,
                           valueStr,                  // input buffer
                           inSize,
                           &outData,         // output buffer
                           sizeof(ULONG),
                           &ReturnedDataLength))
    {
        DBG_GDI((1, "bQueryRegistryValueUlong failed"));
        return(FALSE);
    }
    *pData = outData;
    DBG_GDI((1, "bQueryRegistryValueUlong returning 0x%x (ReturnedDataLength = %d)",
                                                        *pData, ReturnedDataLength));
    return(TRUE);
}

//------------------------------------------------------------------------------
//  BOOL bRegistryRetrieveGammaLUT
// 
//  Look up the registry to reload the saved gamma LUT into memory.
// 
//  Returns:
//    TRUE if we found the string, FALSE if not. Note, if we failed to init
//    the registry the query funtion will simply fail and we act as though
//    the string was not defined.
// 
//------------------------------------------------------------------------------

BOOL
bRegistryRetrieveGammaLUT(
    PPDev ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT,
                           NULL,         // input buffer
                           0,
                           pScreenClut,  // output buffer
                           MAX_CLUT_SIZE,
                           &ReturnedDataLength))
    {
        DBG_GDI((1, "IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}

//------------------------------------------------------------------------------
//  BOOL bRegistrySaveGammaLUT
// 
//  Save the gamma lut in the registry for later reloading.
// 
//  Returns:
//    TRUE if we found the string, FALSE if not. Note, if we failed to init
//    the registry the query funtion will simply fail and we act as though
//    the string was not defined.
// 
//------------------------------------------------------------------------------

BOOL
bRegistrySaveGammaLUT(
    PPDev ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_SAVE_GAMMA_LUT,
                           pScreenClut,  // input buffer
                           MAX_CLUT_SIZE,
                           NULL,         // output buffer
                           0,
                           &ReturnedDataLength))
    {
        DBG_GDI((1, "IOCTL_VIDEO_REG_SAVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\strips.c ===
/**********************************Module*Header*******************************\
*  Module Name: Strips.c
* 
*  Hardware line drawing support routines
* 
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"

#define STRIP_LOG_LEVEL 6

//-----------------------------------------------------------------------------
//
//  BOOL bInitializeStrips
// 
//  Setup hardware for sucessive calls to strips functions.
// 
//-----------------------------------------------------------------------------
BOOL
bInitializeStrips(PDev*       ppdev,
                  ULONG       ulSolidColor, // Solid color fill
                  DWORD       dwLogicOp,    // Logical Operation to perform
                  RECTL*      prclClip)     // Clip region (Or NULL if no clip)
{
    DWORD       dwColorReg;
    BOOL        bRC = FALSE;
    Surf*       psurfDst = ppdev->psurf;
    ULONG*      pBuffer;

    PERMEDIA_DECL;

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bInitializeStrips"));
    
    InputBufferReserve(ppdev, 16, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  psurfDst->ulPixOffset;

    pBuffer += 2;

    if ( dwLogicOp == K_LOGICOP_COPY )
    {
        dwColorReg = __Permedia2TagFBWriteData;

        pBuffer[0] = __Permedia2TagLogicalOpMode;
        pBuffer[1] =  __PERMEDIA_CONSTANT_FB_WRITE;
        pBuffer[2] = __Permedia2TagFBReadMode;
        pBuffer[3] =  PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                   | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

        pBuffer += 4;
    }
    else
    {
        DWORD   dwReadMode;
//@@BEGIN_DDKSPLIT
        //
        // TODO: look into what the heck is going on here
        //       for now, I'll remove the code because it is not clear to
        //       me that it will work
//@@END_DDKSPLIT
        // Special case for 3DS Max when page flipping. Max uses an XOR'ed GDI
        // line within the 3d window. When pageflipping we double write GDI and
        // so always write to buffer 0. We need to make sure the frame buffer
        // read happens from the currently displayed buffer.
        //
        dwColorReg = __Permedia2TagConstantColor;
        dwReadMode = psurfDst->ulPackedPP | LogicopReadDest[dwLogicOp];

        pBuffer[0] = __Permedia2TagColorDDAMode;
        pBuffer[1] =  __COLOR_DDA_FLAT_SHADE;
        pBuffer[2] = __Permedia2TagLogicalOpMode;
        pBuffer[3] =  P2_ENABLED_LOGICALOP(dwLogicOp);
        pBuffer[4] = __Permedia2TagFBReadMode;
        pBuffer[5] =  dwReadMode;

        pBuffer += 6;

        //
        // We have changed the DDA Mode setting so we must return TRUE so we can
        // re-set it later.
        //
        bRC = TRUE;
    }

    pBuffer[0] = dwColorReg;
    pBuffer[1] = ulSolidColor;

    pBuffer += 2;

    if ( prclClip )
    {
        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] = SCREEN_SCISSOR_DEFAULT | USER_SCISSOR_ENABLE;
        pBuffer[2] =__Permedia2TagScissorMinXY;
        pBuffer[3] = ((prclClip->left) << SCISSOR_XOFFSET)
                   | ((prclClip->top) << SCISSOR_YOFFSET);
        pBuffer[4] =__Permedia2TagScissorMaxXY;
        pBuffer[5] = ((prclClip->right) << SCISSOR_XOFFSET)
                   | ((prclClip->bottom) << SCISSOR_YOFFSET);

        pBuffer += 6;
        //
        // Need to reset scissor mode
        //
        bRC = TRUE;
    }
                     
    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bInitializeStrips done return %d", bRC));

    return(bRC);
}// bInitializeStrips()

//-----------------------------------------------------------------------------
//
//  VOID vResetStrips
// 
//  Resets the hardware to its default state
// 
//-----------------------------------------------------------------------------
VOID
vResetStrips(PDev* ppdev)
{
    ULONG*      pBuffer;

    DBG_GDI((STRIP_LOG_LEVEL + 1, "vResetStrips"));
    
    //
    // Reset hardware to default state
    //
    InputBufferReserve(ppdev, 4 , &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] =  SCREEN_SCISSOR_DEFAULT;
    pBuffer[2] = __Permedia2TagColorDDAMode;
    pBuffer[3] =  __PERMEDIA_DISABLE;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

}// vResetStrips()

//-----------------------------------------------------------------------------
//
//  BOOL bFastIntegerLine
// 
//  Integer line drawing.
// 
//  Returns FALSE if the line can not be drawn due to hardware limitations
// 
//  NOTE: This algorithm is not completely compliant. Lines > 190 pixels long
//  may get some incorrect pixels plotted somewhere along the length.
//  If we detect these long lines then we fail the call.
//  NOTE: GLICAP_NT_CONFORMANT_LINES will always be set.
// 
//-----------------------------------------------------------------------------
BOOL
bFastIntegerLine(PDev*   ppdev,
                 LONG    X1,
                 LONG    Y1,
                 LONG    X2,
                 LONG    Y2)
{
    LONG dx, dy, adx, ady;
    LONG gdx, gdy, count;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "bFastIntegerLine"));

    //
    // Convert points to INT format
    //
    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    //
    // Get deltas and absolute deltas
    //
    if ( (adx = dx = X2 - X1) < 0 )
    {
        adx = -adx;
    }

    if ( (ady = dy = Y2 - Y1) < 0 )
    {
        ady = -ady;
    }

    if ( adx > ady )
    {
        //
        // X Major line
        //
        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if ( ady == 0 )
        {
            //
            // Horizontal lines
            //
            gdy = 0;
        }// if (ady == 0)
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (adx > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }

            gdy = INTtoFIXED(dy); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dy < 0 )
            {
                gdy -= adx - 1;
            }

            gdy /= adx;
        }// if (ady != 0)
        count = adx;
    }// if ( adx > ady )
    else if ( adx < ady )
    {
        //
        // Y Major line
        //
        gdy  = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if ( adx == 0 )
        {
            //
            // Vertical lines
            //
            gdx = 0;
        }
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (ady > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }

            gdx = INTtoFIXED(dx); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dx < 0 )
            {
                gdx -= ady - 1;
            }

            gdx /= ady; 
        }
        count = ady;
    }// if ( adx < ady )
    else
    {
        //
        // Special case for 45 degree lines. These are always conformant.
        //
        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        gdy  = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        count = adx;        
    }

    InputBufferReserve(ppdev, 16, &pBuffer);

    //
    // Set up the start point
    //
    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =  INTtoFIXED(X1) + NEARLY_HALF;
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =  INTtoFIXED(Y1) + NEARLY_HALF;
    pBuffer[4] = __Permedia2TagdXDom;
    pBuffer[5] =  gdx;
    pBuffer[6] = __Permedia2TagdY;
    pBuffer[7] =  gdy;
    pBuffer[8] = __Permedia2TagCount;
    pBuffer[9] =  count;
    pBuffer[10] = __Permedia2TagRender;
    pBuffer[11] =  __RENDER_LINE_PRIMITIVE;
    
    pBuffer[12] = __Permedia2TagdXDom;
    pBuffer[13] =  0;
    pBuffer[14] = __Permedia2TagdY;
    pBuffer[15] =  INTtoFIXED(1);

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bFastIntegerLine Done"));

    return(TRUE);
}// bFastIntegerLine()

//-----------------------------------------------------------------------------
//
//  BOOL bFastIntegerContinueLine
// 
//  Integer line drawing through Permedia2.
// 
//  Returns FALSE if the line can not be drawn due to hardware limitations.
// 
//  NOTE: This algorithm is not completely compliant. Lines > 190 pixels long
//  may get some incorrect pixels plotted somewhere along the length.
//  If we detect these long lines then we fail the call.
//  NOTE: GLICAP_NT_CONFORMANT_LINES will always be set.
// 
//-----------------------------------------------------------------------------
BOOL
bFastIntegerContinueLine(PDev*   ppdev,
                         LONG    X1,
                         LONG    Y1,
                         LONG    X2,
                         LONG    Y2)
{
    LONG dx, dy, adx, ady;
    LONG gdx, gdy, count;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "bFastIntegerContinueLine"));

    //
    // This assumes that the end point of the previous line is correct.
    // The Fraction adjust should be set to nearly a half to remove any
    // error from the end point of the previous line.
    // Get deltas and absolute deltas from 28.4 format
    //
    if ( (adx = dx = (X2 - X1) >> 4) < 0 )
    {
        adx = -adx;
    }
    if ( (ady = dy = (Y2 - Y1) >> 4) < 0 )
    {
        ady = -ady;
    }

    if ( adx > ady )
    {
        //
        // X Major line
        //
        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if (ady == 0)
        {
            //
            // Horizontal lines
            //
            gdy = 0;
        }
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (adx > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }
            gdy = INTtoFIXED(dy); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dy < 0 )
            {
                gdy -= adx - 1;
            }

            gdy /= adx;
        }
        count = adx;
    }// if ( adx > ady )
    else if (adx < ady)
    {
        //
        // Y Major line
        //
        gdy = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if ( adx == 0 )
        {
            //
            // Vertical lines
            //
            gdx = 0;
        }
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (ady > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }

            gdx = INTtoFIXED(dx); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dx < 0 )
            {
                gdx -= ady - 1;
            }

            gdx /= ady; 
        }
        count = ady;
    }
    else
    {
        //
        // Special case for 45 degree lines. These are always conformant.
        //
        if ( ady == 0 )
        {
            return(TRUE); // adx == ady == 0! Nothing to draw.
        }

        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        gdy  = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        count = adx;        
    }

    InputBufferReserve(ppdev, 10 , &pBuffer);
    
    //
    // Set up the start point
    //
    DBG_GDI((7, "Loading dXDom 0x%x, dY 0x%x, count 0x%x", gdx, gdy, count));
    
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  gdx;
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  gdy;
    pBuffer[4] = __Permedia2TagContinueNewLine;
    pBuffer[5] =  count;

    //
    // Restore dXDom and dY to their defaults
    //
    pBuffer[6] = __Permedia2TagdXDom;
    pBuffer[7] =  0;
    pBuffer[8] = __Permedia2TagdY;
    pBuffer[9] =  INTtoFIXED(1);

    pBuffer += 10;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bFastIntegerContinueLine Done"));

    return(TRUE);
}// bFastIntegerContinueLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidHorizontal
// 
//  Draws left-to-right x-major near-horizontal lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidHorizontalLine(PDev*       ppdev,
                     STRIP*      pStrip,
                     LINESTATE*  pLineState)
{
    LONG    cStrips;
    PLONG   pStrips;
    LONG    iCurrent;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidHorizontalLine"));

    cStrips = pStrip->cStrips;

    InputBufferReserve(ppdev, 16, &pBuffer);

    //
    // Set up the start point
    //
    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =  INTtoFIXED(pStrip->ptlStart.x);
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =  INTtoFIXED(pStrip->ptlStart.y);

    //
    // Set up the deltas for rectangle drawing. Also set Y return value.
    //
    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {

        pBuffer[4] = __Permedia2TagdXDom;
        pBuffer[5] =  INTtoFIXED(0);
        pBuffer[6] = __Permedia2TagdXSub;
        pBuffer[7] =  INTtoFIXED(0);
        pBuffer[8] = __Permedia2TagdY;
        pBuffer[9] =  INTtoFIXED(1);

        pStrip->ptlStart.y += cStrips;
    }
    else
    {
        pBuffer[4] = __Permedia2TagdXDom;
        pBuffer[5] =  INTtoFIXED(0);
        pBuffer[6] = __Permedia2TagdXSub;
        pBuffer[7] =  INTtoFIXED(0);
        pBuffer[8] = __Permedia2TagdY;
        pBuffer[9] =  INTtoFIXED(-1);

        pStrip->ptlStart.y -= cStrips;
    }

    pStrips = pStrip->alStrips;

    //
    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    //
    iCurrent = pStrip->ptlStart.x + *pStrips++;     // Xsub, Start of next strip
    
    pBuffer[10] = __Permedia2TagStartXSub;
    pBuffer[11] =  INTtoFIXED(iCurrent);
    pBuffer[12] = __Permedia2TagCount;
    pBuffer[13] =  1;                   // Rectangle 1 scanline high
    pBuffer[14] = __Permedia2TagRender;
    pBuffer[15] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    if ( --cStrips )
    {
        while ( cStrips > 1 )
        {
            //
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            //
            iCurrent += *pStrips++;
            
            InputBufferReserve(ppdev, 8, &pBuffer);
            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  1;

            //
            // Second strip of each pair to fill. XDom is valid. Need new XSub
            //
            iCurrent += *pStrips++;
            pBuffer[4] = __Permedia2TagStartXSub;
            pBuffer[5] =  INTtoFIXED(iCurrent);
            pBuffer[6] = __Permedia2TagContinueNewSub;
            pBuffer[7] =  1;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            cStrips -=2;
        }// while ( cStrips > 1 )

        //
        // We may have one last line to draw. Xsub will be valid.
        //
        if ( cStrips )
        {
            iCurrent += *pStrips++;

            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  1;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }
    }// if ( --cStrips )

    //
    // Return last point. Y already calculated when we knew the direction.
    //
    pStrip->ptlStart.x = iCurrent;

    if ( pStrip->flFlips & FL_FLIP_V )
    {
        //
        // Restore hardware to default state
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagdY;
        pBuffer[1] =  INTtoFIXED(1);

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

}// vSolidHorizontalLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidVertical
// 
//  Draws left-to-right y-major near-vertical lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidVerticalLine(PDev*       ppdev,
                   STRIP*      pStrip,
                   LINESTATE*  pLineState)
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidVerticalLine"));

    cStrips = pStrip->cStrips;

    InputBufferReserve(ppdev, 16, &pBuffer);
    
    //
    // Set up the start point
    //
    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =  INTtoFIXED(pStrip->ptlStart.x);
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =  INTtoFIXED(pStrip->ptlStart.y);
    pBuffer[4] = __Permedia2TagdXDom;
    pBuffer[5] =  INTtoFIXED(0);
    pBuffer[6] = __Permedia2TagdXSub;
    pBuffer[7] =  INTtoFIXED(0);

    //
    // Set up the deltas for rectangle drawing.
    // dxDom, dXSub and dY all are to 0, 0, and 1 by default 
    //
    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }
    pBuffer[8] = __Permedia2TagdY;
    pBuffer[9] =  INTtoFIXED(yDir);

    pStrips = pStrip->alStrips;

    //
    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    //
    iCurrent = pStrip->ptlStart.x + 1;          // Xsub, Start of next strip
    iLenSum = (iLen = *pStrips++);
    pBuffer[10] = __Permedia2TagStartXSub;
    pBuffer[11] =  INTtoFIXED(iCurrent);
    pBuffer[12] = __Permedia2TagCount;
    pBuffer[13] =  iLen;           // Rectangle 1 scanline high
    pBuffer[14] = __Permedia2TagRender;
    pBuffer[15] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    if ( --cStrips )
    {
        while ( cStrips > 1 )
        {
            //
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            //
            iCurrent++;

            InputBufferReserve(ppdev, 8, &pBuffer);
            
            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);

            iLenSum += (iLen = *pStrips++);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            //
            // Second strip of each pair to fill. XDom is valid. Need new XSub
            //
            iCurrent ++;
            pBuffer[4] = __Permedia2TagStartXSub;
            pBuffer[5] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            pBuffer[6] = __Permedia2TagContinueNewSub;
            pBuffer[7] =  iLen;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            cStrips -=2;
        }// while ( cStrips > 1 )

        //
        // We may have one last line to draw. Xsub will be valid.
        //
        if ( cStrips )
        {
            iCurrent ++;
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            
            iLenSum += (iLen = *pStrips++);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
    }// if ( --cStrips )

    //
    // Restore hardware to default
    //
    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    
    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);


    //
    // Return last point. 
    //
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vSolidVerticalLine done"));

}// vSolidVerticalLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidDiagonalVertical
// 
//  Draws left-to-right y-major near-diagonal lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidDiagonalVerticalLine(PDev*       ppdev,
                           STRIP*      pStrip,
                           LINESTATE*  pLineState)
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    ULONG*  pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidDiagonalVerticalLine"));

    cStrips = pStrip->cStrips;

    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    InputBufferReserve(ppdev, 16, &pBuffer);

    //
    // Set up the deltas for rectangle drawing.
    //
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  INTtoFIXED(1);
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(yDir);

    pStrips = pStrip->alStrips;

    //
    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    //
    pBuffer[6] = __Permedia2TagStartY;
    pBuffer[7] =  INTtoFIXED(pStrip->ptlStart.y);
    pBuffer[8] = __Permedia2TagStartXDom;
    pBuffer[9] =  INTtoFIXED(pStrip->ptlStart.x + 1);
    pBuffer[10] = __Permedia2TagStartXSub;
    pBuffer[11] =  INTtoFIXED(pStrip->ptlStart.x);

    iLenSum = (iLen = *pStrips++);
    iCurrent = pStrip->ptlStart.x + iLen - 1;// Start of next strip

    pBuffer[12] = __Permedia2TagCount;
    pBuffer[13] =  iLen;           // Trap iLen scanline high
    pBuffer[14] = __Permedia2TagRender;
    pBuffer[15] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    if ( --cStrips )
    {
        while ( cStrips > 1 )
        {
            //
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            //
            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            //
            // Second strip of each pair to fill. XDom is valid. Need new XSub
            //
            pBuffer[4] = __Permedia2TagStartXSub;
            pBuffer[5] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            pBuffer[6] = __Permedia2TagContinueNewSub;
            pBuffer[7] =  iLen;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            cStrips -=2;
        }// while ( cStrips > 1 )

        //
        // We may have one last line to draw. Xsub will be valid.
        //
        if ( cStrips )
        {
            InputBufferReserve(ppdev, 4, &pBuffer);
            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
    }// if ( --cStrips )

    InputBufferReserve(ppdev, 6, &pBuffer);

    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(1);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Return last point. 
    //
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vSolidDiagonalVerticalLine done"));

}// vSolidDiagonalVerticalLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidDiagonalHorizontalLine
// 
//  Draws left-to-right x-major near-diagonal lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidDiagonalHorizontalLine(PDev*       ppdev,
                             STRIP*      pStrip,
                             LINESTATE*  pLineState)
{
    LONG    cStrips, yDir, xCurrent, yCurrent, iLen;
    PLONG   pStrips;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidDiagonalHorizontalLine"));

    // This routine has to be implemented in a different way to the other 3
    // solid line drawing functions because the rasterizer unit will not 
    // produce 2 pixels on the same scanline without a lot of effort in 
    // producing delta values. In this case, we have to draw a complete new
    // primitive for each strip. Therefore, we have to use lines rather than
    // trapezoids to generate the required strips. With lines we use 4 messages
    // per strip, where trapezoids would use 5.

    cStrips = pStrip->cStrips;

    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    pStrips = pStrip->alStrips;

    xCurrent = pStrip->ptlStart.x;
    yCurrent = pStrip->ptlStart.y;


    InputBufferReserve(ppdev, 6, &pBuffer);
    
    //
    // Set up the deltas for rectangle drawing.
    //
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  INTtoFIXED(1);
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(yDir);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    while ( TRUE )
    {
        //
        // Set up the start point
        //
        InputBufferReserve(ppdev, 8, &pBuffer);

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  INTtoFIXED(xCurrent);
        pBuffer[2] = __Permedia2TagStartY;
        pBuffer[3] =  INTtoFIXED(yCurrent);

        iLen = *pStrips++;
        pBuffer[4] = __Permedia2TagCount;
        pBuffer[5] =  iLen;
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  __RENDER_LINE_PRIMITIVE;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        xCurrent += iLen;
        if ( yDir > 0 )
        {
            yCurrent += iLen - 1;
        }
        else
        {
            yCurrent -= iLen - 1;
        }

        if ( !(--cStrips) )
        {
            break;
        }
    }// while ( TRUE )

    InputBufferReserve(ppdev, 6, &pBuffer);
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(1);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Return last point. 
    //
    pStrip->ptlStart.x = xCurrent;
    pStrip->ptlStart.y = yCurrent;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vSolidDiagonalHorizontalLine done"));

}// vSolidDiagonalHorizontalLine()

//-----------------------------------------------------------------------------
//
// VOID vStyledHorizontalLine()
// 
// Takes the list of strips that define the pixels that would be lit for
// a solid line, and breaks them into styling chunks according to the
// styling information that is passed in.
// 
// This particular routine handles x-major lines that run left-to-right,
// and are comprised of horizontal strips.  It draws the dashes using
// short-stroke vectors.
// 
// The performance of this routine could be improved significantly.
//
// Parameters
//  ppdev-------PDEV pointer
//  pStrip------Strip info. Note: the data in the strip are already in normal
//              integer format, not 28.4 format
//  pLineState--Line state info
//
//-----------------------------------------------------------------------------
VOID
vStyledHorizontalLine(PDev*       ppdev,
                      STRIP*      pStrip,
                      LINESTATE*  pLineState)
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    ULONG*      pBuffer;
    
    LONG    lStripLength;
    LONG    lTotalNumOfStrips;
    
    LONG    lNumPixelRemain;
    LONG    lCurrentLength;
    ULONG   bIsGap;
    
    PERMEDIA_DECL;

    DBG_GDI((STRIP_LOG_LEVEL, "vStyledHorizontalLine"));

    if ( pStrip->flFlips & FL_FLIP_V )
    {
        dy = -1;
    }
    else
    {
        dy = 1;
    }

    lTotalNumOfStrips = pStrip->cStrips;// Total number of strips we'll do
    plStrip = pStrip->alStrips;         // Points to current strip
    x = pStrip->ptlStart.x;             // x position of start of first strip
    y = pStrip->ptlStart.y;             // y position of start of first strip

    //
    // Set up the deltas for horizontal line drawing.
    //
    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  0;
    
    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    lStripLength = *plStrip;            // Number of pixels in first strip

    //
    // Number of pixels in first strip
    //
    lNumPixelRemain = pLineState->spRemaining;

    //
    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':
    //
    bIsGap = pLineState->ulStyleMask;
    if ( bIsGap )
    {
        //
        // A gap
        //
        goto SkipAGap;
    }
    else
    {
        //
        // A dash
        //
        goto OutputADash;
    }

PrepareToSkipAGap:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    lNumPixelRemain = *pLineState->psp;

    //
    // If 'lStripLength' is zero, we also need a new strip:
    //
    if ( lStripLength != 0 )
    {
        goto SkipAGap;
    }

    //
    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':
    //
    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new scan and need a new strip
        //
        y += dy;

        plStrip++;
        lTotalNumOfStrips--;
        
        if ( lTotalNumOfStrips == 0 )
        {
            goto AllDone;
        }

        lStripLength = *plStrip;

SkipAGap:

        lCurrentLength = min(lStripLength, lNumPixelRemain);
        lNumPixelRemain -= lCurrentLength;
        lStripLength -= lCurrentLength;

        x += lCurrentLength;

        if ( lNumPixelRemain == 0 )
        {
            goto PrepareToOutputADash;
        }
    }// while (TRUE)

PrepareToOutputADash:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    lNumPixelRemain = *pLineState->psp;

    //
    // If 'lStripLength' is zero, we also need a new strip.
    //
    if ( lStripLength != 0 )
    {
        //
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:
        //
        goto OutputADash;
    }

    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new scan and need a new strip:
        //
        y += dy;

        plStrip++;
        lTotalNumOfStrips--;
        
        if ( lTotalNumOfStrips == 0 )
        {
            goto AllDone;
        }

        lStripLength = *plStrip;

OutputADash:

        lCurrentLength   = min(lStripLength, lNumPixelRemain);
        lNumPixelRemain -= lCurrentLength;
        lStripLength -= lCurrentLength;

        //
        // With Permedia2 we just download the lines to draw
        //
        InputBufferReserve(ppdev, 8, &pBuffer);

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  INTtoFIXED(x);
        pBuffer[2] = __Permedia2TagStartY;
        pBuffer[3] =  INTtoFIXED(y);
        pBuffer[4] = __Permedia2TagCount;
        pBuffer[5] =  lCurrentLength;
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  __PERMEDIA_LINE_PRIMITIVE;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        x += lCurrentLength;

        if ( lNumPixelRemain == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }// while ( TRUE )

AllDone:

    //
    // Restore default state
    //
    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  INTtoFIXED(1);

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Update our state variables so that the next line can continue
    // where we left off:
    //
    pLineState->spRemaining   = lNumPixelRemain;
    pLineState->ulStyleMask   = bIsGap;
    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vStyledHorizontalLine done"));

}// vStyledHorizontalLine()

//-----------------------------------------------------------------------------
//
//  VOID vStripStyledVertical
// 
//  Takes the list of strips that define the pixels that would be lit for
//  a solid line, and breaks them into styling chunks according to the
//  styling information that is passed in.
// 
//  This particular routine handles y-major lines that run left-to-right,
//  and are comprised of vertical strips.  It draws the dashes using
//  short-stroke vectors.
// 
//  The performance of this routine could be improved significantly.
// 
//-----------------------------------------------------------------------------
VOID
vStyledVerticalLine(PDev*       ppdev,
                    STRIP*      pStrip,
                    LINESTATE*  pLineState)
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vStyledVerticalLine"));
//@@BEGIN_DDKSPLIT
    //
    // TODO: improve the performance of this routine
    //
//@@END_DDKSPLIT
    if ( pStrip->flFlips & FL_FLIP_V )
    {
        dy = -1;
    }
    else
    {
        dy = 1;
    }

    cStrips = pStrip->cStrips;      // Total number of strips we'll do
    plStrip = pStrip->alStrips;     // Points to current strip
    x       = pStrip->ptlStart.x;   // x position of start of first strip
    y       = pStrip->ptlStart.y;   // y position of start of first strip

    //
    // Set up the deltas for vertical line drawing.
    //
    InputBufferReserve(ppdev, 6, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(0);
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  INTtoFIXED(0);
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(dy);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pLineState->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pLineState->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if ( bIsGap )
    {
        goto SkipAGap;
    }
    else
    {
        goto OutputADash;
    }

PrepareToSkipAGap:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    cStyle = *pLineState->psp;

    //
    // If 'cStrip' is zero, we also need a new strip:
    //
    if ( cStrip != 0 )
    {
        goto SkipAGap;
    }

    //
    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':
    //
    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new column and need a new strip:
        //
        x++;

        plStrip++;
        cStrips--;
        
        if ( cStrips == 0 )
        {
            goto AllDone;
        }

        cStrip = *plStrip;

SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if ( cStyle == 0 )
        {
            goto PrepareToOutputADash;
        }
    }

PrepareToOutputADash:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    cStyle = *pLineState->psp;

    //
    // If 'cStrip' is zero, we also need a new strip.
    //
    if ( cStrip != 0 )
    {
        goto OutputADash;
    }

    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new column and need a new strip:
        //
        x++;

        plStrip++;
        cStrips--;
        
        if ( cStrips == 0 )
        {
            goto AllDone;
        }

        cStrip = *plStrip;

OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        //
        // With Permedia2 we just download the lines to draw
        //
        InputBufferReserve(ppdev, 8, &pBuffer);

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  INTtoFIXED(x);
        pBuffer[2] = __Permedia2TagStartY;
        pBuffer[3] =  INTtoFIXED(y);
        pBuffer[4] = __Permedia2TagCount;
        pBuffer[5] =  cThis;
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  __PERMEDIA_LINE_PRIMITIVE;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        y += (dy > 0) ? cThis : -cThis;

        if ( cStyle == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }// while ( TRUE )

AllDone:
    //
    // Restore hardware to default state
    //
    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    
    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Update our state variables so that the next line can continue
    // where we left off:
    //
    pLineState->spRemaining   = cStyle;
    pLineState->ulStyleMask   = bIsGap;
    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}// vStyledVerticalLine()

//
// For a given sub-pixel coordinate (x.m, y.n) in 28.4 fixed point
// format this array is indexed by (m,n) and indicates whether the
// given sub-pixel is within a GIQ diamond. m coordinates run left
// to right; n coordinates ru top to bottom so index the array with
// ((n<<4)+m). The array as seen here really contains 4 quarter
// diamonds.
//
static unsigned char    in_diamond[] =
{
/*          0 1 2 3 4 5 6 7 8 9 a b c d e f          */

/* 0 */     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,    /* 0 */
/* 1 */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* 1 */
/* 2 */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* 2 */
/* 3 */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* 3 */
/* 4 */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* 4 */
/* 5 */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* 5 */
/* 6 */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* 6 */
/* 7 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 7 */
/* 8 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 8 */
/* 9 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 9 */
/* a */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* a */
/* b */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* b */
/* c */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* c */
/* d */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* d */
/* e */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* e */
/* f */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* f */

/*      0 1 2 3 4 5 6 7 8 9 a b c d e f          */
};

//
// For lines with abs(slope) != 1 use IN_DIAMOND to determine if an
// end point is in a diamond. For lines of slope = 1 use IN_S1DIAMOND.
// For lines of slope = -1 use IN_SM1DIAMOND. The last two are a bit
// strange. The documentation leaves us with a problem for slope 1
// lines which run exactly betwen the diamonds. According to the docs
// such a line can enter a diamond, leave it and enter again. This is
// plainly rubbish so along the appropriate edge of the diamond we
// consider a slope 1 line to be inside the diamond. This is the
// bottom right edge for lines of slope -1 and the bottom left edge for
// lines of slope 1.
//
#define IN_DIAMOND(m, n)    (in_diamond[((m) << 4) + (n)])
#define IN_S1DIAMOND(m, n)  ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) - (n) == 8))
#define IN_SM1DIAMOND(m, n) ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) + (n) == 8))

BOOL
bFastLine(PPDev     ppdev,
          LONG      fx1,
          LONG      fy1,
          LONG      fx2,
          LONG      fy2)

{
    register LONG   adx, ady, tmp;
    FIX         m1, n1, m2, n2;
    LONG    dx, dy;
    LONG    dX, dY;
    LONG    count, startX, startY;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "bFastLine"));

    //
    // This function is only called if we have a line with non integer end points
    // and the unsigned coordinates are no greater than 15.4. 
    //
    // We can only guarantee to do lines whose coords need <= 12 bits
    // of integer. This is because to get the delta we must shift
    // by 16 bits. This includes 4 bits of fraction which means if
    // we have more than 12 bits of integer we get overrun on the
    // shift. We could use floating point to give us a better 16
    // bits of integer but this requires an extra set of multiplies
    // and divides in order to convert from 28.4 to fp. In any case
    // we have to have a test to reject coords needing > 16 bits
    // of integer.
    // Actually, we can deal with 16.4 coordinates provided dx and dy
    // never require more than 12 bits of integer.
    // So optimise for the common case where the line is completely
    // on the screen (actually 0 to 2047.f). Since the coords have
    // 4 bits of fraction we note that a 32 bit signed number
    // outside the range 0 to 2047.f will have one of its top 17
    // bits set. So logical or all the coords and test against
    // 0xffff8000. This is about as quick a test as we can get for
    // both ends of the line being on the screen. If this test fails
    // then we can check everything else at a leisurely pace.
    //

    //
    // Get signed and absolute deltas
    //
    if ((adx = dx = fx2 - fx1) < 0)
    {
        adx = -adx;
    }
    if ((ady = dy = fy2 - fy1) < 0)
    {
        ady = -ady;
    }

    //
    // Refuse to draw any lines whose delta is out of range.
    // We have to shift the delta by 16, so we dont want to loose any precision
    //
    if ( (adx | ady) & 0xffff8000 )
    {
        return(FALSE);
    }

    //
    // Fractional bits are used to check if point is in a diamond
    //
    m1 = fx1 & 0xf;
    n1 = fy1 & 0xf;
    m2 = fx2 & 0xf;
    n2 = fy2 & 0xf;

    //
    // The rest of the code is a series of cases. Each one is "called" by a
    // goto. This is simply to keep the nesting down. Main cases are: lines
    // with absolute slope == 1; x-major lines; and y-major lines. We draw
    // lines as they are given rather than always drawing in one direction.
    // This adds extra code but saves the time required to swap the points
    // and adjust for not drawing the end point.
    //
    startX = fx1 << 12;
    startY = fy1 << 12;

    DBG_GDI((7, "GDI Line %x, %x  deltas %x, %x", startX, startY, dx, dy));

    if ( adx < ady )
    {
        goto y_major;
    }

    if ( adx > ady )
    {
        goto x_major;
    }

    //
    // All slope 1 lines are sampled in X. i.e. we move the start coord to
    // an integer x and let Permedia2 truncate in y. This is because all GIQ
    // lines are rounded down in y for values exactly half way between two
    // pixels. If we sampled in y then we would have to round up in x for
    // lines of slope 1 and round down in x for other lines. Sampling in x
    // allows us to use the same Permedia2 bias in all cases (0x7fff). We do
    // the x round up or down when we move the start point.
    //
    if ( dx != dy )
    {
        goto slope_minus_1;
    }
    if ( dx < 0 )
    {
        goto slope1_reverse;
    }

    dX = 1 << 16;
    dY = 1 << 16;

    if ( IN_S1DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    startY += tmp - startX;
    startX = tmp;
    
    if ( IN_S1DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

    slope1_reverse:
    dX = -1 << 16;
    dY = -1 << 16;

    if ( IN_S1DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    startY += tmp - startX;
    startX = tmp;
    
    if ( IN_S1DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;                // previous integer
    }

    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

    slope_minus_1:
    
    if ( dx < 0 )
    {
        goto slope_minus_dx;
    }

    //
    // dx > 0, dy < 0
    //
    dX = 1 << 16;
    dY = -1 << 16;
    
    if (IN_SM1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    
    startY += startX - tmp;
    startX = tmp;
    
    if (IN_SM1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

    slope_minus_dx:
    dX = -1 << 16;
    dY = 1 << 16;
    
    if ( IN_SM1DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    startY += startX - tmp;
    startX = tmp;
    
    if ( IN_SM1DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;                // previous integer
    }
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

    x_major:
    
    //
    // Dont necessarily render through Permedia2 if we are worried about
    // conformance.
    //
    if ( (adx > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4))
       &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES)
       &&(ady != 0) )
    {
        return(FALSE);
    }

    if ( dx < 0 )
    {
        goto right_to_left_x;
    }

    //
    // Line goes left to right. Round up the start x to an integer
    // coordinate. This is the coord of the first diamond that the
    // line crosses. Adjust start y to match this point on the line.
    //
    dX = 1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;  // next integer
    }

    //
    // We can optimise for horizontal lines
    //
    if ( dy != 0 )
    {
        dY = dy << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dy < 0 )
        {
            dY -= adx - 1;
        }

        dY /= adx;
        startY += (((tmp - startX) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    startX = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }

    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

    right_to_left_x:

    dX = -1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startX & ~0xffff;             // previous integer
    }

    //
    // We can optimise for horizontal lines
    //
    if (dy != 0)
    {
        dY = dy << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dy < 0 )
        {
            dY -= adx - 1;
        }

        dY /= adx;
        startY += (((startX - tmp) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    startX = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;                // previous integer
    }
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

y_major:
    //
    // Dont necessarily render through Permedia2 if we are worried
    // about conformance.
    //
    if ( (ady > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4))
       &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES)
       &&(adx != 0) )
    {
        return(FALSE);
    }

    if ( dy < 0 )
    {
        goto high_to_low_y;
    }
    
    dY = 1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startY + 0x7fff) & ~0xffff;      // nearest integer
    }
    else
    {
        tmp = (startY + 0xffff) & ~0xffff;      // next integer
    }

    //
    // We can optimise for vertical lines
    //
    if ( dx != 0 )
    {
        dX = dx << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dx < 0 )
        {
            dX -= ady - 1;
        }

        dX /= ady;
        startX += (((tmp - startY) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    startY = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fy2 = (fy2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fy2 = (fy2 + 0xf) & ~0xf;   // next integer
    }
    count = (fy2 >> 4) - (startY >> 16);

    goto Draw_Line;

    high_to_low_y:

    dY = -1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startY + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startY & ~0xffff;             // previous integer
    }

    //
    // We can optimise for horizontal lines
    //
    if ( dx != 0 )
    {
        dX = dx << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dx < 0 )
        {
            dX -= ady - 1;
        }

        dX /= ady;
        startX += (((startY - tmp) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    startY = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fy2 = (fy2 + 0x7) & ~0xf;       // nearest integer
    }
    else
    {
        fy2 &= ~0xf;                    // previous integer
    }
    count = (startY >> 16) - (fy2 >> 4);

Draw_Line:
    //
    // We need 6 fifo entries to draw a line
    //
    InputBufferReserve(ppdev, 16, &pBuffer);

    DBG_GDI((7, "Line %x, %x  deltas %x, %x  Count %x",
             startX + 0x7fff, startY + 0x7fff, dX, dY, count));

    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =   startX + 0x7fff;
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =      startY + 0x7fff;
    pBuffer[4] = __Permedia2TagdXDom;
    pBuffer[5] =       dX;
    pBuffer[6] = __Permedia2TagdY;
    pBuffer[7] =          dY;
    pBuffer[8] = __Permedia2TagCount;
    pBuffer[9] =       count;
    pBuffer[10] = __Permedia2TagRender;
    pBuffer[11] =      __RENDER_LINE_PRIMITIVE;

    //
    // Restore default state
    //
    pBuffer[12] = __Permedia2TagdXDom;
    pBuffer[13] =       0;
    pBuffer[14] = __Permedia2TagdY;
    pBuffer[15] =          INTtoFIXED(1);

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    return(TRUE);
}// bFastLine()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\stroke.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: Stroke.c
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "log.h"

PFNSTRIP gapfnStrip[] =
{
    vSolidHorizontalLine,
    vSolidVerticalLine,
    vSolidDiagonalHorizontalLine,
    vSolidDiagonalVerticalLine,

    // Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vSolidHorizontalLine,
    vSolidVerticalLine,
    vSolidDiagonalHorizontalLine,
    vSolidDiagonalVerticalLine,

    // Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
    // solid lines, and the same number for non-solid lines:

    vStyledHorizontalLine,
    vStyledVerticalLine,
    vStyledVerticalLine,  // Diagonal goes here
    vStyledVerticalLine,  // Diagonal goes here

    vStyledHorizontalLine,
    vStyledVerticalLine,
    vStyledVerticalLine,  // Diagonal goes here
    vStyledVerticalLine,  // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

//-----------------------------------------------------------------------------
// BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
//
// DrvStrokePath strokes a path when called by GDI. If the driver has hooked the
// function, and if the appropriate GCAPs are set, GDI calls DrvStrokePath when
// GDI draws a line or curve with any set of attributes.
//
// Parameters
// pso----------Identifies the surface on which to draw. 
// ppo----------Points to a PATHOBJ structure. GDI PATHOBJ_Xxx service routines
//              are provided to enumerate the lines, Bezier curves, and other
//              data that make up the path. This indicates what is to be drawn. 
// pco----------Points to a CLIPOBJ structure. GDI CLIPOBJ_Xxx service routines
//              are provided to enumerate the clip region as a set of
//              rectangles. Optionally, all the lines in the path may be
//              enumerated preclipped by CLIPOBJ. This means that drivers can
//              have all their line clipping calculations done for them. 
// pxo----------Points to a XFORMOBJ. This is only needed when a geometric wide
//              line is to be drawn. It specifies the transform that maps world
//              coordinates to device coordinates. This is needed because the
//              path is provided in device coordinates but a geometric wide line
//              is actually widened in world coordinates. 
//              The XFORMOBJ can be queried to find the transform. 
// pbo----------Specifies the brush to be used when drawing the path. 
// pptlBrushOrg-Points to the brush origin used to align the brush pattern on
//              the device. 
// pLineAttrs---Points to a LINEATTRS structure. Note that the elStyleState
//              member must be updated as part of this function if the line is
//              styled. Also note that the ptlLastPel member must be updated if
//              a single pixel width cosmetic line is being drawn. 
// mix----------Specifies how to combine the brush with the destination. 
//
// Return Value
//  The return value is TRUE if the driver is able to stroke the path. If GDI
//  should stroke the path, the return value is FALSE, and an error code is not
//  logged. If the driver encounters an error, the return value is DDI_ERROR,
//  and an error code is reported.
//
// Comments
//  If a driver supports this entry point, it should also support the drawing of
//  cosmetic wide lines with arbitrary clipping. Using the provided GDI
//  functions, the call can be broken down into a set of single-pixel-width
//  lines with precomputed clipping.
//
//  This function is required if any drawing is to be done on a device-managed
//  surface.
//
//  Drivers for advanced devices can optionally receive this call to draw paths
//  containing Bezier curves and geometric wide lines. GDI will test the
//  GCAPS_BEZIERS and GCAPS_GEOMETRICWIDE flags of the flGraphicsCaps member of
//  the DEVINFO structure to decide whether it should call. (The four
//  combinations of the bits determine the four levels of functionality for
//  this call.) If the driver gets an advanced call containing Bezier curves or
//  geometric wide lines, it can decide not to handle the call, returning FALSE.
//  This might happen if the path or clipping is too complex for the device to
//  process. If the call does return FALSE, GDI breaks the call down into
//  simpler calls that can be handled easily.
//
//  For device-managed surfaces, the function must minimally support
//  single-pixel-wide solid and styled cosmetic lines using a solid-colored
//  brush. The device can return FALSE if the line is geometric and the engine
//  will convert those calls to DrvFillPath or DrvPaint calls.
//
//  The mix mode defines how the incoming pattern should be mixed with the data
//  already on the device surface. The MIX data type consists of two ROP2 values
//  packed into a single ULONG. The low-order byte defines the foreground raster
//  operation; the next byte defines the background raster operation. For more
//  information about raster operation codes, see the Platform SDK.
//
//-----------------------------------------------------------------------------
BOOL
DrvStrokePath(SURFOBJ*   pso,
              PATHOBJ*   ppo,
              CLIPOBJ*   pco,
              XFORMOBJ*  pxo,
              BRUSHOBJ*  pbo,
              POINTL*    pptlBrush,
              LINEATTRS* pLineAttrs,
              MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE lineState;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDev*     ppdev;
    Surf*     psurfDst;
    RECTL     arclClip[4];                  // For rectangular clipping
    BOOL      bResetHW;
    BOOL      bRet;
    DWORD     logicOp;

    DBG_GDI((6, "DrvStrokePath called with mix =%x", mix));

    psurfDst = (Surf*)pso->dhsurf;

    //
    // Punt to engine if surface to draw is not in video memory
    //
    if ( psurfDst->flags & SF_SM )
    {
        goto puntIt;
    }

    ppdev = (PDev*)pso->dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvStrokePath: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(ppdev);

    ppdev->psurf = psurfDst;

    fl = 0;

    //
    // Look after styling initialization:
    //
    if ( pLineAttrs->fl & LA_ALTERNATE )
    {
        //
        // LA_ALTERNATE: A special cosmetic line style; every other pixel is on
        //
        lineState.cStyle      = 1;
        lineState.spTotal     = 1;
        lineState.spTotal2    = 2;
        lineState.spRemaining = 1;
        lineState.aspRtoL     = &gaspAlternateStyle[0];
        lineState.aspLtoR     = &gaspAlternateStyle[0];
        lineState.spNext      = HIWORD(pLineAttrs->elStyleState.l);
        lineState.xyDensity   = 1;
        lineState.ulStartMask = 0L;
        fl                   |= FL_ARBITRARYSTYLED;
    }// Cosmetic line
    else if ( pLineAttrs->pstyle != (FLOAT_LONG*)NULL )
    {
        //
        // "pLineAttrs->pstyle" points to the style array. If this member is
        // null, the line style is solid
        //
        PFLOAT_LONG pStyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        //
        // "pLineAttrs->cstyle" specifies the number of entries in the style
        // array. So here we get the address of the last array first
        //
        pStyle = &pLineAttrs->pstyle[pLineAttrs->cstyle];

        lineState.xyDensity = STYLE_DENSITY;
        lineState.spTotal   = 0;

        //
        // Loop through all the data array backworfds to get the sum of style
        // array
        //
        while ( pStyle-- > pLineAttrs->pstyle )
        {
            lineState.spTotal += pStyle->l;
        }

        lineState.spTotal *= STYLE_DENSITY;
        lineState.spTotal2 = 2 * lineState.spTotal;

        //
        // Compute starting style position (this is guaranteed not to overflow)
        // Note: "pLineAttrs->elStyleState" is a pair of 16-bit values supplied
        // by GDI whenever the driver calls PATHOBJ_bEnumClipLines. These two
        // values, packed into a LONG, specify where in the styling array
        // (at which pixel) to start the first subpath. This value must be
        // updated as part of the output routine if the line is not solid.
        // This member applies to cosmetic lines only.
        //
        lineState.spNext = HIWORD(pLineAttrs->elStyleState.l) * STYLE_DENSITY
                         + LOWORD(pLineAttrs->elStyleState.l);

        fl |= FL_ARBITRARYSTYLED;
        lineState.cStyle  = pLineAttrs->cstyle;
        lineState.aspRtoL = aspRtoL;
        lineState.aspLtoR = aspLtoR;

        if ( pLineAttrs->fl & LA_STARTGAP )
        {
            //
            // The first entry in the style array specifies the length of the
            // first gap. set "ulStartMask" to mark it as a GAP
            //
            lineState.ulStartMask = 0xffffffffL;
        }
        else
        {
            //
            // It must be LA_GEOMETRIC which specifies a geometric wide line. Mark
            // it as not a GAP
            //
            lineState.ulStartMask = 0L;
        }

        //
        // Let "pStyle" points to the 1st style array, "pspDown" ponits to the
        // "cStyle"th array in aspRtoL and "pspUp" points to the 1st array in
        // aspLtoR
        //
        pStyle  = pLineAttrs->pstyle;
        pspDown = &lineState.aspRtoL[lineState.cStyle - 1];
        pspUp   = &lineState.aspLtoR[0];

        //
        // Move backwards to assign all the style data
        //
        while ( pspDown >= &lineState.aspRtoL[0] )
        {
            //
            // Let the last style data in "pspDown" = the 1st in "pspUp", 2 to
            // last in "pspDown" = 2nd in "pspUp".....
            // pspDown [n][n-1]...[2][1]
            // pspUp [1][2]...[n-1][n]
            //
            *pspDown = pStyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            
            pStyle++;
        }
    }// Non-solid line

    bRet = TRUE;
    apfn = &gapfnStrip[NUM_STRIP_DRAW_STYLES *
                       ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

    //
    // Set up to enumerate the path:
    //
    if ( pco->iDComplexity != DC_COMPLEX )
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*)NULL;
        BOOL      bMore;
        ULONG     lPtFix;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if ( pco->iDComplexity == DC_RECT )
        {
            fl |= FL_SIMPLE_CLIP;

            //
            // This is the only clip region of importance to Permedia2
            //
            arclClip[0]        =  pco->rclBounds;

            //
            // FL_FLIP_D:
            //
            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            //
            // FL_FLIP_V:
            //
            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            //
            // FL_FLIP_V | FL_FLIP_D:
            //
            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }// if ( pco->iDComplexity == DC_RECT )

        pd.flags = 0;

        //
        // Get the logic op and set up the flag to indicate reads from the frame
        // buffer will occur.
        //
        logicOp = ulRop3ToLogicop(gaMix[mix & 0xff]);
        DBG_GDI((7, "logicop is %d", logicOp));

        if ( LogicopReadDest[logicOp] )
        {
            fl |= FL_READ;
        }

        //
        // Need to set up Permedia2 modes and colors appropriately for the lines
        //
        bResetHW = bInitializeStrips(ppdev, pbo->iSolidColor,
                                     logicOp, prclClip);

        PATHOBJ_vEnumStart(ppo);

        do
        {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            lPtFix = pd.count;
            if ( lPtFix == 0 )
            {
                //
                // If the pathdata contains no data, finish
                //
                break;
            }

            if ( pd.flags & PD_BEGINSUBPATH )
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                lPtFix--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if ( pd.flags & PD_RESETSTYLE )
            {
                lineState.spNext = 0;
            }

            if ( lPtFix > 0 )
            {
                if ( !bLines(ppdev,
                             pptfxFirst,
                             pptfxBuf,
                             (RUN*)NULL,
                             lPtFix,
                             &lineState,
                             prclClip,
                             apfn,
                             fl) )
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if ( pd.flags & PD_CLOSEFIGURE )
            {
                if ( !bLines(ppdev,
                             &ptfxLast,
                             &ptfxStartFigure,
                             (RUN*)NULL,
                             1,
                             &lineState,
                             prclClip,
                             apfn,
                             fl) )
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while ( bMore );

        if ( fl & FL_STYLED )
        {
            //
            // Save the style state
            //
            ULONG ulHigh;
            ULONG ulLow;

            //
            // Masked styles don't normalize the style state.  It's a good thing
            // to do, so let's do it now
            //
            if ( (ULONG)lineState.spNext >= (ULONG)lineState.spTotal2 )
            {
                lineState.spNext = (ULONG)lineState.spNext
                                 % (ULONG)lineState.spTotal2;
            }

            ulHigh = lineState.spNext / lineState.xyDensity;
            ulLow  = lineState.spNext % lineState.xyDensity;

            pLineAttrs->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
        //
        // Local state for path enumeration
        //
        BOOL bMore;

        union
        {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        //
        // Need to set up hardware modes and colors appropriately for the lines.
        // NOTE, with a complex clip,we can not yet use permedia2 for fast lines
        //
        bResetHW = bInitializeStrips(ppdev, pbo->iSolidColor,
                                     ulRop3ToLogicop(gaMix[mix&0xff]),
                                     NULL);

        //
        // We use the clip object when non-simple clipping is involved:
        //
        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pLineAttrs);

        do
        {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if ( cl.cl.c != 0 )
            {
                if ( fl & FL_STYLED )
                {
                    lineState.spComplex = HIWORD(cl.cl.lStyleState)
                                        * lineState.xyDensity
                                        + LOWORD(cl.cl.lStyleState);
                }
                if ( !bLines(ppdev,
                             &cl.cl.ptfxA,
                             &cl.cl.ptfxB,
                             &cl.cl.arun[0],
                             cl.cl.c,
                             &lineState,
                             (RECTL*) NULL,
                             apfn,
                             fl) )
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while ( bMore );
    }

ResetReturn:

    if ( bResetHW )
    {
        vResetStrips(ppdev);
    }

    DBG_GDI((6, "DrvStrokePath done it"));

    InputBufferFlush(ppdev);
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (bRet);

puntIt:
//@@BEGIN_DDKSPLIT
#if GDI_TEST    
    ULONG   flags = vPuntBefore(NULL, pso);
#endif
//@@END_DDKSPLIT

    bRet = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush,
                         pLineAttrs, mix);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, NULL, pso);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    DBG_GDI((6, "DrvStrokePath punt it"));
    return bRet;
}// DrvStrokePath()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\stretch.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: stretch.c
 *
 * Contains all the stretch blt functions.
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"
#include "clip.h"

//
// Maximal clip rectangle for trivial stretch clipping
//
// Note: SCISSOR_MAX is defined as 2047 because this is
// the maximum clip size P2 can handle.
// It is OK to set this maximum clip size since no device
// bitmap will be bigger than 2047. This is the limitation
// of P2 hardware. See DrvCreateDeviceBitmap() for more
// detail
//
RECTL grclStretchClipMax = { 0, 0, SCISSOR_MAX, SCISSOR_MAX };

//-----------------------------------------------------------------------------
//
// DWORD dwGetPixelSize()
//
// This routine converts current bitmap format to Permedia pixel size
//
//-----------------------------------------------------------------------------
DWORD
dwGetPixelSize(ULONG    ulBitmapFormat,
               DWORD*   pdwFormatBits,
               DWORD*   pdwFormatExtention)
{
    DWORD dwPixelSize;

    switch ( ulBitmapFormat )
    {
        case BMF_8BPP:
            dwPixelSize = 0;
            *pdwFormatBits = PERMEDIA_8BIT_PALETTEINDEX;
            *pdwFormatExtention = PERMEDIA_8BIT_PALETTEINDEX_EXTENSION;
            break;

        case BMF_16BPP:
            dwPixelSize = 1;
            *pdwFormatBits = PERMEDIA_565_RGB;
            *pdwFormatExtention = PERMEDIA_565_RGB_EXTENSION;
            break;

        case BMF_32BPP:
            dwPixelSize = 2;
            *pdwFormatBits = PERMEDIA_888_RGB;
            *pdwFormatExtention = PERMEDIA_888_RGB_EXTENSION;
            break;

        default:
            dwPixelSize = -1;
    }

    return dwPixelSize;
}// dwGetPixelSize()

//-----------------------------------------------------------------------------
//
// DWORD bStretchInit()
//
// This routine initializes all the registers needed for doing a stretch blt
//
//-----------------------------------------------------------------------------
BOOL
bStretchInit(SURFOBJ*    psoDst,
             SURFOBJ*    psoSrc)
{
    Surf*   pSurfDst = (Surf*)psoDst->dhsurf;
    Surf*   pSurfSrc = (Surf*)psoSrc->dhsurf;
    DWORD   dwDstPixelSize;
    DWORD   dwDstFormatBits;
    DWORD   dwDstFormatExtention;
    DWORD   dwSrcPixelSize;
    DWORD   dwSrcFormatBits;
    DWORD   dwSrcFormatExtention;
    PDev*   ppdev = (PDev*)psoDst->dhpdev;
    ULONG*  pBuffer;

    DBG_GDI((6, "bStretchInit called"));
    
    ASSERTDD(pSurfSrc, "Not valid private surface in source");
    ASSERTDD(pSurfDst, "Not valid private surface in destination");

    dwDstPixelSize = dwGetPixelSize(psoDst->iBitmapFormat,
                                    &dwDstFormatBits,
                                    &dwDstFormatExtention);

    if ( dwDstPixelSize == -1 )
    {
        DBG_GDI((1, "bStretchBlt return FALSE because of wrong DstPixel Size"));
        //
        // Unsupported bitmap format, return false
        //
        return FALSE;
    }
    
    InputBufferReserve(ppdev, 26, &pBuffer);

    if ( dwDstPixelSize != __PERMEDIA_8BITPIXEL)
    {
        pBuffer[0] = __Permedia2TagDitherMode;
        pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) // RGB color order
                   |(dwDstFormatBits << PM_DITHERMODE_COLORFORMAT)
                   |(dwDstFormatExtention << PM_DITHERMODE_COLORFORMATEXTENSION)
                   |(1 << PM_DITHERMODE_ENABLE);
    }
    else
    {
        pBuffer[0] = __Permedia2TagDitherMode;
        pBuffer[1] = __PERMEDIA_DISABLE;
    }

    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = pSurfDst->ulPixOffset;

    //
    // Set no read of source.
    //
    pBuffer[4]  = __Permedia2TagFBReadMode;
    pBuffer[5]  = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP);
    pBuffer[6]  = __Permedia2TagLogicalOpMode;
    pBuffer[7]  = __PERMEDIA_DISABLE;
    pBuffer[8]  = __Permedia2TagTextureBaseAddress;
    pBuffer[9]  = pSurfSrc->ulPixOffset;
    pBuffer[10] = __Permedia2TagTextureAddressMode;
    pBuffer[11] = 1 << PM_TEXADDRESSMODE_ENABLE;
    pBuffer[12] = __Permedia2TagTextureColorMode;
    pBuffer[13] = (1 << PM_TEXCOLORMODE_ENABLE)
                | (0 << 4)                                           // RGB  
                | (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION);

    //
    // Note: we have to turn off BiLinear filtering here, even for stretch
    // because GDI doesn't do it. Otherwise, we will fail during the
    // comparison
    //
    pBuffer[14] = __Permedia2TagTextureReadMode;
    pBuffer[15] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE)
                | PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE)
                | PM_TEXREADMODE_WIDTH(11)
                | PM_TEXREADMODE_HEIGHT(11);

    dwSrcPixelSize = dwGetPixelSize(psoSrc->iBitmapFormat,
                                    &dwSrcFormatBits,
                                    &dwSrcFormatExtention);

    if ( dwSrcPixelSize == -1 )
    {
        DBG_GDI((1, "bStretchBlt return FALSE because of wrong SrcPixel Size"));
        //
        // Unsupported bitmap format, return false
        //
        return FALSE;
    }
    
    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] = (dwSrcFormatBits << PM_TEXDATAFORMAT_FORMAT)
                | (dwSrcFormatExtention << PM_TEXDATAFORMAT_FORMATEXTENSION)
                | (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] = pSurfSrc->ulPackedPP
                |(dwSrcPixelSize << PM_TEXMAPFORMAT_TEXELSIZE);
    pBuffer[20] = __Permedia2TagScissorMode;
    pBuffer[21] = SCREEN_SCISSOR_DEFAULT
                | USER_SCISSOR_ENABLE;
    
    pBuffer[22] = __Permedia2TagdSdyDom;
    pBuffer[23] = 0;
    pBuffer[24] = __Permedia2TagdTdx;
    pBuffer[25] = 0;

    pBuffer += 26;
    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((6, "bStretchInit return TRUE"));
    return TRUE;
}// bStretchInit()

//-----------------------------------------------------------------------------
//
// DWORD bStretchReset()
//
// This routine resets all the registers changed during stretch blt
//
//-----------------------------------------------------------------------------
void
vStretchReset(PDev* ppdev)
{
    ULONG*  pBuffer;
    
    DBG_GDI((6, "vStretchReset called"));
    
    InputBufferReserve(ppdev, 12, &pBuffer);
    
    //
    // Restore the default settings
    //
    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = SCREEN_SCISSOR_DEFAULT;
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = __PERMEDIA_DISABLE;
    pBuffer[4] = __Permedia2TagTextureAddressMode;
    pBuffer[5] = __PERMEDIA_DISABLE;
    pBuffer[6] = __Permedia2TagTextureColorMode;
    pBuffer[7] = __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureReadMode;
    pBuffer[9] = __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagdY;
    pBuffer[11] = INTtoFIXED(1);

    pBuffer += 12;
    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((6, "vStretchReset done"));
    return;
}// vStretchReset()

//-----------------------------------------------------------------------------
//
// VOID vStretchBlt()
//
// This routine does the stretch blt work through the texture engine
//
//-----------------------------------------------------------------------------
VOID
vStretchBlt(SURFOBJ*    psoDst,
            SURFOBJ*    psoSrc,
            RECTL*      rDest,
            RECTL*      rSrc,
            RECTL*      prclClip)
{
    Surf*   pSurfDst = (Surf*)psoDst->dhsurf;
    Surf*   pSurfSrc = (Surf*)psoSrc->dhsurf;
    LONG    lXScale;
    LONG    lYScale;
    DWORD   dwDestWidth = rDest->right - rDest->left;
    DWORD   dwDestHeight = rDest->bottom - rDest->top;
    DWORD   dwSourceWidth = rSrc->right - rSrc->left;
    DWORD   dwSourceHeight = rSrc->bottom - rSrc->top;
    DWORD   dwRenderDirection;
    DWORD   dwDstPixelSize;
    DWORD   dwDstFormatBits;
    DWORD   dwDstFormatExtention;
    DWORD   dwSrcPixelSize;
    DWORD   dwSrcFormatBits;
    DWORD   dwSrcFormatExtention;
    ULONG*  pBuffer;
    PDev*   ppdev = (PDev*)psoDst->dhpdev;

    DBG_GDI((6, "vStretchBlt called"));
    DBG_GDI((6, "prclClip (left, right, top, bottom)=(%d, %d, %d,%d)",
             prclClip->left, prclClip->right, prclClip->top, prclClip->bottom));
    DBG_GDI((6, "rSrc (left, right, top, bottom=(%d, %d, %d,%d)",rSrc->left,
             rSrc->right, rSrc->top, rSrc->bottom));
    DBG_GDI((6, "rDest (left, right, top, bottom)=(%d, %d, %d,%d)",rDest->left,
             rDest->right, rDest->top, rDest->bottom));
    
    ASSERTDD(prclClip != NULL, "Wrong clippng rectangle");

    //
    // Note: the scale factor register value: dsDx, dTdyDom's interger part
    // starts at bit 20. So we need to "<< 20" here
    //
    lXScale = (dwSourceWidth << 20) / dwDestWidth;
    lYScale = (dwSourceHeight << 20) / dwDestHeight;
//    lXScale = (((dwSourceWidth << 18) - 1) / dwDestWidth) << 2;
//    lYScale = (((dwSourceHeight << 18) - 1) / dwDestHeight) << 2;
    DBG_GDI((6, "lXScale=0x%x, lYScale=0x%x", lXScale, lYScale));
    DBG_GDI((6, "dwSourceWidth=%d, dwDestWidth=%d",
             dwSourceWidth, dwDestWidth));
    DBG_GDI((6, "dwSourceHeight=%d, dwDestHeight=%d",
             dwSourceHeight, dwDestHeight));
    
    InputBufferReserve(ppdev, 24, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMinXY;
    pBuffer[1] = ((prclClip->left)<< SCISSOR_XOFFSET)
                |((prclClip->top)<< SCISSOR_YOFFSET);
    pBuffer[2] = __Permedia2TagScissorMaxXY;
    pBuffer[3] = ((prclClip->right)<< SCISSOR_XOFFSET)
                |((prclClip->bottom)<< SCISSOR_YOFFSET);

    //
    // We need to be carefull with overlapping rectangles
    //
    if ( (pSurfSrc->ulPixOffset) != (pSurfDst->ulPixOffset) )
    {
        //
        // Src and dst are differnt surface
        //
        dwRenderDirection = 1;
    }
    else
    {
        //
        // Src and dst are the same surface
        // We will set dwRenderDirection=1 if the src is lower or righter
        // than the dst, that is, if it is bottom-up or right-left, we set
        // dwRenderDirection=1, otherwise it = 0
        //
        if ( rSrc->top < rDest->top )
        {
            dwRenderDirection = 0;
        }
        else if ( rSrc->top > rDest->top )
        {
            dwRenderDirection = 1;
        }
        else if ( rSrc->left < rDest->left )
        {
            dwRenderDirection = 0;
        }
        else
        {
            dwRenderDirection = 1;
        }
    }// src and dst are different

    DBG_GDI((6, "dwRenderDirection=%d", dwRenderDirection));

    //
    // Render the rectangle
    //
    if ( dwRenderDirection )
    {
        pBuffer[4] = __Permedia2TagSStart;
        pBuffer[5] = (rSrc->left << 20) + ((lXScale >> 1) & 0xfffffffc);
        pBuffer[6] = __Permedia2TagTStart;
        pBuffer[7] = (rSrc->top << 20) + ((lYScale >> 1) & 0xfffffffc);
        pBuffer[8] = __Permedia2TagdSdx;
        pBuffer[9] = lXScale;
        pBuffer[10] = __Permedia2TagdTdyDom;
        pBuffer[11] = lYScale;
        pBuffer[12] = __Permedia2TagStartXDom;
        pBuffer[13] = INTtoFIXED(rDest->left);
        pBuffer[14] = __Permedia2TagStartXSub;
        pBuffer[15] = INTtoFIXED(rDest->right);
        pBuffer[16] = __Permedia2TagStartY;
        pBuffer[17] = INTtoFIXED(rDest->top);
        pBuffer[18] = __Permedia2TagdY;
        pBuffer[19] = INTtoFIXED(1);
        pBuffer[20] = __Permedia2TagCount;
        pBuffer[21] = rDest->bottom - rDest->top;
        pBuffer[22] = __Permedia2TagRender;
        pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE;
    }
    else
    {
        //
        // Render right to left, bottom to top
        //
        pBuffer[4] = __Permedia2TagSStart;
        pBuffer[5] = (rSrc->right << 20) + ((lXScale >> 1)& 0xfffffffc);
        pBuffer[6] = __Permedia2TagTStart;
        pBuffer[7] = (rSrc->bottom << 20) - ((lYScale >> 1)& 0xfffffffc);
        
        lXScale = -lXScale;
        lYScale = -lYScale;

        pBuffer[8] = __Permedia2TagdSdx;
        pBuffer[9] = lXScale;
        pBuffer[10] = __Permedia2TagdTdyDom;
        pBuffer[11] = lYScale;
        pBuffer[12] = __Permedia2TagStartXDom;
        pBuffer[13] = INTtoFIXED(rDest->right);
        pBuffer[14] = __Permedia2TagStartXSub;
        pBuffer[15] = INTtoFIXED(rDest->left);
        pBuffer[16] = __Permedia2TagStartY;
        pBuffer[17] = INTtoFIXED(rDest->bottom - 1);
        pBuffer[18] = __Permedia2TagdY;
        pBuffer[19] = (DWORD)INTtoFIXED(-1);
        pBuffer[20] = __Permedia2TagCount;
        pBuffer[21] = rDest->bottom - rDest->top;
        pBuffer[22] = __Permedia2TagRender;    
        pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE;
    }

    pBuffer += 24;
    InputBufferCommit(ppdev, pBuffer);
    
    DBG_GDI((6, "vStretchBlt done"));
    return;
}// vStretchBlt()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvStretchBlt
//
// DrvStretchBlt provides stretching bit-block transfer capabilities between any
// combination of device-managed and GDI-managed surfaces. This function enables
// the device driver to write to GDI bitmaps, especially when the driver can do
// halftoning. This function allows the same halftoning algorithm to be applied
// to GDI bitmaps and device surfaces.
//
// Parameters
//  psoDest-----Points to a SURFOBJ that identifies the surface on which to draw
//  psoSrc------Points to a SURFOBJ that defines the source for the bit-block
//              transfer operation. 
//  psoMask-----This optional parameter points to a surface that provides a mask
//              for the source. The mask is defined by a logic map, which is a
//              bitmap with 1 bit per pixel. 
//              The mask limits the area of the source that is copied. If this
//              parameter is specified, it has an implicit rop4 of 0xCCAA,
//              meaning the source should be copied wherever the mask is one,
//              but the destination should be left alone wherever the mask is
//              zero. 
//
//              When this parameter is null there is an implicit rop4 of 0xCCCC,
//              which means that the source should be copied everywhere in the
//              source rectangle. 
//
//              The mask will always be large enough to contain the relevant
//              source; tiling is unnecessary. 
//  pco---------Points to a CLIPOBJ that limits the area to be modified in the
//              destination. GDI services are provided to enumerate the clip
//              region as a set of rectangles. 
//              Whenever possible, GDI simplifies the clipping involved.
//              However, unlike DrvBitBlt, DrvStretchBlt can be called with a
//              single clipping rectangle. This prevents rounding errors in
//              clipping the output.
//  pxlo--------Points to a XLATEOBJ that specifies how color indices are to be
//              translated between the source and target surfaces. 
//              The XLATEOBJ can also be queried to find the RGB color for any
//              source index. A high quality stretching bit-block transfer will
//              need to interpolate colors in some cases. 
//  pca---------Points to a COLORADJUSTMENT structure that defines the color
//              adjustment values to be applied to the source bitmap before
//              stretching the bits. (See the Platform SDK.) 
//  pptlHTOrg---Specifies the origin of the halftone brush. Device drivers that
//              use halftone brushes should align the upper left pixel of the
//              brush's pattern with this point on the device surface. 
//  prclDest----Points to a RECTL structure that defines the area to be modified
//              in the coordinate system of the destination surface. This
//              rectangle is defined by two points that are not necessarily well
//              ordered, meaning the coordinates of the second point are not
//              necessarily larger than those of the first point. The rectangle
//              they describe does not include the lower and right edges. This
//              function is never called with an empty destination rectangle.
//
//              DrvStretchBlt can do inversions of x and y when the destination
//              rectangle is not well ordered. 
//  prclSrc-----Points to a RECTL that defines the area that will be copied in
//              the coordinate system of the source surface. The rectangle is
//              defined by two points, and will map onto the rectangle defined
//              by prclDest. The points of the source rectangle are well ordered
//              This function is never given an empty source rectangle.
//
//              The mapping is defined by prclSrc and prclDest. The points
//              specified in prclDest and prclSrc lie on integer coordinates,
//              which correspond to pixel centers. A rectangle defined by two
//              such points is considered to be a geometric rectangle with two
//              vertices whose coordinates are the given points, but with 0.5
//              subtracted from each coordinate. (POINTL structures should be
//              considered a shorthand notation for specifying these fractional
//              coordinate vertices.) 
//
//              The edges of any rectangle never intersect a pixel, but go
//              around a set of pixels. The pixels inside the rectangle are
//              those expected for a "bottom-right exclusive" rectangle.
//              DrvStretchBlt will map the geometric source rectangle exactly
//              onto the geometric destination rectangle. 
//  pptlMask----Points to a POINTL structure that specifies which pixel in the
//              given mask corresponds to the upper left pixel in the source
//              rectangle. Ignore this parameter if no mask is specified. 
//  iMode-------Specifies how source pixels are combined to get output pixels.
//              The HALFTONE mode is slower than the other modes, but produces
//              higher quality images.
//                      Value               Meaning 
//                  WHITEONBLACK    On a shrinking bit-block transfer, pixels
//                                  should be combined with a Boolean OR
//                                  operation. On a stretching bit-block
//                                  transfer, pixels should be replicated. 
//                  BLACKONWHITE    On a shrinking bit-block transfer, pixels
//                                  should be combined with a Boolean AND
//                                  operation. On a stretching bit-block
//                                  transfer, pixels should be replicated.
//                  COLORONCOLOR    On a shrinking bit-block transfer, enough
//                                  pixels should be ignored so that pixels
//                                  don't need to be combined. On a stretching
//                                  bit-block transfer, pixels should be
//                                  replicated. 
//                  HALFTONE        The driver can use groups of pixels in the
//                                  output surface to best approximate the color
//                                  or gray level of the input.
//
// Return Value
//  The return value is TRUE if the function is successful. Otherwise, it is
//  FALSE, and an error code is logged.
//
// Comments
//  This function can be provided to handle only certain forms of stretching,
//  such as by integer multiples. If the driver has hooked the call and is asked
//  to perform an operation it does not support, the driver should forward the
//  data to EngStretchBlt for GDI to handle.
//
//  If the driver wants GDI to handle halftoning, and wants to ensure the proper
//  iMode value, the driver can hook DrvStretchBlt, set iMode to HALFTONE, and
//  call back to GDI with EngStretchBlt with the set iMode value.
//
//  DrvStretchBlt is optional for display drivers.
//
//-----------------------------------------------------------------------------
BOOL
DrvStretchBlt(SURFOBJ*            psoDst,
              SURFOBJ*            psoSrc,
              SURFOBJ*            psoMsk,
              CLIPOBJ*            pco,
              XLATEOBJ*           pxlo,
              COLORADJUSTMENT*    pca,
              POINTL*             pptlHTOrg,
              RECTL*              prclDst,
              RECTL*              prclSrc,
              POINTL*             pptlMsk,
              ULONG               iMode)
{
    Surf*       pSurfSrc = (Surf*)psoSrc->dhsurf;
    Surf*       pSurfDst = (Surf*)psoDst->dhsurf;
    PDev*       ppdev = (PDev*)psoDst->dhpdev;
    BYTE	iDComplexity;
    RECTL*      prclClip;
    ULONG       cxDst;
    ULONG       cyDst;
    ULONG       cxSrc;
    ULONG       cySrc;
    BOOL        bMore;
    ClipEnum    ceInfo;
    LONG        lNumOfIntersections;
    LONG        i;

    DBG_GDI((6, "DrvStretchBlt called with iMode = %d", iMode));
    
    if (iMode != COLORONCOLOR)
    {
        DBG_GDI((6, "Punt because iMode != COLORONCOLOR"));
        goto Punt_It;
    }

    vCheckGdiContext(ppdev);
    
    //
    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be in video memory, not in system memory
    //
    ASSERTDD(pSurfDst->flags & SF_VM, "Dest surface is not in video memory");

    //
    // If the source is not a driver created surface or currently not sit
    // in the video memory, we just punt it back because GDI doing it will
    // be faster
    //
    if ( (!pSurfSrc) || (pSurfSrc->flags & SF_SM) )
    {
        DBG_GDI((6, "Punt because source = 0x%x or in sys memory", pSurfSrc));
        goto Punt_It;
    }

    //
    // We don't do the stretch blt if the mask is not NULL or the translate is
    // not trivial. We also don't do it if the source and current screen has
    // different color depth
    //
    if ( (psoMsk == NULL)
       &&((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
       &&((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) )
    {
        cxDst = prclDst->right - prclDst->left;
        cyDst = prclDst->bottom - prclDst->top;
        cxSrc = prclSrc->right - prclSrc->left;
        cySrc = prclSrc->bottom - prclSrc->top;

        //
        // Our 'vStretchDIB' routine requires that the stretch be
        // non-inverting, within a certain size, to have no source
        // clipping, and to have no empty rectangles (the latter is the
        // reason for the '- 1' on the unsigned compare here):
        //
        if ( ((cxSrc - 1) < STRETCH_MAX_EXTENT)
           &&((cySrc - 1) < STRETCH_MAX_EXTENT)
           &&((cxDst - 1) < STRETCH_MAX_EXTENT)
           &&((cyDst - 1) < STRETCH_MAX_EXTENT)
           &&(prclSrc->left   >= 0)
           &&(prclSrc->top    >= 0)
           &&(prclSrc->right  <= psoSrc->sizlBitmap.cx)
           &&(prclSrc->bottom <= psoSrc->sizlBitmap.cy))
        {
            if ( !bStretchInit(psoDst, psoSrc) )
            {
                goto Punt_It;
            }

	    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

            if ( (iDComplexity == DC_TRIVIAL) || (iDComplexity == DC_RECT) )
            {
                if (iDComplexity == DC_TRIVIAL) {
		    DBG_GDI((7, "Trivial clipping"));

		    // If there is no clipping, we just set the clipping area
		    // as the maximum
		    prclClip = &grclStretchClipMax;

		    ASSERTDD(((prclClip->right >= prclDst->right) &&
			      (prclClip->bottom >= prclDst->bottom)), "Dest surface is larger than P2 can handle");
		}
		else
		{
		    DBG_GDI((7, "DC_RECT clipping"));
		    prclClip = &pco->rclBounds;
		}

                vStretchBlt(psoDst,
                            psoSrc,
                            prclDst,
                            prclSrc,
                            prclClip);

            }
            else
            {
                DBG_GDI((7, "Complex clipping"));
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                //
                // Enumerate all the clip rectangles
                //
                do
                {
                    //
                    // Get one clip rectangle
                    //
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ceInfo),
                                          (ULONG*)&ceInfo);

                    //
                    // Get the intersect region with the dest rectangle
                    //
                    lNumOfIntersections = cIntersect(prclDst, ceInfo.arcl,
                                                     ceInfo.c);

                    //
                    // If there is clipping, then we do stretch region
                    // by region
                    //
                    if ( lNumOfIntersections != 0 )
                    {
                        for ( i = 0; i < lNumOfIntersections; ++i )
                        {
                            vStretchBlt(psoDst,
                                        psoSrc,
                                        prclDst,
                                        prclSrc,
                                        &ceInfo.arcl[i]);
                        }
                    }
                } while (bMore);

            }// Non-DC rect clipping

            DBG_GDI((6, "DrvStretchBlt return TRUE"));
            
            // Cleanup stretch settings
            vStretchReset(ppdev);
            InputBufferFlush(ppdev);
            
            return TRUE;
        
        }// source/dest withnin range
    }// No mask, trivial xlate, same BMP format

Punt_It:
    DBG_GDI((6, "DrvStretchBlt punt"));
    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                         pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode));
}// DrvStretchBlt()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\textout.c ===
/**********************************Module*Header********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: textout.c
 *
 * Text rendering module.
 *
 * Uses glyph expansion method.
 *
 * There are three basic methods for drawing text with hardware
 * acceleration:
 *
 * 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
 *       (probably in off-screen memory), and text is drawn by
 *       referring the hardware to the cached glyph locations.
 * 
 * 2) Glyph expansion -- Each individual glyph is colour-expanded
 *       directly to the screen from the monochrome glyph bitmap
 *       supplied by GDI.
 * 
 * 3) Buffer expansion -- The CPU is used to draw all the glyphs into
 *       a 1bpp monochrome bitmap, and the hardware is then used
 *       to colour-expand the result.
 * 
 * The fastest method depends on a number of variables, such as the
 * colour expansion speed, bus speed, CPU speed, average glyph size,
 * and average string length.
 * 
 * Currently we are using glyph expansion.  We will revisit this in the
 * next several months measuring the performance of text on the latest
 * hardware and the latest benchmarks.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
 
#include "precomp.h"
#include "gdi.h"

#include "clip.h"
#include "text.h"
#include "log.h"
#define ALLOC_TAG ALLOC_TAG_XT2P

#define GLYPH_CACHE_HEIGHT  48  // Number of scans to allocate for glyph cache,
                                //   divided by pel size

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((GLYPH_CACHE_CX * GLYPH_CACHE_CY + 31) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cx;         // Glyph width 
    LONG            cy;         // Glyph height 
    LONG            cd;         // Number of dwords to be transferred
    ULONG           cycx;
    ULONG           tag;
    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

RECTL grclMax = { 0, 0, 0x8000, 0x8000 };
                                // Maximal clip rectangle for trivial clipping

BYTE gajBit[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
                                // Converts bit index to set bit

//-----------------------------Private-Routine----------------------------------
// pcfAllocateCachedFont
//     ppdev (I) - PDev pointer
//
// Initializes our font data structure.
//
//------------------------------------------------------------------------------

CACHEDFONT* pcfAllocateCachedFont(
PDev* ppdev)
{
    CACHEDFONT*     pcf;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    pcf = (CACHEDFONT*) ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(CACHEDFONT), ALLOC_TAG);

    if (pcf != NULL)
    {
        //
        // Note that we rely on FL_ZERO_MEMORY to zero 'pgaChain' and
        // 'cjAlloc':
        //
        pcf->cgSentinel.hg = HGLYPH_SENTINEL;

        //
        // Initialize the hash table entries to all point to our sentinel:
        //
        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }
    }

    return(pcf);
}

//-----------------------------Private-Routine----------------------------------
// vTrimAndBitpackGlyph
//     pjBuf (I) - where to stick the trimmed and bit-packed glyph
//     pjGlyph (I) - points to the glyphs bits as given by GDI
//     pcxGlyph (O) - returns the trimmed width of the glyph
//     pcyGlyph (O) - returns the trimmed height of the glyph
//     pptlOrigin (O) - returns the trimmed origin of the glyph
//     pcj (O) - returns the number of bytes in the trimmed glyph
//
// This routine takes a GDI byte-aligned glyphbits definition, trims off
// any unused pixels on the sides, and creates a bit-packed result that
// is a natural for the S3's monochrome expansion capabilities.  
// "Bit-packed" is where a small monochrome bitmap is packed with no 
// unused bits between strides.  So if GDI gives us a 16x16 bitmap to 
// represent '.' that really only has a 2x2 array of lit pixels, we would
// trim the result to give a single byte value of 0xf0.
//
// Use this routine if your monochrome expansion hardware can do bit-packed
// expansion (this is the fastest method).  If your hardware requires byte-,
// word-, or dword-alignment on monochrome expansions, use 
// vTrimAndPackGlyph().
//
//------------------------------------------------------------------------------

VOID vTrimAndBitpackGlyph(
BYTE*   pjBuf,          // Note: Routine may touch preceding byte!
BYTE*   pjGlyph,
LONG*   pcxGlyph,
LONG*   pcyGlyph,
POINTL* pptlOrigin,
LONG*   pcj)            // For returning the count of bytes of the result
{
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    LONG    cAlign;
    LONG    lDelta;
    BYTE*   pj;
    BYTE    jBit;
    LONG    cjSrcWidth;
    LONG    lSrcSkip;
    LONG    lDstSkip;
    LONG    cRem;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    BYTE    jSrc;
    LONG    cj;

    ///////////////////////////////////////////////////////////////
    // Trim the glyph

    cyGlyph   = *pcyGlyph;
    cxGlyph   = *pcxGlyph;
    ptlOrigin = *pptlOrigin;
    cAlign    = 0;

    lDelta = (cxGlyph + 7) >> 3;

    //
    // Trim off any zero rows at the bottom of the glyph:
    //
    pj = pjGlyph + cyGlyph * lDelta;    // One past last byte in glyph
    while (cyGlyph > 0)
    {
        i = lDelta;
        do {
            if (*(--pj) != 0)
                goto Done_Bottom_Trim;
        } while (--i != 0);

        // The entire last row has no lit pixels, so simply skip it:

        cyGlyph--;
    }

    ASSERTDD(cyGlyph == 0, "cyGlyph should only be zero here");

    //
    // We found a space character.  Set both dimensions to zero, so
    // that it's easy to special-case later:
    //
    cxGlyph = 0;

Done_Bottom_Trim:

    //
    // If cxGlyph != 0, we know that the glyph has at least one non-zero
    // row and column.  By exploiting this knowledge, we can simplify our
    // end-of-loop tests, because we don't have to check to see if we've
    // decremented either 'cyGlyph' or 'cxGlyph' to zero:
    //
    if (cxGlyph != 0)
    {
        //
        // Trim off any zero rows at the top of the glyph:
        //

        pj = pjGlyph;                       // First byte in glyph
        while (TRUE)
        {
            i = lDelta;
            do {
                if (*(pj++) != 0)
                    goto Done_Top_Trim;
            } while (--i != 0);

            //
            // The entire first row has no lit pixels, so simply skip it:
            //

            cyGlyph--;
            ptlOrigin.y++;
            pjGlyph = pj;
        }

Done_Top_Trim:

        //
        // Trim off any zero columns at the right edge of the glyph:
        //

        while (TRUE)
        {
            j    = cxGlyph - 1;

            pj   = pjGlyph + (j >> 3);      // Last byte in first row of glyph
            jBit = gajBit[j & 0x7];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Right_Trim;

                pj += lDelta;
            } while (--i != 0);

            //
            // The entire last column has no lit pixels, so simply skip it:
            //

            cxGlyph--;
        }

Done_Right_Trim:

        //
        // Trim off any zero columns at the left edge of the glyph:
        //

        while (TRUE)
        {
            pj   = pjGlyph;                 // First byte in first row of glyph
            jBit = gajBit[cAlign];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Left_Trim;

                pj += lDelta;
            } while (--i != 0);

            //
            // The entire first column has no lit pixels, so simply skip it:
            //

            ptlOrigin.x++;
            cxGlyph--;
            cAlign++;
            if (cAlign >= 8)
            {
                cAlign = 0;
                pjGlyph++;
            }
        }
    }

Done_Left_Trim:

    ///////////////////////////////////////////////////////////////
    // Pack the glyph

    cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;
    lSrcSkip    = lDelta - cjSrcWidth;
    lDstSkip    = ((cxGlyph + 7) >> 3) - cjSrcWidth - 1;
    cRem        = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8

    pjSrc       = pjGlyph;
    pjDst       = pjBuf;

    //
    // Zero the buffer, because we're going to 'or' stuff into it:
    //

    memset(pjBuf, 0, (cxGlyph * cyGlyph + 7) >> 3);

    //
    // cAlign used to indicate which bit in the first byte of the unpacked
    // glyph was the first non-zero pixel column.  Now, we flip it to
    // indicate which bit in the packed byte will receive the next non-zero
    // glyph bit:
    //

    cAlign = (-cAlign) & 0x7;
    if (cAlign > 0)
    {
        //
        // It would be bad if our trimming calculations were wrong, because
        // we assume any bits to the left of the 'cAlign' bit will be zero.
        // As a result of this decrement, we will 'or' those zero bits into
        // whatever byte precedes the glyph bits array:
        //

        pjDst--;

        ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
    }

    for (i = cyGlyph; i != 0; i--)
    {
        for (j = cjSrcWidth; j != 0; j--)
        {
            //
            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:
            //

            jSrc = *pjSrc;
            *(pjDst)     |= (jSrc >> (cAlign));
            *(pjDst + 1) |= (jSrc << (8 - cAlign));
            pjSrc++;
            pjDst++;
        }

        pjSrc  += lSrcSkip;
        pjDst  += lDstSkip;
        cAlign += cRem;

        if (cAlign >= 8)
        {
            cAlign -= 8;
            pjDst++;
        }
    }

    cj = ((cxGlyph * cyGlyph) + 7) >> 3;

    ///////////////////////////////////////////////////////////////
    // Post-process the packed results to account for the Permedia's
    // preference for big-endian data on dword transfers.  If your
    // hardware doesn't need big-endian data, remove this step.

    for (pjSrc = pjBuf, i = (cj + 3) >> 2; i != 0; pjSrc += 4, i--)
    {
        jSrc = *(pjSrc);
        *(pjSrc) = *(pjSrc + 3);
        *(pjSrc + 3) = jSrc;

        jSrc = *(pjSrc + 1);
        *(pjSrc + 1) = *(pjSrc + 2);
        *(pjSrc + 2) = jSrc;
    }

    ///////////////////////////////////////////////////////////////
    // Return results

    *pcxGlyph   = cxGlyph;
    *pcyGlyph   = cyGlyph;
    *pptlOrigin = ptlOrigin;
    *pcj        = cj;
}

//-----------------------------Private-Routine----------------------------------
// cjPutGlyphInCache
//     ppdev (I) - pointer to physical device object
//     pcg (I) - our cache structure for this glyph
//     pgb (I) - GDI's glyph bits
//
// Figures out where to stick a glyph in the cache, copies it
// there, and fills in any other data we'll need to display the glyph.
//
// This routine is rather device-specific, and will have to be extensively
// modified for other display adapters.
//
// Returns the number of bytes taken by the cached glyph bits.
//
//------------------------------------------------------------------------------

LONG cjPutGlyphInCache(
PDev*           ppdev,
CACHEDGLYPH*    pcg,
GLYPHBITS*      pgb)
{
    BYTE*   pjGlyph;
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    BYTE*   pjSrc;
    ULONG*  pulDst;
    LONG    i;
    LONG    cPels;
    ULONG   ulGlyphThis;
    ULONG   ulGlyphNext;
    ULONG   ul;
    ULONG   ulStart;
    LONG    cj;

    pjGlyph   = pgb->aj;
    cyGlyph   = pgb->sizlBitmap.cy;
    cxGlyph   = pgb->sizlBitmap.cx;
    ptlOrigin = pgb->ptlOrigin;

    vTrimAndBitpackGlyph((BYTE*) &pcg->ad, pjGlyph, &cxGlyph, &cyGlyph,
                         &ptlOrigin, &cj);

    ///////////////////////////////////////////////////////////////
    // Initialize the glyph fields

    pcg->cd          = (cj + 3) >> 2;
    
    // We send an extra long to reset the BitMaskPattern register if we
    // have any unused bits in the last long.

    if(((cxGlyph * cyGlyph) & 0x1f) != 0)
        pcg->cd++;

    pcg->ptlOrigin   = ptlOrigin;
    pcg->cx          = cxGlyph;
    pcg->cy          = cyGlyph;
    pcg->cycx        = (cyGlyph << 16) | cxGlyph;
    pcg->tag         = ((pcg->cd - 1) << 16) | __Permedia2TagBitMaskPattern;

    return(cj);
}

//-----------------------------Private-Routine----------------------------------
// pcgNew
//     ppdev (I) - pointer to physical device object
//     pcf (I) - our cache structure for this font
//     pgp (I) - GDI's glyph position
//
// Creates a new CACHEDGLYPH structure for keeping track of the glyph in
// off-screen memory.  bPutGlyphInCache is called to actually put the glyph
// in off-screen memory.
//
// This routine should be reasonably device-independent, as bPutGlyphInCache
// will contain most of the code that will have to be modified for other
// display adapters.
//
//------------------------------------------------------------------------------

CACHEDGLYPH* pcgNew(
PDev*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp)
{
    GLYPHBITS*      pgb;
    GLYPHALLOC*     pga;
    CACHEDGLYPH*    pcg;
    LONG            cjCachedGlyph;
    HGLYPH          hg;
    LONG            iHash;
    CACHEDGLYPH*    pcgFind;
    LONG            cjGlyphRow;
    LONG            cj;

    //
    // First, calculate the amount of storage we'll need for this glyph:
    //

    pgb = pgp->pgdf->pgb;

    //
    // The glyphs are 'word-packed':
    //

    cjGlyphRow    = ((pgb->sizlBitmap.cx + 15) & ~15) >> 3;
    cjCachedGlyph = sizeof(CACHEDGLYPH) + (pgb->sizlBitmap.cy * cjGlyphRow);

    //
    // Reserve an extra byte at the end for temporary usage by our pack
    // routine:
    //

    cjCachedGlyph++;

    if (cjCachedGlyph > pcf->cjAlloc)
    {
        //
        // Have to allocate a new glyph allocation structure:
        //

        pga = (GLYPHALLOC*) ENGALLOCMEM(FL_ZERO_MEMORY, GLYPH_ALLOC_SIZE, ALLOC_TAG);
        if (pga == NULL)
        {
            //
            // It's safe to return at this time because we haven't
            // fatally altered any of our data structures:
            //

            return(NULL);
        }

        //
        // Add this allocation to the front of the allocation linked list,
        // so that we can free it later:
        //

        pga->pgaNext  = pcf->pgaChain;
        pcf->pgaChain = pga;

        //
        // Now we've got a chunk of memory where we can store our cached
        // glyphs:
        //

        pcf->pcgNew  = &pga->acg[0];
        pcf->cjAlloc = GLYPH_ALLOC_SIZE - (sizeof(*pga) - sizeof(pga->acg[0]));

        // Hack: we want to be able to safely read past the glyph data by
        //       one DWORD.  We ensure we can do this by not allocating
        //       the last DWORD out of the glyph cache block.  This is needed
        //       by glyphs which have unused bits in the last DWORD causing
        //       us to have to send an extra DWORD to reset the mask register.

        pcf->cjAlloc -= sizeof(DWORD);

        //
        // It would be bad if we let in any glyphs that would be bigger
        // than our basic allocation size:
        //

        ASSERTDD(cjCachedGlyph <= GLYPH_ALLOC_SIZE, "Woah, this is one big glyph!");
    }

    pcg = pcf->pcgNew;

    ///////////////////////////////////////////////////////////////
    // Insert the glyph, in-order, into the list hanging off our hash
    // bucket:

    hg = pgp->hg;

    pcg->hg = hg;
    iHash   = GLYPH_HASH_FUNC(hg);
    pcgFind = pcf->apcg[iHash];

    if (pcgFind->hg > hg)
    {
        pcf->apcg[iHash] = pcg;
        pcg->pcgNext     = pcgFind;
    }
    else
    {
        //
        // The sentinel will ensure that we never fall off the end of
        // this list:
        //

        while (pcgFind->pcgNext->hg < hg)
            pcgFind = pcgFind->pcgNext;

        //
        // 'pcgFind' now points to the entry to the entry after which
        // we want to insert our new node:
        //

        pcg->pcgNext     = pcgFind->pcgNext;
        pcgFind->pcgNext = pcg;
    }

    cj = cjPutGlyphInCache(ppdev, pcg, pgp->pgdf->pgb);

    ///////////////////////////////////////////////////////////////
    // We now know the size taken up by the packed and trimmed glyph;
    // adjust the pointer to the next glyph accordingly.  We only need
    // to ensure 'dword' alignment:

    cjCachedGlyph = sizeof(CACHEDGLYPH) + ((cj + 7) & ~7);

    pcf->pcgNew   = (CACHEDGLYPH*) ((BYTE*) pcg + cjCachedGlyph);
    pcf->cjAlloc -= cjCachedGlyph;

    return(pcg);
}


//------------------------------------------------------------------------------
// bCachedProportionalText
//
// Renders an array of proportional glyphs using the glyph cache
//
// ppdev-----pointer to physical device object
// pgp-------array of glyphs to render (all members of the pcf font)
// cGlyph----number of glyphs to render
//
// Returns TRUE if the glyphs were rendered
//------------------------------------------------------------------------------

BOOL bCachedProportionalText(
    PDev*       ppdev,
    CACHEDFONT* pcf,
    GLYPHPOS*   pgp,
    LONG        cGlyph)
{
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            cy;
    ULONG           i;
    ULONG*          pd;
    ULONG*          pBuffer;
    ULONG*          pReservationEnd;
    ULONG*          pBufferEnd;
    BOOL            bRet = TRUE;        // assume success
    
    InputBufferStart(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);

    // Reset BitMaskPattern in case there are some unused bits from
    // a previous command.
//@@BEGIN_DDKSPLIT
    // TODO: fix all other uses of SYNC_ON_BIT_MASK so that we don't
    // need to always do this here
//@@END_DDKSPLIT
    pBuffer[0] = __Permedia2TagBitMaskPattern;
//@@BEGIN_DDKSPLIT
    // TODO: remove the setting of pBuffer[1] (it can be garbage) when
    //       we implement the scratch buffer for handling the non-DMA
    //       case.
//@@END_DDKSPLIT    
    pBuffer[1] = 0;
    pBuffer = pReservationEnd;

    do {
        //
        // First lookup the glyph in our cache
        //
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext; // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            //
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.
            //
            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
            {
                bRet= FALSE;
                goto done;
            }
        }

        //
        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:
        //
        cy = pcg->cy;

        if (cy > 0)
        {
            ASSERTDD((pcg->cd <= (MAX_P2_FIFO_ENTRIES - 5)) &&
                     (MAX_GLYPH_SIZE / 4) <= (MAX_P2_FIFO_ENTRIES - 5),
                "Ack, glyph too large for FIFO!");

            //
            // NOTE: We send an extra bit mask pattern to reset the register.
            //       If we don't do this then a subsequent SYNC_ON_BIT_MASK
            //       will use these unused bits.
            //
//@@BEGIN_DDKSPLIT
            // TODO: We could further optimize this by noting that we only
            //       have to send the extra bit mask pattern DWORD if there
            //       are unused bits.  We could also play with the height
            //       width to make it so that this case becomes more common
            //
//@@END_DDKSPLIT
            ULONG   ulLongs = 7 + pcg->cd;

            InputBufferContinue(ppdev, ulLongs, &pBuffer, &pBufferEnd, &pReservationEnd);
            
            pBuffer[0] = __Permedia2TagRectangleOrigin;
            pBuffer[1] = ((pgp->ptl.y + pcg->ptlOrigin.y) << 16) |
                      (pgp->ptl.x + pcg->ptlOrigin.x);
            pBuffer[2] = __Permedia2TagRectangleSize;
            pBuffer[3] = pcg->cycx;
            pBuffer[4] = __Permedia2TagRender;
            pBuffer[5] = __RENDER_RECTANGLE_PRIMITIVE | __RENDER_SYNC_ON_BIT_MASK
                    | __RENDER_INCREASE_X | __RENDER_INCREASE_Y;
            pBuffer[6] = pcg->tag;

            pBuffer += 7;

            pd = &pcg->ad[0];

            do
            {
                *pBuffer++ = *pd++;
            } while(pBuffer < pReservationEnd);

        }

        pgp++;

    } while (--cGlyph != 0);

done:
    
    InputBufferCommit(ppdev, pBuffer);

    return(bRet);
}

//------------------------------------------------------------------------------
// bCachedProportionalText
//
// Renders an array of clipped glyphs using the glyph cache
//
// ppdev----------pointer to physical device object
// pcf------------pointer to cached font structure
// pgpOriginal----array of glyphs to render (all members of the pcf font)
// cGlyphOriginal-number of glyphs to render
// ulCharInc------increment for fixed space fonts
// pco------------clip object
//
// Returns TRUE if the glyphs were rendered
//------------------------------------------------------------------------------

BOOL bCachedClippedText(
PDev*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgpOriginal,
LONG        cGlyphOriginal,
ULONG       ulCharInc,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    BOOL            bClippingSet;
    LONG            cGlyph;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            cy;
    BOOL            bMore;
    ClipEnum        ce;
    RECTL*          prclClip;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    BYTE            iDComplexity;
    ULONG           i;
    ULONG*          pd;
    ULONG*          pBuffer;

    PERMEDIA_DECL;      // Declare and initialize local variables like 
                        //  'permediaInfo' and 'pPermedia'
    bRet      = TRUE;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (cGlyphOriginal > 0)
    {
      if (iDComplexity != DC_COMPLEX)
      {
        //
        // We could call 'cEnumStart' and 'bEnum' when the clipping is
        // DC_RECT, but the last time I checked, those two calls took
        // more than 150 instructions to go through GDI.  Since
        // 'rclBounds' already contains the DC_RECT clip rectangle,
        // and since it's such a common case, we'll special case it:
        //
        bMore = FALSE;
        ce.c  = 1;

        if (iDComplexity == DC_TRIVIAL)
            prclClip = &grclMax;
        else
            prclClip = &pco->rclBounds;

        goto SingleRectangle;
      }

      CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

      do {
        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

        for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
        {

        SingleRectangle:
          //
          // We don't always simply set the clipping rectangle here
          // because it may actually end up that no text intersects
          // this clip rectangle, so it would be for naught.  This
          // actually happens a lot when there is complex clipping.
          //
          bClippingSet = FALSE;

          pgp    = pgpOriginal;
          cGlyph = cGlyphOriginal;

          xGlyph = pgp->ptl.x;
          yGlyph = pgp->ptl.y;

          //
          // Loop through all the glyphs for this rectangle:
          //
          while (TRUE)
          {
            hg  = pgp->hg;
            pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

            while (pcg->hg < hg)
              pcg = pcg->pcgNext;

            if (pcg->hg > hg)
            {
              //
              // This will hopefully not be the common case (that is,
              // we will have a high cache hit rate), so if I were
              // writing this in Asm I would have this out-of-line
              // to avoid the jump around for the common case.
              // But the Pentium has branch prediction, so what the
              // heck.
              //
              pcg = pcgNew(ppdev, pcf, pgp);
              if (pcg == NULL)
              {
                bRet = FALSE;
                goto AllDone;
              }
            }

            //
            // Space glyphs are trimmed to a height of zero, and we don't
            // even have to touch the hardware for them:
            //
            cy = pcg->cy;
            if (cy > 0)
            {
              y      = pcg->ptlOrigin.y + yGlyph;
              x      = pcg->ptlOrigin.x + xGlyph;
              xRight = pcg->cx + x;

              //
              // Do trivial rejection:
              //
              if ((prclClip->right  > x) &&
                  (prclClip->bottom > y) &&
                  (prclClip->left   < xRight) &&
                  (prclClip->top    < y + cy))
              {
                //
                // Lazily set the hardware clipping:
                //
                if ((iDComplexity != DC_TRIVIAL) && (!bClippingSet))
                {
                  bClippingSet = TRUE;

                  InputBufferReserve(ppdev, 6, &pBuffer);

                  pBuffer[0] = __Permedia2TagScissorMode;
                  pBuffer[1] =  USER_SCISSOR_ENABLE |
                                SCREEN_SCISSOR_DEFAULT;
                  pBuffer[2] = __Permedia2TagScissorMinXY;
                  pBuffer[3] =  (prclClip->top << 16) | prclClip->left;
                  pBuffer[4] = __Permedia2TagScissorMaxXY;
                  pBuffer[5] =  (prclClip->bottom << 16) | prclClip->right;

                  pBuffer += 6;

                  InputBufferCommit(ppdev, pBuffer);
                }
                
                InputBufferReserve(ppdev, 10, &pBuffer);

                pBuffer[0] = __Permedia2TagCount;
                pBuffer[1] =  cy;
                pBuffer[2] = __Permedia2TagStartY;
                pBuffer[3] =  INTtoFIXED(y);
                pBuffer[4] = __Permedia2TagStartXDom;
                pBuffer[5] =  INTtoFIXED(x);
                pBuffer[6] = __Permedia2TagStartXSub;
                pBuffer[7] =  INTtoFIXED(xRight);

                pBuffer[8] = __Permedia2TagRender;
                pBuffer[9] = __RENDER_TRAPEZOID_PRIMITIVE 
                           | __RENDER_SYNC_ON_BIT_MASK;

                pBuffer += 10;
    
                InputBufferCommit(ppdev, pBuffer);

                InputBufferReserve(ppdev, pcg->cd + 1, &pBuffer);
                
                *pBuffer++ = (pcg->cd - 1) << 16 | __Permedia2TagBitMaskPattern;
                
                pd = &pcg->ad[0];
                i = pcg->cd;

                do {
                  *pBuffer++ =  *pd;  
                  pd++;
    
                } while (--i != 0);
    
                InputBufferCommit(ppdev, pBuffer);

              }
            }

            if (--cGlyph == 0)
              break;

            //
            // Get ready for next glyph:
            //
            pgp++;

            if (ulCharInc == 0)
            {
              xGlyph = pgp->ptl.x;
              yGlyph = pgp->ptl.y;
            }
            else
            {
              xGlyph += ulCharInc;
            }
          }
        }
      } while (bMore);
    }

AllDone:

    if (iDComplexity != DC_TRIVIAL)
    {
        //
        // Reset the clipping.
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] =  SCREEN_SCISSOR_DEFAULT;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

    return(bRet);
}

//-----------------------------Private-Routine----------------------------------
// vClipSolid
//     ppdev (I) - pointer to physical device object
//     prcl (I) - number of rectangles
//     prcl (I) - array of rectangles
//     iColor (I) - the solid fill color
//     pco (I) - pointer to the clip region object
//
// Fill a series of opaquing rectangles clipped by pco with the given solid
// color.   This function should only be called when the clipping operation
// is non-trivial.
//
//------------------------------------------------------------------------------

VOID vClipSolid(
    PDev*           ppdev,
    Surf *          psurf,
    LONG            crcl,
    RECTL*          prcl,
    ULONG           iColor,
    CLIPOBJ*        pco)
{
    BOOL            bMore;
    ClipEnum        ce;
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBrushColor    rbc;
    GFNPB           pb;

    ASSERTDD((crcl > 0) && (crcl <= 4),
                "vClipSolid: expected 1 to 4 rectangles");

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                "vClipColid: expected a non-null clip object");

    pb.ppdev = ppdev;
    pb.psurfDst = psurf;
    pb.solidColor = iColor;

    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            pb.lNumRects = crcl;
            pb.pRects = prcl;

            ppdev->pgfnSolidFill(&pb);
            
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill
        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:
        do 
        {
            // Get a batch of region rectangles:
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);

            // Clip the rect list to each region rect:
            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.
                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:
                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:
                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:
                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles
                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:
                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects
                    if (crclTmp != 0)
                    {
                        pb.lNumRects = crclTmp;
                        pb.pRects = &arclTmp[0];

                        ppdev->pgfnSolidFill(&pb);
                    }
                }
            }
        } 
        while (bMore);
    }
}// vClipSolid()

//-----------------------------Public-Routine-----------------------------------
// DrvTextOut
//       pso (I) - pointer to surface object to render to
//       pstro (I) - pointer to the string object to be rendered
//       pfo (I) - pointer to the font object
//       pco (I) - pointer to the clip region object
//       prclExtra (I) - If we had set GCAPS_HORIZSTRIKE, we would have to 
//                       fill these extra rectangles (it is used  largely 
//                       for underlines). It's not a big performance win
//                       (GDI will call our DrvBitBlt to draw these).
//       prclOpaque (I) - pointer to the opaque background rectangle
//       pboFore (I) - pointer to the foreground brush object
//       pboOpaque (I) - ptr to the brush for the opaque background rectangle
//       pptlBrush (I) - pointer to the brush origin, Always unused, unless 
//                       GCAPS_ARBRUSHOPAQUE set
//       mix (I) - should always be a COPY operation
// 
// Returns TRUE if the text has been rendered
//
//------------------------------------------------------------------------------

BOOL
DrvTextOut(SURFOBJ*     pso,
           STROBJ*      pstro,
           FONTOBJ*     pfo,
           CLIPOBJ*     pco,
           RECTL*       prclExtra,
           RECTL*       prclOpaque,
           BRUSHOBJ*    pboFore,
           BRUSHOBJ*    pboOpaque,
           POINTL*      pptlBrush, 
           MIX          mix)
{
    PDev*           ppdev;
    Surf*           psurf;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    RECTL           rclOpaque;
    BOOL            bRet = TRUE;
    CACHEDFONT*     pcf;
    PULONG          pBuffer;
    ULONG           ulColor;

    psurf = (Surf*)pso->dhsurf;
    ppdev  = (PDev*)pso->dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvTextOut: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(ppdev);
    
    //
    // The DDI spec says we'll only ever get foreground and background mixes
    // of R2_COPYPEN:
    //
    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");
    ASSERTDD(pco != NULL, "Expect non-null pco");
    ASSERTDD(psurf->flags & SF_VM, "expected video memory destination");

    iDComplexity = pco->iDComplexity;

    //
    //glyph rendering initialisation
    //

    InputBufferReserve(ppdev, 16, &pBuffer);

    pBuffer[0] = __Permedia2TagFBReadMode;
    pBuffer[1] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                 PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

    if(pfo->flFontType & FO_GRAY16)
        pBuffer[1] |= PM_FBREADMODE_READDEST( __PERMEDIA_ENABLE);

    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] = __PERMEDIA_CONSTANT_FB_WRITE;

    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] = psurf->ulPixOffset;

    pBuffer += 6;

    if ( prclOpaque != NULL )
    {
        //
        // Opaque Initialization
        //
        if ( iDComplexity == DC_TRIVIAL )
        {

        DrawOpaqueRect:

//@@BEGIN_DDKSPLIT
            // TODO: use color expansion macro
//@@END_DDKSPLIT

            ulColor = pboOpaque->iSolidColor;

            if ( ppdev->cPelSize < 2 )
            {
                ulColor |= ulColor << 16;
                if ( ppdev->cPelSize == 0 )
                {
                    ulColor |= ulColor << 8;
                }
            }

            //
            // Check the block colour
            //
            pBuffer[0] = __Permedia2TagFBBlockColor;
            pBuffer[1] = ulColor;
            pBuffer[2] = __Permedia2TagRectangleOrigin;
            pBuffer[3] = RECTORIGIN_YX(prclOpaque->top,prclOpaque->left);
            pBuffer[4] = __Permedia2TagRectangleSize;
            pBuffer[5] = ((prclOpaque->bottom - prclOpaque->top) << 16) |
                         (prclOpaque->right - prclOpaque->left);
            pBuffer[6] = __Permedia2TagRender;
            pBuffer[7] = __RENDER_FAST_FILL_ENABLE
                       | __RENDER_RECTANGLE_PRIMITIVE
                       | __RENDER_INCREASE_X
                       | __RENDER_INCREASE_Y;


            pBuffer += 8;

        }
        else if ( iDComplexity == DC_RECT )
        {
            if ( bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque) )
            {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
            }
        }
        else
        {
            //
            // vClipSolid modifies the rect list we pass in but prclOpaque
            // is probably a GDI structure so don't change it. This is also
            // necessary for multi-headed drivers.
            //
            RECTL   tmpOpaque = *prclOpaque;

            InputBufferCommit(ppdev, pBuffer);

            vClipSolid(ppdev, psurf, 1, &tmpOpaque,
                       pboOpaque->iSolidColor, pco);
            
            // restore logicalOpMode
//@@BEGIN_DDKSPLIT
            // TODO: This is a hack, we can only assume that the state
            //       setup above is still valid except for logical op mode
            //       and the FBReadMode for the FO_GRAY16 case only.
            //
            //       We should rethink how to deal with the Permedia2
            //       state throughout the code.
//@@END_DDKSPLIT
            if(pfo->flFontType & FO_GRAY16)
            {
                InputBufferReserve(ppdev, 2, &pBuffer);
                pBuffer[0] = __Permedia2TagFBReadMode;
                pBuffer[1] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                             PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE) |
                             PM_FBREADMODE_READDEST(__PERMEDIA_ENABLE);
                pBuffer += 2;
                InputBufferCommit(ppdev, pBuffer);
            }
            InputBufferReserve(ppdev, 4, &pBuffer);
            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_CONSTANT_FB_WRITE;
            pBuffer += 2;
        }
    }
    // if ( prclOpaque != NULL )

    //
    // Transparent Initialization
    //
        

    if(pfo->flFontType & FO_GRAY16)
    {
        ASSERTDD(ppdev->cPelSize != 0, 
                 "DrvTextOut: unexpected aatext when in 8bpp");

        ulColor = pboFore->iSolidColor;

        if(ppdev->cPelSize == 1)
        {
            ULONG   blue = (ulColor & 0x1f);
            ULONG   green = (ulColor >> 5) & 0x3f;
            ULONG   red = (ulColor >> 11) & 0x1f;

            blue = (blue << 3) | (blue >> 2);
            green = (green << 2) | (green >> 4);
            red = (red << 3) | (red >> 2);

            ulColor = (blue << 16) | (green << 8) | red;
        }
        else
        {
            ulColor = SWAP_BR(ulColor);
        }

        pBuffer[0] = __Permedia2TagConstantColor;
        pBuffer[1] =  0xff000000 | ulColor;

        pBuffer += 2;
    }
    else
    {
        //
        // glyph foreground will be rendered using bitmask downloads
        //
        pBuffer[0] = __Permedia2TagFBWriteData;
        pBuffer[1] = pboFore->iSolidColor;

        pBuffer += 2;
    
    }

    InputBufferCommit(ppdev, pBuffer);

    STROBJ_vEnumStart(pstro);

    do 
    {
        if ( pstro->pgp != NULL )
        {
            //
            // There's only the one batch of glyphs, so save ourselves a
            // call
            //
            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if ( cGlyph > 0 )
        {
            //
            // We only cache reasonable-sized glyphs:
            //
            if ( pfo->flFontType & FO_GRAY16)
            {
                bRet = bClippedAAText(ppdev, pgp, cGlyph, 
                                    pstro->ulCharInc, pco);
            }
            else if ( ( pfo->cxMax <= GLYPH_CACHE_CX ) &&
                 ( pstro->rclBkGround.bottom - pstro->rclBkGround.top 
                    <= GLYPH_CACHE_CY ) )
            {
                pcf = (CACHEDFONT*) pfo->pvConsumer;
          
                if (pcf == NULL)
                {
                    pcf = pcfAllocateCachedFont(ppdev);
                    if (pcf == NULL)
                    {
                        DBG_GDI((0, "failing to allocate cached font"));
                        InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
                        #if MULTITHREADED
                            ppdev->ulLockCount--;
                            EngReleaseSemaphore(ppdev->hsemLock);
                        #endif
//@@END_DDKSPLIT

                        return(FALSE);
                    }
          
                    pfo->pvConsumer = pcf;
                }

                //
                // We special case trivially clipped proportional text because
                // that happens so frequently, and route everything else 
                // the generic clipped routine.  I used to also special case
                // trivially clipped, fixed text, but it happens so 
                // infrequently there's no point.
                //
                if ( (iDComplexity == DC_TRIVIAL ) && ( pstro->ulCharInc == 0 ) )
                {
                    bRet = bCachedProportionalText(ppdev, pcf, pgp, cGlyph);
                }
                else
                {
                    bRet = bCachedClippedText(ppdev, pcf, pgp, cGlyph, 
                                              pstro->ulCharInc, pco);
                }
            }
            else
            {
                bRet = bClippedText(ppdev, pgp, cGlyph, 
                                    pstro->ulCharInc, pco);
            }
        }
    } while ( bMoreGlyphs && bRet );

    InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    return (bRet);

}// DrvTextOut()


//-----------------------------Public-Routine-----------------------------------
// bEnableText
//     ppdev (I) - pointer to physical device object
//
// Always true for success.
//
// Peform any necessary initialization of PPDEV state or hardware state
// to enable accelerated text.
//
// If we were using a glyph cache, we would initialize the necessary data
// structures here.
//
//------------------------------------------------------------------------------
BOOL
bEnableText(PDev* ppdev)
{
    DBG_GDI((6, "bEnableText"));

    return (TRUE);
}// bEnableText()

//-----------------------------Public-Routine-----------------------------------
// vDisableText
//     ppdev (I) - pointer to physical device object
//
//
// Disable hardware text accelerations.  This may require changes to hardware
// state.  We should also free any resources allocated in bEnableText and
// make the neccesary changes to the PPDEV state to reflect that text
// accelerations have been disabled.
//
//------------------------------------------------------------------------------
VOID
vDisableText(PDev* ppdev)
{
    DBG_GDI((6, "vDisableText"));
}// vDisableText()

//-----------------------------Public*Routine-----------------------------------
// vAssertModeText
//     ppdev (I) - pointer to physical device object
//     bEnable (I) - TRUE to enable accelerated text, FALSE to disable
//                   accelerated test.
//
// Called when going to/from full screen mode.
//
//@@BEGIN_DDKSPLIT
// TODO: check to see if this is also called when setting modes.
//@@END_DDKSPLIT
//
//------------------------------------------------------------------------------

VOID vAssertModeText(PDev* ppdev, BOOL bEnable)
{

    DBG_GDI((5, "vAssertModeText"));
    
    if (!bEnable)
        vDisableText(ppdev);
    else
    {
        bEnableText(ppdev);
    }
}// vAssertModeText()

//-----------------------------Public-Routine-----------------------------------
// DrvDestroyFont
//       pfo (I) - pointer to the font object
//       pco (I) - pointer to the clip region object
//       prclExtra (I) - If we had set GCAPS_HORIZSTRIKE, we would have to 
//                       fill these extra rectangles (it is used  largely 
//                       for underlines). It's not a big performance win
//                       (GDI will call our DrvBitBlt to draw these).
//       prclOpaque (I) - pointer to the opaque background rectangle
//       pboFore (I) - pointer to the foreground brush object
//       pboOpaque (I) - ptr to the brush for the opaque background rectangle
//       pptlBrush (I) - pointer to the brush origin, Always unused, unless 
//                       GCAPS_ARBRUSHOPAQUE set
//       mix (I) - should always be a COPY operation
// 
// Frees any cached information we've stored with the font.  This routine
// is relevant only when caching glyphs.
//
// We're being notified that the given font is being deallocated; clean up
// anything we've stashed in the 'pvConsumer' field of the 'pfo'.
//
// Note: Don't forget to export this call in 'enable.c', otherwise you'll
//      get some pretty big memory leaks!
//
//------------------------------------------------------------------------------

VOID DrvDestroyFont(FONTOBJ* pfo)
{
    CACHEDFONT* pcf;

    pcf = (CACHEDFONT*) pfo->pvConsumer;
    if (pcf != NULL)
    {
        GLYPHALLOC* pga;
        GLYPHALLOC* pgaNext;
    
        pga = pcf->pgaChain;
        while (pga != NULL)
        {
            pgaNext = pga->pgaNext;
            ENGFREEMEM(pga);
            pga = pgaNext;
        }
    
        ENGFREEMEM(pcf);

        pfo->pvConsumer = NULL;
    }
}// DrvDestroyFont()

// Work in progress

VOID
vCheckGdiContext(PPDev ppdev)
{
    HwDataPtr   permediaInfo = ppdev->permediaInfo;

    ASSERTDD(ppdev->bEnabled, 
             "vCheckContext(): expect the device to be enabled");

    if(permediaInfo->pCurrentCtxt != permediaInfo->pGDICtxt)
    {
        P2SwitchContext(ppdev, permediaInfo->pGDICtxt);
    }

}

void FASTCALL InputBufferSwap(PPDev ppdev)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferSwap: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferSwap);
//@@END_DDKSPLIT
    
    if(ppdev->dmaBufferVirtualAddress != NULL)
    {
        LONG    lUsed = (LONG)(ppdev->pulInFifoPtr - ppdev->pulInFifoStart);

        while(READ_REGISTER_ULONG(ppdev->pulInputDmaCount) != 0) 
        {
            // do nothing
        }
    
        LONG offset = (LONG)((LONG_PTR)ppdev->pulInFifoStart  - (LONG_PTR)ppdev->dmaBufferVirtualAddress);
        LONG address =  ppdev->dmaBufferPhysicalAddress.LowPart + offset;
       
        WRITE_REGISTER_ULONG(ppdev->pulInputDmaAddress, address);
        MEMORY_BARRIER();
        WRITE_REGISTER_ULONG(ppdev->pulInputDmaCount,lUsed);
        MEMORY_BARRIER();
    
        if(ppdev->pulInFifoStart == ppdev->dmaBufferVirtualAddress)
            ppdev->pulInFifoStart += (INPUT_BUFFER_SIZE>>3);
        else
            ppdev->pulInFifoStart = ppdev->dmaBufferVirtualAddress;

        ppdev->pulInFifoEnd = ppdev->pulInFifoStart + (INPUT_BUFFER_SIZE>>3);
        ppdev->pulInFifoPtr = ppdev->pulInFifoStart;

    }
    else
    {
        ULONG*  pul = ppdev->pulInFifoStart;
        ULONG   available = 0;
        
        while(pul < ppdev->pulInFifoPtr)
        {
            while(available == 0)
            {
                available = READ_REGISTER_ULONG(ppdev->pulInputFifoCount);
                
                if(available == 0)
                {
                    StallExecution(ppdev->hDriver, 1);

                }

            }

            WRITE_REGISTER_ULONG(ppdev->pulFifo, *pul++);
            MEMORY_BARRIER();
            available--;
        }

        ppdev->pulInFifoPtr = ppdev->pulInFifoStart;
    }

}

void FASTCALL InputBufferFlush(PPDev ppdev)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferFlush: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferFlush);
//@@END_DDKSPLIT
    
    ppdev->bNeedSync = TRUE;
    
    if(ppdev->dmaBufferVirtualAddress != NULL)
    {
        if(READ_REGISTER_ULONG(ppdev->pulInputDmaCount) == 0)
            InputBufferSwap(ppdev);
    }
    else
    {
        InputBufferSwap(ppdev);
    }
}

//
// Used for debugging purposes to record whether the driver had to
// bail out of the while loop inside InputBufferSync
//

ULONG gSyncInfiniteLoopCount = 0;

VOID
InputBufferSync(PPDev ppdev)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferSync: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferSync);
//@@END_DDKSPLIT
    
    ULONG * pBuffer;

    if(ppdev->bNeedSync)
    {

        DBG_GDI((6, "InputBufferSync()"));

        InputBufferReserve(ppdev, 6, &pBuffer);
    
        pBuffer[0] = __Permedia2TagFilterMode;
        pBuffer[1] =  0x400;
        pBuffer[2] = __Permedia2TagSync;
        pBuffer[3] =  0L; 
        pBuffer[4] =__Permedia2TagFilterMode;
        pBuffer[5] = 0x0;
        pBuffer += 6;
    
        InputBufferCommit(ppdev, pBuffer);
    
        InputBufferSwap(ppdev);
    
        if(ppdev->dmaBufferVirtualAddress != NULL)
        {
            while(READ_REGISTER_ULONG(ppdev->pulInputDmaCount) != 0) 
            {
                StallExecution(ppdev->hDriver, 1);
            }
        }
    
        while(1)
        {
            ULONG   ulStallCount = 0;

            while(READ_REGISTER_ULONG(ppdev->pulOutputFifoCount) == 0)
            {
                StallExecution(ppdev->hDriver, 1);

                // If we are stuck here for one seconds then break
                // out of the loop.  We have noticed that we will
                // occasionally hit this case and are able to
                // continue without futher problems.  This really
                // should never happen but we have been unable to
                // find the cause of these occasional problems.

                if(++ulStallCount == 1000000)
                {
                    DBG_GDI((6, "InputBufferSync(): infinite loop detected"));
                    gSyncInfiniteLoopCount++;
                    goto bail;
                }
            }
        
            ULONG data = READ_REGISTER_ULONG(ppdev->pulFifo);
    
            if(data != __Permedia2TagSync)
            {
                DBG_GDI((0, "Data other then sync found at output fifo"));
            }
            else
            {
                break;
            }
        }

bail:

        ppdev->bNeedSync = FALSE;
    }
}

#if DBG
void InputBufferStart(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferStart: not in gdi context");
    ASSERTDD(ppdev->ulReserved == 0, 
                "InputBufferStart: called with outstanding reservation");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferStart);
//@@END_DDKSPLIT
    
    *(ppulBuffer) = ppdev->pulInFifoPtr;
    *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs;
    *(ppulBufferEnd) = ppdev->pulInFifoEnd;
    if(*(ppulReservationEnd) > *(ppulBufferEnd))
    {
        InputBufferSwap(ppdev);
        *(ppulBuffer) = ppdev->pulInFifoPtr;
        *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs;
        *(ppulBufferEnd) = ppdev->pulInFifoEnd;
    }

    for(int index = 0; index < (int) ulLongs; index++)
        ppdev->pulInFifoPtr[index] = 0xDEADBEEF;

    ppdev->ulReserved = ulLongs;
}

void InputBufferContinue(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferContinue: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferContinue);
//@@END_DDKSPLIT
    
    LONG    lUsed = (LONG)(*(ppulBuffer) - ppdev->pulInFifoPtr);
    
    if(lUsed > (LONG) ppdev->ulReserved)
    {
        DebugPrint(0, "InputBuffeContinue: exceeded reservation %d (%d)",
                        ppdev->ulReserved, lUsed);
        EngDebugBreak();
    }

    for(int index = 0; index < lUsed; index++)
        if(ppdev->pulInFifoPtr[index] == 0xDEADBEEF)
        {
            DebugPrint(0, "InputBufferContinue: buffer entry %d not set", index);
            EngDebugBreak();
        }

    ppdev->pulInFifoPtr = *(ppulBuffer);
    *(ppulReservationEnd) = *(ppulBuffer) + ulLongs;
    if(*(ppulReservationEnd) > *(ppulBufferEnd))
    {
        InputBufferSwap(ppdev);
        *(ppulBuffer) = ppdev->pulInFifoPtr;
        *(ppulReservationEnd) = *(ppulBuffer) + ulLongs;
        *(ppulBufferEnd) = ppdev->pulInFifoEnd;
    }

    for(index = 0; index < (int) ulLongs; index++)
        ppdev->pulInFifoPtr[index] = 0xDEADBEEF;

    ppdev->ulReserved = ulLongs;
}

void InputBufferReserve(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferReserve: not in gdi context");
    ASSERTDD(ppdev->ulReserved == 0, 
                    "InputBufferReserve: called with outstanding reservation");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferReserve);
//@@END_DDKSPLIT
    
    if(ppdev->pulInFifoPtr + ulLongs > ppdev->pulInFifoEnd)
    {
        InputBufferSwap(ppdev);
    }
    *(ppulBuffer) = ppdev->pulInFifoPtr;

    for(int index = 0; index < (int) ulLongs; index++)
        ppdev->pulInFifoPtr[index] = 0xDEADBEEF;

    ppdev->ulReserved = ulLongs;

}

void InputBufferCommit(
    PPDev   ppdev,
    PULONG  pulBuffer)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferCommit: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferCommit);
//@@END_DDKSPLIT
    
    LONG    lUsed = (LONG)(pulBuffer - ppdev->pulInFifoPtr);

    if(lUsed > (LONG) ppdev->ulReserved)
    {
        DebugPrint(0, "InputBuffeCommit: exceeded reservation %d (%d)",
                        ppdev->ulReserved, lUsed);
        EngDebugBreak();
    }
    ppdev->ulReserved = 0;

    for(int index = 0; index < lUsed; index++)
        if(ppdev->pulInFifoPtr[index] == 0xDEADBEEF)
        {
            DebugPrint(0, "InputBuffer Commit: buffer entry %d not set", index);
            EngDebugBreak();
        }

    ppdev->pulInFifoPtr = pulBuffer;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\text.h ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: text.h
*
* Text rendering support routines.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/

#ifndef __TEXT__
#define __TEXT__

extern BOOL bEnableText(PDev*);
extern VOID vDisableText(PDev*);
extern VOID vAssertModeText(PDev*, BOOL);

extern BOOL bProportionalText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph);

extern BOOL bFixedText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph,
   ULONG ulCharInc);

extern BOOL  bClippedText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph,
    ULONG ulCharInc,
    CLIPOBJ* pco);

extern BOOL  bClippedAAText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph,
    ULONG ulCharInc,
    CLIPOBJ* pco);
#endif // __TEXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\text.c ===
/******************************Module*Header***********************************\
* Module Name: text.c
*
* Non-cached glyph rendering functions.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"

// The shift equations are a nuisance. We want x<<32 to be
// zero but some processors only use the bottom 5 bits
// of the shift value. So if we want to shift by n bits
// where we know that n may be 32, we do it in two parts.
// It turns out that in the algorithms below we get either
// (32 <= n < 0) or (32 < n <= 0). We use the macro for
// the first one and a normal shift for the second.
//
#define SHIFT_LEFT(src, n)  (((src) << ((n)-1)) << 1)


//------------------------------------------------------------------------------
// FUNC: bClippedText
//
// Renders an array of proportional or monospaced glyphs within a non-trivial
// clip region
//
// ppdev------pointer to physical device object
// pgp--------array of glyphs to render (all members of the pcf font)
// cGlyph-----number of glyphs to render
// ulCharInc--fixed character spacing increment (0 if proportional font)
// pco--------pointer to the clip region object
//
// Returns TRUE if string object rendered
//------------------------------------------------------------------------------
BOOL
bClippedText(PDev*      ppdev,
             GLYPHPOS*  pgp,
             LONG       cGlyph, 
             ULONG      ulCharInc,
             CLIPOBJ*   pco)
{
    LONG    cGlyphOriginal;
    GLYPHPOS    *pgpOriginal;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    ClipEnum    ce;
    RECTL*      prclClip;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    LONG        x;
    DWORD       renderBits;
    LONG        unused;
    LONG        rShift;
    ULONG       bits;
    ULONG       bitWord;
    ULONG*      pBuffer;
    ULONG*      pBufferEnd;
    ULONG*      pReservationEnd;

    PERMEDIA_DECL;
    
    DBG_GDI((7, "bClippedText: entered for %d glyphs", cGlyph));

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //we'll go through the glyph list for each of the clipping rectangles
    cGlyphOriginal = cGlyph;
    pgpOriginal = pgp;

    renderBits = __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_SYNC_ON_BIT_MASK;

    // since we are clipping, assume that we will need the scissor clip. So
    // enable user level scissoring here. We disable it just before returning.
    //
    
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = USER_SCISSOR_ENABLE | SCREEN_SCISSOR_DEFAULT;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    if (pco->iDComplexity != DC_COMPLEX)
    {
        // We could call 'cEnumStart' and 'bEnum' when the clipping is
        // DC_RECT, but the last time I checked, those two calls took
        // more than 150 instructions to go through GDI.  Since
        // 'rclBounds' already contains the DC_RECT clip rectangle,
        // and since it's such a common case, we'll special case it:
        DBG_GDI((7, "bClippedText: Enumerating rectangular clip region"));
        bMore    = FALSE;
        prclClip = &pco->rclBounds;
        ce.c     = 1;

        goto SingleRectangle;
    }

    DBG_GDI((7, "bClippedText: Enumerating complex clip region"));
    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

    do 
    {
      bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

      for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
      {
        cGlyph = cGlyphOriginal;
        pgp = pgpOriginal;

      SingleRectangle:
        pgb = pgp->pgdf->pgb;

        ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
        ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

        // load Permedia2 scissor clip to trap partially clipped glyphs. We still
        // check whether a glyph is completely clipped out as an optimisation.
        // I suppose that since we construct the bits to download to Permedia2, with
        // a bit more work I could do the clipping while downloading the bits.
        // But, in the future we will probably cache the packed bits anyway so
        // use the scissor. Wait for the first 5 FIFO entries here as well.
        //
        DBG_GDI((7, "bClippedText: loading scissor clip (%d,%d):(%d,%d)",
                    prclClip->left, prclClip->top,
                    prclClip->right, prclClip->bottom));

        InputBufferReserve(ppdev, 4, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMinXY;
        pBuffer[1] = (prclClip->top << 16) | (prclClip->left);
        pBuffer[2] = __Permedia2TagScissorMaxXY;
        pBuffer[3] = (prclClip->bottom << 16) | (prclClip->right);

        pBuffer += 4;

        InputBufferCommit(ppdev, pBuffer);

        // Loop through all the glyphs for this rectangle:
        for(;;)
        {
          cxGlyph = pgb->sizlBitmap.cx;
          cyGlyph = pgb->sizlBitmap.cy;

          // reject completely clipped out glyphs
          if ((prclClip->right  <= ptlOrigin.x) || 
              (prclClip->bottom <= ptlOrigin.y) ||
              (prclClip->left   >= ptlOrigin.x + cxGlyph) || 
              (prclClip->top    >= ptlOrigin.y + cyGlyph))
          {
                  DBG_GDI((7, "bClippedText: glyph clipped at (%d,%d):(%d,%d)",
                            ptlOrigin.x, ptlOrigin.y,
                            ptlOrigin.x + cxGlyph, ptlOrigin.y + cyGlyph));
                goto ContinueGlyphs;
          }

          pjGlyph = pgb->aj;
          cyGlyph = pgb->sizlBitmap.cy;
          x = ptlOrigin.x;

          unused = 32;
          bitWord = 0;

          DBG_GDI((7, "bClippedText: glyph clipped at (%d,%d):(%d,%d)",
                      x, ptlOrigin.y, x + cxGlyph, ptlOrigin.y + cyGlyph));

          InputBufferReserve(ppdev, 10, &pBuffer);

          pBuffer[0] = __Permedia2TagStartXDom;
          pBuffer[1] =  INTtoFIXED(x);

          pBuffer[2] = __Permedia2TagStartXSub;
          pBuffer[3] = INTtoFIXED(x + cxGlyph);
          pBuffer[4] = __Permedia2TagStartY;
          pBuffer[5] = INTtoFIXED(ptlOrigin.y);
          pBuffer[6] = __Permedia2TagCount;
          pBuffer[7] = cyGlyph;
          pBuffer[8] = __Permedia2TagRender;
          pBuffer[9] = renderBits;

          pBuffer += 10;

          InputBufferCommit(ppdev, pBuffer);

          DBG_GDI((7, "bClippedText: downloading %d pel wide glyph",
                     cxGlyph));

          InputBufferStart(ppdev, 100, &pBuffer, &pBufferEnd, &pReservationEnd);

          if (cxGlyph <= 8)
          {
                //-----------------------------------------------------
                // 1 to 8 pels in width

                BYTE    *pSrcB;

                pSrcB = pjGlyph;
                rShift = 8 - cxGlyph;
                for(;;)	
                {
                    bits = *pSrcB >> rShift;
                    unused -= cxGlyph;
                    if (unused > 0)
                        bitWord |= bits << unused;
                    else 
                    {
                        bitWord |= bits >> -unused;
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        unused += 32;
                        bitWord = SHIFT_LEFT(bits, unused);
                    }
                    if (--cyGlyph == 0)
                        break;
                    ++pSrcB;
                }
            }
            else if (cxGlyph <= 16)
            {
              //-----------------------------------------------------
              // 9 to 16 pels in width

                USHORT  *pSrcW;

                pSrcW = (USHORT *)pjGlyph;
                rShift = 32 - cxGlyph;
                for(;;) 
                {
                    bits = *pSrcW;
                    bits = ((bits << 24) | (bits << 8)) >> rShift;
                    unused -= cxGlyph;
                    if (unused > 0)
                        bitWord |= bits << unused;
                    else 
                    {
                        bitWord |= bits >> -unused;
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        unused += 32;
                        bitWord = SHIFT_LEFT(bits, unused);
                    }
                    if (--cyGlyph == 0)
                        break;
                    ++pSrcW;
                }
            }
            else
            {
              //-----------------------------------------------------
              // More than 16 pels in width

                ULONG *pSrcL;
                LONG    nRight;
                LONG    nRemainder;
                LONG    lDelta;

                lDelta = (cxGlyph + 7) >> 3;
                for(;;) 
                {
                    pSrcL = (ULONG*)((INT_PTR)pjGlyph & ~3);
                    nRight=(LONG)(32-(((INT_PTR)pjGlyph-(INT_PTR)pSrcL) << 3));
                    LSWAP_BYTES(bits, pSrcL);
                    bits &= SHIFT_LEFT(1, nRight) - 1;
                    nRemainder = cxGlyph - nRight;
                    if (nRemainder < 0) 
                    {
                        bits >>= -nRemainder;
                        nRight = cxGlyph;
                        nRemainder = 0;
                    }
                    unused -= nRight;
                    if (unused > 0)
                        bitWord |= bits << unused;
                    else 
                    {
                        bitWord |= bits >> -unused;
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        unused += 32;
                        bitWord = SHIFT_LEFT(bits, unused);
                    }

                    while (nRemainder >= 32) 
                    {
                        ++pSrcL;
                        LSWAP_BYTES(bits, pSrcL);
                        bitWord |= bits >> (32 - unused);
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        bitWord = SHIFT_LEFT(bits, unused);
                        nRemainder -= 32;
                    }

                    if (nRemainder > 0) 
                    {
                        ++pSrcL;
                        LSWAP_BYTES(bits, pSrcL);
                        bits >>= (32 - nRemainder);
                        unused -= nRemainder;
                        if (unused > 0)
                            bitWord |= bits << unused;
                        else 
                        {
                            bitWord |= bits >> -unused;

                            InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                                &pReservationEnd);

                            pBuffer[0] = __Permedia2TagBitMaskPattern;
                            pBuffer[1] = bitWord;

                            pBuffer += 2;

                            unused += 32;
                            bitWord = SHIFT_LEFT(bits, unused);
                        }
                    }

                    if (--cyGlyph == 0)
                        break;

                    /* go onto next scanline */
                    pjGlyph += lDelta;
                }
            }
            
            // complete the bit download
            if (unused < 32) 
            {
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                    &pReservationEnd);

                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;

                pBuffer += 2;
            }

            InputBufferCommit(ppdev, pBuffer);

            DBG_GDI((7, "bClippedText: download completed"));

ContinueGlyphs:
            if (--cGlyph == 0)
              break;

            DBG_GDI((7, "bClippedText: %d still to render", cGlyph));

            // Get ready for next glyph:
            pgp++;
            pgb = pgp->pgdf->pgb;

            if (ulCharInc == 0)
            {
              ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
              ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
            }
            else
            {
              ptlOrigin.x += ulCharInc;
            }

          }
        }

    } while (bMore);

    // reset the scissor. default is the whole of VRAM.
    DBG_GDI((20, "bClippedText: resetting scissor clip"));
    
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = SCREEN_SCISSOR_DEFAULT;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "bClippedText: exited"));

    return(TRUE);
}

//------------------------------------------------------------------------------
// FUNC: bClippedAAText
//
// Renders an array of proportional or monospaced anti-aliassed glyphs within
// a non-trivial clip region
//
// ppdev------pointer to physical device object
// pgp--------array of glyphs to render (all members of the pcf font)
// cGlyph-----number of glyphs to render
// ulCharInc--fixed character spacing increment (0 if proportional font)
// pco--------pointer to the clip region object
//
// Returns TRUE if string object rendered
//------------------------------------------------------------------------------
BOOL
bClippedAAText(PDev*      ppdev,
             GLYPHPOS*  pgp,
             LONG       cGlyph, 
             ULONG      ulCharInc,
             CLIPOBJ*   pco)
{
    LONG    cGlyphOriginal;
    GLYPHPOS    *pgpOriginal;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    ClipEnum    ce;
    RECTL*      prclClip;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    LONG        x;
    DWORD       renderBits;
    LONG        unused;
    LONG        rShift;
    ULONG       bits;
    ULONG       bitWord;
    ULONG*      pBuffer;
    ULONG*      pBufferEnd;
    ULONG*      pReservationEnd;

    PERMEDIA_DECL;
    
    DBG_GDI((7, "bClippedAAText: entered for %d glyphs", cGlyph));

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //we'll go through the glyph list for each of the clipping rectangles

    cGlyphOriginal = cGlyph;
    pgpOriginal = pgp;

    renderBits = __RENDER_TRAPEZOID_PRIMITIVE |
                 __RENDER_TEXTURED_PRIMITIVE |
                 __RENDER_SYNC_ON_HOST_DATA;

    // since we are clipping, assume that we will need the scissor clip. So
    // enable user level scissoring here. We disable it just before returning.
    //
    
    InputBufferReserve(ppdev, 14, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = USER_SCISSOR_ENABLE | SCREEN_SCISSOR_DEFAULT;

    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[4] = __Permedia2TagAlphaBlendMode;
    pBuffer[5] = (0 << PM_ALPHABLENDMODE_BLENDTYPE) |  // RGB
                 (1 << PM_ALPHABLENDMODE_COLORORDER) | // RGB
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (84 << PM_ALPHABLENDMODE_OPERATION) | // PreMult
                 (ppdev->ulPermFormat << PM_ALPHABLENDMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_ALPHABLENDMODE_COLORFORMATEXTENSION);
    
    pBuffer[6] = __Permedia2TagLogicalOpMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (0 << 1);  // Modulate
    
    pBuffer[10] = __Permedia2TagTextureDataFormat;
    pBuffer[11] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                  (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                  (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[12] = __Permedia2TagColorDDAMode;
    pBuffer[13] = 1;
    
    pBuffer += 14;

    InputBufferCommit(ppdev, pBuffer);

    if (pco->iDComplexity != DC_COMPLEX)
    {
        // We could call 'cEnumStart' and 'bEnum' when the clipping is
        // DC_RECT, but the last time I checked, those two calls took
        // more than 150 instructions to go through GDI.  Since
        // 'rclBounds' already contains the DC_RECT clip rectangle,
        // and since it's such a common case, we'll special case it:
        DBG_GDI((7, "bClippedText: Enumerating rectangular clip region"));
        bMore    = FALSE;
        prclClip = &pco->rclBounds;
        ce.c     = 1;
        
        goto SingleRectangle;
    }

    DBG_GDI((7, "bClippedAAText: Enumerating complex clip region"));
    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

    do 
    {
        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
        
        for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
        {
            cGlyph = cGlyphOriginal;
            pgp = pgpOriginal;
            
        SingleRectangle:

            pgb = pgp->pgdf->pgb;
            
            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;
            
            // load Permedia2 scissor clip to trap partially clipped glyphs. We still
            // check whether a glyph is completely clipped out as an optimisation.
            // I suppose that since we construct the bits to download to Permedia2, with
            // a bit more work I could do the clipping while downloading the bits.
            // But, in the future we will probably cache the packed bits anyway so
            // use the scissor. Wait for the first 5 FIFO entries here as well.
            //
            DBG_GDI((7, "bClippedAAText: loading scissor clip (%d,%d):(%d,%d)",
                    prclClip->left, prclClip->top,
                    prclClip->right, prclClip->bottom));
            
            InputBufferReserve(ppdev, 4, &pBuffer);
            
            pBuffer[0] = __Permedia2TagScissorMinXY;
            pBuffer[1] = (prclClip->top << 16) | (prclClip->left);
            pBuffer[2] = __Permedia2TagScissorMaxXY;
            pBuffer[3] = (prclClip->bottom << 16) | (prclClip->right);
            
            pBuffer += 4;
            
            InputBufferCommit(ppdev, pBuffer);
            
            // Loop through all the glyphs for this rectangle:
            for(;;)
            {
                cxGlyph = pgb->sizlBitmap.cx;
                cyGlyph = pgb->sizlBitmap.cy;
                
                // reject completely clipped out glyphs
                if ((prclClip->right  <= ptlOrigin.x) || 
                  (prclClip->bottom <= ptlOrigin.y) ||
                  (prclClip->left   >= ptlOrigin.x + cxGlyph) || 
                  (prclClip->top    >= ptlOrigin.y + cyGlyph))
                {
                    DBG_GDI((7, "bClippedAAText: glyph clipped at (%d,%d):(%d,%d)",
                            ptlOrigin.x, ptlOrigin.y,
                            ptlOrigin.x + cxGlyph, ptlOrigin.y + cyGlyph));
                    goto ContinueGlyphs;
                }
                
                pjGlyph = pgb->aj;
                cyGlyph = pgb->sizlBitmap.cy;
                x = ptlOrigin.x;
                
                unused = 32;
                bitWord = 0;
                
                DBG_GDI((7, "bClippedAAText: glyph clipped at (%d,%d):(%d,%d)",
                          x, ptlOrigin.y, x + cxGlyph, ptlOrigin.y + cyGlyph));
                
                InputBufferReserve(ppdev, 12, &pBuffer);
                
                pBuffer[0] = __Permedia2TagStartXDom;
                pBuffer[1] =  INTtoFIXED(x);
                
                pBuffer[2] = __Permedia2TagStartXSub;
                pBuffer[3] = INTtoFIXED(x + cxGlyph);
                pBuffer[4] = __Permedia2TagStartY;
                pBuffer[5] = INTtoFIXED(ptlOrigin.y);
                pBuffer[6] = __Permedia2TagdY;
                pBuffer[7] =  1 << 16;
                pBuffer[8] = __Permedia2TagCount;
                pBuffer[9] = cyGlyph;
                pBuffer[10] = __Permedia2TagRender;
                pBuffer[11] = renderBits;
                
                pBuffer += 12;
                
                InputBufferCommit(ppdev, pBuffer);
                
                DBG_GDI((7, "bClippedAAText: downloading %d pel wide glyph",
                         cxGlyph));
                
                while(cyGlyph--)
                
                {
                
                    InputBufferReserve(ppdev, cxGlyph + 1, &pBuffer);
                    
                    *pBuffer++ = ((cxGlyph - 1) << 16) | __Permedia2TagTexel0;
                    
                    x = 0;
                    
                    while (x++ < cxGlyph)
                    {
                        ULONG   pixels = *pjGlyph++;
                        ULONG   alpha = pixels & 0xf0;
                        
                        alpha |= alpha >> 4;
                        
                        ULONG   pixel;

                        pixel = (alpha << 24) | 0xffffff;

                        *pBuffer++ = pixel;
                        
                        if(x++ < cxGlyph)
                        {
                            alpha = pixels & 0xf;
                            alpha |= alpha << 4;
                            
                            pixel = (alpha << 24) | 0xffffff;
                            
                            *pBuffer++ = pixel;
                            
                        }
                        
                    }
                    
                    InputBufferCommit(ppdev, pBuffer);
                    
                }
                
                DBG_GDI((7, "bClippedAAText: download completed"));
                
            ContinueGlyphs:
    
                if (--cGlyph == 0)
                    break;
                
                DBG_GDI((7, "bClippedAAText: %d still to render", cGlyph));
                
                // Get ready for next glyph:
                pgp++;
                pgb = pgp->pgdf->pgb;
                
                if (ulCharInc == 0)
                {
                    ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                    ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
                }
                else
                {
                    ptlOrigin.x += ulCharInc;
                }
            
            }
        }
        
    } while (bMore);

    // reset the scissor. default is the whole of VRAM.

    DBG_GDI((20, "bClippedAAText: resetting scissor clip"));
    
    InputBufferReserve(ppdev, 10, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = SCREEN_SCISSOR_DEFAULT;
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = __PERMEDIA_DISABLE;
    pBuffer[4] = __Permedia2TagAlphaBlendMode;
    pBuffer[5] = __PERMEDIA_DISABLE;
    pBuffer[6] = __Permedia2TagTextureColorMode;
    pBuffer[7] = __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagColorDDAMode;
    pBuffer[9] = __PERMEDIA_DISABLE;

    pBuffer += 10;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "bClippedText: exited"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\sync.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: sync.c
*
* Surface synchronization support.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"

//-----------------------------Public*Routine----------------------------------
//
// VOID DrvSynchronizeSurface(pso, prcl, fl)
//
// DrvSynchronizeSurface allows drawing operations performed on the specified
// surface by a device's coprocessor to be coordinated with GDI.
//
// Parameters
//  pso---------Points to a SURFOBJ that identifies the surface on which the
//              drawing synchronization is to occur. 
//  prcl--------Specifies a rectangle on the surface that GDI will draw into, or
//              NULL. If this does not collide with the drawing operation in
//              progress, the driver can elect to let GDI draw without waiting
//              for the coprocessor to complete. 
//  fl----------Flag 
//
// Comments
//  DrvSynchronize can be optionally implemented in graphics drivers. It is
//  intended to support devices that use a coprocessor for drawing. Such a
//  device can start a long drawing operation and return to GDI while the
//  operation continues. If the device driver does not perform all drawing
//  operations to the surface, it is possible that a subsequent drawing
//  operation will be handled by GDI. In this case, it is necessary for GDI
//  to wait for the coprocessor to complete its work before drawing on the
//  surface. DrvSynchronize is not an output function.
//
//  This function is only called if it is hooked by EngAssociateSurface.
//  GDI will call DrvSynchronizeSurface()
//   1. before rendering to any device managed surface
//   2. when at timer event occurs and GCAPS2_SYNCTIMER was specified passing
//      the desktop surface and specifying DSS_TIMER_EVENT
//   3. when a flush evern occurs and GCAPS2_SYNCFLUSH was specified passing
//      the desktip surface and specifying DSS_FLUSH_EVENT
//
//  The function should return when it is safe for GDI to draw on the surface.
//
//  Per surface synchronization enables hardware which uses a graphics
//  acceleration queue model to flush the acceleration queue only to the extent
//  that is neccessary.  That is, it only has to flush up to the last
//  queue entry that references the given surface.
//
//  GDI will call DrvSynchronizeSurface instead of DrvSynchronize in drivers
//  that implement both of these functions. DrvSynchronize is called (and
//  shouuld be provided) only if DrvSyncrhoizeSurface is not provided.
//
//-----------------------------------------------------------------------------
VOID
DrvSynchronizeSurface(SURFOBJ*  pso,
                      RECTL*    prcl,
                      FLONG     fl)
{
    Surf  *psurf;
    PDev   *ppdev = (PDev *) pso->dhpdev;
    
    ASSERTDD(pso->dhsurf != NULL,
                "DrvSynchronizeSurface: called with GDI managed surface");

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvSynchronizeSurface: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;

#endif
//@@END_DDKSPLIT
    
    psurf = (Surf *) pso->dhsurf;

    if ( fl & (DSS_FLUSH_EVENT | DSS_TIMER_EVENT) )
    {
        if(ppdev->bGdiContext && ppdev->bNeedSync)
        {
            if(ppdev->bForceSwap)
            {
                ppdev->bForceSwap = FALSE;
                InputBufferSwap(ppdev);
            }
            else
                InputBufferFlush(ppdev);
        }
        goto done;
    }
    else if ( psurf->flags & SF_VM )
    {
        // If we only had a hardware acceleration queue with per surface
        // reference counting perhaps we could sync to this passed in surface

        // for now just fall through to below
    }

    // we don't have per surface synchronization ... always sync the entire
    // dma buffer

    if(ppdev->bGdiContext)
    {
        InputBufferSync(ppdev);
    }
    else
    {
//@@BEGIN_DDKSPLIT
#if MULTITHREADED && DBG
        ppdev->pP2dma->ppdev = ppdev;
#endif
//@@END_DDKSPLIT
        vSyncWithPermedia(ppdev->pP2dma);
    }

done:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\thunks.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: thunks.c
*
* This module contains the routines for dynamically loading the newly 
* added GDI exported APIs in the NT5.0 environment. By dynamic loading
* we enable the usage of the same binary on NT4.0.
*
* All the functions in this module should only be called on NT5.0. If called
* on NT4.0 in debug builds they will bugcheck.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\*****************************************************************************/

#include "precomp.h"
#include "gdi.h"
#include "directx.h"
#include "log.h"
#include "heap.h"

typedef BOOL
(*_EngAlphaBlend)(IN SURFOBJ *psoDest,
                  IN SURFOBJ *psoSrc,
                  IN CLIPOBJ *pco,
                  IN XLATEOBJ *pxlo,
                  IN RECTL *prclDest,
                  IN RECTL *prclSrc,
                  IN BLENDOBJ *pBlendObj);

typedef BOOL
(*_EngGradientFill)(IN SURFOBJ *psoDest,
                    IN CLIPOBJ *pco,
                    IN XLATEOBJ *pxlo,
                    IN TRIVERTEX *pVertex,
                    IN ULONG nVertex,
                    IN PVOID pMesh,
                    IN ULONG nMesh,
                    IN RECTL *prclExtents,
                    IN POINTL *pptlDitherOrg,
                    IN ULONG ulMode);

typedef BOOL
(*_EngTransparentBlt)(IN SURFOBJ *psoDst,
                      IN SURFOBJ *psoSrc,
                      IN CLIPOBJ *pco,
                      IN XLATEOBJ *pxlo,
                      IN RECTL *prclDst,
                      IN RECTL *prclSrc,
                      IN ULONG iTransparentColor,
                      IN ULONG ulReserved);

typedef PVOID
(*_EngMapFile)(IN LPWSTR pwsz,
               IN ULONG cjSize,
               IN ULONG_PTR *piFile);

typedef BOOL
(*_EngUnmapFile)(IN ULONG_PTR iFile);

typedef BOOL
(*_EngQuerySystemAttribute)(ENG_SYSTEM_ATTRIBUTE CapNum,
                            PDWORD pCapability);

typedef ULONG
(*_EngDitherColor)(HDEV hDev,
                   ULONG iMode,
                   ULONG rgb,
                   ULONG *pul);

typedef BOOL
(*_EngModifySurface)(HSURF hsurf,
                     HDEV hdev,
                     FLONG flHooks,
                     FLONG flSurface,
                     DHSURF dhSurf,
                     VOID* pvScan0,
                     LONG lDelta,
                     VOID* pvReserved);

typedef BOOL
(*_EngQueryDeviceAttribute)(HDEV hdev,
                            ENG_DEVICE_ATTRIBUTE devAttr,
                            VOID *pvIn,
                            ULONG ulInSize,
                            VOID *pvOut,
                            ULONG ulOutSize);

typedef FLATPTR
(*_HeapVidMemAllocAligned)(LPVIDMEM lpVidMem,
                           DWORD dwWidth,
                           DWORD dwHeight,
                           LPSURFACEALIGNMENT lpAlignment,
                           LPLONG lpNewPitch);

typedef void
(*_VidMemFree)(LPVMEMHEAP pvmh, FLATPTR ptr);

typedef ULONG
(*_EngHangNotification)(HDEV hdev,
                        PVOID Reserved);

static _EngAlphaBlend               pfnEngAlphaBlend = 0;
static _EngGradientFill             pfnEngGradientFill = 0;
static _EngTransparentBlt           pfnEngTransparentBlt = 0;
static _EngMapFile                  pfnEngMapFile = 0;
static _EngUnmapFile                pfnEngUnmapFile = 0;
static _EngQuerySystemAttribute     pfnEngQuerySystemAttribute = 0;
static _EngDitherColor              pfnEngDitherColor = 0;
static _EngModifySurface            pfnEngModifySurface = 0;
static _EngQueryDeviceAttribute     pfnEngQueryDeviceAttribute = 0;
static _HeapVidMemAllocAligned      pfnHeapVidMemAllocAligned = 0;
static _VidMemFree                  pfnVidMemFree = 0;
static _EngHangNotification         pfnEngHangNotification = 0;

#define LOADTHUNKFUNC(x)\
    pfn##x = (_##x)EngFindImageProcAddress(0,#x);\
    ASSERTDD(pfn##x != 0, #x"thunk NULL");\
    if(pfn##x == 0)\
        return FALSE;

//-----------------------------------------------------------------------------
//
// void bEnableThunks
//
//-----------------------------------------------------------------------------
BOOL
bEnableThunks()
{
    ASSERTDD(g_bOnNT40 == FALSE, "bEnableThunks: called on NT4.0");

    LOADTHUNKFUNC(EngAlphaBlend);
    LOADTHUNKFUNC(EngGradientFill);
    LOADTHUNKFUNC(EngTransparentBlt);
    LOADTHUNKFUNC(EngMapFile);
    LOADTHUNKFUNC(EngUnmapFile);
    LOADTHUNKFUNC(EngQuerySystemAttribute);
    LOADTHUNKFUNC(EngDitherColor);
    LOADTHUNKFUNC(EngModifySurface);
    LOADTHUNKFUNC(EngQueryDeviceAttribute);
    LOADTHUNKFUNC(HeapVidMemAllocAligned);
    LOADTHUNKFUNC(VidMemFree);
    
    pfnEngHangNotification = 
        (_EngHangNotification)EngFindImageProcAddress(0,"EngHangNotification");

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngAlphaBlend
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngAlphaBlend(IN SURFOBJ *psoDest,
                    IN SURFOBJ *psoSrc,
                    IN CLIPOBJ *pco,
                    IN XLATEOBJ *pxlo,
                    IN RECTL *prclDest,
                    IN RECTL *prclSrc,
                    IN BLENDOBJ *pBlendObj)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngAlphaBlend called on NT4.0");

    return (*pfnEngAlphaBlend)(psoDest,
                               psoSrc,
                               pco,
                               pxlo,
                               prclDest,
                               prclSrc,
                               pBlendObj);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngGradientFill
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngGradientFill(IN SURFOBJ *psoDest,
                      IN CLIPOBJ *pco,
                      IN XLATEOBJ *pxlo,
                      IN TRIVERTEX *pVertex,
                      IN ULONG nVertex,
                      IN PVOID pMesh,
                      IN ULONG nMesh,
                      IN RECTL *prclExtents,
                      IN POINTL *pptlDitherOrg,
                      IN ULONG ulMode)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngGradientFill called on NT4.0");

    return (*pfnEngGradientFill)(psoDest,
                                 pco,
                                 pxlo,
                                 pVertex,
                                 nVertex,
                                 pMesh,
                                 nMesh,
                                 prclExtents,
                                 pptlDitherOrg,
                                 ulMode);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngTransparentBlt
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngTransparentBlt(IN SURFOBJ *psoDst,
                        IN SURFOBJ *psoSrc,
                        IN CLIPOBJ *pco,
                        IN XLATEOBJ *pxlo,
                        IN RECTL *prclDst,
                        IN RECTL *prclSrc,
                        IN ULONG iTransparentColor,
                        IN ULONG ulReserved)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngTransparentBlt called on NT4.0");

    return (*pfnEngTransparentBlt)(psoDst,
                                   psoSrc,
                                   pco,
                                   pxlo,
                                   prclDst,
                                   prclSrc,
                                   iTransparentColor,
                                   ulReserved);
}

//-----------------------------------------------------------------------------
//
// PVOID THUNK_EngMapFile
//
//-----------------------------------------------------------------------------
PVOID
THUNK_EngMapFile(IN LPWSTR pwsz,
                 IN ULONG cjSize,
                 IN ULONG_PTR *piFile)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngMapFile called on NT4.0");
    return (*pfnEngMapFile)(pwsz,cjSize,piFile);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngUnmapFile
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngUnmapFile(IN ULONG_PTR iFile)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngUnmapFile called on NT4.0");
    return (*pfnEngUnmapFile)(iFile);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngQuerySystemAttribute
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngQuerySystemAttribute(ENG_SYSTEM_ATTRIBUTE CapNum,
                              PDWORD pCapability)
{
    ASSERTDD(g_bOnNT40 == 0, "EngQuerySystemAttribute called on NT4.0");
    return (*pfnEngQuerySystemAttribute)(CapNum,pCapability);
}

//-----------------------------------------------------------------------------
//
// ULONG THUNK_EngDitherColor
//
//-----------------------------------------------------------------------------
ULONG
THUNK_EngDitherColor(HDEV hDev,
                     ULONG iMode,
                     ULONG rgb,
                     ULONG *pul)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngDitherColor called on NT4.0");
    return (*pfnEngDitherColor)(hDev,
                                iMode,
                                rgb,
                                pul);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngModifySurface
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngModifySurface(HSURF hsurf,
                       HDEV hdev,
                       FLONG flHooks,
                       FLONG flSurface,
                       DHSURF dhSurf,
                       VOID* pvScan0,
                       LONG lDelta,
                       VOID* pvReserved)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngModifySurface called on NT4.0");
    return (*pfnEngModifySurface)(hsurf,
                                  hdev,
                                  flHooks,
                                  flSurface,
                                  dhSurf,
                                  pvScan0,
                                  lDelta,
                                  pvReserved);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngQueryDeviceAttribute
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngQueryDeviceAttribute(HDEV hdev,
                              ENG_DEVICE_ATTRIBUTE devAttr,
                              VOID *pvIn,
                              ULONG ulInSize,
                              VOID *pvOut,
                              ULONG ulOutSize)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngQueryDeviceAttribute called on NT4.0");
    return (*pfnEngQueryDeviceAttribute)(hdev,
                                         devAttr,
                                         pvIn,
                                         ulInSize,
                                         pvOut,
                                         ulOutSize);
}

//-----------------------------------------------------------------------------
//
// FLATPTR THUNK_HeapVidMemAllocAligned 
//
//-----------------------------------------------------------------------------
FLATPTR
THUNK_HeapVidMemAllocAligned(LPVIDMEM lpVidMem,
                             DWORD dwWidth,
                             DWORD dwHeight,
                             LPSURFACEALIGNMENT lpAlignment,
                             LPLONG lpNewPitch)
{
    ASSERTDD(g_bOnNT40 == FALSE, "HeapVidMemAllocAligned called on NT4.0");
    return (*pfnHeapVidMemAllocAligned)(lpVidMem,
                                        dwWidth,
                                        dwHeight,
                                        lpAlignment,
                                        lpNewPitch);
}

//-----------------------------------------------------------------------------
//
// void THUNK_VidMemFree
//
//-----------------------------------------------------------------------------
void
THUNK_VidMemFree(LPVMEMHEAP pvmh,
                 FLATPTR ptr)
{
    ASSERTDD(g_bOnNT40 == FALSE, "VidMemFree called on NT4.0");
    (*pfnVidMemFree)(pvmh,ptr);
}

//-----------------------------------------------------------------------------
//
// ULONG THUNK_EngHangNotifiation
//
//-----------------------------------------------------------------------------
ULONG
THUNK_EngHangNotification(HDEV hdev,
                          PVOID Reserved)
{
    return (pfnEngHangNotification != NULL) ?
            (*pfnEngHangNotification)(hdev,
                                     Reserved) :
            EHN_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\i386\fasttext.asm ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\tvp4020.h ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: tvp4020.h
 *
 * This module contains the hardware pointer support for the display driver.
 * We also have support for color space double buffering using the RAMDAC pixel
 * read mask.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *
\*****************************************************************************/
#define ADbgpf

//
// TI TVP4020 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _tvp4020_regs
{
    //
    // register addresses
    //
    RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address,
                                // Index Register
    RAMDAC_REG  palData;        // 0x01 - palette RAM data
    RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    RAMDAC_REG  pciAddrRd;      // 0x03 - palette/cursor RAM read address

    RAMDAC_REG  curColAddr;     // 0x04 - cursor color address
    RAMDAC_REG  curColData;     // 0x05 - cursor color data
    RAMDAC_REG  Reserved1;      // 0x06 - reserved
    RAMDAC_REG  Reserved2;      // 0x07 - reserved

    RAMDAC_REG  Reserved3;      // 0x08 - reserved
    RAMDAC_REG  Reserved4;      // 0x09 - reserved
    RAMDAC_REG  indexData;      // 0x0A - indexed data
    RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data

    RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP4020RAMDAC, *pTVP4020RAMDAC;

//
// structure containing the mapped addresses for each of the TVP4020 registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _tvp4020_data
{
    //
    // Register addresses
    //
    UINT_PTR    pciAddrRd;      // loads internal register for palette reads
    UINT_PTR    palData;        // read/write to get/set palette data
    UINT_PTR    pixelMask;      // mask to AND with input pixel data
    UINT_PTR    pciAddrWr;      // Palettte/Index/Cursor Write address register
    UINT_PTR    curRAMData;     // read/write to get/set cursor shape data

    UINT_PTR    indexData;      // read/write to get/set control/cursor data

    UINT_PTR    curAddrRd;      // loads internal register for cursor reads
    UINT_PTR    curAddrWr;      // loads internal register for cursor writes
    UINT_PTR    curData;        // read/write to get/set cursor color data
    UINT_PTR    curColAddr;     // cursor color address
    UINT_PTR    curColData;     // cursor color data

    UINT_PTR    cursorXLow;     // Cursor's X position low byte 
    UINT_PTR    cursorXHigh;    // Cursor's X position high byte 
    UINT_PTR    cursorYLow;     // Cursor's Y position low byte 
    UINT_PTR    cursorYHigh;    // Cursor's Y position high byte 

    // RAMDAC state info
    ULONG       cursorControlOff;
                                // cursor disabled
    ULONG       cursorControlCurrent;
                                // disabled 32/64 mode cursor 
} TVP4020Data, *pTVP4020Data;

//
// Macro declared by any function wishing to use the P2 internal RAMDAC . MUST
// be declared after PERMEDIA_DECL.
//
#define TVP4020_DECL_VARS pTVP4020Data pTVP4020info
#define TVP4020_DECL_INIT pTVP4020info = (pTVP4020Data)ppdev->pvPointerData

#define TVP4020_DECL \
            TVP4020_DECL_VARS; \
            TVP4020_DECL_INIT

//
// Use the following macros as the address to pass to the WRITE_4020REG_ULONG
// function
//
//  Palette Access
//
#define __TVP4020_PAL_WR_ADDR               (pTVP4020info->pciAddrWr)
#define __TVP4020_PAL_RD_ADDR               (pTVP4020info->pciAddrRd)
#define __TVP4020_PAL_DATA                  (pTVP4020info->palData)

//
// Pixel mask
//
#define __TVP4020_PIXEL_MASK                (pTVP4020info->pixelMask)

//
// Access to the indexed registers
//
#define __TVP4020_INDEX_ADDR                (pTVP4020info->pciAddrWr)
#define __TVP4020_INDEX_DATA                (pTVP4020info->indexData)

//
// Access to the Cursor
//
#define __TVP4020_CUR_RAM_WR_ADDR           (pTVP4020info->pciAddrWr)
#define __TVP4020_CUR_RAM_RD_ADDR           (pTVP4020info->pciAddrRd)
#define __TVP4020_CUR_RAM_DATA              (pTVP4020info->curRAMData)

#define __TVP4020_CUR_COL_ADDR              (pTVP4020info->curColAddr)
#define __TVP4020_CUR_COL_DATA              (pTVP4020info->curColData)

//
// Cursor position control
//
#define __TVP4020_CUR_X_LSB                 (pTVP4020info->cursorXLow)
#define __TVP4020_CUR_X_MSB                 (pTVP4020info->cursorXHigh)
#define __TVP4020_CUR_Y_LSB                 (pTVP4020info->cursorYLow)
#define __TVP4020_CUR_Y_MSB                 (pTVP4020info->cursorYHigh)

//
//----------------------Values for some direct registers---------------------
//

/*****************************************************************************/
/*              DIRECT REGISTER - CURSOR POSITION CONTROL                    */
/*****************************************************************************/
//  ** TVP4020_CUR_X_LSB 
//  ** TVP4020_CUR_X_MSB 
//  ** TVP4020_CUR_Y_LSB 
//  ** TVP4020_CUR_Y_MSB 
//      Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
//
#define TVP4020_CURSOR_OFFSCREEN            0x00    // Cursor offscreen

/*****************************************************************************/
/*              DIRECT REGISTER - CURSOR COLORS                              */
/*****************************************************************************/

#define TVP4020_CURSOR_COLOR0               0x01
#define TVP4020_CURSOR_COLOR1               0x02
#define TVP4020_CURSOR_COLOR2               0x03

/*****************************************************************************/
/*              INDIRECT REGISTER - CURSOR CONTROL                           */
/*****************************************************************************/
#define __TVP4020_CURSOR_CONTROL            0x06    // Indirect cursor control - 
//      Default - 0x00

#define TVP4020_CURSOR_SIZE_32              (0 << 6)// 32x32 cursor
#define TVP4020_CURSOR_SIZE_MASK            (1 << 6)// Mask

#define TVP4020_CURSOR_32_SEL(i)            ((i) << 4)// one of 4 32x32 cursors
                                                      // changed to << 4
#define TVP4020_CURSOR_32_MASK              (0x03 << 4) // Mask

#define TVP4020_CURSOR_RAM_ADDRESS(x)       (((x) & 0x03) << 2)
                                                    // High bits of cursor RAM
                                                    // address
#define TVP4020_CURSOR_RAM_MASK             ((0x03) << 2)
                                                    // Mask for high bits of
                                                    // cursor RAM address

// Added constants for cursor mode
#define TVP4020_CURSOR_OFF                  0x00    // Cursor off
#define TVP4020_CURSOR_COLOR                0x01    // 2-bits select color
#define TVP4020_CURSOR_XGA                  0x02    // 2-bits select XOR
#define TVP4020_CURSOR_XWIN                 0x03    // 2-bits select transparency/color
#define TVP4020_CURSOR_MASK                 0x03    // Mask

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR MODE REGISTER                      */
/*****************************************************************************/
#define __TVP4020_COLOR_MODE                0x18    //  Color Mode Register
//      Default - 0x00

#define TVP4020_TRUE_COLOR_ENABLE           (1 << 7)// True Color data accesses LUT
#define TVP4020_TRUE_COLOR_DISABLE          (0 << 7)// Non true color accesses LUT

#define TVP4020_RGB_MODE                    (1 << 5)// RGB mode Swapped 0/1 (0=BGR, 1=RGB)
#define TVP4020_BGR_MODE                    (0 << 5)// BGR mode

#define TVP4020_VGA_SELECT                  (0 << 4)// select VGA mode
#define TVP4020_GRAPHICS_SELECT             (1 << 4)// select graphics modes

#define TVP4020_PIXEL_MODE_CI8              (0 << 0)// pseudo color or VGA mode
#define TVP4020_PIXEL_MODE_332              (1 << 0)// 332 true color
#define TVP4020_PIXEL_MODE_2320             (2 << 0)// 232 off
#define TVP4020_PIXEL_MODE_2321             (3 << 0)//
#define TVP4020_PIXEL_MODE_5551             (4 << 0)// 
#define TVP4020_PIXEL_MODE_4444             (5 << 0)// 
#define TVP4020_PIXEL_MODE_565              (6 << 0)// 
#define TVP4020_PIXEL_MODE_8888             (8 << 0)// 
#define TVP4020_PIXEL_MODE_PACKED           (9 << 0)// 24 bit packed

/********************************************************************************/
/*              INDIRECT REGISTER - MODE CONTROL REGISTER                       */
/********************************************************************************/
#define __TVP4020_MODE_CONTROL              0x19    //  Mode control
//      Default - 0x00

#define TVP4020_PRIMARY_INPUT               (0 << 4)// Primary input throuh palette
#define TVP4020_SECONDARY_INPUT             (1 << 4)// Secondary input throuh palette

#define TVP4020_5551_DBL_BUFFER             (1 << 2)// Enable 5551 dbl buffer
#define TVP4020_5551_PACKED                 (0 << 2)// Packed 555 mode

#define TVP4020_ENABLE_STATIC_DBL_BUFFER    (1 << 1)// Static dbl buffer enabled
#define TVP4020_DISABLE_STATIC_DBL_BUFFER   (1 << 1)// Static dbl buffer disabled

#define TVP4020_SELECT_FRONT_MODE           (0 << 0)// Front mode
#define TVP4020_SELECT_BACK_MODE            (1 << 0)// Back mode

/*****************************************************************************/
/*              INDIRECT REGISTER - PALETTE PAGE                             */
/*****************************************************************************/
#define __TVP4020_PALETTE_PAGE              0x1C    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - MISC CONTROL                             */
/*****************************************************************************/
#define __TVP4020_MISC_CONTROL              0x1E    //  
//      Default - 0x00
#define TVP4020_SYNC_ENABLE                 (1 << 5)// Output SYNC info onto IOG
#define TVP4020_SYNC_DISABLE                (0 << 5)// No SYNC IOG output

#define TVP4020_PEDESTAL_0                  (0 << 4)// 0 IRE blanking pedestal
#define TVP4020_PEDESTAL_75                 (1 << 4)// 7.5 IRE blanking pedestal

#define TVP4020_VSYNC_INVERT                (1 << 3)// invert VSYNC output polarity
#define TVP4020_VSYNC_NORMAL                (0 << 3)// normal VSYNC output polarity

#define TVP4020_HSYNC_INVERT                (1 << 2)// invert HSYNC output polarity
#define TVP4020_HSYNC_NORMAL                (0 << 3)// normal HSYNC output polarity

#define TVP4020_DAC_8BIT                    (1 << 1)// DAC is in 8-bit mode
#define TVP4020_DAC_6BIT                    (0 << 1)// DAC is in 6-bit mode

#define TVP4020_DAC_POWER_ON                (0 << 0)// Turn DAC Power on 
#define TVP4020_DAC_POWER_OFF               (1 << 0)// Turn DAC Power off 

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY CONTROL                        */
/*****************************************************************************/
#define __TVP4020_CK_CONTROL                0x40    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY                        */
/*****************************************************************************/
#define __TVP4020_CK_OVR_REG                0x41    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED                            */
/*****************************************************************************/
#define __TVP4020_CK_RED_REG                0x42    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY GREEN                          */
/*****************************************************************************/
#define __TVP4020_CK_GREEN_REG              0x43    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE                           */
/*****************************************************************************/
#define __TVP4020_CK_BLUE_REG               0x44    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - PIXEL CLOCK PLL                          */
/*****************************************************************************/

#define __TVP4020_PIXCLK_REG_A1             0x20
#define __TVP4020_PIXCLK_REG_A2             0x21
#define __TVP4020_PIXCLK_REG_A3             0x22
#define __TVP4020_PIXCLK_REG_B1             0x23
#define __TVP4020_PIXCLK_REG_B2             0x24
#define __TVP4020_PIXCLK_REG_B3             0x25
#define __TVP4020_PIXCLK_REG_C1             0x26
#define __TVP4020_PIXCLK_REG_C2             0x27
#define __TVP4020_PIXCLK_REG_C3             0x28

#define __TVP4020_PIXCLK_STATUS             0x29

/*****************************************************************************/
/*              INDIRECT REGISTER - MEMORU CLOCK PLL                         */
/*****************************************************************************/

#define __TVP4020_MEMCLK_REG_1              0x30
#define __TVP4020_MEMCLK_REG_2              0x31
#define __TVP4020_MEMCLK_REG_3              0x32

#define __TVP4020_MEMCLK_STATUS             0x33

//
// generic read/write routines for 3026 registers
//
#define WRITE_4020REG_ULONG(r, d) \
{ \
    WRITE_REGISTER_ULONG((PULONG)(r), (d)); \
    MEMORY_BARRIER(); \
}

#define READ_4020REG_ULONG(r)    READ_REGISTER_ULONG((PULONG)(r))

// macro to load a given data value into an internal TVP4020 register.
//
#define TVP4020_SET_INDEX_REG(index) \
{ \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_ADDR, (index) & 0xff)); \
    WRITE_4020REG_ULONG(__TVP4020_INDEX_ADDR, (ULONG)((index) & 0xff)); \
}

#define TVP4020_WRITE_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index);                            \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_DATA, (data) & 0xff)); \
    WRITE_4020REG_ULONG(__TVP4020_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

#define TVP4020_READ_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index); \
    data = READ_4020REG_ULONG(__TVP4020_INDEX_DATA) & 0xff;   \
    ADbgpf(("0x%X <-- *(0x%X)\n", data, __TVP4020_INDEX_DATA)); \
}

//
// For compatibility with TVP3026
//
//#define TVP4020_LOAD_CURSOR_CTRL(data) \
//{ \
//    volatile LONG   __temp;                                    \
//    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
//    __temp &= ~(0x03) ;                                        \
//    __temp |= ((data) & 0x03) ;                                \
//    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp); \
//}

//
// Macros to write a given RGB triplet into cursors 0, 1 and 2
//
#define TVP4020_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR0));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
}

#define TVP4020_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR1));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
}

#define TVP4020_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR2));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
}

//
// Macros to load a given RGB triple into the TVP4020 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP4020_PALETTE_START and multiple TVP4020_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP4020_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define TVP4020_PALETTE_START_WR(index) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_WR_ADDR,     (ULONG)(index));    \
}

#define TVP4020_PALETTE_START_RD(index) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_RD_ADDR,     (ULONG)(index));    \
}

#define TVP4020_LOAD_PALETTE(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
}

#define TVP4020_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_WR_ADDR, (ULONG)(index));    \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
}

//
// Macro to read back a given RGB triple from the TVP4020 palette. Use after
// a call to TVP4020_PALETTE_START_RD
//
#define TVP4020_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_4020_ULONG(__TVP4020_PAL_DATA) & 0xff);        \
    green = (UCHAR)(READ_4020_ULONG(__TVP4020_PAL_DATA) & 0xff);        \
    blue  = (UCHAR)(READ_4020_ULONG(__TVP4020_PAL_DATA) & 0xff);        \
}

//
// Macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define TVP4020_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PIXEL_MASK,  (ULONG)(mask)); \
}

#define TVP4020_READ_PIXEL_READMASK(mask) \
{ \
    mask = READ_4020_ULONG(__TVP4020_PIXEL_MASK) & 0xff; \
}

//
// Macros to load values into the cursor array
//
#define CURSOR_PLANE0_OFFSET 0
#define CURSOR_PLANE1_OFFSET 0x200

#define TVP4020_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP4020_CURSOR_RAM_MASK ;                        \
    __temp |= TVP4020_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
}

//
// Changed to __TVP4020_CUR_RAM_DATA
//
#define TVP4020_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_RAM_DATA, (ULONG)(data)); \
}

//
// Changed to __TVP4020_CUR_RAM_DATA
//
#define TVP4020_READ_CURSOR_ARRAY(data) \
{ \
    data = READ_4020REG_ULONG(__TVP4020_CUR_RAM_DATA) & 0xff; \
}

//
// Macro to move the cursor
//
#define TVP4020_MOVE_CURSOR(x, y) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_X_LSB,    (ULONG)((x) & 0xff));   \
    WRITE_4020REG_ULONG(__TVP4020_CUR_X_MSB,    (ULONG)((x) >> 8));     \
    WRITE_4020REG_ULONG(__TVP4020_CUR_Y_LSB,    (ULONG)((y) & 0xff));   \
    WRITE_4020REG_ULONG(__TVP4020_CUR_Y_MSB,    (ULONG)((y) >> 8));     \
}

//
// Exported functions from pointer.c. Anything which is TVP4020 specific goes
// in this file as well as real pointer stuff.
//
extern BOOL  bTVP4020CheckCSBuffering(PPDev);
extern BOOL  bTVP4020SwapCSBuffers(PPDev, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\i386\hw.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\i386\strucs.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\drvext.cxx ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: drvexts.cxx
 *
 * Contains all the driver debugger extension functions
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "dbgext.hxx"
#include "gdi.h"

#define TMP_BUFSIZE 512

/**********************************Public*Routine******************************\
 *
 * Dump Permedia 2 display driver's Surf obj
 *
 ******************************************************************************/
DECLARE_API(surf)
{
    Surf        tempSurf;
    FLAGDEF*    pfd;
    
    //
    // Check if there is a "-?" in the command. If yes, show the help
    //
    PARSE_POINTER(surf_help);

    move(tempSurf, (Surf*)arg);

    dprintf("----Permedia2 Surf Structure-------------\n");
    dprintf("SurfFlags      flags           0x%x\n", tempSurf.flags);

    //
    // Print the detail info of the Surface info
    //
    for ( pfd = afdSURF; pfd->psz; ++pfd )
    {
        if ( tempSurf.flags & pfd->fl )
        {
            dprintf("\t\t\t%s\n", pfd->psz);
        }
    }
    
    dprintf("PDev*          ppdev           0x%x\n", tempSurf.ppdev);
    dprintf("struct _Surf*  psurfNext       0x%x\n", tempSurf.psurfNext);
    dprintf("struct _Surf*  psurfPrev       0x%x\n", tempSurf.psurfPrev);
    dprintf("ULONG          cBlt            %ld\n", tempSurf.cBlt);
    dprintf("ULONG          iUniq           %ld\n", tempSurf.iUniq);
    dprintf("LONG           cx(Surf Width)  %ld pixels\n", tempSurf.cx);
    dprintf("LONG           cy(Surf Height) %ld pixels\n", tempSurf.cy);

    if ( tempSurf.flags & SF_VM )
    {
        dprintf("ULONG          ulByteOffset    %ld\n", tempSurf.ulByteOffset);
    }
    else
    {
        dprintf("VOID*      pvScan0         0x%x\n", tempSurf.pvScan0);
    }

    dprintf("LONG           lDelta          0x%x\n", tempSurf.lDelta);
    dprintf("VIDEOMEMORY*   pvmHeap         0x%x\n", tempSurf.pvmHeap);
    dprintf("HSURF          hsurf           0x%x\n", tempSurf.hsurf);
    dprintf("ULONG          ulPackedPP      0x%x\n", tempSurf.ulPackedPP);
    dprintf("ULONG          ulPixOffset     0x%x\n", tempSurf.ulPixOffset);
    dprintf("ULONG          ulPixDelta      0x%x\n", tempSurf.ulPixDelta);
    dprintf("ULONG          ulChecksum      0x%x\n", tempSurf.ulChecksum);
    
    return;
    
surf_help:
    dprintf("Usage: surf [-?] SURF_PTR\n");
}// surf

/**********************************Public*Routine******************************\
 *
 * Dump Permedia 2 display driver's PDev obj
 *
 ******************************************************************************/
DECLARE_API(pdev)
{
    PDev        tempPDev;
    char        tempStr[TMP_BUFSIZE];
    FLAGDEF*    pfd;

    BOOL bAll = FALSE;
    BOOL bGeneral = FALSE;
    BOOL bHeap = FALSE;
    BOOL bBase = FALSE;
    BOOL bGDI = FALSE;
    BOOL bPalette = FALSE;
    BOOL bCursor = FALSE;
    BOOL bBrush = FALSE;
    BOOL bDDraw = FALSE;

    //
    // Check if there is a "-?" in the command. If yes, show the help
    //
    PARSE_POINTER(pdev_help);

    move(tempPDev, (PDev*)arg);

    if( iParseiFindSwitch(tokens, ntok, 'a')!= -1 )
    {
        bAll = TRUE;
        goto Start_Dump;
    }

    if( iParseiFindSwitch(tokens, ntok, 'g') != -1 )
    {
        bGeneral = TRUE;
    }

    if( iParseiFindSwitch(tokens, ntok, 'h')!= -1 )
    {
        bHeap = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'b')!= -1 )
    {
        bBase = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'i')!= -1 )
    {
        bGDI = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'p')!= -1 )
    {
        bPalette = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'c')!= -1 )
    {
        bCursor = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'r')!= -1 )
    {
        bBrush = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'd')!= -1 )
    {
        bDDraw = TRUE;
    }

    if( !(bGeneral || bHeap || bBase || bGDI || bPalette ||  bCursor || bBrush
        ||bBrush || bDDraw ) )
    {
        bAll = TRUE;
    }

Start_Dump:

    dprintf("----------------PDev Structure----------------\n");
    
    if ( bAll || bGeneral )
    {
        dprintf("*************General Information**************\n");
        dprintf("BOOL        bEnabled        %ld %s\n",tempPDev.bEnabled,
                tempPDev.bEnabled? "(Graphics Mode)":"(Full Screen Mode)");
        dprintf("DWORD       dwAccelLevel    %ld\n",  tempPDev.dwAccelLevel);
        switch ( tempPDev.dwAccelLevel )
        {
            case 0:
                dprintf("%s\n","\t\t\tAll HW accelerations are enabled");

                break;

            case 1:
                dprintf("%s\n", "\t\t\tDrvMovePointer,");
                dprintf("%s\n", "\t\t\tDrvCreateDeviceBitmap");
                dprintf("%s\n", "are disabled");

                break;

            case 2:
                dprintf("%s\n", "\t\t\tDrvAlphaBlend,");
                dprintf("%s\n", "\t\t\tDrvCreateDeviceBitmap,");
                dprintf("%s\n", "\t\t\tDrvFillPath,");
                dprintf("%s\n", "\t\t\tDrvGradientFill,");
                dprintf("%s\n", "\t\t\tDrvLineTo,");
                dprintf("%s\n", "\t\t\tDrvMovePointer,");
                dprintf("%s\n", "\t\t\tDrvPlgBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBltROP,");
                dprintf("%s\n", "\t\t\tDrvStrokeAndFillPath,");
                dprintf("%s\n", "\t\t\tDrvTransparentBlt");
                dprintf("%s\n", "are disabled");

                break;

            case 3:
                dprintf("%s\n", "\t\t\tDrvAlphaBlend,");
                dprintf("%s\n", "\t\t\tDrvCreateDeviceBitmap,");
                dprintf("%s\n", "\t\t\tDrvFillPath,");
                dprintf("%s\n", "\t\t\tDrvGradientFill,");
                dprintf("%s\n", "\t\t\tDrvLineTo,");
                dprintf("%s\n", "\t\t\tDrvMovePointer,");
                dprintf("%s\n", "\t\t\tDrvPlgBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBltROP,");
                dprintf("%s\n", "\t\t\tDrvStrokeAndFillPath,");
                dprintf("%s\n", "\t\t\tDrvTransparentBlt");
                dprintf("%s\n", "\t\t\tAnd all DDraw and D3D accelerations");
                dprintf("%s\n", "are disabled");

                break;

            case 4:
                dprintf("%s\n", "\t\t\tOnly following HW accelerated functions");
                dprintf(" are enabled");
                dprintf("%s\n", "\t\t\tDrvBitBlt,");
                dprintf("%s\n", "\t\t\tDrvCopyBits,");
                dprintf("%s\n", "\t\t\tDrvStrokePath,");
                dprintf("%s\n", "\t\t\tDrvTextOut");

                break;

            case 5:
                dprintf("%s\n","\t\t\tAll HW accelerations are disabled");

                break;

            default:
                dprintf("%s\n", "\t\t\tUNKNOWN HW accelerations level");
                
                break;
        }

        dprintf("ULONG       iBitmapFormat   %ld\n",  tempPDev.iBitmapFormat);

        switch ( tempPDev.iBitmapFormat )
        {
            case BMF_32BPP:
                strcpy(tempStr, "\t\t\tBMF_32BPP");
                
                break;

            case BMF_16BPP:
                strcpy(tempStr, "\t\t\tBMF_16BPP");
                
                break;

            case BMF_8BPP:
                strcpy(tempStr, "\t\t\tBMF_8BPP");
                
                break;

            default:
                strcpy(tempStr, "\t\t\tUNKNOWN BMP format");
            
                break;
        }
        dprintf("%s\n", tempStr);

        dprintf("LONG        cjPelSize       %ld\n",  tempPDev.cjPelSize);
        switch ( tempPDev.cjPelSize )
        {
            case 4:
                strcpy(tempStr, "\t\t\t32BPP Mode");
                
                break;

            case 2:
                strcpy(tempStr, "\t\t\t16BPP Mode");
                
                break;

            case 1:
                strcpy(tempStr, "\t\t\t8BPP Mode");
                
                break;

            default:
                strcpy(tempStr, "\t\t\tUNKNOWN color depth");
            
                break;
        }
        dprintf("%s\n", tempStr);

        dprintf("LONG        cPelSize        %ld\n",  tempPDev.cPelSize);
        dprintf("LONG        cBitsPerPel     %ld\n",  tempPDev.cBitsPerPel);
        dprintf("DWORD       bPixShift       %ld\n",  tempPDev.bPixShift);
        dprintf("DWORD       bBppShift       %ld\n",  tempPDev.bBppShift);
        dprintf("DWORD       dwBppMask       %ld\n",  tempPDev.dwBppMask);

        dprintf("CAPS        flCaps          0x%x\n",  tempPDev.flCaps);

        //
        // Print the detail info of the CAPS
        //
        for ( pfd = afdCAPS; pfd->psz; ++pfd )
        {
            if ( tempPDev.flCaps & pfd->fl )
            {
                dprintf("\t\t\t%s\n", pfd->psz);
            }
        }

        dprintf("Status      flStatus        0x%x\n",  tempPDev.flStatus);

        //
        // Print the detail info of the STATUS
        //
        for ( pfd = afdSTATUS; pfd->psz; ++pfd )
        {
            if ( tempPDev.flStatus & pfd->fl )
            {
                dprintf("\t\t\t%s\n", pfd->psz);
            }
        }

        dprintf("FLONG       flHooks         0x%x\n", tempPDev.flHooks);

        //
        // Print the detail info of the HOOKS
        //
        for ( pfd = afdHOOK; pfd->psz; ++pfd )
        {
            if ( tempPDev.flHooks & pfd->fl )
            {
                dprintf("\t\t\t%s\n", pfd->psz);
            }
        }

        dprintf("Surf*       pdsurfScreen    0x%x\n", tempPDev.pdsurfScreen);
        dprintf("Surf*       pdsurfOffScreen 0x%x\n", tempPDev.pdsurfOffScreen);
        dprintf("LONG        cxScreen        %-6ld (Screen Width)\n",
                tempPDev.cxScreen);
        dprintf("LONG        cyScreen        %-6ld (Screen Height)\n",
                tempPDev.cyScreen);
        dprintf("ULONG       ulPermFormat    %ld\n",  tempPDev.ulPermFormat);
        dprintf("ULONG       ulPermFormatEx  %ld\n",  tempPDev.ulPermFormatEx);

        dprintf("POINTL      ptlOrigin       (%ld, %ld)\n",
                tempPDev.ptlOrigin.x, tempPDev.ptlOrigin.y);
    }// General Info

    if ( bAll || bHeap )
    {
        dprintf("\n*************Heap Manager Information*********\n");
        dprintf("VIDEOMEMORY* pvmList        0x%x\n", tempPDev.pvmList);
        dprintf("ULONG       cHeaps;         %ld\n",  tempPDev.cHeaps);
        dprintf("LONG        cxMemory        %-6ld (Video RAM Width)\n",
                tempPDev.cxMemory);
        dprintf("LONG        cyMemory        %-6ld (Video RAM Height)\n",
                tempPDev.cyMemory);
        dprintf("LONG        lDelta          %ld\n",  tempPDev.lDelta);
        dprintf("Surf*       psurfListHead   0x%x\n", tempPDev.psurfListHead);
        dprintf("Surf*       psurfListTail   0x%x\n", tempPDev.psurfListTail);
    }// Heap Info

    if ( bAll || bBase )
    {
        dprintf("\n*************Base Information*****************\n");
        dprintf("BYTE*       pjScreen        0x%x\n", tempPDev.pjScreen);
        dprintf("ULONG       ulMode          %ld\n",  tempPDev.ulMode);
        dprintf("ULONG*      pulCtrlBase[2]  0x%x, 0x%x\n",
                tempPDev.pulCtrlBase[0], tempPDev.pulCtrlBase[1]);
        dprintf("ULONG*      pulDenseCtrlBase 0x%x\n",
                tempPDev.pulDenseCtrlBase);
        dprintf("ULONG*      pulRamdacBase   0x%x\n", tempPDev.pulRamdacBase);
        dprintf("VOID*       pvTmpBuffer     0x%x\n", tempPDev.pvTmpBuffer);
        dprintf("LONG        lVidMemHeight   %ld\n",  tempPDev.lVidMemHeight);
        dprintf("LONG        lVidMemWidth    %ld\n",  tempPDev.lVidMemWidth);
        dprintf("UCHAR*      pjIoBase        %ld\n",  tempPDev.pjIoBase);
        dprintf("HwDataPtr   permediaInfo    0x%x\n", tempPDev.permediaInfo);
        dprintf("LONG        FrameBufferLength %ld\n",
                tempPDev.FrameBufferLength);
        dprintf("UINT_PTR    dwScreenStart   %ld\n",  tempPDev.dwScreenStart);
        dprintf("P2DMA*      pP2dma          0x%x\n", tempPDev.pP2dma);
        dprintf("DDPIXELFORMAT   ddpfDisplay %ld\n",  tempPDev.ddpfDisplay);
        dprintf("DWORD       dwChipConfig    %ld\n",  tempPDev.dwChipConfig);
        dprintf("ULONG*      pCtrlBase       0x%x\n", tempPDev.pCtrlBase);
        dprintf("ULONG*      pCoreBase       0x%x\n", tempPDev.pCoreBase);
        dprintf("ULONG*      pGPFifo         0x%x\n", tempPDev.pGPFifo);
        dprintf("PULONG      pulInFifoPtr    0x%x\n", tempPDev.pulInFifoPtr);
        dprintf("PULONG      pulInFifoStart  0x%x\n", tempPDev.pulInFifoStart);
        dprintf("PULONG      pulInFifoEnd    0x%x\n", tempPDev.pulInFifoEnd);
        dprintf("ULONG*      dmaBufferVirtualAddress 0x%x\n",
                tempPDev.dmaBufferVirtualAddress);
        dprintf("LARGE_INTEGER dmaBufferPhysicalAddress 0x%x\n",
                tempPDev.dmaBufferPhysicalAddress);
        dprintf("ULONG       dmaCurrentBufferOffset 0x%x\n",
                tempPDev.dmaCurrentBufferOffset);
        dprintf("ULONG       dmaActiveBufferOffset %ld\n",
                tempPDev.dmaActiveBufferOffset);
        dprintf("ULONG*      pulInputDmaCount 0x%x\n",
                tempPDev.pulInputDmaCount);
        dprintf("ULONG*      pulInputDmaAddress  0x%x\n",
                tempPDev.pulInputDmaAddress);
        dprintf("ULONG*      pulFifo         0x%x\n", tempPDev.pulFifo);
        dprintf("ULONG*      pulOutputFifoCount 0x%x\n",
                tempPDev.pulOutputFifoCount);
        dprintf("ULONG*      pulInputFifoCount 0x%x\n",
                tempPDev.pulInputFifoCount);
        dprintf("BOOL        bGdiContext     %ld\n",  tempPDev.bGdiContext);
        dprintf("BOOL        bNeedSync       %ld\n",  tempPDev.bNeedSync);
        dprintf("BOOL        bForceSwap      %ld\n",  tempPDev.bForceSwap);
        dprintf("SURFOBJ*    psoScreen       0x%x\n", tempPDev.psoScreen);
    }// Base Info

    if ( bAll || bGDI )
    {
        dprintf("\n*************GDI Runtime Information**********\n");
        dprintf("HANDLE      hDriver         0x%x\n", tempPDev.hDriver);
        dprintf("HDEV        hdevEng         0x%x\n", tempPDev.hdevEng);
        dprintf("HSURF       hsurfScreen     0x%x\n", tempPDev.hsurfScreen);
        dprintf("ULONG       iHeapUniq       %ld\n",  tempPDev.iHeapUniq);
    }// GDI Runtime Info

    if ( bAll || bPalette )
    {
        dprintf("\n*************Palette Information**************\n");
        dprintf("ULONG       ulWhite;        0x%x\n", tempPDev.ulWhite);
        dprintf("PALETTEENTRY* pPal          0x%x\n", tempPDev.pPal);
        dprintf("HPALETTE    hpalDefault     0x%x\n",  tempPDev.hpalDefault);
        dprintf("FLONG       flRed           0x%x\n",  tempPDev.flRed);
        dprintf("FLONG       flGreen         0x%x\n",  tempPDev.flGreen);
        dprintf("FLONG       flBlue          0x%x\n",  tempPDev.flBlue);
    }// Palette Info

    if ( bAll || bCursor )
    {
        dprintf("\n*************Cursor Information***************\n");
        dprintf("LONG        xPointerHot     %ld\n", tempPDev.xPointerHot);
        dprintf("LONG        yPointerHot     %ld\n", tempPDev.yPointerHot);
        dprintf("ULONG       ulHwGraphicsCursorModeRegister_45   %ld\n",
                tempPDev.ulHwGraphicsCursorModeRegister_45);
        dprintf("PtrFlags    flPointer       %ld %s\n",  tempPDev.flPointer,
                (tempPDev.flPointer == PTR_HW_ACTIVE)? "(HW Pointer)":"(SW Pointer)");
        dprintf("VOID*       pvPointerData   0x%x\n",  tempPDev.pvPointerData);
        dprintf("BYTE        ajPointerData   0x%x\n", tempPDev.ajPointerData);
        dprintf("BOOL        bPointerInitialized %ld\n",
                tempPDev.bPointerInitialized);
        dprintf("HWPointerCache  HWPtrCache  %ld\n",  tempPDev.HWPtrCache);
        dprintf("LONG        HWPtrLastCursor %ld\n",  tempPDev.HWPtrLastCursor);
        dprintf("LONG        HWPtrPos_X      %ld\n",  tempPDev.HWPtrPos_X);
        dprintf("LONG        HWPtrPos_Y      %ld\n",  tempPDev.HWPtrPos_Y);
    }// Cursor Info

    if ( bAll || bBrush )
    {
        dprintf("\n*************Brush Information****************\n");    
        dprintf("BOOL        bRealizeTransparent %ld\n",
                tempPDev.bRealizeTransparent);
        dprintf("LONG        cPatterns       %ld\n",  tempPDev.cPatterns);
        dprintf("LONG        lNextCachedBrush %ld\n",
                tempPDev.lNextCachedBrush);
        dprintf("LONG        cBrushCache     %ld\n",  tempPDev.cBrushCache);
        dprintf("BrushEntry  abeMono         0x%x, %ld\n",
                tempPDev.abeMono.prbVerify,
                tempPDev.abeMono.ulPixelOffset);
        dprintf("BrushEntry  abe[%d]         0x%x\n", TOTAL_BRUSH_COUNT,
                tempPDev.abe);
        dprintf("HBITMAP     ahbmPat[%d]      0x%x\n",
                HS_DDI_MAX, tempPDev.ahbmPat);
        dprintf("ULONG       ulBrushPackedPP 0x%x\n",
                tempPDev.ulBrushPackedPP);
        dprintf("VIDEOMEMORY* pvmBrushHeap   0x%x\n", tempPDev.pvmBrushHeap);
        dprintf("ULONG       ulBrushVidMem   0x%x\n", tempPDev.ulBrushVidMem);
    }// Brush Info

    if ( bAll || bDDraw )
    {
        dprintf("\n*************DDRAW/D3D Information************\n");

        dprintf("P2CtxtPtr   pDDContext      0x%x\n", tempPDev.pDDContext);
        dprintf("DDHAL_DDCALLBACKS DDHALCallbacks 0x%x\n",
                tempPDev.DDHALCallbacks);
        dprintf("DDHAL_DDSURFACECALLBACKS    DDSurfCallbacks 0x%x\n",
                tempPDev.DDSurfCallbacks);
        dprintf("DWORD       dwNewDDSurfaceOffset %ld\n",
                tempPDev.dwNewDDSurfaceOffset);
        dprintf("BOOL        bDdExclusiveMode %ld\n",
                tempPDev.bDdExclusiveMode);
        dprintf("BOOL        bDdStereoMode   %ld\n",  tempPDev.bDdStereoMode);
        dprintf("BOOL        bCanDoStereo    %ld\n",  tempPDev.bCanDoStereo);
        dprintf("UINT_PTR    pD3DDriverData32 0x%x\n",
                tempPDev.pD3DDriverData32);
        dprintf("UINT_PTR    pD3DHALCallbacks32 0x%x\n",
                tempPDev.pD3DHALCallbacks32);
        dprintf("UINT_PTR    dwGARTLin       %ld\n",  tempPDev.dwGARTLin);
        dprintf("UINT_PTR    dwGARTDev       %ld\n",  tempPDev.dwGARTDev);
        dprintf("UINT_PTR    dwGARTLinBase   %ld\n",  tempPDev.dwGARTLinBase);
        dprintf("UINT_PTR    dwGARTDevBase   %ld\n",  tempPDev.dwGARTDevBase);
        dprintf("DDHALINFO   ddhi32          0x%x\n", tempPDev.ddhi32);
        dprintf("PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand 0x%x\n",
                tempPDev.pD3DParseUnknownCommand);
    }// DDRAW/D3D Info

    return;
    
pdev_help:
    dprintf("Usage: pdev [-?] [-a] [-g] [-h] [-b] [-i] [-p] [-c] [-r]");
    dprintf(" [-d] PDEV_PTR\n");
    dprintf("-a     dump the whole PDev info\n");
    dprintf("-g     dump General info from the PDev\n");
    dprintf("-h     dump Heap Manager info from the PDev\n");
    dprintf("-b     dump Base info from the PDev\n");
    dprintf("-i     dump GDI Runtime info from the PDev\n");
    dprintf("-p     dump Palette info from the PDev\n");
    dprintf("-c     dump Cursor info from the PDev\n");
    dprintf("-r     dump Brush info from the PDev\n");
    dprintf("-d     dump DDRAW/D3D info from the PDev\n");
    
    return;
}// pdev

/**********************************Public*Routine******************************\
 *
 * Dump Permedia 2 display driver's function block
 *
 ******************************************************************************/
DECLARE_API(fb)
{
    GFNPB       tempFB;
    FLAGDEF*    pfd;
    
    //
    // Check if there is a "-?" in the command. If yes, show the help
    //
    PARSE_POINTER(fb_help);

    move(tempFB, (GFNPB*)arg);

    dprintf("----Permedia2 GFNPB Structure-------------\n");
    dprintf("VOID (*pgfn)(struct _GFNPB*)   0x%x\n", tempFB.pgfn);
    dprintf("PDev*          ppdev           0x%x\n", tempFB.ppdev);
    dprintf("Surf*          psurfDst        0x%x\n", tempFB.psurfDst);
    dprintf("RECTL*         prclDst         0x%x\n", tempFB.prclDst);
    dprintf("Surf*          psurfSrc        0x%x\n", tempFB.psurfSrc);
    dprintf("RECTL*         prclSrc         0x%x\n", tempFB.prclSrc);
    dprintf("POINTL*        pptlSrc         0x%x\n", tempFB.pptlSrc);
    dprintf("LONG           lNumRects       %ld\n",  tempFB.lNumRects);
    dprintf("RECTL*         pRects          0x%x\n", tempFB.pRects);
    dprintf("ULONG          colorKey        0x%x\n", tempFB.colorKey);
    dprintf("ULONG          solidColor      0x%x\n", tempFB.solidColor);
    dprintf("RBrush*        prbrush         0x%x\n", tempFB.prbrush);
    dprintf("POINTL*        pptlBrush       0x%x\n", tempFB.pptlBrush);
    dprintf("CLIPOBJ*       pco             0x%x\n", tempFB.pco);
    dprintf("XLATEOBJ*      pxlo            0x%x\n", tempFB.pxlo);
    dprintf("POINTL*        pptlMask        0x%x\n", tempFB.pptlMask);
    dprintf("ULONG          ulRop4          0x%x\n", tempFB.ulRop4);
    dprintf("UCHAR          ucAlpha         0x%x\n", tempFB.ucAlpha);
    dprintf("TRIVERTEX*     ptvrt           0x%x\n", tempFB.ptvrt);
    dprintf("ULONG          ulNumTvrt       %ld\n",  tempFB.ulNumTvrt);
    dprintf("PVOID          pvMesh          0x%x\n", tempFB.pvMesh);
    dprintf("ULONG          ulNumMesh       %ld\n",  tempFB.ulNumMesh);
    dprintf("ULONG          ulMode          0x%x\n", tempFB.ulMode);
    dprintf("SURFOBJ*       psoSrc          0x%x\n", tempFB.psoSrc);
    dprintf("SURFOBJ*       psoDst          0x%x\n", tempFB.psoDst);
    
    return;
    
fb_help:
    dprintf("Usage: fb [-?] GFNPB_PTR\n");
}// fb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\extparse.cxx ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: extparse.cxx
 *
 * Contains all the token parser functions
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "dbgext.hxx"

/**********************************Public*Routine******************************\
 *
 * Command line parsing routines
 *
 * This routine should return an array of char* 's in the idx parameter with the
 * beginning of each token in the array.
 * It also returns the number of tokens found. 
 *
 ******************************************************************************/
int
iParseTokenizer(char*   pcCmdStr,
                char**  ppcTok)
{
    char*   pcSeps = " \t\n";                  // white space separators
    char*   pcToken = strtok(pcCmdStr, pcSeps);  // get the first token
    int     iTokCount = 0;                 // the token count
    
    while ( pcToken )
    {
        ppcTok[iTokCount++] = pcToken;
        pcToken = strtok(NULL, pcSeps);
    }

    return iTokCount;
}// iParseTokenizer()

/**********************************Public*Routine******************************\
 *
 * This routine finds the token specified in srchtok 
 * and returns the index into tok.
 * A return value of -1 is used if the token is not found.
 *
 * Generally we use the case insensitive version (iParseiFindToken) 
 * but occasionally we need the case sensitive version (iParseFindToken).
 *
 ******************************************************************************/
int
iParseFindToken(char**  ppcTok,
                int     iTok,
                char*   pcSrchTok)
{
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( strcmp(ppcTok[iTemp], pcSrchTok) == 0 )
        {
            break;
        }
    }
    if ( iTemp >= iTok )
    {
        return -1;
    }

    return iTemp;
}// iParseFindToken()

/**********************************Public*Routine******************************\
 *
 * Case insensitive version of iParseFindToken
 *
 ******************************************************************************/
int
iParseiFindToken(char** ppcTok,
                 int    iTok,
                 char*  pcSrchTok)
{
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( _strnicmp(ppcTok[iTemp], pcSrchTok, strlen(pcSrchTok)) == 0 )
        {
            break;
        }
    }

    if ( iTemp >= iTok )
    {
        return -1;
    }

    return iTemp;
}// iParseiFindToken()

/**********************************Public*Routine******************************\
 *
 * Verifies that the given token at tok[iTokPos] is a switch
 * and contains the switch value cSwitch.
 *
 * Both case sensitive and insensitive versions.
 *
 ******************************************************************************/
int
iParseiIsSwitch(char**  ppcTok,
                int     iTokPos,
                char    cSwitch)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }

    char*   pcTemp = ppcTok[iTokPos];

    if ( (pcTemp[0] == '-' ) || ( pcTemp[0] == '/' ) )
    {
        //
        // Is a switch.
        //
        for ( pcTemp++; *pcTemp; pcTemp++ )
        {
            if ( toupper(*pcTemp) == toupper(cSwitch) )
            {
                return 1;
            }
        }
    }

    return 0;
}// iParseiIsSwitch()

int
iParseIsSwitch(char**   ppcTok,
               int      iTokPos,
               char     cSwitch)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }

    char*   pcTemp = ppcTok[iTokPos];

    if ( (pcTemp[0] == '-') || (pcTemp[0] == '/') )
    {
        //
        // Is a switch.
        //
        for ( pcTemp++; *pcTemp; pcTemp++ )
        {
            if ( *pcTemp == cSwitch )
            {
                return 1;
            }// search each char
        }
    }

    return 0;
}// iParseIsSwitch()

/**********************************Public*Routine******************************\
 *
 * Finds a switch in a given list of tokens.
 * of the form -xxx(cSwitch)xxx or /xxx(cSwitch)xxx
 * example:
 * searching for 'a' in -jklabw returns true.
 *
 * Again both case sensitive and insensitive versions are needed.
 *
 ******************************************************************************/
int
iParseFindSwitch(char** ppcTok,
                 int    iTok,
                 char   cSwitch)
{
    //
    // Search each token
    //
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( iParseIsSwitch(ppcTok, iTemp, cSwitch) )
        {
            return iTemp;
        }// found it? return position.
    }

    return -1;
}// iParseIsSwitch()

int
iParseiFindSwitch(char**    ppcTok,
                  int       iTok,
                  char      cSwitch)
{
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( iParseIsSwitch(ppcTok, iTemp, cSwitch) )
        {
            return iTemp;
        }//found it? return position.
    }

    return -1;
}// iParseIsSwitch()

/**********************************Public*Routine******************************\
 *
 * Find the first non-switch token starting from position start
 * Will find token at position start
 *
 ******************************************************************************/
int
iParseFindNonSwitch(char**  ppcTok,
                    int     iTok,
                    int     iStart)
{
    for (int iTemp = iStart; iTemp < iTok; ++iTemp )
    {
        if ( (ppcTok[iTemp][0]!='-')&&(ppcTok[iTemp][0]!='/') )
        {
            break;
        }
    }

    if ( iTemp >= iTok )
    {
        return -1;
    }

    return iTemp;
}// iParseFindNonSwitch()

/**********************************Public*Routine******************************\
 *
 * Case insensitive token comparer.
 * returns 1 if pcChk == ppcTok[iTokPos] otherwise returns 0
 *
 * Pay careful attention to the length specifier in the _strnicmp
 *
 ******************************************************************************/
int
iParseiIsToken(char**   ppcTok,
               int      iTokPos,
               char*    pcChk)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }

    return(_strnicmp(ppcTok[iTokPos], pcChk, strlen(pcChk)) == 0);
}// iParseiIsToken()

int
iParseIsToken(char**    ppcTok,
              int       iTokPos,
              char*     pcChk)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }
    return(strcmp(ppcTok[iTokPos], pcChk) == 0);
}// iParseIsToken()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\flags.cxx ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: flags.cxx
*
* Contains all the flags stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "dbgext.hxx"
#include "gdi.h"

//
// The following define expans 'FLAG(x)' to '"x", x':
//
#define FLAG(x) { #x, x }

#define END_FLAG { 0, 0 }

FLAGDEF afdSURF[] =
{
    { "Surface is in Video Memory          ", SF_VM         },
    { "Surface is in System Memory         ", SF_SM         },
    { "Surface is in AGP Memory            ", SF_AGP        },
    { "Surface is kept in surface list     ", SF_LIST       },
    { "Surface was allocated by the driver ", SF_ALLOCATED  },
    { "Surface is a DDRAW wrap surface     ", SF_DIRECTDRAW },
    { NULL                                  , 0             }
};

FLAGDEF afdCAPS[] =
{
    { "CAPS_ZOOM_X_BY2      ", CAPS_ZOOM_X_BY2      },
    { "CAPS_ZOOM_Y_BY2      ", CAPS_ZOOM_Y_BY2      },
    { "CAPS_SPARSE_SPACE    ", CAPS_SPARSE_SPACE    },
    { "CAPS_SW_POINTER      ", CAPS_SW_POINTER      },
    { "CAPS_TVP4020_POINTER ", CAPS_TVP4020_POINTER },
    { "CAPS_P2RD_POINTER    ", CAPS_P2RD_POINTER    },
    { NULL                   , 0                    }
};

FLAGDEF afdSTATUS[] =
{
    { "STAT_BRUSH_CACHE     ", STAT_BRUSH_CACHE     },
    { "STAT_DEV_BITMAPS     ", STAT_DEV_BITMAPS     },
    { "ENABLE_BRUSH_CACHE   ", ENABLE_BRUSH_CACHE   },
    { "ENABLE_DEV_BITMAPS   ", ENABLE_DEV_BITMAPS   },
    { NULL                   , 0                    }
};

FLAGDEF afdHOOK[] = {
    { "HOOK_ALPHABLEND        ", HOOK_ALPHABLEND        },
    { "HOOK_BITBLT            ", HOOK_BITBLT            },
    { "HOOK_COPYBITS          ", HOOK_COPYBITS          },
    { "HOOK_FILLPATH          ", HOOK_FILLPATH          },
    { "HOOK_GRADIENTFILL      ", HOOK_GRADIENTFILL      },
    { "HOOK_LINETO            ", HOOK_LINETO            },
    { "HOOK_PAINT             ", HOOK_PAINT             },
    { "HOOK_PLGBLT            ", HOOK_PLGBLT            },
    { "HOOK_STRETCHBLT        ", HOOK_STRETCHBLT        },
    { "HOOK_STRETCHBLTROP     ", HOOK_STRETCHBLTROP     },
    { "HOOK_STROKEANDFILLPATH ", HOOK_STROKEANDFILLPATH },
    { "HOOK_STROKEPATH        ", HOOK_STROKEPATH        },
    { "HOOK_SYNCHRONIZE       ", HOOK_SYNCHRONIZE       },
    { "HOOK_TEXTOUT           ", HOOK_TEXTOUT           },
    { "HOOK_TRANSPARENTBLT    ", HOOK_TRANSPARENTBLT    },
    { NULL                     , 0                      }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\kdexts.cxx ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: kdexts.cxx
*
* Contains all the kernel debugger extension necessary routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "dbgext.hxx"
#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;


DllInit(HANDLE hModule,
        DWORD  dwReason,
        DWORD  dwReserved)
{
    switch ( dwReason )
    {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}// DllInit()

VOID
WinDbgExtensionDllInit(PWINDBG_EXTENSION_APIS   lpExtensionApis,
                       USHORT                   MajorVersion,
                       USHORT                   MinorVersion)
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}// WinDbgExtensionDllInit()

DECLARE_API(version)
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion);
}// version

VOID
CheckVersion(VOID)
{
#if DBG
    if ( (SavedMajorVersion != 0x0c)
       ||(SavedMinorVersion != VER_PRODUCTBUILD) )
    {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion,
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ( (SavedMajorVersion != 0x0f)
       ||(SavedMinorVersion != VER_PRODUCTBUILD) )
    {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}// CheckVersion()

LPEXT_API_VERSION
ExtensionApiVersion(VOID)
{
    return &ApiVersion;
}// ExtensionApiVersion()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\help.cxx ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: help.cxx
 *
 * Display the help information for p2kdx debug extension
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "dbgext.hxx"

/**********************************Public*Routine******************************\
 *
 * help
 *
 * Prints a simple help summary of the debugging extentions.
 *
 *
 * Note: If you add any debugger extentions, please add a brief description here
 *      then your new extention will be showed when the user types:
 *      !p2kdx.help
 *
 ******************************************************************************/
char*   gaszHelp[] =
{
 "=======================================================================\n"
,"Permedia 2 debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"\n"
,"help\n"
,"Displays this help page.\n"
,"All of the debugger extensions support a -? option for extension specific " 
,"help.\n"
,"All of the debugger extensions that expect a pointer (or handle) can\n"
,"parse expressions. Such as: ebp+8\n"
,"\n"
,"Switches are case insensitive and can be reordered unless otherwise\n"
,"specified in the extension help\n"
,"\n"
,"  - general extensions -\n"
,"\n"
,"surf [Surf Pointer]                             -- dump permedia surf info\n"
,"pdev [PDev Pointer] [-?aghbipcrd]               -- dump permedia PDev info\n"
,"fb   [FunctionBlock Pointer]                    -- dump blt function block\n"
,"\n"
,"=======================================================================\n"
,NULL
};

DECLARE_API(help)
{
    for (char **ppsz = gaszHelp; *ppsz; ppsz++)
    {
        dprintf("%s",*ppsz);
    }
};// help()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\extparse.h ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: extparse.h
 *
 * Header fiel for all the token parser functions
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#ifndef __EXTPARSE__H__
#define __EXTPARSE__H__

int iParseTokenizer(char* pcCmdStr, char** ppcTok);
int iParseFindNonSwitch(char** ppcTok, int iTok, int iStart = 0);

int iParseIsToken(char **ppcTok, int iTokPos, char* pcChk);
int iParseiIsToken(char **ppcTok, int iTokPos, char* pcChk);

int iParseFindToken(char** ppcTok, int iTok, char* pcSrchTok);
int iParseiFindToken(char** ppcTok, int iTok, char* pcSrchTok);

int iParseIsSwitch(char**   ppcTok, int iTokPos, char cSwitch);
int iParseiIsSwitch(char**  ppcTok, int iTokPos, char cSwitch);
int iParseFindSwitch(char** ppcTok, int iTok, char cSwitch);
int iParseiFindSwitch(char**    ppcTok, int iTok, char cSwitch);

/**********************************Public*Routine******************************\
 *
 * Parse the arguments passed to the extension
 * Automatically handle the -? option
 *
 ******************************************************************************/
#define PARSE_ARGUMENTS(ext_label)               \
  char tmp_args[200];                            \
  char *tokens[40];                              \
  int ntok, tok_pos;                             \
  strcpy(tmp_args, args);                        \
  ntok = iParseTokenizer(tmp_args, tokens);      \
  if(ntok>0) {                                   \
    tok_pos=iParseFindSwitch(tokens, ntok, '?'); \
    if(tok_pos>=0) {                             \
      goto ext_label;                            \
    }                                            \
  }                                              \
  tok_pos=0

/**********************************Public*Routine******************************\
 *
 * Parse the arguments assuming a required parameter
 * which is a pointer to be parsed with the expression
 * handler.
 *
 ******************************************************************************/
#define PARSE_POINTER(ext_label)                 \
  UINT_PTR arg;                                     \
  PARSE_ARGUMENTS(ext_label);                    \
  if(ntok<1) {goto ext_label;}                   \
  tok_pos = iParseFindNonSwitch(tokens, ntok);   \
  if(tok_pos==-1) {goto ext_label;}              \
  arg = (UINT_PTR)GetExpression(tokens[tok_pos])

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\interupt.h ===
//***************************************************************************
//
// Module Name:
// 
//     interupt.h
// 
// Abstract:
// 
//    This module contains the definitions for the shared memory used by
//    the interrupt control routines.
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
} INTERRUPT_CONTROL;

//
// The display driver will only use the interrupt handler
// if we set this magic number. Increment it if the
// data structure changes
//

#define P2_ICB_MAGICNUMBER 0xbadabe01

//
// This data structure is shared between the Permedia 2 Display
// Driver and the miniport
//
// Do not change the data structures without updating the DD
//

typedef struct INTERRUPT_CONTROL_BLOCK {

    ULONG ulMagicNo;                   // The dd will search for
                                       // this magic number and only
                                       // use the interupt handler
                                       // if the magic no is the same
                                       // as in the display driver

    volatile ULONG  ulControl;         // flags mark DMA/VS IRQs
    volatile ULONG  ulIRQCounter;      // counter for total number of IRQs
    
    LARGE_INTEGER   liDMAPhysAddress;  // physical address of DMA Buffer
    ULONG *         pDMABufferStart;   // virtual address of DMA buffer
    ULONG *         pDMABufferEnd;     // full size in DWORDs of DMA Buffer
    volatile ULONG *pDMAActualBufferEnd;
                                       // size in DWORDs of DMA Buffer

    volatile ULONG *pDMAWriteEnd;      // end of buffer
    volatile ULONG *pDMAPrevStart;     // last start address of a DMA
    volatile ULONG *pDMANextStart;     // next start address of a DMA
    volatile ULONG *pDMAWritePos;      // current write Index pointer

    volatile ULONG  ulICBLock;         // this lock is set by the display driver

    volatile ULONG  ulVSIRQCounter;    // counter for VS IRQs

    volatile ULONG  ulLastErrorFlags;   
    volatile ULONG  ulErrorCounter;

} INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;


//
// structure containing information about the interrupt control block
//
typedef struct _interrupt_control_buffer_ {

    PVOID ControlBlock;
    ULONG Size;

} P2_INTERRUPT_CTRLBUF, *PP2_INTERRUPT_CTRLBUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\interupt.c ===
//***************************************************************************
//
// Module Name:
//
//   interupt.c
//
// Abstract:
//
//    This module contains code to control interrupts for Permedia2. The
//    interrupt handler performs operations required by the display driver.
//    To communicate between the two we set up a piece of non-paged shared
//    memory to contain synchronization information and a queue for DMA
//    buffers.
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


#include "permedia.h"

#pragma alloc_text(PAGE,Permedia2InitializeInterruptBlock)
#pragma optimize("x",on)

//
// *** THIS ROUTINE CANNOT BE PAGED ***
//

BOOLEAN
Permedia2VidInterrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Interrupts are enabled by the DD as and when they are needed. The miniport
    simply indicates via the Capabilities flags whether interrupts are
    available.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    ULONG intrFlags;
    ULONG enableFlags;

    P2_DECL;

    if(hwDeviceExtension->PreviousPowerState != VideoPowerOn) 
    {

        //
        // We reach here because we are sharing IRQ with other devices
        // and another device on the chain is in D0 and functioning
        //

        return FALSE;
    }

    //
    // find out what caused the interrupt. We AND with the enabled interrupts
    // since the flags are set if the event occurred even though no interrupt
    // was enabled.
    //

    intrFlags   = VideoPortReadRegisterUlong(INT_FLAGS);
    enableFlags = VideoPortReadRegisterUlong(INT_ENABLE);

    intrFlags &= enableFlags;
    if (intrFlags == 0)
        return FALSE;

    //
    // select the interrupt control block for this board
    //

    pBlock = hwDeviceExtension->InterruptControl.ControlBlock;

    VideoPortWriteRegisterUlong(INT_FLAGS, intrFlags);

    if (pBlock == NULL) return TRUE;


#if DBG

    //
    // if this error handler bugchecks, we have a synchronization problem
    // with the display driver
    //

    if (intrFlags & INTR_ERROR_SET)
    {
        ULONG ulError = VideoPortReadRegisterUlong (ERROR_FLAGS);

        if (ulError & (0xf|0x700))
        {
            pBlock->ulLastErrorFlags=ulError;
            pBlock->ulErrorCounter++;

            DEBUG_PRINT((0, "***Error Interrupt!!!(%lxh)\n", ulError));
        }

        VideoPortWriteRegisterUlong ( ERROR_FLAGS, ulError);
    }

    pBlock->ulIRQCounter++;

    if (intrFlags & INTR_VBLANK_SET)
    {
        pBlock->ulControl |= VBLANK_INTERRUPT_AVAILABLE;
        pBlock->ulVSIRQCounter++;
    }

#endif

    if (intrFlags & INTR_DMA_SET)
    {
        pBlock->ulControl |= DMA_INTERRUPT_AVAILABLE;

        //
        // lock access to shared memory section first
        //

        if (VideoPortInterlockedExchange((LONG*)&pBlock->ulICBLock,TRUE))
        {
            return TRUE;
        }

        if (VideoPortReadRegisterUlong(DMA_COUNT) == 0)
        {

            if (pBlock->pDMAWritePos>pBlock->pDMANextStart)
            {
                VideoPortWriteRegisterUlong(DMA_ADDRESS,
                     (ULONG)(pBlock->liDMAPhysAddress.LowPart +
                     (pBlock->pDMANextStart-
                      pBlock->pDMABufferStart)
                     *sizeof(ULONG)));

                VideoPortWriteRegisterUlong(DMA_COUNT,
                     (ULONG)(pBlock->pDMAWritePos-pBlock->pDMANextStart));

                pBlock->pDMAWriteEnd  = pBlock->pDMABufferEnd;
                pBlock->pDMAPrevStart = pBlock->pDMANextStart;
                pBlock->pDMANextStart = pBlock->pDMAWritePos;

            } else if (pBlock->pDMAWritePos<pBlock->pDMANextStart)
            {
                VideoPortWriteRegisterUlong(DMA_ADDRESS,
                     (ULONG)(pBlock->liDMAPhysAddress.LowPart +
                     (pBlock->pDMANextStart-
                      pBlock->pDMABufferStart)
                     *sizeof(ULONG)));

                VideoPortWriteRegisterUlong(DMA_COUNT,
                         (ULONG)(pBlock->pDMAActualBufferEnd-pBlock->pDMANextStart));

                pBlock->pDMAActualBufferEnd=pBlock->pDMABufferEnd;

                pBlock->pDMAPrevStart=pBlock->pDMANextStart;
                pBlock->pDMAWriteEnd =pBlock->pDMANextStart-1;
                pBlock->pDMANextStart=pBlock->pDMABufferStart;

            } else //if (pBlock->pDMAWritePos==pBlock->pDMANextStart)
            {
                //
                //  turn off IRQ service if we are idle...
                //

                VideoPortWriteRegisterUlong(INT_ENABLE, enableFlags & ~INTR_DMA_SET);
            }
        }


        //
        // release lock, we are done
        //

        VideoPortInterlockedExchange((LONG*)&pBlock->ulICBLock,FALSE);
    }

    return TRUE;
}

#pragma optimize("",on)


BOOLEAN
Permedia2InitializeInterruptBlock(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

Routine Description:

    Do any initialization needed for interrupts, such as allocating the shared
    memory control block.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

--*/

{
    PINTERRUPT_CONTROL_BLOCK pBlock;
    PVOID virtAddr;
    ULONG size;
    PHYSICAL_ADDRESS phyadd;
    ULONG ActualSize;

    //
    // allocate a page of non-paged memory. This will be used as the shared
    // memory between the display driver and the interrupt handler. Since
    // it's only a page in size the physical addresses are contiguous. So
    // we can use this as a small DMA buffer.
    //

    size = PAGE_SIZE;

    virtAddr = VideoPortGetCommonBuffer( hwDeviceExtension,
                                         size,
                                         PAGE_SIZE,
                                         &phyadd,
                                         &ActualSize,
                                         TRUE );

    hwDeviceExtension->InterruptControl.ControlBlock = virtAddr;
    hwDeviceExtension->InterruptControl.Size         = ActualSize;

    if ( (virtAddr == NULL) || (ActualSize < size) )
    {
        DEBUG_PRINT((1, "ExAllocatePool failed for interrupt control block\n"));
        return(FALSE);
    }

    VideoPortZeroMemory( virtAddr, size);

    //
    // We can't flush the cache from the interrupt handler because we must be
    // running at <= DISPATCH_LEVEL to call KeFlushIoBuffers. So we need a DPC
    // to do the cache flush.
    //

    DEBUG_PRINT((2, "Initialized custom DPC routine for cache flushing\n"));

    P2_ASSERT((sizeof(INTERRUPT_CONTROL_BLOCK) <= size),
                 "InterruptControlBlock is too big. Fix the driver!!\n");

    //
    // set up the control block
    //

    pBlock = virtAddr;
    pBlock->ulMagicNo = P2_ICB_MAGICNUMBER;

    //
    // we rely on the pBlock data being set to zero after allocation!
    //

    return(TRUE);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\p2rd.h ===
//***************************************************************************
//
// Module Name:
// 
// 	p2rd.h
// 
// Abstract:
// 
//      This module contains the definitions for the 3Dlabs P2ST RAMDAC
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


//
// structure with all the direct access registers
//
    
typedef struct _p2rd_regs
{
    RAMDAC_REG    RDPaletteWriteAddress;
    RAMDAC_REG    RDPaletteData;
    RAMDAC_REG    RDPixelMask;
    RAMDAC_REG    RDPaletteAddressRead;
    RAMDAC_REG    RDIndexLow;
    RAMDAC_REG    RDIndexHigh;
    RAMDAC_REG    RDIndexedData;
    RAMDAC_REG    RDIndexControl;
}
P2RDRAMDAC;

//
// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after P2_DECL.
//
    
#define P2RD_DECL \
    P2RDRAMDAC *pP2RDRegs = (P2RDRAMDAC *)hwDeviceExtension->pRamdac

//
// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
    
#define P2RD_PAL_WR_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteWriteAddress.reg))
#define P2RD_PAL_RD_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteAddressRead.reg))
#define P2RD_PAL_DATA                 ((PULONG)&(pP2RDRegs->RDPaletteData.reg))
#define P2RD_PIXEL_MASK               ((PULONG)&(pP2RDRegs->RDPixelMask.reg))
#define P2RD_INDEX_ADDR_LO            ((PULONG)&(pP2RDRegs->RDIndexLow.reg))
#define P2RD_INDEX_ADDR_HI            ((PULONG)&(pP2RDRegs->RDIndexHigh.reg))
#define P2RD_INDEX_DATA               ((PULONG)&(pP2RDRegs->RDIndexedData.reg))
#define P2RD_INDEX_CONTROL            ((PULONG)&(pP2RDRegs->RDIndexControl.reg))

//
// bit field definitions for the direct access registers
//
    
#define P2RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

//
// indexed register definitions accessed via P2RD_LOAD_INDEX_REG() and P2RD_READ_INDEX_REG()
//
    
#define P2RD_MISC_CONTROL             0x0000
#define P2RD_SYNC_CONTROL             0x0001
#define P2RD_DAC_CONTROL              0x0002
#define P2RD_PIXEL_SIZE               0x0003
#define P2RD_COLOR_FORMAT             0x0004
#define P2RD_CURSOR_MODE              0x0005
#define P2RD_CURSOR_CONTROL           0x0006
#define P2RD_CURSOR_X_LOW             0x0007
#define P2RD_CURSOR_X_HIGH            0x0008
#define P2RD_CURSOR_Y_LOW             0x0009
#define P2RD_CURSOR_Y_HIGH            0x000a
#define P2RD_CURSOR_HOTSPOT_X         0x000b
#define P2RD_CURSOR_HOTSPOT_Y         0x000c
#define P2RD_OVERLAY_KEY              0x000d
#define P2RD_PAN                      0x000e
#define P2RD_SENSE                    0x000f
#define P2RD_CHECK_CONTROL            0x0018
#define P2RD_CHECK_PIXEL_RED          0x0019
#define P2RD_CHECK_PIXEL_GREEN        0x001a
#define P2RD_CHECK_PIXEL_BLUE         0x001b
#define P2RD_CHECK_LUT_RED            0x001c
#define P2RD_CHECK_LUT_GREEN          0x001d
#define P2RD_CHECK_LUT_BLUE           0x001e
#define P2RD_DCLK_SETUP_1             0x01f0
#define P2RD_DCLK_SETUP_2             0x01f1
#define P2RD_MCLK_SETUP_1             0x01f2
#define P2RD_MCLK_SETUP_2             0x01f3
#define P2RD_DCLK_CONTROL             0x0200
#define P2RD_DCLK0_PRE_SCALE          0x0201
#define P2RD_DCLK0_FEEDBACK_SCALE     0x0202
#define P2RD_DCLK0_POST_SCALE         0x0203
#define P2RD_DCLK1_PRE_SCALE          0x0204
#define P2RD_DCLK1_FEEDBACK_SCALE     0x0205
#define P2RD_DCLK1_POST_SCALE         0x0206
#define P2RD_DCLK2_PRE_SCALE          0x0207
#define P2RD_DCLK2_FEEDBACK_SCALE     0x0208
#define P2RD_DCLK2_POST_SCALE         0x0209
#define P2RD_DCLK3_PRE_SCALE          0x020a
#define P2RD_DCLK3_FEEDBACK_SCALE     0x020b
#define P2RD_DCLK3_POST_SCALE         0x020c
#define P2RD_MCLK_CONTROL             0x020d
#define P2RD_MCLK_PRE_SCALE           0x020e
#define P2RD_MCLK_FEEDBACK_SCALE      0x020f
#define P2RD_MCLK_POST_SCALE          0x0210
#define P2RD_CURSOR_PALETTE_START     0x0303        // 303..32f
#define P2RD_CURSOR_PATTERN_START     0x0400        // 400..7ff

//
// bit field definitions for the indexed registers
//
    
#define P2RD_MISC_CONTROL_OVERLAYS_ENABLED        0x10
#define P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED    0x08
#define P2RD_MISC_CONTROL_PIXEL_DOUBLE            0x02
#define P2RD_MISC_CONTROL_HIGHCOLORRES            0x01

#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW        0x00
#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH       0x08
#define P2RD_SYNC_CONTROL_VSYNC_INACTIVE          0x20
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW        0x00
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH       0x01
#define P2RD_SYNC_CONTROL_HSYNC_INACTIVE          0x04

#define P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED   0x80

#define P2RD_PIXEL_SIZE_8BPP                      0x00
#define P2RD_PIXEL_SIZE_16BPP                     0x01
#define P2RD_PIXEL_SIZE_24_BPP                    0x04
#define P2RD_PIXEL_SIZE_32BPP                     0x02

#define P2RD_COLOR_FORMAT_CI8                     0x0e
#define P2RD_COLOR_FORMAT_8BPP                    0x05
#define P2RD_COLOR_FORMAT_15BPP                   0x01
#define P2RD_COLOR_FORMAT_16BPP                   0x10
#define P2RD_COLOR_FORMAT_32BPP                   0x00
#define P2RD_COLOR_FORMAT_LINEAR_EXT              0x40
#define P2RD_COLOR_FORMAT_RGB                     0x20

#define P2RD_CURSOR_MODE_REVERSE                  0x40
#define P2RD_CURSOR_MODE_WINDOWS                  0x00
#define P2RD_CURSOR_MODE_X                        0x10
#define P2RD_CURSOR_MODE_3COLOR                   0x20
#define P2RD_CURSOR_MODE_15COLOR                  0x30
#define P2RD_CURSOR_MODE_64x64                    0x00
#define P2RD_CURSOR_MODE_P0_32x32x2               0x02
#define P2RD_CURSOR_MODE_P1_32x32x2               0x04
#define P2RD_CURSOR_MODE_P2_32x32x2               0x06
#define P2RD_CURSOR_MODE_P3_32x32x2               0x08
#define P2RD_CURSOR_MODE_P01_32x32x4              0x0a
#define P2RD_CURSOR_MODE_P23_32x32x4              0x0c
#define P2RD_CURSOR_MODE_ENABLED                  0x01

#define P2RD_CURSOR_CONTROL_RPOS_ENABLED          0x04
#define P2RD_CURSOR_CONTROL_DOUBLE_Y              0x02
#define P2RD_CURSOR_CONTROL_DOUBLE_X              0x01

#define P2RD_DCLK_CONTROL_LOCKED                  0x02    // read-only
#define P2RD_DCLK_CONTROL_ENABLED                 0x01
#define P2RD_DCLK_CONTROL_RUN                     0x08

#define P2RD_MCLK_CONTROL_LOCKED                  0x02    // read-only
#define P2RD_MCLK_CONTROL_ENABLED                 0x01
#define P2RD_MCLK_CONTROL_RUN                     0x08

#define P2RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}


#if 0

//
// need a delay between each write to the P2RD. The only way to guarantee
// that the write has completed is to read from a Permedia 2 control register.
// Reading forces any posted writes to be flushed out. 
//

#define P2RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else

#define P2RD_DELAY

#endif

//
// macro to load a given data value into an internal P2RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
    
#define P2RD_INDEX_REG(index) \
{ \
    DEBUG_PRINT((3, "*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P2RD_DELAY; \
    DEBUG_PRINT((3, "*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    DEBUG_PRINT((3, "*(0x%x) <-- 0x%x\n", P2RD_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_READ_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    data = VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff;   \
    P2RD_DELAY; \
    DEBUG_PRINT((3, "0x%x <-- *(0x%x)\n", data, P2RD_INDEX_DATA)); \
}

#define P2RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA,    (ULONG)(data));   \
    P2RD_DELAY; \
}

//
// macros to load a given RGB triple into the P2RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P2RD_PALETTE_START and multiple P2RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P2RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
    
#define P2RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR, (ULONG)(index));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

//
// macro to read back a given RGB triple from the P2RD palette. Use after
// a call to P2RD_PALETTE_START_RD
//
    
#define P2RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
}

//
// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
    
#define P2RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PIXEL_MASK,  (ULONG)(mask)); \
    P2RD_DELAY; \
}

#define P2RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P2RD_PIXEL_MASK) & 0xff; \
}

//
// macros to load values into the cursor array usage is P2RD_CURSOR_ARRAR_START() followed by 
// n iterations of P2RD_LOAD_CURSOR_ARRAY() or P2RD_READ_CURSOR_ARRAY()
//
    
#define P2RD_CURSOR_ARRAY_START(offset) \
{ \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) & 0xff));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) >> 8));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)(data)); \
    P2RD_DELAY; \
}

#define P2RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff; \
    P2RD_DELAY; \
}

//
// macro to move the cursor
//
    
#define P2RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)0);              \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

//
// macro to change the cursor hotspot
//
    
#define P2RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
    
//
// macro to change the cursor color
//
    
#define P2RD_CURSOR_COLOR(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\perm2tag.h ===
//***************************************************************************
//
// Module Name:
// 
//     perm2tag.h
// 
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1994 3Dlabs Inc. Ltd. All Rights Reserved. 
//
//***************************************************************************

/* NOTE:File is machine generated.Do not edit.*/

#ifndef PERM2TAG_H
#define PERM2TAG_H

#define    __P2TagStartXDom                    0x000
#define    __P2TagdXDom                        0x001
#define    __P2TagStartXSub                    0x002
#define    __P2TagdXSub                        0x003
#define    __P2TagStartY                       0x004
#define    __P2TagdY                           0x005
#define    __P2TagCount                        0x006
#define    __P2TagRender                       0x007
#define    __P2TagContinueNewLine              0x008
#define    __P2TagContinueNewDom               0x009
#define    __P2TagContinueNewSub               0x00a
#define    __P2TagContinue                     0x00b
#define    __P2TagFlushSpan                    0x00c
#define    __P2TagBitMaskPattern               0x00d
#define    __P2TagPointTable0                  0x010
#define    __P2TagPointTable1                  0x011
#define    __P2TagPointTable2                  0x012
#define    __P2TagPointTable3                  0x013
#define    __P2TagRasterizerMode               0x014
#define    __P2TagYLimits                      0x015
#define    __P2TagScanlineOwnership            0x016
#define    __P2TagWaitForCompletion            0x017
#define    __P2TagPixelSize                    0x018
#define    __P2TagScissorMode                  0x030
#define    __P2TagScissorMinXY                 0x031
#define    __P2TagScissorMaxXY                 0x032
#define    __P2TagScreenSize                   0x033
#define    __P2TagAreaStippleMode              0x034
#define    __P2TagLineStippleMode              0x035
#define    __P2TagLoadLineStippleCounters      0x036
#define    __P2TagUpdateLineStippleCounters    0x037
#define    __P2TagSaveLineStippleCounters      0x038
#define    __P2TagWindowOrigin                 0x039
#define    __P2TagAreaStipplePattern0          0x040
#define    __P2TagAreaStipplePattern1          0x041
#define    __P2TagAreaStipplePattern2          0x042
#define    __P2TagAreaStipplePattern3          0x043
#define    __P2TagAreaStipplePattern4          0x044
#define    __P2TagAreaStipplePattern5          0x045
#define    __P2TagAreaStipplePattern6          0x046
#define    __P2TagAreaStipplePattern7          0x047
#define    __P2TagAreaStipplePattern8          0x048
#define    __P2TagAreaStipplePattern9          0x049
#define    __P2TagAreaStipplePattern10         0x04a
#define    __P2TagAreaStipplePattern11         0x04b
#define    __P2TagAreaStipplePattern12         0x04c
#define    __P2TagAreaStipplePattern13         0x04d
#define    __P2TagAreaStipplePattern14         0x04e
#define    __P2TagAreaStipplePattern15         0x04f
#define    __P2TagAreaStipplePattern16         0x050
#define    __P2TagAreaStipplePattern17         0x051
#define    __P2TagAreaStipplePattern18         0x052
#define    __P2TagAreaStipplePattern19         0x053
#define    __P2TagAreaStipplePattern20         0x054
#define    __P2TagAreaStipplePattern21         0x055
#define    __P2TagAreaStipplePattern22         0x056
#define    __P2TagAreaStipplePattern23         0x057
#define    __P2TagAreaStipplePattern24         0x058
#define    __P2TagAreaStipplePattern25         0x059
#define    __P2TagAreaStipplePattern26         0x05a
#define    __P2TagAreaStipplePattern27         0x05b
#define    __P2TagAreaStipplePattern28         0x05c
#define    __P2TagAreaStipplePattern29         0x05d
#define    __P2TagAreaStipplePattern30         0x05e
#define    __P2TagAreaStipplePattern31         0x05f
#define    __P2TagTexel0                       0x0c0
#define    __P2TagTexel1                       0x0c1
#define    __P2TagTexel2                       0x0c2
#define    __P2TagTexel3                       0x0c3
#define    __P2TagTexel4                       0x0c4
#define    __P2TagTexel5                       0x0c5
#define    __P2TagTexel6                       0x0c6
#define    __P2TagTexel7                       0x0c7
#define    __P2TagInterp0                      0x0c8
#define    __P2TagInterp1                      0x0c9
#define    __P2TagInterp2                      0x0ca
#define    __P2TagInterp3                      0x0cb
#define    __P2TagInterp4                      0x0cc
#define    __P2TagTextureFilter                0x0cd
#define    __P2TagTextureColorMode             0x0d0
#define    __P2TagTextureEnvColor              0x0d1
#define    __P2TagFogMode                      0x0d2
#define    __P2TagFogColor                     0x0d3
#define    __P2TagFStart                       0x0d4
#define    __P2TagdFdx                         0x0d5
#define    __P2TagdFdyDom                      0x0d6
#define    __P2TagRStart                       0x0f0
#define    __P2TagdRdx                         0x0f1
#define    __P2TagdRdyDom                      0x0f2
#define    __P2TagGStart                       0x0f3
#define    __P2TagdGdx                         0x0f4
#define    __P2TagdGdyDom                      0x0f5
#define    __P2TagBStart                       0x0f6
#define    __P2TagdBdx                         0x0f7
#define    __P2TagdBdyDom                      0x0f8
#define    __P2TagAStart                       0x0f9
#define    __P2TagdAdx                         0x0fa
#define    __P2TagdAdyDom                      0x0fb
#define    __P2TagColorDDAMode                 0x0fc
#define    __P2TagConstantColor                0x0fd
#define    __P2TagColor                        0x0fe
#define    __P2TagAlphaTestMode                0x100
#define    __P2TagAntialiasMode                0x101
#define    __P2TagAlphaBlendMode               0x102
#define    __P2TagDitherMode                   0x103
#define    __P2TagFBSoftwareWriteMask          0x104
#define    __P2TagLogicalOpMode                0x105
#define    __P2TagFBWriteData                  0x106
#define    __P2TagFBCancelWrite                0x107
#define    __P2TagLBReadMode                   0x110
#define    __P2TagLBReadFormat                 0x111
#define    __P2TagLBSourceOffset               0x112
#define    __P2TagLBSourceData                 0x114
#define    __P2TagLBStencil                    0x115
#define    __P2TagLBDepth                      0x116
#define    __P2TagLBWindowBase                 0x117
#define    __P2TagLBWriteMode                  0x118
#define    __P2TagLBWriteFormat                0x119
#define    __P2TagWindow                       0x130
#define    __P2TagStencilMode                  0x131
#define    __P2TagStencilData                  0x132
#define    __P2TagStencil                      0x133
#define    __P2TagDepthMode                    0x134
#define    __P2TagDepth                        0x135
#define    __P2TagZStartU                      0x136
#define    __P2TagZStartL                      0x137
#define    __P2TagdZdxU                        0x138
#define    __P2TagdZdxL                        0x139
#define    __P2TagdZdyDomU                     0x13a
#define    __P2TagdZdyDomL                     0x13b
#define    __P2TagFastClearDepth               0x13c
#define    __P2TagFBReadMode                   0x150
#define    __P2TagFBSourceOffset               0x151
#define    __P2TagFBPixelOffset                0x152
#define    __P2TagFBColor                      0x153
#define    __P2TagFBWindowBase                 0x156
#define    __P2TagFBWriteMode                  0x157
#define    __P2TagFBHardwareWriteMask          0x158
#define    __P2TagFBBlockColor                 0x159
#define    __P2TagFilterMode                   0x180
#define    __P2TagStatisticMode                0x181
#define    __P2TagMinRegion                    0x182
#define    __P2TagMaxRegion                    0x183
#define    __P2TagResetPickResult              0x184
#define    __P2TagMinHitRegion                 0x185
#define    __P2TagMaxHitRegion                 0x186
#define    __P2TagPickResult                   0x187
#define    __P2TagSync                         0x188

#endif // PERM2TAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\perm2ver.h ===
// UpVer: 0009

#define PERM2_VERSION_STRING    "1.00-0009 (MS)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\pciprobe.c ===
//***************************************************************************
//
//  Module Name:
//
//    pciprobe.c
//
//  Abstract:
//
//    Probe PCI and get access range
//
//  Environment:
//
//    Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, Permedia2AssignResources)
#pragma alloc_text(PAGE, Permedia2AssignResourcesNT4)
#endif

#define CreativeSubVendorID   0x1102
#define PiccasoSubVendorID    0x148C
#define PiccasoSubSystemID    0x0100
#define SynergyA8SubVendorID  0x1048
#define SynergyA8SubSystemID  0x0A32

BOOLEAN
Permedia2AssignResources(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

// 
// Look for a Permedia2 adapter and return the address regions for 
// that adapter. 
//

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PCI_COMMON_CONFIG    PCIFunctionConfig;
    PPCI_COMMON_CONFIG   PciData = &PCIFunctionConfig;
    BOOLEAN              bRet;
    USHORT               VendorID;
    USHORT               DeviceID;
    VP_STATUS            status;
    ULONG                i;
    ULONG                VgaStatus;

    // 
    // assume we fail to catch all errors.
    // 

    bRet = FALSE;

#if DBG

    DEBUG_PRINT((2, "Permedia2AssignResources: read PCI config space (bus %d):-\n",
                (int)ConfigInfo->SystemIoBusNumber));
    DumpPCIConfigSpace(HwDeviceExtension, ConfigInfo->SystemIoBusNumber, 0);

#endif

    VideoPortGetBusData( HwDeviceExtension,
                         PCIConfiguration,
                         0,
                         PciData,
                         0,
                         PCI_COMMON_HDR_LENGTH ); 

    hwDeviceExtension->bDMAEnabled = PciData->Command & PCI_ENABLE_BUS_MASTER;

    if (!hwDeviceExtension->bDMAEnabled) 
    {
        DEBUG_PRINT((1, "PERM2: enabling DMA for VGA card\n"));

        PciData->Command |= PCI_ENABLE_BUS_MASTER;

        VideoPortSetBusData( HwDeviceExtension,
                             PCIConfiguration,
                             0,
                             PciData,
                             0,
                             PCI_COMMON_HDR_LENGTH ); 
    }

    VendorID = PciData->VendorID;
    DeviceID = PciData->DeviceID;

    hwDeviceExtension->deviceInfo.VendorId   = VendorID;
    hwDeviceExtension->deviceInfo.DeviceId   = DeviceID; 
    hwDeviceExtension->deviceInfo.RevisionId = PciData->RevisionID;

    hwDeviceExtension->deviceInfo.SubsystemVendorId = 
            PciData->u.type0.SubVendorID;

    hwDeviceExtension->deviceInfo.SubsystemId = 
            PciData->u.type0.SubSystemID;

    if( ( PciData->u.type0.SubVendorID == PiccasoSubVendorID ) &&
        ( PciData->u.type0.SubSystemID == PiccasoSubSystemID ) )
    {
       return(FALSE);
    } 

    if( ( PciData->u.type0.SubVendorID == SynergyA8SubVendorID ) &&
        ( PciData->u.type0.SubSystemID == SynergyA8SubSystemID ) )
    {
       return(FALSE);
    } 

    //
    // check if SubSystemID/SubVendorID bits are read only
    // 

    if( PciData->u.type0.SubVendorID == CreativeSubVendorID )
    {
        hwDeviceExtension->HardwiredSubSystemId = FALSE;
    } 
    else
    {
        hwDeviceExtension->HardwiredSubSystemId = TRUE;
    }


    hwDeviceExtension->pciBus = ConfigInfo->SystemIoBusNumber;

    hwDeviceExtension->deviceInfo.DeltaRevId = 0;

    // 
    // in multi-adapter systems we need to check if the VGA on this device 
    // is active
    // 

    VideoPortGetVgaStatus( HwDeviceExtension, &VgaStatus );

    hwDeviceExtension->bVGAEnabled = 
                      (VgaStatus & DEVICE_VGA_ENABLED) ? TRUE : FALSE;

    if(!hwDeviceExtension->bVGAEnabled)
    {

        // 
        // in a multi-adapter system we'll need to turn on the memory 
        // space for the secondary adapters
        // 

        DEBUG_PRINT((1, "PERM2: enabling memory space access for the secondary card\n"));

        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;

        VideoPortSetBusData( HwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH );
    }

    hwDeviceExtension->PciSpeed = 
                     (PciData->Status & PCI_STATUS_66MHZ_CAPABLE) ? 66 : 33;

    DEBUG_PRINT((2, "VGAEnabled = %d. Pci Speed = %d\n",
                     hwDeviceExtension->bVGAEnabled, 
                     hwDeviceExtension->PciSpeed));

    VideoPortZeroMemory((PVOID)AccessRange, 
                         NumRegions * sizeof(VIDEO_ACCESS_RANGE));

    // 
    // these should be zero but just in case
    // 

    ConfigInfo->BusInterruptLevel  = 0;
    ConfigInfo->BusInterruptVector = 0;

    i = 0;
    status = VideoPortGetAccessRanges(HwDeviceExtension,
                                      0,
                                      NULL,
                                      NumRegions,
                                      AccessRange,
                                      &VendorID,
                                      &DeviceID,
                                      &i);
    if (status == NO_ERROR)
    {
        DEBUG_PRINT((2, "VideoPortGetAccessRanges succeeded\n"));
    }
    else
    {
        DEBUG_PRINT((2, "VideoPortGetAccessRanges failed. error 0x%x\n", status));
        goto ReturnValue;
    }

    // 
    // get an updated copy of the config space
    // 

    VideoPortGetBusData(HwDeviceExtension,
                        PCIConfiguration,
                        0,
                        PciData,
                        0,
                        PCI_COMMON_HDR_LENGTH);

#if DBG

    DEBUG_PRINT((2, "Final set of base addresses\n"));
 
    for (i = 0; i < NumRegions; ++i)
    {
        if (AccessRange[i].RangeLength == 0)
            break;

        DEBUG_PRINT((2, "%d: Addr 0x%x.0x%08x, Length 0x%08x, InIo %d, visible %d, share %d\n", i,
                     AccessRange[i].RangeStart.HighPart,
                     AccessRange[i].RangeStart.LowPart,
                     AccessRange[i].RangeLength,
                     AccessRange[i].RangeInIoSpace,
                     AccessRange[i].RangeVisible,
                     AccessRange[i].RangeShareable));
    }

#endif

    // 
    // try to enable for DMA transfers
    // 

    ConfigInfo->Master=1;
    bRet = TRUE;

ReturnValue:

    return(bRet);
}

BOOLEAN
Permedia2AssignResourcesNT4(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

// 
// Look for a Permedia2 adapter and return the address regions for 
// that adapter. 
//

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    BOOLEAN              bRet;
    USHORT               VendorID, DeviceID;
    USHORT               *pVenID, *pDevID;
    VP_STATUS            status;
    ULONG                i;

    USHORT VenID[] = { VENDOR_ID_3DLABS, 
                       VENDOR_ID_TI,
                       0 };
                
    USHORT DevID[] = { PERMEDIA2_ID, 
                       PERMEDIA_P2_ID, 
                       PERMEDIA_P2S_ID, 
                       0 };

    if( hwDeviceExtension->NtVersion != NT4)
    {

        DEBUG_PRINT((0, "Permedia2AssignResourcesNT4: This function can only be called on NT 4\n"));
        return (FALSE);
    
    }
    else
    {

        bRet = FALSE;

        // 
        // Since we do not support multi-mon on NT 4, we
        // assume this is the only video card in the system.
        //

        hwDeviceExtension->bVGAEnabled = 1;
 
        VideoPortZeroMemory((PVOID)AccessRange, 
                             NumRegions * sizeof(VIDEO_ACCESS_RANGE));

        for( pVenID = &(VenID[0]); *pVenID != 0; pVenID++)
        {
             for( pDevID = &(DevID[0]); *pDevID != 0; pDevID++)
             {   

                 i = 0;

                 status = VideoPortGetAccessRanges(HwDeviceExtension,
                                                   0,
                                                   NULL,
                                                   NumRegions,
                                                   (PVIDEO_ACCESS_RANGE) AccessRange,
                                                   pVenID,
                                                   pDevID,
                                                   &i);

                 if (status == NO_ERROR)
                 {

                     DEBUG_PRINT((2, "VideoPortGetAccessRanges succeeded\n"));

                     bRet = TRUE;

                     return(bRet);
                 }
            }
        }

        return(bRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\permdata.c ===
//***************************************************************************
//
//  Module Name:
//
//    permdata.c
//
//  Abstract:
//
//    This module contains all the global data used by the Permedia2 driver.
//
//  Environment:
//
//    Kernel mode
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


#include "permedia.h"

/*
 * DATA STRUCTURES
 * ===============
 */

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGED_DATA")
#endif

//
// Permedia2 Legacy Resource List
//
//              RangeStart        RangeLength
//              |                 |      RangeInIoSpace
//              |                 |      |  RangeVisible
//        +-----+-----+           |      |  |  RangeShareable
//        |           |           |      |  |  |  RangePassive
//        v           v           v      v  v  v  v

VIDEO_ACCESS_RANGE P2LegacyResourceList[] = 
{
    {0x000C0000, 0x00000000, 0x00010000, 0, 0, 0, 0}, // ROM location
    {0x000A0000, 0x00000000, 0x00020000, 0, 0, 1, 0}, // Frame buffer
    {0x000003B0, 0x00000000, 0x0000000C, 1, 1, 1, 0}, // VGA regs
    {0x000003C0, 0x00000000, 0x00000020, 1, 1, 1, 0}  // VGA regs
};

ULONG P2LegacyResourceEntries = sizeof P2LegacyResourceList / sizeof P2LegacyResourceList[0];


// Entries for 3 bpp colors
//      Index(0-7) -> Color(0-255)
ULONG   bPal8[] = {
        0x00, 0x24, 0x48, 0x6D,
        0x91, 0xB6, 0xDA, 0xFF
    };

// Entries for 2 bpp colors
//      Index(0-3) -> Color(0-255)
ULONG   bPal4[] = {
        0x00, 0x6D, 0xB6, 0xFF
    };

    

///////////////////////////////////////////////////////////////////////////
// Video mode table - Lists the information about each individual mode.
//
// Note that any new modes should be added here and to the appropriate
// P2_VIDEO_FREQUENCIES tables.
//

P2_VIDEO_MODES P2Modes[] = {
    {                      // 320x200x8bpp

      0,                   // 'Contiguous' Int 10 mode number (for high-colour)
      0,                   // 'Noncontiguous' Int 10 mode number
      320,                 // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          320,                            // X Resolution, in pixels
          200,                            // Y Resolution, in pixels
          320,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                      // 640x400x8bpp

      0,                       
      0,                       
      640,                     
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0, 
          640,                            
          400,                            
          640,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                   // 320x200x16bpp

      0,
      0,
      640,
        {
            sizeof(VIDEO_MODE_INFORMATION),
            0,
            320,
            200,
            640,
            1,
            16,
            1,
            320,
            240,
            8,
            8,
            8,
            0x0000f800,           // BGR 5:6:5
            0x000007e0,
            0x0000001f,
            VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {            // 640x400x16bpp
      0,
      0,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },
         

    {                           // 320x240x8bpp

      0x0201,           
      0x0201,           
      320,              
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0,                              
          320,                            
          240,                            
          320,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                           // 512x384x8bpp

      0x0201,           
      0x0201,           
      512,              
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0,                              
          512,                            
          384,                            
          512,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                           // 640x480x8bpp

      0x0201,           
      0x0201,           
      640,              
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0,                              
          640,                            
          480,                            
          640,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                           // 800x600x8bpp
      0x0103,
      0x0203,
      800,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          800,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1024x768x8bpp
      0x0205,
      0x0205,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          1024,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1152x870x8bpp
      0x0207,
      0x0207,
      1152,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          1152,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1280x1024x8bpp
      0x0107,
      0x0107,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1600x1200x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 320x240x16bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 512x384x16bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x16bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x16bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x16bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          2304,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 320x240x15bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 512x384x15bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x15bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x15bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x15bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          2304,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x12bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x12bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x12bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x12bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          4608,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x12bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x12bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 320x240x32bpp
      0x0112,
      0x0220,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          1280,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 512x384x32bpp
      0x0112,
      0x0220,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          2048,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x32bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x32bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x32bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          4608,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                                     // 640x480x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      1920,                               // 'Contiguous' screen stride (640 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          1920,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 800x600x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      2400,                               // 'Contiguous' screen stride (800 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          800,                            // X Resolution, in pixels
          600,                            // Y Resolution, in pixels
          2400,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1024x768x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3072,                               // 'Contiguous' screen stride (1024 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1024,                            // X Resolution, in pixels
          768,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1152x870x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3456,                               // 'Contiguous' screen stride (1152 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1152,                           // X Resolution, in pixels
          870,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1280x1024x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3840,                               // 'Contiguous' screen stride (1280 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          3840,                           // X Resolution, in pixels
          1280,                            // Y Resolution, in pixels
          1024,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1600x1200x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      4800,                               // 'Contiguous' screen stride (1600 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1600,                           // X Resolution, in pixels
          1280,                            // Y Resolution, in pixels
          4800,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },
};


ULONG NumP2VideoModes = sizeof(P2Modes) / sizeof(P2Modes[0]);


/*****************************************************************************
 * Reference Permedia2 hard-wired mode-sets.
 *
 * The order they appear here is the order they appear in the Display Applet.
 *
 ****************************************************************************/

//
// We can replace the hard coded list of frequencies with a hard-coded list 
// of pixel depths, which is a lot easier to maintain, and takes less memory.
// What we then do is for each 'TIMINGS' registry entry and for each timing 
// entry we create 'P2DepthCnt' frequency table entries, one for each pixel 
// depth. Once we have done that then we validate the entries in the frequency 
// list with the 'P2VideoModes' array.
//

ULONG P2DepthList [] = { 8, 16, 24, 32 };

#define P2DepthCnt (sizeof(P2DepthList) / sizeof(P2DepthList[0]))

//
//  VESA_LIST []
//  ------------
//
//      This is an array of structures containing the VESA definition 
//      for a width, height, frequency combination.
// 
//

typedef struct          // Extended VESA TIMING structure
{
    ULONG Width;
    ULONG Height;
    ULONG Frequency;
    VESA_TIMING_STANDARD VESAInfo;
} VESA_TIMING_STANDARD_EXT;

VESA_TIMING_STANDARD_EXT VESA_LIST [] =
{
    //
    // I have commented out the VESA-compliant 640x480@60 and replaced it 
    // with a VGA-compliant one. This is because some monitors won't SYNC 
    // with the values that we have.
    //

    //640,480,60,   {0x064,0x02,0x08,0x0a,0x00,0x1f1,0x01,0x03,0x0d,0x00 },
    640,480,60,     {0x064,0x02,0x0c,0x06,0x00,0x20d,0x0a,0x02,0x21,0x00 },
    640,480,75,     {0x066,0x03,0x08,0x0b,0x00,0x1f6,0x01,0x03,0x12,0x00 },
    640,480,85,     {0x068,0x04,0x08,0x0c,0x00,0x1f9,0x01,0x03,0x15,0x00 },
    640,480,100,    {0x06a,0x05,0x08,0x0d,0x00,0x1fd,0x01,0x03,0x19,0x00 },

    800,600,60,     {0x084,0x05,0x10,0x0b,0x01,0x274,0x01,0x04,0x17,0x01 },
    800,600,75,     {0x084,0x02,0x0a,0x14,0x01,0x271,0x01,0x03,0x15,0x01 },
    800,600,85,     {0x083,0x04,0x08,0x13,0x01,0x277,0x01,0x03,0x1b,0x01 },
    800,600,100,    {0x086,0x06,0x0b,0x11,0x01,0x27c,0x01,0x03,0x20,0x01 },

    1024,768,60,    {0x0a8,0x03,0x11,0x14,0x01,0x326,0x04,0x06,0x1c,0x01 },
    1024,768,75,    {0x0a4,0x02,0x0c,0x16,0x01,0x320,0x01,0x03,0x1c,0x01 },
    1024,768,85,    {0x0ac,0x06,0x0c,0x1a,0x01,0x328,0x01,0x03,0x24,0x01 },
    1024,768,100,   {0x0ae,0x09,0x0e,0x17,0x01,0x32e,0x01,0x03,0x2a,0x01 },

    1152,870,60,    {0x0c8,0x08,0x10,0x20,0x01,0x38a,0x01,0x03,0x20,0x01 },
    1152,870,75,    {0x0c2,0x09,0x10,0x19,0x01,0x38c,0x01,0x03,0x22,0x01 },
    1152,870,85,    {0x0c5,0x08,0x10,0x1d,0x01,0x391,0x01,0x03,0x27,0x01 },
    1152,870,100,   {0x0c4,0x0a,0x10,0x1a,0x01,0x39a,0x01,0x03,0x30,0x01 },

    1280,1024,60,   {0x0d3,0x06,0x0e,0x1f,0x01,0x42a,0x01,0x03,0x26,0x01 },
    1280,1024,75,   {0x0d3,0x02,0x12,0x1f,0x01,0x42a,0x01,0x03,0x26,0x01 },
    1280,1024,85,   {0x0d8,0x06,0x14,0x1e,0x01,0x430,0x01,0x03,0x2c,0x01 },
    1280,1024,100,  {0x0dc,0x0c,0x12,0x1e,0x01,0x43d,0x01,0x03,0x39,0x01 },

    1600,1200,60,   {0x10e,0x08,0x18,0x26,0x01,0x4e2,0x01,0x03,0x2e,0x01 },
    1600,1200,75,   {0x10e,0x08,0x18,0x26,0x01,0x4e2,0x01,0x03,0x2e,0x01 },
    1600,1200,85,   {0x10e,0x08,0x18,0x26,0x01,0x4e2,0x01,0x03,0x2e,0x01 },
    1600,1200,100,  {0x114,0x10,0x16,0x26,0x01,0x4f7,0x01,0x03,0x43,0x01 },

    //320,240,60,   {0x032,0x01,0x04,0x05,0x00,0x0f9,0x01,0x03,0x05,0x00 },
    320,240,75,     {0x033,0x02,0x04,0x05,0x00,0x0fb,0x01,0x03,0x07,0x00 },
    320,240,85,     {0x034,0x02,0x04,0x06,0x00,0x0fd,0x01,0x03,0x09,0x00 },
    320,240,100,    {0x034,0x02,0x04,0x06,0x00,0x0ff,0x01,0x03,0x0b,0x00 },

    //
    // TMM: 512x384@60Hz seems to work OK, but some older monitors refuse to
    // SYNC, so I have commented it out.
    //
    //512,384,60,   {0x04c,0x00,0x06,0x06,0x00,0x18e,0x01,0x03,0x0a,0x00 },
    512,384,75,     {0x050,0x02,0x06,0x08,0x00,0x192,0x01,0x03,0x0e,0x00 },
    512,384,85,     {0x052,0x02,0x07,0x09,0x00,0x194,0x01,0x03,0x10,0x00 },
    512,384,100,    {0x052,0x02,0x07,0x09,0x00,0x197,0x01,0x03,0x13,0x00 },

    //320,200,60,     {0x02a,0x00,0x03,0x01,0x00,0x0d0,0x01,0x03,0x04,0x00 },
    320,200,75,     {0x02c,0x00,0x04,0x02,0x00,0x0d2,0x01,0x03,0x06,0x00 },
    320,200,85,     {0x02e,0x00,0x04,0x03,0x00,0x0d3,0x01,0x03,0x07,0x00 },
    320,200,100,    {0x030,0x00,0x04,0x04,0x00,0x0d5,0x01,0x03,0x09,0x00 },

    //640,400,60,     {0x062,0x01,0x08,0x09,0x00,0x19f,0x01,0x03,0x0b,0x01 },
    640,400,75,     {0x064,0x02,0x08,0x0a,0x00,0x1a2,0x01,0x03,0x0e,0x01 },
    640,400,85,     {0x066,0x03,0x08,0x0b,0x00,0x1a5,0x01,0x03,0x11,0x01 },
    640,400,100,    {0x068,0x04,0x08,0x0c,0x00,0x1a8,0x01,0x03,0x14,0x01 }

};

#define VESA_CNT (sizeof(VESA_LIST) / sizeof(VESA_LIST [0]))

VESA_TIMING_STANDARD_EXT VESA_LIST_P2S [] =
{
    1280,1024,85,   {0x0c6,0x04,0x0b,0x17,0x01,0x41e,0x01,0x03,0x1a,0x01 },
    1600,1200,60,   {0x106,0x0a,0x15,0x1f,0x01,0x4d4,0x01,0x03,0x20,0x01 }
};

#define VESA_CNT_P2S (sizeof(VESA_LIST_P2S) / sizeof(VESA_LIST_P2S [0]))

P2_VIDEO_FREQUENCIES freqList[VESA_CNT * P2DepthCnt + 1];

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif


/*
 * THE CODE
 * ========
 */

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetVideoTiming)
#pragma alloc_text(PAGE,BuildFrequencyList)
#endif


BOOLEAN 
GetVideoTiming (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD * VESATimings
    )

/*++

 Routine Description:

     Given a width, height and frequency this function will return a 
     VESA timing information.

     The information is extracted from the timing definitions in the 
     registry, if there aren't any in the registry then it looks up
     the values in the VESA_LIST.

--*/
{
    ULONG i, j, hackCnt;
    BOOLEAN  retVal;
    VESA_TIMING_STANDARD_EXT * hackList = NULL;

    DEBUG_PRINT((2, "GetVideoTiming: xres %d, yres %d, freq %d, Depth\n",
                            xRes, yRes, Freq, Depth));

    //
    // Allow us to put hacks in for chips that can't support the proper 
    // VESA values
    //

    if ((DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId) == PERMEDIA_P2S_ID ||
        (DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId) == PERMEDIA_P2_ID && 
        hwDeviceExtension->deviceInfo.RevisionId == PERMEDIA2A_REV_ID)) &&
        Depth > 16)
    {

        //
        // P2S & P2A can't handle VESA versions of 1600x1200 & 1280x1024, 32BPP
        //

        hackList = VESA_LIST_P2S;
        hackCnt  = VESA_CNT_P2S;
    }

    retVal = FALSE;     // Nothing found yet

    //
    // If we have a hack list then search through it
    //

    if (hackList != NULL)
    {
        for (i = 0; !retVal && i < hackCnt; i++)
        {
            //
            // Comparewidth, height and frequency
            //

            if (hackList [i].Width == xRes  &&
                hackList [i].Height == yRes &&
                hackList [i].Frequency == Freq )
            {
                //
                // We got a match
                //

                *VESATimings = hackList [i].VESAInfo;

                retVal = TRUE;

                DEBUG_PRINT((2, "Found value in hack list\n")) ;
            }
        }
    }

    //
    // Loop through the table looking for a match
    //

    for (i = 0; !retVal && i < VESA_CNT; i++)
    {
        //
        // Comparewidth, height and frequency
        //

        if (VESA_LIST [i].Width == xRes  &&
            VESA_LIST [i].Height == yRes &&
            VESA_LIST [i].Frequency == Freq )
        {
            //
            // We got a match
            //

            *VESATimings = VESA_LIST [i].VESAInfo;

            retVal = TRUE;
        }
    }

    return (retVal);
}


LONG
BuildFrequencyList ( 
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:

     This function creates a table of P2_VIDEO_FREQENCIES entries
     pointedat by hwDeviceExtension->FrequencyTable. 

     The list is created by examining the 'TIMING\xxx,yyy,zzz' registry
     entries, if there aren't any entries then the hard-coded VESA_LIST 
     is used.

--*/
{
    ULONG i, j, k;

    hwDeviceExtension->FrequencyTable = freqList;

    //
    // loop through the list of VESA resolutions
    //

    for (i = 0, k = 0; i < VESA_CNT; i++)
    {
        //
        // For every supported pixel depth, create a frequency entry 
        //

        for (j = 0; j < P2DepthCnt; j++, k++)
        {
            freqList [k].BitsPerPel      = P2DepthList [j];
            freqList [k].ScreenWidth     = VESA_LIST [i].Width;
            freqList [k].ScreenHeight    = VESA_LIST [i].Height;
            freqList [k].ScreenFrequency = VESA_LIST [i].Frequency;
            freqList [k].PixelClock      = 
                                ( (VESA_LIST[i].VESAInfo.HTot * 
                                   VESA_LIST [i].VESAInfo.VTot * 8) / 100 ) * 
                                   VESA_LIST [i].Frequency;
       }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\permedia.c ===
//***************************************************************************
//
// Module Name:
//
//   permedia.c
//
// Abstract:
//
//   This module contains the code that implements the Permedia2 miniport driver
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#include "string.h"

#define USE_SINGLE_CYCLE_BLOCK_WRITES 0

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,Permedia2FindAdapter)
#pragma alloc_text(PAGE,Permedia2RegistryCallback)
#pragma alloc_text(PAGE,Permedia2RetrieveGammaCallback)
#pragma alloc_text(PAGE,InitializeAndSizeRAM)
#pragma alloc_text(PAGE,ConstructValidModesList)
#pragma alloc_text(PAGE,Permedia2Initialize)
#pragma alloc_text(PAGE,Permedia2StartIO)
#pragma alloc_text(PAGE,Permedia2SetColorLookup)
#pragma alloc_text(PAGE,Permedia2GetClockSpeeds)
#pragma alloc_text(PAGE,ZeroMemAndDac)
#endif

//
//  NtVersion:  NT4   - This driver is working on NT4
//              WIN2K - This driver is working on Windows 2000
//

short NtVersion;

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is the initial entry point to the video miniport driver.

    This routine is called by the I/O subsystem when the video miniport
    is loaded.  The miniport is responsible for initializing a
    VIDEO_HW_INITIALIZATION_DATA structure to register the driver functions
    called by the video port driver in response to requests from the display
    driver, plug and play manager, power management, or other driver
    components.

    The following tasks MUST be completed by the video miniport in the
    context of DriverEntry. Driver writers should consult the documentation
    for full details on the exact initialization process.

    1. Initialize VIDEO_HW_INITIALIZATION_DATA structure with all relevant
       data structures.

    2. Call VideoPortInitialize.

    3. Return appropriate status value to the caller of DriverEntry.

    Drivers can undertake other tasks as required and under the restrictions
    outlined in the documentation.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    VP_STATUS initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter             = Permedia2FindAdapter;
    hwInitData.HwInitialize              = Permedia2Initialize;
    hwInitData.HwStartIO                 = Permedia2StartIO;
    hwInitData.HwResetHw                 = Permedia2ResetHW;
    hwInitData.HwInterrupt               = Permedia2VidInterrupt;
    hwInitData.HwGetPowerState           = Permedia2GetPowerState;
    hwInitData.HwSetPowerState           = Permedia2SetPowerState;
    hwInitData.HwGetVideoChildDescriptor = Permedia2GetChildDescriptor;

    //
    // Declare the legacy resources
    //

    hwInitData.HwLegacyResourceList      = P2LegacyResourceList;
    hwInitData.HwLegacyResourceCount     = P2LegacyResourceEntries;

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // This device only supports the PCI bus.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    NtVersion = WIN2K;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if( initializationStatus != NO_ERROR) 
    {
        hwInitData.HwInitDataSize = SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA;
        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);
    }

    if( initializationStatus != NO_ERROR) 
    {
        NtVersion = NT4;
        hwInitData.HwInterrupt = NULL;

        hwInitData.HwInitDataSize = SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA;
        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);
    }

    DEBUG_PRINT((2, "PERM2: VideoPortInitialize returned status 0x%x\n", initializationStatus));

    return initializationStatus;

} // end DriverEntry()


VP_STATUS
Permedia2FindAdapter(
    PVOID HwDeviceExtension,
    PVOID pReserved,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

 
    This routine gets the access ranges for a device on an enumerable 
    bus and, if necessary, determines the device type

Arguments:

    HwDeviceExtension - 
        System supplied device extension supplied to the miniport for 
        a per-device storage area. 

    pReserved - 
        NULL on Windows 2000 and should be ignored by the miniport.

    ArgumentString - 
        Suuplies a NULL terminated ASCII string. This string originates 
        from the user. This pointer can be NULL. 

    ConfigInfo - 
        Points to a VIDEO_PORT_CONFIG_INFO structure allocated and initialized 
        by the port driver. This structure will contain as much information 
        as could be obtained by the port driver. This routine is responsible 
        for filling in any relevant missing information.

    Again - Is not used on Windows 2000. 
            We set this to FALSE on NT 4, since we only support one adapter on NT4. 

Return Value:

    This routine must return:

    NO_ERROR - 
        Indicates that the routine completed without error.

    ERROR_INVALID_PARAMETER - 
        Indicates that the adapter could not be properly configured or
        information was inconsistent. (NOTE: This does not mean that the
        adapter could not be initialized. Miniports must not attempt to
        initialize the adapter until HwVidInitialize.)

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{
    PHW_DEVICE_EXTENSION    hwDeviceExtension = HwDeviceExtension;
    P2_DECL_VARS;
    WCHAR                   StringBuffer[60];
    ULONG                   StringLength;
    VP_STATUS               vpStatus;
    ULONG                   UseSoftwareCursor;
    ULONG                   ulValue;
    ULONG                   i;
    VIDEO_ACCESS_RANGE      *pciAccessRange = hwDeviceExtension->PciAccessRange;
    PWSTR                   pwszChip, pwszDAC, pwszAdapterString;
    ULONG                   cbChip, cbDAC, cbAdapterString, cbBiosString;
    ULONG                   pointerCaps;
    USHORT                  usData;

    //
    // 3 (major number) + 1 (dot) + 3 (minor number) + 1 (L'\0') = 8 digtis
    // is enough for bios verions string           
    //

    WCHAR pwszBiosString[8];

    //
    // save current NT version obtained at DriverEntry
    //

    hwDeviceExtension->NtVersion = NtVersion;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if ( (NtVersion == WIN2K) && 
         (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) ) 
    {

        DEBUG_PRINT((1, "bad size for VIDEO_PORT_CONFIG_INFO\n"));

        return (ERROR_INVALID_PARAMETER);

    }
    else if ( (NtVersion == NT4) && 
         (ConfigInfo->Length < SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO) ) 
    {

        DEBUG_PRINT((1, "bad size for VIDEO_PORT_CONFIG_INFO\n"));

        return (ERROR_INVALID_PARAMETER);

    }

    //
    // we must be a PCI device
    //

    if (ConfigInfo->AdapterInterfaceType != PCIBus) 
    {
        DEBUG_PRINT((1,  "not a PCI device\n"));
        return (ERROR_DEV_NOT_EXIST);
    }

    //
    // Retrieve pointers of those new video port functions in Win2k.
    // If you don't want to support NT4, you don't need to do this. You
    // can just call these functions by their name.
    //

    if ( NtVersion == WIN2K )
    {

        if(!(hwDeviceExtension->Win2kVideoPortGetRomImage =  
               ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                    "VideoPortGetRomImage")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortGetCommonBuffer = 
             ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                 "VideoPortGetCommonBuffer")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortFreeCommonBuffer =
             ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                 "VideoPortFreeCommonBuffer")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortDDCMonitorHelper =
             ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                 "VideoPortDDCMonitorHelper")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortInterlockedExchange =
              ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                  "VideoPortInterlockedExchange")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortGetVgaStatus =
              ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                  "VideoPortGetVgaStatus")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

    }
    else
    {

        //
        //  We only support one adapter on NT 4
        //

        Again = FALSE;
    }

    //
    // will be initialized in CopyROMInitializationTable
    //

    hwDeviceExtension->culTableEntries = 0;

    //
    // will be initialized in ConstructValidModesList
    //

    hwDeviceExtension->pFrequencyDefault = NULL;

    //
    // We'll set this TRUE when in InitializeVideo after programming the VTG
    //

    hwDeviceExtension->bVTGRunning = FALSE;
    hwDeviceExtension->bMonitorPoweredOn = TRUE;
    hwDeviceExtension->ChipClockSpeed   = 0;
    hwDeviceExtension->RefClockSpeed    = 0;
    hwDeviceExtension->P28bppRGB        = 0;
    hwDeviceExtension->ExportNon3DModes = 0;
    hwDeviceExtension->PreviousPowerState = VideoPowerOn;

    //
    // pick up capabilities on the way.
    //

    hwDeviceExtension->Capabilities = CAPS_GLYPH_EXPAND;

    //
    // We'll use a software pointer in all modes if the user sets
    // the correct entry in the registry.
    //

    UseSoftwareCursor = 0;

    vpStatus = VideoPortGetRegistryParameters( HwDeviceExtension,
                                               L"UseSoftwareCursor",
                                               FALSE,
                                               Permedia2RegistryCallback,
                                               &UseSoftwareCursor);

    if ( ( vpStatus == NO_ERROR )  && UseSoftwareCursor)
    {
        hwDeviceExtension->Capabilities |= CAPS_SW_POINTER;
    }

    //
    // Query the PCI to see if any of our supported chip devices exist.
    //

    if ( NtVersion == WIN2K )
    {
        if (!Permedia2AssignResources( HwDeviceExtension,
                                       ConfigInfo,
                                       PCI_TYPE0_ADDRESSES + 1,
                                       pciAccessRange ))
        {
            DEBUG_PRINT((1,  "Permedia2AssignResources failed\n"));
            return (ERROR_DEV_NOT_EXIST);
        }

    }
    else
    {
        if (!Permedia2AssignResourcesNT4( HwDeviceExtension,
                                          ConfigInfo,
                                          PCI_TYPE0_ADDRESSES + 1,
                                          pciAccessRange ))
        {
            DEBUG_PRINT((1,  "Permedia2AssignResources failed\n"));
            return (ERROR_DEV_NOT_EXIST);
        }

    }

    //
    // construct the identifier string including the revision id
    //

    StringLength = sizeof(L"3Dlabs PERMEDIA2");

    VideoPortMoveMemory((PVOID)StringBuffer,
                        (PVOID)(L"3Dlabs PERMEDIA2"),
                        StringLength);

    pwszChip = (PWSTR)StringBuffer;
    cbChip   = StringLength;

    //
    // Set the defaults for the board type.
    //

    hwDeviceExtension->deviceInfo.BoardId = PERMEDIA2_BOARD;

    pwszAdapterString = L"Permedia 2";
    cbAdapterString = sizeof(L"Permedia 2");

    //
    // Get the mapped addresses for the control registers and the
    // framebuffer. Must use local variable pCtrlRegs so macro
    // declarations further down will work.
    //

    pCtrlRegs = VideoPortGetDeviceBase(
                     HwDeviceExtension,
                     pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart,
                     pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength,
                     pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace
                     );

    if (pCtrlRegs == NULL) 
    {
        DEBUG_PRINT((1, "CTRL DeviceBase mapping failed\n"));
        return ERROR_INVALID_PARAMETER;
    }

    hwDeviceExtension->ctrlRegBase = pCtrlRegs;

    //
    // Some boards have a ROM which we can use to identify them.
    //

    CopyROMInitializationTable(hwDeviceExtension);


    if(hwDeviceExtension->culTableEntries == 0)
    {
        //
        // No initialization table, but P2 really needs one in order to come
        // out of sleep mode correctly. Generate initialization table by
        // default values
        //

        GenerateInitializationTable(hwDeviceExtension);
    }


    //
    // Find out what type of RAMDAC we have. 
    //

    vpStatus = NO_ERROR;

    hwDeviceExtension->pRamdac = &(pCtrlRegs->ExternalVideo);

    //
    // some RAMDACs may not support a cursor so a software cursor is the default
    //

    pointerCaps = CAPS_SW_POINTER;

    //
    // Check for a TI TVP4020
    //

    if(DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId) == PERMEDIA_P2S_ID)
    {
        //
        // P2 with 3Dlabs RAMDAC, check for a rev 2 chip
        //

        i = VideoPortReadRegisterUlong(CHIP_CONFIG);
 
       if(i & 0x40000000)
        {
            DEBUG_PRINT((2, "PERM2: Permedia2 is rev 2\n"));
            hwDeviceExtension->deviceInfo.RevisionId = 2;
        }
        else
        {
            DEBUG_PRINT((2, "PERM2: Permedia2 is rev 1\n"));
        }

        hwDeviceExtension->DacId = P2RD_RAMDAC;
        pointerCaps = (ULONG)CAPS_P2RD_POINTER;

        hwDeviceExtension->deviceInfo.ActualDacId = P2RD_RAMDAC;

        pwszDAC = L"3Dlabs P2RD";
        cbDAC = sizeof(L"3Dlabs P2RD");

        DEBUG_PRINT((1, "PERM2: using P2RD RAMDAC\n"));
    }
    else
    {
        hwDeviceExtension->DacId = TVP4020_RAMDAC;
        pointerCaps = CAPS_TVP4020_POINTER;

        hwDeviceExtension->deviceInfo.ActualDacId = TVP4020_RAMDAC;

        if(hwDeviceExtension->deviceInfo.RevisionId == PERMEDIA2A_REV_ID)
        {
            pwszDAC = L"TI TVP4020A";
            cbDAC = sizeof(L"TI TVP4020A");
            DEBUG_PRINT((1, "PERM2: using TVP4020A RAMDAC\n"));
        }
        else
        {
            pwszDAC = L"TI TVP4020C";
            cbDAC = sizeof(L"TI TVP4020C");
            DEBUG_PRINT((1, "PERM2: using TVP4020C RAMDAC\n"));
        }
    }

    //
    // use the RAMDAC cursor capability only if the user didn't specify 
    // a software cursor
    //
   
    if (!(hwDeviceExtension->Capabilities & CAPS_SW_POINTER))
    {
        hwDeviceExtension->Capabilities |= pointerCaps;
    }

    if ( (hwDeviceExtension->pFramebuffer =
            VideoPortGetDeviceBase(
                           HwDeviceExtension,
                           pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                           pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                           pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace 
                           ) ) == NULL)
    {

        //
        // Some machines have limitations on how much PCI address space they
        // can map in so try again, reducing the amount we map till we succeed
        // or the size gets to zero in which case we really have failed.
        //

        ULONG sz;

        DEBUG_PRINT((1, "PERM2: FB DeviceBase mapping failed\n"));

        for ( sz = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength; 
              sz > 0; 
              sz -= 1024*1024 )
        {

            if ( (hwDeviceExtension->pFramebuffer =
                     VideoPortGetDeviceBase(
                               HwDeviceExtension,
                               pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                               sz,
                               pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace
                               ) ) != NULL)
            {

                //
                // store the modified size
                //

                pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = sz;

                break;

            }
        }

        //
        // if sz is zero, well we tried ...
        //

        if (sz == 0)
            return ERROR_INVALID_PARAMETER;
    }

    DEBUG_PRINT((1, "PERM2: FB mapped at 0x%x for length 0x%x (%s)\n",
                    hwDeviceExtension->pFramebuffer,
                    pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                    pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace ?
                        "I/O Ports" : "MemMapped"));


    //
    // Initialize the RAM registers and dynamically size the framebuffer 
    //

    if (!InitializeAndSizeRAM(hwDeviceExtension, pciAccessRange))
    {
        DEBUG_PRINT((0, "InitializeAndSizeRAM failed\n"));
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Record the size of the video memory.
    //

    hwDeviceExtension->AdapterMemorySize = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    hwDeviceExtension->PhysicalFrameIoSpace = 0;

#if defined(_ALPHA_)

    //
    // We want to use a dense space mapping of the frame buffer
    // whenever we can on the Alpha.
    //

    hwDeviceExtension->PhysicalFrameIoSpace = 4;

    //
    // The new DeskStation Alpha machines don't always support
    // dense space.  Therefore, we should try to map the memory
    // at this point as a test.  If the mapping succeeds then
    // we can use dense space, otherwise we'll use sparse space.
    //

    {
        PULONG MappedSpace=0;
        VP_STATUS status;

        DEBUG_PRINT((1, "PERM2: Checking to see if we can use dense space...\n"));

        //
        // We want to try to map the dense memory where it will ultimately
        // be mapped anyway.
        //

        MappedSpace = (PULONG)VideoPortGetDeviceBase (
                              hwDeviceExtension,
                              pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                              pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                              (UCHAR) hwDeviceExtension->PhysicalFrameIoSpace
                              );

        if (MappedSpace == NULL)
        {
            //
            // Well, looks like we can't use dense space to map the
            // range.  Lets use sparse space, and let the display
            // driver know.
            //

            DEBUG_PRINT((1, "PERM2: Can't use dense space!\n"));

            hwDeviceExtension->PhysicalFrameIoSpace = 0;

            hwDeviceExtension->Capabilities |= CAPS_SPARSE_SPACE;
        }
        else
        {
            //
            // The mapping worked.  However, we were only mapping to
            // see if dense space was supported.  Free the memory.
            //

            DEBUG_PRINT((1, "PERM2: We can use dense space.\n"));

            VideoPortFreeDeviceBase(hwDeviceExtension,
                                    MappedSpace);
        }
    }

#endif  //  defined(_ALPHA_)

    //
    // We now have a complete hardware description of the hardware.
    // Save the information to the registry so it can be used by
    // configuration programs - such as the display applet.
    //

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    cbBiosString = GetBiosVersion(HwDeviceExtension, (PWSTR) pwszBiosString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.BiosString",
                                   pwszBiosString,
                                   cbBiosString);

    ConstructValidModesList(HwDeviceExtension, hwDeviceExtension);

    if (hwDeviceExtension->NumAvailableModes == 0)
    {
        DEBUG_PRINT((1, "No video modes available\n"));
    
        return(ERROR_DEV_NOT_EXIST);
    }

    //
    // Frame buffer information
    //

    hwDeviceExtension->PhysicalFrameAddress = 
            pciAccessRange[PCI_FB_BASE_INDEX].RangeStart;

    hwDeviceExtension->FrameLength = 
            pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    //
    // Control Register information
    // Get the base address, starting at zero and map all registers
    //

    hwDeviceExtension->PhysicalRegisterAddress = 
            pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart;

    hwDeviceExtension->RegisterLength = 
            pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength;

    hwDeviceExtension->RegisterSpace =  
            pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;


    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //
    // in a multi-adapter system we'll need to disable VGA for the 
    // secondary adapters
    //

    if(!hwDeviceExtension->bVGAEnabled)
    {
        DEBUG_PRINT((1, "PERM2: disabling VGA for the secondary card\n"));

        // 
        // Enable graphics mode, disable VGA
        // 

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, 
                                    PERMEDIA_VGA_CTRL_INDEX);

        usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);
        usData &= ~PERMEDIA_VGA_ENABLE;
 
        usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
        VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

        #define INTERNAL_VGA_ENABLE  (1 << 1)
        #define VGA_FIXED_ADD_DECODE (1 << 2)

        ulValue = VideoPortReadRegisterUlong(CHIP_CONFIG);
        ulValue &= ~INTERNAL_VGA_ENABLE;
        ulValue &= ~VGA_FIXED_ADD_DECODE;
        VideoPortWriteRegisterUlong(CHIP_CONFIG, ulValue);

    }

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // end Permedia2FindAdapter()

VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

 Routine Description:

    Here we prune valid modes, based on rules according to the chip
    capabilities and memory requirements.
    
    We prune modes so that we will not annoy the user by presenting
    modes in the 'Video Applet' which we know the user can't use.
    
    Look up the registry to see if we want to export modes which can only
    be used as single buffered by 3D applications. If we only want double
    buffered modes then, effectively, we have only half the memory in 
    which to display the standard 2D resolution. This is only not true at 12bpp
    where we can double buffer at any resolution.
    
--*/
{
    PP2_VIDEO_FREQUENCIES FrequencyEntry;
    PP2_VIDEO_MODES       ModeEntry;
    LONG    AdapterMemorySize;
    ULONG   ModeIndex;
    ULONG   i;

    hwDeviceExtension->NumAvailableModes = 0;

    //
    // Since there are a number of frequencies possible for each
    // distinct resolution/colour depth, we cycle through the
    // frequency table and find the appropriate mode entry for that
    // frequency entry.
    //

    if (!BuildFrequencyList(hwDeviceExtension))
        return;

    for (FrequencyEntry = hwDeviceExtension->FrequencyTable, ModeIndex = 0;
         FrequencyEntry->BitsPerPel != 0;
         FrequencyEntry++, ModeIndex++) 
    {

        //
        // Find the mode for this entry.  First, assume we won't find one.
        //

        FrequencyEntry->ModeValid = FALSE;
        FrequencyEntry->ModeIndex = ModeIndex;

        for (ModeEntry = P2Modes, i = 0; i < NumP2VideoModes; ModeEntry++, i++)
        {

            if ((FrequencyEntry->BitsPerPel ==
                    ModeEntry->ModeInformation.BitsPerPlane) &&
                (FrequencyEntry->ScreenWidth ==
                    ModeEntry->ModeInformation.VisScreenWidth) &&
                (FrequencyEntry->ScreenHeight ==
                    ModeEntry->ModeInformation.VisScreenHeight))
            {
                AdapterMemorySize = (LONG)hwDeviceExtension->AdapterMemorySize;

                //
                // We've found a mode table entry that matches this frequency
                // table entry.  Now we'll figure out if we can actually do
                // this mode/frequency combination.  For now, assume we'll
                // succeed.
                //

                FrequencyEntry->ModeEntry = ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                ModeEntry->ModeInformation.ScreenStride = 
                        ModeEntry->ScreenStrideContiguous;

                //
                // Rule: use true color at 8bpp if we've enabled that
                // capability above.
                //

                if ((FrequencyEntry->BitsPerPel == 8) &&
                        (hwDeviceExtension->Capabilities & CAPS_8BPP_RGB))
                {
                    ModeEntry->ModeInformation.AttributeFlags &=
                         ~(VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE);

                    //
                    // NB. These must match the way the palette is loaded in
                    // InitializeVideo.
                    //

                    ModeEntry->ModeInformation.RedMask   = 0x07;
                    ModeEntry->ModeInformation.GreenMask = 0x38;
                    ModeEntry->ModeInformation.BlueMask  = 0xc0;
                }

                //
                // Rule: We have to have enough memory to handle the mode.
                //

                if ((LONG)(ModeEntry->ModeInformation.VisScreenHeight *
                           ModeEntry->ModeInformation.ScreenStride) >
                                   AdapterMemorySize)
                {
                    FrequencyEntry->ModeValid = FALSE;
                }

                { 
                    ULONG pixelData;
                    ULONG DacDepth = FrequencyEntry->BitsPerPel;

                    //
                    // We need the proper pixel size to calculate timing values
                    //

                    if (DacDepth == 15)
                    {
                        DacDepth = 16;
                    }
                    else if (DacDepth == 12)
                    {
                        DacDepth = 32;
                    }

                    pixelData = FrequencyEntry->PixelClock * (DacDepth / 8);

                    if (((FrequencyEntry->PixelClock > P2_MAX_PIXELCLOCK ||
                          pixelData > P2_MAX_PIXELDATA)))
                    {
                        FrequencyEntry->ModeValid = FALSE;
                    }
    
                    //
                    // Don't supports 24bpp
                    //

                    if(FrequencyEntry->BitsPerPel == 24)
                    {
                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Don't forget to count it if it's still a valid mode after
                // applying all those rules.
                //

                if (FrequencyEntry->ModeValid)
                {
                    if(hwDeviceExtension->pFrequencyDefault == NULL &&
                       ModeEntry->ModeInformation.BitsPerPlane == 8 &&
                       ModeEntry->ModeInformation.VisScreenWidth == 640 &&
                       ModeEntry->ModeInformation.VisScreenHeight == 480)
                    {
                        hwDeviceExtension->pFrequencyDefault = FrequencyEntry;
                    }

                    hwDeviceExtension->NumAvailableModes++;
                }

                //
                // We've found a mode for this frequency entry, so we
                // can break out of the mode loop:
                //

                break;

            }
        }
    }

    hwDeviceExtension->NumTotalModes = ModeIndex;

    DEBUG_PRINT((2, "PERM2: %d total modes\n", ModeIndex));
    DEBUG_PRINT((2, "PERM2: %d total valid modes\n", hwDeviceExtension->NumAvailableModes));
}


VP_STATUS
Permedia2RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine is used to read back various registry values.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine. If
    this is not null assume it's a ULONG* and save the data value in it.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    if the variable doesn't exist return an error,
    else if a context is supplied assume it's a PULONG and fill in the value
    and return no error, else if the value is non-zero return an error.

--*/

{

    if (ValueLength) 
    {
        if (Context) 
        {                  
            *(ULONG *)Context = *(PULONG)ValueData;
        }
        else if (*((PULONG)ValueData) != 0)
        {                  
            return ERROR_INVALID_PARAMETER;
        }

        return NO_ERROR;

    } else 
    {
        return ERROR_INVALID_PARAMETER;
    }

} // end Permedia2RegistryCallback()


VP_STATUS
Permedia2RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine is used to read back the gamma LUT from the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    if the variable doesn't exist return an error, else copy the gamma lut 
    into the supplied pointer

--*/

{

    if (ValueLength != MAX_CLUT_SIZE)
    {

        DEBUG_PRINT((1, "Permedia2RetrieveGammaCallback got ValueLength of %d\n", ValueLength));

        return ERROR_INVALID_PARAMETER;

    }

    VideoPortMoveMemory(Context, ValueData, MAX_CLUT_SIZE);

    return NO_ERROR;

} // end Permedia2RetrieveGammaCallback()


BOOLEAN
InitializeAndSizeRAM(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_ACCESS_RANGE pciAccessRange
    )

/*++

Routine Description:

    Initialize extra control registers and dynamically size the
    video RAM for the Permedia.

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.
    pciAccessRange    - access range of mapped resources

Return Value:

    FALSE if we find no RAM, TRUE otherwise

--*/

{
    PVOID   HwDeviceExtension = (PVOID)hwDeviceExtension;
    ULONG   fbMappedSize;
    ULONG   i, j;
    P2_DECL;

    PULONG  pV, pVStart, pVEnd;
    ULONG   testPattern;
    ULONG   probeSize;
    ULONG   save0, save1;
    ULONG   temp;
    ULONG   saveVidCtl;		
    USHORT  saveVGA, usData;


    if(hwDeviceExtension->culTableEntries)
    {
        //
        // When vga is enabled, these registers should be set by bios at
        // boot time. But we saw cases when bios failed to do this. We'll
        // set these register when vga is off or when we see values are
        // wrong
        //

        if(!hwDeviceExtension->bVGAEnabled || 
           !VerifyBiosSettings(hwDeviceExtension))
        {
            //
            // save video control and vga register
            //

            saveVidCtl = VideoPortReadRegisterUlong(VIDEO_CONTROL);

            VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, 
                                         PERMEDIA_VGA_CTRL_INDEX );

            saveVGA = (USHORT)VideoPortReadRegisterUchar(
                                        PERMEDIA_MMVGA_DATA_REG );

            //
            // Disable Video and VGA
            //

            VideoPortWriteRegisterUlong(VIDEO_CONTROL, 0);	

            usData = saveVGA & (USHORT)(~PERMEDIA_VGA_ENABLE);
            usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
            VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);
 
            ProcessInitializationTable(hwDeviceExtension);

            #if USE_SINGLE_CYCLE_BLOCK_WRITES
            {

                i = VideoPortReadRegisterUlong(MEM_CONFIG);

                VideoPortWriteRegisterUlong(MEM_CONFIG, i | (1 << 21)); // single cycle block writes

            }
            #endif //USE_SINGLE_CYCLE_BLOCK_WRITES

            //
            // Restore VGA and video control
            //

            saveVGA = (saveVGA << 8) | PERMEDIA_VGA_CTRL_INDEX;
            VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, saveVGA);

            VideoPortWriteRegisterUlong(VIDEO_CONTROL, saveVidCtl);

        }
    }


    VideoPortWriteRegisterUlong(APERTURE_ONE, 0x0);
    VideoPortWriteRegisterUlong(APERTURE_TWO, 0x0);  

    VideoPortWriteRegisterUlong(BYPASS_WRITE_MASK, 0xFFFFFFFF);

    if (pciAccessRange == NULL)
    {
        return TRUE;
    }

    fbMappedSize = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    i = VideoPortReadRegisterUlong(MEM_CONFIG);

    //
    // MEM_CONFIG doesn't have the number of memory banks defined 
    // at boot-time for P2: set up the board for 8MB. Can't do this 
    // if the VGA is running, but that's OK. The VGA has set this 
    // register to what we want.
    //

    if (!hwDeviceExtension->bVGAEnabled)
    {
        i |= (3 << 29);

        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = 
                  (((i >> 29) & 0x3) + 1) * (2*1024*1024);

        VideoPortWriteRegisterUlong(MEM_CONFIG, i);
    }

    testPattern = 0x55aa33cc;
    probeSize = (128 * 1024 / sizeof(ULONG));   // In DWords

    //
    // Dynamically size the SGRAM. Sample every 128K. If you happen to
    // have some VERY odd SGRAM size you may need cut this down. After
    // each write to the probe address, write to SGRAM address zero to 
    // clear the PCI data bus. Otherwise, if we read from fresh air the
    // written value may be floating on the bus and the read give it back 
    // to us.
    //
    // Note, if the memory wraps around at the end, then a different 
    // algorithm must be used (which waits for address zero to become 
    // equal to the address being written).
    //
    // Any valid pixel that we probe, we save and restore. This is to
    // avoid dots on the screen if we have booted onto the Permedia2 board.
    //

    pVStart = (PULONG)hwDeviceExtension->pFramebuffer;
    pVEnd   = (PULONG)((ULONG_PTR)pVStart + fbMappedSize);

    //
    // check out address zero
    //

    save0 = VideoPortReadRegisterUlong(pVStart);
    save1 = VideoPortReadRegisterUlong(pVStart+1);

    VideoPortWriteRegisterUlong(pVStart, testPattern);
    VideoPortWriteRegisterUlong(pVStart+1, 0);

    if ((temp = VideoPortReadRegisterUlong(pVStart)) != testPattern)
    {
        DEBUG_PRINT((1, "cannot access SGRAM. Expected 0x%x, got 0x%x\n", 
                                                      testPattern, temp));
        return FALSE;
    }
 
    VideoPortWriteRegisterUlong(pVStart+1, save1);

    for (pV = pVStart + probeSize; pV < pVEnd; pV += probeSize)
    {
        save1 = VideoPortReadRegisterUlong(pV);
        VideoPortWriteRegisterUlong(pV, testPattern);
        VideoPortWriteRegisterUlong(pVStart, 0);

        if ((temp = VideoPortReadRegisterUlong(pV)) != testPattern)
        {

            DEBUG_PRINT((1, "PERM2: FB probe failed at offset 0x%x\n", 
                    (LONG)((LONG_PTR)pV - (LONG_PTR)pVStart)));

            DEBUG_PRINT((1, "PERM2: \tread back 0x%x, wanted 0x%x\n", 
                    temp, testPattern));
            break;
        }

        VideoPortWriteRegisterUlong(pV, save1);

    }

    VideoPortWriteRegisterUlong(pVStart, save0);

    if (pV < pVEnd)
    {
        //
        // I could also set MEM_CONFIG to the correct value here as we 
        // now know the size of SGRAM, but as it's never used again
        // I won't bother
        //

        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = 
                       (ULONG)((ULONG_PTR)pV - (ULONG_PTR)pVStart);

        DEBUG_PRINT((1, "PERM2: SGRAM dynamically resized to length 0x%x\n",
                        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));

    }

    if (pciAccessRange[PCI_FB_BASE_INDEX].RangeLength > fbMappedSize)
    {
        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = fbMappedSize;
    }

    DEBUG_PRINT((2, "PERM2: got a size of 0x%x bytes\n", 
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));

    //
    // finally, if the SGRAM size is actually smaller than the region that
    // we probed, remap to the smaller size to save on page table entries.
    // Not doing this causes some systems to run out of PTEs.
    //

    if (fbMappedSize > pciAccessRange[PCI_FB_BASE_INDEX].RangeLength)
    {
        VideoPortFreeDeviceBase(HwDeviceExtension, 
                                hwDeviceExtension->pFramebuffer);

        if ( (hwDeviceExtension->pFramebuffer =
                VideoPortGetDeviceBase(HwDeviceExtension,
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace)) == NULL)
        {

            //
            // this shouldn't happen but we'd better check
            //

            DEBUG_PRINT((0, "Remap of framebuffer to smaller size failed!!!\n"));
            return FALSE;

        }

        DEBUG_PRINT((1, "PERM2: Remapped framebuffer memory to 0x%x, size 0x%x\n",
                         hwDeviceExtension->pFramebuffer,
                         pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));
    }

    //
    // PERMEDIA2 has no localbuffer
    //

    hwDeviceExtension->deviceInfo.LocalbufferWidth = 0;
    hwDeviceExtension->deviceInfo.LocalbufferLength = 0;

    return TRUE;

}

BOOLEAN
Permedia2Initialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    Returns TRUE when success.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ulValue;
    P2_DECL;

    //
    // always initialize the IRQ control block...
    // the memory is used to store information which is global to all 
    // driver instances of a display card by the display driver
    //

    if ( hwDeviceExtension->NtVersion == WIN2K)
    {
        if (!Permedia2InitializeInterruptBlock(hwDeviceExtension))
        {

            DEBUG_PRINT((0, "PERM2: failed to initialize the IRQ control block\n"));
            return FALSE;

        }
    }

    //
    // Clear the framebuffer.
    //

    VideoPortZeroDeviceMemory(hwDeviceExtension->pFramebuffer,
                              hwDeviceExtension->AdapterMemorySize);

    return TRUE;

} // end Permedia2Initialize()


BOOLEAN
Permedia2StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    P2_DECL;
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEOPARAMETERS pVideoParams;
    PVIDEO_CLUT clutBuffer;
    ULONG inIoSpace;
    ULONG RequestedMode;
    ULONG modeNumber;
    ULONG ulValue;
    HANDLE ProcessHandle;
    PP2_VIDEO_MODES ModeEntry;
    P2_VIDEO_FREQUENCIES FrequencyEntry, *pFrequencyEntry;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) 
    {

        case IOCTL_VIDEO_QUERY_REGISTRY_DWORD:
        {
            DEBUG_PRINT((2, "PERM2: got IOCTL_VIDEO_QUERY_REGISTRY_DWORD\n"));

            if (RequestPacket->OutputBufferLength <
               (RequestPacket->StatusBlock->Information = sizeof(ULONG)))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            if (VideoPortGetRegistryParameters( HwDeviceExtension,
                                                RequestPacket->InputBuffer,
                                                FALSE,
                                                Permedia2RegistryCallback,
                                                &ulValue) != NO_ERROR )
            {
                DEBUG_PRINT((1, "PERM2: IOCTL_VIDEO_QUERY_REGISTRY_DWORD failed\n"));
    
                status = ERROR_INVALID_PARAMETER;
                break;
            }

            *(PULONG)(RequestPacket->OutputBuffer) = ulValue;

            status = NO_ERROR;
            break;
        }

        case IOCTL_VIDEO_REG_SAVE_GAMMA_LUT:
        {
            DEBUG_PRINT((2, "PERM2: got IOCTL_VIDEO_REG_SAVE_GAMMA_LUT\n"));
    
            if (RequestPacket->InputBufferLength <
               (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE))
            {
  
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
  
            }
  
            status = VideoPortSetRegistryParameters( HwDeviceExtension,
                                                     L"DisplayGammaLUT",
                                                     RequestPacket->InputBuffer,
                                                     MAX_CLUT_SIZE);
            break;
        }
  
        case IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT:
        {
            DEBUG_PRINT((2, "PERM2: got IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT\n"));
  
            if (RequestPacket->OutputBufferLength <
               (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            status = VideoPortGetRegistryParameters( HwDeviceExtension,
                                                     L"DisplayGammaLUT",
                                                     FALSE,
                                                     Permedia2RetrieveGammaCallback,
                                                     RequestPacket->InputBuffer);
            break;
        }
  
        case IOCTL_VIDEO_QUERY_DEVICE_INFO:
  
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QUERY_deviceInfo\n"));
  
            if ( RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(P2_Device_Info))) 
                           
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            //
            // Copy our local PCI info to the output buffer
            //
  
            *(P2_Device_Info *)(RequestPacket->OutputBuffer) = 
                               hwDeviceExtension->deviceInfo;

            status = NO_ERROR;
            break;
  
        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
  
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - MapVideoMemory\n"));
  
            if ( ( RequestPacket->OutputBufferLength <
                 ( RequestPacket->StatusBlock->Information =
                   sizeof(VIDEO_MEMORY_INFORMATION) ) ) ||
                 ( RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY) ) ) 
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            memoryInformation = RequestPacket->OutputBuffer;
  
            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;
  
            memoryInformation->VideoRamLength =
                    hwDeviceExtension->FrameLength;
  
            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;
  
            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            // We only do it for the frame buffer - memory mapped registers can
            // not be mapped USWC because write combining the registers would
            // cause very bad things to happen !
            //
            //
            // P6 workaround:
            //
            // Because of a current limitation in many P6 machines, USWC only
            // works on sections of 4MB of memory. So make sure our framebuffer
            // is a multiple of 4MB. We could try to round up the memory region
            // but then we'd have to rework the reserved PCI regions. In any
            // case PERMEDIA cards nearly all have 4 or 8MB of SGRAM. Some low 
            // cost cards have 2MB which will not benefit.
            //
            //
  
            if ((memoryInformation->VideoRamLength & (4*1024*1024 - 1)) == 0)
            {
                DEBUG_PRINT((2, "PERM2: Setting VIDEO_MEMORY_SPACE_P6CACHE\n"));
                inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
            }
  
            status = VideoPortMapMemory( HwDeviceExtension,
                                         hwDeviceExtension->PhysicalFrameAddress,
                                         &(memoryInformation->VideoRamLength),
                                         &inIoSpace,
                                         &(memoryInformation->VideoRamBase));

            if (status != NO_ERROR) 
            {
                DEBUG_PRINT((1, "PERM2: VideoPortMapMemory failed with error %d\n", status));
                break;
            }
  
            //
            // The frame buffer and virtual memory and equivalent in this
            // case.
            //

            memoryInformation->FrameBufferBase = 
                               memoryInformation->VideoRamBase;
  
            memoryInformation->FrameBufferLength = 
                               memoryInformation->VideoRamLength;
  
            break;
  
  
        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:
    
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - UnMapVideoMemory\n"));
  
            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) 
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
    
            status = VideoPortUnmapMemory(
                          HwDeviceExtension,
                          ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                          0 );
  
            break;
  
  
        case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:
    
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryPublicAccessRanges\n"));
    
            {
    
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            ULONG physicalPortLength;
            PVOID VirtualAddress;
            PHYSICAL_ADDRESS PhysicalAddress;
    
            if ( ( RequestPacket->OutputBufferLength <
                 ( RequestPacket->StatusBlock->Information =
                   sizeof(VIDEO_PUBLIC_ACCESS_RANGES))) ||
                 ( RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY) ) )
            {
  
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            ProcessHandle = (HANDLE)(((PVIDEO_MEMORY)
                     (RequestPacket->InputBuffer))->RequestedVirtualAddress);
  
            if (ProcessHandle != (HANDLE)0)
            {
                 //
                 // map 4K area for a process
                 //
          
                 DEBUG_PRINT((2, "PERM2: Mapping in 4K area from Control registers\n"));

                 VirtualAddress  = (PVOID)ProcessHandle;
                 PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                 PhysicalAddress.LowPart += 0x2000;
                 physicalPortLength = 0x1000;
  
            }
            else
            {
                 DEBUG_PRINT((2, "PERM2: Mapping in all Control registers\n"));
                 VirtualAddress = NULL;
                 PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                 physicalPortLength = hwDeviceExtension->RegisterLength;
            }

            portAccess = RequestPacket->OutputBuffer;
  
            portAccess->VirtualAddress  = VirtualAddress;
            portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;
  
            status = VideoPortMapMemory( HwDeviceExtension,
                                         PhysicalAddress,
                                         &physicalPortLength,
                                         &(portAccess->MappedInIoSpace),
                                         &(portAccess->VirtualAddress));
  
            if (status == NO_ERROR)
            {
                DEBUG_PRINT((1, "PERM2: mapped PAR[0] at vaddr 0x%x for length 0x%x\n",
                                    portAccess->VirtualAddress,
                                    physicalPortLength));
            }
            else
            {
                DEBUG_PRINT((1, "PERM2: VideoPortMapMemory failed with status 0x%x\n", status));
            }

            if ( (RequestPacket->OutputBufferLength >= 
                                3 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES) ) &&
                 (ProcessHandle == (HANDLE)0) )
            {

                RequestPacket->StatusBlock->Information =
                                3 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

                portAccess = RequestPacket->OutputBuffer;
                PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                physicalPortLength = hwDeviceExtension->RegisterLength;

#if defined(_ALPHA_)

                //
                // for alpha, we want to map in a dense version of the 
                // control registers if we can. If this fails, we null 
                // the virtual address
                //

                portAccess += 2;
                portAccess->VirtualAddress  = NULL;
                portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
                portAccess->MappedInIoSpace = 4;

                status = VideoPortMapMemory( HwDeviceExtension,
                                             PhysicalAddress,
                                             &physicalPortLength,
                                             &(portAccess->MappedInIoSpace),
                                             &(portAccess->VirtualAddress));

                if (status == NO_ERROR)
                {
                    DEBUG_PRINT((1, "PERM2: mapped dense PAR[0] at vaddr 0x%x for length 0x%x\n",
                                     portAccess->VirtualAddress,
                                     physicalPortLength));
                }
                else
                {
                    DEBUG_PRINT((1, "PERM2: dense VideoPortMapMemory failed with status 0x%x\n", status));
                }
#else
                //
                // all others, we just copy range[0]
                //

                portAccess[2] = portAccess[0];
#endif
            }
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - FreePublicAccessRanges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) 
        {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = VideoPortUnmapMemory(
                         HwDeviceExtension,
                         ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->
                                                 RequestedVirtualAddress,
                         0);

        if (status != NO_ERROR)
        {
            DEBUG_PRINT((1, "PERM2: VideoPortUnmapMemory failed with status 0x%x\n", status));
        }

#if defined(_ALPHA_)

        {
            PVIDEO_MEMORY pVideoMemory;
            PVOID pVirtualAddress;

            if (RequestPacket->InputBufferLength >= 3 * sizeof(VIDEO_MEMORY)) 
            {
                pVideoMemory = (PVIDEO_MEMORY)(RequestPacket->InputBuffer);

                pVirtualAddress = pVideoMemory->RequestedVirtualAddress;

                pVideoMemory += 2;

                if((pVideoMemory->RequestedVirtualAddress) &&
                   (pVideoMemory->RequestedVirtualAddress != pVirtualAddress))
                {
                    status = VideoPortUnmapMemory(
                                  HwDeviceExtension,
                                  pVideoMemory->RequestedVirtualAddress,
                                  0 );
                }

                if (status != NO_ERROR)
                        DEBUG_PRINT((1, "PERM2: VideoPortUnmapMemory failed on Alpha with status 0x%x\n", status));
            
            }
        }

#endif
        break;

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - HandleVideoParameters\n"));

        //
        // We don't support a tv connector so just return NO_ERROR here
        //

        pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->InputBuffer);

        if (pVideoParams->dwCommand == VP_COMMAND_GET) 
        {
            pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->OutputBuffer);
            pVideoParams->dwFlags = 0;
        }

        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
               ( RequestPacket->StatusBlock->Information =
                 hwDeviceExtension->NumAvailableModes * 
                 sizeof(VIDEO_MODE_INFORMATION)) ) 
                 
        {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else 
        {

            modeInformation = RequestPacket->OutputBuffer;

            for (pFrequencyEntry = hwDeviceExtension->FrequencyTable;
                 pFrequencyEntry->BitsPerPel != 0;
                 pFrequencyEntry++) 
            {

                if (pFrequencyEntry->ModeValid) 
                {
                    *modeInformation =
                        pFrequencyEntry->ModeEntry->ModeInformation;

                    modeInformation->Frequency =
                        pFrequencyEntry->ScreenFrequency;

                    modeInformation->ModeIndex =
                        pFrequencyEntry->ModeIndex;

                    modeInformation++;
                }
            }

            status = NO_ERROR;
        }

        break;


     case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryCurrentModes. current mode is %d\n",
                hwDeviceExtension->ActiveModeEntry->ModeInformation.ModeIndex));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_MODE_INFORMATION)) ) 
        {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else 
        {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                    hwDeviceExtension->ActiveModeEntry->ModeInformation;

            ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                    hwDeviceExtension->ActiveFrequencyEntry.ScreenFrequency;

            status = NO_ERROR;

        }

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryNumAvailableModes (= %d)\n",
                     hwDeviceExtension->NumAvailableModes));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //

        if (RequestPacket->OutputBufferLength <
           (RequestPacket->StatusBlock->Information = sizeof(VIDEO_NUM_MODES))) 
        {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else 
        {
            //
            // Configure the valid modes again. This allows non 3D accelerated
            // modes to be added dynamically. BUT, we cannot allow modes to be
            // dynamically removed. If we do we may have nowhere to go after
            // the Test screen (or if we logout). So only reconfigure these
            // modes if the ExportNon3D flag is turned on and it used to be
            // off. If it was already on then there's no need to reconfigure.
            //

            if (!hwDeviceExtension->ExportNon3DModes)
            {
                ULONG ExportNon3DModes = 0;

                status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                        PERM2_EXPORT_HIRES_REG_STRING,
                                                        FALSE,
                                                        Permedia2RegistryCallback,
                                                        &ExportNon3DModes);

                if (( status == NO_ERROR) && ExportNon3DModes)
                {
                    ConstructValidModesList( HwDeviceExtension, 
                                             hwDeviceExtension );
                }

            }

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                    hwDeviceExtension->NumAvailableModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                    sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - SetCurrentMode\n"));

        if(!hwDeviceExtension->bVGAEnabled)
        {
            //
            // secondary card: if it's just returned from hibernation 
            // it won't be set-up yet 
            // NB. primary is OK, its BIOS has run
            //

            PCI_COMMON_CONFIG  PciData;

            VideoPortGetBusData(hwDeviceExtension, 
                                PCIConfiguration, 
                                0, 
                                &PciData, 
                                0, 
                                PCI_COMMON_HDR_LENGTH);

            if((PciData.Command & PCI_ENABLE_MEMORY_SPACE) == 0)
            {
                //
                // memory accesses not turned on - this card has just returned 
                // from hibernation and is back in its default state: set it 
                // up once more
                //

                PowerOnReset(hwDeviceExtension);

            }
        }

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) 
        {
            RequestPacket->StatusBlock->Information = sizeof(VIDEO_MODE);
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        //
        // Find the correct entries in the P2_VIDEO_MODES and
        // P2_VIDEO_FREQUENCIES tables that correspond to this
        // mode number.
        //
        // ( Remember that each mode in the P2_VIDEO_MODES table 
        // can have a number of possible frequencies associated with it.)
        //

        RequestedMode = ((PVIDEO_MODE) RequestPacket->InputBuffer)->RequestedMode;

        modeNumber = RequestedMode & ~VIDEO_MODE_NO_ZERO_MEMORY;

        if ((modeNumber >= hwDeviceExtension->NumTotalModes) ||
            !(hwDeviceExtension->FrequencyTable[modeNumber].ModeValid)) 
        {
            RequestPacket->StatusBlock->Information = 
                     hwDeviceExtension->NumTotalModes;

            status = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Re-sample the clock speed. This allows us to change the clock speed
        // on the fly using the display applet Test button.
        //

        Permedia2GetClockSpeeds(HwDeviceExtension);

        FrequencyEntry = hwDeviceExtension->FrequencyTable[modeNumber];
        ModeEntry = FrequencyEntry.ModeEntry;

        //
        // At this point, 'ModeEntry' and 'FrequencyEntry' point to the 
        // necessary table entries required for setting the requested mode.
        //
        // Zero the DAC and the Screen buffer memory.
        //

        ZeroMemAndDac(hwDeviceExtension, RequestedMode);

        ModeEntry->ModeInformation.DriverSpecificAttributeFlags = 
                   hwDeviceExtension->Capabilities;

        //
        // For low resolution modes we may have to do various tricks
        // such as line doubling and getting the RAMDAC to zoom.
        // Record any such zoom in the Mode DeviceAttributes field.
        // Primarily this is to allow the display driver to
        // compensate when asked to move the cursor or change its
        // shape.
        //
        // Currently, low res means lower than 512 pixels width.
        //

        if (FrequencyEntry.ScreenWidth < 512)
        {
            // Permedia does line doubling. If using a TVP we must
            // get it to zoom by 2 in X to get the pixel rate up.
            //
            ModeEntry->ModeInformation.DriverSpecificAttributeFlags |= CAPS_ZOOM_Y_BY2;

        }

        if (!InitializeVideo(HwDeviceExtension, &FrequencyEntry))
        {
            DEBUG_PRINT((1, "PERM2: InitializeVideo failed\n"));
            RequestPacket->StatusBlock->Information = modeNumber;
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Save the mode since we know the rest will work.
        //

        hwDeviceExtension->ActiveModeEntry = ModeEntry;
        hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

        //
        // Update VIDEO_MODE_INFORMATION fields
        //
        // Now that we've set the mode, we now know the screen stride, and
        // so can update some fields in the VIDEO_MODE_INFORMATION
        // structure for this mode.  The Permedia 2 display driver is expected 
        // to call IOCTL_VIDEO_QUERY_CURRENT_MODE to query these corrected
        // values.
        //
        //
        // Calculate the bitmap width (note the '+ 1' on BitsPerPlane is
        // so that '15bpp' works out right). 12bpp is special in that we
        // support it as sparse nibbles within a 32-bit pixel. ScreenStride
        // is in bytes; VideoMemoryBitmapWidth is measured in pixels;
        //

        if (ModeEntry->ModeInformation.BitsPerPlane != 12)
        {
            ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
                   ModeEntry->ModeInformation.ScreenStride
                   / ((ModeEntry->ModeInformation.BitsPerPlane + 1) >> 3);
        }
        else 
        {
            ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
                   ModeEntry->ModeInformation.ScreenStride >> 2;
        }

        //
        // Calculate the bitmap height. 
        //

        ulValue = hwDeviceExtension->AdapterMemorySize;
        ModeEntry->ModeInformation.VideoMemoryBitmapHeight =
                        ulValue / ModeEntry->ModeInformation.ScreenStride;

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - SetColorRegs\n"));

        clutBuffer = (PVIDEO_CLUT) RequestPacket->InputBuffer;

        status = Permedia2SetColorLookup(hwDeviceExtension,
                                         clutBuffer,
                                         RequestPacket->InputBufferLength,
                                         FALSE, // update when we need to
                                         TRUE); // Update cache entries as 
                                                // well as RAMDAC
        break;

    case IOCTL_VIDEO_RESET_DEVICE:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - RESET_DEVICE\n"));

        if(hwDeviceExtension->bVGAEnabled)
        {
            //
            // Do any resets required before getting the BIOS to
            // do an INT 10
            //
            //
            // reset the VGA before rerouting the bypass to display VGA
            //
            // Only reset the device if the monitor is on.  If it is off,
            // then executing the int10 will turn it back on.
            //

            if (hwDeviceExtension->bMonitorPoweredOn) 
            {
                //
                // Do an Int10 to mode 3 will put the VGA to a known state.
                //

                VideoPortZeroMemory(&biosArguments, 
                                    sizeof(VIDEO_X86_BIOS_ARGUMENTS));

                biosArguments.Eax = 0x0003;

                VideoPortInt10(HwDeviceExtension, &biosArguments);
            }
        }

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:
        {

        PVIDEO_SHARE_MEMORY pShareMemory;
        PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
        PHYSICAL_ADDRESS shareAddress;
        PVOID virtualAddress;
        ULONG sharedViewSize;

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - ShareVideoMemory\n"));

        if( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
            (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) 
        {
            DEBUG_PRINT((1, "PERM2: IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
            ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) 
        {
            DEBUG_PRINT((1, "PERM2: IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
                hwDeviceExtension->PhysicalFrameAddress.QuadPart;

#if defined(_X86_) // it seems best to only do this for X86

        //
        // Performance:
        //
        // Enable USWC on the P6 processor.
        // We only do it for the frame buffer - memory mapped registers can
        // not be mapped USWC because write combining the registers would
        // cause very bad things to happen !
        //

        inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

#endif

        //
        // Unlike the MAP_MEMORY IOCTL, in this case we can not map extra
        // address space since the application could actually use the
        // pointer we return to it to touch locations in the address space
        // that do not have actual video memory in them.
        //
        // An app doing this would cause the machine to crash.
        //
        // However, because the caching policy for USWC in the P6 is on
        // *physical* addresses, this memory mapping will "piggy back" on
        // the normal frame buffer mapping, and therefore also benefit
        // from USWC ! Cool side-effect !!!
        //

        status = VideoPortMapMemory( hwDeviceExtension,
                                     shareAddress,
                                     &sharedViewSize,
                                     &inIoSpace,
                                     &virtualAddress );
 
        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        }
        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        {
        PVIDEO_SHARE_MEMORY pShareMemory;

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) 
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);
        }
        break;


    case IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER:

        //
        // Return the line DMA buffer information. The buffer size and 
        // virtual address will be zero if the buffer couldn't be allocated.
        //
        // output buffer has zero length, so free buffer....
        //

        status = ERROR_INSUFFICIENT_BUFFER;

        if (RequestPacket->OutputBufferLength <
           (RequestPacket->StatusBlock->Information = sizeof(LINE_DMA_BUFFER)))
        {

            //
            // Maybe we should free something
            //

            if ( RequestPacket->InputBufferLength >= sizeof(LINE_DMA_BUFFER))
            {
                if (hwDeviceExtension->ulLineDMABufferUsage > 0)
                {
                    hwDeviceExtension->ulLineDMABufferUsage--;
                    if (hwDeviceExtension->ulLineDMABufferUsage == 0)
                    {
                        VideoPortFreeCommonBuffer(
                                hwDeviceExtension,
                                hwDeviceExtension->LineDMABuffer.size,
                                hwDeviceExtension->LineDMABuffer.virtAddr,
                                hwDeviceExtension->LineDMABuffer.physAddr,
                                hwDeviceExtension->LineDMABuffer.cacheEnabled);

                        memset(&hwDeviceExtension->LineDMABuffer,
                               0,
                               sizeof(LINE_DMA_BUFFER));
                    }
                }
                  status = NO_ERROR;
             } 
        }
        else
        {
            PLINE_DMA_BUFFER pDMAIn, pDMAOut;

            pDMAIn  = (PLINE_DMA_BUFFER)RequestPacket->InputBuffer;
            pDMAOut = (PLINE_DMA_BUFFER)RequestPacket->OutputBuffer;

            if (RequestPacket->InputBufferLength >= sizeof(LINE_DMA_BUFFER))
            {
                if (hwDeviceExtension->ulLineDMABufferUsage == 0)
                {
                    *pDMAOut = *pDMAIn;

                    if( ( pDMAOut->virtAddr = 
                          VideoPortGetCommonBuffer( hwDeviceExtension,
                                                    pDMAIn->size,
                                                    PAGE_SIZE,
                                                    &pDMAOut->physAddr,
                                                    &pDMAOut->size,
                                                    pDMAIn->cacheEnabled ) )
                           != NULL )
                    {
                        hwDeviceExtension->LineDMABuffer=*pDMAOut;
                        hwDeviceExtension->ulLineDMABufferUsage++;
                    }

                } else
                {
                    *pDMAOut = hwDeviceExtension->LineDMABuffer;
                    hwDeviceExtension->ulLineDMABufferUsage++;
                }
                
                status = NO_ERROR;
            } 
        }

        DEBUG_PRINT((1, "PERM2: QUERY LINE DMA BUFFER status %d\n", status));
        break;

    case IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - MapInterruptCmdBuf\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(PVOID)) )
        {
            //
            // They've give us a duff buffer.
            //

            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            *((PVOID*)(RequestPacket->OutputBuffer)) = 
                    hwDeviceExtension->InterruptControl.ControlBlock;
            status = NO_ERROR;
        }

        DEBUG_PRINT((1, "PERM2: MapInterruptCmdBuf returns va %x\n",
                        *(PULONG)(RequestPacket->OutputBuffer)));
        break;


#if defined(_X86_)

        case IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE:

            status = ERROR_INSUFFICIENT_BUFFER;

            if ( RequestPacket->OutputBufferLength >=
                 (RequestPacket->StatusBlock->Information = sizeof(PVOID)) )
            {
                PVOID *pIE = (PVOID)RequestPacket->OutputBuffer;
                *pIE       = (PVOID) VideoPortInterlockedExchange;
                status     = NO_ERROR;
            }

         break;
#endif


    case IOCTL_VIDEO_STALL_EXECUTION:
        if (RequestPacket->InputBufferLength >= sizeof(ULONG))
        {   
            ULONG *pMicroseconds = (ULONG *)RequestPacket->InputBuffer;
            VideoPortStallExecution(*pMicroseconds);
            status = NO_ERROR;    
        } else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        
        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        DEBUG_PRINT((1, "Fell through Permedia2 startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }


    RequestPacket->StatusBlock->Status = status;

    if( status != NO_ERROR )
        RequestPacket->StatusBlock->Information = 0;

    return TRUE;

} // end Permedia2StartIO()


BOOLEAN
Permedia2ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*++

Routine Description:

    This routine resets the hardware when a soft reboot is performed. We
    need this to reset the VGA pass through.

    THIS FUNCTION CANNOT BE PAGED.

Arguments:

    hwDeviceExtension - Pointer to the miniport driver's device extension.

    Columns - Specifies the number of columns of the mode to be set up.

    Rows - Specifies the number of rows of the mode to be set up.

Return Value:

    We always return FALSE to force the HAL to do an INT10 reset.

--*/

{

    //
    // return false so the HAL does an INT10 mode 3
    //

    return(FALSE);
}


VP_STATUS
Permedia2SetColorLookup(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    )

/*++

Routine Description:

    This routine sets a specified portion of the color lookup table settings.

Arguments:

    hwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    None.

--*/

{
    USHORT i, j;
    TVP4020_DECL;
    P2RD_DECL;
    PVIDEO_CLUT LUTCachePtr = &(hwDeviceExtension->LUTCache.LUTCache);
    P2_DECL;
    ULONG VsEnd;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < (sizeof(VIDEO_CLUT) - sizeof(ULONG))) ||
         (ClutBufferSize < (sizeof(VIDEO_CLUT) +
         (sizeof(ULONG) * (ClutBuffer->NumEntries - 1))) ) )
    {

        DEBUG_PRINT((1, "PERM2: Permedia2SetColorLookup: insufficient buffer (was %d, min %d)\n",
                    ClutBufferSize,
                    (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)))));

        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
          VIDEO_MAX_COLOR_REGISTER + 1) )
    {
        DEBUG_PRINT((1, "Permedia2SetColorLookup: invalid parameter\n"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set CLUT registers directly on the hardware.
    //

    switch (hwDeviceExtension->DacId)
    {
        case TVP4020_RAMDAC:
        case P2RD_RAMDAC:
            break;

        default:
            return (ERROR_DEV_NOT_EXIST);
    }

    if (hwDeviceExtension->bVTGRunning && 
        hwDeviceExtension->bMonitorPoweredOn)
    {
        // 
        // if VTG has been set-up, we wait for VSync before updating
        // the palette entries (just to avoid possible flickers)
        //

        VsEnd = VideoPortReadRegisterUlong(VS_END);
        while ( VideoPortReadRegisterUlong(LINE_COUNT) > VsEnd ); 
    }

    //
    // RAMDAC Programming phase
    //

    for ( i = 0, j = ClutBuffer->FirstEntry; 
          i < ClutBuffer->NumEntries; 
          i++, j++ )
    {

        //
        // Update the RAMDAC entry if it has changed or if we have 
        // been told to overwrite it.
        //

        if ( ForceRAMDACWrite ||
            ( LUTCachePtr->LookupTable[j].RgbLong != 
              ClutBuffer->LookupTable[i].RgbLong ) )
        {
            switch (hwDeviceExtension->DacId)
            {
                case TVP4020_RAMDAC:
                    TVP4020_LOAD_PALETTE_INDEX (
                         j,
                         ClutBuffer->LookupTable[i].RgbArray.Red,
                         ClutBuffer->LookupTable[i].RgbArray.Green,
                         ClutBuffer->LookupTable[i].RgbArray.Blue);
                break;

                case P2RD_RAMDAC:
                    P2RD_LOAD_PALETTE_INDEX (
                         j,
                         ClutBuffer->LookupTable[i].RgbArray.Red,
                         ClutBuffer->LookupTable[i].RgbArray.Green,
                         ClutBuffer->LookupTable[i].RgbArray.Blue);
                break;
            }

        }


        //
        // Update the cache, if instructed to do so
        //

        if (UpdateCache)
        {
            LUTCachePtr->LookupTable[j].RgbLong = ClutBuffer->LookupTable[i].RgbLong;
        }
    }

    return NO_ERROR;

} // end Permedia2SetColorLookup()



VOID
Permedia2GetClockSpeeds(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Work out the chip clock speed and save in hwDeviceExtension.

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    On return the following values will be in hwDeviceExtension:

       - ChipClockSpeed: this is the desired speed for the chip
       - RefClockSpeed:  this is the speed of the oscillator input on the board

Note:

    We use ChipClockSpeed to refer to the speed of the chip. RefClockSpeed 
    is the reference clock speed. 
    
--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ulValue, ulChipClk, ulRefClk;
    VP_STATUS status;
    P2_DECL;

    //
    // inherit the values from board zero or default
    //

    ulChipClk = hwDeviceExtension->ChipClockSpeed;
    ulRefClk  = REF_CLOCK_SPEED;

    //
    // Use the Registry specified clock-speed if supplied
    //

    status = VideoPortGetRegistryParameters( HwDeviceExtension,
                                             L"PermediaClockSpeed",
                                             FALSE,
                                             Permedia2RegistryCallback,
                                             &ulChipClk);

    if ( (status != NO_ERROR) || ulChipClk == 0)
    {

        //
        // The Registry does not specify an override so read the chip clock 
        // speed (in MHz) from the Video ROM BIOS (offset 0xA in the BIOS) 
        // NB. this involves changing the aperture 2 register so aperture 
        //     better be completely idle or we could be in trouble; fortunately 
        //     we only call this function during a mode change and expect 
        //     aperture 2 (the FrameBuffer) to be idle
        //

        ULONG Default = VideoPortReadRegisterUlong(APERTURE_TWO);
        UCHAR *p = (UCHAR *)hwDeviceExtension->pFramebuffer;

        //
        // r/w via aperture 2 actually go to ROM
        //

        VideoPortWriteRegisterUlong(APERTURE_TWO, Default | 0x200); 

        //
        // If we have a valid ROM then read the clock speed
        //

        if (VideoPortReadRegisterUshort ((USHORT *) p) == 0xAA55)
        {
            //
            // Get the clock speed, on some boards (eg Creative), the clock 
            // value at 0x0A is sometimes remains undefined leading to 
            // unpredictable results. The values are validated before this 
            // function returns
            //

            ulChipClk = VideoPortReadRegisterUchar(&(p[0xA]));
    
            DEBUG_PRINT((1, "ROM clk speed value 0x%x\n Mhz", ulChipClk));

        }
        else
        {
            DEBUG_PRINT((1, "Bad BIOS ROM header 0x%x\n", 
                        (ULONG) VideoPortReadRegisterUshort ((USHORT *) p)));         
        
        }

        VideoPortWriteRegisterUlong(APERTURE_TWO, Default);
    }

    //
    // Convert to Hz
    //

    ulChipClk *= 1000000;  

    //
    // Validate the selected clock speed, adjust if it is either too 
    // high or too low.
    //

    if (ulChipClk < MIN_PERMEDIA_CLOCK_SPEED)
    {
        if(ulChipClk == 0x00)
        {
            ulChipClk = PERMEDIA2_DEFAULT_CLOCK_SPEED;
        }
        else
        {
            ulChipClk = MIN_PERMEDIA_CLOCK_SPEED;
        }
    } 
    
    if (ulChipClk > MAX_PERMEDIA_CLOCK_SPEED)
    {
        DEBUG_PRINT((1, "PERM2: Permedia clock speed %d too fast. Limiting to %d\n" ,
                         ulChipClk, MAX_PERMEDIA_CLOCK_SPEED));

        ulChipClk= PERMEDIA2_DEFAULT_CLOCK_SPEED;
 
    }

    DEBUG_PRINT((3, "PERM2: Permedia Clock Speed set to %dHz\n", ulChipClk));

    hwDeviceExtension->ChipClockSpeed = ulChipClk;
    hwDeviceExtension->RefClockSpeed = ulRefClk;
}


VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG RequestedMode
    )

/*++

Routine Description:

    Initialize the DAC to 0 (black).

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestedMode - use the VIDEO_MODE_NO_ZERO_MEMORY bit to determine if the
                    framebuffer should be cleared

Return Value:

    None

--*/

{
    ULONG  i;
    P2_DECL;
    TVP4020_DECL;
    P2RD_DECL;

    //
    // Turn off the screen at the DAC.
    //

    if (hwDeviceExtension->DacId == TVP4020_RAMDAC)
    {
        TVP4020_SET_PIXEL_READMASK (0x0);
        TVP4020_PALETTE_START_WR (0);

        for (i = 0; i <= VIDEO_MAX_COLOR_REGISTER; i++)
        {
            TVP4020_LOAD_PALETTE (0, 0, 0);
        }
    }
    else
    {
        P2RD_SET_PIXEL_READMASK (0x0);
        P2RD_PALETTE_START_WR(0);       

        for (i = 0; i <= VIDEO_MAX_COLOR_REGISTER; i++)
        {
            P2RD_LOAD_PALETTE (0, 0, 0);
        }
    }

    if (!(RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY))
    {
        //
        // Zero the memory. Don't use Permedia 2 as we would have to save and 
        // restore state and that's a pain. This is not time critical.
        //

        VideoPortZeroDeviceMemory(hwDeviceExtension->pFramebuffer,
                                  hwDeviceExtension->FrameLength);

        DEBUG_PRINT((1, "PERM2: framebuffer cleared\n"));
    }

    //
    // Turn on the screen at the DAC
    //

    if (hwDeviceExtension->DacId == TVP4020_RAMDAC) 
    {
        TVP4020_SET_PIXEL_READMASK (0xff);
    }
    else
    {
        P2RD_SET_PIXEL_READMASK (0xff);
    }

    LUT_CACHE_INIT();

    return;
}



#if DBG

VOID
DumpPCIConfigSpace(
    PVOID HwDeviceExtension, 
    ULONG bus, 
    ULONG slot)
{

    PPCI_COMMON_CONFIG  PciData;
    UCHAR buffer[sizeof(PCI_COMMON_CONFIG)];
    ULONG j;

    PciData = (PPCI_COMMON_CONFIG)buffer;

    j = VideoPortGetBusData( HwDeviceExtension,
                             PCIConfiguration,
                             slot,
                             PciData,
                             0,
                             PCI_COMMON_HDR_LENGTH + 4 );

    //
    // don't report junk slots
    //

    if (PciData->VendorID == 0xffff)
        return;

    DEBUG_PRINT((2, "PERM2: DumpPCIConfigSpace: VideoPortGetBusData returned %d PCI_COMMON_HDR_LENGTH = %d\n",
                     j, PCI_COMMON_HDR_LENGTH+4));

    DEBUG_PRINT((2,  "DumpPCIConfigSpace: ------------------------\n"));
    DEBUG_PRINT((2,  "  Bus: %d\n",              bus  ));
    DEBUG_PRINT((2,  "  Slot: %d\n",             slot  ));
    DEBUG_PRINT((2,  "  Vendor Id: 0x%x\n",      PciData->VendorID  ));
    DEBUG_PRINT((2,  "  Device Id: 0x%x\n",      PciData->DeviceID  ));
    DEBUG_PRINT((2,  "  Command: 0x%x\n",        PciData->Command  ));
    DEBUG_PRINT((2,  "  Status: 0x%x\n",         PciData->Status  ));
    DEBUG_PRINT((2,  "  Rev Id: 0x%x\n",         PciData->RevisionID  ));
    DEBUG_PRINT((2,  "  ProgIf: 0x%x\n",         PciData->ProgIf  ));
    DEBUG_PRINT((2,  "  SubClass: 0x%x\n",       PciData->SubClass  ));
    DEBUG_PRINT((2,  "  BaseClass: 0x%x\n",      PciData->BaseClass  ));
    DEBUG_PRINT((2,  "  CacheLine: 0x%x\n",      PciData->CacheLineSize  ));
    DEBUG_PRINT((2,  "  Latency: 0x%x\n",        PciData->LatencyTimer  ));
    DEBUG_PRINT((2,  "  Header Type: 0x%x\n",    PciData->HeaderType  ));
    DEBUG_PRINT((2,  "  BIST: 0x%x\n",           PciData->BIST  ));
    DEBUG_PRINT((2,  "  Base Reg[0]: 0x%x\n",    PciData->u.type0.BaseAddresses[0]  ));
    DEBUG_PRINT((2,  "  Base Reg[1]: 0x%x\n",    PciData->u.type0.BaseAddresses[1]  ));
    DEBUG_PRINT((2,  "  Base Reg[2]: 0x%x\n",    PciData->u.type0.BaseAddresses[2]  ));
    DEBUG_PRINT((2,  "  Base Reg[3]: 0x%x\n",    PciData->u.type0.BaseAddresses[3]  ));
    DEBUG_PRINT((2,  "  Base Reg[4]: 0x%x\n",    PciData->u.type0.BaseAddresses[4]  ));
    DEBUG_PRINT((2,  "  Base Reg[5]: 0x%x\n",    PciData->u.type0.BaseAddresses[5]  ));
    DEBUG_PRINT((2,  "  Rom Base: 0x%x\n",       PciData->u.type0.ROMBaseAddress  ));
    DEBUG_PRINT((2,  "  Interrupt Line: 0x%x\n", PciData->u.type0.InterruptLine  ));
    DEBUG_PRINT((2,  "  Interrupt Pin: 0x%x\n",  PciData->u.type0.InterruptPin  ));
    DEBUG_PRINT((2,  "  Min Grant: 0x%x\n",      PciData->u.type0.MinimumGrant  ));
    DEBUG_PRINT((2,  "  Max Latency: 0x%x\n",    PciData->u.type0.MaximumLatency ));

    DEBUG_PRINT((2,  "  AGP Capability: 0x%x\n", buffer[0x40]));
    DEBUG_PRINT((2,  "  AGP Next Cap:   0x%x\n", buffer[0x41]));
    DEBUG_PRINT((2,  "  AGP Revision:   0x%x\n", buffer[0x42]));
    DEBUG_PRINT((2,  "  AGP Status:     0x%x\n", buffer[0x43]));

}

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\permedia.h ===
//***************************************************************************
//
// Module Name:
//
//   permedia.h
//
// Abstract:
//
//   This module contains the definitions for the Permedia2 miniport driver
//
// Environment:
//
//   Kernel mode
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


#include "winerror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "interupt.h"
#include "perm2tag.h"

//
// define an assert macro for debugging
//

#if DBG
#define RIP(x)  { VideoDebugPrint((0, x)); ASSERT(FALSE); }
#define P2_ASSERT(x, y) if (!(x)) RIP(y)
#else
#define P2_ASSERT(x, y)
#endif


#if DBG
#define DEBUG_PRINT(arg) VideoDebugPrint(arg)
#else
#define DEBUG_PRINT(arg)
#endif


//
// RAMDAC registers live on 64 bit boundaries. Leave it up to individual
// RAMDAC definitions to determine what registers are available and how
// many bits wide the registers really are.
//

typedef struct {

    volatile ULONG   reg;
    volatile ULONG   pad;

} RAMDAC_REG;

//
// include definitions for all supported RAMDACS
//

#include "tvp4020.h"
#include "p2rd.h"

#define PAGE_SIZE  0x1000

//
// default clock speed in Hz for the reference board. The actual speed
// is looked up in the registry. Use this if no registry entry is found
// or the registry entry is zero.
//

#define PERMEDIA_DEFAULT_CLOCK_SPEED        ( 60 * (1000*1000))
#define PERMEDIA_4MB_DEFAULT_CLOCK_SPEED    ( 70 * (1000*1000))
#define PERMEDIA_8MB_DEFAULT_CLOCK_SPEED    ( 60 * (1000*1000))
#define PERMEDIA_LC_DEFAULT_CLOCK_SPEED     ( 83 * (1000*1000))
#define MAX_PERMEDIA_CLOCK_SPEED            (100 * (1000*1000))
#define MIN_PERMEDIA_CLOCK_SPEED            ( 50 * (1000*1000))
#define REF_CLOCK_SPEED                     14318200
#define PERMEDIA2_DEFAULT_CLOCK_SPEED       ( 70 * (1000*1000))

//
// Maximum pixelclock values that the RAMDAC can handle (in 100's hz).
//

#define P2_MAX_PIXELCLOCK 2200000    // RAMDAC rated at 220 Mhz

//
// Maximum amount of video data per second, that the rasterizer
// chip can send to the RAMDAC (limited by SDRAM/SGRAM throuput).
//

#define P2_MAX_PIXELDATA  5000000    // 500 million bytes/sec (in 100's bytes)

//
// Base address numbers for the Permedia2 PCI regions in which we're interested.
// These are indexes into the AccessRanges array we get from probing the
// device. 
//

#define PCI_CTRL_BASE_INDEX         0
#define PCI_LB_BASE_INDEX           1
#define PCI_FB_BASE_INDEX           2

#define VENDOR_ID_3DLABS        0x3D3D
#define VENDOR_ID_TI            0x104C

#define PERMEDIA2_ID            0x0007     // 3Dlabs Permedia 2 (TI4020 RAMDAC)
#define PERMEDIA_P2_ID          0x3D07     // TI Permedia 2 (TI4020 RAMDAC)
#define PERMEDIA_P2S_ID         0x0009     // 3Dlabs Permedia 2 (P2RD RAMDAC)
#define DEVICE_FAMILY_ID(id)    ((id) & 0xff)

#define PERMEDIA_REV_1          0x0001
#define PERMEDIA2A_REV_ID       0x0011

//
// Capabilities flags
//
// These are private flags passed to the Permedia2 display driver. They're
// put in the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to the display driver via an 'VIDEO_QUERY_AVAIL_MODES' or
// 'VIDEO_QUERY_CURRENT_MODE' IOCTL.
//
// NOTE: These definitions must match those in the Permedia2 display driver's
//       'driver.h'!
//

typedef enum {
    CAPS_ZOOM_X_BY2         = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2         = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_SPARSE_SPACE       = 0x00000004,   // Framebuffer is sparsely mapped
                                            // (don't allow direct access). The machine
                                            // is probably an Alpha.
    CAPS_SW_POINTER         = 0x00010000,   // No hardware pointer; use software
                                            //  simulation
    CAPS_GLYPH_EXPAND       = 0x00020000,   // Use glyph-expand method to draw
                                            //  text.
    CAPS_RGB525_POINTER     = 0x00040000,   // Use IBM RGB525 cursor
    CAPS_FAST_FILL_BUG      = 0x00080000,   // chip fast fill bug exists
//  CAPS_INTERRUPTS         = 0x00100000,   // interrupts supported
//  CAPS_DMA_AVAILABLE      = 0x00200000,   // DMA is supported
    CAPS_TVP3026_POINTER    = 0x00400000,   // Use TI TVP3026 pointer
    CAPS_8BPP_RGB           = 0x00800000,   // Use RGB in 8bpp mode
    CAPS_RGB640_POINTER     = 0x01000000,   // Use IBM RGB640 cursor
    CAPS_DUAL_GLINT         = 0x02000000,   // Dual-TX board
    CAPS_GLINT2_RAMDAC      = 0x04000000,   // Second TX/MX attached to the RAMDAC
    CAPS_ENHANCED_TX        = 0x08000000,   // TX is in enhanced mode
    CAPS_ACCEL_HW_PRESENT   = 0x10000000,   // Accel Graphics Hardware
    CAPS_TVP4020_POINTER    = 0x20000000,   // Use TI TVP3026 pointer
    CAPS_P2RD_POINTER       = 0x80000000    // Use the 3Dlabs P2RD RAMDAC
} CAPS;


//
// Supported board definitions.
//

typedef enum _PERM2_BOARDS {
    PERMEDIA2_BOARD = 1,
} PERM2_BOARDS;

//
// Supported RAMDAC definitions.
//

typedef enum _PERM2_RAMDACS {
    TVP4020_RAMDAC = 1,
    P2RD_RAMDAC,
} PERM2_RAMDACS;

//
// macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The id
// is irrelevant as long as it's different from every other id used in the same
// struct. It's a pity pad##__LINE__ doesn't work.
//

#define PAD(id, n)              UCHAR   pad##id[n]
#define PADRANGE(id, n)         PAD(id, (n)-sizeof(P2_REG))
#define PADCORERANGE(id, n)     PADRANGE(id, (n)<<3)

//
// Permedia2 registers are 32 bits wide and live on 64-bit boundaries.
//

typedef struct {
    ULONG   reg;
    ULONG   pad;
} P2_REG;


//
// Permedia2 PCI Region 0 Address MAP:
//
// All registers are on 64-bit boundaries so we have to define a number of
// padding words. The number given in the comments are offsets from the start
// of the PCI region.
//

typedef struct _p2_region0_map {

    // Control Status Registers:
    P2_REG       ResetStatus;                // 0000h
    P2_REG       IntEnable;                  // 0008h
    P2_REG       IntFlags;                   // 0010h
    P2_REG       InFIFOSpace;                // 0018h
    P2_REG       OutFIFOWords;               // 0020h
    P2_REG       DMAAddress;                 // 0028h
    P2_REG       DMACount;                   // 0030h
    P2_REG       ErrorFlags;                 // 0038h
    P2_REG       VClkCtl;                    // 0040h
    P2_REG       TestRegister;               // 0048h
    union a0 {
        // GLINT
        struct b0 {
            P2_REG       Aperture0;          // 0050h
            P2_REG       Aperture1;          // 0058h
        };
        // PERMEDIA
        struct b1 {
            P2_REG       ApertureOne;        // 0050h
            P2_REG       ApertureTwo;        // 0058h
        };
    };
    P2_REG       DMAControl;                 // 0060h
    P2_REG       DisconnectControl;          // 0068h

    // PERMEDIA only
    P2_REG       ChipConfig;                 // 0070h
    PADRANGE(1, 0x80-0x70);
    P2_REG       OutDMAAddress;              // 0080h
    P2_REG       OutDMACount;                // 0088h
    PADRANGE(1a, 0x800-0x88);

    // GLINTdelta registers. Registers with the same functionality as on GLINT
    // are at the same offset. XXX are not real registers.
    //
    P2_REG       DeltaReset;                 // 0800h
    P2_REG       DeltaIntEnable;             // 0808h
    P2_REG       DeltaIntFlags;              // 0810h
    P2_REG       DeltaInFIFOSpaceXXX;        // 0818h
    P2_REG       DeltaOutFIFOWordsXXX;       // 0820h
    P2_REG       DeltaDMAAddressXXX;         // 0828h
    P2_REG       DeltaDMACountXXX;           // 0830h
    P2_REG       DeltaErrorFlags;            // 0838h
    P2_REG       DeltaVClkCtlXXX;            // 0840h
    P2_REG       DeltaTestRegister;          // 0848h
    P2_REG       DeltaAperture0XXX;          // 0850h
    P2_REG       DeltaAperture1XXX;          // 0858h
    P2_REG       DeltaDMAControlXXX;         // 0860h
    P2_REG       DeltaDisconnectControl;     // 0868h
    PADRANGE(2, 0x1000-0x868);

    // Localbuffer Registers
    union x0 {                               // 1000h
        P2_REG   LBMemoryCtl;                // GLINT
        P2_REG   Reboot;                     // PERMEDIA
    };
    P2_REG       LBMemoryEDO;                // 1008h
    PADRANGE(3, 0x1040-0x1008);

    // PERMEDIA only
    P2_REG       RomControl;                 // 1040h
    PADRANGE(4, 0x1080-0x1040);
    P2_REG       BootAddress;                // 1080h
    PADRANGE(5, 0x10C0-0x1080);
    P2_REG       MemConfig;                  // 10C0h
    PADRANGE(6, 0x1100-0x10C0);
    P2_REG       BypassWriteMask;            // 1100h
    PADRANGE(7, 0x1140-0x1100);
    P2_REG       FramebufferWriteMask;       // 1140h
    PADRANGE(8, 0x1180-0x1140);
    P2_REG       Count;                      // 1180h
    PADRANGE(9, 0x1800-0x1180);

    // Framebuffer Registers
    P2_REG       FBMemoryCtl;                // 1800h
    P2_REG       FBModeSel;                  // 1808h
    P2_REG       FBGCWrMask;                 // 1810h
    P2_REG       FBGCColorMask;              // 1818h
    P2_REG       FBTXMemCtl;                 // 1820h
    PADRANGE(10, 0x2000-0x1820);

    // Graphics Core FIFO Interface
    P2_REG       FIFOInterface;              // 2000h
    PADRANGE(11, 0x3000-0x2000);

    // Internal Video Registers
    union x1 {
        // GLINT
        struct s1 {
            P2_REG   VTGHLimit;              // 3000h
            P2_REG   VTGHSyncStart;          // 3008h
            P2_REG   VTGHSyncEnd;            // 3010h
            P2_REG   VTGHBlankEnd;           // 3018h
            P2_REG   VTGVLimit;              // 3020h
            P2_REG   VTGVSyncStart;          // 3028h
            P2_REG   VTGVSyncEnd;            // 3030h
            P2_REG   VTGVBlankEnd;           // 3038h
            P2_REG   VTGHGateStart;          // 3040h
            P2_REG   VTGHGateEnd;            // 3048h
            P2_REG   VTGVGateStart;          // 3050h
            P2_REG   VTGVGateEnd;            // 3058h
            P2_REG   VTGPolarity;            // 3060h
            P2_REG   VTGFrameRowAddr;        // 3068h
            P2_REG   VTGVLineNumber;         // 3070h
            P2_REG   VTGSerialClk;           // 3078h
        };
        // PERMEDIA
        struct s2 {
            P2_REG   ScreenBase;             // 3000h
            P2_REG   ScreenStride;           // 3008h
            P2_REG   HTotal;                 // 3010h
            P2_REG   HgEnd;                  // 3018h
            P2_REG   HbEnd;                  // 3020h
            P2_REG   HsStart;                // 3028h
            P2_REG   HsEnd;                  // 3030h
            P2_REG   VTotal;                 // 3038h
            P2_REG   VbEnd;                  // 3040h
            P2_REG   VsStart;                // 3048h
            P2_REG   VsEnd;                  // 3050h
            P2_REG   VideoControl;           // 3058h
            P2_REG   InterruptLine;          // 3060h
            P2_REG   DDCData;                // 3068h
            P2_REG   LineCount;              // 3070h
            P2_REG   VFifoCtl;               // 3078h
        };
    };

    P2_REG       VTGModeCtl;                 // 3080h
    PADRANGE(12, 0x4000-0x3080);

    // External Video Control Registers
    // Need to cast this to a struct for a particular video generator
    P2_REG       ExternalVideo;              // 4000h
    PADRANGE(13, 0x4080-0x4000);

    // Mentor Dual-TX clock chip registers
    P2_REG       MentorICDControl;           // 4080h
    // for future: MentorDoubleWrite is at 40C0: 0 = single write, 1 = double
    //             NB must have 2-way interleaved memory
    PADRANGE(14, 0x5800-0x4080);

    // P2 video streams registers
    P2_REG       VSConfiguration;            // 5800h
    PADRANGE(15, 0x6000-0x5800);

    union x2 {
        struct s3 {
            P2_REG   RacerDoubleWrite;       // 6000h
            P2_REG   RacerBankSelect;        // 6008h
            P2_REG   DualTxVgaSwitch;        // 6010h
            P2_REG   DDC1ReadAddress;        // 6018h
        };
        struct s4 {
            // the following array is actually 1024 bytes long
            UCHAR       PermediaVgaCtrl[4*sizeof(P2_REG)];
        };
    };

} P2ControlRegMap, *pP2ControlRegMap;

//
// Permedia2 Interrupt Control Bits
//

//
// InterruptEnable register
//

#define INTR_DISABLE_ALL                0x00
#define INTR_ENABLE_DMA                 0x01
#define INTR_ENABLE_SYNC                0x02
#define INTR_ENABLE_EXTERNAL            0x04
#define INTR_ENABLE_ERROR               0x08
#define INTR_ENABLE_VBLANK              0x10

//
// InterruptFlags register
//

#define INTR_DMA_SET                    0x01
#define INTR_SYNC_SET                   0x02
#define INTR_EXTERNAL_SET               0x04
#define INTR_ERROR_SET                  0x08
#define INTR_VBLANK_SET                 0x10

#define INTR_CLEAR_ALL                  0x1f
#define INTR_CLEAR_DMA                  0x01
#define INTR_CLEAR_SYNC                 0x02
#define INTR_CLEAR_EXTERNAL             0x04
#define INTR_CLEAR_ERROR                0x08
#define INTR_CLEAR_VBLANK               0x10

//
// Macro to declare local variables at the start of any function that wants to
// load Permedia2 registers. Assumes PHW_DEVICE_EXTENSION *hwDeviceExtension 
// has already been declared.
//

#define P2_DECL_VARS \
    pP2ControlRegMap pCtrlRegs

#define P2_DECL \
    pP2ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase

//
// generic RAMDAC declaration. Used when we have table driven I/O. Must be
// declared after P2_DECL
//

#define RAMDAC_DECL \
    P2_REG *pRAMDAC = &(pCtrlRegs->ExternalVideo)

//
// macros which takes a Permedia2 tag name or control register name and translates
// it to a register address. Data must be written to these addresses using
// VideoPortWriteRegisterUlong and read using VideoPortReadRegisterUlong.
// e.g. dma_count = VideoPortReadRegisterUlong(DMA_COUNT);
//

#define CTRL_REG_ADDR(reg)      ((PULONG)&(pCtrlRegs->reg))

#define CTRL_REG_OFFSET(regAddr)    ((ULONG)(((ULONG_PTR)regAddr) - ((ULONG_PTR)pCtrlRegs)))

//
// defines for the different control registers needed by Permedia2. These macros
// can be used as the address part.
//

#define RESET_STATUS            CTRL_REG_ADDR(ResetStatus)
#define INT_ENABLE              CTRL_REG_ADDR(IntEnable)
#define INT_FLAGS               CTRL_REG_ADDR(IntFlags)
#define IN_FIFO_SPACE           CTRL_REG_ADDR(InFIFOSpace)
#define OUT_FIFO_WORDS          CTRL_REG_ADDR(OutFIFOWords)
#define DMA_ADDRESS             CTRL_REG_ADDR(DMAAddress)
#define DMA_COUNT               CTRL_REG_ADDR(DMACount)
#define DMA_OUT_ADDRESS         CTRL_REG_ADDR(OutDMAAddress)        // P2 only
#define DMA_OUT_COUNT           CTRL_REG_ADDR(OutDMACount)          // P2 only
#define ERROR_FLAGS             CTRL_REG_ADDR(ErrorFlags)
#define V_CLK_CTL               CTRL_REG_ADDR(VClkCtl)
#define TEST_REGISTER           CTRL_REG_ADDR(TestRegister)
#define APERTURE_0              CTRL_REG_ADDR(Aperture0)
#define APERTURE_1              CTRL_REG_ADDR(Aperture1)
#define DMA_CONTROL             CTRL_REG_ADDR(DMAControl)
#define LB_MEMORY_CTL           CTRL_REG_ADDR(LBMemoryCtl)
#define LB_MEMORY_EDO           CTRL_REG_ADDR(LBMemoryEDO)
#define FB_MEMORY_CTL           CTRL_REG_ADDR(FBMemoryCtl)
#define FB_MODE_SEL             CTRL_REG_ADDR(FBModeSel)
#define FB_GC_WRITEMASK         CTRL_REG_ADDR(FBGCWrMask)
#define FB_GC_COLORMASK         CTRL_REG_ADDR(FBGCColorMask)
#define FB_TX_MEM_CTL           CTRL_REG_ADDR(FBTXMemCtl)
#define FIFO_INTERFACE          CTRL_REG_ADDR(FIFOInterface)
#define DISCONNECT_CONTROL      CTRL_REG_ADDR(DisconnectControl)

//
// internal timing registers
//

#define VTG_HLIMIT              CTRL_REG_ADDR(VTGHLimit)
#define VTG_HSYNC_START         CTRL_REG_ADDR(VTGHSyncStart)
#define VTG_HSYNC_END           CTRL_REG_ADDR(VTGHSyncEnd)
#define VTG_HBLANK_END          CTRL_REG_ADDR(VTGHBlankEnd)
#define VTG_VLIMIT              CTRL_REG_ADDR(VTGVLimit)
#define VTG_VSYNC_START         CTRL_REG_ADDR(VTGVSyncStart)
#define VTG_VSYNC_END           CTRL_REG_ADDR(VTGVSyncEnd)
#define VTG_VBLANK_END          CTRL_REG_ADDR(VTGVBlankEnd)
#define VTG_HGATE_START         CTRL_REG_ADDR(VTGHGateStart)
#define VTG_HGATE_END           CTRL_REG_ADDR(VTGHGateEnd)
#define VTG_VGATE_START         CTRL_REG_ADDR(VTGVGateStart)
#define VTG_VGATE_END           CTRL_REG_ADDR(VTGVGateEnd)
#define VTG_POLARITY            CTRL_REG_ADDR(VTGPolarity)
#define VTG_FRAME_ROW_ADDR      CTRL_REG_ADDR(VTGFrameRowAddr)
#define VTG_VLINE_NUMBER        CTRL_REG_ADDR(VTGVLineNumber)
#define VTG_SERIAL_CLK          CTRL_REG_ADDR(VTGSerialClk)
#define VTG_MODE_CTL            CTRL_REG_ADDR(VTGModeCtl)

#define SUSPEND_UNTIL_FRAME_BLANK   (1 << 2)
#define TX_ENHANCED_ENABLE          (1 << 1)

//
// Permedia registers
//

#define APERTURE_ONE            CTRL_REG_ADDR(ApertureOne)
#define APERTURE_TWO            CTRL_REG_ADDR(ApertureTwo)
#define BYPASS_WRITE_MASK       CTRL_REG_ADDR(BypassWriteMask)
#define ROM_CONTROL             CTRL_REG_ADDR(RomControl)
#define BOOT_ADDRESS            CTRL_REG_ADDR(BootAddress)
#define MEM_CONFIG              CTRL_REG_ADDR(MemConfig)
#define CHIP_CONFIG             CTRL_REG_ADDR(ChipConfig)
#define SGRAM_REBOOT            CTRL_REG_ADDR(Reboot)
#define SCREEN_BASE             CTRL_REG_ADDR(ScreenBase)
#define SCREEN_STRIDE           CTRL_REG_ADDR(ScreenStride)
#define H_TOTAL                 CTRL_REG_ADDR(HTotal)
#define HG_END                  CTRL_REG_ADDR(HgEnd)
#define HB_END                  CTRL_REG_ADDR(HbEnd)
#define HS_START                CTRL_REG_ADDR(HsStart)
#define HS_END                  CTRL_REG_ADDR(HsEnd)
#define V_TOTAL                 CTRL_REG_ADDR(VTotal)
#define VB_END                  CTRL_REG_ADDR(VbEnd)
#define VS_START                CTRL_REG_ADDR(VsStart)
#define VS_END                  CTRL_REG_ADDR(VsEnd)
#define VIDEO_CONTROL           CTRL_REG_ADDR(VideoControl)
#define INTERRUPT_LINE          CTRL_REG_ADDR(InterruptLine)
#define DDC_DATA                CTRL_REG_ADDR(DDCData)
#define LINE_COUNT              CTRL_REG_ADDR(LineCount)
#define VIDEO_FIFO_CTL          CTRL_REG_ADDR(VFifoCtl)

//
// Permedia 2 Video Streams registers
//

#define VSTREAM_CONFIG          CTRL_REG_ADDR(VSConfiguration)

// PERMEDIA memory mapped VGA access
#define PERMEDIA_MMVGA_INDEX_REG    ((PVOID)(&(pCtrlRegs->PermediaVgaCtrl[0x3C4])))
#define PERMEDIA_MMVGA_DATA_REG     (&(pCtrlRegs->PermediaVgaCtrl[0x3C5]))
#define PERMEDIA_MMVGA_STAT_REG     (&(pCtrlRegs->PermediaVgaCtrl[0x3DA]))

#define PERMEDIA_VGA_CTRL_INDEX     5
#define PERMEDIA_VGA_ENABLE         (1 << 3)
#define PERMEDIA_VGA_STAT_VSYNC     (1 << 3)

//
// magic bits in the FBMemoryCtl and LBMemoryCtl registers
//

#define LBCTL_RAS_CAS_LOW_MASK      (3 << 3)
#define LBCTL_RAS_CAS_LOW_2_CLK     (0 << 3)
#define LBCTL_RAS_CAS_LOW_3_CLK     (1 << 3)
#define LBCTL_RAS_CAS_LOW_4_CLK     (2 << 3)
#define LBCTL_RAS_CAS_LOW_5_CLK     (3 << 3)

#define LBCTL_RAS_PRECHARGE_MASK    (3 << 5)
#define LBCTL_RAS_PRECHARGE_2_CLK   (0 << 5)
#define LBCTL_RAS_PRECHARGE_3_CLK   (1 << 5)
#define LBCTL_RAS_PRECHARGE_4_CLK   (2 << 5)
#define LBCTL_RAS_PRECHARGE_5_CLK   (3 << 5)

#define LBCTL_CAS_LOW_MASK          (3 << 7)
#define LBCTL_CAS_LOW_1_CLK         (0 << 7)
#define LBCTL_CAS_LOW_2_CLK         (1 << 7)
#define LBCTL_CAS_LOW_3_CLK         (2 << 7)
#define LBCTL_CAS_LOW_4_CLK         (3 << 7)

#define FBCTL_RAS_CAS_LOW_MASK      (3 << 0)
#define FBCTL_RAS_CAS_LOW_2_CLK     (0 << 0)
#define FBCTL_RAS_CAS_LOW_3_CLK     (1 << 0)
#define FBCTL_RAS_CAS_LOW_4_CLK     (2 << 0)
#define FBCTL_RAS_CAS_LOW_5_CLK     (3 << 0)

#define FBCTL_RAS_PRECHARGE_MASK    (3 << 2)
#define FBCTL_RAS_PRECHARGE_2_CLK   (0 << 2)
#define FBCTL_RAS_PRECHARGE_3_CLK   (1 << 2)
#define FBCTL_RAS_PRECHARGE_4_CLK   (2 << 2)
#define FBCTL_RAS_PRECHARGE_5_CLK   (3 << 2)

#define FBCTL_CAS_LOW_MASK          (3 << 4)
#define FBCTL_CAS_LOW_1_CLK         (0 << 4)
#define FBCTL_CAS_LOW_2_CLK         (1 << 4)
#define FBCTL_CAS_LOW_3_CLK         (2 << 4)
#define FBCTL_CAS_LOW_4_CLK         (3 << 4)

//
// DisconnectControl bits
//

#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)
//
// structure of timing data contained in the registry
//
typedef struct {
    USHORT  HTot;   // Hor Total Time
    UCHAR   HFP;    // Hor Front Porch
    UCHAR   HST;    // Hor Sync Time
    UCHAR   HBP;    // Hor Back Porch
    UCHAR   HSP;    // Hor Sync Polarity
    USHORT  VTot;   // Ver Total Time
    UCHAR   VFP;    // Ver Front Porch
    UCHAR   VST;    // Ver Sync Time
    UCHAR   VBP;    // Ver Back Porch
    UCHAR   VSP;    // Ver Sync Polarity
} VESA_TIMING_STANDARD;

//
// Characteristics of each mode
//

typedef struct _P2_VIDEO_MODES {

    // Leave INT10 fields in for later chips which have VGA
    USHORT Int10ModeNumberContiguous;
    USHORT Int10ModeNumberNoncontiguous;
    ULONG ScreenStrideContiguous;
    VIDEO_MODE_INFORMATION ModeInformation;

} P2_VIDEO_MODES, *PP2_VIDEO_MODES;


//
// Mode-set specific information.
//

//
// for a given (frequency x resolution x depth) combination we have:
// frequency x resolution only dependent initialization
// frequency x resolution x depth dependent initialization
// We split these into 2 tables to save space in the driver.
//

typedef struct _frd_tables {
    PULONG FRTable;
    PULONG FRDTable;
} FRDTable;

typedef struct _P2_VIDEO_FREQUENCIES {

    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG ScreenHeight;
    ULONG ScreenFrequency;

    PP2_VIDEO_MODES ModeEntry;
    ULONG ModeIndex;
    UCHAR ModeValid;

    ULONG PixelClock;

} P2_VIDEO_FREQUENCIES, *PP2_VIDEO_FREQUENCIES;

//
// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the display drivers
//

typedef struct _P2_Device_Info {
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    ULONG LocalbufferWidth;
    ULONG ActualDacId;
} P2_Device_Info;

//
// Definition of the IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER
//

typedef struct _LINE_DMA_BUFFER {

    PHYSICAL_ADDRESS    physAddr;       // physical address of DMA buffer
    PVOID               virtAddr;       // mapped virtual address
    ULONG               size;           // size in bytes
    BOOLEAN             cacheEnabled;   // Whether buffer is cached

} LINE_DMA_BUFFER, *PLINE_DMA_BUFFER;

//
// The following are the definition for the LUT cache. The aim of the LUT cache
// is to stop sparkling from occurring, bu only writing those LUT entries that
// have changed to the chip, we can only do this by remembering what is already
// down there. The 'mystify' screen saver on P2 demonstrates the problem.
//

#define LUT_CACHE_INIT()        {VideoPortZeroMemory (&(hwDeviceExtension->LUTCache), sizeof (hwDeviceExtension->LUTCache));}
#define LUT_CACHE_SETSIZE(sz)   {hwDeviceExtension->LUTCache.LUTCache.NumEntries = (sz);}
#define LUT_CACHE_SETFIRST(frst){hwDeviceExtension->LUTCache.LUTCache.FirstEntry = (frst);}

#define LUT_CACHE_SETRGB(idx,zr,zg,zb) {    \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Red   = (UCHAR) (zr); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Green = (UCHAR) (zg); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Blue  = (UCHAR) (zb); \
}

//
// The LUT cache
//

typedef struct {

    VIDEO_CLUT     LUTCache;        // Header  plus 1 LUT entry
    VIDEO_CLUTDATA LUTData [255];   // the other 255 LUT entries

} LUT_CACHE;

#define MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES 10
#define MAX_REGISTER_INITIALIZATION_TABLE_ULONGS (2 * MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES)

//
// Define device extension structure. This is device dependent/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {

    pP2ControlRegMap ctrlRegBase;
    PVOID pFramebuffer;
    PVOID pRamdac;
    PHYSICAL_ADDRESS PhysicalFrameAddress;
    ULONG FrameLength;
    PHYSICAL_ADDRESS PhysicalRegisterAddress;
    ULONG RegisterLength;
    UCHAR RegisterSpace;

    PP2_VIDEO_MODES ActiveModeEntry;
    P2_VIDEO_FREQUENCIES ActiveFrequencyEntry;
    PP2_VIDEO_FREQUENCIES FrequencyTable;

    PCI_SLOT_NUMBER pciSlot;
    ULONG pciBus;
    ULONG BoardNumber;
    ULONG DacId;
    ULONG ChipClockSpeed;
    ULONG RefClockSpeed;
    ULONG Capabilities;
    ULONG NumAvailableModes;
    ULONG NumTotalModes;
    ULONG AdapterMemorySize;
    ULONG PhysicalFrameIoSpace;

    P2_Device_Info deviceInfo;

    //
    // Shared memory for communications with the display driver
    //

    P2_INTERRUPT_CTRLBUF InterruptControl;

    //
    // defaults for registry variable values
    //

    ULONG UseSoftwareCursor;
    ULONG P28bppRGB;
    ULONG ExportNon3DModes;
    
    //
    // DMA Buffer definition
    // allocate only one copy of DMA buffer at start of day
    // and keep it until system is shut down or display drivers say goodbye
    //

    ULONG ulLineDMABufferUsage;
    LINE_DMA_BUFFER LineDMABuffer;

    //
    // PCI Config Information
    //

    ULONG bVGAEnabled;
    ULONG bDMAEnabled;
    ULONG PciSpeed;
    VIDEO_ACCESS_RANGE    PciAccessRange[PCI_TYPE0_ADDRESSES+1];

    //
    // Initialisation table
    //

    ULONG aulInitializationTable[MAX_REGISTER_INITIALIZATION_TABLE_ULONGS];
    ULONG culTableEntries;

    //
    // LUT cache
    //

    LUT_CACHE LUTCache;

    BOOLEAN bVTGRunning;
    PP2_VIDEO_FREQUENCIES pFrequencyDefault;

    //
    // state save variables (for during power-saving)
    //

    ULONG VideoControl;
    ULONG IntEnable;       
    ULONG PreviousPowerState;

    BOOLEAN bMonitorPoweredOn;

    //
    // current NT version 
    //

    USHORT NtVersion;
  
    //
    // pointers of VideoPort function that not available on NT4
    //

    PVOID     (*Win2kVideoPortGetRomImage)();
    PVOID     (*Win2kVideoPortGetCommonBuffer)();
    PVOID     (*Win2kVideoPortFreeCommonBuffer)();
    BOOLEAN   (*Win2kVideoPortDDCMonitorHelper)();
    LONG      (FASTCALL *Win2kVideoPortInterlockedExchange)();
    VP_STATUS (*Win2kVideoPortGetVgaStatus)();

    //
    // if the SubSystemId/SubVendorId in PCI config space are read only
    //
    
    BOOLEAN HardwiredSubSystemId;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// definitions for the purpose of binary level compatable with NT4 
//

#define NT4    400
#define WIN2K  500

#define VideoPortGetRomImage \
        hwDeviceExtension->Win2kVideoPortGetRomImage

#define VideoPortGetCommonBuffer \
        hwDeviceExtension->Win2kVideoPortGetCommonBuffer

#define VideoPortFreeCommonBuffer \
        hwDeviceExtension->Win2kVideoPortFreeCommonBuffer

#define VideoPortDDCMonitorHelper \
        hwDeviceExtension->Win2kVideoPortDDCMonitorHelper

#define VideoPortInterlockedExchange \
        hwDeviceExtension->Win2kVideoPortInterlockedExchange

#define VideoPortGetVgaStatus \
        hwDeviceExtension->Win2kVideoPortGetVgaStatus

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (VIDEO_MAX_COLOR_REGISTER+1)))


//
// Data
//

extern ULONG  bPal8[];
extern ULONG  bPal4[];

extern P2_VIDEO_MODES P2Modes[];
extern ULONG NumP2VideoModes;

//
// Permedia2 Legacy Resources
//
extern VIDEO_ACCESS_RANGE P2LegacyResourceList[];
extern ULONG P2LegacyResourceEntries;

//
// Function prototypes
//

//
// permedia.c
//

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PP2_VIDEO_FREQUENCIES VideoMode
    );

BOOLEAN
Permedia2AssignResources(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    );

BOOLEAN
Permedia2AssignResourcesNT4(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    );

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    );

VP_STATUS
Permedia2FindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
     );

BOOLEAN
InitializeAndSizeRAM(
    PVOID HwDeviceExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    );

VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
Permedia2Initialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
Permedia2StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
Permedia2ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

VP_STATUS
Permedia2GetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

VP_STATUS
Permedia2SetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

ULONG
Permedia2GetChildDescriptor (
    IN  PVOID HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE pChildType,
    OUT PVOID  pChildDescriptor,
    OUT PULONG pUId,
    OUT PULONG pUnused
    );

BOOLEAN
PowerOnReset(
            PHW_DEVICE_EXTENSION hwDeviceExtension
            );

VP_STATUS
Permedia2SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    );

VP_STATUS
Permedia2RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
Permedia2RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VOID
Permedia2GetClockSpeeds(
    PVOID HwDeviceExtension
    );

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG RequestedMode
    );

BOOLEAN
Permedia2InitializeInterruptBlock(
    PVOID   HwDeviceExtension
    );

BOOLEAN
Permedia2VidInterrupt(
    PVOID HwDeviceExtension
    );

BOOLEAN
Permedia2InitializeDMABuffers(
    PVOID   HwDeviceExtension
    );

BOOLEAN 
DMAExecute(PVOID Context);

#if DBG
VOID
DumpPCIConfigSpace(
    PVOID HwDeviceExtension,
    ULONG bus,
    ULONG slot
    );
#endif

VOID 
CopyROMInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
GenerateInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
VerifyBiosSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    );

LONG 
IntergerToUnicode(
    IN ULONG number,
    OUT PWSTR string
    );

LONG
GetBiosVersion (
     PHW_DEVICE_EXTENSION hwDeviceExtension,
     OUT PWSTR BiosVersion
     );

#if defined(_ALPHA_)
#define abs(a) ( ((LONG)(a)) > 0 ? ((LONG)(a)) : -((LONG)(a)) )
#endif


BOOLEAN 
GetVideoTiming (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD * VESATimings
    );

LONG BuildFrequencyList (
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

//
// Registry Strings
//

#define PERM2_EXPORT_HIRES_REG_STRING   L"ExportSingleBufferedModes"

#define IOCTL_VIDEO_MAP_CPERMEDIA \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_STALL_EXECUTION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDB, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SLEEP \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDF, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD6, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\power.c ===
//***************************************************************************
//
// Module Name:
//
//   power.c
//
// Abstract:
//   This module contains the code that implements the Plug & Play and 
//   power management features
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#define VESA_POWER_FUNCTION   0x4f10
#define VESA_POWER_ON         0x0000
#define VESA_POWER_STANDBY    0x0100
#define VESA_POWER_SUSPEND    0x0200
#define VESA_POWER_OFF        0x0400
#define VESA_GET_POWER_FUNC   0x0000
#define VESA_SET_POWER_FUNC   0x0001
#define VESA_STATUS_SUCCESS   0x004f

//
// all our IDs begin with 0x1357bd so they are readily identifiable as our own
//

#define P2_DDC_MONITOR        (0x1357bd00)
#define P2_NONDDC_MONITOR     (0x1357bd01)

BOOLEAN PowerOnReset( PHW_DEVICE_EXTENSION hwDeviceExtension );
VOID    SaveDeviceState( PHW_DEVICE_EXTENSION hwDeviceExtension );
VOID    RestoreDeviceState( PHW_DEVICE_EXTENSION hwDeviceExtension );

VOID    I2CWriteClock(PVOID HwDeviceExtension, UCHAR data);
VOID    I2CWriteData(PVOID HwDeviceExtension, UCHAR data);
BOOLEAN I2CReadClock(PVOID HwDeviceExtension);
BOOLEAN I2CReadData(PVOID HwDeviceExtension);
VOID    I2CWaitVSync(PVOID HwDeviceExtension);

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, PowerOnReset)
#pragma alloc_text(PAGE, SaveDeviceState)
#pragma alloc_text(PAGE, RestoreDeviceState)
#pragma alloc_text(PAGE, Permedia2GetPowerState)
#pragma alloc_text(PAGE, Permedia2SetPowerState)
#pragma alloc_text(PAGE, Permedia2GetChildDescriptor)
#pragma alloc_text(PAGE, I2CWriteClock) 
#pragma alloc_text(PAGE, I2CWriteData) 
#pragma alloc_text(PAGE, I2CReadClock) 
#pragma alloc_text(PAGE, I2CReadData)  
#pragma alloc_text(PAGE, I2CWaitVSync)
#endif


I2C_FNC_TABLE I2CFunctionTable = 
{
    sizeof(I2C_FNC_TABLE), 
    I2CWriteClock, 
    I2CWriteData, 
    I2CReadClock, 
    I2CReadData,  
    I2CWaitVSync, 
    NULL
};


VP_STATUS Permedia2GetPowerState (
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl 
    )

/*++

Routine Description:

    Returns power state information.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.

    HwId                 - Private unique 32 bit ID identifing the device.

    VideoPowerControl    - Points to a VIDEO_POWER_MANAGEMENT structure that 
                           specifies the power state for which support is 
                           being queried. 

Return Value:

    VP_STATUS value (NO_ERROR or error value)

--*/

{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DEBUG_PRINT((2, "Permedia2GetPowerState: hwId(%xh) state = %d\n", 
                     (int)HwId, (int)VideoPowerControl->PowerState));

    switch((int)HwId)
    {
        case P2_DDC_MONITOR:
        case P2_NONDDC_MONITOR:

            switch (VideoPowerControl->PowerState)
            {

                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:
                case VideoPowerShutdown:

                    status = NO_ERROR;
                    break;

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown monitor PowerState(%xh)\n", 
                                    (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }
            break;

        case DISPLAY_ADAPTER_HW_ID:

            //
            // only support ON at the moment
            //

            switch (VideoPowerControl->PowerState)
            {
                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerHibernate:
                case VideoPowerShutdown:
                    status = NO_ERROR;
                    break;

                case VideoPowerOff:

                    if( hwDeviceExtension->HardwiredSubSystemId )
                    {
                        status = NO_ERROR;
                    } 
                    else
                    {
                        //
                        // If SubSystemId is not hardwired in a read-only way, 
                        // it is possible we'll see a different value when 
                        // system comes back form S3 mode. This will cause 
                        // problem since os will assume this is a different 
                        // device 
                        //

                        DEBUG_PRINT((2, "Permedia2GetPowerState: VideoPowerOff is not suported by this card!\n"));
 
                        status = ERROR_INVALID_FUNCTION;
                    }

                    break;
 

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown adapter PowerState(%xh)\n", 
                                 (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);

                    status = ERROR_INVALID_PARAMETER;

            }
            break;

        default:

            DEBUG_PRINT((1, "Permedia2GetPowerState: Unknown hwId(%xh)", 
                            (int)HwId));
            ASSERT(FALSE);

            status = ERROR_INVALID_PARAMETER;
    }

    DEBUG_PRINT((2, "Permedia2GetPowerState: returning %xh\n", status));

    return(status);
}

VP_STATUS Permedia2SetPowerState ( 
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwId              - Private unique 32 bit ID identifing the device.

    VideoPowerControl - Points to a VIDEO_POWER_MANAGEMENT structure that 
                        specifies the power state to be set. 

Return Value:

    VP_STATUS value (NO_ERROR, if all's well)

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Polarity;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;
    P2_DECL;

    DEBUG_PRINT((2, "Permedia2SetPowerState: hwId(%xh) state = %d\n", 
                     (int)HwId, (int)VideoPowerControl->PowerState));

    switch((int)HwId)
    {

        case P2_DDC_MONITOR:
        case P2_NONDDC_MONITOR:

            Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);

            Polarity &= ~((1 << 5) | (1 << 3) | 1);

            switch (VideoPowerControl->PowerState)
            {

                case VideoPowerHibernate:
                case VideoPowerShutdown:

                    //
                    // Do nothing for hibernate as the monitor must stay on.
                    //

                    status = NO_ERROR;
                    break;

                case VideoPowerOn:

                    RestoreDeviceState(hwDeviceExtension);
                    status = NO_ERROR;
                    break;

                case VideoPowerStandBy:

                    //
                    // hsync low, vsync active high, video disabled
                    //

                    SaveDeviceState(hwDeviceExtension);
                    VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                Polarity | (1 << 5) | (2 << 3) | 0);

                    status = NO_ERROR;
                    break;

                case VideoPowerSuspend:

                    //
                    // vsync low, hsync active high, video disabled
                    //

                    VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                Polarity | (2 << 5) | (1 << 3) | 0);

                    status = NO_ERROR;
                    break;

                case VideoPowerOff:

                    //
                    // vsync low, hsync low, video disabled
                    //

                    VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                Polarity | (2 << 5) | (2 << 3) | 0);

                    status = NO_ERROR;
                    break;

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown monitor PowerState(%xh)\n", 
                                     (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            //
            // Track the current monitor power state
            //

            hwDeviceExtension->bMonitorPoweredOn =
                (VideoPowerControl->PowerState == VideoPowerOn) ||
                (VideoPowerControl->PowerState == VideoPowerHibernate);

            Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);

            break;

        case DISPLAY_ADAPTER_HW_ID:

            switch (VideoPowerControl->PowerState)
            {
                case VideoPowerHibernate:
                    status = NO_ERROR;
                    break;

                case VideoPowerShutdown:

                    //
                    // We need to make sure no interrupts will be generated
                    // after the device being powered down
                    //

                    VideoPortWriteRegisterUlong(INT_ENABLE, 0);

                    status = NO_ERROR;
                    break;

                case VideoPowerOn:

                    if ((hwDeviceExtension->PreviousPowerState == VideoPowerOff) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerSuspend) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerHibernate))
                    {
                        PowerOnReset(hwDeviceExtension);
                    }

                    status = NO_ERROR;
                    break;

                case VideoPowerStandBy:

                    status = NO_ERROR;
                    break;

                case VideoPowerSuspend:

                    status = NO_ERROR;
                    break;
    
                case VideoPowerOff:

                    status = NO_ERROR;
                    break;

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown adapter PowerState(%xh)\n", 
                                     (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            hwDeviceExtension->PreviousPowerState = 
                    VideoPowerControl->PowerState;

            break;
    
        default:

            DEBUG_PRINT((1, "Permedia2SetPowerState: Unknown hwId(%xh)\n", 
                             (int)HwId));

            ASSERT(FALSE);
            status = ERROR_INVALID_PARAMETER;
    }

    return(status);

}


BOOLEAN PowerOnReset(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

Routine Description:

   Called when the adapter is powered on 

--*/

{
    int      i;
    ULONG    ulValue;
    BOOLEAN  bOK;
    P2_DECL;

    if(!hwDeviceExtension->bVGAEnabled ||
       !hwDeviceExtension->bDMAEnabled)
    {
        PCI_COMMON_CONFIG  PciData;

        //
        // in a multi-adapter system we'll need to turn on the DMA and 
        // memory space for the secondary adapters
        //

        DEBUG_PRINT((1, "PowerOnReset() enabling memory space access for the secondary card\n"));

        VideoPortGetBusData( hwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             &PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH);

        PciData.Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData.Command |= PCI_ENABLE_BUS_MASTER; 

        VideoPortSetBusData( hwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             &PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH );

#if DBG
        DumpPCIConfigSpace(hwDeviceExtension, hwDeviceExtension->pciBus, 
                            (ULONG)hwDeviceExtension->pciSlot.u.AsULONG);
#endif

    }

    //
    // While waking up from hibernation, we usually don't need
    // to reset perm2 and call ProcessInitializationTable()
    // for the primary card since video bios will get posted. 
    // We do so here because we saw cases that the perm2 bios 
    // failed to worked correctly on some machines. 
    //

    //
    // reset the device
    //

    VideoPortWriteRegisterUlong(RESET_STATUS, 0);

    for(i = 0; i < 100000; ++i)
    {
        ulValue = VideoPortReadRegisterUlong(RESET_STATUS);

        if (ulValue == 0)
            break;
    }

    if(ulValue)
    {
        DEBUG_PRINT((1, "PowerOnReset() Read RESET_STATUS(%xh) - failed to reset\n", 
                         ulValue));

        ASSERT(FALSE);
        bOK = FALSE;
    }
    else
    {
        //
        // reload registers given in ROM
        //

        if(hwDeviceExtension->culTableEntries)
        {
            ProcessInitializationTable(hwDeviceExtension);
        }

        //
        // set-up other registers not set in InitializeVideo
        //

        VideoPortWriteRegisterUlong(BYPASS_WRITE_MASK, 0xFFFFFFFF);
        VideoPortWriteRegisterUlong(APERTURE_ONE, 0x0);
        VideoPortWriteRegisterUlong(APERTURE_TWO, 0x0);    

        bOK = TRUE;

    }

    return(bOK);

}


VOID SaveDeviceState(PHW_DEVICE_EXTENSION hwDeviceExtension)

/*++

Routine Description:

    Save any registers that will be destroyed when we power down the monitor

--*/

{
    P2_DECL;

    DEBUG_PRINT((2, "SaveDeviceState() called\n"));
    
    //
    // hwDeviceExtension->VideoControl should be set in InitializeVideo,
    // just in case we get here before InitializeVideo
    //

    if( !(hwDeviceExtension->VideoControl) )
    {
        hwDeviceExtension->VideoControl = 
               VideoPortReadRegisterUlong(VIDEO_CONTROL);
    }

    hwDeviceExtension->IntEnable = VideoPortReadRegisterUlong(INT_ENABLE);

}


VOID RestoreDeviceState(PHW_DEVICE_EXTENSION hwDeviceExtension)

/*++

Routine Description:

    Restore registers saved before monitor power down

--*/

{
    P2_DECL;

    DEBUG_PRINT((2, "RestoreDeviceState() called\n"));
    VideoPortWriteRegisterUlong(VIDEO_CONTROL, hwDeviceExtension->VideoControl);
    VideoPortWriteRegisterUlong(INT_ENABLE, hwDeviceExtension->IntEnable);

}


ULONG
Permedia2GetChildDescriptor( 
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,  
    PVOID pChildDescriptor, 
    PULONG pUId, 
    PULONG pUnused )


/*++

Routine Description:

    Enumerate all child devices controlled by the Permedia 2 chip.

    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension -
        Pointer to our hardware device extension structure.

    ChildEnumInfo - 
        Information about the device that should be enumerated.

    pChildType -
        Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor -
        Identification structure of the device (EDID, string)

    pUId -
        Private unique 32 bit ID to passed back to the miniport

    pUnused -
        Do not use

Return Value:

    ERROR_NO_MORE_DEVICES -
        if no more child devices exist.

    ERROR_INVALID_NAME -
        The miniport could not enumerate the child device identified in 
        ChildEnumInfo but does have more devices to be enumerated. 

    ERROR_MORE_DATA - 
        There are more devices to be enumerated. 

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/


{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DEBUG_PRINT((2, "Permedia2GetChildDescriptor called\n"));

    switch (ChildEnumInfo->ChildIndex) 
    {
        case 0:

            //
            // Case 0 is used to enumerate devices found by the ACPI firmware.
            // We do not currently support ACPI devices
            //

            return ERROR_NO_MORE_DEVICES;

        case 1:

            //
            // Treat index 1 as the monitor
            //

            *pChildType = Monitor;

            //
            // if it's a DDC monitor we return its EDID in pjBuffer
            // (always 128 bytes)
            //

            if(VideoPortDDCMonitorHelper(HwDeviceExtension,
                                         &I2CFunctionTable,
                                         pChildDescriptor,
                                         ChildEnumInfo->ChildDescriptorSize))
            {
                //
                // found a DDC monitor
                //

                DEBUG_PRINT((2, "Permedia2GetChildDescriptor: found a DDC monitor\n"));

                *pUId = P2_DDC_MONITOR;
            }
            else
            {
                //
                // failed: assume non-DDC monitor
                //

                DEBUG_PRINT((2, "Permedia2GetChildDescriptor: found a non-DDC monitor\n"));

                *pUId = P2_NONDDC_MONITOR;

            }

            return ERROR_MORE_DATA;

        default:

            return ERROR_NO_MORE_DEVICES;
    }
}


VOID I2CWriteClock(PVOID HwDeviceExtension, UCHAR data)
{
    const ULONG nbitClock = 3;
    const ULONG Clock = 1 << nbitClock;

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~Clock;
    ul |= (data & 1) << nbitClock;
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

VOID I2CWriteData(PVOID HwDeviceExtension, UCHAR data)
{
    const ULONG nbitData = 2;
    const ULONG Data = 1 << nbitData;

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~Data;
    ul |= ((data & 1) << nbitData);
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

BOOLEAN I2CReadClock(PVOID HwDeviceExtension)
{
    const ULONG nbitClock = 1;
    const ULONG Clock = 1 << nbitClock;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= Clock;
    ul >>= nbitClock;

    return((BOOLEAN)ul);
}

BOOLEAN I2CReadData(PVOID HwDeviceExtension)
{
    const ULONG nbitData = 0;
    const ULONG Data = 1 << nbitData;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= Data;
    ul >>= nbitData;
    return((BOOLEAN)ul);
}

VOID I2CWaitVSync(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jIndexSaved, jStatus;
    P2_DECL;
    
    if(hwDeviceExtension->bVGAEnabled)
    {

        //
        // VGA run on this board, is it currently in VGA or VTG mode?
        //

        jIndexSaved = VideoPortReadRegisterUchar(PERMEDIA_MMVGA_INDEX_REG);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, 
                                    PERMEDIA_VGA_CTRL_INDEX);

        jStatus = VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, jIndexSaved);

    }
    else
    {
        //
        // VGA not run
        //

        jStatus = 0;

    }

    
    if(jStatus & PERMEDIA_VGA_ENABLE)
    {
        //
        // in VGA, so check VSync via the VGA registers
        // 1. if we're in VSync, wait for it to end
        //

        while( (VideoPortReadRegisterUchar(PERMEDIA_MMVGA_STAT_REG) & 
                PERMEDIA_VGA_STAT_VSYNC) == 1); 

        //
        // 2. wait for the start of VSync
        //

        while( (VideoPortReadRegisterUchar(PERMEDIA_MMVGA_STAT_REG) & 
                PERMEDIA_VGA_STAT_VSYNC) == 0); 
    }
    else
    {
        if(!hwDeviceExtension->bVTGRunning)
        {

            //
            // time to set-up the VTG - we'll need a valid mode to do this, 
            // so we;ll choose 640x480x8 we get here (at boot-up only) if 
            // the secondary card has VGA disabled: GetChildDescriptor is 
            // called before InitializeVideo so that the VTG hasn't been 
            // programmed yet
            //

            DEBUG_PRINT((2, "I2CWaitVSync() - VGA nor VTG running: attempting to setup VTG\n"));

            if(hwDeviceExtension->pFrequencyDefault == NULL)
            {
                DEBUG_PRINT((1, "I2CWaitVSync() - no valid modes to use: can't set-up VTG\n"));
                return;
            }

            Permedia2GetClockSpeeds(HwDeviceExtension);
            ZeroMemAndDac(hwDeviceExtension, 0);

            if (!InitializeVideo( HwDeviceExtension, 
                                  hwDeviceExtension->pFrequencyDefault) )
            {
                DEBUG_PRINT((1, "I2CWaitVSync() - InitializeVideo failed\n"));
                return;
            }        
        }

        //
        // VTG has been set-up: check via the control registers
        //

        VideoPortWriteRegisterUlong ( INT_FLAGS, 
                                      INTR_VBLANK_SET );

        while (( (VideoPortReadRegisterUlong (INT_FLAGS) ) & 
                 INTR_VBLANK_SET ) == 0 ); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\video.c ===
//***************************************************************************
//
// Module Name:
//
//   video.c
//
// Abstract:
//
//   This module contains the code to setup the timing values for chips
//   and RAMDACs
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

VOID CheckRGBClockInteraction(PULONG PixelClock, PULONG SystemClock);

ULONG TVP4020_CalculateMNPForClock(PVOID HwDeviceExtension, 
                                   ULONG RefClock, 
                                   ULONG ReqClock, 
                                   BOOLEAN IsPixClock, 
                                   ULONG MinClock, 
                                   ULONG MaxClock, 
                                   ULONG *rM, 
                                   ULONG *rN, 
                                   ULONG *rP);

ULONG Dac_SeparateClocks(ULONG PixelClock, ULONG SystemClock);   

BOOLEAN InitializeVideo(PHW_DEVICE_EXTENSION HwDeviceExtension, 
                        PP2_VIDEO_FREQUENCIES VideoMode);

ULONG P2RD_CalculateMNPForClock(PVOID HwDeviceExtension, 
                                ULONG RefClock, 
                                ULONG ReqClock, 
                                ULONG *rM, 
                                ULONG *rN, 
                                ULONG *rP);

BOOLEAN Program_P2RD(PHW_DEVICE_EXTENSION HwDeviceExtension, 
                     PP2_VIDEO_FREQUENCIES VideoMode,  
                     ULONG Hsp, 
                     ULONG Vsp,
                     ULONG RefClkSpeed, 
                     PULONG pSystemClock, 
                     PULONG pPixelClock);

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,CheckRGBClockInteraction)
#pragma alloc_text(PAGE,TVP4020_CalculateMNPForClock)
#pragma alloc_text(PAGE,Dac_SeparateClocks)
#pragma alloc_text(PAGE,InitializeVideo)
#pragma alloc_text(PAGE,P2RD_CalculateMNPForClock)
#pragma alloc_text(PAGE,Program_P2RD)
#endif

VOID
CheckRGBClockInteraction(
    PULONG PixelClock,
    PULONG SystemClock
    )
/*++

Routine Description:

    Ensure the output frequencies do not interract. The following must be true
        fHigher != n*fLower +/- 3MHz,   for all N >= 1
    3MHz is the safe limit. 2MHz is sufficient.

Arguments:

    PixelClock - Pointer to the clock rate for pixel output.

    SystemClock - Pointer to the clock rate driving the Permedia2.

Return Value:

    If the clocks interact then they are adjusted and returned in the pointer
    values.

--*/

{
    PLONG fLower, fHigher;
    LONG nfLower;

    if (*PixelClock < *SystemClock)
    {
        fLower  = PixelClock;
        fHigher = SystemClock;
    }
    else
    {
        fLower  = SystemClock;
        fHigher = PixelClock;
    }

    while (TRUE)
    {
        nfLower = *fLower;

        while (nfLower - 20000 <= *fHigher)
        {
            if (*fHigher <= (nfLower + 20000))
            {
                //
                // 100KHz adjustments
                //

                if (*fHigher > nfLower)
                {
                    *fLower  -= 1000;
                    *fHigher += 1000;
                }
                else
                {
                    *fLower  += 1000;
                    *fHigher -= 1000;
                }
                break;
            }
            nfLower += *fLower;
        }
        if ((nfLower - 20000) > *fHigher)
            break;
    }
}


#define INITIALFREQERR 100000

ULONG
TVP4020_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,     // In 100Hz units
    ULONG ReqClock,     // In 100Hz units
    BOOLEAN IsPixClock, // is this the pixel or the sys clock
    ULONG MinClock,     // Min VCO rating
    ULONG MaxClock,     // Max VCO rating
    ULONG *rM,          // M Out
    ULONG *rN,          // N Out
    ULONG *rP           // P Out
    )
{
    ULONG   M, N, P;
    ULONG   VCO, Clock;
    LONG    freqErr, lowestFreqErr = INITIALFREQERR;
    ULONG   ActualClock = 0;

    for (N = 2; N <= 14; N++) 
    {
        for (M = 2; M <= 255; M++) 
        {
            VCO = ((RefClock * M) / N);

            if ((VCO < MinClock) || (VCO > MaxClock))
                continue;

            for (P = 0; P <= 4; P++) 
            {
                Clock = VCO >> P;

                freqErr = (Clock - ReqClock);

                if (freqErr < 0)
                {
                    //   
                    // PixelClock gets rounded up always so monitor reports
                    // correct frequency. 
                    // TMM: I have changed this because it causes our refresh
                    // rate to be incorrect and some DirectDraw waitForVBlank 
                    // tests fail.
                    // if (IsPixClock)
                    //      continue;
                    //

                    freqErr = -freqErr;
                }

                if (freqErr < lowestFreqErr) 
                { 
                    // 
                    // Only replace if error is less; keep N small!
                    // 

                    *rM = M;
                    *rN = N;
                    *rP = P;

                    ActualClock   = Clock;
                    lowestFreqErr = freqErr;

                    // 
                    // Return if we found an exact match
                    // 

                    if (freqErr == 0)
                        return(ActualClock);
                }
            }
        }
    }

    return(ActualClock);
}


ULONG Dac_SeparateClocks(ULONG PixelClock, ULONG SystemClock)
{
    ULONG   M, N, P;

    //
    // Ensure frequencies do not interract
    //

    P = 1;

    do 
    {
        M = P * SystemClock;
        if ((M > PixelClock - 10000) && (M < PixelClock + 10000)) 
        {
            //
            // Frequencies do interract. We can either change the
            // PixelClock or change the System clock to avoid it.
            //

            SystemClock = (PixelClock - 10000) / P;

        }

        N = P * PixelClock;

        if ((N > SystemClock - 10000) && (N < SystemClock + 10000)) 
        {
            //
            // Frequencies do interract. We can either change the
            // PixelClock or change the System clock to avoid it.
            //

            SystemClock = N - 10000;

        }

        P++;

    } while ((M < PixelClock + 30000) || (N < SystemClock + 30000));

    return (SystemClock);
}

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PP2_VIDEO_FREQUENCIES VideoMode
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    ULONG   index;
    ULONG   color;
    ULONG   ulValue;
    ULONG   ulValue1;
    UCHAR   pixelCtrl;
    UCHAR   pixelFormat;
    ULONG   dShift;
    VESA_TIMING_STANDARD    VESATimings;
    ULONG   Htot, Hss, Hse, Hbe, Hsp;
    ULONG   Vtot, Vss, Vse, Vbe, Vsp;
    ULONG   PixelClock, Freq;
    ULONG   VCO;
    ULONG   RefClkSpeed, SystemClock;   // Speed of clocks in 100Hz units
    ULONG   VTGPolarity;
    ULONG   M, N, P, C, Q;
    LONG    gateAdjust;
    BOOLEAN SecondTry;
    USHORT  usData;
    ULONG   DacDepth, depth, xRes, yRes;
    ULONG   xStride;
    ULONG   ClrComp5, ClrComp6;
    ULONG   pixelData;

    P2_DECL;
    TVP4020_DECL;

    depth   = VideoMode->BitsPerPel;
    xRes    = VideoMode->ScreenWidth;
    yRes    = VideoMode->ScreenHeight;
    Freq    = VideoMode->ScreenFrequency;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15)
    {
        DacDepth = 16;
    }
    else if (depth == 12)  
    {
        DacDepth = 32;
    }

    //
    // convert screen stride from bytes to pixels
    //

    xStride = (8 * VideoModeInfo->ScreenStride) / DacDepth;

    //
    // Ensure minimum frequency of 60 Hz
    //

    if (Freq < 60)
    {
        DEBUG_PRINT((2, "Frequency raised to minimum of 60Hz\n"));
        Freq = 60;
    }

    DEBUG_PRINT((2, "depth %d, xres %d, yres %d, freq %d\n",
                            depth, xRes, yRes, Freq));

    //
    // Get the video timing, from the registry, if an entry exists, or from
    // the list of defaults, if it doesn't.
    //

    if (!GetVideoTiming ( HwDeviceExtension, 
                          xRes, 
                          yRes,  
                          Freq, 
                          depth, 
                          &VESATimings ))
    {
        DEBUG_PRINT((1, "GetVideoTiming failed."));
        return (FALSE);
    }

    //
    // We have got a valid set of VESA timigs
    //

    Htot =  VESATimings.HTot;
    Hss  =  VESATimings.HFP ;
    Hse  =  Hss + VESATimings.HST;
    Hbe  =  Hse + VESATimings.HBP;
    Hsp  =  VESATimings.HSP;
    Vtot =  VESATimings.VTot;
    Vss  =  VESATimings.VFP ;
    Vse  =  Vss + VESATimings.VST;
    Vbe  =  Vse + VESATimings.VBP;
    Vsp  =  VESATimings.VSP;

    //
    // if we're zooming by 2 in Y then double the vertical timing values.
    //

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2)
    {
        Vtot *= 2;
        Vss  *= 2;
        Vse  *= 2;
        Vbe  *= 2;
    }

    //
    // Calculate Pixel Clock in 100 Hz units
    //

    PixelClock = (Htot * Vtot * Freq * 8) / 100;
    pixelData = PixelClock * (DacDepth / 8);

    if (pixelData > P2_MAX_PIXELDATA)
    {
        //
        // Failed pixelData validation
        //

        return (FALSE);

    }

    RefClkSpeed = hwDeviceExtension->RefClockSpeed  / 100;   // 100Hz units
    SystemClock = hwDeviceExtension->ChipClockSpeed / 100;   // 100Hz units

    //
    // We do some basic initialization before setting up MCLK.
    //

    //
    // disable the video control register
    //

    hwDeviceExtension->bVTGRunning = FALSE;
    hwDeviceExtension->VideoControl = 0;
    VideoPortWriteRegisterUlong( VIDEO_CONTROL, 
                                 hwDeviceExtension->VideoControl );

    //
    // Enable graphics mode, disable VGA
    //

    VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, 
                                 PERMEDIA_VGA_CTRL_INDEX);

    usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);

    usData &= ~PERMEDIA_VGA_ENABLE;
    usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;

    VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

    //
    // Setup Ramdac.
    //

    if (hwDeviceExtension->DacId == TVP4020_RAMDAC)
    {
        //
        // No separate S/W reset for P2 pixel unit
        //

        //
        // 1x64x64, cursor 1, ADDR[9:8] = 00, cursor off
        //

        TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, 0x40);

        //
        // Redundant here; we just cleared the CCR above
        //

        TVP4020_LOAD_CURSOR_CTRL(TVP4020_CURSOR_OFF);   

        TVP4020_SET_CURSOR_COLOR0(0, 0, 0);
        TVP4020_SET_CURSOR_COLOR1(0xFF, 0xFF, 0xFF);

        //
        // P2 sets the sync polarity in the RAMDAC rather than VideoControl
        // 7.5 IRE, 8-bit data
        //

        ulValue = ((Hsp ? 0x0 : 0x1) << 2) | ((Vsp ? 0x0 : 0x1) << 3) | 0x12;

        TVP4020_WRITE_INDEX_REG(__TVP4020_MISC_CONTROL, ulValue);
        TVP4020_WRITE_INDEX_REG(__TVP4020_MODE_CONTROL, 0x00);  // Mode Control
        TVP4020_WRITE_INDEX_REG(__TVP4020_CK_CONTROL,   0x00);  // Color-Key Control
        TVP4020_WRITE_INDEX_REG(__TVP4020_PALETTE_PAGE, 0x00);  // Palette page

        //
        // No zoom on P2 pixel unit
        //
        // No separate multiplex control on P2 pixel unit
        //
        // Start TI TVP4020 programming
        //

        switch (depth)
        {
            case 8:

                //
                // RGB, graphics, Color Index 8
                //

                TVP4020_WRITE_INDEX_REG(__TVP4020_COLOR_MODE, 0x30);  

                if( hwDeviceExtension->Capabilities & CAPS_8BPP_RGB )
                {
                    ULONG   Red, Green, Blue ;

                    //
                    // load BGR 2:3:3 ramp into LUT
                    //

                    for (index = 0; index <= 0xff; ++index)
                    {
                        Red   = bPal8[index & 0x07];
                        Green = bPal8[(index >> 3 ) &0x07];
                        Blue  = bPal4[(index >> 6 ) &0x03];

                        // 
                        // EXTRA!! EXTRA!! EXTRA!!!
                        //  After more research on more pleasing appearance
                        //  we now added more grays, now we look not only for 
                        //  EXACT match of RED and GREEN, we consider it gray 
                        //  even when they differ by 1.
                        //  Added  15-Jan-1996  -by-  [olegsher]
                        // 
                        // Maybe it's a special case of gray ?
                        // 

                        if (abs((index & 0x07) - ((index >> 3 ) &0x07)) <= 1)
                        {
                            //
                            // This is a tricky part:
                            //  the Blue field in BGR 2:3:3 color goes thru 
                            //  steps 00, 01, 10, 11 (Binary)
                            //  
                            //  the Red and Green go thru 000, 001, 010, 011, 
                            //  100, 101, 110, 111 (Binary)
                            //  
                            //  We load the special gray values ONLY when Blue 
                            //  color is close in intensity to both Green and Red, 
                            //  i.e.    Blue = 01, Green = 010 or 011,
                            //          Blue = 10, Green = 100 or 101,
                            //  
    
                            if ((((index >> 1) & 0x03) == ((index >> 6 ) & 0x03 )) ||
                                 (((index >> 4) & 0x03) == ((index >> 6 ) & 0x03 )) ||
                                 ((Green == Red) && ( abs((index & 0x07) - ((index >> 5) & 0x06)) <= 1 )))
                            {
                                if( Blue || (Green == Red)) // Don't mess with dark colors
                                {
                                    color = (Red * 2 + Green * 3 + Blue) / 6;
                                    Red = Green = Blue = color;
                                }
                            }
                        }
                    
                        LUT_CACHE_SETRGB (index, Red, Green, Blue);
                    }
                }
                else
                {
                    for (index = 0; index <= 0xff; ++index)
                        LUT_CACHE_SETRGB (index, index, index, index);
                }
                break;

            case 15:
            case 16:

                //       
                // True color w/gamma, RGB, graphics, 5:5:5:1
                //       

                pixelCtrl = 0xB4; 

                //       
                // True-color w/gamma, RGB, graphics, 5:6:5
                //       

                if (depth == 16)
                    pixelCtrl |= 0x02;

                TVP4020_WRITE_INDEX_REG(__TVP4020_COLOR_MODE, pixelCtrl);

                //       
                // load linear ramp into LUT
                //       

                for (index = 0; index <= 0xff; ++index)
                {
                    ClrComp5 = (index & 0xF8) | (index >> 5);
                    ClrComp6 = (index & 0xFC) | (index >> 6);

                    LUT_CACHE_SETRGB (index, 
                                      ClrComp5, 
                                      depth == 16 ? ClrComp6 : ClrComp5, ClrComp5);
                }
                break;

            case 24: 
            case 32:

                //
                // True color w/gamma, RGB, graphics, 8:8:8:8
                //

                pixelCtrl = 0xB8; 

                //
                // True color w/gamma, RGB, graphics, packed-24
                //

                if (depth == 24)
                    pixelCtrl |= 0x01;

                TVP4020_WRITE_INDEX_REG(__TVP4020_COLOR_MODE, pixelCtrl);

                //
                // load linear ramp into LUT
                // standard 888 ramps
                //

                for (index = 0; index <= 0xff; ++index)
                    LUT_CACHE_SETRGB (index, index, index, index);
                break;

            default:

                DEBUG_PRINT((2, "Cannot set RAMDAC for bad depth %d\n", depth));
                break;

        }

        //
        // if the clocks are in danger of interacting adjust the system clock
        //

        SystemClock = Dac_SeparateClocks(PixelClock, SystemClock);

        //
        // Program system clock. This controls the speed of the Permedia 2.
        //

        SystemClock = TVP4020_CalculateMNPForClock(
                                          HwDeviceExtension,
                                          RefClkSpeed,  // In 100Hz units
                                          SystemClock,  // In 100Hz units
                                          FALSE,        // SysClock
                                          1500000,      // Min VCO rating
                                          3000000,      // Max VCO rating
                                          &M,           // M Out
                                          &N,           // N Out
                                          &P);          // P Out

        if (SystemClock == 0)
        {
            DEBUG_PRINT((1, "TVP4020_CalculateMNPForClock failed\n"));
            return(FALSE);
        }

        //
        // Can change P2 MCLK directly without switching to PCLK
        //
        // Program the Mclk PLL
        //
        // test mode: forces MCLK to constant high
        //

        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_3, 0x06); 

        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_2, N);       // N
        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_1, M);       // M
        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_3, P | 0x08);// P / Enable

        C = 1000000;

        do 
        {
            TVP4020_READ_INDEX_REG(__TVP4020_MEMCLK_STATUS, ulValue); // Status

        } while ((!(ulValue & (1 << 4))) && (--C));

        //
        // No zoom on P2 pixel unit
        //
        // Program Pixel Clock to the correct value for the required resolution
        //

        PixelClock = TVP4020_CalculateMNPForClock( 
                                           HwDeviceExtension,
                                           RefClkSpeed,  // In 100Hz units
                                           PixelClock,   // In 100Hz units
                                           TRUE,         // Pixel Clock
                                           1500000,      // Min VCO rating
                                           3000000,      // Max VCO rating
                                           &M,           // M Out
                                           &N,           // N Out
                                           &P);          // P Out

        if (PixelClock == 0)
        {
            DEBUG_PRINT((1, "TVP4020_CalculateMNPForClock failed\n"));
            return(FALSE);
        }

        // 
        // Pixel Clock
        // 

        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C3, 0x06);    // RESET PCLK PLL
        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C2, N );      // N
        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C1, M);       // M
        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C3, P | 0x08);// Enable PCLK

        M = 1000000;

        do 
        {
            TVP4020_READ_INDEX_REG(__TVP4020_PIXCLK_STATUS, ulValue); 

        } while ((!(ulValue & (1 << 4))) && (--M));

        //
        // No Loop Clock on P2
        //

        TVP4020_SET_PIXEL_READMASK (0xff); 

        //
        // TMM: there is a rule that says if you muck about with the
        // MCLK then you must set up the MEM_CONFIG register again.
        //
    }
    else if (hwDeviceExtension->DacId == P2RD_RAMDAC)
    {
        if( !Program_P2RD( HwDeviceExtension, 
                           VideoMode, 
                           Hsp, 
                           Vsp, 
                           RefClkSpeed, 
                           &SystemClock, 
                           &PixelClock))
            return(FALSE);
    }

    //
    // Set the LUT cache size and set the first entry to zero, then
    // write the LUT cache to the LUT
    //

    LUT_CACHE_SETSIZE (256);
    LUT_CACHE_SETFIRST (0);

    (void) Permedia2SetColorLookup ( hwDeviceExtension,
                                     &(hwDeviceExtension->LUTCache.LUTCache),
                                     sizeof (hwDeviceExtension->LUTCache),
                                     TRUE,    // Always update RAMDAC 
                                     FALSE ); // Don't Update cache entries

    //
    // Setup VTG
    //

    ulValue = 3;    // RAMDAC pll pins for VClkCtl

    if ((hwDeviceExtension->DacId == P2RD_RAMDAC) ||
        (hwDeviceExtension->DacId == TVP4020_RAMDAC))
    {
        ULONG PCIDelay;

        //
        // TMM: The algorithm we used to calculate PCIDelay for P1 doesn't 
        // work for P2, frequent mode changes might cause hangups. 
        // So I took the value used by the BIOS for AGP and PCI systems 
        // and used that one. It works fine on PCI and VGA PCs.
        //

        PCIDelay = 32;

        ulValue |= (PCIDelay << 2);
    }
    else
    {
        DEBUG_PRINT((1, "Invalid RAMDAC type! \n"));
    }

    //
    // dShift is now used as a multiplier, instead of a shift count.
    // This is to support P2 packed-24 mode where the VESA horizontal 
    // timing values need to be multiplied by a non-power-of-two multiplier.
    //

    if ((hwDeviceExtension->DacId == TVP4020_RAMDAC && DacDepth > 8) || 
         hwDeviceExtension->DacId == P2RD_RAMDAC)
    {
        dShift = DacDepth >> 3;  // 64-bit pixel bus
    }
    else
    {
        dShift = DacDepth >> 2;  // 32-bit pixel bus
    }

    //
    // must load HgEnd before ScreenBase
    //

    VideoPortWriteRegisterUlong(HG_END, Hbe * dShift);

    //
    // Need to set up RAMDAC pll pins
    //

    VideoPortWriteRegisterUlong(V_CLK_CTL, ulValue); 

    VideoPortWriteRegisterUlong(SCREEN_BASE,   0);
    VideoPortWriteRegisterUlong(SCREEN_STRIDE, (xStride >> 3) * (DacDepth >> 3)); // 64-bit units
    VideoPortWriteRegisterUlong(H_TOTAL,       (Htot * dShift) - 1);
    VideoPortWriteRegisterUlong(HS_START,      Hss * dShift);
    VideoPortWriteRegisterUlong(HS_END,        Hse * dShift);
    VideoPortWriteRegisterUlong(HB_END,        Hbe * dShift);

    VideoPortWriteRegisterUlong(V_TOTAL,       Vtot - 1);
    VideoPortWriteRegisterUlong(VS_START,      Vss - 1);
    VideoPortWriteRegisterUlong(VS_END,        Vse - 1);
    VideoPortWriteRegisterUlong(VB_END,        Vbe);

    {
        ULONG highWater, newChipConfig, oldChipConfig;

        #define videoFIFOSize       32
        #define videoFIFOLoWater     8
        #define videoFIFOLatency    26

        //
        // Calculate the high-water, by taking into account
        // the pixel clock, the pxiel size, add 1 for luck
        //

        highWater = (((videoFIFOLatency * PixelClock * DacDepth) / 
                      (64 * SystemClock )) + 1);

        //
        // Trim the highwater, make sure it's not bigger than the FIFO size
        //

        if (highWater > videoFIFOSize)
            highWater = videoFIFOSize;

        highWater = videoFIFOSize - highWater;

        //
        // Make sure the highwater is greater than the low water mark.
        //

        if (highWater <= videoFIFOLoWater)
            highWater = videoFIFOLoWater + 1;

        ulValue = (highWater << 8) | videoFIFOLoWater;
            
        VideoPortWriteRegisterUlong(VIDEO_FIFO_CTL, ulValue);

        //
        // select the appropriate Delta clock source
        //

        #define SCLK_SEL_PCI        (0x0 << 10)   // Delta Clk == PCI Clk
        #define SCLK_SEL_PCIHALF    (0x1 << 10)   // Delta Clk == 1/2 PCI Clk
        #define SCLK_SEL_MCLK       (0x2 << 10)   // Delta Clk == MClk
        #define SCLK_SEL_MCLKHALF   (0x3 << 10)   // Delta Clk == 1/2 MClk
        #define SCLK_SEL_MASK       (0x3 << 10)

        if (VideoPortGetRegistryParameters(HwDeviceExtension,
                                           L"P2DeltaClockMode",
                                           FALSE,
                                           Permedia2RegistryCallback,
                                           &ulValue) == NO_ERROR)
        {
            ulValue <<= 10;
            ulValue &= SCLK_SEL_MASK;
        }
        else
        {
            if((hwDeviceExtension->deviceInfo.RevisionId == PERMEDIA2A_REV_ID) &&
               (hwDeviceExtension->PciSpeed == 66))
            {
                ulValue = SCLK_SEL_PCI;
            }
            else
            {
                //
                // This is the default value
                //

                ulValue = SCLK_SEL_MCLKHALF;

            }
        }

        newChipConfig = oldChipConfig = VideoPortReadRegisterUlong(CHIP_CONFIG);
        newChipConfig &= ~SCLK_SEL_MASK; 
        newChipConfig |= ulValue; 
        
        VideoPortWriteRegisterUlong(CHIP_CONFIG, newChipConfig);
    }

    //
    // Enable video out and set sync polaritys to active high.
    // P2 uses 64-bit pixel bus for modes > 8BPP
    //

    VTGPolarity = (1 << 5) | (1 << 3) | 1;

    if (hwDeviceExtension->DacId == P2RD_RAMDAC || DacDepth > 8)
    {
        //
        // P2ST always uses 64-bit pixel bus
        // P2 uses 64-bit pixel bus for modes > 8BPP
        //

        VTGPolarity |= (1 << 16);
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2)
        VTGPolarity |= (1 << 2);

    hwDeviceExtension->VideoControl = VTGPolarity;
    VideoPortWriteRegisterUlong(VIDEO_CONTROL, hwDeviceExtension->VideoControl); 

    DEBUG_PRINT((2, "Loaded Permedia timing registers:\n"));
    DEBUG_PRINT((2, "\tVClkCtl: 0x%x\n", 3));
    DEBUG_PRINT((2, "\tScreenBase: 0x%x\n", 0));
    DEBUG_PRINT((2, "\tScreenStride: 0x%x\n", xStride >> (3 - (DacDepth >> 4))));
    DEBUG_PRINT((2, "\tHTotal: 0x%x\n", (Htot << dShift) - 1));
    DEBUG_PRINT((2, "\tHsStart: 0x%x\n", Hss << dShift));
    DEBUG_PRINT((2, "\tHsEnd: 0x%x\n", Hse << dShift));
    DEBUG_PRINT((2, "\tHbEnd: 0x%x\n", Hbe << dShift));
    DEBUG_PRINT((2, "\tHgEnd: 0x%x\n", Hbe << dShift));
    DEBUG_PRINT((2, "\tVTotal: 0x%x\n", Vtot - 1));
    DEBUG_PRINT((2, "\tVsStart: 0x%x\n", Vss - 1));
    DEBUG_PRINT((2, "\tVsEnd: 0x%x\n", Vse - 1));
    DEBUG_PRINT((2, "\tVbEnd: 0x%x\n", Vbe));
    DEBUG_PRINT((2, "\tVideoControl: 0x%x\n", VTGPolarity));

    //
    // record the final chip clock in the registry
    //

    SystemClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.CurrentChipClockSpeed",
                                   &SystemClock,
                                   sizeof(ULONG));

    hwDeviceExtension->bVTGRunning = TRUE;
    DEBUG_PRINT((2, "InitializeVideo Finished\n"));
    return(TRUE);
}


ULONG P2RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,     // In 100Hz units
    ULONG ReqClock,     // In 100Hz units
    ULONG *rM,          // M Out (feedback scaler)
    ULONG *rN,          // N Out (prescaler)
    ULONG *rP           // P Out (postscaler)
    )

/*++

Routine Description:

   Calculates prescaler, feedback scaler and postscaler values for the
   STMACRO PLL61-1M used by P2RD.

--*/

{
    const ULONG fMinVCO    = 1280000;  // min fVCO is 128MHz (in 100Hz units)
    const ULONG fMaxVCO    = 2560000;  // max fVCO is 256MHz (in 100Hz units)
    const ULONG fMinINTREF = 10000;    // min fINTREF is 1MHz (in 100Hz units)
    const ULONG fMaxINTREF = 20000;    // max fINTREF is 2MHz (in 100Hz units)

    ULONG   M, N, P;
    ULONG   fINTREF;
    ULONG   fVCO;
    ULONG   ActualClock;
    int     Error;
    int     LowestError = INITIALFREQERR;
    BOOLEAN bFoundFreq = FALSE;
    int     LoopCount;

    for(P = 0; P <= 4; ++P)
    {
        ULONG fVCOLowest, fVCOHighest;

        //
        // it's pointless going through the main loop if all values of N 
        // produce an fVCO outside the acceptable range
        //

        N = 1;
        M = (N * (1 << P) * ReqClock) / RefClock;

        fVCOLowest = (RefClock * M) / N;

        N = 255;
        M = (N * (1 << P) * ReqClock) / RefClock;

        fVCOHighest = (RefClock * M) / N;

        if(fVCOHighest < fMinVCO || fVCOLowest > fMaxVCO)
            continue;

        for(N = 1; N <= 255; ++N)
        {
            fINTREF = RefClock / N;
            if(fINTREF < fMinINTREF || fINTREF > fMaxINTREF)
            {
                if(fINTREF > fMaxINTREF)
                {
                    //
                    // hopefully we'll get into range as the prescale 
                    // value increases
                    //

                    continue;
                }
                else
                {
                    //
                    // already below minimum and it'll only get worse: 
                    // move to the next postscale value
                    //

                    break;
                }
            }

            M = (N * (1 << P) * ReqClock) / RefClock;
            if(M > 255)
            {
                //
                // M, N & P registers are only 8 bits wide
                //

                break;

            }

            //
            // we can expect rounding errors in calculating M, which will 
            // always be rounded down.  So we'll checkout our calculated 
            // value of M along with (M+1)
            //

            for(LoopCount = (M == 255) ? 1 : 2; --LoopCount >= 0; ++M)
            {
                fVCO = (RefClock * M) / N;

                if(fVCO >= fMinVCO && fVCO <= fMaxVCO)
                {
                    ActualClock = fVCO / (1 << P);

                    Error = ActualClock - ReqClock;
                    if(Error < 0)
                        Error = -Error;

                    if(Error < LowestError)
                    {
                        bFoundFreq = TRUE;
                        LowestError = Error;
                        *rM = M;
                        *rN = N;
                        *rP = P;
                        if(Error == 0)
                            goto Done;
                    }
                }
            }
        }
    }

Done:

    if(bFoundFreq)
        ActualClock = (RefClock * *rM) / (*rN * (1 << *rP));
    else
        ActualClock = 0;

    return(ActualClock);
}


BOOLEAN Program_P2RD(PHW_DEVICE_EXTENSION HwDeviceExtension, 
                     PP2_VIDEO_FREQUENCIES VideoMode, 
                     ULONG Hsp, 
                     ULONG Vsp,
                     ULONG RefClkSpeed, 
                     PULONG pSystemClock, 
                     PULONG pPixelClock )

/*++

Routine Description:

    initializes the P2RD registers and programs the DClk (pixel clock)
    and MClk (system clock) PLLs. After programming the MClk, the
    contents of all registers in the graphics core, the memory controller
    and the video control should be assumed to be undefined

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    ULONG   DacDepth, depth;
    LONG    mpxAdjust;
    ULONG   index;
    ULONG   color;
    ULONG   ulValue;
    UCHAR   pixelCtrl;
    ULONG   M, N, P;
    P2_DECL;
    P2RD_DECL;

    depth = VideoMode->BitsPerPel;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15)
        DacDepth = 16;
    else if (depth == 12)
        DacDepth = 32;

    VideoPortWriteRegisterUlong(P2RD_INDEX_CONTROL,   
                                P2RD_IDX_CTL_AUTOINCREMENT_ENABLED);

    ulValue = (Hsp ? P2RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH : P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW) |
              (Vsp ? P2RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH : P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW);

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_X_BY2)
    {
        //
        // it's a really low resolution (e.g. 320x200) so enable pixel 
        // doubling in the RAMDAC (we'll enable line doubling in the
        // pixel unit too)
        //

        P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, 
                            P2RD_MISC_CONTROL_HIGHCOLORRES | 
                            P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED |
                            P2RD_MISC_CONTROL_PIXEL_DOUBLE);
    }
    else
    {
        P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, 
                            P2RD_MISC_CONTROL_HIGHCOLORRES | 
                            P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED);
    }

    P2RD_LOAD_INDEX_REG(P2RD_SYNC_CONTROL, ulValue);
    P2RD_LOAD_INDEX_REG(P2RD_DAC_CONTROL,  
                        P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED);

    ulValue = 0;

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_X_BY2)
    {
        ulValue |= P2RD_CURSOR_CONTROL_DOUBLE_X;
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2)
    {
        ulValue |= P2RD_CURSOR_CONTROL_DOUBLE_Y;
    }

    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_CONTROL,   ulValue);

    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_MODE,      0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_X_LOW,     0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_X_HIGH,    0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_Y_LOW,     0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_Y_HIGH,    0xff);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_HOTSPOT_X, 0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_HOTSPOT_Y, 0);
    P2RD_LOAD_INDEX_REG(P2RD_PAN, 0);

    //
    // the first 3-color cursor is the mini cursor which is always 
    // black & white. Set it up here
    //

    P2RD_CURSOR_PALETTE_CURSOR_RGB(0, 0x00,0x00,0x00);
    P2RD_CURSOR_PALETTE_CURSOR_RGB(1, 0xff,0xff,0xff);

    //
    // stop dot and memory clocks
    //

    P2RD_LOAD_INDEX_REG(P2RD_DCLK_CONTROL, 0);
    P2RD_LOAD_INDEX_REG(P2RD_MCLK_CONTROL, 0);

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_X_BY2)
    {
        // 
        // we're doubling each pixel so we double the pixel clock too
        // NB. the PixelDouble field of RDMiscControl needs to be set also)
        // 

        *pPixelClock *= 2;
    }

    *pPixelClock = P2RD_CalculateMNPForClock( HwDeviceExtension, 
                                              RefClkSpeed, 
                                              *pPixelClock, 
                                              &M, 
                                              &N, 
                                              &P );

    if(*pPixelClock == 0)
    {
        DEBUG_PRINT((1, "P2RD_CalculateMNPForClock(PixelClock) failed\n"));
        return(FALSE);
    }

    //
    // load both copies of the dot clock with our times (DCLK0 & DCLK1 
    // reserved for VGA only)
    //

    P2RD_LOAD_INDEX_REG(P2RD_DCLK2_PRE_SCALE,      N);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK2_FEEDBACK_SCALE, M);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK2_POST_SCALE,     P);

    P2RD_LOAD_INDEX_REG(P2RD_DCLK3_PRE_SCALE,      N);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK3_FEEDBACK_SCALE, M);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK3_POST_SCALE,     P);

    *pSystemClock = P2RD_CalculateMNPForClock( HwDeviceExtension, 
                                               RefClkSpeed, 
                                               *pSystemClock, 
                                               &M, 
                                               &N, 
                                               &P );

    if(*pSystemClock == 0)
    {
        DEBUG_PRINT((1, "P2RD_CalculateMNPForClock(SystemClock) failed\n"));
        return(FALSE);
    }

    //
    // load the system clock
    //

    P2RD_LOAD_INDEX_REG(P2RD_MCLK_PRE_SCALE,      N);
    P2RD_LOAD_INDEX_REG(P2RD_MCLK_FEEDBACK_SCALE, M);
    P2RD_LOAD_INDEX_REG(P2RD_MCLK_POST_SCALE,     P);

    //
    // enable the dot clock
    //

    P2RD_LOAD_INDEX_REG(P2RD_DCLK_CONTROL, 
                        P2RD_DCLK_CONTROL_ENABLED | P2RD_DCLK_CONTROL_RUN);


    M = 0x100000;

    do
    {
        P2RD_READ_INDEX_REG(P2RD_DCLK_CONTROL, ulValue);
    }
    while((ulValue & P2RD_DCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P2RD_DCLK_CONTROL_LOCKED) == FALSE)
    {
        DEBUG_PRINT((1, "Program_P2RD: PixelClock failed to lock\n"));
        return(FALSE);
    }

    //
    // enable the system clock
    //

    P2RD_LOAD_INDEX_REG(P2RD_MCLK_CONTROL, 
                        P2RD_MCLK_CONTROL_ENABLED | P2RD_MCLK_CONTROL_RUN);


    M = 0x100000;

    do
    {
        P2RD_READ_INDEX_REG(P2RD_MCLK_CONTROL, ulValue);
    }
    while((ulValue & P2RD_MCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P2RD_MCLK_CONTROL_LOCKED) == FALSE)
    {
        DEBUG_PRINT((1, "Program_P2RD: SystemClock failed to lock\n"));
        return(FALSE);
    }

    switch (depth) 
    {
        case 8:

            P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

            ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;

            P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            P2RD_LOAD_INDEX_REG(P2RD_PIXEL_SIZE, P2RD_PIXEL_SIZE_8BPP);

            if (hwDeviceExtension->Capabilities & CAPS_8BPP_RGB)
            {
                ULONG   Red, Green, Blue ;
    
                P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, 
                                    P2RD_COLOR_FORMAT_8BPP | P2RD_COLOR_FORMAT_RGB);

                for (index = 0; index <= 0xff; ++index)
                {
                    Red     = bPal8[index & 0x07];
                    Green   = bPal8[(index >> 3 ) & 0x07];
                    Blue    = bPal4[(index >> 6 ) & 0x03];

                    if( Red == Green)   // Maybe it's a special case of gray ?
                    {
                        //  
                        // This is a tricky part:
                        // the Blue field in BGR 2:3:3 color goes thru 
                        // steps 00, 01, 10, 11 (Binary)
                        // the Red and Green go thru 000, 001, 010, 011, 
                        // 100, 101, 110, 111 (Binary)
                        // We load the special gray values ONLY when Blue 
                        // color is close in intensity to both Green and Red, 
                        // i.e. Blue = 01, Green = 010 or 011,
                        //      Blue = 10, Green = 100 or 101,
                        //  

                        if ( ((index >> 1) & 0x03) == ((index >> 6 ) & 0x03 ) )
                        { 
                            Blue = Red;
                        }
                    }
                    LUT_CACHE_SETRGB (index, Red, Green, Blue);
                }
            }
            else
            {
                //
                // Color indexed mode
                //

                P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, 
                                    P2RD_COLOR_FORMAT_CI8 | P2RD_COLOR_FORMAT_RGB);

            }

            break;

        case 15:
        case 16:

            P2RD_LOAD_INDEX_REG(P2RD_PIXEL_SIZE, P2RD_PIXEL_SIZE_16BPP);

#if  GAMMA_CORRECTION

            P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

            //
            // load linear ramp into LUT as default
            //

            for (index = 0; index <= 0xff; ++index)
                LUT_CACHE_SETRGB (index, index, index, index);

            pixelCtrl = 0;

#else
            P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            ulValue |= P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            pixelCtrl = P2RD_COLOR_FORMAT_LINEAR_EXT;

#endif

            pixelCtrl |= 
                 (depth == 16) ? P2RD_COLOR_FORMAT_16BPP : P2RD_COLOR_FORMAT_15BPP;

            pixelCtrl |= P2RD_COLOR_FORMAT_RGB;

            P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, pixelCtrl);

            break;

        case 12:
        case 24:
        case 32:

            P2RD_LOAD_INDEX_REG(P2RD_PIXEL_SIZE, P2RD_PIXEL_SIZE_32BPP);
            P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, 
                                P2RD_COLOR_FORMAT_32BPP | P2RD_COLOR_FORMAT_RGB);

            if (depth == 12) 
            {
                USHORT cacheIndex;

                P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
                ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
                P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

                //
                // use auto-increment to load a ramp into entries 0 to 15
                //

                for (index = 0, cacheIndex = 0; 
                     index <= 0xff; 
                     index += 0x11, cacheIndex++)
                {
                    LUT_CACHE_SETRGB (index, index, index, index);
                }

                //
                // load ramp in every 16th entry from 16 to 240
                //

                color = 0x11;
                for (index = 0x10; index <= 0xf0; index += 0x10, color += 0x11) 
                    LUT_CACHE_SETRGB (index, color, color, color);

                P2RD_SET_PIXEL_READMASK(0x0f);
            }
            else
            {

#if  GAMMA_CORRECTION

                P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
                ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
                P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

                //
                // load linear ramp into LUT as default
                //

                for (index = 0; index <= 0xff; ++index)
                    LUT_CACHE_SETRGB (index, index, index, index);

#else
                P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
                ulValue |= P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
                P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

#endif  // GAMMA_CORRECTION

            }

            break;

        default:

            DEBUG_PRINT((1, "bad depth %d passed to Program_P2RD\n", depth));

            return(FALSE);

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3d.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3d.c
*
* Content: Main D3D capabilites and callback tables
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//-----------------------------------------------------------------------------
//
// Certain conventions are followed in this sample driver in order to ease 
// the code reading process:
//
// - All driver function callbacks are prefixed with either D3D or DD. No other
//   functions start with such a prefix
//
// - Helper (or secondary) functions which are called from other places INSIDE
//   the driver (in different files) are prefixed with either _D3D or _DD
//
// - Helper functions called from within the same file are prefixed with __
//   (but not with __D3D or __DD !) so names as __CTX_CleanDirect3DContext arise
//
// - Data structures declared and used only be the driver are prefixed with P3
//
// - Very minor hungarian notation is used, basically in the form of prefixes 
//   for DWORDs (dw), pointers (p), handles (h), and counters (i).
//
// - Global data items are prefixed with g_
//
// - This driver is intended to be source code compatible between the NT and 
//   Win9x kernel display driver models. As such, most kernel structures retain
//   their Win9x name ( The DX8 d3dnthal.h shares the same names as the Win9x
//   d3dhal.h and for DX7 dx95type.h in the Win2K DDK will perform the 
//   required level of translation). Major differences however are observed 
//   using preprocessor #if statements.
//
//-----------------------------------------------------------------------------

#include "glint.h"

//-----------------------------------------------------------------------------
// in-the-file nonexported forward declarations
//-----------------------------------------------------------------------------
void __D3D_BuildTextureFormatsP3(P3_THUNKEDDATA *pThisDisplay, 
                             DDSURFACEDESC TexFmt[MAX_TEXTURE_FORMAT],
                             DWORD *pNumTextures);
#if DX8_DDI
void __D3D_Fill_DX8Caps(D3DCAPS8 *pd3d8caps,
                        D3DDEVICEDESC_V1 *pDeviceDesc,
                        D3DHAL_D3DEXTENDEDCAPS *pD3DEC,
                        DDHALINFO *pDDHALInfo);
#endif // DX8_DDI                        
//-----------------------------------------------------------------------------
// This structure contains all the the primitive capabilities (D3DPRIMCAPS)
// this driver supports for triangles and lines. All of the information in this 
// table will be implementation specific according to the specifications of 
// the hardware.
//-----------------------------------------------------------------------------

#define P3RXTriCaps {                                                    \
    sizeof(D3DPRIMCAPS),                                                 \
    D3DPMISCCAPS_CULLCCW        |              /* MiscCaps */            \
        D3DPMISCCAPS_CULLCW     |                                        \
        D3DPMISCCAPS_CULLNONE   |                                        \
        D3DPMISCCAPS_MASKZ      |                                        \
        D3DPMISCCAPS_LINEPATTERNREP,                                     \
    D3DPRASTERCAPS_DITHER            |         /* RasterCaps */          \
        D3DPRASTERCAPS_PAT           |                                   \
        D3DPRASTERCAPS_SUBPIXEL      |                                   \
        D3DPRASTERCAPS_ZTEST         |                                   \
        D3DPRASTERCAPS_FOGVERTEX     |                                   \
        D3DPRASTERCAPS_FOGTABLE      |                                   \
        D3DPRASTERCAPS_ZFOG          |                                   \
        D3DPRASTERCAPS_STIPPLE       |                                   \
        D3DPRASTERCAPS_MIPMAPLODBIAS,                                    \
    D3DPCMPCAPS_NEVER            |             /* ZCmpCaps */            \
        D3DPCMPCAPS_LESS         |                                       \
        D3DPCMPCAPS_EQUAL        |                                       \
        D3DPCMPCAPS_LESSEQUAL    |                                       \
        D3DPCMPCAPS_GREATER      |                                       \
        D3DPCMPCAPS_NOTEQUAL     |                                       \
        D3DPCMPCAPS_GREATEREQUAL |                                       \
        D3DPCMPCAPS_ALWAYS       |                                       \
        D3DPCMPCAPS_LESSEQUAL,                                           \
    D3DPBLENDCAPS_ZERO             |           /* SourceBlendCaps */     \
        D3DPBLENDCAPS_ONE          |                                     \
        D3DPBLENDCAPS_SRCALPHA     |                                     \
        D3DPBLENDCAPS_INVSRCALPHA  |                                     \
        D3DPBLENDCAPS_DESTALPHA    |                                     \
        D3DPBLENDCAPS_INVDESTALPHA |                                     \
        D3DPBLENDCAPS_DESTCOLOR    |                                     \
        D3DPBLENDCAPS_INVDESTCOLOR |                                     \
        D3DPBLENDCAPS_SRCALPHASAT  |                                     \
        D3DPBLENDCAPS_BOTHSRCALPHA |                                     \
        D3DPBLENDCAPS_BOTHINVSRCALPHA,                                   \
    D3DPBLENDCAPS_ZERO            |            /* DestBlendCaps */       \
        D3DPBLENDCAPS_ONE         |                                      \
        D3DPBLENDCAPS_SRCCOLOR    |                                      \
        D3DPBLENDCAPS_INVSRCCOLOR |                                      \
        D3DPBLENDCAPS_SRCALPHA    |                                      \
        D3DPBLENDCAPS_INVSRCALPHA |                                      \
        D3DPBLENDCAPS_DESTALPHA   |                                      \
        D3DPBLENDCAPS_INVDESTALPHA,                                      \
    D3DPCMPCAPS_NEVER            |             /* Alphatest caps */      \
        D3DPCMPCAPS_LESS         |                                       \
        D3DPCMPCAPS_EQUAL        |                                       \
        D3DPCMPCAPS_LESSEQUAL    |                                       \
        D3DPCMPCAPS_GREATER      |                                       \
        D3DPCMPCAPS_NOTEQUAL     |                                       \
        D3DPCMPCAPS_GREATEREQUAL |                                       \
        D3DPCMPCAPS_ALWAYS,                                              \
    D3DPSHADECAPS_COLORFLATRGB              |  /* ShadeCaps */           \
        D3DPSHADECAPS_COLORGOURAUDRGB       |                            \
        D3DPSHADECAPS_SPECULARFLATRGB       |                            \
        D3DPSHADECAPS_SPECULARGOURAUDRGB    |                            \
        D3DPSHADECAPS_FOGFLAT               |                            \
        D3DPSHADECAPS_FOGGOURAUD            |                            \
        D3DPSHADECAPS_ALPHAFLATBLEND        |                            \
        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |                            \
        D3DPSHADECAPS_ALPHAFLATSTIPPLED,                                 \
    D3DPTEXTURECAPS_PERSPECTIVE         |      /* TextureCaps */         \
        D3DPTEXTURECAPS_ALPHA           |                                \
        D3DPTEXTURECAPS_POW2            |                                \
        D3DPTEXTURECAPS_ALPHAPALETTE    |                                \
        D3DPTEXTURECAPS_TRANSPARENCY,                                    \
    D3DPTFILTERCAPS_NEAREST              |     /* TextureFilterCaps*/    \
        D3DPTFILTERCAPS_LINEAR           |                               \
        D3DPTFILTERCAPS_MIPNEAREST       |                               \
        D3DPTFILTERCAPS_MIPLINEAR        |                               \
        D3DPTFILTERCAPS_LINEARMIPNEAREST |                               \
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |                               \
        D3DPTFILTERCAPS_MIPFPOINT        |                               \
        D3DPTFILTERCAPS_MIPFLINEAR       |                               \
        D3DPTFILTERCAPS_MAGFPOINT        |                               \
        D3DPTFILTERCAPS_MAGFLINEAR       |                               \
        D3DPTFILTERCAPS_MINFPOINT        |                               \
        D3DPTFILTERCAPS_MINFLINEAR,                                      \
    D3DPTBLENDCAPS_DECAL             |        /* TextureBlendCaps */     \
        D3DPTBLENDCAPS_DECALALPHA    |                                   \
        D3DPTBLENDCAPS_MODULATE      |                                   \
        D3DPTBLENDCAPS_MODULATEALPHA |                                   \
        D3DPTBLENDCAPS_ADD           |                                   \
        D3DPTBLENDCAPS_COPY,                                             \
    D3DPTADDRESSCAPS_WRAP       |              /* TextureAddressCaps */  \
        D3DPTADDRESSCAPS_MIRROR |                                        \
        D3DPTADDRESSCAPS_CLAMP  |                                        \
        D3DPTADDRESSCAPS_INDEPENDENTUV,                                  \
    8,                                         /* StippleWidth */        \
    8                                          /* StippleHeight */       \
}    

static D3DDEVICEDESC_V1 g_P3RXCaps = {
    sizeof(D3DDEVICEDESC_V1),                 // dwSize 
    D3DDD_COLORMODEL               |          // dwFlags 
        D3DDD_DEVCAPS              |
        D3DDD_TRICAPS              |
        D3DDD_LINECAPS             |
        D3DDD_DEVICERENDERBITDEPTH |
        D3DDD_DEVICEZBUFFERBITDEPTH,
    D3DCOLOR_RGB ,                            // dcmColorModel
    D3DDEVCAPS_CANRENDERAFTERFLIP       |     // devCaps 
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_SORTINCREASINGZ      |
        D3DDEVCAPS_SORTEXACT            |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TEXTUREVIDEOMEMORY   |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     |
        D3DDEVCAPS_DRAWPRIMITIVES2      |       
#if DX7_VERTEXBUFFERS
        D3DDEVCAPS_HWVERTEXBUFFER       |
#endif        
        D3DDEVCAPS_HWRASTERIZATION      |
        D3DDEVCAPS_DRAWPRIMITIVES2EX,
    { sizeof(D3DTRANSFORMCAPS), 0 },            // transformCaps 
    FALSE,                                      // bClipping 
    { sizeof(D3DLIGHTINGCAPS), 0 },             // lightingCaps 
    P3RXTriCaps,                                // lineCaps 
    P3RXTriCaps,                                // triCaps 
        DDBD_16 | DDBD_32,                      // dwDeviceRenderBitDepth 
        DDBD_16 | DDBD_32,                      // Z Bit depths 
        0,                                      // dwMaxBufferSize 
    0                                           // dwMaxVertexCount 
};

D3DHAL_D3DEXTENDEDCAPS gc_D3DEC = {
    sizeof(D3DHAL_D3DEXTENDEDCAPS),       // dwSize                   // DX5
    1,                                    // dwMinTextureWidth
    2048,                                 // dwMaxTextureWidth
    1,                                    // dwMinTextureHeight
    2048,                                 // dwMaxTextureHeight
    32,                                   // dwMinStippleWidth
    32,                                   // dwMaxStippleWidth
    32,                                   // dwMinStippleHeight
    32,                                   // dwMaxStippleHeight

    0,  /*azn*/                           // dwMaxTextureRepeat       //DX6
    0,                                    // dwMaxTextureAspectRatio (no limit)
    0,                                    // dwMaxAnisotropy
    -4096.0f,                             // dvGuardBandLeft
    -4096.0f,                             // dvGuardBandTop
    4096.0f,                              // dvGuardBandRight
    4096.0f,                              // dvGuardBandBottom
    0.0f,                                 // dvExtentsAdjust                           
    D3DSTENCILCAPS_KEEP    |              // dwStencilCaps
       D3DSTENCILCAPS_ZERO    |
       D3DSTENCILCAPS_REPLACE |
       D3DSTENCILCAPS_INCRSAT |
       D3DSTENCILCAPS_DECRSAT |
       D3DSTENCILCAPS_INVERT  |
       D3DSTENCILCAPS_INCR    |
       D3DSTENCILCAPS_DECR,                                        
    8,                                          // dwFVFCaps                  
    D3DTEXOPCAPS_DISABLE                      | // dwTextureOpCaps
       D3DTEXOPCAPS_SELECTARG1                | 
       D3DTEXOPCAPS_SELECTARG2                |
       D3DTEXOPCAPS_MODULATE                  |
       D3DTEXOPCAPS_MODULATE2X                |
       D3DTEXOPCAPS_MODULATE4X                |
       D3DTEXOPCAPS_ADD                       |
       D3DTEXOPCAPS_ADDSIGNED                 |
       D3DTEXOPCAPS_ADDSIGNED2X               |
       D3DTEXOPCAPS_SUBTRACT                  |
       D3DTEXOPCAPS_ADDSMOOTH                 |
       D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
       D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
       D3DTEXOPCAPS_BLENDFACTORALPHA          |
//@@BEGIN_DDKSPLIT
#if 0
 // Fix texturestage DCT - seems we can't do this reliably
       D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
       D3DTEXOPCAPS_PREMODULATE               |   
       D3DTEXOPCAPS_BLENDCURRENTALPHA         |       
#endif
//@@END_DDKSPLIT
       D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
       D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
       D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
       D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
       D3DTEXOPCAPS_DOTPRODUCT3,                                      
    2,                                    // wMaxTextureBlendStages
    2,                                    // wMaxSimultaneousTextures

    0,                                    // dwMaxActiveLights        // DX7
    0.0f,                                 // dvMaxVertexW
    0,                                    // wMaxUserClipPlanes
    0                                     // wMaxVertexBlendMatrices
};

#if DX8_DDI
static D3DCAPS8 g_P3RX_D3DCaps8;
#endif // DX8_DDI

//--------------------------------------------------------
// Supported ZBuffer/Stencil Formats by this hardware
//--------------------------------------------------------

#define P3RX_Z_FORMATS 4

typedef struct 
{
    DWORD dwStructSize;

    DDPIXELFORMAT Format[P3RX_Z_FORMATS];
} ZFormats;

ZFormats P3RXZFormats = 
{
    P3RX_Z_FORMATS,
    {
        // Format 1 - 16 Bit Z Buffer, no stencil
        {
            sizeof(DDPIXELFORMAT),        
            DDPF_ZBUFFER,                     
            0,                            
            16,                     // Total bits in buffer
            0,                      // Stencil bits
            0xFFFF,                 // Z mask
            0,                      // Stencil mask
            0
        },
        // Format 2 - 24 bit Z Buffer, 8 bit stencil
        {
            sizeof(DDPIXELFORMAT),
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,
            0,
            32,                     // Total bits in buffer
            8,                      // Stencil bits
            0x00FFFFFF,             // Z Mask
            0xFF000000,             // Stencil Mask
            0
        },
        // Format 3 - 15 bit Z Buffer, 1 bit stencil
        {
            sizeof(DDPIXELFORMAT),
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,             
            0,                    
            16,                     // Total bits in buffer
            1,                      // Stencil bits
            0x7FFF,                 // Z Mask
            0x8000,                 // Stencil mask
            0
        },
        // Format 4 - 32 bit Z Buffer, no stencil
        {
            sizeof(DDPIXELFORMAT),
            DDPF_ZBUFFER,
            0,
            32,                     // Total bits in buffer
            0,                      // Stencil bits
            0xFFFFFFFF,             // Z Mask
            0,                      // Stencil Mask
            0
        }
    }
};

#if DX8_DDI
//----------------------------------------------------------------------------
// Supported DX8 RenderTarget/Texture/ZBuffer/Stencil Formats by this hardware
//----------------------------------------------------------------------------

#if DX8_MULTISAMPLING
// Note: For multisampling we need to setup appropriately both the rendertarget
// and the depth buffer format's multisampling fields.
#define D3DMULTISAMPLE_NUM_SAMPLES (1 << (D3DMULTISAMPLE_4_SAMPLES - 1))
#else
#define D3DMULTISAMPLE_NUM_SAMPLES D3DMULTISAMPLE_NONE
#endif // DX8_MULTISAMPLING

#define DX8_FORMAT(FourCC, Ops, dwMSFlipTypes)                              \
    { sizeof(DDPIXELFORMAT), DDPF_D3DFORMAT, (FourCC), 0, (Ops),            \
        ((dwMSFlipTypes) & 0xFFFF ) << 16 | ((dwMSFlipTypes) & 0xFFFF), 0, 0 }

DDPIXELFORMAT DX8FormatTable[] =
{
    DX8_FORMAT(D3DFMT_X1R5G5B5,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE | 
                                         D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET, 
                                          D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_R5G6B5,          D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE | 
                                         D3DFORMAT_OP_DISPLAYMODE |
                                          D3DFORMAT_OP_3DACCELERATION |
                                           D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET, 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_X8R8G8B8,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE | 
                                         D3DFORMAT_OP_DISPLAYMODE | 
                                          D3DFORMAT_OP_3DACCELERATION |
                                           D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET,   0), 
#ifdef DX7_PALETTETEXTURE
    DX8_FORMAT(D3DFMT_P8,              D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
#endif

    DX8_FORMAT(D3DFMT_A1R5G5B5,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A4R4G4B4,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A8R8G8B8,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A4L4,            D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A8L8,            D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
//@@BEGIN_DDKSPLIT 
// We are turning D3DFMT_A8 support OFF because the default color for
// this format has been changed from white to black. The P3 has white
// hardwired so there is no simple solution for this.
#if 0                                        
    DX8_FORMAT(D3DFMT_A8,              D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
#endif                                        
//@@END_DDKSPLIT
    DX8_FORMAT(D3DFMT_L8,              D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_D16_LOCKABLE,    D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_D32,             D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_S8D24,           D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_S1D15,           D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES )
};
#define DX8_FORMAT_COUNT (sizeof(DX8FormatTable) / sizeof(DX8FormatTable[0]))
#endif // DX8_DDI

#ifdef W95_DDRAW
#define DDHAL_D3DBUFCALLBACKS DDHAL_DDEXEBUFCALLBACKS 
#endif

//-----------------------------------------------------------------------------
//
// void _D3DHALCreateDriver
//
// _D3DHALCreateDriver is a helper function, not a callback.
//
// Its main purpouse is to centralize the first part of D3D initialization 
// (the second part is handled by _D3DGetDriverInfo) . _D3DHALCreateDriver:
//      Clears contexts
//      Fills entry points to D3D driver.
//      Generates and passes back texture formats.
//
// If the structures are succesfully created the internal pointers 
// (lpD3DGlobalDriverData, lpD3DHALCallbacks and (maybe) lpD3DBufCallbacks)
// are updated to point to valid data structures.
//
//-----------------------------------------------------------------------------
void  
_D3DHALCreateDriver(P3_THUNKEDDATA *pThisDisplay)
{
    BOOL bRet;
    ULONG Result;
    D3DHAL_GLOBALDRIVERDATA* pD3DDriverData = NULL;
    D3DHAL_CALLBACKS* pD3DHALCallbacks = NULL;
    DDHAL_D3DBUFCALLBACKS* pD3DBufCallbacks = NULL;

    DBG_ENTRY(_D3DHALCreateDriver);

    // Verify if we have already created the necessary data. If so, don't go
    // again through this process.
    if ((pThisDisplay->lpD3DGlobalDriverData != 0) &&
        (pThisDisplay->lpD3DHALCallbacks != 0))
    {
        DISPDBG((WRNLVL,"D3D Data already created for this PDEV, "
                        "not doing it again."));

        // we keep the same structure pointers to previously 
        // created and stored in pThisDisplay                 
        
        DBG_EXIT(_D3DHALCreateDriver, 0); 
        return;
    }
    else
    {
        DISPDBG((WRNLVL,"Creating D3D caps/callbacks for the "
                        "first time on this PDEV"));
    }

    // We set the structure pointers to NULL in case an error happens and 
    // we're forced to disable D3D support
    pThisDisplay->lpD3DGlobalDriverData = 0;
    pThisDisplay->lpD3DHALCallbacks = 0;
    pThisDisplay->lpD3DBufCallbacks = 0;       

    // Initialize the context handle data structures (array) . We are careful
    // not to initialize the data structures twice (as between mode changes,
    // for example) as this info needs to be persistent between such events.
    _D3D_CTX_HandleInitialization();

    //-----------------------------------
    // Allocate necessary data structures
    //-----------------------------------

    // Initialize our pointers to global driver 
    // data and to HAL callbacks to NULL
    pThisDisplay->pD3DDriverData16 = 0;
    pThisDisplay->pD3DDriverData32 = 0;

    pThisDisplay->pD3DHALCallbacks16 = 0;
    pThisDisplay->pD3DHALCallbacks32 = 0;

    pThisDisplay->pD3DHALExecuteCallbacks16 = 0;
    pThisDisplay->pD3DHALExecuteCallbacks32 = 0;       

    // Allocate memory for the global driver data structure.
    SHARED_HEAP_ALLOC(&pThisDisplay->pD3DDriverData16, 
                      &pThisDisplay->pD3DDriverData32, 
                      sizeof(D3DHAL_GLOBALDRIVERDATA));
             
    if (pThisDisplay->pD3DDriverData32 == 0)
    {
        DISPDBG((ERRLVL, "ERROR: _D3DHALCreateDriver: "
                         "Failed to allocate driverdata memory"));
        
        DBG_EXIT(_D3DHALCreateDriver,0);         
        return;
    }
    
    DISPDBG((DBGLVL,"Allocated D3DDriverData Memory: p16:0x%x, p32:0x%x", 
                     pThisDisplay->pD3DDriverData16, 
                     pThisDisplay->pD3DDriverData32));

    // Allocate memory for the global HAL callback data structure.
    SHARED_HEAP_ALLOC(&pThisDisplay->pD3DHALCallbacks16, 
                      &pThisDisplay->pD3DHALCallbacks32, 
                      sizeof(D3DHAL_CALLBACKS));
             
    if (pThisDisplay->pD3DHALCallbacks32 == 0)
    {
        DISPDBG((ERRLVL, "ERROR: _D3DHALCreateDriver: "
                         "Failed to allocate callback memory"));

        SHARED_HEAP_FREE(&pThisDisplay->pD3DDriverData16, 
                         &pThisDisplay->pD3DDriverData32,
                         TRUE);
                
        DBG_EXIT(_D3DHALCreateDriver, 0); 
        return;
    }

    DISPDBG((DBGLVL,"Allocated HAL Callbacks Memory: p16:0x%x, p32:0x%x", 
                    pThisDisplay->pD3DHALCallbacks16, 
                    pThisDisplay->pD3DHALCallbacks32));

    // Allocate memory for the global Vertex Buffer callback data structure.
    SHARED_HEAP_ALLOC(&pThisDisplay->pD3DHALExecuteCallbacks16, 
                      &pThisDisplay->pD3DHALExecuteCallbacks32, 
                      sizeof(DDHAL_D3DBUFCALLBACKS));
             
    if (pThisDisplay->pD3DHALExecuteCallbacks32 == 0)
    {       
        DISPDBG((ERRLVL, "ERROR: _D3DHALCreateDriver: "
                         "Failed to allocate callback memory"));

        SHARED_HEAP_FREE(&pThisDisplay->pD3DDriverData16, 
                         &pThisDisplay->pD3DDriverData32,
                         TRUE);
        SHARED_HEAP_FREE(&pThisDisplay->pD3DHALCallbacks16, 
                         &pThisDisplay->pD3DHALCallbacks32,
                         TRUE);                          
                
        DBG_EXIT(_D3DHALCreateDriver, 0); 
        return;
    }

    DISPDBG((DBGLVL,"Allocated Vertex Buffer Callbacks Memory: "
                    "p16:0x%x, p32:0x%x", 
                    pThisDisplay->pD3DHALExecuteCallbacks16, 
                    pThisDisplay->pD3DHALExecuteCallbacks32));
               
    //------------------------------------------------------
    // Fill in the data structures the driver has to provide
    //------------------------------------------------------
    
    // Get the Pointers
    pD3DDriverData = (D3DHAL_GLOBALDRIVERDATA*)pThisDisplay->pD3DDriverData32;
    pD3DHALCallbacks = (D3DHAL_CALLBACKS*)pThisDisplay->pD3DHALCallbacks32;
    pD3DBufCallbacks = 
                (DDHAL_D3DBUFCALLBACKS *)pThisDisplay->pD3DHALExecuteCallbacks32;

    // Clear the global data
    memset(pD3DDriverData, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    pD3DDriverData->dwSize = sizeof(D3DHAL_GLOBALDRIVERDATA);
    
    // Clear the HAL callbacks
    memset(pD3DHALCallbacks, 0, sizeof(D3DHAL_CALLBACKS));
    pD3DHALCallbacks->dwSize = sizeof(D3DHAL_CALLBACKS);

    // Clear the Vertex Buffer callbacks
    memset(pD3DBufCallbacks, 0, sizeof(DDHAL_D3DBUFCALLBACKS));
    pD3DBufCallbacks->dwSize = sizeof(DDHAL_D3DBUFCALLBACKS);
                          
    // Report that we can texture from nonlocal vidmem only if the 
    // card is an AGP one and AGP is enabed.
    if (pThisDisplay->bCanAGP)
    {
        g_P3RXCaps.dwDevCaps |= D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
    }

#if DX7_ANTIALIAS
    // Report we support fullscreen antialiasing
    g_P3RXCaps.dpcTriCaps.dwRasterCaps |= 
#if DX8_DDI    
                                D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  |
#endif                                
                                D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT;
#endif // DX7_ANTIALIAS
               
#if DX8_3DTEXTURES
    // Report we support 3D textures
    g_P3RXCaps.dpcTriCaps.dwTextureCaps |= D3DPTEXTURECAPS_VOLUMEMAP |
                                           D3DPTEXTURECAPS_VOLUMEMAP_POW2;
#endif // DX8_3DTEXTURES

//@@BEGIN_DDKSPLIT
#if DX7_WBUFFER
    g_P3RXCaps.dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_WBUFFER;
#endif // DX7_WBUFFER
//@@END_DDKSPLIT

#if DX8_DDI    
    if (TLCHIP_GAMMA)
    {
        // Enable handling of the new D3DRS_COLORWRITEENABLE
        // but only for GVX1 since VX1 has trouble with this at 16bpp
        g_P3RXCaps.dpcTriCaps.dwMiscCaps |= D3DPMISCCAPS_COLORWRITEENABLE;
        g_P3RXCaps.dpcLineCaps.dwMiscCaps |= D3DPMISCCAPS_COLORWRITEENABLE;
    }

    // Enable new cap for mipmap support
    g_P3RXCaps.dpcTriCaps.dwTextureCaps |= D3DPTEXTURECAPS_MIPMAP;
    g_P3RXCaps.dpcLineCaps.dwTextureCaps |= D3DPTEXTURECAPS_MIPMAP; 

#endif // DX8_DDI  

    //---------------------------
    // Fill in global driver data
    //---------------------------

    // Hardware caps supoorted
    pD3DDriverData->dwNumVertices = 0;       
    pD3DDriverData->dwNumClipVertices = 0;
    pD3DDriverData->hwCaps = g_P3RXCaps;

    // Build a table with the texture formats supported. Store in pThisDisplay
    // as we will need this also for DdCanCreateSurface. ( Notice that since 
    // _D3DHALCreateDriver will be called in every driver load or mode change,
    // we will have valid TextureFormats in pThisDisplay whenever 
    // DdCanCreateSurface is called )
    __D3D_BuildTextureFormatsP3(pThisDisplay, 
                            &pThisDisplay->TextureFormats[0],
                            &pThisDisplay->dwNumTextureFormats);

    pD3DDriverData->dwNumTextureFormats = pThisDisplay->dwNumTextureFormats;                                              
    pD3DDriverData->lpTextureFormats = pThisDisplay->TextureFormats;

    //---------------------------------------
    // Fill in context handling HAL callbacks
    //---------------------------------------
    pD3DHALCallbacks->ContextCreate  = D3DContextCreate;
    pD3DHALCallbacks->ContextDestroy = D3DContextDestroy;


    //---------------------------------------------------
    // Fill in Vertex Buffer callbacks pointers and flags
    //---------------------------------------------------

#if !DX7_VERTEXBUFFERS   
    // We won't use this structure at all so delete it
    SHARED_HEAP_FREE(&pThisDisplay->pD3DHALExecuteCallbacks16, 
                     &pThisDisplay->pD3DHALExecuteCallbacks32,
                     TRUE);       
    pD3DBufCallbacks = NULL;
//@@BEGIN_DDKSPLIT
#else    
    pD3DBufCallbacks->dwSize = sizeof(DDHAL_D3DBUFCALLBACKS);
    pD3DBufCallbacks->dwFlags =  DDHAL_EXEBUFCB32_CANCREATEEXEBUF |
                                 DDHAL_EXEBUFCB32_CREATEEXEBUF    |
                                 DDHAL_EXEBUFCB32_DESTROYEXEBUF   |
                                 DDHAL_EXEBUFCB32_LOCKEXEBUF      |
                                 DDHAL_EXEBUFCB32_UNLOCKEXEBUF;
#if WNT_DDRAW
    // Execute buffer callbacks for WinNT
    pD3DBufCallbacks->CanCreateD3DBuffer = D3DCanCreateD3DBuffer;
    pD3DBufCallbacks->CreateD3DBuffer = D3DCreateD3DBuffer;
    pD3DBufCallbacks->DestroyD3DBuffer = D3DDestroyD3DBuffer;
    pD3DBufCallbacks->LockD3DBuffer = D3DLockD3DBuffer;
    pD3DBufCallbacks->UnlockD3DBuffer = D3DUnlockD3DBuffer;                                 
#else 

    // Execute buffer callbacks for Win9x
    pD3DBufCallbacks->CanCreateExecuteBuffer = D3DCanCreateD3DBuffer;
    pD3DBufCallbacks->CreateExecuteBuffer = D3DCreateD3DBuffer;
    pD3DBufCallbacks->DestroyExecuteBuffer = D3DDestroyD3DBuffer;
    pD3DBufCallbacks->LockExecuteBuffer = D3DLockD3DBuffer;
    pD3DBufCallbacks->UnlockExecuteBuffer = D3DUnlockD3DBuffer;

#endif // WNT_DDRAW
//@@END_DDKSPLIT

#endif // DX7_VERTEXBUFFERS         

    //---------------------------------------------------------
    // We return with updated pThisDisplay internal pointers to 
    // the driver data, HAL and Vertex Buffer structures.
    //---------------------------------------------------------
    pThisDisplay->lpD3DGlobalDriverData = (ULONG_PTR)pD3DDriverData;
    pThisDisplay->lpD3DHALCallbacks = (ULONG_PTR)pD3DHALCallbacks;
    pThisDisplay->lpD3DBufCallbacks = (ULONG_PTR)pD3DBufCallbacks;    

#ifndef WNT_DDRAW

    //
    // Set up the same information in DDHALINFO
    //

//@@BEGIN_DDKSPLIT
#ifdef W95_DDRAW
    
    //
    // Our {in|ex}ternal header files are not completely consistent regarding
    // these 2 callback functions, internally they are typed function pointers,
    // externally they are just DWORDs.
    //

    pThisDisplay->ddhi32.lpD3DGlobalDriverData = pD3DDriverData;
    pThisDisplay->ddhi32.lpD3DHALCallbacks     = pD3DHALCallbacks;
#else
//@@END_DDKSPLIT
    pThisDisplay->ddhi32.lpD3DGlobalDriverData = (ULONG_PTR)pD3DDriverData;
    pThisDisplay->ddhi32.lpD3DHALCallbacks     = (ULONG_PTR)pD3DHALCallbacks;
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT
    pThisDisplay->ddhi32.lpDDExeBufCallbacks   = pD3DBufCallbacks;

#endif

    DBG_EXIT(_D3DHALCreateDriver,0); 
    return;
} // _D3DHALCreateDriver


//-----------------------------------------------------------------------------
//
// void _D3DGetDriverInfo
//
// _D3DGetDriverInfo is a helper function called by DdGetDriverInfo , not a 
// callback. Its main purpouse is to centralize the second part of D3D 
// initialization (the first part is handled by _D3DHALCreateDriver) . 
//
// _D3DGetDriverInfo handles the 
//
//           GUID_D3DExtendedCaps
//           GUID_D3DParseUnknownCommandCallback         
//           GUID_D3DCallbacks3
//           GUID_ZPixelFormats
//           GUID_Miscellaneous2Callbacks
//
// GUIDs and fills all the relevant information associated to them. 
// GUID_D3DCallbacks2 is not handled at all because it is a legacy GUID.
//
//-----------------------------------------------------------------------------
void 
_D3DGetDriverInfo(
    LPDDHAL_GETDRIVERINFODATA lpData)
{
    DWORD dwSize;
    P3_THUNKEDDATA *pThisDisplay;

    DBG_ENTRY(_D3DGetDriverInfo);

    // Get a pointer to the chip we are on.
    
#if WNT_DDRAW
    pThisDisplay = (P3_THUNKEDDATA*)(((PPDEV)(lpData->dhpdev))->thunkData);
#else    
    pThisDisplay = (P3_THUNKEDDATA*)lpData->dwContext;
    if (! pThisDisplay) 
    {
        pThisDisplay = g_pDriverData;
    }    
#endif

    // Fill in required Miscellaneous2 callbacks
    if ( MATCH_GUID(lpData->guidInfo, GUID_Miscellaneous2Callbacks))
    {
        DDHAL_DDMISCELLANEOUS2CALLBACKS DDMisc2;

        DISPDBG((DBGLVL, "  GUID_Miscellaneous2Callbacks"));

        memset(&DDMisc2, 0, sizeof(DDMisc2));

        dwSize = min(lpData->dwExpectedSize, 
                     sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS));
        lpData->dwActualSize = sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS);

        ASSERTDD((lpData->dwExpectedSize == 
                    sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS)), 
                  "ERROR: Callbacks 2 size incorrect!");

        DDMisc2.dwSize = dwSize;
        DDMisc2.dwFlags = DDHAL_MISC2CB32_GETDRIVERSTATE | 
                          DDHAL_MISC2CB32_CREATESURFACEEX | 
                          DDHAL_MISC2CB32_DESTROYDDLOCAL;
                          
        DDMisc2.GetDriverState = D3DGetDriverState;
        DDMisc2.CreateSurfaceEx = D3DCreateSurfaceEx;
        DDMisc2.DestroyDDLocal = D3DDestroyDDLocal;

        memcpy(lpData->lpvData, &DDMisc2, dwSize);
        lpData->ddRVal = DD_OK;
    }

    // Fill in the extended caps 
    if (MATCH_GUID((lpData->guidInfo), GUID_D3DExtendedCaps) )
    {
        DISPDBG((DBGLVL, "  GUID_D3DExtendedCaps"));
        dwSize = min(lpData->dwExpectedSize, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        lpData->dwActualSize = sizeof(D3DHAL_D3DEXTENDEDCAPS);
 
        memcpy(lpData->lpvData, &gc_D3DEC, sizeof(gc_D3DEC) );
        lpData->ddRVal = DD_OK;
    }

    // Grab the pointer to the ParseUnknownCommand OS callback 
    if ( MATCH_GUID(lpData->guidInfo, GUID_D3DParseUnknownCommandCallback) )
    {
        DISPDBG((DBGLVL, "Get D3DParseUnknownCommandCallback"));

        *(ULONG_PTR *)(&pThisDisplay->pD3DParseUnknownCommand) = 
                                                    (ULONG_PTR)lpData->lpvData;

        ASSERTDD((pThisDisplay->pD3DParseUnknownCommand),
                 "D3D ParseUnknownCommand callback == NULL");
                 
        lpData->ddRVal = DD_OK;
    }

    // Fill in ZBuffer/Stencil formats supported. If you don't respond to
    // this GUID, ZBuffer formats will be inferred from the D3DDEVICEDESC 
    // copied in _D3DHALCreateDriver
    if ( MATCH_GUID(lpData->guidInfo, GUID_ZPixelFormats))
    {
        DISPDBG((DBGLVL, "  GUID_ZPixelFormats"));

        dwSize = min(lpData->dwExpectedSize, sizeof(P3RXZFormats));
        lpData->dwActualSize = sizeof(P3RXZFormats);
        memcpy(lpData->lpvData, &P3RXZFormats, dwSize);

        lpData->ddRVal = DD_OK;
    }

    // Fill in required D3DCallbacks3 callbacks
    if ( MATCH_GUID(lpData->guidInfo, GUID_D3DCallbacks3) )
    {
        D3DHAL_CALLBACKS3 D3DCallbacks3;
        memset(&D3DCallbacks3, 0, sizeof(D3DCallbacks3));

        DISPDBG((DBGLVL, "  GUID_D3DCallbacks3"));
        dwSize = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS3));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        
        ASSERTDD((lpData->dwExpectedSize == sizeof(D3DHAL_CALLBACKS3)), 
                  "ERROR: Callbacks 3 size incorrect!");

        D3DCallbacks3.dwSize = dwSize;
        D3DCallbacks3.dwFlags = D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE  |
                                D3DHAL3_CB32_DRAWPRIMITIVES2;

        D3DCallbacks3.DrawPrimitives2 = D3DDrawPrimitives2_P3;      
        D3DCallbacks3.ValidateTextureStageState = D3DValidateDeviceP3;

        memcpy(lpData->lpvData, &D3DCallbacks3, dwSize);
        lpData->ddRVal = DD_OK;
    }

    // Check for calls to GetDriverInfo2
    // Notice : GUID_GetDriverInfo2 has the same value as GUID_DDStereoMode
#if DX8_DDI
    if ( MATCH_GUID(lpData->guidInfo, GUID_GetDriverInfo2) )
#else
    if ( MATCH_GUID(lpData->guidInfo, GUID_DDStereoMode) )
#endif
    {
#if DX8_DDI
        // Make sure this is actually a call to GetDriverInfo2 
        // ( and not a call to DDStereoMode!)
        if (D3DGDI_IS_GDI2(lpData))
        {
            // Yes, its a call to GetDriverInfo2, fetch the
            // DD_GETDRIVERINFO2DATA data structure.
            DD_GETDRIVERINFO2DATA* pgdi2 = D3DGDI_GET_GDI2_DATA(lpData);
            DD_GETFORMATCOUNTDATA* pgfcd;
            DD_GETFORMATDATA*      pgfd;
            DD_DXVERSION*          pdxv;

            // What type of request is this?
            switch (pgdi2->dwType)
            {
            case D3DGDI2_TYPE_DXVERSION:
                // This is a way for a driver on NT to find out the DX-Runtime 
                // version. This information is provided to a new driver (i.e. 
                // one that  exposes GETDRIVERINFO2) for DX7 applications and 
                // DX8 applications. And you should get x0000800 for 
                // dwDXVersion; or more accurately, you should get
                // DD_RUNTIME_VERSION which is defined in ddrawi.h.
                pdxv = (DD_DXVERSION*)pgdi2;  
                pThisDisplay->dwDXVersion = pdxv->dwDXVersion;
                lpData->dwActualSize = sizeof(DD_DXVERSION);
                lpData->ddRVal       = DD_OK;                
                break;
                
            case D3DGDI2_TYPE_GETFORMATCOUNT:
                {
                    // Its a request for the number of texture formats
                    // we support. Get the extended data structure so
                    // we can fill in the format count field.
                    pgfcd = (DD_GETFORMATCOUNTDATA*)pgdi2;
                    pgfcd->dwFormatCount = DX8_FORMAT_COUNT;
                    lpData->dwActualSize = sizeof(DD_GETFORMATCOUNTDATA);
                    lpData->ddRVal       = DD_OK;
                }
                break;

            case D3DGDI2_TYPE_GETFORMAT:
                {
                    // Its a request for a particular format we support.
                    // Get the extended data structure so we can fill in
                    // the format field.
                    pgfd = (DD_GETFORMATDATA*)pgdi2;
                    
                    // Initialize the surface description and copy over
                    // the pixel format from out pixel format table.
                    memcpy(&pgfd->format, 
                           &DX8FormatTable[pgfd->dwFormatIndex], 
                           sizeof(pgfd->format));
                    lpData->dwActualSize = sizeof(DD_GETFORMATDATA);
                    lpData->ddRVal       = DD_OK;
                }
                break;

            case D3DGDI2_TYPE_GETD3DCAPS8:
                {
                    // The runtime is requesting the DX8 D3D caps 

                    int    i;
                    size_t copySize;                   
                    
                    // We will populate this caps as much as we can
                    // from the DX7 caps structure(s). ( We need anyway
                    // to be able to report DX7 caps for DX7 apps )
                    __D3D_Fill_DX8Caps(&g_P3RX_D3DCaps8,
                                       &g_P3RXCaps,
                                       &gc_D3DEC,
                                       &pThisDisplay->ddhi32);

                    // And now we fill anything that might not be there
                    // These fields are new and absent from any  other legacy 
                    // structure

                    g_P3RX_D3DCaps8.DeviceType = D3DDEVTYPE_HAL;   // Device Info 
                    g_P3RX_D3DCaps8.AdapterOrdinal = 0;

#if DX_NOT_SUPPORTED_FEATURE
                    // NOTE: In some beta releases of this sample driver we 
                    //       used to setup bit caps for using it as a pure 
                    //       device (D3DDEVCAPS_PUREDEVICE). On the final 
                    //       DX8 release pure devices are not allowed on 
                    //       non-TnL/non hwvp parts as they don't give any 
                    //       real advantage over non-pure ones. 
                    
                    g_P3RX_D3DCaps8.DevCaps |= D3DDEVCAPS_PUREDEVICE;
#endif                    

#if DX8_3DTEXTURES
                    // On Windows XP the ability to lock just a subvolume of a 
                    // volume texture has been introduced in DX8.1 (Windows 2000 
                    // will ignore it)
                    g_P3RX_D3DCaps8.DevCaps |= D3DDEVCAPS_SUBVOLUMELOCK;
#endif // DX8_3DTEXTURES                    
                    
                    // Indicating that the GDI part of the driver can change
                    // gamma ramp while running in full-screen mode.
                    g_P3RX_D3DCaps8.Caps2 |= D3DCAPS2_FULLSCREENGAMMA;

                    // The following field can/should be left as 0 as the
                    // runtime will field them by itself.
                    g_P3RX_D3DCaps8.Caps3 = 0;                
                    g_P3RX_D3DCaps8.PresentationIntervals = 0;

#if DX_NOT_SUPPORTED_FEATURE
                    // If your hw/driver supports colored cursor without
                    // limitations then set these caps as below. We don't
                    // do this in our driver because we have a hw limitation
                    // of 16 colors on the cursor. WHQL tests therefore
                    // fail because of this limitation
                    g_P3RX_D3DCaps8.CursorCaps = D3DCURSORCAPS_COLOR;   
                    
                    // Signal that the driver does support hw cursors
                    // both for hi resolution modes ( height >= 400) and
                    // for low resolution modes as well.
                    g_P3RX_D3DCaps8.CursorCaps |= D3DCURSORCAPS_LOWRES;
#else
                    // We have some limitations (read above) in the Perm3 
                    // hardware so we're not supporting these caps here
                    g_P3RX_D3DCaps8.CursorCaps = 0;                    
#endif                                        
                    // Miscellanneous settings new DX8 features as
                    // pointsprites, multistreaming, 3D textures, 
                    // pixelshaders and vertex shaders
                    g_P3RX_D3DCaps8.MaxVertexIndex = 0x000FFFFF;
                    
#if DX8_POINTSPRITES                      
                    // Notify we can handle pointsprite size
                    g_P3RX_D3DCaps8.FVFCaps |= D3DFVFCAPS_PSIZE;
                    // Notice that the MaxPointSize has to be at least 16
                    // per the DX8 specification for pointsprites.
                    g_P3RX_D3DCaps8.MaxPointSize = P3_MAX_POINTSPRITE_SIZE;
#endif                    

                    // Any DX8 driver must declare it suppports 
                    // AT LEAST 1 stream. Otherwise its used as a DX7 driver.
                    g_P3RX_D3DCaps8.MaxStreams = 1;
                    
                    g_P3RX_D3DCaps8.MaxVertexBlendMatrixIndex = 0; 
                    
                    // NOTE: It is essential that the macros D3DVS_VERSION
                    // and D3DPS_VERSION be used to intialize the vertex
                    // and pixel shader version respecitively. The format
                    // of the version DWORD is complex so please don't try
                    // and build the version DWORD manually.
                    g_P3RX_D3DCaps8.VertexShaderVersion = D3DVS_VERSION(0, 0);
                    g_P3RX_D3DCaps8.PixelShaderVersion  = D3DPS_VERSION(0, 0);

#if DX8_3DTEXTURES                     
                    g_P3RX_D3DCaps8.MaxVolumeExtent = 2048;
#endif                    
        
                    // D3DPTFILTERCAPS for IDirect3DCubeTexture8's                    
                    g_P3RX_D3DCaps8.CubeTextureFilterCaps = 0;      

                    // D3DLINECAPS
                    g_P3RX_D3DCaps8.LineCaps = D3DLINECAPS_TEXTURE  |
                                               D3DLINECAPS_ZTEST    |
                                               D3DLINECAPS_BLEND    |
                                               D3DLINECAPS_ALPHACMP |
                                               D3DLINECAPS_FOG;
                                               
                    // max number of primitives per DrawPrimitive call
                    g_P3RX_D3DCaps8.MaxPrimitiveCount = 0x000FFFFF;         
                     // max value of pixel shade
                    g_P3RX_D3DCaps8.MaxPixelShaderValue = 0;       
                    // max stride for SetStreamSource
                    // we will use this defualt value for now
                    g_P3RX_D3DCaps8.MaxStreamStride = 256;    
                    // number of vertex shader constant 
                    g_P3RX_D3DCaps8.MaxVertexShaderConst = 0;       

#if DX8_3DTEXTURES 
                    g_P3RX_D3DCaps8.VolumeTextureFilterCaps = 
                                           D3DPTFILTERCAPS_MINFPOINT |
                                           D3DPTFILTERCAPS_MAGFPOINT;
                                           
                    g_P3RX_D3DCaps8.VolumeTextureAddressCaps =     
                                           D3DPTADDRESSCAPS_WRAP     |
                                           D3DPTADDRESSCAPS_MIRROR   |                                           
                                           D3DPTADDRESSCAPS_CLAMP;
#endif // DX8_3DTEXTURES

                    // It should be noted that the dwExpectedSize field
                    // of DD_GETDRIVERINFODATA is not used for
                    // GetDriverInfo2 calls and should be ignored.                   
                    copySize = min(sizeof(g_P3RX_D3DCaps8), 
                                   pgdi2->dwExpectedSize);
                    memcpy(lpData->lpvData, &g_P3RX_D3DCaps8, copySize);
                    lpData->dwActualSize = copySize;
                    lpData->ddRVal       = DD_OK;
                }
            default:
                // Default behavior for any other type.
                break;
            }
        }
        else
#endif // DX8_DDI
        {
#if WNT_DDRAW
#if DX7_STEREO
            PDD_STEREOMODE pDDStereoMode;

            // Permedia3 supports all modes as stereo modes.
            // for test purposes, we restrict them to something
            // larger than 320x240

            //
            // note: this GUID_DDStereoMode is only used on NT to
            // report stereo modes. There is no need to implement
            // it in win9x drivers. Win9x drivers report stereo
            // modes by setting the DDMODEINFO_STEREO bit in the
            // dwFlags member of the DDHALMODEINFO structure.
            // It is also recommended to report DDMODEINFO_MAXREFRESH
            // for stereo modes when running under a runtime >= DX7 to
            // allow applications to select higher refresh rates for
            // stereo modes.
            //

            if (lpData->dwExpectedSize >= sizeof(PDD_STEREOMODE))
            {
                pDDStereoMode = (PDD_STEREOMODE)lpData->lpvData;

                pDDStereoMode->bSupported =
                    _DD_bIsStereoMode(pThisDisplay,
                                      pDDStereoMode->dwWidth,
                                      pDDStereoMode->dwHeight,
                                      pDDStereoMode->dwBpp);

                DISPDBG((DBGLVL,"  GUID_DDStereoMode(%d,%d,%d,%d=%d)",
                    pDDStereoMode->dwWidth,
                    pDDStereoMode->dwHeight,
                    pDDStereoMode->dwBpp,
                    pDDStereoMode->dwRefreshRate,
                    pDDStereoMode->bSupported));

                lpData->dwActualSize = sizeof(DD_STEREOMODE);
                lpData->ddRVal = DD_OK;        
            }
#endif // DX7_STEREO
#endif // WNT_DDRAW
        }
    }

    DBG_EXIT(_D3DGetDriverInfo, 0);
    
} // _D3DGetDriverInfo

//-----------------------------------------------------------------------------
//
// __D3D_BuildTextureFormatsP3
//
// Fills a list of texture formats in.  
// Returns the number of formats specified.  
//
//-----------------------------------------------------------------------------
void 
__D3D_BuildTextureFormatsP3(
    P3_THUNKEDDATA *pThisDisplay, 
    DDSURFACEDESC TexFmt[MAX_TEXTURE_FORMAT],
    DWORD *pNumTextures)
{
    int i;

    // Initialise the defaults
    for (i = 0; i < MAX_TEXTURE_FORMAT; i++)
    {
        TexFmt[i].dwSize = sizeof(DDSURFACEDESC);
        TexFmt[i].dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
        TexFmt[i].dwHeight = 0;
        TexFmt[i].dwWidth = 0;
        TexFmt[i].lPitch = 0;
        TexFmt[i].dwBackBufferCount = 0;
        TexFmt[i].dwZBufferBitDepth = 0;
        TexFmt[i].dwReserved = 0;
        TexFmt[i].lpSurface = 0;

        TexFmt[i].ddckCKDestOverlay.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKDestOverlay.dwColorSpaceHighValue = 0;
        
        TexFmt[i].ddckCKDestBlt.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKDestBlt.dwColorSpaceHighValue = 0;

        TexFmt[i].ddckCKSrcOverlay.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKSrcOverlay.dwColorSpaceHighValue = 0;

        TexFmt[i].ddckCKSrcBlt.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKSrcBlt.dwColorSpaceHighValue = 0;
        TexFmt[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    }
    i = 0;

    // 5:5:5 RGB
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0x7C00;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x03E0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x001F;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    i++;

    // 8:8:8 RGB
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 32;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0xff00;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0xff;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    i++;

    // 1:5:5:5 ARGB 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0x7C00;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x03E0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x001F;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
    i++;        
    
    // 4:4:4:4 ARGB
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xf00;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0xf0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0xf;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
    i++;
    
    // 8:8:8:8 ARGB 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 32;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0xff00;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0xff;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    i++;

    // 5:6:5
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xF800;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x07E0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x001F;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    i++;

    // A4L4
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitMask = 0x0F;
    TexFmt[i].ddpfPixelFormat.dwLuminanceAlphaBitMask = 0xF0;
    i++;

    // A8L8
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitMask = 0x00FF;
    TexFmt[i].ddpfPixelFormat.dwLuminanceAlphaBitMask = 0xFF00;
    i++;
    
//@@BEGIN_DDKSPLIT 
#if 0
    // A8
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_ALPHA;
    TexFmt[i].ddpfPixelFormat.dwAlphaBitDepth = 8;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF;
    i++;
#endif    
//@@END_DDKSPLIT

    // L8 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitMask = 0xFF;
    TexFmt[i].ddpfPixelFormat.dwLuminanceAlphaBitMask = 0;
    i++;

#if DX7_PALETTETEXTURE
    // P8 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 8;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0x00000000;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x00000000;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x00000000;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x00000000;

    // Notice we aren't incrementing i for this format. This will effectively
    // cause us to not report the palettized texture format in our DX7 caps
    // list. This is intentional, and driver writers may choose to follow or
    // not this approach. For our DX8 caps list we DO list paletted texture
    // formats as supported. __SUR_bCheckTextureFormat is written to make
    // sure we can create a paletted texture when asked for it.

    // The whole reason behind this approach is because in legacy DX interfaces
    // the TextureSwap method causes the surface and palette handle association 
    // to be lost. While there are some ugly and tricky ways around this (as in 
    // the Permedia2 sample driver), and there is no rational way to fix the 
    // problem. 
    
#endif
    
    // Return the number of texture formats to use
    *pNumTextures = i;
    
} // __D3D_BuildTextureFormatsP3

#if DX8_DDI
//-----------------------------------------------------------------------------
//
// __D3D_Fill_DX8Caps
//
// Fills the D3DCAPS8 structure of a DX8 driver from legacy caps structures.
//
//-----------------------------------------------------------------------------
void 
__D3D_Fill_DX8Caps(
    D3DCAPS8 *pd3d8caps,
    D3DDEVICEDESC_V1 *pDeviceDesc,
    D3DHAL_D3DEXTENDEDCAPS *pD3DEC,
    DDHALINFO *pDDHALInfo)
{

    pd3d8caps->Caps  = pDDHALInfo->ddCaps.dwCaps;
    pd3d8caps->Caps2 = pDDHALInfo->ddCaps.dwCaps2;  

    pd3d8caps->DevCaps           = pDeviceDesc->dwDevCaps;

    pd3d8caps->PrimitiveMiscCaps = pDeviceDesc->dpcTriCaps.dwMiscCaps;
    pd3d8caps->RasterCaps        = pDeviceDesc->dpcTriCaps.dwRasterCaps;
    pd3d8caps->ZCmpCaps          = pDeviceDesc->dpcTriCaps.dwZCmpCaps;
    pd3d8caps->SrcBlendCaps      = pDeviceDesc->dpcTriCaps.dwSrcBlendCaps;
    pd3d8caps->DestBlendCaps     = pDeviceDesc->dpcTriCaps.dwDestBlendCaps;
    pd3d8caps->AlphaCmpCaps      = pDeviceDesc->dpcTriCaps.dwAlphaCmpCaps;
    pd3d8caps->ShadeCaps         = pDeviceDesc->dpcTriCaps.dwShadeCaps;
    pd3d8caps->TextureCaps       = pDeviceDesc->dpcTriCaps.dwTextureCaps;
    pd3d8caps->TextureFilterCaps = pDeviceDesc->dpcTriCaps.dwTextureFilterCaps;      
    pd3d8caps->TextureAddressCaps= pDeviceDesc->dpcTriCaps.dwTextureAddressCaps;

    pd3d8caps->MaxTextureWidth   = pD3DEC->dwMaxTextureWidth;
    pd3d8caps->MaxTextureHeight  = pD3DEC->dwMaxTextureHeight;
    
    pd3d8caps->MaxTextureRepeat  = pD3DEC->dwMaxTextureRepeat;
    pd3d8caps->MaxTextureAspectRatio = pD3DEC->dwMaxTextureAspectRatio;
    pd3d8caps->MaxAnisotropy     = pD3DEC->dwMaxAnisotropy;
    pd3d8caps->MaxVertexW        = pD3DEC->dvMaxVertexW;

    pd3d8caps->GuardBandLeft     = pD3DEC->dvGuardBandLeft;
    pd3d8caps->GuardBandTop      = pD3DEC->dvGuardBandTop;
    pd3d8caps->GuardBandRight    = pD3DEC->dvGuardBandRight;
    pd3d8caps->GuardBandBottom   = pD3DEC->dvGuardBandBottom;

    pd3d8caps->ExtentsAdjust     = pD3DEC->dvExtentsAdjust;
    pd3d8caps->StencilCaps       = pD3DEC->dwStencilCaps;

    pd3d8caps->FVFCaps           = pD3DEC->dwFVFCaps;
    pd3d8caps->TextureOpCaps     = pD3DEC->dwTextureOpCaps;
    pd3d8caps->MaxTextureBlendStages     = pD3DEC->wMaxTextureBlendStages;
    pd3d8caps->MaxSimultaneousTextures   = pD3DEC->wMaxSimultaneousTextures;

    pd3d8caps->VertexProcessingCaps      = pD3DEC->dwVertexProcessingCaps;
    pd3d8caps->MaxActiveLights           = pD3DEC->dwMaxActiveLights;
    pd3d8caps->MaxUserClipPlanes         = pD3DEC->wMaxUserClipPlanes;
    pd3d8caps->MaxVertexBlendMatrices    = pD3DEC->wMaxVertexBlendMatrices;

} // __D3D_Fill_DX8Caps
#endif // DX8_DDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\tvp4020.h ===
//***************************************************************************
//
// Module Name:
// 
//     TVP4020.h
// 
// Abstract:
// 
//     This module contains the definitions for the P2 internal RAMDAC.
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1995  AccelGraphics, Inc.
//
//***************************************************************************

//
// TI TVP4020 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//

typedef struct _tvp4020_regs {
    RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address, Index Register
    RAMDAC_REG  palData;        // 0x01 - palette RAM data
    RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    RAMDAC_REG  pciAddrRd;         // 0x03 - palette/cursor RAM read address
    
    RAMDAC_REG  curColAddr;     // 0x04 - cursor color address
    RAMDAC_REG  curColData;     // 0x05 - cursor color data
    RAMDAC_REG  Reserved1;      // 0x06 - reserved
    RAMDAC_REG  Reserved2;      // 0x07 - reserved

    RAMDAC_REG  Reserved3;      // 0x08 - reserved
    RAMDAC_REG  Reserved4;      // 0x09 - reserved
    RAMDAC_REG  indexData;      // 0x0A - indexed data
    RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data
    
    RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP4020RAMDAC, *pTVP4020RAMDAC;

//
// macro declared by any function wishing to use the P2 internal RAMDAC . MUST be declared
// after P2_DECL.
//

#define TVP4020_DECL \
    pTVP4020RAMDAC   pTVP4020Regs = (pTVP4020RAMDAC)(hwDeviceExtension->pRamdac)

//
// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
//  Palette Access

#define __TVP4020_PAL_WR_ADDR       ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_PAL_RD_ADDR       ((PULONG)&(pTVP4020Regs->pciAddrRd.reg))
#define __TVP4020_PAL_DATA          ((PULONG)&(pTVP4020Regs->palData.reg))

//
// Pixel mask
//

#define __TVP4020_PIXEL_MASK        ((PULONG)&(pTVP4020Regs->pixelMask.reg))

//
// Access to the indexed registers
//

#define __TVP4020_INDEX_ADDR        ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_INDEX_DATA        ((PULONG)&(pTVP4020Regs->indexData.reg))

//
// Access to the Cursor
//

#define __TVP4020_CUR_RAM_WR_ADDR   ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_CUR_RAM_RD_ADDR   ((PULONG)&(pTVP4020Regs->palAddrRd.reg))
#define __TVP4020_CUR_RAM_DATA      ((PULONG)&(pTVP4020Regs->curRAMData.reg))

#define __TVP4020_CUR_COL_ADDR      ((PULONG)&(pTVP4020Regs->curColAddr.reg))
#define __TVP4020_CUR_COL_DATA      ((PULONG)&(pTVP4020Regs->curColData.reg))

//
// Cursor position control
//

#define __TVP4020_CURSOR_X_LSB      ((PULONG)&(pTVP4020Regs->cursorXLow.reg))
#define __TVP4020_CURSOR_X_MSB      ((PULONG)&(pTVP4020Regs->cursorXHigh.reg))
#define __TVP4020_CURSOR_Y_LSB      ((PULONG)&(pTVP4020Regs->cursorYLow.reg))
#define __TVP4020_CURSOR_Y_MSB      ((PULONG)&(pTVP4020Regs->cursorYHigh.reg))



// ----------------------Values for some direct registers-----------------------

/********************************************************************************/
/*                DIRECT REGISTER - CURSOR POSITION CONTROL                        */
/********************************************************************************/
//
//  ** TVP4020_CUR_X_LSB 
//  ** TVP4020_CUR_X_MSB 
//  ** TVP4020_CUR_Y_LSB 
//  ** TVP4020_CUR_Y_MSB 
//        Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
//

#define TVP4020_CURSOR_OFFSCREEN                0x00    // Cursor offscreen

/********************************************************************************/
/*                DIRECT REGISTER - CURSOR COLORS                                 */
/********************************************************************************/

#define TVP4020_CURSOR_COLOR0                   0x01
#define TVP4020_CURSOR_COLOR1                   0x02
#define TVP4020_CURSOR_COLOR2                   0x03

/********************************************************************************/
/*                INDIRECT REGISTER - CURSOR CONTROL                                */
/********************************************************************************/
#define __TVP4020_CURSOR_CONTROL                0x06    // Indirect cursor control - 

//        Default - 0x00

#define TVP4020_CURSOR_SIZE_32                  (0 << 6)// 32x32 cursor
#define TVP4020_CURSOR_SIZE_64                  (1 << 6)// 32x32 cursor

#define TVP4020_CURSOR_32_SEL(i)   ((i) << 4)// one of 4 32x32 cursors  DABO: changed to << 4

#define TVP4020_CURSOR_RAM_ADDRESS(x)    (((x) & 0x03) << 2)// High bits of cursor RAM address
#define TVP4020_CURSOR_RAM_MASK          ((0x03) << 2)       // Mask for high bits of cursor RAM address

// DABO: Added constants for cursor mode
#define TVP4020_CURSOR_OFF               0x00    // Cursor off
#define TVP4020_CURSOR_COLOR             0x01    // 2-bits select color
#define TVP4020_CURSOR_XGA               0x02    // 2-bits select XOR
#define TVP4020_CURSOR_XWIN              0x03    // 2-bits select transparency/color



/********************************************************************************/
/*                INDIRECT REGISTER - COLOR MODE REGISTER                            */
/********************************************************************************/
#define __TVP4020_COLOR_MODE                    0x18    //  Color Mode Register
//        Default - 0x00

#define TVP4020_TRUE_COLOR_ENABLE               (1 << 7)// True Color data accesses LUT
#define TVP4020_TRUE_COLOR_DISABLE              (0 << 7)// Non true color accesses LUT

#define TVP4020_RGB_MODE                        (1 << 5)// RGB mode  DABO: Swapped 0/1 (0=BGR, 1=RGB)
#define TVP4020_BGR_MODE                        (0 << 5)// BGR mode

#define TVP4020_VGA_SELECT                      (0 << 4)// select VGA mode
#define TVP4020_GRAPHICS_SELECT                 (1 << 4)// select graphics modes

#define TVP4020_PIXEL_MODE_CI8                  (0 << 0)// pseudo color or VGA mode
#define TVP4020_PIXEL_MODE_332                  (1 << 0)// 332 true color
#define TVP4020_PIXEL_MODE_2320                 (2 << 0)// 232 off
#define TVP4020_PIXEL_MODE_2321                 (3 << 0)//
#define TVP4020_PIXEL_MODE_5551                 (4 << 0)// 
#define TVP4020_PIXEL_MODE_4444                 (5 << 0)// 
#define TVP4020_PIXEL_MODE_565                  (6 << 0)// 
#define TVP4020_PIXEL_MODE_8888                 (8 << 0)// 
#define TVP4020_PIXEL_MODE_PACKED               (9 << 0)// 24 bit packed

/********************************************************************************/
/*                INDIRECT REGISTER - MODE CONTROL REGISTER                        */
/********************************************************************************/
#define __TVP4020_MODE_CONTROL              0x19    //  Mode control
//        Default - 0x00

#define TVP4020_PRIMARY_INPUT               (0 << 4)// Primary input throuh palette
#define TVP4020_SECONDARY_INPUT             (1 << 4)// Secondary input throuh palette

#define TVP4020_5551_DBL_BUFFER             (1 << 2)// Enable 5551 dbl buffer
#define TVP4020_5551_PACKED                 (0 << 2)// Packed 555 mode

#define TVP4020_ENABLE_STATIC_DBL_BUFFER    (1 << 1)// Static dbl buffer enabled
#define TVP4020_DISABLE_STATIC_DBL_BUFFER   (1 << 1)// Static dbl buffer disabled

#define TVP4020_SELECT_FRONT_MODE           (0 << 0)// Front mode
#define TVP4020_SELECT_BACK_MODE            (1 << 0)// Back mode

/********************************************************************************/
/*                INDIRECT REGISTER - PALETTE PAGE                                */
/********************************************************************************/
#define __TVP4020_PALETTE_PAGE                    0x1C    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - MISC CONTROL                                */
/********************************************************************************/
#define __TVP4020_MISC_CONTROL            0x1E    //  
//        Default - 0x00

#define TVP4020_SYNC_ENABLE               (1 << 5)// Output SYNC info onto IOG
#define TVP4020_SYNC_DISABLE              (0 << 5)// No SYNC IOG output

#define TVP4020_PEDESTAL_0                (0 << 4)// 0 IRE blanking pedestal
#define TVP4020_PEDESTAL_75               (1 << 4)// 7.5 IRE blanking pedestal

#define TVP4020_VSYNC_INVERT              (1 << 3)// invert VSYNC output polarity
#define TVP4020_VSYNC_NORMAL              (0 << 3)// normal VSYNC output polarity

#define TVP4020_HSYNC_INVERT              (1 << 2)// invert HSYNC output polarity
#define TVP4020_HSYNC_NORMAL              (0 << 3)// normal HSYNC output polarity

#define TVP4020_DAC_8BIT                  (1 << 1)// DAC is in 8-bit mode
#define TVP4020_DAC_6BIT                  (0 << 1)// DAC is in 6-bit mode

#define TVP4020_DAC_POWER_ON              (0 << 0)// Turn DAC Power on 
#define TVP4020_DAC_POWER_OFF             (1 << 0)// Turn DAC Power off 

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY CONTROL                            */
/********************************************************************************/
#define __TVP4020_CK_CONTROL              0x40    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY OVERLAY                           */
/********************************************************************************/
#define __TVP4020_CK_OVR_REG              0x41    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY RED                               */
/********************************************************************************/
#define __TVP4020_CK_RED_REG              0x42    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY GREEN                             */
/********************************************************************************/
#define __TVP4020_CK_GREEN_REG            0x43    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY BLUE                              */
/********************************************************************************/
#define __TVP4020_CK_BLUE_REG             0x44    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - PIXEL CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_PIXCLK_REG_A1                0x20
#define __TVP4020_PIXCLK_REG_A2                0x21
#define __TVP4020_PIXCLK_REG_A3                0x22
#define __TVP4020_PIXCLK_REG_B1                0x23
#define __TVP4020_PIXCLK_REG_B2                0x24
#define __TVP4020_PIXCLK_REG_B3                0x25
#define __TVP4020_PIXCLK_REG_C1                0x26
#define __TVP4020_PIXCLK_REG_C2                0x27
#define __TVP4020_PIXCLK_REG_C3                0x28

#define __TVP4020_PIXCLK_STATUS                0x29

/********************************************************************************/
/*                INDIRECT REGISTER - MEMORU CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_MEMCLK_REG_1                 0x30
#define __TVP4020_MEMCLK_REG_2                 0x31
#define __TVP4020_MEMCLK_REG_3                 0x32

#define __TVP4020_MEMCLK_STATUS                0x33


#if 0
// need a delay between each write to the 4020. The only way to guarantee
// that the write has completed is to read from a Permedia2 control register.
// Reading forces any posted writes to be flushed out. 

#define TVP4020_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}

#else
#define TVP4020_DELAY
#endif

// macro to load a given data value into an internal TVP4020 register.
//

#define TVP4020_SET_INDEX_REG(index) \
{ \
    DEBUG_PRINT((3, "*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_ADDR, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_ADDR, (ULONG)((index) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_WRITE_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index);                            \
    DEBUG_PRINT((3, "*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_DATA, (ULONG)((data) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index); \
    data = VideoPortReadRegisterUlong(__TVP4020_INDEX_DATA) & 0xff;   \
    TVP4020_DELAY; \
    DEBUG_PRINT((3, "0x%X <-- *(0x%X)\n", data, __TVP4020_INDEX_DATA)); \
}

// DABO: For compatibility with TVP3026
#define TVP4020_LOAD_CURSOR_CTRL(data) \
{ \
    volatile LONG   __temp;                                    \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    __temp &= ~(0x03) ;                                        \
    __temp |= ((data) & 0x03) ;                                \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp); \
}

//
// macros to write a given RGB triplet into cursors 0, 1 and 2
//

#define TVP4020_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR, (ULONG)(TVP4020_CURSOR_COLOR0));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR, (ULONG)(TVP4020_CURSOR_COLOR1));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR, (ULONG)(TVP4020_CURSOR_COLOR2));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(blue));   \
    TVP4020_DELAY; \
}



//
// macros to load a given RGB triple into the TVP4020 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP4020_PALETTE_START and multiple TVP4020_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP4020_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//

#define TVP4020_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR,  (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_RD_ADDR,  (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR, (ULONG)(index));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

//
// macro to read back a given RGB triple from the TVP4020 palette. Use after
// a call to TVP4020_PALETTE_START_RD
//

#define TVP4020_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
}

//
// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//

#define TVP4020_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PIXEL_MASK,  (ULONG)(mask)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(__TVP4020_PIXEL_MASK) & 0xff; \
}

//
// macros to load values into the cursor array
//

#define TVP4020_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP4020_CURSOR_RAM_MASK ;                        \
    __temp |= TVP4020_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
    TVP4020_DELAY; \
}

//
// DABO: Need a similar macro to set the read address for cursor RAM?
// DABO: changed to __TVP4020_CUR_RAM_DATA
//

#define TVP4020_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_DATA, (ULONG)(data)); \
    TVP4020_DELAY; \
}

//
// DABO: changed to __TVP4020_CUR_RAM_DATA
//

#define TVP4020_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP4020_CUR_RAM_DATA) & 0xff; \
    TVP4020_DELAY; \
}

//
// macro to move the cursor
//

#define TVP4020_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_X_LSB,     (ULONG)((x) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_X_MSB,     (ULONG)((x) >> 8));     \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_Y_LSB,     (ULONG)((y) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_Y_MSB,     (ULONG)((y) >> 8));     \
    TVP4020_DELAY; \
}

//
// macro to change the cursor hotspot
//

#define TVP4020_CURSOR_HOTSPOT(x, y) \
{ \
    TVP4020_DELAY; \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\mini\permmem.c ===
//***************************************************************************
//
//  Module Name:
//
//    permmem.c
//
//  Abstract:
//
//    This module contains code to generate initialize table form ROM
//
//  Environment:
//
//    Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,CopyROMInitializationTable)
#pragma alloc_text(PAGE,GenerateInitializationTable)
#pragma alloc_text(PAGE,ProcessInitializationTable)
#pragma alloc_text(PAGE,IntergerToUnicode)
#pragma alloc_text(PAGE,GetBiosVersion)
#endif

VOID 
CopyROMInitializationTable (
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:
       this function should be called for devices that have an expansion ROM
       which contains a register initialization table. The function assumes
       the ROM is present and enabled.

 Arguments:
     hwDeviceExtension - 
           the device extension of the device whose ROM is to be read
     pvROMAddress - 
           base address of the expansion ROM. This function assumes that 
           the offset to the initialization table is defined at 0x1c from
           the beginning of ROM

 Return: 
     void

--*/
{
    PULONG    pulROMTable;
    PVOID     pvROMAddress;
    ULONG     ulTableOffset;
    ULONG     cEntries;
    PULONG    pul;
    ULONG     ul;


    hwDeviceExtension->culTableEntries = 0;

    //
    // just use default values on NT4
    //

    if(hwDeviceExtension->NtVersion == NT4)
    return;

    //
    // the 2-byte offset to the initialization table is given at 0x1c 
    // from the start of ROM
    //

    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         0x1c + 2 );

    if(pvROMAddress == NULL)
    {

        DEBUG_PRINT((1, "CopyROMinitializationTable: Can not access ROM\n"));
        return;

    }
    else if ( *(USHORT *)pvROMAddress != 0xAA55)
    {

        DEBUG_PRINT((1, "CopyROMinitializationTable: ROM Signature 0x%x is invalid\n", 
                     *(USHORT *)pvROMAddress ));
        return;

    }

    ulTableOffset = *((PUSHORT)(0x1c + (PCHAR)pvROMAddress));

    //
    // read the table header (32 bits)
    //

    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         ulTableOffset + 4 );

    if(pvROMAddress == NULL)
    {

        DEBUG_PRINT((1, "CopyROMinitializationTable: Can not access ROM\n"));
        return;
    }


    pulROMTable = (PULONG)(ulTableOffset + (PCHAR)pvROMAddress);

    //
    // the table header (32 bits) has an identification code and a count 
    // of the number of entries in the table
    //

    if((*pulROMTable >> 16) != 0x3d3d)
    {
        DEBUG_PRINT((1, "CopyROMinitializationTable: invalid initialization table header\n"));
        return;
    }

    //
    // number of register address & data pairs
    //

    cEntries = *pulROMTable & 0xffff; 

    if(cEntries == 0)
    {
        DEBUG_PRINT((1, "CopyROMinitializationTable: empty initialization table\n"));
        return;
    }

    //
    // this assert, and the one after the copy should ensure we don't write 
    // past the end of the table
    //

    P2_ASSERT(cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable),
              "ERROR: too many initialization entries\n");


    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         ulTableOffset + 4 + cEntries * sizeof(ULONG) * 2 );

    if(pvROMAddress == NULL)
    {
        DEBUG_PRINT((1, "CopyROMinitializationTable: Can not access ROM\n"));
        return;
    }

    //
    // each entry contains two 32-bit words
    //

    pul = hwDeviceExtension->aulInitializationTable;

    //
    // skip the 4 bype table header
    //

    pulROMTable = (PULONG)(ulTableOffset + 4 + (PCHAR)pvROMAddress);

    ul  = cEntries << 1;

    while(ul--)
    {
        *pul++ = *pulROMTable;
        ++pulROMTable;
    }

    hwDeviceExtension->culTableEntries = 
            (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

    P2_ASSERT(cEntries == hwDeviceExtension->culTableEntries,
                 "ERROR: generated different size init table to that expected\n");

#if DBG

    //
    // output the initialization table
    //

    pul = hwDeviceExtension->aulInitializationTable;
    ul  = hwDeviceExtension->culTableEntries;

    while(ul--)
    {
        ULONG ulReg;
        ULONG ulRegData;

        ulReg = *pul++;
        ulRegData = *pul++;
        DEBUG_PRINT((2, "CopyROMInitializationTable: initializing register %08.8Xh with %08.8Xh\n",
                         ulReg, ulRegData));
    }

#endif //DBG

}

VOID 
GenerateInitializationTable (
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

 Routine Description:
     creates a register initialization table (called if we can't read one
     from ROM). If VGA is enabled the registers are already initialized so
     we just read them back, otherwise we have to use default values

 Arguments:
     hwDeviceExtension - the device for which we are creating the table

 Return: 
     void

--*/
{
    ULONG    cEntries;
    PULONG   pul;
    ULONG    ul;
    int      i, j;
    P2_DECL;

    hwDeviceExtension->culTableEntries = 0;

    cEntries = 6;

    //
    // this assert, and the one after the copy should ensure we don't 
    // write past the end of the table
    //

    P2_ASSERT(cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable),
                 "ERROR: to many initialization entries\n");

    //
    // each entry contains two 32-bit words
    //

    pul = hwDeviceExtension->aulInitializationTable;

    if(hwDeviceExtension->bVGAEnabled)
    {
        //
        // OK: no initialization table but VGA is running so our key 
        // registers have been initialized to sensible values
        //

        DEBUG_PRINT((1, "GenerateinitializationTable: VGA enabled: reading registers\n"));

        //
        // key entries are: ROM control, Boot Address, Memory Config and 
        // VStream Config
        //

        *pul++ = CTRL_REG_OFFSET(ROM_CONTROL);
        *pul++ = VideoPortReadRegisterUlong(ROM_CONTROL);

        *pul++ = CTRL_REG_OFFSET(BOOT_ADDRESS);
        *pul++ = VideoPortReadRegisterUlong(BOOT_ADDRESS);

        *pul++ = CTRL_REG_OFFSET(MEM_CONFIG);
        *pul++ = VideoPortReadRegisterUlong(MEM_CONFIG);

        *pul++ = CTRL_REG_OFFSET(VSTREAM_CONFIG);
        *pul++ = VideoPortReadRegisterUlong(VSTREAM_CONFIG);

        *pul++ = CTRL_REG_OFFSET(VIDEO_FIFO_CTL);
        *pul++ = VideoPortReadRegisterUlong(VIDEO_FIFO_CTL);

        *pul++ = CTRL_REG_OFFSET(V_CLK_CTL);
        *pul++ = VideoPortReadRegisterUlong(V_CLK_CTL);
    }
    else
    {
        //
        // no initialization table and no VGA. Use default values.
        //

        DEBUG_PRINT((2, "PERM2: GenerateInitializationTable() VGA disabled - using default values\n"));

        *pul++ = CTRL_REG_OFFSET(ROM_CONTROL);
        *pul++ = 0;

        *pul++ = CTRL_REG_OFFSET(BOOT_ADDRESS);
        *pul++ = 0x20;

        *pul++ = CTRL_REG_OFFSET(MEM_CONFIG);
        *pul++ = 0xe6002021;

        *pul++ = CTRL_REG_OFFSET(VSTREAM_CONFIG);
        *pul++ = 0x1f0;

        *pul++ = CTRL_REG_OFFSET(VIDEO_FIFO_CTL);
        *pul++ = 0x11008;

        *pul++ = CTRL_REG_OFFSET(V_CLK_CTL);

        if( DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId )
                                                 == PERMEDIA_P2S_ID )
        {
            *pul++ = 0x80;
        }
        else
        {
            *pul++ = 0x40;
        }
    }

    hwDeviceExtension->culTableEntries = 
         (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

    P2_ASSERT(cEntries == hwDeviceExtension->culTableEntries,
          "ERROR: generated different size init table to that expected\n");

#if DBG

    //
    // output the initialization table
    //

    pul = hwDeviceExtension->aulInitializationTable;
    ul = hwDeviceExtension->culTableEntries;

    while(ul--)
    {
        ULONG ulReg;
        ULONG ulRegData;

        ulReg = *pul++;
        ulRegData = *pul++;
        DEBUG_PRINT((2, "GenerateInitializationTable: initializing register %08.8Xh with %08.8Xh\n",
                         ulReg, ulRegData));
    }

#endif //DBG

}

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:
     this function processes the register initialization table

 Arguments:
     hwDeviceExtension - a pointer to the device extension.

 Return: 
     void

--*/

{
    PULONG   pul;
    ULONG    cul;
    ULONG    ulRegAddr, ulRegData;
    PULONG   pulReg;
    ULONG    BaseAddrSelect;
    P2_DECL;

    pul = (PULONG)hwDeviceExtension->aulInitializationTable;
    cul = hwDeviceExtension->culTableEntries;

    while(cul--)
    {
        ulRegAddr = *pul++;
        ulRegData = *pul++;

        BaseAddrSelect = ulRegAddr >> 29;

        if(BaseAddrSelect == 0)
        {
            //
            // the offset is from the start of the control registers
            //

            pulReg = (PULONG)((ULONG_PTR)pCtrlRegs + (ulRegAddr & 0x3FFFFF));
        }
        else
        {
            DEBUG_PRINT((2, "ProcessInitializationTable: Invalid base address select %d regAddr = %d regData = %d\n",
                             BaseAddrSelect, ulRegAddr, ulRegData));
            continue;
        }

        DEBUG_PRINT((2, "ProcessInitializationTable: initializing (region %d) register %08.8Xh with %08.8Xh\n",
                         BaseAddrSelect, pulReg, ulRegData));

        VideoPortWriteRegisterUlong(pulReg, ulRegData);
    }

    //
    // We need a small delay after initializing the above registers
    //

    VideoPortStallExecution(5);
}

BOOLEAN
VerifyBiosSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:
     This function validate a few register values set by bios at boot time

 Arguments:
     hwDeviceExtension - a pointer to the device extension.

 Return: 
     TRUE  - if the everything is all right
     FALSE - if some of the values don't match those in initialization table

--*/

{
    PULONG   pul;
    ULONG    cul;
    ULONG    ulRegAddr, ulRegData;
    PULONG   pulReg;
    ULONG    BaseAddrSelect;
    P2_DECL;

    pul = (PULONG)hwDeviceExtension->aulInitializationTable;
    cul = hwDeviceExtension->culTableEntries;

    while(cul--)
    {
        ulRegAddr = *pul++;
        ulRegData = *pul++;

        BaseAddrSelect = ulRegAddr >> 29;

        if(BaseAddrSelect == 0)
        {
            //
            // the offset is from the start of the control registers
            //

            pulReg = (PULONG)((ULONG_PTR)pCtrlRegs + (ulRegAddr & 0x3FFFFF));           

            //
            // we only care above these registers
            //

            if ( ( pulReg != BOOT_ADDRESS ) && (pulReg != MEM_CONFIG) )
            {
                continue;
            }
        
        }
        else
        {
            DEBUG_PRINT((2, "VerifyBiosSettings: Invalid base address select %d regAddr = %d regData = %d\n",
                             BaseAddrSelect, ulRegAddr, ulRegData));
            continue;
        }

        if( ulRegData != VideoPortReadRegisterUlong(pulReg) )
        {

            DEBUG_PRINT((1, "VerifyBiosSettings: Bios failed to set some registers correctly. \n"));
            return (FALSE);
        }
    }

    return (TRUE);
}


LONG 
GetBiosVersion (
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    OUT PWSTR BiosVersionString
    )

/*++

 Routine Description:

     this function get the bios version and convert it to a unicode string

 Return: 

     lenth of bios version string in bytes

--*/

{

    PVOID     pvROMAddress;
    ULONG     len, ulVersion;
    PCHAR     pByte;


    BiosVersionString[0] = L'\0' ; 

    //
    // just return on NT4
    //

    if( hwDeviceExtension->NtVersion == NT4 )
    {
        return 0;
    }

    //
    // bios version is stored at offset 7 and 8 
    //

    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         7 + 2 );

    if( pvROMAddress == NULL )
    {

        DEBUG_PRINT((1, "GetBiosVersion: Can not access ROM\n"));
        return 0;
    }
    else if ( *(USHORT *)pvROMAddress != 0xAA55)
    {

        DEBUG_PRINT(( 2, "GetBiosVersion: ROM Signature 0x%x is invalid\n", 
                     *(USHORT *)pvROMAddress ));
        return 0;
    }

    pByte = ( PCHAR ) pvROMAddress;

    //
    // get major version number at offset 7
    //

    ulVersion = (ULONG) pByte[7];

    len = IntergerToUnicode( ulVersion, (PWSTR) (&BiosVersionString[0]));

    //
    // a dot between major and minor version number
    //

    BiosVersionString[len] =  L'.' ; 

    len++;
    
    //
    // get minor version number at offset 8
    //

    ulVersion = (ULONG) pByte[8];

    len = len + IntergerToUnicode( ulVersion, (PWSTR) (&BiosVersionString[len]) );

    //
    // len is the number of unicodes in string, we need to return 
    // the string size in bytes
    //

    return (len * sizeof(WCHAR) );

}

LONG 
IntergerToUnicode(
    IN  ULONG Number,
    OUT PWSTR UnicodeString
    )

/*++

 Routine Description:

     this function convert an unsigned long to a unicode string

 Return: 

     the number of the unicodes in UnicodeString


--*/

{
    const WCHAR digits[] = L"0123456789";

    LONG i, len;

    //
    // a ULONG decimal integer will not exceed 10 digits
    //

    WCHAR tmpString[10];

    i = 10;
    len = 0;

    do
    {
        tmpString[--i] = digits[ Number % 10 ];

        Number /= 10;
        len++;

    } while ( Number );

    VideoPortMoveMemory(UnicodeString, &tmpString[i], sizeof(WCHAR) * len  );

    UnicodeString[len] = L'\0' ; 

    return( len );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\chroma.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * DX  SAMPLE CODE *
*                           *******************
*
* Module Name: chroma.h
*
* Content: Chromakeying definitions and inline functions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifdef __CHROMA
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __CHROMA


//-----------------------------------------------------------------------------
//
// In this module we define the 
//
//                 Get8888ScaledChroma 
//                 Get8888ZeroExtendedChroma 

// inline functions used to do texture chroma keying correctly.
//
// All other macros defined in this module are for internal module consumption
// only.
//
//-----------------------------------------------------------------------------

// Get the components for each of the colors
// Put the value into the top bits of a byte.
#define GET_RED_332(a)    (((a) & 0xE0))
#define GET_GREEN_332(a)  (((a) & 0x1C) << 3)
#define GET_BLUE_332(a)   (((a) & 0x03) << 6)

#define GET_ALPHA_2321(a) (((a) & 0x80))
#define GET_RED_2321(a)   (((a) & 0x60) << 1)
#define GET_GREEN_2321(a) (((a) & 0x1C) << 3)
#define GET_BLUE_2321(a)  (((a) & 0x03) << 6)

#define GET_ALPHA_5551(a) (((a) & 0x8000) >> 8)
#define GET_RED_5551(a)   (((a) & 0x7C00) >> 7)
#define GET_GREEN_5551(a) (((a) & 0x03E0) >> 2)
#define GET_BLUE_5551(a)  (((a) & 0x001F) << 3)

#define GET_RED_565(a)    (((a) & 0xF800) >> 8)
#define GET_GREEN_565(a)  (((a) & 0x07E0) >> 3)
#define GET_BLUE_565(a)   (((a) & 0x001F) << 3)

#define GET_ALPHA_4444(a) (((a) & 0xF000) >> 8)
#define GET_RED_4444(a)   (((a) & 0x0F00) >> 4)
#define GET_GREEN_4444(a) (((a) & 0x00F0))
#define GET_BLUE_4444(a)  (((a) & 0x000F) << 4)

#define GET_ALPHA_8888(a) (((a) & 0xFF000000) >> 24)
#define GET_RED_8888(a)   (((a) & 0x00FF0000) >> 16)
#define GET_GREEN_8888(a) (((a) & 0x0000FF00) >> 8)
#define GET_BLUE_8888(a)  (((a) & 0x000000FF))

// These macros assume that the passed value (a) contains no more than the
// designated number of bits set i.e. 11111000 not 1111101 for a 5 bit color
// The macro scales the number to match the internal color conversion of 
// Permedia3.

#define P3SCALE_1_BIT(a) (((a) & 0x80) ? 0xFF : 0x0)
#define P3SCALE_2_BIT(a) ((a) | (((a) & 0xC0) >> 2) \
                              | (((a) & 0xC0) >> 4) \
                              | (((a) & 0xC0) >> 6))
#define P3SCALE_3_BIT(a) ((a) | (((a) & 0xE0) >> 3) | (((a) & 0xC0) >> 6))
#define P3SCALE_4_BIT(a) ((a) | (((a) & 0xF0) >> 4))
#define P3SCALE_5_BIT(a) ((a) | (((a) & 0xE0) >> 5))
#define P3SCALE_6_BIT(a) ((a) | (((a) & 0xC0) >> 6))
#define P3SCALE_7_BIT(a) ((a) | (((a) & 0x80) >> 7))
#define P3SCALE_8_BIT(a) ((a))

#define P3REG_PLACE_RED(a) ((a))
#define P3REG_PLACE_GREEN(a) ((a) << 8)
#define P3REG_PLACE_BLUE(a) ((a) << 16)
#define P3REG_PLACE_ALPHA(a) ((a) << 24)

// The scaling versions.
#define GEN_332_KEY(a)  (P3REG_PLACE_RED  (P3SCALE_3_BIT(GET_RED_332  (a))) |  \
                         P3REG_PLACE_GREEN(P3SCALE_3_BIT(GET_GREEN_332(a))) |  \
                         P3REG_PLACE_BLUE (P3SCALE_2_BIT(GET_BLUE_332 (a))))

#define GEN_2321_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_1_BIT(GET_ALPHA_2321(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_2_BIT(GET_RED_2321  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_3_BIT(GET_GREEN_2321(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_2_BIT(GET_BLUE_2321 (a))))

#define GEN_5551_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_1_BIT(GET_ALPHA_5551(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_5_BIT(GET_RED_5551  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_5_BIT(GET_GREEN_5551(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_5_BIT(GET_BLUE_5551 (a))))

#define GEN_565_KEY(a)  (P3REG_PLACE_RED  (P3SCALE_5_BIT(GET_RED_565  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_6_BIT(GET_GREEN_565(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_5_BIT(GET_BLUE_565 (a))))

#define GEN_4444_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_4_BIT(GET_ALPHA_4444(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_4_BIT(GET_RED_4444  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_4_BIT(GET_GREEN_4444(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_4_BIT(GET_BLUE_4444 (a))))

#define GEN_8888_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_8_BIT(GET_ALPHA_8888(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_8_BIT(GET_RED_8888  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_8_BIT(GET_GREEN_8888(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_8_BIT(GET_BLUE_8888 (a))))

// The shifting versions.
#define GEN_332_SKEY(a)  (P3REG_PLACE_RED  (GET_RED_332  (a)) |  \
                          P3REG_PLACE_GREEN(GET_GREEN_332(a)) |  \
                          P3REG_PLACE_BLUE (GET_BLUE_332 (a)))

#define GEN_2321_SKEY(a) (P3REG_PLACE_ALPHA(GET_ALPHA_2321(a)) | \
                          P3REG_PLACE_RED  (GET_RED_2321  (a)) | \
                          P3REG_PLACE_GREEN(GET_GREEN_2321(a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_2321 (a)))

#define GEN_5551_SKEY(a) (P3REG_PLACE_ALPHA(GET_ALPHA_5551(a)) | \
                          P3REG_PLACE_RED  (GET_RED_5551  (a)) | \
                          P3REG_PLACE_GREEN(GET_GREEN_5551(a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_5551 (a)))

#define GEN_565_SKEY(a)  (P3REG_PLACE_RED  (GET_RED_565  (a)) |  \
                          P3REG_PLACE_GREEN(GET_GREEN_565(a)) |  \
                          P3REG_PLACE_BLUE (GET_BLUE_565 (a)))

#define GEN_4444_SKEY(a) (P3REG_PLACE_ALPHA(GET_ALPHA_4444(a)) | \
                          P3REG_PLACE_RED  (GET_RED_4444  (a)) | \
                          P3REG_PLACE_GREEN(GET_GREEN_4444(a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_4444 (a)))

// The luminance versions
#define GEN_L8_KEY(a)    (P3REG_PLACE_ALPHA(0xFF) | \
                          P3REG_PLACE_RED  (GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_GREEN(GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_8888 (a)))

#define GEN_A8L8_KEY(a)  (P3REG_PLACE_ALPHA(GET_GREEN_8888 (a)) | \
                          P3REG_PLACE_RED  (GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_GREEN(GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_8888 (a)))
                          
#define GEN_A4L4_KEY(a)  (P3REG_PLACE_ALPHA(P3SCALE_4_BIT(GET_GREEN_4444 (a))) | \
                          P3REG_PLACE_RED  (P3SCALE_4_BIT(GET_BLUE_4444 (a))) | \
                          P3REG_PLACE_GREEN(P3SCALE_4_BIT(GET_BLUE_4444 (a))) | \
                          P3REG_PLACE_BLUE (P3SCALE_4_BIT(GET_BLUE_4444 (a))))

//Note: No GEN_8888_SKEY - no difference in functionality.

//-----------------------------------------------------------------------------
//
// __inline Get8888ScaledChroma
//
// Convert a FB Format color to a colorkey value.  The value produced exactly 
// matches the value that the chip will read in from the Framebuffer (it will 
// scale the color into it's internal 8888 format). Non-null pPalEntries  
// indicates that color index should be converted to RGB{A} value. bUsePalAlpha
// indicates whether Alpha channel of the palette should be used. bShift makes
// the conversion use a shift instead of a scale, to match the shift option in
// the P3.
//
//-----------------------------------------------------------------------------
static __inline 
void 
Get8888ScaledChroma(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwSurfFlags,
    DDPIXELFORMAT* pSurfPixFormat,
    DWORD InLowerBound, 
    DWORD InUpperBound, 
    DWORD* OutLowerBound, 
    DWORD* OutUpperBound, 
    DWORD* pPalEntries,
    BOOL bUsePalAlpha, 
    BOOL bShift)
{
    DDPIXELFORMAT* pPixFormat;
    
    DISPDBG((DBGLVL, "InLowerBound  = 0x%08X", InLowerBound));
    DISPDBG((DBGLVL, "InUpperBound = 0x%08X", InUpperBound));

    // Get a pointer to the pixelformat data (not guaranteed to exist.
    // If it doesn't, we use the same format as the display.
    if (DDSurf_HasPixelFormat(dwSurfFlags))
    {
        pPixFormat = pSurfPixFormat;
    }
    else
    {
        pPixFormat = &pThisDisplay->ddpfDisplay;
    }   

    // Is the texture palette indexed?
    if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED4 || 
        pPixFormat->dwFlags & DDPF_PALETTEINDEXED8)
    {
        // Are we doing a lookup through the LUT?  We won't be during a blit
        if (! pPalEntries)
        {
            *OutLowerBound = 
                    CHROMA_LOWER_ALPHA(FORMAT_PALETTE_32BIT(InLowerBound));
            *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_PALETTE_32BIT(InUpperBound));
            DISPDBG((DBGLVL,"Keying of index: %d", InLowerBound));
        }
        else
        {
            DWORD dwTrueColor;

            // ChromaKeying for paletted textures is done on the looked up 
            // color, not the index. This means using a range is meaningless
            // and we have to lookup the color from the palette.  Make sure 
            // the user doesn't force us to access invalid memory. 
                
            dwTrueColor = pPalEntries[(InLowerBound & 0xFF)];

            DISPDBG((DBGLVL,
                    "Texture lookup index: %d, ChromaColor: 0x%x", 
                    InLowerBound, dwTrueColor));
            
            if (bUsePalAlpha)
            {
                *OutLowerBound = dwTrueColor;
                *OutUpperBound = dwTrueColor;
            }
            else
            {
                // Alpha channel of LUT will be set to FF 
                
                *OutLowerBound = CHROMA_LOWER_ALPHA(dwTrueColor);
                *OutUpperBound = CHROMA_UPPER_ALPHA(dwTrueColor);
            }
        }

        return;
    } 

    // Texture is RGB format
    if (pPixFormat->dwFlags & DDPF_RGB)
    {
        DWORD RedMask = pPixFormat->dwRBitMask;
        DWORD AlphaMask = pPixFormat->dwRGBAlphaBitMask;
        switch (pPixFormat->dwRGBBitCount) 
        {
        // 8 Bit RGB Textures
        case 8:
            if (RedMask == 0xE0) 
            {
                DISPDBG((DBGLVL,"  3:3:2"));

                // Never any alpha
                if ( bShift )
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_332_SKEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_332_SKEY(InUpperBound));
                }
                else
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_332_KEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_332_KEY(InUpperBound));
                }
            }
            else 
            {
                DISPDBG((DBGLVL,"  1:2:3:2"));

                if ( bShift )
                {
                    *OutLowerBound = GEN_2321_SKEY(InLowerBound);
                    *OutUpperBound = GEN_2321_SKEY(InUpperBound);
                }
                else
                {
                    *OutLowerBound = GEN_2321_KEY(InLowerBound);
                    *OutUpperBound = GEN_2321_KEY(InUpperBound);
                }

                if (!AlphaMask) 
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
            }
            break;
            
        // 16 Bit RGB Textures
        case 16:
            switch (RedMask)
            {
            case 0xf00:
                DISPDBG((DBGLVL,"  4:4:4:4"));

                if ( bShift )
                {
                    *OutLowerBound = GEN_4444_SKEY(InLowerBound);
                    *OutUpperBound = GEN_4444_SKEY(InUpperBound);
                }
                else
                {
                    *OutLowerBound = GEN_4444_KEY(InLowerBound);
                    *OutUpperBound = GEN_4444_KEY(InUpperBound);
                }
                break;
            case 0x7c00:
                DISPDBG((DBGLVL,"  1:5:5:5"));

                if ( bShift )
                {
                    *OutLowerBound = GEN_5551_SKEY(InLowerBound);
                    *OutUpperBound = GEN_5551_SKEY(InUpperBound);
                }
                else
                {
                    *OutLowerBound = GEN_5551_KEY(InLowerBound);
                    *OutUpperBound = GEN_5551_KEY(InUpperBound);
                }

                if (!AlphaMask)
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
                break;
                
            default:
                // Always supply full range of alpha values to ensure test 
                // is done
                DISPDBG((DBGLVL,"  5:6:5"));

                if ( bShift )
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_565_SKEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_565_SKEY(InUpperBound));
                }
                else
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_565_KEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_565_KEY(InUpperBound));
                }
                break;
                
            } // switch (RedMask)
            break;
            
        // 32/24 Bit RGB Textures
        case 24:
        case 32:
            DISPDBG((DBGLVL,"  8:8:8:8"));
            // If the surface isn't alpha'd then set a valid
            // range of alpha to catch all cases.
            // No change in behavior for shifting or scaling.
            if (!AlphaMask)
            {
                *OutLowerBound = CHROMA_LOWER_ALPHA(GEN_8888_KEY(InLowerBound));
                *OutUpperBound = CHROMA_UPPER_ALPHA(GEN_8888_KEY(InUpperBound));
            }
            else
            {
                *OutLowerBound = GEN_8888_KEY(InLowerBound);
                *OutUpperBound = GEN_8888_KEY(InUpperBound);
            }                               
            break;
            
        } //   switch (pPixFormat->dwRGBBitCount) 
        
        DISPDBG((DBGLVL, "OutLowerBound = 0x%08X", *OutLowerBound));
        DISPDBG((DBGLVL, "OutUpperBound = 0x%08X", *OutUpperBound));
    }
    // luminance formats
    else if (pPixFormat->dwFlags & DDPF_LUMINANCE)
    {
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            if (pPixFormat->dwLuminanceBitCount == 16)
            {
                // 16 bit A8L8
                *OutLowerBound = GEN_A8L8_KEY(InLowerBound);
                *OutUpperBound = GEN_A8L8_KEY(InUpperBound);                  
            }
            else
            {
                // 8 Bit A4L4              
                *OutLowerBound = GEN_A4L4_KEY(InLowerBound);
                *OutUpperBound = GEN_A4L4_KEY(InUpperBound);                
            }
        }
        else
        {
            // 8 Bit L8           
            *OutLowerBound = GEN_L8_KEY(InLowerBound);
            *OutUpperBound = GEN_L8_KEY(InUpperBound);
        }
    }

//@@BEGIN_DDKSPLIT
//AZN - just keep in case we find an app requiring this (Legoland???)
#if 0
    if ( TEST_BUGFIX_FLAG ( IGNORE_CK_ALPHA ) )
    {
        // Fix it up for games that don't realise that they
        // need to set up the alpha-channel of the chromakey
        // values appropriately.
        *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
        *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
    }
#endif
//@@END_DDKSPLIT


} // Get8888ScaledChroma

//-----------------------------------------------------------------------------
//
// __inline Get8888ZeroExtendedChroma
//
//-----------------------------------------------------------------------------
__inline void 
Get8888ZeroExtendedChroma(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwSurfFlags,
    DDPIXELFORMAT* pSurfPixFormat,    
    DWORD LowerBound, 
    DWORD UpperBound, 
    DWORD* OutLowerBound, 
    DWORD* OutUpperBound)
{
    DDPIXELFORMAT* pPixFormat;
    DWORD InLowerBound = LowerBound;
    DWORD InUpperBound = UpperBound;

    DISPDBG((DBGLVL, "InLowerBound  = 0x%08X", InLowerBound));
    DISPDBG((DBGLVL, "InUpperBound = 0x%08X", InUpperBound));

    // Get a pointer to the pixelformat data (not guaranteed to exist.
    // If it doesn't, we use the same format as the display.
    if (DDSurf_HasPixelFormat(dwSurfFlags))
    {
        pPixFormat = pSurfPixFormat;
    }
    else
    {
        pPixFormat = &pThisDisplay->ddpfDisplay;
    }

    {
        DWORD RedMask = pPixFormat->dwRBitMask;
        DWORD AlphaMask = pPixFormat->dwRGBAlphaBitMask;
        switch (pPixFormat->dwRGBBitCount) 
        {
        // 8 Bit RGB Textures
        case 8:
            if (RedMask == 0xE0) 
            {
                // Never any alpha
                *OutLowerBound = 
                    CHROMA_LOWER_ALPHA(FORMAT_332_32BIT_ZEROEXTEND(InLowerBound));
                *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_332_32BIT_ZEROEXTEND(InUpperBound));
            }
            else 
            {
                *OutLowerBound = FORMAT_2321_32BIT_ZEROEXTEND(InLowerBound);
                *OutUpperBound = FORMAT_2321_32BIT_ZEROEXTEND(InUpperBound);
                if (!AlphaMask) 
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
            }
            break;
            
        // 16 Bit RGB Textures
        case 16:
            switch (RedMask)
            {
            case 0xf00:
                *OutLowerBound = (FORMAT_4444_32BIT_ZEROEXTEND(InLowerBound));
                *OutUpperBound = (FORMAT_4444_32BIT_ZEROEXTEND(InUpperBound));
                break;
                
            case 0x7c00:
                *OutLowerBound = FORMAT_5551_32BIT_ZEROEXTEND(InLowerBound);
                *OutUpperBound = FORMAT_5551_32BIT_ZEROEXTEND(InUpperBound);
                if (!AlphaMask) 
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
                break;
                
            default:
                // Always supply full range of alpha values to ensure test 
                // is done
                *OutLowerBound =
                    CHROMA_LOWER_ALPHA(FORMAT_565_32BIT_ZEROEXTEND(InLowerBound));
                *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_565_32BIT_ZEROEXTEND(InUpperBound));
                break;
            }
            break;
            
        // 32/24 Bit RGB Textures
        case 24:
        case 32:
            // If the surface isn't alpha'd then set a valid
            // range of alpha to catch all cases.
            if (!AlphaMask)
            {
                *OutLowerBound = 
                    CHROMA_LOWER_ALPHA(FORMAT_8888_32BIT_BGR(InLowerBound));
                *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_8888_32BIT_BGR(InUpperBound));
            }
            else
            {
                *OutLowerBound = FORMAT_8888_32BIT_BGR(InLowerBound);
                *OutUpperBound = FORMAT_8888_32BIT_BGR(InUpperBound);
            }                               
            break;
            
        } // switch (pPixFormat->dwRGBBitCount)
        
        DISPDBG((DBGLVL, "OutLowerBound = 0x%08X", *OutLowerBound));
        DISPDBG((DBGLVL, "OutUpperBound = 0x%08X", *OutUpperBound));
    }

//@@BEGIN_DDKSPLIT
//AZN - just keep in case we find an app requiring this (Legoland???)
#if 0
    if ( TEST_BUGFIX_FLAG ( IGNORE_CK_ALPHA ) )
    {
        // Fix it up for games that don't realise that they
        // need to set up the alpha-channel of the chromakey
        // values appropriately.
        *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
        *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
    }
#endif
//@@END_DDKSPLIT

} // Get8888ZeroExtendedChroma
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsset.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsset.c
*
* Content: State set (block) management
*
* Copyright (c) 1999-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"

//-----------------------------------------------------------------------------
// This module implements an emulation mechanism for handling state blocks 
// (which are a required feature of the DX7 DDI) for hardware that doesn't
// offer any silicon support of the feature. It works simply by recording the
// render states and texture stage states set during state block recording
// and then "plays" them back when execution of the stage state is requested.
// Internal data structures are interchangeable between an uncompressed
// version (for recording speed) and a compressed format (for memory
// efficiency) since it is anticipated some apps may request thousands of 
// state blocks.
//
// The following symbols have to be replaced according to your perticular
// driver implementation:
//                          - HEAP_ALLOC
//                          - HEAP_FREE
//                          - DISPDBG
//                          - _D3D_ST_ProcessOneRenderState
//                          - _D3D_TXT_ParseTextureStageStates
//-----------------------------------------------------------------------------

#if DX7_D3DSTATEBLOCKS

//-----------------------------------------------------------------------------
//
// P3StateSetRec *__SB_FindStateSet
//
// Find a state identified by dwHandle starting from pRootSS.
// If not found, returns NULL.
//
//-----------------------------------------------------------------------------
P3StateSetRec *__SB_FindStateSet(P3_D3DCONTEXT *pContext,
                                 DWORD dwHandle)
{
    if (dwHandle <= pContext->dwMaxSSIndex)
    {
        return pContext->pIndexTableSS[dwHandle - 1];
    }
    else
    {
        DISPDBG((DBGLVL,"State set %x not found (Max = %x)",
                        dwHandle, pContext->dwMaxSSIndex));
        return NULL;
    }
} // __SB_FindStateSet

//-----------------------------------------------------------------------------
//
// void __SB_DumpStateSet
//
// Dump info stored in a state set
//
//-----------------------------------------------------------------------------
#define ELEMS_IN_ARRAY(a) ((sizeof(a)/sizeof(a[0])))

void __SB_DumpStateSet(P3StateSetRec *pSSRec)
{
    DWORD i,j;

    DISPDBG((DBGLVL,"__SB_DumpStateSet %x, Id=%x dwSSFlags=%x",
                    pSSRec,pSSRec->dwHandle,pSSRec->dwSSFlags));

    if (!(pSSRec->dwSSFlags & SB_COMPRESSED))
    {
        // uncompressed state set

        // Dump render states values
        for (i=0; i< MAX_STATE; i++)
        {
            DISPDBG((DBGLVL,"RS %x = %x",i, pSSRec->uc.RenderStates[i]));
        }

        // Dump TSS's values
        for (j=0; j<= SB_MAX_STAGES; j++)
        {
            for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
            {
                DISPDBG((DBGLVL,"TSS [%x] %x = %x",
                                j, i, pSSRec->uc.TssStates[j][i]));
            }
        }

        // Dump RS bit masks
        for (i=0; i< ELEMS_IN_ARRAY(pSSRec->uc.bStoredRS); i++)
        {
            DISPDBG((DBGLVL,"bStoredRS[%x] = %x",
                            i, pSSRec->uc.bStoredRS[i]));
        }

        // Dump TSS bit masks
        for (j=0; j<= SB_MAX_STAGES; j++)
        {        
            for (i=0; i< ELEMS_IN_ARRAY(pSSRec->uc.bStoredTSS[j]); i++)
            {
                DISPDBG((DBGLVL,"bStoredTSS[%x][%x] = %x",
                                j, i, pSSRec->uc.bStoredTSS[j][i]));
            }
        }

    }
    else
    {
        // compressed state set

        D3DHAL_DP2COMMAND              *pDP2Cmd;
        D3DHAL_DP2RENDERSTATE          *pDP2RenderState;
        D3DHAL_DP2TEXTURESTAGESTATE    *pDP2TSState;

        pDP2Cmd = pSSRec->cc.pDP2RenderState;
        if (pDP2Cmd) 
        {
            DISPDBG((DBGLVL,"dwNumRS =%x", pDP2Cmd->wStateCount));
            pDP2RenderState = (D3DHAL_DP2RENDERSTATE *)(pDP2Cmd + 1);
            for (i=0; i< pDP2Cmd->wStateCount; i++, pDP2RenderState++)
            {
                DISPDBG((DBGLVL,"RS %x = %x",
                                pDP2RenderState->RenderState, 
                                pDP2RenderState->dwState));
            }
        
        }

        pDP2Cmd = pSSRec->cc.pDP2TextureStageState;
        if (pDP2Cmd)
        {
            DISPDBG((DBGLVL,"dwNumTSS=%x", pDP2Cmd->wStateCount));
            pDP2TSState = (D3DHAL_DP2TEXTURESTAGESTATE *)(pDP2Cmd + 1);
            for (i = 0; i < pDP2Cmd->wStateCount; i++, pDP2TSState++)
            {
                DISPDBG((DBGLVL,"TSS [%x] %x = %x",
                                pDP2TSState->wStage,
                                pDP2TSState->TSState, 
                                pDP2TSState->dwValue));
            }        
        }
    }

} // __SB_DumpStateSet

//-----------------------------------------------------------------------------
//
// void __SB_AddStateSetIndexTableEntry
//
// Add an antry to the index table. If necessary, grow it.
//-----------------------------------------------------------------------------
void __SB_AddStateSetIndexTableEntry(P3_D3DCONTEXT* pContext,
                                     DWORD dwNewHandle,
                                     P3StateSetRec *pNewSSRec)
{
    DWORD dwNewSize;
    P3StateSetRec **pNewIndexTableSS;

    // If the current list is not large enough, we'll have to grow a new one.
    if (dwNewHandle > pContext->dwMaxSSIndex)
    {
        // New size of our index table
        // (round up dwNewHandle in steps of SSPTRS_PERPAGE)
        dwNewSize = ((dwNewHandle -1 + SSPTRS_PERPAGE) / SSPTRS_PERPAGE)
                      * SSPTRS_PERPAGE;

        // we have to grow our list
        pNewIndexTableSS = (P3StateSetRec **)
                                HEAP_ALLOC( FL_ZERO_MEMORY,
                                            dwNewSize*sizeof(P3StateSetRec *),
                                            ALLOC_TAG_DX(2));

        if (!pNewIndexTableSS)
        {
            // we weren't able to grow the list so we will keep the old one
            // and (sigh) forget about this state set since that is the 
            // safest thing to do. We will delete also the state set structure
            // since no one will otherwise be able to find it later.
            DISPDBG((ERRLVL,"Out of mem growing state set list,"
                            " droping current state set"));
            HEAP_FREE(pNewSSRec);
            return;
        }

        if (pContext->pIndexTableSS)
        {
            // if we already had a previous list, we must transfer its data
            memcpy(pNewIndexTableSS, 
                   pContext->pIndexTableSS,
                   pContext->dwMaxSSIndex*sizeof(P3StateSetRec *));
            
            //and get rid of it
            HEAP_FREE(pContext->pIndexTableSS);
        }

        // New index table data
        pContext->pIndexTableSS = pNewIndexTableSS;
        pContext->dwMaxSSIndex = dwNewSize;
    }

    // Store our state set pointer into our access list
    pContext->pIndexTableSS[dwNewHandle - 1] = pNewSSRec;
    
} // __SB_AddStateSetIndexTableEntry

//-----------------------------------------------------------------------------
//
// int __SB_GetCompressedSize
//
// Calculate the size of the compressed state set
//
//-----------------------------------------------------------------------------

int __SB_GetCompressedSize(P3_D3DCONTEXT* pContext, 
                           P3StateSetRec* pUncompressedSS,
                           OffsetsCompSS* offsetSS)
{
    DWORD   dwSize;
    DWORD   dwCount;
    int     i, j;

    // Calculate the size of fixed part
    dwSize = sizeof(CompressedStateSet) + 2*sizeof(DWORD);

    // Calculate size of the render states 
    dwCount = 0;
    for (i = 0; i < MAX_STATE; i++)
    {
        if (IS_FLAG_SET(pUncompressedSS->uc.bStoredRS , i))
        {
            dwCount++;
        }
    }
    if (dwCount) 
    {
        offsetSS->dwOffDP2RenderState = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + dwCount * sizeof(D3DHAL_DP2RENDERSTATE));
    }

    // Calculate size of the texture stage states
    dwCount = 0;
    for (j = 0; j <= SB_MAX_STAGES; j++)
    {
        for (i = 0; i <= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
        {
            if (IS_FLAG_SET(pUncompressedSS->uc.bStoredTSS[j] , i))
            {
                dwCount++;
            }
        }
    }
    if (dwCount) 
    {
        offsetSS->dwOffDP2TextureStageState = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + dwCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
    }
    
    // Calculate size of Viewport and ZRange
    if (pUncompressedSS->uc.dwFlags & SB_VIEWPORT_CHANGED) 
    {
        offsetSS->dwOffDP2Viewport = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO));
    }

    if (pUncompressedSS->uc.dwFlags & SB_ZRANGE_CHANGED) 
    {
        offsetSS->dwOffDP2ZRange = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ZRANGE));
    }

#if DX8_DDI
    if (pUncompressedSS->uc.dwFlags & SB_INDICES_CHANGED) 
    {
        offsetSS->dwOffDP2SetIndices = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETINDICES));
    }

    dwCount = 0;
    for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
    {
        if (pUncompressedSS->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
        {
            dwCount++;
        }
    }
    if (dwCount) 
    {
        offsetSS->dwOffDP2SetStreamSources = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + dwCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE));
    }
#endif // DX8_DDI

#if DX7_SB_TNL
    // TODO, Calculate size needed for lights, clip planes, material, transformation
#endif // DX7_SB_TNL

#if DX7_SB_TNL
    // TODO, Calculate size needed for {V|P} shader constants
#endif // DX7_SB_TNL

#if DX8_DDI
    if (pUncompressedSS->uc.dwFlags & SB_CUR_VS_CHANGED) 
    {
        offsetSS->dwOffDP2SetVertexShader = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER));
    }
#endif // DX8_DDI

    return (dwSize);
} // __SB_GetCompressedSize


//-----------------------------------------------------------------------------
//
// void __SB_CompressStateSet
//
// Compress a state set so it uses the minimum necessary space. Since we expect 
// some apps to make extensive use of state sets we want to keep things tidy.
// Returns address of new structure (ir old, if it wasn't compressed)
//
//-----------------------------------------------------------------------------
P3StateSetRec * __SB_CompressStateSet(P3_D3DCONTEXT* pContext,
                                      P3StateSetRec *pUncompressedSS)
{
    P3StateSetRec *pCompressedSS;
    LPBYTE pTmp;
    OffsetsCompSS offsetSS;
    DWORD i, j, dwSize, dwCount;
    D3DHAL_DP2COMMAND* pDP2Cmd;

    // Initialize the offset structure
    memset(&offsetSS, 0, sizeof(OffsetsCompSS));

    // Create a new state set of just the right size we need
    dwSize = __SB_GetCompressedSize(pContext, pUncompressedSS, &offsetSS);

    if (dwSize >= pUncompressedSS->uc.dwSize)
    {
        // it is not efficient to compress, leave uncompressed !
        pUncompressedSS->dwSSFlags &= (~SB_COMPRESSED);
        return pUncompressedSS;
    }

    pTmp = HEAP_ALLOC(FL_ZERO_MEMORY, dwSize, ALLOC_TAG_DX(3));
    if (! pTmp)
    {
        DISPDBG((ERRLVL,"Not enough memory left to compress D3D state set"));
        pUncompressedSS->dwSSFlags &= (~SB_COMPRESSED);
        return pUncompressedSS;
    }

    pCompressedSS = (P3StateSetRec *)pTmp;
        
    // Adjust data in new compressed state set
    pCompressedSS->dwSSFlags |= SB_COMPRESSED;
    pCompressedSS->dwHandle = pUncompressedSS->dwHandle;

    // Set up render state in the compressed state set
    if (offsetSS.dwOffDP2RenderState)
    {
        D3DHAL_DP2RENDERSTATE* pDP2RS;
        
        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2RenderState); 
        pCompressedSS->cc.pDP2RenderState = pDP2Cmd;
    
        pDP2Cmd->bCommand = D3DDP2OP_RENDERSTATE;
        pDP2RS = (D3DHAL_DP2RENDERSTATE *)(pDP2Cmd + 1);
    
        for (i = 0; i < MAX_STATE; i++)
        {
            if (IS_FLAG_SET(pUncompressedSS->uc.bStoredRS , i))
            {
                pDP2RS->RenderState = i;
                pDP2RS->dwState = pUncompressedSS->uc.RenderStates[i];
                pDP2RS++;
            }
        }

        pDP2Cmd->wStateCount = (WORD)(pDP2RS - ((D3DHAL_DP2RENDERSTATE *)(pDP2Cmd + 1)));
    }

    // Set up texture stage state in the compress state set
    if (offsetSS.dwOffDP2TextureStageState)
    {
        D3DHAL_DP2TEXTURESTAGESTATE* pDP2TSS;
        
        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2TextureStageState);
        pCompressedSS->cc.pDP2TextureStageState = pDP2Cmd;
    
        pDP2Cmd->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
        pDP2TSS = (D3DHAL_DP2TEXTURESTAGESTATE *)(pDP2Cmd + 1);
    
        for (j = 0; j < SB_MAX_STAGES; j++)
        {
            for (i = 0; i <= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
            {
                if (IS_FLAG_SET(pUncompressedSS->uc.bStoredTSS[j] , i))
                {
                    pDP2TSS->wStage = (WORD)j;                   
                    pDP2TSS->TSState = (WORD)i;
                    pDP2TSS->dwValue =  pUncompressedSS->uc.TssStates[j][i];
                    pDP2TSS++;
                }
            }
        }

        pDP2Cmd->wStateCount = (WORD)(pDP2TSS - ((D3DHAL_DP2TEXTURESTAGESTATE *)(pDP2Cmd + 1)));
    }

    // Set up the viewport and zrange in the compressed state set
    if (offsetSS.dwOffDP2Viewport) 
    {
        D3DHAL_DP2VIEWPORTINFO* pDP2ViewPort;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2Viewport);
        pCompressedSS->cc.pDP2Viewport = pDP2Cmd;
        
        pDP2Cmd->bCommand = D3DDP2OP_VIEWPORTINFO;
        pDP2ViewPort = (D3DHAL_DP2VIEWPORTINFO *)(pDP2Cmd + 1);

        *pDP2ViewPort = pUncompressedSS->uc.viewport;
    }
    
    if (offsetSS.dwOffDP2ZRange) 
    {
        D3DHAL_DP2ZRANGE* pDP2ZRange;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2ZRange);
        pCompressedSS->cc.pDP2ZRange = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_ZRANGE;
        pDP2ZRange = (D3DHAL_DP2ZRANGE *)(pDP2Cmd + 1);

        *pDP2ZRange = pUncompressedSS->uc.zRange;
    }
    
#if DX8_DDI
    // Set up the vertex shader in the compressed state set
    if (offsetSS.dwOffDP2SetIndices) 
    {
        D3DHAL_DP2SETINDICES* pDP2SetIndices;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2SetIndices);
        pCompressedSS->cc.pDP2SetIndices = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_SETINDICES;
        pDP2SetIndices = (D3DHAL_DP2SETINDICES *)(pDP2Cmd + 1);

        *pDP2SetIndices = pUncompressedSS->uc.vertexIndex;

        pDP2Cmd->wStateCount = 1;
    }

    // Set up the vertex shader in the compressed state set
    if (offsetSS.dwOffDP2SetStreamSources) 
    {
        D3DHAL_DP2SETSTREAMSOURCE* pDP2SetStmSrc;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2SetStreamSources);
        pCompressedSS->cc.pDP2SetStreamSources = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_SETSTREAMSOURCE;
        pDP2SetStmSrc = (D3DHAL_DP2SETSTREAMSOURCE *)(pDP2Cmd + 1);

        for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
        {
            if (pUncompressedSS->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
            {
                *pDP2SetStmSrc = pUncompressedSS->uc.streamSource[i];
                pDP2SetStmSrc++;
            }
        }

        pDP2Cmd->wPrimitiveCount = (WORD)(pDP2SetStmSrc - ((D3DHAL_DP2SETSTREAMSOURCE *)(pDP2Cmd + 1)) );
    }
#endif // DX8_DDI

#if DX7_SB_TNL
    // TODO, set up light, material, transform, clip plane
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // TODO, set up shader constants
#endif // DX8_SB_SHADERS

#if DX8_DDI
    // Set up the vertex shader in the compressed state set
    if (offsetSS.dwOffDP2SetVertexShader) 
    {
        D3DHAL_DP2VERTEXSHADER* pDP2SetVtxShader;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2SetVertexShader);
        pCompressedSS->cc.pDP2SetVertexShader = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_SETVERTEXSHADER;
        pDP2SetVtxShader = (D3DHAL_DP2VERTEXSHADER *)(pDP2Cmd + 1);

        pDP2SetVtxShader->dwHandle = pUncompressedSS->uc.dwCurVertexShader;
    }
#endif // DX8_DDI

    // Get rid of the old(uncompressed) one
    HEAP_FREE(pUncompressedSS);
    return pCompressedSS;

} // __SB_CompressStateSet


//-----------------------------------------------------------------------------
//
// void _D3D_SB_DeleteAllStateSets
//
// Delete any remaining state sets for cleanup purpouses
//
//-----------------------------------------------------------------------------
void _D3D_SB_DeleteAllStateSets(P3_D3DCONTEXT* pContext)
{
    P3StateSetRec *pSSRec;
    DWORD dwSSIndex;

    DISPDBG((DBGLVL,"_D3D_SB_DeleteAllStateSets"));

    if (pContext->pIndexTableSS)
    {
        for(dwSSIndex = 0; dwSSIndex < pContext->dwMaxSSIndex; dwSSIndex++)
        {
            if (pSSRec = pContext->pIndexTableSS[dwSSIndex])
            {
                HEAP_FREE(pSSRec);
            }
        }

        // free fast index table
        HEAP_FREE(pContext->pIndexTableSS);
    }
    
} // _D3D_SB_DeleteAllStateSets

//-----------------------------------------------------------------------------
//
// void _D3D_SB_BeginStateSet
//
// Create a new state set identified by dwParam and start recording states
//
//-----------------------------------------------------------------------------
void _D3D_SB_BeginStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    DWORD dwSSSize;
    P3StateSetRec *pSSRec;

    DISPDBG((DBGLVL,"_D3D_SB_BeginStateSet dwParam=%08lx",dwParam));
    
    // Calculate the maximum size of the state set
    dwSSSize = sizeof(P3StateSetRec);
#if DX7_SB_TNL
    // TODO, Size depends on number of lights, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // TODO, size depends on number of vertext/pixel shaders
#endif // DX8_SB_SHADERS
    
    // Create a new state set
    pSSRec = (P3StateSetRec *)HEAP_ALLOC(FL_ZERO_MEMORY, 
                                         dwSSSize, 
                                         ALLOC_TAG_DX(4));
    if (!pSSRec)
    {
        DISPDBG((ERRLVL,"Run out of memory for additional state sets"));
        return;
    }

    // Remember handle to current state set
    pSSRec->dwHandle = dwParam;
    pSSRec->dwSSFlags &= (~SB_COMPRESSED);

    // Remember the size of the uncompressed state set
    pSSRec->uc.dwSize = dwSSSize;

#if DX7_SB_TNL
    // TODO, Set up pointers for data used for lights, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // TODO, Set up pointers for data used for {V|P} shader constants
#endif // DX8_SB_SHADERS

    // Get pointer to current recording state set
    pContext->pCurrSS = pSSRec;

    // Start recording mode
    pContext->bStateRecMode = TRUE;
    
} // _D3D_SB_BeginStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_EndStateSet
//
// stop recording states - revert to executing them.
//
//-----------------------------------------------------------------------------
void _D3D_SB_EndStateSet(P3_D3DCONTEXT* pContext)
{
    DWORD dwHandle;
    P3StateSetRec *pNewSSRec;

    DISPDBG((DBGLVL,"_D3D_SB_EndStateSet"));

    if (pContext->pCurrSS)
    {
        dwHandle = pContext->pCurrSS->dwHandle;

        // compress the current state set
        // Note: after being compressed the uncompressed version is free'd.
        pNewSSRec = __SB_CompressStateSet(pContext, pContext->pCurrSS);

        __SB_AddStateSetIndexTableEntry(pContext, dwHandle, pNewSSRec);
    }

    // No state set being currently recorded
    pContext->pCurrSS = NULL;

    // End recording mode
    pContext->bStateRecMode = FALSE;
    
} // _D3D_SB_EndStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_DeleteStateSet
//
// Delete the recorder state ste identified by dwParam
//
//-----------------------------------------------------------------------------
void _D3D_SB_DeleteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    P3StateSetRec *pSSRec;
    DWORD i;
    
    DISPDBG((DBGLVL,"_D3D_SB_DeleteStateSet dwParam=%08lx",dwParam));

    if (pSSRec = __SB_FindStateSet(pContext, dwParam))
    {
        // Clear index table entry
        pContext->pIndexTableSS[dwParam - 1] = NULL;

        // Now delete the actual state set structure
        HEAP_FREE(pSSRec);
    }
    
} // _D3D_SB_DeleteStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_ExecuteStateSet
//
// Execute the render states and texture stage states of which a given 
// state set is comprised. Distinguish between the compressed and
// uncomressed representations of records. 
//
//-----------------------------------------------------------------------------
void _D3D_SB_ExecuteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    P3StateSetRec *pSSRec;
    DWORD i,j;
    
    DISPDBG((DBGLVL,"_D3D_SB_ExecuteStateSet dwParam=%08lx",dwParam));
    
    if (pSSRec = __SB_FindStateSet(pContext, dwParam))
    {

        if (!(pSSRec->dwSSFlags & SB_COMPRESSED))
        {
            // uncompressed state set

            // Execute any necessary render states
            for (i=0; i< MAX_STATE; i++)
            {
                if (IS_FLAG_SET(pSSRec->uc.bStoredRS , i))
                {
                    DWORD dwRSType, dwRSVal;

                    dwRSType = i;
                    dwRSVal = pSSRec->uc.RenderStates[dwRSType];

                    // Store the state in the context
                    pContext->RenderStates[dwRSType] = dwRSVal;

                    DISPDBG((DBGLVL,"_D3D_SB_ExecuteStateSet RS %x = %x",
                                    dwRSType, dwRSVal));

                    // Process it
                    _D3D_ST_ProcessOneRenderState(pContext, dwRSType, dwRSVal);

                }
            }

            // Execute any necessary TSS's
            for (j=0; j<SB_MAX_STAGES; j++)
            {
                for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                {
                    if (IS_FLAG_SET(pSSRec->uc.bStoredTSS[j] , i))
                    {
                        D3DHAL_DP2TEXTURESTAGESTATE dp2TSS;

                        dp2TSS.TSState = (WORD)i;
                        dp2TSS.wStage = (WORD)j;                         
                        dp2TSS.dwValue = pSSRec->uc.TssStates[j][i];
                        
                        DISPDBG((DBGLVL,
                                 "_D3D_SB_ExecuteStateSet TSS %x [%x] = %x",
                                  dp2TSS.TSState,
                                  dp2TSS.wStage,
                                  dp2TSS.dwValue));
                                    
                        // If a state set is changed by _D3D_SB_CaptureStateSet(),
                        // then texture filter values in it are DX6 semantic, otherwise
                        // it is DX8
                        if (pSSRec->dwSSFlags & SB_VAL_CAPTURED)
                        {
                            _D3D_TXT_ParseTextureStageStates(pContext, 
                                                             &dp2TSS, 
                                                             1, 
                                                             FALSE); //It is already DX6
                        }
                        else
                        {
                            _D3D_TXT_ParseTextureStageStates(pContext, 
                                                             &dp2TSS, 
                                                             1, 
                                                             TRUE);
                        }
                    }
                }
            }

            // Excute viewport info, z range
            if (pSSRec->uc.dwFlags & SB_VIEWPORT_CHANGED) 
            {
                _D3D_OP_Viewport(pContext, &pSSRec->uc.viewport);
            }

            if (pSSRec->uc.dwFlags & SB_ZRANGE_CHANGED) 
            {
                _D3D_OP_ZRange(pContext, &pSSRec->uc.zRange);
            }

#if DX8_DDI
            // Excute vertex indices and stream sources
            if (pSSRec->uc.dwFlags & SB_INDICES_CHANGED) 
            {
                _D3D_OP_MStream_SetIndices(pContext,
                                           pSSRec->uc.vertexIndex.dwVBHandle,
                                           pSSRec->uc.vertexIndex.dwStride);
            }

            for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
            {
                if (pSSRec->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
                {
                    _D3D_OP_MStream_SetSrc(pContext,
                                           pSSRec->uc.streamSource[i].dwStream,
                                           pSSRec->uc.streamSource[i].dwVBHandle,
                                           pSSRec->uc.streamSource[i].dwStride);
                }
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Execute any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL
        
#if DX8_SB_SHADERS
            // TODO, Execute any necessary set current shader and set shader
            // constants pairs
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Note : This should be done after setting shader constants, since
            // current shader may have to be set before changing constants
            if (pSSRec->uc.dwFlags & SB_CUR_VS_CHANGED) 
            {
                _D3D_OP_VertexShader_Set(pContext,
                                         pSSRec->uc.dwCurVertexShader);
            }
#endif // DX8_DDI
        }
        else
        {
            // compressed state set
    
            // Execute any necessary RS's
            if (pSSRec->cc.pDP2RenderState) 
            {

                DISPDBG((DBGLVL, "_D3D_SB_ExecuteStateSet RenderState"));

                _D3D_ST_ProcessRenderStates(pContext, 
                                            pSSRec->cc.pDP2RenderState->wStateCount,
                                            (LPD3DSTATE)(pSSRec->cc.pDP2RenderState + 1),
                                            FALSE);
            }

            // Execute any necessary TSS's
            if (pSSRec->cc.pDP2TextureStageState)
            {
                DISPDBG((DBGLVL,"_D3D_SB_ExecuteStateSet TSS"));

                // If a state set is changed by _D3D_SB_CaptureStateSet(),
                // then texture filter values in it are DX6 semantic, otherwise
                // it is DX8
                if (pSSRec->dwSSFlags & SB_VAL_CAPTURED)
                {
                    _D3D_TXT_ParseTextureStageStates(pContext, 
                                                     (D3DHAL_DP2TEXTURESTAGESTATE *)(pSSRec->cc.pDP2TextureStageState + 1), 
                                                     pSSRec->cc.pDP2TextureStageState->wStateCount,
                                                     FALSE); // It is already DX6
                } 
                else
                {
                    _D3D_TXT_ParseTextureStageStates(pContext, 
                                                     (D3DHAL_DP2TEXTURESTAGESTATE *)(pSSRec->cc.pDP2TextureStageState + 1), 
                                                     pSSRec->cc.pDP2TextureStageState->wStateCount,
                                                     TRUE);
                }
            }

            // execute viewport info, z range             
            if (pSSRec->cc.pDP2Viewport) 
            {
                _D3D_OP_Viewport(pContext, 
                                 ((D3DHAL_DP2VIEWPORTINFO *)(pSSRec->cc.pDP2Viewport + 1)) 
                                );
            }

            if (pSSRec->cc.pDP2ZRange)
            {
                _D3D_OP_ZRange(pContext, 
                               ((D3DHAL_DP2ZRANGE *)(pSSRec->cc.pDP2ZRange + 1)) 
                               );
            }

#if DX8_DDI
            // Execute vertex index, stream, shader
            if (pSSRec->cc.pDP2SetIndices) 
            {
                D3DHAL_DP2SETINDICES* pDP2SetIndices;

                pDP2SetIndices = (D3DHAL_DP2SETINDICES *)(pSSRec->cc.pDP2SetIndices + 1);

                _D3D_OP_MStream_SetIndices(pContext,
                                           pDP2SetIndices->dwVBHandle,
                                           pDP2SetIndices->dwStride);
            }

            if (pSSRec->cc.pDP2SetStreamSources) 
            {
                D3DHAL_DP2SETSTREAMSOURCE *pDP2SetStmSrc;

                DISPDBG((DBGLVL,"More than 1 stream (%d)", 
                        pSSRec->cc.pDP2SetStreamSources->wStateCount));
                 
                pDP2SetStmSrc = (D3DHAL_DP2SETSTREAMSOURCE *)(pSSRec->cc.pDP2SetStreamSources + 1);
                ASSERTDD(pDP2SetStmSrc->dwStream == 0, "Wrong vertex stream");
                for (i = 0; i < pSSRec->cc.pDP2SetStreamSources->wStateCount; i++, pDP2SetStmSrc++) 
                {
                    _D3D_OP_MStream_SetSrc(pContext,
                                           pDP2SetStmSrc->dwStream,
                                           pDP2SetStmSrc->dwVBHandle,
                                           pDP2SetStmSrc->dwStride);
                }
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Execute any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
            // TODO, Execute any necessary state for setting {V|P} shader constants 
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Execute current pixel shader (legacy FVF code)
            if (pSSRec->cc.pDP2SetVertexShader) 
            {
                _D3D_OP_VertexShader_Set(pContext,
                                         ((D3DHAL_DP2VERTEXSHADER *)(pSSRec->cc.pDP2SetVertexShader + 1))->dwHandle);
            }
#endif // DX8_DDI
        }
    }

} // _D3D_SB_ExecuteStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_CaptureStateSet
//
// Capture the render states and texture stage states of which a given 
// state set is comprised. Distinguish between the compressed and
// uncomressed representations of records. This functionality allows the
// app to have a push/pop state feature.
//
//-----------------------------------------------------------------------------
void _D3D_SB_CaptureStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    P3StateSetRec *pSSRec;
    DWORD i, j;

    DISPDBG((DBGLVL,"_D3D_SB_CaptureStateSet dwParam=%08lx",dwParam));

    if (pSSRec = __SB_FindStateSet(pContext, dwParam))
    {
        // Mark it as having DX6 texture filter values instead of DX8,
        // so that _D3D_SB_ExecuteStateSet() uses the FALSE for the
        // bTranslateDX8FilterValueToDX6 of _D3D_TXT_ParseTextureStageStates()
        pSSRec->dwSSFlags |= SB_VAL_CAPTURED;

        // Actually capture the values
        if (!(pSSRec->dwSSFlags & SB_COMPRESSED))
        {
            // uncompressed state set

            // Capture any necessary render states
            for (i=0; i< MAX_STATE; i++)
                if (IS_FLAG_SET(pSSRec->uc.bStoredRS , i))
                {
                    pSSRec->uc.RenderStates[i] = pContext->RenderStates[i];
                }

            // Capture any necessary TSS's
            for (j=0; j<SB_MAX_STAGES; j++)
            {
                for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                {
                    if (IS_FLAG_SET(pSSRec->uc.bStoredTSS[j] , i))
                    {
                        pSSRec->uc.TssStates[j][i] = 
                                    pContext->TextureStageState[j].m_dwVal[i];
                             
                    }
                }
            }

            // Capture viewport info, z range
            if (pSSRec->uc.dwFlags & SB_VIEWPORT_CHANGED) 
            {
                pSSRec->uc.viewport = pContext->ViewportInfo;
            }

            if (pSSRec->uc.dwFlags & SB_ZRANGE_CHANGED) 
            {
                pSSRec->uc.zRange = pContext->ZRange;
            }

#if DX8_DDI
            // Capture vertex indices and stream sources
            if (pSSRec->uc.dwFlags & SB_INDICES_CHANGED) 
            {
                pSSRec->uc.vertexIndex.dwVBHandle = pContext->dwIndexHandle;
                pSSRec->uc.vertexIndex.dwStride = pContext->dwIndicesStride;
            }

            // Note : P3 supports only one stream    
            for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
            {
                ASSERTDD(i == 0, "Wrong vertex stream");
                if (pSSRec->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
                {
                    pSSRec->uc.streamSource[i].dwStream = 0;
                    pSSRec->uc.streamSource[i].dwVBHandle = pContext->dwVBHandle; 
                    pSSRec->uc.streamSource[i].dwStride = pContext->dwVerticesStride;
                }
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Capture any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL
        
#if DX8_SB_SHADERS
            // TODO, Capture any necessary state for {V|P} shader constants
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Capture the current vertex shader
            if (pSSRec->uc.dwFlags & SB_CUR_VS_CHANGED) 
            {
                pSSRec->uc.dwCurVertexShader = pContext->dwVertexType;
            }
#endif // DX8_DDI
        }
        else
        {
            // compressed state set

            // Capture any necessary render states
            if (pSSRec->cc.pDP2RenderState) 
            {
            
                D3DHAL_DP2RENDERSTATE* pDP2RS;
                pDP2RS = (D3DHAL_DP2RENDERSTATE *)(pSSRec->cc.pDP2RenderState + 1);
                for (i = 0; i < pSSRec->cc.pDP2RenderState->wStateCount; i++, pDP2RS++)
                {
                    pDP2RS->dwState = pContext->RenderStates[pDP2RS->RenderState];
                }
            }

            // Capture any necessary TSS's
            if (pSSRec->cc.pDP2TextureStageState)
            {
                D3DHAL_DP2TEXTURESTAGESTATE* pDP2TSS;
                pDP2TSS = (D3DHAL_DP2TEXTURESTAGESTATE *)(pSSRec->cc.pDP2TextureStageState + 1);

                for (i = 0; i < pSSRec->cc.pDP2TextureStageState->wStateCount; i++, pDP2TSS++)
                {
                    pDP2TSS->dwValue = pContext->TextureStageState[pDP2TSS->wStage].m_dwVal[pDP2TSS->TSState];
                }
            }

            // Capture viewport info, z range

            if (pSSRec->cc.pDP2Viewport)
            {
                *((D3DHAL_DP2VIEWPORTINFO *)(pSSRec->cc.pDP2Viewport + 1)) = pContext->ViewportInfo;
            }

            if (pSSRec->cc.pDP2ZRange) 
            {
                *((D3DHAL_DP2ZRANGE *)(pSSRec->cc.pDP2ZRange + 1)) = pContext->ZRange;
            }

#if DX8_DDI
            // Capture vertex index, stream, shader
            if (pSSRec->cc.pDP2SetIndices) 
            {
                D3DHAL_DP2SETINDICES* pDP2SetIndices;
                pDP2SetIndices = (D3DHAL_DP2SETINDICES *)(pSSRec->cc.pDP2SetIndices + 1);
                pDP2SetIndices->dwVBHandle = pContext->dwIndexHandle;
                pDP2SetIndices->dwStride = pContext->dwIndicesStride; // 2 | 4
            }

            if (pSSRec->cc.pDP2SetStreamSources)
            {
                D3DHAL_DP2SETSTREAMSOURCE* pDP2SetStmSrc;
                pDP2SetStmSrc = (D3DHAL_DP2SETSTREAMSOURCE *)(pSSRec->cc.pDP2SetStreamSources + 1);
                pDP2SetStmSrc->dwStream = 0;                         // Only stream for permedia 3
                pDP2SetStmSrc->dwVBHandle = pContext->dwVBHandle;
                pDP2SetStmSrc->dwStride = pContext->dwVerticesStride;
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Capture any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
            // TODO, Capture any necessary state for {V|P} shader constants
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Capture current vertex shader
            if (pSSRec->cc.pDP2SetVertexShader) 
            {
                D3DHAL_DP2VERTEXSHADER* pSetVtxShader;
                pSetVtxShader = (D3DHAL_DP2VERTEXSHADER *)(pSSRec->cc.pDP2SetVertexShader + 1);
                pSetVtxShader->dwHandle = pContext->dwVertexType;
            }
#endif // DX8_DDI
        }    
    }

} // _D3D_SB_CaptureStateSet

//-----------------------------------------------------------------------------
// Recording happens between BeginStateSet and EndStateSet calls so we
// never need to deal with recording into a compressed state set (since
// compression happens in EndStateSet)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// void _D3D_SB_RecordStateSetRS
//
// Record this render state into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_RecordStateSetRS(P3_D3DCONTEXT* pContext, 
                              DWORD dwRSType, 
                              DWORD dwRSVal)
{
    if (pContext->pCurrSS != NULL)
    {
        DISPDBG((DBGLVL,"Recording SB # %x : RS %x = %x",
                        pContext->pCurrSS->dwHandle,dwRSType,dwRSVal));

       // Recording the state in an uncompressed stateblock
        pContext->pCurrSS->uc.RenderStates[dwRSType] = dwRSVal;
        FLAG_SET(pContext->pCurrSS->uc.bStoredRS, dwRSType);
    }
} // _D3D_SB_RecordStateSetRS

//-----------------------------------------------------------------------------
//
// void _D3D_SB_RecordStateSetTSS
//
// Record this texture stage state into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_RecordStateSetTSS(P3_D3DCONTEXT* pContext, 
                               DWORD dwTSStage, 
                               DWORD dwTSState,
                               DWORD dwTSVal)
{   
   if (pContext->pCurrSS != NULL)
   {
       DISPDBG((DBGLVL,"Recording SB # %x : TSS %x [%x] = %x",
                       pContext->pCurrSS->dwHandle,dwTSState, dwTSStage, dwTSVal));

       // Recording the state in an uncompressed stateblock
       pContext->pCurrSS->uc.TssStates[dwTSStage][dwTSState] = dwTSVal;
       FLAG_SET(pContext->pCurrSS->uc.bStoredTSS[dwTSStage], dwTSState);
   }
} // _D3D_SB_RecordStateSetTSS

#if DX8_MULTSTREAMS
//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_VertexShader_Set
//
// Record this vertex shader set code into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_VertexShader_Set(P3_D3DCONTEXT* pContext, 
                                     DWORD dwVtxShaderHandle)
{                                     
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");

        pContext->pCurrSS->uc.dwCurVertexShader = dwVtxShaderHandle;
        pContext->pCurrSS->uc.dwFlags |= SB_CUR_VS_CHANGED;
    }
} // _D3D_SB_Record_VertexShader_Set

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_MStream_SetSrc
//
// Record this stream src set code into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_MStream_SetSrc(P3_D3DCONTEXT* pContext, 
                                    DWORD dwStream,
                                    DWORD dwVBHandle,
                                    DWORD dwStride)
{                                     
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");
    
        pContext->pCurrSS->uc.streamSource[dwStream].dwStream = dwStream;
        pContext->pCurrSS->uc.streamSource[dwStream].dwVBHandle = dwVBHandle;
        pContext->pCurrSS->uc.streamSource[dwStream].dwStride = dwStride;
        
        pContext->pCurrSS->uc.dwFlags |= (SB_STREAMSRC_CHANGED << dwStream);
    }
} // _D3D_SB_Record_MStream_SetSrc

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_MStream_SetIndices
//
// Record this stream indices code into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_MStream_SetIndices(P3_D3DCONTEXT* pContext, 
                                       DWORD dwVBHandle,
                                       DWORD dwStride)
{                     
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");

        pContext->pCurrSS->uc.vertexIndex.dwVBHandle = dwVBHandle;
        pContext->pCurrSS->uc.vertexIndex.dwStride = dwStride;
        pContext->pCurrSS->uc.dwFlags |= SB_INDICES_CHANGED;
    }        
} // _D3D_SB_Record_MStream_SetIndices
#endif // DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_Viewport
//
// Record this viewport info into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_Viewport(P3_D3DCONTEXT* pContext,
                             D3DHAL_DP2VIEWPORTINFO* lpvp)
{             
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");
    
        pContext->pCurrSS->uc.viewport = *lpvp;
        pContext->pCurrSS->uc.dwFlags |= SB_VIEWPORT_CHANGED;
    }        
} // _D3D_SB_Record_Viewport

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_ZRange
//
// Record this z range info into the current state set being recorded
//
//-----------------------------------------------------------------------------
VOID _D3D_SB_Record_ZRange(P3_D3DCONTEXT* pContext,
                           D3DHAL_DP2ZRANGE* lpzr)
{
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");

        pContext->pCurrSS->uc.zRange = *lpzr;
        pContext->pCurrSS->uc.dwFlags |= SB_ZRANGE_CHANGED;
    }        
}        

#endif //DX7_D3DSTATEBLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3ddp2p3.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddp2p3.c
*
* Content: D3D DrawPrimitives2 callback support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
// in-the-file nonexported forward declarations
//-----------------------------------------------------------------------------
BOOL __DP2_PrimitiveOpsParser( 
    P3_D3DCONTEXT *pContext, 
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d,
    LPD3DHAL_DP2COMMAND *lplpIns, 
    LPBYTE insStart, 
    LPDWORD lpVertices);

//-----------------------------------------------------------------------------
// Macros to access and validate command and vertex buffer data
// These checks need ALWAYS to be made for all builds, free and checked. 
//-----------------------------------------------------------------------------
#define STARTVERTEXSIZE (sizeof(D3DHAL_DP2STARTVERTEX))

#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                            \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +      \
                                ((num) * sizeof(type)) + (extrabytes))

#define PARSE_ERROR_AND_EXIT( pDP2Data, pIns, pStartIns, ddrvalue)              \
   {                                                                            \
            pDP2Data->dwErrorOffset = (DWORD)((LPBYTE)pIns - (LPBYTE)pStartIns);\
            pDP2Data->ddrval = ddrvalue;                                        \
            bParseError = TRUE;                                                 \
            break;                                                              \
   }

#define CHECK_CMDBUF_LIMITS( pDP2Data, pBuf, type, num, extrabytes)            \
        CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, sizeof(type), num, extrabytes)

#define CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, typesize, num, extrabytes)      \
{                                                                              \
        LPBYTE pBase,pEnd,pBufEnd;                                             \
        pBase = (LPBYTE)(pDP2Data->lpDDCommands->lpGbl->fpVidMem +             \
                        pDP2Data->dwCommandOffset);                            \
        pEnd  = pBase + pDP2Data->dwCommandLength;                             \
        pBufEnd = ((LPBYTE)pBuf + ((num) * (typesize)) + (extrabytes) - 1);    \
        if (! ((LPBYTE)pBufEnd < pEnd) && ( pBase <= (LPBYTE)pBuf))            \
        {                                                                      \
            DISPDBG((ERRLVL,"Trying to read past Command Buffer limits "       \
                    "%x %x %x %x",pBase ,(LPBYTE)pBuf, pBufEnd, pEnd ));       \
            PARSE_ERROR_AND_EXIT( pDP2Data, lpIns, lpInsStart,                 \
                                  D3DERR_COMMAND_UNPARSED      );              \
        }                                                                      \
}    

#define LP_FVF_VERTEX(lpBaseAddr, wIndex)                         \
         (LPDWORD)((LPBYTE)(lpBaseAddr) + (wIndex) * pContext->FVFData.dwStride)

#define LP_FVF_NXT_VTX(lpVtx)                                    \
         (LPDWORD)((LPBYTE)(lpVtx) + pContext->FVFData.dwStride)



//-----------------------------------------------------------------------------
// These defines are derived from the VertexTagList initialisation in stateset.c

#define FVF_TEXCOORD_BASE   6
#define FVF_XYZ         (7 << 0)
#define FVF_RHW         (1 << 3)
#define FVF_DIFFUSE     (1 << 4)
#define FVF_SPECULAR    (1 << 5)
#define FVF_TEXCOORD1   (3 << FVF_TEXCOORD_BASE)
#define FVF_TEXCOORD2   (3 << (FVF_TEXCOORD_BASE + 2))

//-----------------------------------------------------------------------------
//
// ReconsiderStateChanges
//
//-----------------------------------------------------------------------------
static D3DSTATE localState[] =
{
    { (D3DTRANSFORMSTATETYPE)D3DRENDERSTATE_SHADEMODE, 0 },
    { (D3DTRANSFORMSTATETYPE)D3DRENDERSTATE_CULLMODE, 0 }
};

#define NUM_LOCAL_STATES ( sizeof( localState ) / sizeof( D3DSTATE ))

void ReconsiderStateChanges( P3_D3DCONTEXT *pContext )
{
    int i;

    for( i = 0; i < NUM_LOCAL_STATES; i++ )
    {
        localState[i].dwArg[0] = 
                    pContext->RenderStates[localState[i].drstRenderStateType];
    }

    _D3D_ST_ProcessRenderStates(pContext, NUM_LOCAL_STATES, localState, FALSE);

    _D3D_ST_RealizeHWStateChanges( pContext );
    
} // ReconsiderStateChanges

//-----------------------------------------------------------------------------
//
// __CheckFVFRequest
//
// This utility function verifies that the requested FVF format makes sense
// and computes useful offsets into the data and a stride between succesive
// vertices.
//
//-----------------------------------------------------------------------------
#define FVFEQUAL(fvfcode, fvfmask) \
    (((DWORD)fvfcode & (DWORD)fvfmask)) == (DWORD)fvfmask)
DWORD __CheckFVFRequest(P3_D3DCONTEXT *pContext, DWORD dwFVF)
{
    UINT i, iTexCount;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    int nonTexStride, texMask;
    FVFOFFSETS KeptFVF;
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_DMA_DEFS();

    DISPDBG((DBGLVL,"Looking at FVF Code %x:",dwFVF));

    // Check for bogus fields
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2)) ||
         (!(dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)))       ||
         (dwFVF & (D3DFVF_NORMAL) )                      )
    {
        DISPDBG((ERRLVL,"ERROR: Invalid FVF Buffer for this hardware!(%x)"
                        ,dwFVF));
                        
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers (since we're not a TnL driver/hw)
        // and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    KeptFVF = pContext->FVFData;

    // Ensure the default offsets are setup
    ZeroMemory(&pContext->FVFData, sizeof(FVFOFFSETS));

    // Minimum FVF coordinate fields
    pContext->FVFData.dwStride = sizeof(D3DVALUE) * 3;
    pContext->FVFData.vFmat |= FVF_XYZ;

    // RHW if present in FVF
    if (dwFVF & D3DFVF_XYZRHW)
    {
        DISPDBG((DBGLVL, "  D3DFVF_XYZRHW"));
        pContext->FVFData.dwStride += sizeof(D3DVALUE);
        pContext->FVFData.vFmat |= FVF_RHW;
    }

#if DX8_POINTSPRITES
    // Point size offsets for point sprites
    if (dwFVF & D3DFVF_PSIZE)
    {
        pContext->FVFData.dwPntSizeOffset = pContext->FVFData.dwStride;
        pContext->FVFData.dwStride  += sizeof(D3DVALUE);
    }
#else
    if (dwFVF & D3DFVF_RESERVED1)
    {
        DISPDBG((DBGLVL, "  D3DFVF_RESERVED1"));
        pContext->FVFData.dwStride += sizeof(D3DVALUE);
    }
#endif // DX8_POINTSPRITES    

    // Diffuse color
    if (dwFVF & D3DFVF_DIFFUSE)
    {
        DISPDBG((DBGLVL, "  D3DFVF_DIFFUSE"));
        pContext->FVFData.dwColOffset = pContext->FVFData.dwStride;
        pContext->FVFData.dwStride += sizeof(D3DCOLOR);
        pContext->FVFData.vFmat |= FVF_DIFFUSE;
    }

    // Specular color
    if (dwFVF & D3DFVF_SPECULAR)
    {
        DISPDBG((DBGLVL, "  D3DFVF_SPECULAR"));
        pContext->FVFData.dwSpcOffset = pContext->FVFData.dwStride;
        pContext->FVFData.dwStride  += sizeof(D3DCOLOR);
        pContext->FVFData.vFmat |= FVF_SPECULAR;
    }

    // Store some info for later setting up our inline hostin renderers
    nonTexStride = pContext->FVFData.dwStride / sizeof(DWORD);
    texMask = 0;
    pContext->FVFData.dwStrideHostInline = pContext->FVFData.dwStride;
    pContext->FVFData.dwNonTexStride = pContext->FVFData.dwStride;    

    // Up until this point the vertex format is the same for both
    pContext->FVFData.vFmatHostInline = pContext->FVFData.vFmat;

    // Get number of texture coordinates present in this FVF code
    iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
    pContext->FVFData.dwTexCount = iTexCount;

    for (i=0; i<D3DHAL_TSS_MAXSTAGES;i++)
    {
        pContext->FVFData.dwTexCoordOffset[i] = 0;
    }

    // Do we have tex coords in FVF? What kinds?
    if (iTexCount >= 1)
    {
        DISPDBG((DBGLVL,"Texture enabled: %d stages", iTexCount));

        // What is the dimensionality of each of our texcoords?
        if (0xFFFF0000 & dwFVF)
        {
            //expansion of FVF, these 16 bits are designated for up to
            //8 sets of texture coordinates with each set having 2bits
            //Normally a capable driver has to process all coordinates
            //Code below shows correct parsing
            UINT numcoord;
            for (i = 0; i < iTexCount; i++)
            {
                if (FVFEQUAL(dwFVF,D3DFVF_TEXCOORDSIZE1(i))
                {
                    // one less D3DVALUE for 1D textures
                    numcoord = 1;                
                }
                else if (FVFEQUAL(dwFVF,D3DFVF_TEXCOORDSIZE3(i))
                {
                    // one more D3DVALUE for 3D textures
                    numcoord = 3;                
                }
                else if (FVFEQUAL(dwFVF,D3DFVF_TEXCOORDSIZE4(i))
                {
                    // two more D3DVALUEs for 4D textures
                    numcoord = 4;                
                }
                else
                {
                    // D3DFVF_TEXCOORDSIZE2(i) is always 0
                    // i.e. case 0 regular 2 D3DVALUEs
                    numcoord = 2;                
                }
                
                DISPDBG((DBGLVL,"Expanded TexCoord set %d has a offset %8lx",
                                 i,pContext->FVFData.dwStride));

                pContext->FVFData.dwTexCoordOffset[i] = 
                                                pContext->FVFData.dwStride; 
                
                pContext->FVFData.dwStride += sizeof(D3DVALUE) * numcoord;
            }
            
            DISPDBG((DBGLVL,"Expanded dwVertexType=0x%08lx has %d "
                            "Texture Coords with total stride=0x%08lx",
                            dwFVF, iTexCount, pContext->FVFData.dwStride));
        }
        else
        {
            // If the top FVF bits are not set, the default is to consider all
            // text coords to be u.v (2D)
            for (i = 0; i < iTexCount; i++)
            {
                pContext->FVFData.dwTexCoordOffset[i] = 
                                                pContext->FVFData.dwStride;

                pContext->FVFData.dwStride += sizeof(D3DVALUE) * 2;
            }

        }

        // Update the offsets to our current (2) textures
        if( pContext->iTexStage[0] != -1 )
        {
            DWORD dwTexCoordSet = 
                pContext->TextureStageState[pContext->iTexStage[0]].
                                         m_dwVal[D3DTSS_TEXCOORDINDEX];

            // The texture coordinate index may contain texgen flags
            // in the high word. These flags are not interesting here
            // so we mask them off.
            dwTexCoordSet = dwTexCoordSet & 0x0000FFFFul;
                                         
            pContext->FVFData.dwTexOffset[0] = 
                    pContext->FVFData.dwTexCoordOffset[dwTexCoordSet];

            texMask |= 3 << ( 2 * dwTexCoordSet );

            pContext->FVFData.vFmat |= FVF_TEXCOORD1;
        }

        if( pContext->iTexStage[1] != -1 )
        {
            DWORD dwTexCoordSet = 
                pContext->TextureStageState[pContext->iTexStage[1]].
                                         m_dwVal[D3DTSS_TEXCOORDINDEX];
                                         
            // The texture coordinate index may contain texgen flags
            // in the high word. These flags are not interesting here
            // so we mask them off.
            dwTexCoordSet = dwTexCoordSet & 0x0000FFFFul;

            pContext->FVFData.dwTexOffset[1] = 
                    pContext->FVFData.dwTexCoordOffset[dwTexCoordSet];

            texMask |= 3 << ( 2 * dwTexCoordSet );

            pContext->FVFData.vFmat |= FVF_TEXCOORD2;
        }               

    } // if (iTexCount >= 1)


    //---------------------------------------------------------
    // Update Permedia 3 hw registers for host inline rendering
    //---------------------------------------------------------
    
    // Update the Hostinline renderers with the correct values.
    // These usually aren't the same as the Hostin renderer values
    if (pContext->FVFData.vFmat & FVF_TEXCOORD1)
    {
        // Add this texture coordinate into the stride
        pContext->FVFData.dwStrideHostInline += (sizeof(D3DVALUE) * 2);

        // Set up the vertex format bit
        pContext->FVFData.vFmatHostInline |= FVF_TEXCOORD1;
    }
    
    if (pContext->FVFData.vFmat & FVF_TEXCOORD2)
    {
        P3_SURF_INTERNAL* pTexture = pContext->pCurrentTexture[TEXSTAGE_1];

        // If the texture coordinates aren't the same, or we are mipmapping, 
        // then we must send the second set of texture coordinates
        if ((pContext->FVFData.dwTexOffset[0] != 
             pContext->FVFData.dwTexOffset[1]) ||
                ((pTexture != NULL) &&
                 (pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MIPFILTER] != D3DTFP_NONE) &&
                 (pTexture->bMipMap)))
        {
            pContext->FVFData.dwStrideHostInline += (sizeof(D3DVALUE) * 2);

            // Add in the second texture set to the vertex format
            pContext->FVFData.vFmatHostInline |= FVF_TEXCOORD2;
        }
    }

    // VertexValid is all 1's for the stride, because we will never want 
    // to send a gap in the inline hostin triangle renderer
    pContext->FVFData.dwVertexValidHostInline = 
                        (1 << (pContext->FVFData.dwStrideHostInline >> 2)) - 1;

    // The vertex valid for Hostin renderers is more complex because the chip 
    // may be required to skip data.
    pContext->FVFData.dwVertexValid = ((1 << nonTexStride) - 1) | 
                                      (texMask << nonTexStride);

    // If the FVF has changed, resend the state. This can be improved because 
    // you don't always have to send the default stuff (only if that state is 
    // enabled and the vertex doesn't contain it).
    if (memcmp(&KeptFVF, &pContext->FVFData, sizeof(KeptFVF)) != 0)
    {
        // Update P3 for the changed FVF
        P3_DMA_GET_BUFFER_ENTRIES( 12 );

        SEND_P3_DATA(V0FloatPackedColour, 0xFFFFFFFF);
        SEND_P3_DATA(V1FloatPackedColour, 0xFFFFFFFF);
        SEND_P3_DATA(V2FloatPackedColour, 0xFFFFFFFF);
    
        SEND_P3_DATA(V0FloatPackedSpecularFog, 0x0);
        SEND_P3_DATA(V1FloatPackedSpecularFog, 0x0);
        SEND_P3_DATA(V2FloatPackedSpecularFog, 0x0);

        pSoftP3RX->P3RX_P3VertexControl.CacheEnable = 1;

        P3_DMA_COMMIT_BUFFER();

    }

    DISPDBG((DBGLVL,"FVF stride set to %d",pContext->FVFData.dwStride));

    return DD_OK;
    
} // __CheckFVFRequest

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DDrawPrimitives2_P3
//
// Renders primitives and returns the updated render state.
//
// D3dDrawPrimitives2 must be implemented in Direct3D drivers.
//
// The driver must do the following: 
//
// -Ensure that the context handle specified by dwhContext is valid. 
//
// -Check that a flip to the drawing surface associated with the context is not
//  in progress. If the drawing surface is involved in a flip, the driver should
//  set ddrval to DDERR_WASSTILLDRAWING and return DDHAL_DRIVER_HANDLED. 
//
// -Determine the location at which the first D3DNTHAL_DP2COMMAND structure is 
//  found by adding dwCommandOffset bytes to the Command Buffer to which 
//  lpDDCommands points. 
//
// -Determine the location in the Vertex Buffer at which the first vertex is found
//  This is should only be done if there is data in the Vertex Buffer; that is, 
//  when a D3DDP2OP_* command token is received (except when the token is 
//  D3DDP2OP_LINELIST_IMM or D3DDP2OP_TRIANGLEFAN_IMM). These later two opcodes 
//  indicate that the vertex data is passed immediately in the command stream, 
//  rather than in a Vertex Buffer. So, assuming there is data in the Vertex 
//  Buffer, if the Vertex Buffer is in user memory, the first vertex is 
//  dwVertexOffset bytes into the buffer to which lpVertices points. Otherwise, 
//  the driver should apply dwVertexOffset to the memory associated with the 
//  DD_SURFACE_LOCAL structure to which lpDDVertex points. 
//
// -Check dwVertexType to ensure that the driver supports the requested FVF. The 
//  driver should fail the call if any of the following conditions exist: 
//
//  *Vertex coordinates are not specified; that is, if D3DFVF_XYZRHW is not set. 
//  *Normals are specified; that is, if D3DFVF_NORMAL is set. 
//  *Any of the reserved D3DFVF_RESERVEDx bits are set. 
//
// -Process all of the commands in the Command Buffer sequentially. For each 
//  D3DNTHAL_DP2COMMAND structure, the driver should do the following: 
//
//  *If the command is D3DDP2OP_RENDERSTATE, process the wStateCount 
//   D3DNTHAL_DP2RENDERSTATE structures that follow in the Command Buffer, 
//   updating the driver state for each render state structure. When the 
//   D3DNTHALDP2_EXECUTEBUFFER flag is set, the driver should also reflect the 
//   state change in the array to which lpdwRStates points. 
//  *If the command is D3DDP2OP_TEXTURESTAGESTATE, process the wStateCount 
//   D3DNTHAL_DP2TEXTURESTAGESTATE structures that follow in the Command Buffer, 
//   updating the driver's texture state associated with the specified texture 
//   stage for each texture state structure. 
//  *If the command is D3DDP2OP_VIEWPORTINFO, process the D3DNTHAL_DP2VIEWPORTINFO
//   structure that follows in the Command Buffer, updating the viewport 
//   information stored in the driver's internal rendering context. 
//  *If the command is D3DDP2OP_WINFO, process the D3DNTHAL_DP2WINFO structure 
//   that follows in the Command Buffer, updating the w-buffering information 
//   stored in the driver's internal rendering context. 
//  *Otherwise, process the D3DNTHAL_DP2Xxx primitive structures that follow the 
//   D3DDP2OP_Xxx primitive rendering command in the Command Buffer. 
//  *If the command is unknown, call the runtime's D3dParseUnknownCommand callback
//   The runtime provides this callback to the driver's DdGetDriverInfo callback 
//   with the GUID_D3DPARSEUNKNOWNCOMMANDCALLBACK guid. 
//
// The driver doesn't need to probe for readability the memory in which the 
// Command and Vertex Buffers are stored. However, the driver is responsible for 
// ensuring that it does not exceed the bounds of these buffers; that is, the 
// driver must stay within the bounds specified by dwCommandLength and 
// dwVertexLength.
//
// If the driver needs to fail D3dDrawPrimitives2, it should fill in 
// dwErrorOffset with the offset into Command Buffer at which the first 
// unhandled D3DNTHAL_DP2COMMAND can be found.
//
//
// Parameters
//
//      pdp2d 
//          Points to a D3DNTHAL_DRAWPRIMITIVES2DATA structure that contains 
//          the information required for the driver to render one or more 
//          primitives. 
//
//          .dwhContext 
//              Specifies the context handle of the Direct3D device. 
//          .dwFlags 
//              Specifies flags that provide additional instructions to the 
//              driver or provide information from the driver. This member 
//              can be a bitwise OR of the following values: 
//
//              D3DNTHALDP2_USERMEMVERTICES 
//                      The lpVertices member is valid; that is, the driver 
//                      should obtain the vertex data from the user-allocated 
//                      memory to which lpVertices points. This flag is set 
//                      by Direct3D only. 
//              D3DNTHALDP2_EXECUTEBUFFER 
//                      Indicates that the Command and Vertex Buffers were 
//                      created in system memory. The driver should update 
//                      the state array to which lpdwRStates points. This 
//                      flag is set by Direct3D only. 
//              D3DNTHALDP2_SWAPVERTEXBUFFER 
//                      Indicates that the driver can swap the buffer to 
//                      which lpDDVertex or lpVertices points with a new 
//                      Vertex Buffer and return immediately, asynchronously 
//                      processing the original buffer while Direct3D fills 
//                      the new Vertex Buffer. Drivers that do not support 
//                      multi-buffering of Vertex Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_SWAPCOMMANDBUFFER 
//                      Indicates that the driver can swap the buffer to 
//                      which lpDDCommands points with a new Command Buffer 
//                      and return immediately, asynchronously processing 
//                      the original buffer while Direct3D fills the new 
//                      Command Buffer. Drivers that do not support 
///                     multi-buffering of Command Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_REQVERTEXBUFSIZE 
//                      Indicates that the driver must be able to allocate 
//                      a Vertex Buffer of at least the size specified in 
//                      dwReqVertexBufSize. Drivers that do not support 
//                      multi-buffering of Vertex Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_REQCOMMANDBUFSIZE 
//                      Indicates that the driver must be able to allocate 
//                      a Command Buffer of at least the size specified in 
//                      dwReqCommandBufSize. Drivers that do not support 
//                      multi-buffering of Command Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_VIDMEMVERTEXBUF 
//                      Indicates that the Vertex Buffer allocated by the 
//                      driver as a swap buffer is not in system memory. 
//                      This flag can be set by drivers that support multi-
//                      buffering of Vertex Buffers. 
//              D3DNTHALDP2_VIDMEMCOMMANDBUF 
//                      Indicates that the Command Buffer allocated by the 
//                      driver as a swap buffer is not in system memory. This 
//                      flag can be set by drivers that support multi-
//                      buffering of Command Buffers. 
//
//          .dwVertexType 
//              Identifies the FVF of the data in the Vertex Buffer; that is, 
//              dwVertexType specifies which per-vertex data fields are present 
//              in the Vertex Buffer to which lpDDVertex or lpVertices points. 
//              This member can be a bitwise OR of the values in the table that 
//              follows. Only one of the D3DFVF_TEXx flags will be set. 
//
//              Value               Meaning 
//              ==============      =======
//              D3DFVF_XYZRHW       Each vertex has an x,y,z, and w. 
//                                  This flag is always set. 
//              D3DFVF_DIFFUSE      Each vertex has a diffuse color. 
//              D3DFVF_SPECULAR     Each vertex has a specular color. 
//              D3DFVF_TEX0         No texture coordinates are provided 
//                                  with the vertex data. 
//              D3DFVF_TEX1         Each vertex has one set of texture 
//                                  coordinates. 
//              D3DFVF_TEX2         Each vertex has two sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX3         Each vertex has three sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX4         Each vertex has four sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX5         Each vertex has five sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX6         Each vertex has six sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX7         Each vertex has seven sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX8         Each vertex has eight sets of texture 
//                                  coordinates. 
//
//          .lpDDCommands 
//              Points to the DD_SURFACE_LOCAL structure that identifies the 
//              DirectDraw surface containing the command data. The fpVidMem 
//              member of the embedded DD_SURFACE_GLOBAL structure points to 
//              the buffer that contains state change and primitive drawing 
//              commands for the driver to process. Specifically, this buffer 
//              contains one or more D3DNTHAL_DP2COMMAND structures, each 
//              followed by a D3DNTHAL_DP2Xxx structure whose exact type is 
//              identified by D3DNTHAL_DP2COMMAND's bCommand member. 
//          .dwCommandOffset 
//              Specifies the number of bytes into the surface to which 
//              lpDDCommands points at which the command data starts. 
//          .dwCommandLength 
//              Specifies the number of bytes of valid command data in the 
//              surface to which lpDDCommands points starting at dwCommandOffset.
//          .lpDDVertex 
//              Points to the DD_SURFACE_LOCAL structure that identifies the 
//              DirectDraw surface containing the vertex data when the 
//              D3DNTHALDP2_USERMEMVERTICES flag is not set in dwFlags. Union 
//              with lpVertices. 
//          .lpVertices 
//              Points to a user-mode memory block containing vertex data when 
//              the D3DNTHALDP2_USERMEMVERTICES flag is set in dwFlags. 
//          .dwVertexOffset 
//              Specifies the number of bytes into the surface to which 
//              lpDDVertex or lpVertices points at which the vertex data starts.
//          .dwVertexLength 
//              The number of vertices, for which valid data exists in the 
//              surface, that lpDDVertex points to (starting at dwVertexOffset). 
//              Note that dwVertexOffset is specified in bytes. 
//          .dwReqVertexBufSize 
//              Specifies the minimum number of bytes that the driver must 
//              allocate for the swap Vertex Buffer. This member is valid only 
//              when the D3DNTHALDP2_REQVERTEXBUFSIZE flag is set. Drivers that 
//              do not support multi-buffering of Vertex Buffers should ignore 
//              this member. 
//          .dwReqCommandBufSize 
//              Specifies the minimum number of bytes that the driver must 
//              allocate for the swap Command Buffer. This member is valid only 
//              when the D3DNTHALDP2_REQCOMMANDBUFSIZE flag is set. Drivers that 
//              do not support multi-buffering of Command Buffers should ignore 
//              this member. 
//          .lpdwRStates 
//              Points to a render state array that the driver should update 
//              when it parses render state commands from the Command Buffer. 
//              The driver should update this array only when the 
//              D3DNTHALDP2_EXECUTEBUFFER flag is set in dwFlags. The driver 
//              should use the D3DRENDERSTATETYPE enumerated types to update 
//              the appropriate render state's array element. 
//          .dwVertexSize 
//              Used to pass in the size of each vertex in bytes. Union with 
//              ddrval. 
//          .ddrval 
//              Specifies the location in which the driver writes the return 
//              value of D3dDrawPrimitives2. D3D_OK indicates success; 
//              otherwise, the driver should return the appropriate 
//              D3DNTERR_Xxx error code. 
//          .dwErrorOffset 
//              Specifies the location in which the driver should write the 
//              offset into the surface to which lpDDCommands points at which 
//              the first unhandled D3DNTHAL_DP2COMMAND can be found. The 
//              driver must set this value when it returns an error condition 
//              in ddrval. 
//
//-----------------------------------------------------------------------------
DWORD WINAPI 
D3DDrawPrimitives2_P3( 
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d )
{
    P3_THUNKEDDATA*             pThisDisplay;
    P3_D3DCONTEXT*              pContext;
    LPDWORD                     lpVertices;
    P3_VERTEXBUFFERINFO*        pVertexBufferInfo;
    P3_VERTEXBUFFERINFO*        pCommandBufferInfo;
    LPD3DHAL_DP2COMMAND         lpIns;
    LPBYTE                      lpInsStart;
    LPBYTE                      lpPrim;
    BOOL                        bParseError = FALSE;
    BOOL                        bUsedHostIn = FALSE;
    HRESULT                     ddrval;
    LPBYTE                      pUMVtx;
    int                         i;

    DBG_CB_ENTRY(D3DDrawPrimitives2_P3);

    // Get current context and validate it
    pContext = _D3D_CTX_HandleToPtr(pdp2d->dwhContext);
    
    if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
    {
        pdp2d->ddrval = D3DHAL_CONTEXT_BAD;
        DISPDBG((ERRLVL,"ERROR: Context not valid"));
        DBG_CB_EXIT(D3DDrawPrimitives2_P3, D3DHAL_CONTEXT_BAD);
        return (DDHAL_DRIVER_HANDLED);
    }
   
    // Get and validate driver data
    pThisDisplay = pContext->pThisDisplay;
    VALIDATE_MODE_AND_STATE(pThisDisplay);

    // Debugging messages
    DISPDBG((DBGLVL, "  dwhContext = %x",pdp2d->dwhContext));
    DISPDBG((DBGLVL, "  dwFlags = %x",pdp2d->dwFlags));
    DBGDUMP_D3DDP2FLAGS(DBGLVL, pdp2d->dwFlags);
    DISPDBG((DBGLVL, "  dwVertexType = %x",pdp2d->dwVertexType));
    DISPDBG((DBGLVL, "  dwCommandOffset = %d",pdp2d->dwCommandOffset));
    DISPDBG((DBGLVL, "  dwCommandLength = %d",pdp2d->dwCommandLength));
    DISPDBG((DBGLVL, "  dwVertexOffset = %d",pdp2d->dwVertexOffset));
    DISPDBG((DBGLVL, "  dwVertexLength = %d",pdp2d->dwVertexLength));
    DISPDBG((DBGLVL, "  dwReqVertexBufSize = %d",pdp2d->dwReqVertexBufSize));
    DISPDBG((DBGLVL, "  dwReqCommandBufSize = %d",pdp2d->dwReqCommandBufSize));                 

    // Get appropriate pointers to commands in command buffer
    lpInsStart = (LPBYTE)(pdp2d->lpDDCommands->lpGbl->fpVidMem);
    if (lpInsStart == NULL) 
    {
        DISPDBG((ERRLVL, "ERROR: Command Buffer pointer is null"));
        pdp2d->ddrval = DDERR_INVALIDPARAMS;
        DBG_CB_EXIT(D3DDrawPrimitives2_P3, DDERR_INVALIDPARAMS);        
        return DDHAL_DRIVER_HANDLED;
    }
       
    lpIns = (LPD3DHAL_DP2COMMAND)(lpInsStart + pdp2d->dwCommandOffset);

    // Check if vertex buffer resides in user memory or in a DDraw surface
    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pUMVtx = (LPBYTE)pdp2d->lpVertices;
    
        // Get appropriate pointer to vertices , memory is already secured
        lpVertices = (LPDWORD)((LPBYTE)pdp2d->lpVertices + 
                                       pdp2d->dwVertexOffset);
    } 
    else
    {
        // Get appropriate pointer to vertices 
        lpVertices = (LPDWORD)((LPBYTE)pdp2d->lpDDVertex->lpGbl->fpVidMem + 
                                       pdp2d->dwVertexOffset);
    }

    if (lpVertices == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Vertex Buffer pointer is null"));
        pdp2d->ddrval = DDERR_INVALIDPARAMS;
        DBG_CB_EXIT(D3DDrawPrimitives2_P3, DDERR_INVALIDPARAMS);       
        return DDHAL_DRIVER_HANDLED;
    }

#if DX8_DDI
// Take notice of the following block of code necessary 
// for DX8 drivers to run <= DX7 apps succesfully!
#endif // DX8_DDI

    // Take the VB format and address from our header info if we are 
    // processing a DX7 or earlier context. Otherwise we'll get updates 
    // through the new DX8 DP2 tokens (D3DDP2OP_SETSTREAMSOURCE & 
    // D3DDP2OP_SETVERTEXSHADER)
    if (IS_DX7_OR_EARLIER_APP(pContext))
    {
        // Update place from where vertices will be processed for this context
        pContext->lpVertices = lpVertices;

        // Update the FVF code to be used currently. 
        pContext->dwVertexType = pdp2d->dwVertexType;
    }

    // Switch to the chips D3D context and get ready for rendering
    STOP_SOFTWARE_CURSOR(pThisDisplay);
    D3D_OPERATION(pContext, pThisDisplay);

//@@BEGIN_DDKSPLIT
//AZN This check for flips is here because otherwise DX3 tunnel in FS flickers
//@@END_DDKSPLIT
    // Can return if still drawing
    pdp2d->ddrval = 
        _DX_QueryFlipStatus(pThisDisplay, 
                            pContext->pSurfRenderInt->fpVidMem, 
                            TRUE);

    if( FAILED( pdp2d->ddrval ) ) 
    {
        DISPDBG((DBGLVL,"Returning because flip has not occurred"));
        START_SOFTWARE_CURSOR(pThisDisplay);

        DBG_CB_EXIT(D3DDrawPrimitives2_P3, 0);
        return DDHAL_DRIVER_HANDLED;
    }

//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS 
    _D3D_EB_GetAndWaitForBuffers(pThisDisplay,
                                 pdp2d,
                                 &pCommandBufferInfo,
                                 &pVertexBufferInfo);
#endif                                 
//@@END_DDKSPLIT

    DISPDBG((DBGLVL,"Command Buffer @ %x Vertex Buffer @ %x",
                    lpIns, lpVertices));

    // Process commands while we haven't exhausted the command buffer
    while (!bParseError && 
           ((LPBYTE)lpIns <
             (lpInsStart + pdp2d->dwCommandLength + pdp2d->dwCommandOffset) )
          )
    {
        // Get pointer to first primitive structure past the D3DHAL_DP2COMMAND
        lpPrim = (LPBYTE)lpIns + sizeof(D3DHAL_DP2COMMAND);

        DISPDBG((DBGLVL, "DrawPrimitive2: Parsing instruction %d Count = %d @ %x",
                    lpIns->bCommand, lpIns->wPrimitiveCount, lpIns));

        // Look for opcodes that cause rendering - we need to process state 
        // changes and wait for any pending flip.

        switch( lpIns->bCommand )
        {
            case D3DDP2OP_RENDERSTATE:
            case D3DDP2OP_TEXTURESTAGESTATE:
            case D3DDP2OP_STATESET:
            case D3DDP2OP_VIEWPORTINFO:
            case D3DDP2OP_WINFO:
            case D3DDP2OP_UPDATEPALETTE:
            case D3DDP2OP_SETPALETTE:
#if DX7_TEXMANAGEMENT
            case D3DDP2OP_SETTEXLOD:
            case D3DDP2OP_SETPRIORITY:
#if DX8_DDI
            case D3DDP2OP_ADDDIRTYRECT:
            case D3DDP2OP_ADDDIRTYBOX:
#endif // DX8_DDI
#endif
            case D3DDP2OP_ZRANGE:
            case D3DDP2OP_SETMATERIAL:
            case D3DDP2OP_SETLIGHT:
            case D3DDP2OP_CREATELIGHT:
            case D3DDP2OP_EXT:
            case D3DDP2OP_SETTRANSFORM:
            case D3DDP2OP_SETRENDERTARGET:

#if DX8_DDI
            case D3DDP2OP_CREATEVERTEXSHADER:
            case D3DDP2OP_SETVERTEXSHADER:
            case D3DDP2OP_DELETEVERTEXSHADER:
            case D3DDP2OP_SETVERTEXSHADERCONST:
            case D3DDP2OP_CREATEPIXELSHADER:
            case D3DDP2OP_SETPIXELSHADER:
            case D3DDP2OP_DELETEPIXELSHADER:
            case D3DDP2OP_SETPIXELSHADERCONST:
            case D3DDP2OP_SETSTREAMSOURCE :
            case D3DDP2OP_SETSTREAMSOURCEUM :
            case D3DDP2OP_SETINDICES :

#endif // DX8_DDI


                // These opcodes don't cause any rendering - do nothing

                break;

            default:

                // The primitive type is not actually important to 
                // make sure the hw setup changes have been done.
                _D3D_ST_RealizeHWStateChanges( pContext );

                // Need to reset the FVF data because it 
                // depends on the texture setup
                if (__CheckFVFRequest(pContext, 
                                      pContext->dwVertexType) != DD_OK) 
                {
                    DISPDBG((ERRLVL, "ERROR: D3DDrawPrimitives2_P3 cannot handle "
                                "Flexible Vertex Format requested"));

                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          D3DERR_COMMAND_UNPARSED);
                }

                // Fall through as we don't need to handle any new state or
                // check our FVF formats if we're only clearing or blitting
                // surfaces
                
            case D3DDP2OP_CLEAR:
            case D3DDP2OP_TEXBLT:   
#if DX8_DDI            
            case D3DDP2OP_VOLUMEBLT:
            case D3DDP2OP_BUFFERBLT:
#endif // DX8_DDI
            
            
                // Check to see if any pending physical flip has occurred
//@@BEGIN_DDKSPLIT                
                //
                // The runtime doesn't expect to see DDERR_WASSTILLDRAWING 
                // when using DP2 to emulate Execute buffers, so we have to 
                // spin here. Also, if we have processed any of this command 
                // buffer we are forced into spinning here because if we 
                // returned the runtime would not know about the already 
                // processed commands and we would process them again - 
                // probably a bad thing. We must do this check here rather 
                // than earlier because in some cases DP2 gets called when 
                // the render surface has been freed. This causes an exception 
                // if we try to check the flip status.
               

                if(( pdp2d->dwFlags & D3DHALDP2_EXECUTEBUFFER ) ||
                                ( lpIns > 
                                     (LPD3DHAL_DP2COMMAND)( lpInsStart + 
                                                            pdp2d->dwCommandOffset )))
                {
                    while( _DX_QueryFlipStatus(pThisDisplay, 
                                               pContext->pSurfRenderInt->fpVidMem, 
                                               TRUE) == DDERR_WASSTILLDRAWING )
                    {
                        // Waste time - could back off here
                    }
                }
                else
//@@END_DDKSPLIT                 
                {
                    // Can return if still drawing

                    pdp2d->ddrval = 
                        _DX_QueryFlipStatus(pThisDisplay, 
                                            pContext->pSurfRenderInt->fpVidMem, 
                                            TRUE);

                    if( FAILED ( pdp2d->ddrval ) ) 
                    {
                        DISPDBG((DBGLVL,"Returning because flip has not occurred"));
                        START_SOFTWARE_CURSOR(pThisDisplay);

                        DBG_CB_EXIT(D3DDrawPrimitives2_P3, 0);
                        return DDHAL_DRIVER_HANDLED;
                    }
                }
                
                break;
        }

        switch( lpIns->bCommand )
        {

        case D3DDP2OP_VIEWPORTINFO:
            // Used to inform the guard-band aware drivers, the view 
            // clipping rectangle. Non-guard-band drivers should ignore 
            // and skip over these instructions and continue processing 
            // the rest of the command buffer. The clipping rectangle is 
            // specified by the members dwX, dwY, dwWidth and dwHeight. 
            DISPDBG((DBGLVL, "D3DDP2OP_VIEWPORTINFO"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2VIEWPORTINFO, lpIns->wStateCount, 0);

            for( i = 0; i < lpIns->wStateCount; i++)
            {
                // There should be only one of these, but we'll pay attention 
                // to the last one just in case
                _D3D_OP_Viewport(pContext, (D3DHAL_DP2VIEWPORTINFO*)lpPrim);

                lpPrim += sizeof(D3DHAL_DP2VIEWPORTINFO);
            }
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2VIEWPORTINFO, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_WINFO:
            // Record the W Buffering info
            DISPDBG((DBGLVL, "D3DDP2OP_WINFO"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2WINFO, lpIns->wStateCount, 0);

            pContext->WBufferInfo = *((D3DHAL_DP2WINFO*)lpPrim);
            DIRTY_WBUFFER(pContext);

            lpPrim += sizeof(D3DHAL_DP2WINFO);
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2WINFO, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_RENDERSTATE:
            // Specifies a render state change that requires processing. 
            // The rendering state to change is specified by one or more 
            // D3DHAL_DP2RENDERSTATE structures following D3DHAL_DP2COMMAND.
            DISPDBG((DBGLVL,"D3DDP2OP_RENDERSTATE: state count = %d", 
                       lpIns->wStateCount));
                       
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2RENDERSTATE, lpIns->wStateCount, 0);

            if (pdp2d->dwFlags & D3DHALDP2_EXECUTEBUFFER)
            {
                _D3D_ST_ProcessRenderStates(pContext, 
                                            lpIns->wStateCount, 
                                            (LPD3DSTATE)lpPrim, 
                                            TRUE);

                // As the render states vector lives in user memory, we need to
                // access it bracketing it with a try/except block. This
                // is because the user memory might under some circumstances
                // become invalid while the driver is running and then it
                // would AV. Also, the driver might need to do some cleanup
                // before returning to the OS.
                __try
                {
                    for (i = lpIns->wStateCount; i > 0; i--)
                    {
                        pdp2d->lpdwRStates[((D3DHAL_DP2RENDERSTATE*)lpPrim)->RenderState]
                                                        = ((D3DHAL_DP2RENDERSTATE*)lpPrim)->dwState;
                        lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // On this driver we don't need to do anything special
                    DISPDBG((ERRLVL,"Driver caused exception at "
                                    "line %u of file %s",
                                    __LINE__,__FILE__));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);
                }                 

                
            }
            else
            {
                _D3D_ST_ProcessRenderStates(pContext, 
                                            lpIns->wStateCount, 
                                            (LPD3DSTATE)lpPrim, 
                                            FALSE);
                                        
                lpPrim += (sizeof(D3DHAL_DP2RENDERSTATE) * lpIns->wStateCount);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2RENDERSTATE, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_TEXTURESTAGESTATE:
        
            DISPDBG((DBGLVL,"D3DDP2OP_TEXTURESTAGESTATE: state count = %d", 
                       lpIns->wStateCount));
                       
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2TEXTURESTAGESTATE, 
                                lpIns->wStateCount , 0);

            _D3D_TXT_ParseTextureStageStates(
                                    pContext, 
                                    (D3DHAL_DP2TEXTURESTAGESTATE*)lpPrim,
                                    lpIns->wStateCount,
                                    TRUE);
                                        
            lpPrim += sizeof(D3DHAL_DP2TEXTURESTAGESTATE) * 
                      lpIns->wStateCount;
            
            NEXTINSTRUCTION(lpIns, 
                            D3DHAL_DP2TEXTURESTAGESTATE, 
                            lpIns->wStateCount , 0); 
            break;


        case D3DDP2OP_STATESET:
            {
                D3DHAL_DP2STATESET *pStateSetOp = (D3DHAL_DP2STATESET*)(lpPrim);
                
                DISPDBG((DBGLVL,"D3DDP2OP_STATESET: state count = %d", 
                            lpIns->wStateCount));

                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2STATESET, lpIns->wStateCount, 0);                
#if DX7_D3DSTATEBLOCKS
                for (i = 0; i < lpIns->wStateCount; i++, pStateSetOp++)
                {
                    switch (pStateSetOp->dwOperation)
                    {
#if DX8_DDI
                    case D3DHAL_STATESETCREATE :
                        // This DDI should be called only for drivers > DX7
                        // and only for those which support TLHals. It is 
                        // called only when the device created is a pure-device
                        // On receipt of this request the driver should create
                        // a state block of the type given in the field sbType
                        // and capture the current given state into it.
                        break;
#endif //DX8_DDI
                    case D3DHAL_STATESETBEGIN  :
                        _D3D_SB_BeginStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEND    :
                        _D3D_SB_EndStateSet(pContext);
                        break;
                    case D3DHAL_STATESETDELETE :
                        _D3D_SB_DeleteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEXECUTE:
                        _D3D_SB_ExecuteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETCAPTURE:
                        _D3D_SB_CaptureStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    default :
                        DISPDBG((ERRLVL,"D3DDP2OP_STATESET has invalid"
                            "dwOperation %08lx",pStateSetOp->dwOperation));
                    }
                }
#endif //DX7_D3DSTATEBLOCKS
                // Update the command buffer pointer
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2STATESET, 
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_ZRANGE:
            DISPDBG((DBGLVL, "D3DDP2OP_ZRANGE"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2ZRANGE, lpIns->wStateCount, 0);

            for( i = 0; i < lpIns->wStateCount; i++)
            {
                // There should be only one of these, but we'll pay attention 
                // to the last one just in case
                _D3D_OP_ZRange(pContext, (D3DHAL_DP2ZRANGE*)lpPrim);
                
                lpPrim += sizeof(D3DHAL_DP2ZRANGE);
            }
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2ZRANGE, lpIns->wStateCount, 0);

            break;

        case D3DDP2OP_UPDATEPALETTE:
            // Perform modifications to the palette that is used for palettized
            // textures. The palette handle attached to a surface is updated
            // with wNumEntries PALETTEENTRYs starting at a specific wStartIndex
            // member of the palette. (A PALETTENTRY (defined in wingdi.h and
            // wtypes.h) is actually a DWORD with an ARGB color for each byte.)
            // After the D3DNTHAL_DP2UPDATEPALETTE structure in the command
            // stream the actual palette data will follow (without any padding),
            // comprising one DWORD per palette entry. There will only be one
            // D3DNTHAL_DP2UPDATEPALETTE structure (plus palette data) following
            // the D3DNTHAL_DP2COMMAND structure regardless of the value of
            // wStateCount.
            {
                D3DHAL_DP2UPDATEPALETTE* pUpdatePalette;

                DISPDBG((DBGLVL, "D3DDP2OP_UPDATEPALETTE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2UPDATEPALETTE, 1, 0);

                pUpdatePalette = (D3DHAL_DP2UPDATEPALETTE *)lpPrim;
                // Each palette entry is a DWORD ARGB 8:8:8:8
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2UPDATEPALETTE, 
                                    1, pUpdatePalette->wNumEntries * sizeof(DWORD));

                ddrval = _D3D_OP_UpdatePalette(pContext, 
                                               pUpdatePalette, 
                                               (LPDWORD)(pUpdatePalette + 1));
                if ( FAILED(ddrval) )
                {
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart,
                                          ddrval);
                }

                lpPrim += (sizeof(D3DHAL_DP2UPDATEPALETTE) + 
                           pUpdatePalette->wNumEntries * 4);
                // Each palette entry is a DWORD ARGB 8:8:8:8
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2UPDATEPALETTE, 
                                1, pUpdatePalette->wNumEntries * sizeof(DWORD));
            }

            break;

        case D3DDP2OP_SETPALETTE:
            // Attach a palette to a texture, that is , map an association
            // between a palette handle and a surface handle, and specify
            // the characteristics of the palette. The number of
            // D3DNTHAL_DP2SETPALETTE structures to follow is specified by
            // the wStateCount member of the D3DNTHAL_DP2COMMAND structure
            {
                DISPDBG((DBGLVL, "D3DDP2OP_SETPALETTE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETPALETTE, 
                                    lpIns->wStateCount, 0);

                ddrval = _D3D_OP_SetPalettes(pContext, 
                                             (D3DHAL_DP2SETPALETTE *)lpPrim,
                                             lpIns->wStateCount);
                if ( FAILED(ddrval) )
                {
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart,
                                          ddrval);
                }

                lpPrim += sizeof(D3DHAL_DP2SETPALETTE) * lpIns->wStateCount;
            
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETPALETTE, 
                                lpIns->wStateCount, 0);
            }
            break;

#if DX7_TEXMANAGEMENT
        case D3DDP2OP_SETTEXLOD:
            {
                D3DHAL_DP2SETTEXLOD* pTexLod;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETTEXLOD"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETTEXLOD, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pTexLod = ((D3DHAL_DP2SETTEXLOD*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETTEXLOD);                
                
                    _D3D_OP_SetTexLod(pContext, pTexLod);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETTEXLOD, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_SETPRIORITY:
            {
                D3DHAL_DP2SETPRIORITY* pSetPri;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETPRIORITY"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETPRIORITY, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pSetPri = ((D3DHAL_DP2SETPRIORITY*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETPRIORITY);                
                
                    _D3D_OP_SetPriority(pContext, pSetPri); 
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETPRIORITY, 
                                lpIns->wStateCount, 0);
            }
            break;

#if DX8_DDI
        case D3DDP2OP_ADDDIRTYRECT:
            {
                D3DHAL_DP2ADDDIRTYRECT* pAddRect;
                
                DISPDBG((DBGLVL, "D3DDP2OP_ADDDIRTYRECT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DDP2OP_ADDDIRTYRECT, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the dirty rect
                    pAddRect = ((D3DHAL_DP2ADDDIRTYRECT*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2ADDDIRTYRECT);                
                
                    _D3D_OP_AddDirtyRect(pContext, pAddRect);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2ADDDIRTYRECT, 
                                lpIns->wStateCount, 0);            
            }
            break;
        
        case D3DDP2OP_ADDDIRTYBOX:
            {
                D3DHAL_DP2ADDDIRTYBOX* pAddBox;
                
                DISPDBG((DBGLVL, "D3DDP2OP_ADDDIRTYBOX"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DDP2OP_ADDDIRTYBOX, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the dirty rect
                    pAddBox = ((D3DHAL_DP2ADDDIRTYBOX*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2ADDDIRTYBOX);                
                
                    _D3D_OP_AddDirtyBox(pContext, pAddBox);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2ADDDIRTYBOX, 
                                lpIns->wStateCount, 0);            
            }
            break;
#endif // DX8_DDI

#endif // DX7_TEXMANAGEMENT

        case D3DDP2OP_SETCLIPPLANE:
            {
                D3DHAL_DP2SETCLIPPLANE* pSetPlane;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETCLIPPLANE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETCLIPPLANE, 
                                    lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pSetPlane = ((D3DHAL_DP2SETCLIPPLANE*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETCLIPPLANE);                

                    // (unimplemented OP as we don't support user 
                    // defined clipping planes)                
                    // _D3D_OP_SetClipPlane(pContext, pSetPlane);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETCLIPPLANE, 
                                lpIns->wStateCount, 0);
            }

            break;

        case D3DDP2OP_SETMATERIAL:
            {
                D3DHAL_DP2SETMATERIAL* pSetMaterial;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETMATERIAL"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2SETMATERIAL, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pSetMaterial = ((D3DHAL_DP2SETMATERIAL*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETMATERIAL);                

                    // (unimplemented OP as we are not a TnL driver)                
                    // _D3D_OP_SetMaterial(pContext, pSetMaterial);            
                    DIRTY_MATERIAL;
                    DBGDUMP_D3DMATERIAL7(DBGLVL, &pSetMaterial);
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETMATERIAL, lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_SETLIGHT:
            {
                D3DHAL_DP2SETLIGHT* pSetLight;

                DISPDBG((DBGLVL, "D3DDP2OP_SETLIGHT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETLIGHT, lpIns->wStateCount, 0);    

                for( i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in light
                    pSetLight = (D3DHAL_DP2SETLIGHT*)lpPrim;
                    lpPrim += sizeof(D3DHAL_DP2SETLIGHT);

                    // (unimplemented OP as we are not a TnL driver)
                    // _D3D_OP_SetLight(pContext, pSetLight);
                    DIRTY_GAMMA_STATE;                    
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETLIGHT, lpIns->wStateCount, 0);

            }
            break;

        case D3DDP2OP_CREATELIGHT:
            {
                D3DHAL_DP2CREATELIGHT* pCreateLight;

                DISPDBG((DBGLVL, "D3DDP2OP_CREATELIGHT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2CREATELIGHT, 1, 0);

                pCreateLight = (D3DHAL_DP2CREATELIGHT*)lpPrim;

                DISPDBG((DBGLVL,"Creating light, handle: 0x%x", 
                                pCreateLight->dwIndex));

                DIRTY_GAMMA_STATE;

                lpPrim += sizeof(D3DHAL_DP2CREATELIGHT);
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2CREATELIGHT, 1, 0);
            }
            break;

        case D3DDP2OP_SETTRANSFORM:
            {
                D3DHAL_DP2SETTRANSFORM* pTransform;

                DISPDBG((DBGLVL, "D3DDP2OP_SETTRANSFORM"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2SETTRANSFORM, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {
                    pTransform = (D3DHAL_DP2SETTRANSFORM*)lpPrim;
                    switch(pTransform->xfrmType)
                    {
                        case D3DTRANSFORMSTATE_WORLD:
                            DISPDBG((DBGLVL,"D3DTRANSFORMSTATE_WORLD"));
                            DIRTY_MODELVIEW;
                            break;

                        case D3DTRANSFORMSTATE_VIEW:
                            DISPDBG((DBGLVL,"D3DTRANSFORMSTATE_VIEW"));
                            DIRTY_MODELVIEW;
                            break;

                        case D3DTRANSFORMSTATE_PROJECTION:
                            DISPDBG((DBGLVL,"D3DTRANSFORMSTATE_PROJECTION"));
                            DIRTY_PROJECTION;
                            break;

                        default:
                            DISPDBG((ERRLVL,"Texture transform not handled yet!"));
                            break;
                    }

                    // (unimplemented OP as we are not a TnL driver)
                    // _D3D_OP_SetTransform(pContext, pTransform);
                    
                    // display the matrix in the debugger               
                    DBGDUMP_D3DMATRIX(DBGLVL, &pTransform->matrix);

                    lpPrim += sizeof(D3DHAL_DP2SETTRANSFORM);                    
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETTRANSFORM, lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_EXT:
            DISPDBG((ERRLVL, "D3DDP2OP_EXT"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, DWORD, 1, 0);

            lpPrim += sizeof(DWORD);
            NEXTINSTRUCTION(lpIns, DWORD, 1, 0);

            break;

        case D3DDP2OP_CLEAR:
            {
                D3DHAL_DP2CLEAR* pClear;

                DISPDBG((DBGLVL, "D3DDP2OP_CLEAR"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2CLEAR, 1, 
                                    (lpIns->wStateCount - 1)*sizeof(RECT) );

                pClear = (D3DHAL_DP2CLEAR*)lpPrim;

                // Notice that the interpretation of wStateCount for this
                // operation is special: wStateCount means the number of
                // RECTs following the D3DHAL_DP2CLEAR struct
                _D3D_OP_Clear2(pContext, pClear, lpIns->wStateCount);

                // Return to the 3D state, because the above call
                // will have switched us to a DDRAW hw context
                D3D_OPERATION(pContext, pThisDisplay);

                lpPrim += sizeof(D3DHAL_DP2CLEAR);
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2CLEAR, 1, 
                                      (lpIns->wStateCount - 1)*sizeof(RECT) );
            }
            break;

        case D3DDP2OP_SETRENDERTARGET:
            {
                D3DHAL_DP2SETRENDERTARGET* pSetRenderTarget;
                P3_SURF_INTERNAL* pFrameBuffer;
                P3_SURF_INTERNAL* pZBuffer;
                BOOL bNewAliasBuffers;

                DISPDBG((DBGLVL, "D3DDP2OP_SETRENDERTARGET"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETRENDERTARGET, 1, 0);

                pSetRenderTarget = (D3DHAL_DP2SETRENDERTARGET*)lpPrim;

                pFrameBuffer = 
                           GetSurfaceFromHandle(pContext, 
                                                pSetRenderTarget->hRenderTarget);
                pZBuffer = GetSurfaceFromHandle(pContext, 
                                                pSetRenderTarget->hZBuffer);

                // Check that the Framebuffer is valid
                if (pFrameBuffer == NULL)
                {
                    DISPDBG((ERRLVL, "ERROR: "
                                "FrameBuffer Surface is invalid!"));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);
                }

                // Decide whether the render target's size has changed
                bNewAliasBuffers = TRUE;
                if ((pContext->pSurfRenderInt) &&
                    (pContext->pSurfRenderInt->wWidth == pFrameBuffer->wWidth) &&
                    (pContext->pSurfRenderInt->wHeight == pFrameBuffer->wHeight))
                {
                    bNewAliasBuffers = FALSE;
                }

                // Setup in hw the new render target and zbuffer
                if (FAILED(_D3D_OP_SetRenderTarget(pContext, 
                                                   pFrameBuffer, 
                                                   pZBuffer,
                                                   bNewAliasBuffers) ) )
                {
                    DISPDBG((ERRLVL, "ERROR: "
                                "FrameBuffer Surface Format is invalid!"));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);                    
                }

                // Dirty the renderstate so that the hw setup is reevaluated
                // next time before we render anything
                DIRTY_RENDER_OFFSETS(pContext);
                DIRTY_ALPHABLEND(pContext);
                DIRTY_OPTIMIZE_ALPHA(pContext);
                DIRTY_ZBUFFER(pContext);
                DIRTY_VIEWPORT(pContext);

                lpPrim += sizeof(D3DHAL_DP2SETRENDERTARGET);
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETRENDERTARGET, 1, 0);
            }
            break;

        case D3DDP2OP_TEXBLT:
            {
                DISPDBG((DBGLVL, "D3DDP2OP_TEXBLT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);

                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    // As the texture might live in user memory, we need to
                    // access it bracketing it with a try/except block. This
                    // is because the user memory might under some circumstances
                    // become invalid while the driver is running and then it
                    // would AV. Also, the driver might need to do some cleanup
                    // before returning to the OS.
                    __try
                    {
                        _D3D_OP_TextureBlt(pContext,
                                        pThisDisplay, 
                                        (D3DHAL_DP2TEXBLT*)(lpPrim));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        // On this driver we don't need to do anything special
                        DISPDBG((ERRLVL,"Driver caused exception at "
                                        "line %u of file %s",
                                        __LINE__,__FILE__));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              DDERR_GENERIC);
                    }                 
                
                                 
                    lpPrim += sizeof(D3DHAL_DP2TEXBLT);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);
            }
            break;

#if DX8_VERTEXSHADERS
        case D3DDP2OP_CREATEVERTEXSHADER:
            {
                D3DHAL_DP2CREATEVERTEXSHADER* pCreateVtxShader;
                DWORD dwExtraBytes = 0;

                DISPDBG((DBGLVL, "D3DDP2OP_CREATEVERTEXSHADER"));

                // iterate through each passed vertex shader creation block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // verify that the next vertex shader is readable
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                        D3DHAL_DP2CREATEVERTEXSHADER, 1, 0);    

                    // Get the passed in vertex shader
                    pCreateVtxShader = (D3DHAL_DP2CREATEVERTEXSHADER*)lpPrim;

                    // Check if the size of the declaration and body of the 
                    // vertex shader don't exceed the command buffer limits
                    CHECK_CMDBUF_LIMITS_S(pdp2d, lpPrim,
                                          0, 0, 
                                          pCreateVtxShader->dwDeclSize + 
                                          pCreateVtxShader->dwCodeSize);  

                    // Advance lpPrim so that it points to the vertex shader's
                    // declaration and body
                    lpPrim += sizeof(D3DHAL_DP2CREATEVERTEXSHADER);

                    // Create this particular shader
                    ddrval = _D3D_OP_VertexShader_Create(pContext,
                                                      pCreateVtxShader->dwHandle,
                                                      pCreateVtxShader->dwDeclSize,
                                                      pCreateVtxShader->dwCodeSize,
                                                      lpPrim);

                    if ( FAILED(ddrval) )
                    {
                        DISPDBG((ERRLVL, "ERROR: "
                                    "Vertex Shader couldn't be created!"));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              D3DERR_DRIVERINVALIDCALL);                      
                    }
                                          
                    // Update lpPrim in order to get to the next vertex
                    // shader creation command block. 
                    dwExtraBytes +=   pCreateVtxShader->dwDeclSize
                                    + pCreateVtxShader->dwCodeSize;

                    lpPrim +=         pCreateVtxShader->dwDeclSize
                                    + pCreateVtxShader->dwCodeSize;      
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2CREATEVERTEXSHADER, 
                                lpIns->wStateCount, 
                                dwExtraBytes);
            }
            break;
            
        case D3DDP2OP_SETVERTEXSHADER:
            {
                D3DHAL_DP2VERTEXSHADER* pSetVtxShader;

                DISPDBG((DBGLVL, "D3DHAL_DP2SETVERTEXSHADER"));

                // Following the DP2 token there is one and only one
                // set vertex shader block. But lets accomodate if for
                // any reason we receive more than one
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2VERTEXSHADER, 
                                    lpIns->wStateCount, 0);    

                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader
                    pSetVtxShader = (D3DHAL_DP2VERTEXSHADER*)lpPrim;

                    // Setup the given vertex shader.
                    _D3D_OP_VertexShader_Set(pContext,
                                       pSetVtxShader->dwHandle);                

                    // Now skip into the next DP2 token in the command buffer
                    lpPrim += sizeof(D3DHAL_DP2VERTEXSHADER);               
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2VERTEXSHADER, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_DELETEVERTEXSHADER:
            {
                D3DHAL_DP2VERTEXSHADER* pDelVtxShader;

                DISPDBG((DBGLVL, "D3DDP2OP_DELETEVERTEXSHADER"));

                // verify that all the following vertex shader 
                // delete blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2VERTEXSHADER, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader delete block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader
                    pDelVtxShader = (D3DHAL_DP2VERTEXSHADER*)lpPrim;

                    // Destroy the given vertex shader.
                    _D3D_OP_VertexShader_Delete(pContext,
                                          pDelVtxShader->dwHandle);

                    // Update lpPrim in order to get to the next vertex
                    // shader delete command block. 
                    lpPrim += sizeof(D3DHAL_DP2VERTEXSHADER);               
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2VERTEXSHADER, 
                                lpIns->wStateCount, 
                                0);            
            }
            break;
        case D3DDP2OP_SETVERTEXSHADERCONST:
            {
                D3DHAL_DP2SETVERTEXSHADERCONST* pVtxShaderConst;
                DWORD dwExtraBytes = 0;                

                DISPDBG((DBGLVL, "D3DDP2OP_SETVERTEXSHADERCONST"));

                // verify that all the following vertex shader 
                // constant blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETVERTEXSHADERCONST, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader constant block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader constant
                    pVtxShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST*)lpPrim;

                    // Advance lpPrim so that it points to the constant
                    // values to be loaded
                    lpPrim += sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);

                    // constant block in order to Set up the constant entries
                    _D3D_OP_VertexShader_SetConst(pContext,
                                            pVtxShaderConst->dwRegister,
                                            pVtxShaderConst->dwCount,
                                            (DWORD *)lpPrim);

                    // Update lpPrim in order to get to the next vertex
                    // shader constants command block. Each register has 4 floats.
                    lpPrim += pVtxShaderConst->dwCount * 4 * sizeof(FLOAT);

                    dwExtraBytes += pVtxShaderConst->dwCount * 4 * sizeof(FLOAT);
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2SETVERTEXSHADERCONST, 
                                lpIns->wStateCount, 
                                dwExtraBytes);                 
            }
            break;
                        
#endif // DX8_VERTEXSHADERS

#if DX8_PIXELSHADERS
        case D3DDP2OP_CREATEPIXELSHADER:
            {
                D3DHAL_DP2CREATEPIXELSHADER* pCreatePxlShader;
                DWORD dwExtraBytes = 0;

                DISPDBG((DBGLVL, "D3DDP2OP_CREATEPIXELSHADER"));

                // iterate through each passed pixel shader creation block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // verify that the next pixel shader is readable
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                        D3DHAL_DP2CREATEPIXELSHADER, 1, 0);    

                    // Get the passed in pixel shader
                    pCreatePxlShader = (D3DHAL_DP2CREATEPIXELSHADER*)lpPrim;

                    // Check if the size of the declaration and body of the 
                    // pixel shader don't exceed the command buffer limits
                    CHECK_CMDBUF_LIMITS_S(pdp2d, lpPrim,
                                          0, 0, 
                                          pCreatePxlShader->dwCodeSize);

                    // Update lpPrim to point to the actual pixel shader code
                    lpPrim += sizeof(D3DHAL_DP2CREATEPIXELSHADER);

                    // Create the given pixel shader
                    ddrval = _D3D_OP_PixelShader_Create(pContext,
                                                  pCreatePxlShader->dwHandle,
                                                  pCreatePxlShader->dwCodeSize,
                                                  lpPrim);

                    if ( FAILED(ddrval) )
                    {
                        DISPDBG((ERRLVL, "ERROR: "
                                    "Pixel Shader couldn't be created!"));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              D3DERR_DRIVERINVALIDCALL);                                           
                    }                                                  

                    // Update lpPrim in order to get to the next vertex
                    // shader creation command block. 
                    lpPrim += pCreatePxlShader->dwCodeSize;               
                    
                    dwExtraBytes += pCreatePxlShader->dwCodeSize;
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2CREATEPIXELSHADER, 
                                lpIns->wStateCount, 
                                dwExtraBytes);
            }
            break;
            
        case D3DDP2OP_SETPIXELSHADER:
            {
                D3DHAL_DP2PIXELSHADER* pSetPxlShader;

                DISPDBG((DBGLVL, "D3DHAL_DP2SETPIXELSHADER"));

                // Following the DP2 token there is one and only one
                // set pixel shader block. But lets accomodate if for
                // any reason we receive more than one                
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2PIXELSHADER, 
                                    lpIns->wStateCount, 0);    

                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in pixel shader
                    pSetPxlShader = (D3DHAL_DP2PIXELSHADER*)lpPrim;

                    // Setup the given pixel shader.
                    _D3D_OP_PixelShader_Set(pContext,
                                      pSetPxlShader->dwHandle);

                    // Now skip into the next DP2 token in the command buffer
                    lpPrim += sizeof(D3DHAL_DP2PIXELSHADER);               
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2PIXELSHADER, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_DELETEPIXELSHADER:
            {
                D3DHAL_DP2PIXELSHADER* pDelPxlShader;

                DISPDBG((DBGLVL, "D3DDP2OP_DELETEPIXELSHADER"));

                // verify that all the following pixel shader 
                // delete blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2PIXELSHADER, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader delete block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader
                    pDelPxlShader = (D3DHAL_DP2PIXELSHADER*)lpPrim;

                    // Destroy the given pixel shader
                    _D3D_OP_PixelShader_Delete(pContext,
                                         pDelPxlShader->dwHandle);

                    // Update lpPrim in order to get to the next vertex
                    // shader delete command block. 
                    lpPrim += sizeof(D3DHAL_DP2PIXELSHADER);               
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2PIXELSHADER, 
                                lpIns->wStateCount, 
                                0);            
            }
            break;
            
        case D3DDP2OP_SETPIXELSHADERCONST:
            {
                D3DHAL_DP2SETPIXELSHADERCONST* pPxlShaderConst;
                DWORD dwExtraBytes = 0;

                DISPDBG((DBGLVL, "D3DDP2OP_SETPIXELSHADERCONST"));

                // verify that all the following vertex shader 
                // constant blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETPIXELSHADERCONST, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader constant block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader constant
                    pPxlShaderConst = (D3DHAL_DP2SETPIXELSHADERCONST*)lpPrim;

                    // Update lpPrim to point to the const data to setup
                    lpPrim += sizeof(D3DHAL_DP2SETPIXELSHADERCONST);     

                    // Set up the constant entries
                    _D3D_OP_PixelShader_SetConst(pContext,
                                           pPxlShaderConst->dwRegister,
                                           pPxlShaderConst->dwCount,
                                           (DWORD *)lpPrim);

                    // Update lpPrim in order to get to the next vertex
                    // shader delete command block. Each register has 4 floats.
                    lpPrim += pPxlShaderConst->dwCount * 4 * sizeof(FLOAT);

                    dwExtraBytes += pPxlShaderConst->dwCount * 4 * sizeof(FLOAT);
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2SETPIXELSHADERCONST, 
                                lpIns->wStateCount, 
                                dwExtraBytes);                 
            }
            break;
                        
#endif // DX8_PIXELSHADERS

#if DX8_MULTSTREAMS

        case D3DDP2OP_SETSTREAMSOURCE :
            {
                D3DHAL_DP2SETSTREAMSOURCE* pSetStreamSrc;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETSTREAMSOURCE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETSTREAMSOURCE, 
                                    lpIns->wStateCount, 0);

                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pSetStreamSrc = (D3DHAL_DP2SETSTREAMSOURCE*)lpPrim;
                    
                    _D3D_OP_MStream_SetSrc(pContext,
                                     pSetStreamSrc->dwStream,
                                     pSetStreamSrc->dwVBHandle,
                                     pSetStreamSrc->dwStride);
                                 
                    lpPrim += sizeof(D3DHAL_DP2SETSTREAMSOURCE);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETSTREAMSOURCE, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_SETSTREAMSOURCEUM :
            {
                D3DHAL_DP2SETSTREAMSOURCEUM* pSetStreamSrcUM;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETSTREAMSOURCEUM"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETSTREAMSOURCEUM, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pSetStreamSrcUM = (D3DHAL_DP2SETSTREAMSOURCEUM*)lpPrim;
                    
                    _D3D_OP_MStream_SetSrcUM(pContext,
                                        pSetStreamSrcUM->dwStream,
                                        pSetStreamSrcUM->dwStride,
                                        pUMVtx,
                                        pdp2d->dwVertexLength);
                                 
                    lpPrim += sizeof(D3DHAL_DP2SETSTREAMSOURCEUM);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETSTREAMSOURCEUM, 
                                lpIns->wStateCount, 0);
            }
            break;        
            
        case D3DDP2OP_SETINDICES :
            {
                D3DHAL_DP2SETINDICES* pSetIndices;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETINDICES"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETINDICES, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pSetIndices = (D3DHAL_DP2SETINDICES*)lpPrim;
                    
                    _D3D_OP_MStream_SetIndices(pContext,
                                         pSetIndices->dwVBHandle,
                                         pSetIndices->dwStride);
                                 
                    lpPrim += sizeof(D3DHAL_DP2SETINDICES);
                }
                    
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETINDICES, 
                                lpIns->wStateCount, 0);
            }
            break;            
                        
#endif // DX8_MULTSTREAMS

#if DX8_3DTEXTURES

        case D3DDP2OP_VOLUMEBLT:
            {
                DISPDBG((DBGLVL, "D3DDP2OP_VOLUMEBLT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2VOLUMEBLT, 
                                    lpIns->wStateCount, 0);

                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    // As the texture might live in user memory, we need to
                    // access it bracketing it with a try/except block. This
                    // is because the user memory might under some circumstances
                    // become invalid while the driver is running and then it
                    // would AV. Also, the driver might need to do some cleanup
                    // before returning to the OS.
                    __try
                    {
                        _D3D_OP_VolumeBlt(pContext,
                                        pThisDisplay, 
                                        (D3DHAL_DP2VOLUMEBLT*)(lpPrim));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        // On this driver we don't need to do anything special
                        DISPDBG((ERRLVL,"Driver caused exception at "
                                        "line %u of file %s",
                                        __LINE__,__FILE__));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              DDERR_GENERIC);
                    }                  
                                 
                    lpPrim += sizeof(D3DHAL_DP2VOLUMEBLT);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2VOLUMEBLT, 
                                lpIns->wStateCount, 0);
            }
            break;     

#endif // DX8_3DTEXTURES
            
#if DX8_DDI            

        case D3DDP2OP_BUFFERBLT:
            {
                DISPDBG((DBGLVL, "D3DDP2OP_BUFFERBLT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2BUFFERBLT, 
                                    lpIns->wStateCount, 0);

                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    _D3D_OP_BufferBlt(pContext,
                                    pThisDisplay, 
                                    (D3DHAL_DP2BUFFERBLT*)(lpPrim));
                                 
                    lpPrim += sizeof(D3DHAL_DP2BUFFERBLT);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2BUFFERBLT, 
                                lpIns->wStateCount, 0);
            }
            break;   
        
#endif // DX8_DDI

        // This was found to be required for a few D3DRM apps 
        case D3DOP_EXIT:
            lpIns = (D3DHAL_DP2COMMAND *)(lpInsStart + 
                                          pdp2d->dwCommandLength + 
                                          pdp2d->dwCommandOffset);
            break;

        default:

            // Pick up the right rasterizers depending on the 
            // current rendering state
            _D3D_R3_PickVertexProcessor( pContext );

            // Check if vertex buffer resides in user memory or in a DDraw surface
            if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
            {
                // As the vertex buffer lives in user memory, we need to
                // access it bracketing it with a try/except block. This
                // is because the user memory might under some circumstances
                // become invalid while the driver is running and then it
                // would AV. Also, the driver might need to do some cleanup
                // before returning to the OS.

                __try
                {
                    // Try to render as a primitive(s) in a separate loop
                    // in order not loose performance doing hw setup again
                    bParseError = __DP2_PrimitiveOpsParser( pContext, 
                                                            pdp2d, 
                                                            &lpIns, 
                                                            lpInsStart, 
                                                            pContext->lpVertices);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // On this driver we don't need to do anything special
                    DISPDBG((ERRLVL,"Driver caused exception at "
                                    "line %u of file %s",
                                    __LINE__,__FILE__));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);
                }                
            
            }
            else
            {
                // Try to render as a primitive(s) in a separate loop
                // in order not loose performance doing hw setup again
                bParseError = __DP2_PrimitiveOpsParser( pContext, 
                                                        pdp2d, 
                                                        &lpIns, 
                                                        lpInsStart, 
                                                        pContext->lpVertices);
            }

            // We weren't succesful, so we exit with an error code
            if (bParseError)
            {
                PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                      D3DERR_COMMAND_UNPARSED);
            }
        } // switch
    } // while


//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS 
    if( bUsedHostIn )
    {
        _D3D_EB_UpdateSwapBuffers(pThisDisplay,
                                  pdp2d ,
                                  pVertexBufferInfo,
                                  pCommandBufferInfo);        
    }
#endif    
//@@END_DDKSPLIT

    START_SOFTWARE_CURSOR(pThisDisplay);

    if (!bParseError)
    {
        pdp2d->ddrval = DD_OK;
    }

    DBG_CB_EXIT(D3DDrawPrimitives2_P3, DD_OK);                              
    return DDHAL_DRIVER_HANDLED;
    
} // D3DDrawPrimitives2_P3

//-----------------------------------------------------------------------------
//
// __DP2_PrimitiveOpsParser
//
// Render command buffer which contains primitive(s) in a separate loop            
// in order not to loose performance doing hw setup repeatedly. We keep
// spinning in this loop until we reach an EOB, a non-rendering DP2 command
// or until an error is detected.
//
//-----------------------------------------------------------------------------
BOOL
__DP2_PrimitiveOpsParser( 
    P3_D3DCONTEXT *pContext, 
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d,
    LPD3DHAL_DP2COMMAND *lplpIns, 
    LPBYTE lpInsStart, 
    LPDWORD lpVerts)
{
    P3_THUNKEDDATA*      pThisDisplay = pContext->pThisDisplay;
    LPD3DTLVERTEX        lpVertices = (LPD3DTLVERTEX) lpVerts;
    LPD3DHAL_DP2COMMAND  lpIns;
    LPD3DHAL_DP2COMMAND  lpResumeIns;  
    LPBYTE               lpPrim, lpChkPrim;
    HRESULT              ddrval;
    DWORD                dwFillMode;
    BOOL                 bParseError = FALSE;
    DWORD                i;

    DBG_ENTRY(__DP2_PrimitiveOpsParser);           

    lpIns = *lplpIns;

// This macro includes all parameters passed to all the specialized
// rendering functions (since their parameters are all the same)
// just to save us of some clutter in the actual code
#define P3_RND_PARAMS               \
            pContext,               \
            lpIns->wPrimitiveCount, \
            lpPrim,                 \
            lpVertices,             \
            pdp2d->dwVertexLength, \
            &bParseError

    // Ensure the hostin unit is setup for inline vertex data.
    {
        P3_DMA_DEFS();
        P3_DMA_GET_BUFFER_ENTRIES(6);
        pContext->SoftCopyGlint.P3RX_P3VertexControl.Size = 
                    pContext->FVFData.dwStrideHostInline / sizeof(DWORD);
                            
        COPY_P3_DATA( VertexControl, 
                      pContext->SoftCopyGlint.P3RX_P3VertexControl );
        SEND_P3_DATA( VertexValid, 
                      pContext->FVFData.dwVertexValidHostInline);
        SEND_P3_DATA( VertexFormat, 
                      pContext->FVFData.vFmatHostInline);
                      
        P3_DMA_COMMIT_BUFFER();
    }

    // Process commands while we haven't exhausted the command buffer
    while (!bParseError && 
           ((LPBYTE)lpIns < 
            (lpInsStart + pdp2d->dwCommandLength + pdp2d->dwCommandOffset))) 
    {
        BOOL bNonRenderingOP;
    
        // Get pointer to first primitive structure past the D3DHAL_DP2COMMAND
        lpPrim = (LPBYTE)lpIns + sizeof(D3DHAL_DP2COMMAND);

        // Rendering primitive functions called vary according to 
        // the fill mode selected ( POINT, WIREFRAME, SOLID );
        dwFillMode = pContext->RenderStates[D3DRENDERSTATE_FILLMODE];        

        DISPDBG((DBGLVL, "__DP2_PrimitiveOpsParser: "
                    "Parsing instruction %d Count = %d @ %x",
                    lpIns->bCommand, lpIns->wPrimitiveCount, lpIns));

        // If we are processing a known, though non-rendering opcode 
        // then  its time to quit this function
        bNonRenderingOP =
            ( lpIns->bCommand == D3DDP2OP_RENDERSTATE )       ||
            ( lpIns->bCommand == D3DDP2OP_TEXTURESTAGESTATE ) ||
            ( lpIns->bCommand == D3DDP2OP_STATESET )          ||            
            ( lpIns->bCommand == D3DDP2OP_VIEWPORTINFO )      ||
            ( lpIns->bCommand == D3DDP2OP_WINFO )             ||
            ( lpIns->bCommand == D3DDP2OP_ZRANGE )            ||
            ( lpIns->bCommand == D3DDP2OP_SETMATERIAL )       ||
            ( lpIns->bCommand == D3DDP2OP_SETLIGHT )          ||
            ( lpIns->bCommand == D3DDP2OP_TEXBLT )            ||
            ( lpIns->bCommand == D3DDP2OP_SETLIGHT )          ||
            ( lpIns->bCommand == D3DDP2OP_TEXBLT )            ||
            ( lpIns->bCommand == D3DDP2OP_CREATELIGHT )       ||
            ( lpIns->bCommand == D3DDP2OP_EXT )               ||
            ( lpIns->bCommand == D3DDP2OP_SETTRANSFORM )      ||
            ( lpIns->bCommand == D3DDP2OP_CLEAR )             ||
            ( lpIns->bCommand == D3DDP2OP_UPDATEPALETTE )     ||
            ( lpIns->bCommand == D3DDP2OP_SETPALETTE )        ||
#if DX7_TEXMANAGEMENT
            ( lpIns->bCommand == D3DDP2OP_SETTEXLOD )         ||
            ( lpIns->bCommand == D3DDP2OP_SETPRIORITY )       ||
#endif // DX7_TEXMANAGEMENT
#if DX8_DDI            
            ( lpIns->bCommand == D3DDP2OP_CREATEVERTEXSHADER) ||
            ( lpIns->bCommand == D3DDP2OP_SETVERTEXSHADER)    ||
            ( lpIns->bCommand == D3DDP2OP_DELETEVERTEXSHADER) ||
            ( lpIns->bCommand == D3DDP2OP_SETVERTEXSHADERCONST) ||
            ( lpIns->bCommand == D3DDP2OP_CREATEPIXELSHADER)  ||
            ( lpIns->bCommand == D3DDP2OP_SETPIXELSHADER)     ||
            ( lpIns->bCommand == D3DDP2OP_DELETEPIXELSHADER)  ||
            ( lpIns->bCommand == D3DDP2OP_SETPIXELSHADERCONST)||
            ( lpIns->bCommand == D3DDP2OP_SETSTREAMSOURCE )   ||
            ( lpIns->bCommand == D3DDP2OP_SETSTREAMSOURCEUM ) ||
            ( lpIns->bCommand == D3DDP2OP_SETINDICES )        ||
#endif //DX8_DDI            
            ( lpIns->bCommand == D3DDP2OP_SETRENDERTARGET);

        if (bNonRenderingOP)            
        {
            break;
        }

        // Main rendering Dp2 opcode switch                   
        switch( lpIns->bCommand )
        {
        case D3DDP2OP_POINTS:

            DISPDBG((DBGLVL, "D3DDP2OP_POINTS"));

            // Point primitives in vertex buffers are defined by the 
            // D3DHAL_DP2POINTS structure. The driver should render
            // wCount points starting at the initial vertex specified 
            // by wFirst. Then for each D3DHAL_DP2POINTS, the points
            // rendered will be (wFirst),(wFirst+1),...,
            // (wFirst+(wCount-1)). The number of D3DHAL_DP2POINTS
            // structures to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND.
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2POINTS, lpIns->wPrimitiveCount, 0);

            _D3D_R3_DP2_Points( P3_RND_PARAMS );
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2POINTS, 
                            lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_LINELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_LINELIST"));

            // Non-indexed vertex-buffer line lists are defined by the 
            // D3DHAL_DP2LINELIST structure. Given an initial vertex, 
            // the driver will render a sequence of independent lines, 
            // processing two new vertices with each line. The number 
            // of lines to render is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be 
            // (wVStart, wVStart+1),(wVStart+2, wVStart+3),...,
            // (wVStart+(wPrimitiveCount-1)*2), wVStart+wPrimitiveCount*2 - 1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, D3DHAL_DP2LINELIST, 1, 0);

            _D3D_R3_DP2_LineList( P3_RND_PARAMS );
        
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDLINELIST"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),...
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2INDEXEDLINELIST, 
                                lpIns->wPrimitiveCount, 0);

            _D3D_R3_DP2_IndexedLineList( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST2:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDLINELIST2"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).
            // The indexes are relative to a base index value that 
            // immediately follows the command
            
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2INDEXEDLINELIST, 
                                lpIns->wPrimitiveCount, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedLineList2( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_LINESTRIP"));

            // Non-index line strips rendered with vertex buffers are
            // specified using D3DHAL_DP2LINESTRIP. The first vertex 
            // in the line strip is specified by wVStart. The 
            // number of lines to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of lines rendered will be (wVStart, wVStart+1),
            // (wVStart+1, wVStart+2),(wVStart+2, wVStart+3),...,
            // (wVStart+wPrimitiveCount, wVStart+wPrimitiveCount+1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,D3DHAL_DP2LINESTRIP, 1, 0);

            _D3D_R3_DP2_LineStrip( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDLINESTRIP"));

            // Indexed line strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDLINESTRIP. The number
            // of lines to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[1], wV[2]),
            // (wV[2], wV[3]), ...
            // (wVStart[wPrimitiveCount-1], wVStart[wPrimitiveCount]). 
            // Although the D3DHAL_DP2INDEXEDLINESTRIP structure only
            // has enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+1 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                WORD, 
                                lpIns->wPrimitiveCount + 1, 
                                STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedLineStrip( P3_RND_PARAMS );

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            // Advance only as many vertex indices there are, with no padding!
            NEXTINSTRUCTION(lpIns, WORD, 
                            lpIns->wPrimitiveCount + 1, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLELIST"));

            // Non-indexed vertex buffer triangle lists are defined by 
            // the D3DHAL_DP2TRIANGLELIST structure. Given an initial
            // vertex, the driver will render independent triangles, 
            // processing three new vertices with each triangle. The
            // number of triangles to render is specified by the 
            // wPrimitveCount field of D3DHAL_DP2COMMAND. The sequence
            // of vertices processed will be  (wVStart, wVStart+1, 
            // vVStart+2), (wVStart+3, wVStart+4, vVStart+5),...,
            // (wVStart+(wPrimitiveCount-1)*3), wVStart+wPrimitiveCount*3-2, 
            // vStart+wPrimitiveCount*3-1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2TRIANGLELIST, 1, 0);

            _D3D_R3_DP2_TriangleList( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDTRIANGLELIST"));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.

            // This is the only indexed primitive where we don't get 
            // an offset into the vertex buffer in order to maintain
            // DX3 compatibility. A new primitive 
            // (D3DDP2OP_INDEXEDTRIANGLELIST2) has been added to handle
            // the corresponding D3D primitive.

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2INDEXEDTRIANGLELIST, 
                                lpIns->wPrimitiveCount, 0);
                                
            if( lpIns->wPrimitiveCount )
            {   
                _D3D_R3_DP2_IndexedTriangleList( P3_RND_PARAMS );
            }
    
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST, 
                            lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST2:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDTRIANGLELIST2 "));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST2 structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2INDEXEDTRIANGLELIST2, 
                                lpIns->wPrimitiveCount, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedTriangleList2( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST2, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLESTRIP"));

            // Non-index triangle strips rendered with vertex buffers 
            // are specified using D3DHAL_DP2TRIANGLESTRIP. The first 
            // vertex in the triangle strip is specified by wVStart. 
            // The number of triangles to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of triangles rendered for the odd-triangles case will 
            // be (wVStart, wVStart+1, vVStart+2), (wVStart+2, 
            // wVStart+1, vVStart+3),.(wVStart+2, wVStart+3, 
            // vVStart+4),.., (wVStart+wPrimitiveCount-1), 
            // wVStart+wPrimitiveCount, vStart+wPrimitiveCount+1). For an
            // even number of , the last triangle will be .,
            // (wVStart+wPrimitiveCount), wVStart+wPrimitiveCount-1, 
            // vStart+wPrimitiveCount+1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, D3DHAL_DP2TRIANGLESTRIP, 1, 0);

            _D3D_R3_DP2_TriangleStrip( P3_RND_PARAMS );

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDTRIANGLESTRIP"));

            // Indexed triangle strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDTRIANGLESTRIP. The number
            // of triangles to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of triangles 
            // rendered for the odd-triangles case will be 
            // (wV[0],wV[1],wV[2]),(wV[2],wV[1],wV[3]),
            // (wV[3],wV[4],wV[5]),...,(wV[wPrimitiveCount-1],
            // wV[wPrimitiveCount],wV[wPrimitiveCount+1]). For an even
            // number of triangles, the last triangle will be
            // (wV[wPrimitiveCount],wV[wPrimitiveCount-1],
            // wV[wPrimitiveCount+1]).Although the 
            // D3DHAL_DP2INDEXEDTRIANGLESTRIP structure only has 
            // enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+2 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, WORD,
                                lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedTriangleStrip( P3_RND_PARAMS );
            
            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, WORD , 
                            lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLEFAN:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLEFAN"));

            // The D3DHAL_DP2TRIANGLEFAN structure is used to draw 
            // non-indexed triangle fans. The sequence of triangles
            // rendered will be (wVStart, wVstart+1, wVStart+2),
            // (wVStart,wVStart+2,wVStart+3), (wVStart,wVStart+3,
            // wVStart+4),...,(wVStart,wVStart+wPrimitiveCount,
            // wVStart+wPrimitiveCount+1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2TRIANGLEFAN, 1, 0);

            _D3D_R3_DP2_TriangleFan( P3_RND_PARAMS );
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLEFAN, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLEFAN:

            DISPDBG((DBGLVL,"D3DDP2OP_INDEXEDTRIANGLEFAN"));

            // The D3DHAL_DP2INDEXEDTRIANGLEFAN structure is used to 
            // draw indexed triangle fans. The sequence of triangles
            // rendered will be (wV[0], wV[1], wV[2]), (wV[0], wV[2],
            // wV[3]), (wV[0], wV[3], wV[4]),...,(wV[0],
            // wV[wPrimitiveCount], wV[wPrimitiveCount+1]).
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, WORD,
                                lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedTriangleFan( P3_RND_PARAMS );

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns,WORD ,lpIns->wPrimitiveCount + 2, 
                            STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINELIST_IMM:

            DISPDBG((DBGLVL, "D3DDP2OP_LINELIST_IMM"));

            // Draw a set of lines specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of lines that follow. 

            // Primitives in an IMM instruction are stored in the
            // command buffer and are DWORD aligned
            lpPrim = (LPBYTE)((ULONG_PTR)(lpPrim + 3 ) & ~3 );

            // Verify the command buffer validity (data lives in it!)
            CHECK_CMDBUF_LIMITS_S(pdp2d, lpPrim,
                                  pContext->FVFData.dwStride, 
                                  lpIns->wPrimitiveCount + 1, 0);            

            _D3D_R3_DP2_LineListImm( P3_RND_PARAMS );

            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            NEXTINSTRUCTION(lpIns, BYTE, 
                            ((lpIns->wPrimitiveCount * 2) * 
                                 pContext->FVFData.dwStride), 0);

            // Realign next command since vertices are dword aligned
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);

            break;

        case D3DDP2OP_TRIANGLEFAN_IMM:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLEFAN_IMM"));

            // Draw a triangle fan specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of triangles that follow. 

            // Verify the command buffer validity for the first structure
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                BYTE , 0 , 
                                sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));

            // Get pointer where data should start
            lpChkPrim = (LPBYTE)((ULONG_PTR)( lpPrim + 3 + 
                                   sizeof(D3DHAL_DP2TRIANGLEFAN_IMM)) & ~3 );

            // Verify the rest of the command buffer
            CHECK_CMDBUF_LIMITS_S(pdp2d, lpChkPrim,
                                  pContext->FVFData.dwStride, 
                                  lpIns->wPrimitiveCount + 2, 0);  
                                         
            _D3D_R3_DP2_TriangleFanImm( P3_RND_PARAMS );    
    
            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            NEXTINSTRUCTION(lpIns, BYTE, 
                            ((lpIns->wPrimitiveCount + 2) * 
                                    pContext->FVFData.dwStride), 
                            sizeof(D3DHAL_DP2TRIANGLEFAN_IMM)); 

            // Realign next command since vertices are dword aligned
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);


            break;                                     


#if DX8_MULTSTREAMS
        case D3DDP2OP_DRAWPRIMITIVE :
            {
                D3DHAL_DP2DRAWPRIMITIVE* pDrawPrim;
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWPRIMITIVE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWPRIMITIVE, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawPrim = (D3DHAL_DP2DRAWPRIMITIVE*)lpPrim;
                    
                    _D3D_OP_MStream_DrawPrim(pContext,
                                       pDrawPrim->primType,
                                       pDrawPrim->VStart,
                                       pDrawPrim->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWPRIMITIVE);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWPRIMITIVE, 
                                lpIns->wStateCount, 0);
                }
            break;  
            
        case D3DDP2OP_DRAWINDEXEDPRIMITIVE :
            {
                D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pDrawIndxPrim;
            
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWINDEXEDPRIMITIVE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWINDEXEDPRIMITIVE, 
                                    lpIns->wStateCount, 0);
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawIndxPrim = (D3DHAL_DP2DRAWINDEXEDPRIMITIVE*)lpPrim;
                    
                    _D3D_OP_MStream_DrawIndxP(pContext,
                                        pDrawIndxPrim->primType,
                                        pDrawIndxPrim->BaseVertexIndex,
                                        pDrawIndxPrim->MinIndex,
                                        pDrawIndxPrim->NumVertices,
                                        pDrawIndxPrim->StartIndex,
                                        pDrawIndxPrim->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE);
                }
               
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWINDEXEDPRIMITIVE, 
                                lpIns->wStateCount, 0);
            }
            break;  
            
        case D3DDP2OP_DRAWPRIMITIVE2 :
            {
                D3DHAL_DP2DRAWPRIMITIVE2* pDrawPrim2;
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWPRIMITIVE2"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWPRIMITIVE2, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawPrim2 = (D3DHAL_DP2DRAWPRIMITIVE2*)lpPrim;
                    
                    _D3D_OP_MStream_DrawPrim2(pContext,
                                        pDrawPrim2->primType,
                                        pDrawPrim2->FirstVertexOffset,
                                        pDrawPrim2->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWPRIMITIVE2);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWPRIMITIVE2, 
                                lpIns->wStateCount, 0);
                }
            break;    
            
        case D3DDP2OP_DRAWINDEXEDPRIMITIVE2 :
            {
                D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pDrawIndxPrim2;
            
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWINDEXEDPRIMITIVE2"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWINDEXEDPRIMITIVE2, 
                                    lpIns->wStateCount, 0);
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawIndxPrim2 = (D3DHAL_DP2DRAWINDEXEDPRIMITIVE2*)lpPrim;
                    
                    _D3D_OP_MStream_DrawIndxP2(pContext,
                                         pDrawIndxPrim2->primType,
                                         pDrawIndxPrim2->BaseVertexOffset,
                                         pDrawIndxPrim2->MinIndex,
                                         pDrawIndxPrim2->NumVertices,
                                         pDrawIndxPrim2->StartIndexOffset,
                                         pDrawIndxPrim2->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE2);
                }
               
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWINDEXEDPRIMITIVE2,
                                lpIns->wStateCount, 0);
            }
            break;          
    
        case D3DDP2OP_DRAWRECTPATCH :
            {
                D3DHAL_DP2DRAWRECTPATCH* pRectSurf;
                DWORD dwExtraBytes = 0;
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWRECTPATCH"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWRECTPATCH, 
                                    lpIns->wStateCount, 0);
                                    
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pRectSurf = (D3DHAL_DP2DRAWRECTPATCH*)lpPrim;

                    lpPrim += sizeof(D3DHAL_DP2DRAWRECTPATCH);                    
                    
                    _D3D_OP_MStream_DrawRectSurface(pContext, 
                                                    pRectSurf->Handle,
                                                    pRectSurf->Flags,
                                                    lpPrim);
                                                    
                    if (pRectSurf->Flags & RTPATCHFLAG_HASSEGS)
                    {
                        dwExtraBytes += sizeof(D3DVALUE)* 4;                    
                    }
                    
                    if (pRectSurf->Flags & RTPATCHFLAG_HASINFO)                    
                    {
                        dwExtraBytes += sizeof(D3DRECTPATCH_INFO);
                    }

                    lpPrim += dwExtraBytes;
                } 
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWRECTPATCH, 
                                lpIns->wStateCount, dwExtraBytes);
            }
            break;     

        case D3DDP2OP_DRAWTRIPATCH :
            {
                D3DHAL_DP2DRAWTRIPATCH* pTriSurf;
                DWORD dwExtraBytes = 0;                
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWTRIPATCH"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWTRIPATCH, 
                                    lpIns->wStateCount, 0);
                                    
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pTriSurf = (D3DHAL_DP2DRAWTRIPATCH*)lpPrim;

                    lpPrim += sizeof(D3DHAL_DP2DRAWTRIPATCH);

                    _D3D_OP_MStream_DrawTriSurface(pContext, 
                                                   pTriSurf->Handle,
                                                   pTriSurf->Flags,
                                                   lpPrim);                    
                                 
                    if (pTriSurf->Flags & RTPATCHFLAG_HASSEGS)
                    {
                        dwExtraBytes += sizeof(D3DVALUE)* 3;                    
                    }
                    
                    if (pTriSurf->Flags & RTPATCHFLAG_HASINFO)                    
                    {
                        dwExtraBytes += sizeof(D3DTRIPATCH_INFO);
                    }

                    lpPrim += dwExtraBytes;
                } 
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWTRIPATCH, 
                                lpIns->wStateCount, dwExtraBytes);
            }
            break;                 
            
        case D3DDP2OP_CLIPPEDTRIANGLEFAN :
            {
                D3DHAL_CLIPPEDTRIANGLEFAN* pClipdTriFan;
            
                DISPDBG((DBGLVL, "D3DDP2OP_CLIPPEDTRIANGLEFAN"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_CLIPPEDTRIANGLEFAN, 
                                    lpIns->wStateCount, 0);

                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pClipdTriFan = (D3DHAL_CLIPPEDTRIANGLEFAN*)lpPrim;
                    
                    _D3D_OP_MStream_ClipTriFan(pContext,
                                         pClipdTriFan->FirstVertexOffset,
                                         pClipdTriFan->dwEdgeFlags,
                                         pClipdTriFan->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_CLIPPEDTRIANGLEFAN);
                } 
                
                NEXTINSTRUCTION(lpIns, D3DHAL_CLIPPEDTRIANGLEFAN, 
                                lpIns->wStateCount, 0);
            }
            break;     

#endif // DX8_MULTSTREAMS

        // This was found to be required for a few D3DRM apps 
        case D3DOP_EXIT:
            lpIns = (D3DHAL_DP2COMMAND *)(lpInsStart + 
                                          pdp2d->dwCommandLength + 
                                          pdp2d->dwCommandOffset);
            break;

        default:

            ASSERTDD((pThisDisplay->pD3DParseUnknownCommand),
                      "D3D ParseUnknownCommand callback == NULL");

            if( SUCCEEDED(ddrval=(pThisDisplay->pD3DParseUnknownCommand)
                                    ( lpIns , 
                                      (void**)&lpResumeIns)) ) 
            {
                // Resume buffer processing after D3DParseUnknownCommand
                // was succesful in processing an unknown command
                lpIns = lpResumeIns;
                break;
            }

            DISPDBG((ERRLVL, "Unhandled opcode (%d)- "
                        "returning D3DERR_COMMAND_UNPARSED @ addr %x", 
                        lpIns->bCommand,
                        lpIns));
                    
            PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, ddrval);
        } // switch

    } //while

    *lplpIns = lpIns;

    DBG_EXIT(__DP2_PrimitiveOpsParser, bParseError); 
    return bParseError;
    
} // __DP2_PrimitiveOpsParser


//-----------------------------Public Routine----------------------------------
//
// D3DValidateDeviceP3
//
// Returns the number of passes in which the hardware can perform the blending 
// operations specified in the current state.
//
// Direct3D drivers that support texturing must implement 
// D3dValidateTextureStageState.
//
// The driver must do the following: 
//
// Evaluate the current texture state for all texture stages associated with the 
// context. If the driver's hardware can perform the specified blending 
// operations, the driver should return the number of passes on the state data 
// that its hardware requires in order to entirely process the operations. If 
// the hardware is incapable of performing the specified blending operations, 
// the driver should return one of the following error codes in ddrval: 
//
//      D3DERR_CONFLICTINGTEXTUREFILTER 
//              The hardware cannot do both trilinear filtering and 
//              multi-texturing at the same time. 
//      D3DERR_TOOMANYOPERATIONS 
//              The hardware cannot handle the specified number of operations. 
//      D3DERR_UNSUPPORTEDALPHAARG 
//              The hardware does not support a specified alpha argument. 
//      D3DERR_UNSUPPORTEDALPHAOPERATION 
//              The hardware does not support a specified alpha operation. 
//      D3DERR_UNSUPPORTEDCOLORARG 
//              The hardware does not support a specified color argument. 
//      D3DERR_UNSUPPORTEDCOLOROPERATION 
//              The hardware does not support a specified color operation. 
//      D3DERR_UNSUPPORTEDFACTORVALUE 
//              The hardware does not support a D3DTA_TFACTOR greater than 1.0. 
//      D3DERR_WRONGTEXTUREFORMAT 
//              The hardware does not support the current state in the selected 
//              texture format
// 
// Direct3D calls D3dValidateTextureStageState in response to an application 
// request through a call to IDirect3DDevice3::ValidateTextureStageState. The 
// number of passes returned by the driver is propagated back to the application
// , which can then decide whether it wants to proceed with rendering using the 
// current state or if it wants/needs to change the blending operations to 
// render faster or render at all. There are no limits to the number of passes 
// that a driver can return.
//
// A driver that returns more than one pass is responsible for properly 
//executing the passes on all state and primitive data when rendering.
//
// Parameters
//
//      pvtssd
//
//          .dwhContext
//               Specifies the context ID of the Direct3D device. 
//          .dwFlags
//               Is currently set to zero and should be ignored by the driver. 
//          .dwReserved
//               Is reserved for system use and should be ignored by the driver.
//          .dwNumPasses
//              Specifies the location in which the driver should write the 
//              number of passes required by the hardware to perform the 
//              blending operations. 
//          .ddrval
//               return value
//
//-----------------------------------------------------------------------------

// Taken from the registry variable.
#define VDOPMODE_IGNORE_NONFATAL    0   // dualtex + trilinear (for examples) 
                                        // not flagged as a bug.

DWORD CALLBACK 
D3DValidateDeviceP3( 
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd )
{
    P3_D3DCONTEXT* pContext;
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(D3DValidateDeviceP3);
    
    pContext = _D3D_CTX_HandleToPtr(pvtssd->dwhContext);
    if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
    {
        pvtssd->ddrval = D3DHAL_CONTEXT_BAD;
        DISPDBG((WRNLVL,"ERROR: Context not valid"));
        DBG_CB_EXIT(D3DValidateDeviceP3, pvtssd->ddrval);  

        return (DDHAL_DRIVER_HANDLED);
    }

    pThisDisplay = pContext->pThisDisplay;

    STOP_SOFTWARE_CURSOR(pThisDisplay);
    D3D_OPERATION(pContext, pThisDisplay);

    // Re-do all the blend-mode setup from scratch.
    RESET_BLEND_ERROR(pContext);
    DIRTY_EVERYTHING(pContext);
    
    // The primitive type is not actually important except to keep the
    // rout from asserting various things when it tries to pick the renderer
    // (which of course does not need to be done in this case).
    ReconsiderStateChanges ( pContext );

    START_SOFTWARE_CURSOR(pThisDisplay);

    _D3DDisplayWholeTSSPipe ( pContext, DBGLVL);

    // And see if anything died.
    if (GET_BLEND_ERROR(pContext) == BS_OK )
    {
        // Cool - that worked.
        pvtssd->dwNumPasses = 1;
        pvtssd->ddrval = DD_OK;
        DBG_CB_EXIT(D3DValidateDeviceP3, pvtssd->ddrval);  

        return ( DDHAL_DRIVER_HANDLED );
    }
    else
    {
        // Oops. Failed.
        DISPDBG((DBGLVL,"ValidateDevice: failed ValidateDevice()"));

        switch ( GET_BLEND_ERROR(pContext) )
        {
            case BS_OK:
                DISPDBG((ERRLVL,"ValidateDevice: got BS_OK - that's not "
                             "an error!"));
                pvtssd->ddrval = DD_OK;
                break;

            case BS_INVALID_FILTER:
                pvtssd->ddrval = D3DERR_CONFLICTINGTEXTUREFILTER;
                break;

            case BSF_CANT_USE_COLOR_OP_HERE:
            case BSF_CANT_USE_COLOR_ARG_HERE:
            case BSF_CANT_USE_ALPHA_OP_HERE:
            case BSF_CANT_USE_ALPHA_ARG_HERE:
                pvtssd->ddrval = D3DERR_CONFLICTINGRENDERSTATE;
                break;

            case BSF_INVALID_TEXTURE:
            case BSF_TEXTURE_NOT_POW2:
                pvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                break;

            case BSF_UNDEFINED_COLOR_OP:
            case BSF_UNSUPPORTED_COLOR_OP:
            case BSF_UNSUPPORTED_ALPHA_BLEND:   // doesn't fit anywhere else.
            case BSF_UNDEFINED_ALPHA_BLEND:     // doesn't fit anywhere else.
            case BSF_UNSUPPORTED_STATE:         // doesn't fit anywhere else.
            case BSF_UNDEFINED_STATE:           // doesn't fit anywhere else.
            case BS_PHONG_SHADING:              // doesn't fit anywhere else.
                pvtssd->ddrval = D3DERR_UNSUPPORTEDCOLOROPERATION;
                break;

            case BSF_UNDEFINED_COLOR_ARG:
            case BSF_UNSUPPORTED_COLOR_ARG:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDCOLORARG;
                break;

            case BSF_UNDEFINED_ALPHA_OP:
            case BSF_UNSUPPORTED_ALPHA_OP:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAOPERATION;
                break;

            case BSF_UNDEFINED_ALPHA_ARG:
            case BSF_UNSUPPORTED_ALPHA_ARG:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAARG;
                break;

            case BSF_TOO_MANY_TEXTURES:
            case BSF_TOO_MANY_BLEND_STAGES:
                pvtssd->ddrval = D3DERR_TOOMANYOPERATIONS;
                break;

            case BSF_UNDEFINED_FILTER:
            case BSF_UNSUPPORTED_FILTER:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDTEXTUREFILTER;
                break;

            case BSF_TOO_MANY_PALETTES:
                pvtssd->ddrval = D3DERR_CONFLICTINGTEXTUREPALETTE;
                break;

// Nothing maps to these, but they are valid D3D return
// codes that be used for future errors.
//              pvtssd->ddrval = D3DERR_UNSUPPORTEDFACTORVALUE;
//              break;
//              pvtssd->ddrval = D3DERR_TOOMANYPRIMITIVES;
//              break;
//              pvtssd->ddrval = D3DERR_INVALIDMATRIX;
//              break;
//              pvtssd->ddrval = D3DERR_TOOMANYVERTICES;
//              break;

            case BSF_UNINITIALISED:
                // Oops.
                DISPDBG((ERRLVL,"ValidateDevice: unitialised error"
                             " - logic problem."));
                pvtssd->ddrval = D3DERR_TOOMANYOPERATIONS;
                break;
            default:
                // Unknown.
                DISPDBG((ERRLVL,"ValidateDevice: unknown "
                             "blend-mode error."));
                pvtssd->ddrval = D3DERR_TOOMANYOPERATIONS;
                break;
        }

        pvtssd->dwNumPasses = 1;
        DBG_CB_EXIT(D3DValidateDeviceP3, pvtssd->ddrval);  
        return ( DDHAL_DRIVER_HANDLED );
    }

} // D3DValidateDeviceP3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dbuff.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dbuff.c
*
//@@BEGIN_DDKSPLIT
* Content: Main context callbacks for D3D videomemory buffers
//@@END_DDKSPLIT
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS

#define _32_KBYTES ( 32 * 1024 )

//-----------------------------------------------------------------------------
// in-the-file nonexported forward declarations
//-----------------------------------------------------------------------------
                                  
BOOL __EB_RemoveFromBufferQueue(P3_THUNKEDDATA* pThisDisplay, 
                                   P3_VERTEXBUFFERINFO* pVictim);
void __EB_Wait(P3_THUNKEDDATA* pThisDisplay, P3_VERTEXBUFFERINFO* pBuffer);

#if DBG 
//-----------------------------------------------------------------------------
//
// __EB_DisplayHeapInfo
//
// A debug function.  Displays the current buffer queue
//
//-----------------------------------------------------------------------------
void 
__EB_DisplayHeapInfo(
    int DebugLevel, 
    P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwSequenceID = 0xFFFFFFFF;
   
    if (DebugLevel <= P3R3DX_DebugLevel)
    {
        P3_VERTEXBUFFERINFO* pCurrentCommandBuffer = 
                                        pThisDisplay->pRootCommandBuffer;
        P3_VERTEXBUFFERINFO* pCurrentVertexBuffer = 
                                        pThisDisplay->pRootVertexBuffer;
        int count = 0;

        DISPDBG((DebugLevel,"Command buffer heap"));
        
        dwSequenceID = 0xFFFFFFFF;
        if (pCurrentCommandBuffer) 
        {           
            do
            {
                // A debug check to ensure that the sequence ID's go backwards
                ASSERTDD((dwSequenceID >= pCurrentCommandBuffer->dwSequenceID),
                          "ERROR: Sequence ID's broken!");
                          
                DISPDBG((DebugLevel,"Buffer %d,SequenceID:0x%x Pointer: 0x%x",
                                    count++, 
                                    pCurrentCommandBuffer->dwSequenceID, 
                                    pCurrentCommandBuffer));
                DISPDBG((DebugLevel,"  pPrev: 0x%x, pNext: 0x%x", 
                                    pCurrentCommandBuffer->pPrev, 
                                    pCurrentCommandBuffer->pNext));
                DISPDBG((DebugLevel,"  bInUse: %d", 
                                    pCurrentCommandBuffer->bInUse));
                                    
                dwSequenceID = pCurrentCommandBuffer->dwSequenceID;
                pCurrentCommandBuffer = pCurrentCommandBuffer->pNext;
                
            } while (pCurrentCommandBuffer != pThisDisplay->pRootCommandBuffer);
        }

        DISPDBG((DebugLevel,"Vertex buffer heap"));

        dwSequenceID = 0xFFFFFFFF;
        if (pCurrentVertexBuffer) 
        {           
            do
            {
                // A debug check to ensure that the sequence ID's go backwards
                ASSERTDD((dwSequenceID >= pCurrentVertexBuffer->dwSequenceID),
                          "ERROR: Sequence ID's broken!");

                DISPDBG((DebugLevel,"Buffer %d,SequenceID:0x%x Pointer: 0x%x",
                                    count++, 
                                    pCurrentVertexBuffer->dwSequenceID, 
                                    pCurrentVertexBuffer));
                DISPDBG((DebugLevel,"  pPrev: 0x%x, pNext: 0x%x", 
                                    pCurrentVertexBuffer->pPrev, 
                                    pCurrentVertexBuffer->pNext));
                DISPDBG((DebugLevel,"  bInUse: %d", 
                                    pCurrentVertexBuffer->bInUse));
                                    
                dwSequenceID = pCurrentVertexBuffer->dwSequenceID;
                pCurrentVertexBuffer = pCurrentVertexBuffer->pNext;
            } while (pCurrentVertexBuffer != pThisDisplay->pRootVertexBuffer);
        }

    }
    
} // __EB_DisplayHeapInfo

#endif // DBG



//-----------------------------------------------------------------------------
//
// __EB_FreeCachedBuffer
//
// Frees a buffer associated with this directdraw surface.  This is called
// in response to a destroyexecutebuffer call
//
//-----------------------------------------------------------------------------
void 
__EB_FreeCachedBuffer(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    P3_VERTEXBUFFERINFO* pVictim = 
                        (P3_VERTEXBUFFERINFO*)pSurf->lpGbl->dwReserved1;

    if (pVictim != NULL)
    {
        DISPDBG((DBGLVL,"Buffer is one of ours - destroying it"));

        // Wait for the buffer to be consumed
        __EB_Wait(pThisDisplay, pVictim);

        // Set the inuse flag off so the buffer will be freed.
        pVictim->bInUse = FALSE;

        // Remove the buffer from the pending list
        // The memory won't be freed if the buffer isn't in the list
        if (!__EB_RemoveFromBufferQueue(pThisDisplay, pVictim))
        {
            // Free the memory
            switch (pVictim->BufferType)
            {
            case COMMAND_BUFFER:
                _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedCommandHeapInfo, 
                                         PtrToUlong(pVictim));
                break;
                
            case VERTEX_BUFFER:
                _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedVertexHeapInfo, 
                                         PtrToUlong(pVictim));
                break;
            }
        }

        // Reset the buffer pointers
        pSurf->lpGbl->dwReserved1 = 0;
        pSurf->lpGbl->fpVidMem = 0;
    }

} // __EB_FreeCachedBuffer

//-----------------------------------------------------------------------------
//
// __EB_GetSequenceID
//
// Each vertex buffer and command buffer is "stamped" with a sequence ID which
// can be queried in order to find out if a given buffer was already consumed
// by the hardware. __EB_GetSequenceID returns us the sequence ID of the last
// processed buffer.
//
//-----------------------------------------------------------------------------
const DWORD 
__EB_GetSequenceID(
    P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwSequenceID;

    dwSequenceID = READ_GLINT_CTRL_REG(HostInID);

    DISPDBG((DBGLVL,"HostIn ID: 0x%x", dwSequenceID));

    return dwSequenceID;
    
} // __EB_GetSequenceID

//-----------------------------------------------------------------------------
//
// __EB_GetNewSequenceID
//
// A driver routine to increment the sequence ID and return it.  This 
// routine handles the case where the buffer is wrapped beyond the maximum
// number that it can hold.  In such case all buffers are flushed
// 
//-----------------------------------------------------------------------------
const DWORD 
__EB_GetNewSequenceID(
     P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwWrapMask;
    
    DBG_ENTRY(__EB_GetNewSequenceID);

#if DBG
    dwWrapMask = 0x1F;
#else
    dwWrapMask = 0xFFFFFFFF;
#endif

    if( pThisDisplay->dwCurrentSequenceID >= dwWrapMask )
    {
        // We have wrapped, so flush all the buffers 
        // but wait for them to be consumed (bWait == TRUE)
        _D3D_EB_FlushAllBuffers(pThisDisplay , TRUE);

        // This SYNC is needed for unknown reasons - further investigation
        // required. //azn???

        SYNC_WITH_GLINT;

        // Reset the sequence ID numbering
        pThisDisplay->dwCurrentSequenceID = 0;
    }
    else
    {
        pThisDisplay->dwCurrentSequenceID++;
    }

    DISPDBG((DBGLVL, "Returning Sequence ID: 0x%x", 
                     pThisDisplay->dwCurrentSequenceID));

    DBG_EXIT(__EB_GetNewSequenceID,pThisDisplay->dwCurrentSequenceID);
    return pThisDisplay->dwCurrentSequenceID;
    
} // __EB_GetNewSequenceID



//-----------------------------------------------------------------------------
//
// __EB_Wait
//
// If the current buffer is in the queue, wait for it to pass through
// the chip.
//
//-----------------------------------------------------------------------------
void 
__EB_Wait(
    P3_THUNKEDDATA* pThisDisplay, 
    P3_VERTEXBUFFERINFO* pBuffer)
{   
    DBG_ENTRY(__EB_Wait);

    ASSERTDD(pBuffer, "ERROR: Buffer passed to __EB_Wait is null!");

    // Don't wait for the buffer, if it has not been added to the queue
    if (pBuffer->pNext != NULL)
    {
        // Flush to ensure that the hostin ID has been sent to the chip
        P3_DMA_DEFS();
        P3_DMA_GET_BUFFER();
        P3_DMA_FLUSH_BUFFER();

        DISPDBG((DBGLVL, "*** In __EB_Wait: Buffer Sequence ID: 0x%x", 
                         pBuffer->dwSequenceID));

        while (__EB_GetSequenceID(pThisDisplay) < pBuffer->dwSequenceID)
        {
            static int blockCount;
            
            // This buffer is in the chain of buffers that are being used
            // by the host-in unit.  We must wait for it to be consumed
            // before freeing it.

            blockCount = 100;
            while( blockCount-- )
                NULL;
        }
    }

    DBG_EXIT(__EB_Wait,0);
} // __EB_Wait

//-----------------------------------------------------------------------------
//
// __EB_RemoveFromBufferQueue
//
// Removes a buffer from the queue. Will also free the associated memory
// if it is no longer in use
//
//-----------------------------------------------------------------------------
BOOL 
__EB_RemoveFromBufferQueue(
    P3_THUNKEDDATA* pThisDisplay, 
    P3_VERTEXBUFFERINFO* pVictim)
{
    ASSERTDD(pVictim != NULL, 
             "ERROR: NULL buffer passed to EB_RemoveFromList");

    DBG_ENTRY(__EB_RemoveFromBufferQueue);

    // Don't remove a buffer that isn't already in the queue
    if (pVictim->pNext == NULL)
    {    
        DBG_EXIT(__EB_RemoveFromBufferQueue,FALSE);
        return FALSE;
    }

    DISPDBG((DBGLVL,"Removing buffer for queue, ID: 0x%x", 
                    pVictim->dwSequenceID));

    // Remove this entry from the list
    pVictim->pPrev->pNext = pVictim->pNext;
    pVictim->pNext->pPrev = pVictim->pPrev;
    
    switch (pVictim->BufferType)
    {
    case COMMAND_BUFFER:
        // Replace the root node if necessary       
        if (pVictim == pThisDisplay->pRootCommandBuffer)
        {
            if (pVictim->pNext != pThisDisplay->pRootCommandBuffer)
            {
                pThisDisplay->pRootCommandBuffer = pVictim->pNext;
            }
            else
            {
                pThisDisplay->pRootCommandBuffer = NULL;
            }
        }
        break;

    case VERTEX_BUFFER:
        // Replace the root node if necessary       
        if (pVictim == pThisDisplay->pRootVertexBuffer)
        {
            if (pVictim->pNext != pThisDisplay->pRootVertexBuffer)
            {
                pThisDisplay->pRootVertexBuffer = pVictim->pNext;
            }
            else
            {
                pThisDisplay->pRootVertexBuffer = NULL;
            }
        }
        break;
    
    } // switch (pVictim->BufferType)

    // Buffer is no longer in the list
    pVictim->pPrev = NULL;
    pVictim->pNext = NULL;

    // Free the memory we found if it isn't reserved as a real buffer.
    if (!pVictim->bInUse)
    {
        DISPDBG((DBGLVL,"  Buffer is old - freeing the memory"));

        switch (pVictim->BufferType)
        {
        case COMMAND_BUFFER:
            _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedCommandHeapInfo, 
                                     PtrToUlong(pVictim));
            break;
            
        case VERTEX_BUFFER:
            _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedVertexHeapInfo, 
                                     PtrToUlong(pVictim));
            break;
        }
        
        DBG_EXIT(__EB_RemoveFromBufferQueue,TRUE);
        return TRUE;
    }

    DBG_EXIT(__EB_RemoveFromBufferQueue,FALSE);
    return FALSE;
    
} // __EB_RemoveFromBufferQueue

//-----------------------------------------------------------------------------
//
// __EB_AddToBufferQueue
//
// Adds a buffer to the queue.  Note that buffers are always added
// at the start to maintain a temporal ordering of the buffers.
//
//-----------------------------------------------------------------------------
void 
__EB_AddToBufferQueue(
    P3_THUNKEDDATA* pThisDisplay, 
    P3_VERTEXBUFFERINFO* pNewBuffer)
{
    DBG_ENTRY(__EB_AddToBufferQueue);

    ASSERTDD(pNewBuffer != NULL, 
             "ERROR: NULL buffer passed to EB_AddToList");
    ASSERTDD(pNewBuffer->pNext == NULL, 
             "ERROR: Buffer already in queue (pNext!NULL)");
    ASSERTDD(pNewBuffer->pPrev == NULL, 
             "ERROR: Buffer already in queue (pPrev!NULL)");

    switch(pNewBuffer->BufferType)
    {
    case COMMAND_BUFFER:
        // Add the buffer to the queue
        // Check that the queue isn't empty.
        // If it is start a new list
        if (pThisDisplay->pRootCommandBuffer == NULL)
        {
            DISPDBG((DBGLVL,"Command Buffer queue is empty."
                            "  Starting a new one"));

            // Sew in the buffer
            pThisDisplay->pRootCommandBuffer = pNewBuffer;
            pNewBuffer->pNext = pNewBuffer;
            pNewBuffer->pPrev = pNewBuffer;
        }
        else
        {
            DISPDBG((DBGLVL,"Adding command buffer to the list"));

            // Always put new buffers at the root.
            pNewBuffer->pNext = pThisDisplay->pRootCommandBuffer;
            pNewBuffer->pPrev = pThisDisplay->pRootCommandBuffer->pPrev;
            pThisDisplay->pRootCommandBuffer->pPrev->pNext = pNewBuffer;
            pThisDisplay->pRootCommandBuffer->pPrev = pNewBuffer;
            pThisDisplay->pRootCommandBuffer = pNewBuffer;
        }
        break;

    case VERTEX_BUFFER:
        // Add the buffer to the queue
        // Check that the queue isn't empty.  If it is start a new list
        if (pThisDisplay->pRootVertexBuffer == NULL)
        {
            DISPDBG((DBGLVL,"Vertex Buffer queue is empty.  Starting a new one"));

            // Sew in the buffer
            pThisDisplay->pRootVertexBuffer = pNewBuffer;
            pNewBuffer->pNext = pNewBuffer;
            pNewBuffer->pPrev = pNewBuffer;
        }
        else
        {
            DISPDBG((DBGLVL,"Adding vertex buffer to the list"));

            // Always put new buffers at the root.
            pNewBuffer->pNext = pThisDisplay->pRootVertexBuffer;
            pNewBuffer->pPrev = pThisDisplay->pRootVertexBuffer->pPrev;
            pThisDisplay->pRootVertexBuffer->pPrev->pNext = pNewBuffer;
            pThisDisplay->pRootVertexBuffer->pPrev = pNewBuffer;
            pThisDisplay->pRootVertexBuffer = pNewBuffer;
        }
        break;
    } // switch(pNewBuffer->BufferType)


    DISPDBG((DBGLVL, "Added buffer to queue, ID: 0x%x", pNewBuffer->dwSequenceID));
    DBG_EXIT(__EB_AddToBufferQueue,pNewBuffer->dwSequenceID);
    
} // __EB_AddToBufferQueue        

//-----------------------------------------------------------------------------
//
// __EB_AllocateCachedBuffer
//
// Allocates a cached buffer and stores it in the surface structure.
// First this function will try to allocate out of the linear heap.
// If this fails, it will keep walking the buffer queue until there 
// are no more buffers left that are pending and aren't in use.
// If all else fails this driver will return FALSE indicating that
// it couldn't allocate the memory due to lack of space
//
//-----------------------------------------------------------------------------
BOOL 
__EB_AllocateCachedBuffer(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwBytes, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    P3_MEMREQUEST mmrq;
    DWORD dwResult;
    P3_VERTEXBUFFERINFO* pCurrentBuffer;
    P3_VERTEXBUFFERINFO** ppRootBuffer;
    BOOL bFound;
    eBufferType BufferType;
    pLinearAllocatorInfo pAllocHeap;
    static int blockCount;

    DBG_ENTRY(__EB_AllocateCachedBuffer);

#if WNT_DDRAW
    pAllocHeap = &pThisDisplay->CachedVertexHeapInfo;
    BufferType = VERTEX_BUFFER;
    ppRootBuffer = &pThisDisplay->pRootVertexBuffer;
#else
    // Decide on which heap this surface should come out of.
    if (pSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_COMMANDBUFFER)
    {
        pAllocHeap = &pThisDisplay->CachedCommandHeapInfo;
        BufferType = COMMAND_BUFFER;
        ppRootBuffer = &pThisDisplay->pRootCommandBuffer;

        DISPDBG((DBGLVL,"Buffer is COMMAND_BUFFER"));
    }
    else
    {
        pAllocHeap = &pThisDisplay->CachedVertexHeapInfo;
        BufferType = VERTEX_BUFFER;
        ppRootBuffer = &pThisDisplay->pRootVertexBuffer;

        DISPDBG((DBGLVL,"Buffer is VERTEX_BUFFER"));
    }
#endif // WNT_DDRAW

#if DBG
    // Dump the memory and the pending buffer heaps.
    __EB_DisplayHeapInfo(DBGLVL, pThisDisplay);
#endif //DBG

    // Do a quick check to see if the buffer at the back is free.
    if ((*ppRootBuffer) != NULL)
    {
        pCurrentBuffer = (*ppRootBuffer)->pPrev;
        // If the buffer is big enough, and it's completed, and 
        // it isn't in use, then free it.
        if ( ((dwBytes + sizeof(P3_VERTEXBUFFERINFO)) <= pCurrentBuffer->dwSize) &&
             (!pCurrentBuffer->bInUse) &&
             (__EB_GetSequenceID(pThisDisplay) >= pCurrentBuffer->dwSequenceID) )
        {
            // Mark this buffer as in use, so that it doesn't get freed
            pCurrentBuffer->bInUse = TRUE;

            // It isn't pending any more, so remove it from the queue
            // Note that the memory won't be deallocated because we have explicity
            // marked it as in use.
            __EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer);
            
            // Pass back a pointer to the memory
            pSurf->lpGbl->fpVidMem = (FLATPTR)((BYTE *)pCurrentBuffer) + 
                                                    sizeof(P3_VERTEXBUFFERINFO);

            // Store a pointer to the info block at the start of the memory
            pSurf->lpGbl->dwReserved1 = (ULONG_PTR)pCurrentBuffer;
#if W95_DDRAW
            // Setup the caps
            pSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
#endif      
            // If you set these you don't see any locks....
            pSurf->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;

            // Remember the new size
            pSurf->lpGbl->dwLinearSize = dwBytes;

            // Mark the buffer as in use and return it
            pCurrentBuffer->dwSequenceID = 0;
            pCurrentBuffer->bInUse = TRUE;
            pCurrentBuffer->pNext = NULL;
            pCurrentBuffer->pPrev = NULL;
            pCurrentBuffer->BufferType = BufferType;
            pCurrentBuffer->dwSize = dwBytes + sizeof(P3_VERTEXBUFFERINFO);    

            DISPDBG((DBGLVL,"Found a re-useable buffer "
                            "- didn't need to reallocate memory"));

            DBG_EXIT(__EB_AllocateCachedBuffer,TRUE);
            return TRUE;
        }
    }

    // do things the longer way...
    // Try to allocate the requested memory
    do
    {
        ZeroMemory(&mmrq, sizeof(P3_MEMREQUEST));
        mmrq.dwSize = sizeof(P3_MEMREQUEST);
        mmrq.dwAlign = 4;   
        mmrq.dwBytes = dwBytes + sizeof(P3_VERTEXBUFFERINFO);
        mmrq.dwFlags = MEM3DL_FIRST_FIT | MEM3DL_FRONT;
        dwResult = _DX_LIN_AllocateLinearMemory(pAllocHeap, &mmrq);
        if (dwResult == GLDD_SUCCESS)
        {
            DISPDBG((DBGLVL,"Allocated a cached buffer"));

            // Pass back a pointer to the memory
            pSurf->lpGbl->fpVidMem = mmrq.pMem + sizeof(P3_VERTEXBUFFERINFO);

            // Store a pointer to the info block at the start of the memory
            pSurf->lpGbl->dwReserved1 = mmrq.pMem;
#if W95_DDRAW
            // Setup the caps
            pSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
#endif
            // If you set these you don't see any locks....
            pSurf->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;

            // Remember the new size
            pSurf->lpGbl->dwLinearSize = dwBytes;

            // Mark the buffer as in use and return it
            pCurrentBuffer = (P3_VERTEXBUFFERINFO*)(ULONG_PTR)mmrq.pMem;
            pCurrentBuffer->dwSequenceID = 0;
            pCurrentBuffer->bInUse = TRUE;
            pCurrentBuffer->pNext = NULL;
            pCurrentBuffer->pPrev = NULL;
            pCurrentBuffer->BufferType = BufferType;
            pCurrentBuffer->dwSize = dwBytes + sizeof(P3_VERTEXBUFFERINFO);
            
            DBG_EXIT(__EB_AllocateCachedBuffer,TRUE);
            return TRUE;
        }
        else
        {
            DISPDBG((DBGLVL,"Failed to allocate cached buffer"));

            // Remember that we haven't found any memory yet.
            // and that there isn't any memory to use.
            bFound = FALSE;
            
            // There are no buffers currently available.  
            // Wait for a new one to be free from the
            // ones that are available and in the queue

            // None at all?  No chance of any memory being free
            // Return FALSE to indicate this.
            if ((*ppRootBuffer) == NULL)
            {
                DISPDBG((DBGLVL,"No buffers in the list!"));
                
                DBG_EXIT(__EB_AllocateCachedBuffer,FALSE);
                return FALSE;
            }

            // Start at the back of the queue, as these are 
            // the least recently used buffers
            pCurrentBuffer = (*ppRootBuffer)->pPrev;
            do
            {
                P3_DMA_DEFS();

                // Ensure that all DMA is completed so that the HostIn
                // ID is up to date
                P3_DMA_GET_BUFFER();
                P3_DMA_FLUSH_BUFFER();

                DISPDBG((DBGLVL,"Searching for old buffers..."));

                // Check to see if this buffer is available to be freed
                // It may not be if it is a buffer that hasn't been swapped out,
                // such as a vertex buffer.

                DISPDBG((DBGLVL,"This buffer ID: 0x%x", 
                                pCurrentBuffer->dwSequenceID));

                if( __EB_GetSequenceID(pThisDisplay) >= 
                            pCurrentBuffer->dwSequenceID )
                {
                    DISPDBG((DBGLVL,"Found a buffer that can be "
                                    "removed from the list"));

                    // It isn't pending any more, so remove it from the queue
                    if (__EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer))
                    {
                        bFound = TRUE;
                        break;
                    }

                    // If the queue is gone, exit (bFound hasn't been
                    // setup because we didn't find any memory in the queue)
                    if ((*ppRootBuffer) == NULL)
                    {
                        break;
                    }

                    // Reset to the last buffer in the chain.  This ensures that
                    // we always look at the least recent buffer
                    pCurrentBuffer = (*ppRootBuffer)->pPrev;
                }
                else
                {
                    // BLOCK!
                    // The buffer we are looking at hasn't become available yet.
                    // We should back off here until it does.

                    blockCount = 100;
                    while( blockCount-- )
                        NULL;

                    DISPDBG((DBGLVL,"Blocked waiting for buffer to be free"));
                }
            } while (pCurrentBuffer != NULL);
        }
        // Loop until we haven't found any more space to allocate buffers into
    } while (bFound);

    DISPDBG((WRNLVL,"!! No available new buffers pending to be freed!!"));
    
    DBG_EXIT(__EB_AllocateCachedBuffer,FALSE);
    return FALSE;
    
} // __EB_AllocateCachedBuffer



//-----------------------------------------------------------------------------
//
// _D3D_EB_FlushAllBuffers
//
// Empties the queue.  Note that this will cause any allocated buffer
// memory to be freed along the way.  This version doesn't wait for the
// buffer to be consumed.  It is used when a context switch has
// occured and we know it is safe to do
//
//-----------------------------------------------------------------------------
void 
_D3D_EB_FlushAllBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    BOOL bWait)
{
    P3_VERTEXBUFFERINFO* pCurrentBuffer;

    DBG_ENTRY(_D3D_EB_FlushAllBuffers);

    // Walk the list of buffers, flushing them from the queue
    while (pThisDisplay->pRootVertexBuffer != NULL)
    {
        pCurrentBuffer = pThisDisplay->pRootVertexBuffer;

        if(bWait)
        {
            // Wait for the buffer to be consumed
            __EB_Wait(pThisDisplay, pCurrentBuffer);
        }
        
        // Remove the buffer from the queue
        __EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer);
    }

    while (pThisDisplay->pRootCommandBuffer != NULL)
    {
        pCurrentBuffer = pThisDisplay->pRootCommandBuffer;

        if(bWait)
        {
            // Wait for the buffer to be consumed
            __EB_Wait(pThisDisplay, pCurrentBuffer);
        }
        
        // Remove the buffer from the queue
        __EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer);
    }

    DBG_EXIT(_D3D_EB_FlushAllBuffers,0);

} // _D3D_EB_FlushAllBuffers

 
//-----------------------------------------------------------------------------
//
// _D3D_EB_GetAndWaitForBuffers
//
//-----------------------------------------------------------------------------
void
_D3D_EB_GetAndWaitForBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO** ppVertexBufferInfo,
    P3_VERTEXBUFFERINFO** ppCommandBufferInfo)
{
    P3_VERTEXBUFFERINFO* pVertexBufferInfo;
    P3_VERTEXBUFFERINFO* pCommandBufferInfo;
    
    pCommandBufferInfo = 
            (P3_VERTEXBUFFERINFO*)pdp2d->lpDDCommands->lpGbl->dwReserved1;

    // Check if vertex buffer resides in user memory or in a DDraw surface
    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pVertexBufferInfo = NULL;
    } 
    else
    {
        // This pointer may be NULL, indicating a buffer passed that isn't 
        // one of ours. That doesn't mean to say that we can't swap in one 
        // of our buffers if there is one available.
        pVertexBufferInfo = 
                (P3_VERTEXBUFFERINFO*)pdp2d->lpDDVertex->lpGbl->dwReserved1;
    }

    // If the vertex buffer is in the queue, wait for it.
    if (pVertexBufferInfo && pVertexBufferInfo->pPrev)
    { 
        // Wait for this buffer if we need to
        __EB_Wait(pThisDisplay, pVertexBufferInfo);

        // Remove this buffer from the queue
        if (__EB_RemoveFromBufferQueue(pThisDisplay, pVertexBufferInfo))
        {
            DISPDBG((ERRLVL,"ERROR: This buffer should not have been freed "
                        "(is in use!)"));
        }
    }
    
    // If the command buffer is in the queue, wait for it.
    if (pCommandBufferInfo && pCommandBufferInfo->pPrev)
    {
        // Wait for this buffer if we need to
        __EB_Wait(pThisDisplay, pCommandBufferInfo);

        // Remove this buffer from the queue
        if (__EB_RemoveFromBufferQueue(pThisDisplay, pCommandBufferInfo))
        {   
            DISPDBG((ERRLVL,"ERROR: This buffer should not have been freed"
                        " (is in use!)"));
        }
    }

    // Return current values of pointers to EB buffers
    *ppCommandBufferInfo = pCommandBufferInfo;
    *ppVertexBufferInfo = pVertexBufferInfo;
} // _D3D_EB_GetAndWaitForBuffers

//-----------------------------------------------------------------------------
//
// _D3D_EB_UpdateSwapBuffers
//
//-----------------------------------------------------------------------------
void
_D3D_EB_UpdateSwapBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO* pVertexBufferInfo,
    P3_VERTEXBUFFERINFO* pCommandBufferInfo)
{
    // Add the buffers to the pending queue.
    // Only do this if the buffers actually belong to us.
    
    // If either of the buffers was sent, update the HOSTIN ID.
    // We need to make the new sequence ID and the update of the hostin
    // 'atomic', or the wraparound will cause a lockup

    if (pVertexBufferInfo)
    {
        P3_DMA_DEFS();

        pVertexBufferInfo->dwSequenceID = 
                            __EB_GetNewSequenceID(pThisDisplay);
                            
        __EB_AddToBufferQueue(pThisDisplay, pVertexBufferInfo);

        P3_DMA_GET_BUFFER_ENTRIES( 2 );

        SEND_P3_DATA(HostInID, pVertexBufferInfo->dwSequenceID);

        P3_DMA_COMMIT_BUFFER();
    }

    if (pCommandBufferInfo)
    {
        P3_DMA_DEFS();

        pCommandBufferInfo->dwSequenceID = 
                            __EB_GetNewSequenceID(pThisDisplay);
                            
        __EB_AddToBufferQueue(pThisDisplay, pCommandBufferInfo);

        P3_DMA_GET_BUFFER_ENTRIES( 2 );

        SEND_P3_DATA(HostInID, pCommandBufferInfo->dwSequenceID);

        P3_DMA_COMMIT_BUFFER();
    }

    if (D3DHALDP2_SWAPVERTEXBUFFER & pdp2d->dwFlags)
    { 
        DWORD dwNewSize = pdp2d->lpDDVertex->lpGbl->dwLinearSize;

        DISPDBG((DBGLVL,"D3DHALDP2_SWAPVERTEXBUFFER..."));
        if (D3DHALDP2_REQVERTEXBUFSIZE & pdp2d->dwFlags)
        {
            DISPDBG((DBGLVL,"D3DHALDP2_REQVERTEXBUFSIZE - %d", 
                       pdp2d->dwReqVertexBufSize));
            if (dwNewSize < pdp2d->dwReqVertexBufSize)
            {
                dwNewSize = pdp2d->dwReqVertexBufSize;
            }
        }

        DISPDBG((DBGLVL,"Current vertex buffer size: %d, "
                        "New size will be: %d",
                        pdp2d->lpDDVertex->lpGbl->dwLinearSize, 
                        dwNewSize));

        // The vertex buffer we just sent off is fixed in place until we 
        // mark it as not in use, which we will after allocating a new 
        // buffer. The following call will try to get a new buffer and 
        // update the surface structure appropriately. Note that it won't 
        // trash the current surface unless the allocation succeeds.
        if (__EB_AllocateCachedBuffer(pThisDisplay, 
                                         dwNewSize, 
                                         pdp2d->lpDDVertex))
        {
            DISPDBG((DBGLVL,"Got a new swap vertex buffer"));

#define STAMP_BUFFER 0
#if STAMP_BUFFER
            {
                DWORD i, *pv;

                pv = (DWORD * ) pdp2d->lpDDVertex->lpGbl->fpVidMem;

                for( i = 0; i < ( dwNewSize / 4 ); i++ )
                {
                    *pv++ = 0x44000000;
                }
            }
#endif

            // Fix up the discarded buffer if required
            if (pVertexBufferInfo)
            {
                // Mark the current buffer as not in use, meaning it can 
                // be freed once it has cleared P3. This might occur the 
                // next time we are here.
                pVertexBufferInfo->bInUse = FALSE;

                // A gotcha!  The buffer we just launched was consumed so 
                // fast that it was freed from the pending list to make 
                // room for it's replacement. This is normally OK, but in 
                // this case the buffer we freed isn't being put back 
                // anywhere - i.e. no surface now owns it, and the memory 
                // associated with it wasn't freed because as far as the 
                // driver is concerned it is still in use until it is 
                // replaced due to the above succesfull call. The 
                // 'solution' is to add it back into the queue if it is 
                // not in it, and make sure that it is marked as not in 
                // use and at a 0 hostin ID.
                if (!pVertexBufferInfo->pPrev)
                {
                    pVertexBufferInfo->dwSequenceID = 0;
                    __EB_AddToBufferQueue(pThisDisplay, 
                                             pVertexBufferInfo);
                }
            }
        }
        else
        {
            // Couldn't swap this buffer, so we have to wait

            DISPDBG((DBGLVL,"Not swapping vertex buffer "
                            "due to lack of space!"));

            __EB_Wait(pThisDisplay, pVertexBufferInfo);
        }
    }
    else
    {
        DISPDBG((DBGLVL,"No vertex buffer swapping..."));
    }

    if (D3DHALDP2_SWAPCOMMANDBUFFER & pdp2d->dwFlags)
    {   
        DWORD dwNewSize = pdp2d->lpDDCommands->lpGbl->dwLinearSize;

        DISPDBG((DBGLVL,"D3DHALDP2_SWAPCOMMANDBUFFER..."));

        if (D3DHALDP2_REQCOMMANDBUFSIZE & pdp2d->dwFlags)
        {
            DISPDBG((DBGLVL,"D3DHALDP2_REQCOMMANDBUFSIZE - %d", 
                       pdp2d->dwReqCommandBufSize));
                       
            if (dwNewSize < pdp2d->dwReqCommandBufSize)
            {
                dwNewSize = pdp2d->dwReqCommandBufSize;
            }
        }

        DISPDBG((DBGLVL,"Current command buffer size: "
                        "%d, New size will be: %d",
                        pdp2d->lpDDCommands->lpGbl->dwLinearSize, 
                        dwNewSize));

        // The command buffer we just sent off is fixed in place until we 
        // mark it as not in use, which we will after allocating a new 
        // buffer. The following call will try to get a new buffer and 
        // update the surface structure appropriately. Note that it won't 
        // trash the current surface unless the allocation succeeds
        if (__EB_AllocateCachedBuffer(pThisDisplay, 
                                         dwNewSize, 
                                         pdp2d->lpDDCommands))
        {
            DISPDBG((DBGLVL,"Got a new swap command buffer"));

            // Fix up the previous command buffer if required.
            if (pCommandBufferInfo)
            {
                // Mark the current buffer as not in use, meaning it can 
                // be freed once it has cleared P3. This might occur the 
                // next time we are here.
                pCommandBufferInfo->bInUse = FALSE;

                // A gotcha!  The buffer we just launched was consumed so 
                // fast that it was freed from the pending list to make 
                // room for it's replacement. This is normally OK, but in 
                // this case the buffer we freed isn't being put back 
                // anywhere - i.e. no surface now owns it, and the memory 
                // associated with it wasn't freed because as far as the 
                // driver is concerned it is still in use until it is 
                // replaced due to the above succesfull call. The 
                // 'solution' is to add it back into the queue if it is 
                // not in it, and make sure that it is marked as not in 
                // use and at a 0 hostin ID.
                if (!pCommandBufferInfo->pPrev)
                {
                    pCommandBufferInfo->dwSequenceID = 0;
                    __EB_AddToBufferQueue(pThisDisplay, 
                                             pCommandBufferInfo);
                }
            }
        }
        else
        {
            // Couldn't swap this buffer, so we have to wait

            DISPDBG((DBGLVL,"Not swapping command buffer "
                            "due to lack of space!"));

            __EB_Wait(pThisDisplay, pCommandBufferInfo);
        }
    }
    else
    {
        DISPDBG((DBGLVL,"No Command buffer swapping..."));
    }
} // _D3D_EB_UpdateSwapBuffers

//-----------------------------Public Routine----------------------------------
//
// D3DCanCreateD3DBuffer
//
// Called by the runtime to ask if a type of vertex/command buffer can
// be created by the driver.  We don't do anything here at present
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DCanCreateD3DBuffer(
    LPDDHAL_CANCREATESURFACEDATA pccsd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(D3DCanCreateD3DBuffer);
    
    GET_THUNKEDDATA(pThisDisplay, pccsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DBGDUMP_DDSURFACEDESC(DBGLVL, pccsd->lpDDSurfaceDesc);

    pccsd->ddRVal = DD_OK;
    
    DBG_CB_EXIT(D3DCanCreateD3DBuffer,pccsd->ddRVal);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DCanCreateD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DCreateD3DBuffer
//
// Called by the runtime to create a vertex buffer.  We try to allocate
// from our cached heap here.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DCreateD3DBuffer(
    LPDDHAL_CREATESURFACEDATA pcsd)
{
    P3_THUNKEDDATA* pThisDisplay;
    LPDDRAWI_DDRAWSURFACE_LCL pSurf;
    LPDDRAWI_DDRAWSURFACE_LCL FAR* ppSList;
    BOOL bHandled = FALSE;
    DWORD i;

    DBG_CB_ENTRY(D3DCreateD3DBuffer);

    GET_THUNKEDDATA(pThisDisplay, pcsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay);

    ppSList = pcsd->lplpSList;
    
    for (i = 0; i < pcsd->dwSCnt; i++)
    {       
        pSurf = ppSList[i];

        // Allocate the size we want
        DISPDBG((DBGLVL,"Surface %d requested is 0x%x big",
                        i, pSurf->lpGbl->dwLinearSize));
        
        DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pSurf);

        pSurf->lpGbl->dwReserved1 = 0;

        // A 32 kB command buffer gives a high probability of being allowed
        // to swap the associated vertex buffer

        if( pSurf->lpGbl->dwLinearSize < _32_KBYTES )
        {
            pSurf->lpGbl->dwLinearSize = _32_KBYTES;
        }

        if (__EB_AllocateCachedBuffer(pThisDisplay, 
                                         pSurf->lpGbl->dwLinearSize, 
                                         pSurf))
        {
            DISPDBG((DBGLVL,"Allocated a new cached buffer for use by D3D"));
            bHandled = TRUE;
        }
        else
        {
            // If we can't find a buffer, the best thing to do is to 
            // punt to D3D and always copy the data into a DMA buffer
            // (because it won't be contiguous). The DP2 call should 
            // check the reserved field before using the HostIn unit
            DISPDBG((ERRLVL,"WARNING: Couldn't find any vertex memory"
                            " in the heap or in the sent list!"));
                            
            pSurf->lpGbl->dwReserved1 = 0;

            bHandled = FALSE;
        }
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    pcsd->ddRVal = DD_OK;
    
    if (bHandled)
    {
        DBG_EXIT(D3DCreateD3DBuffer,DDHAL_DRIVER_HANDLED);
        return DDHAL_DRIVER_HANDLED;
    } 
    else
    {    
        DBG_CB_EXIT(D3DCreateD3DBuffer,DDHAL_DRIVER_NOTHANDLED);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    
} // D3DCreateD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DDestroyD3DBuffer
//
// Called by the runtime to destroy a vertex buffer.  We free the buffer
// from our memory heap and the current queue.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DDestroyD3DBuffer(
    LPDDHAL_DESTROYSURFACEDATA pdd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(D3DDestroyD3DBuffer);

    GET_THUNKEDDATA(pThisDisplay, pdd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay);

    // Debug data
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pdd->lpDDSurface);

    // Free the D3D buffer. If its in use, we will wait for it to be ready.
    __EB_FreeCachedBuffer(pThisDisplay, pdd->lpDDSurface);

#ifdef CHECK_BUFFERS_ARENT_LEFT_AFTER_APPLICATION_SHUTDOWN
    // Flush all the buffers
    // This checks that the queue is OK.  If you don't do this
    // you may see the linear allocator on the 16 bit side complain 
    // that there is freeable memory there.  This is quite alright.
    _D3D_EB_FlushAllBuffers(pThisDisplay , TRUE);
#endif

    START_SOFTWARE_CURSOR(pThisDisplay);

    // We don't handle the call because DDRAW has allocated out of AGP memory
    pdd->ddRVal = DD_OK;

    DBG_CB_EXIT(D3DDestroyD3DBuffer,DDHAL_DRIVER_HANDLED);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DDestroyD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DLockD3DBuffer
//
// Called by the runtime to lock a vertex buffer.  We make sure
// it has been consumed by the queue, then we continue.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DLockD3DBuffer(
    LPDDHAL_LOCKDATA pld)
{
    P3_THUNKEDDATA* pThisDisplay;
    P3_VERTEXBUFFERINFO* pCurrentBuffer;

    DBG_CB_ENTRY(D3DLockD3DBuffer);
    
    GET_THUNKEDDATA(pThisDisplay, pld->lpDD); 

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pld->lpDDSurface);
    
    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay);

    if (pld->bHasRect)
    {
        DISPDBG((ERRLVL,"Trying to lock a rect in a D3D buffer (error):"));
        DISPDBG((ERRLVL,"left:%d, top:%d, right:%d, bottom:%d",
                        pld->rArea.left, pld->rArea.top,
                        pld->rArea.right, pld->rArea.bottom));
        // This is just a debugging aid
        // We will ignore any rects requested and lock the whole buffer
    }

    // If the buffer has a next pointer then it is in the circular list
    // and we need to wait for the chip to finish consuming it.
    pCurrentBuffer = (P3_VERTEXBUFFERINFO*)pld->lpDDSurface->lpGbl->dwReserved1;
    if (pCurrentBuffer)
    {
        // Wait for the buffer to be consumed
        __EB_Wait(pThisDisplay, pCurrentBuffer);

        // Remove it from the queue
        if (__EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer))
        {
            // There was an error removing it from the queue
            DISPDBG((ERRLVL,"ERROR: This buffer should not have been freed"
                        "(its in use!)"));
        }
    }
    else
    {
        DISPDBG((WRNLVL,"Buffer was not allocated by the driver"));
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    // Return the pointer
    pld->lpSurfData = (LPVOID)pld->lpDDSurface->lpGbl->fpVidMem;

    DISPDBG((DBGLVL,"Returning 0x%x for locked buffer address", 
                    pld->lpDDSurface->lpGbl->fpVidMem));
    
    pld->ddRVal = DD_OK;

    DBG_CB_EXIT(D3DLockD3DBuffer,DDHAL_DRIVER_HANDLED);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DLockD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DUnlockD3DBuffer
//
// Called by the runtime to unlock a vertex buffer.  
// 
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DUnlockD3DBuffer(
    LPDDHAL_UNLOCKDATA puld)
{
    DBG_CB_ENTRY(D3DUnlockD3DBuffer);

    // We don't need to do anything special here.

    puld->ddRVal = DD_OK;

    DBG_CB_EXIT(D3DUnlockD3DBuffer,DDHAL_DRIVER_HANDLED);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DUnlockD3DBuffer

#endif // DX7_VERTEXBUFFERS
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dcntxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dcntxt.c
*
* Content: Main context callbacks for D3D
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#if W95_DDRAW
#include <dmemmgr.h>
#endif
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
// ****************************************************************************
// *********************** D3D Context handle management **********************
// ****************************************************************************
//-----------------------------------------------------------------------------
// Here we abstract the managment of context structures. If you wish to modify
// the way these are managed, this is the place to perform the modification
//-----------------------------------------------------------------------------

// Maximum simultaneous number of contexts we can keep track of
#define MAX_CONTEXT_NUM 200

// Since these variables are global they are forced 
// into shared data segment by the build.
P3_D3DCONTEXT*  g_D3DContextSlots[MAX_CONTEXT_NUM] = {NULL};
BOOL g_D3DInitialised = FALSE;

//-----------------------------------------------------------------------------
//
// _D3D_CTX_HandleInitialization
//
// Initialize the handle data structures (array) . Be careful not to initialize
// it twice (between mode changes for example) as this info has to be persistent
//-----------------------------------------------------------------------------
VOID _D3D_CTX_HandleInitialization(VOID)
{
    DWORD i;
    
    // Do only the first time the driver is loaded.
    if (g_D3DInitialised == FALSE)
    {
        // Clear the contexts. Since this is done only once, lets do it right,
        // rather than just clearing with a memset(g_D3DContextSlots,0,size);
        for (i = 0; i < MAX_CONTEXT_NUM; i++)
        {
            g_D3DContextSlots[i] = NULL;
        }        

        // This will assure we only initialize the data once
        g_D3DInitialised = TRUE;
    }
} // _D3D_CTX_HandleInitialization

//-----------------------------------------------------------------------------
// __CTX_NewHandle
//
// Returns a valid context handle number to use in all D3D callbacks and ready
// to be associated with a P3_D3DCONTEXT structure
//-----------------------------------------------------------------------------
DWORD __CTX_NewHandle(VOID)
{
    DWORD dwSlotNum;
    
    // Find an empty slot.
    for (dwSlotNum = 1; dwSlotNum < MAX_CONTEXT_NUM; dwSlotNum++)
    {
        if (g_D3DContextSlots[dwSlotNum] == NULL)
        {
            return dwSlotNum;
        }
    }

    DISPDBG((WRNLVL,"WARN:No empty context slots left"));
    return 0; // no empty slots left, check for this return value!
} // __CTX_NewHandle

//-----------------------------------------------------------------------------
// __CTX_AssocPtrToHandle
//
// Associate a pointer (to a P3_D3DCONTEXT) with this context handle
//-----------------------------------------------------------------------------
VOID __CTX_AssocPtrToHandle(DWORD hHandle,P3_D3DCONTEXT* pContext)
{
    ASSERTDD(hHandle < MAX_CONTEXT_NUM,
             "Accessing g_D3DContextSlots out of bounds");
             
    g_D3DContextSlots[hHandle] = pContext;        
} // __CTX_AssocPtrToHandle


//-----------------------------------------------------------------------------
// _D3D_CTX_HandleToPtr
//
// Returns the pointer associated to this context handle
//-----------------------------------------------------------------------------
P3_D3DCONTEXT* 
_D3D_CTX_HandleToPtr(ULONG_PTR hHandle)
{
    return g_D3DContextSlots[(DWORD)(hHandle)];
} // _D3D_CTX_HandleToPtr

//-----------------------------------------------------------------------------
// __CTX_HandleRelease
//
// This marks the handle number as "free" so it can be reused again when 
// a new D3D context is created
//-----------------------------------------------------------------------------
VOID __CTX_HandleRelease(DWORD hHandle)
{
    ASSERTDD(hHandle < MAX_CONTEXT_NUM,
             "Accessing g_D3DContextSlots out of bounds");
             
    g_D3DContextSlots[hHandle] = NULL;
} // __CTX_HandleRelease

//-----------------------------------------------------------------------------
// ****************************************************************************
// ***********Hardware specific context and state initial setup ***************
// ****************************************************************************
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// __CTX_CleanDirect3DContext
//
// After it has been decided that a context is indeed still active
// and is being freed, this function walks along cleaning everything
// up.  Note it can be called either as a result of a D3DContextDestroy,
// or as a result of the app exiting without freeing the context, or
// as the result of an error whilst creating the context.
// 
//-----------------------------------------------------------------------------
VOID 
__CTX_CleanDirect3DContext(
    P3_D3DCONTEXT* pContext)
{
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    // Free any antialiasing buffer we might have left around in vidmem
    if (pContext->dwAliasBackBuffer != 0)
    {
        _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                 pContext->dwAliasBackBuffer);
        pContext->dwAliasBackBuffer = 0;
        pContext->dwAliasPixelOffset = 0;
    }

    if (pContext->dwAliasZBuffer != 0)
    {
        _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                 pContext->dwAliasZBuffer);
        pContext->dwAliasZBuffer = 0;
        pContext->dwAliasZPixelOffset = 0;
    }
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

//@@BEGIN_DDKSPLIT
#if DX7_VIDMEM_VB
    // Free up the useful DrawPrim buffers.
    // Yes, these are device-global rather than per-context, but that's fine
    // since whenever they are used, a macro checks to see if they are big
    // enough and if not re-allocates them. The data does not need to
    // survive across calls.
    // I'm doing the free here instead of end-of-driver-day because there
    // is no elegant place to do it then.
    if ( (void *)pThisDisplay->DrawPrimIndexBufferMem != NULL )
    {
        ASSERTDD ( pThisDisplay->DrawPrimIndexBufferMemSize > 0, 
                   "** D3DContextDestroy - DrawPrimIndexBufferMemSize "
                   "negative or zero, but memory pointer not NULL" );
        HEAP_FREE ( (void *)pThisDisplay->DrawPrimIndexBufferMem );
        pThisDisplay->DrawPrimIndexBufferMem = (ULONG_PTR)NULL;
        pThisDisplay->DrawPrimIndexBufferMemSize = 0;
    }
    else
    {
        ASSERTDD ( pThisDisplay->DrawPrimIndexBufferMemSize == 0, 
                   "** D3DContextDestroy - DrawPrimIndexBufferMemSize "
                   "not zero, but memory pointer is NULL" );
        pThisDisplay->DrawPrimIndexBufferMemSize = 0;
    }

    if ( (void *)pThisDisplay->DrawPrimVertexBufferMem != NULL )
    {
        ASSERTDD ( pThisDisplay->DrawPrimVertexBufferMemSize > 0, 
                   "** D3DContextDestroy - DrawPrimVertexBufferMemSize "
                   "negative or zero, but memory pointer not NULL" );
        HEAP_FREE ( (void *)pThisDisplay->DrawPrimVertexBufferMem );
        pThisDisplay->DrawPrimVertexBufferMem = (ULONG_PTR)NULL;
        pThisDisplay->DrawPrimVertexBufferMemSize = 0;
    }
    else
    {
        ASSERTDD ( pThisDisplay->DrawPrimVertexBufferMemSize == 0, 
                   "** D3DContextDestroy - DrawPrimVertexBufferMemSize "
                   "not zero, but memory pointer is NULL" );
        pThisDisplay->DrawPrimVertexBufferMemSize = 0;
    }
#endif DX7_VIDMEM_VB    
//@@END_DDKSPLIT

#if DX7_D3DSTATEBLOCKS
    // Free up any remaining state sets
    _D3D_SB_DeleteAllStateSets(pContext);
#endif //DX7_D3DSTATEBLOCKS
    
#if DX7_PALETTETEXTURE
    // Destroy the per context palette pointer array
    if (pContext->pPalettePointerArray) 
    {
        PA_DestroyArray(pContext->pPalettePointerArray, NULL);
    }
#endif
    
} // __CTX_CleanDirect3DContext()



//-----------------------------------------------------------------------------
//
// __CTX_Perm3_DisableUnits
//
// Disables all the mode registers to give us a clean start.
//
//-----------------------------------------------------------------------------
static VOID 
__CTX_Perm3_DisableUnits(
    P3_D3DCONTEXT* pContext)
{
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    P3_DMA_DEFS();

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(128);

    WAIT_FIFO(32);
    SEND_P3_DATA(RasterizerMode,       __PERMEDIA_DISABLE);
    SEND_P3_DATA(AreaStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(LineStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(ScissorMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(DepthMode,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(ColorDDAMode,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(FogMode,              __PERMEDIA_DISABLE);
    SEND_P3_DATA(AntialiasMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaTestMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBReadMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(Window,               __PERMEDIA_DISABLE);
    SEND_P3_DATA(StencilMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBReadMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(PatternRAMMode,       __PERMEDIA_DISABLE);

    WAIT_FIFO(18);
    SEND_P3_DATA(DitherMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaBlendMode,       __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBWriteMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(StatisticMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(PixelSize,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBSourceData,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteFormat,        __PERMEDIA_DISABLE);

    WAIT_FIFO(32);
    

    SEND_P3_DATA(TextureReadMode,   __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCoordMode,  __PERMEDIA_DISABLE);

    SEND_P3_DATA(ChromaTestMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(FilterMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTTransfer,       __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTIndex,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTAddress,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTMode,           __PERMEDIA_DISABLE);

    if (TLCHIP_GAMMA)
    {
        WAIT_FIFO(32);
        SEND_P3_DATA(Light0Mode, 0);
        SEND_P3_DATA(Light1Mode, 0);       
        SEND_P3_DATA(Light2Mode, 0);
        SEND_P3_DATA(Light3Mode, 0);       
        SEND_P3_DATA(Light4Mode, 0);
        SEND_P3_DATA(Light5Mode, 0);       
        SEND_P3_DATA(Light6Mode, 0);
        SEND_P3_DATA(Light7Mode, 0);  
        SEND_P3_DATA(Light8Mode, 0);
        SEND_P3_DATA(Light9Mode, 0);       
        SEND_P3_DATA(Light10Mode, 0);
        SEND_P3_DATA(Light11Mode, 0);  
        SEND_P3_DATA(Light12Mode, 0);
        SEND_P3_DATA(Light13Mode, 0);       
        SEND_P3_DATA(Light14Mode, 0);
        SEND_P3_DATA(Light15Mode, 0);          

        WAIT_FIFO(32);
        SEND_P3_DATA(TransformMode, 0);
        SEND_P3_DATA(MaterialMode, 0);
        SEND_P3_DATA(GeometryMode, 0);
        SEND_P3_DATA(LightingMode, 0);
        SEND_P3_DATA(ColorMaterialMode, 0);
        SEND_P3_DATA(NormaliseMode, 0);
        SEND_P3_DATA(LineMode, 0);
        SEND_P3_DATA(TriangleMode, 0);
    }

    P3_DMA_COMMIT_BUFFER();
} // __CTX_Perm3_DisableUnits

//-----------------------------------------------------------------------------
//
// __CTX_Perm3_SetupD3D_HWDefaults
//
// Sets up the initial value of registers for this D3D context. This is done
// within the current chip context (D3D_OPERATION) so that when we return to
// it from DD or GDI we get the correct register values restored
// 
//-----------------------------------------------------------------------------
void 
__CTX_Perm3_SetupD3D_HWDefaults(
    P3_D3DCONTEXT* pContext)
{
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;

    P3_DMA_DEFS();

    // Make sure we our working within the right chip-regs context
    D3D_OPERATION(pContext, pThisDisplay);

    // Initially turn off all hardware units. 
    // We will turn on back whatever units are needed.
    __CTX_Perm3_DisableUnits(pContext);

    // Set up VertexControl register in HostIn unit.
    pSoftP3RX->P3RX_P3VertexControl.Size = 1;
    pSoftP3RX->P3RX_P3VertexControl.Flat = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.ReadAll = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.SkipFlags = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.CacheEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3VertexControl.OGL = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.Line2D = __PERMEDIA_DISABLE;

    // Constant LBReadMode setup
    pSoftP3RX->LBReadMode.WindowOrigin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;                // Top left
    pSoftP3RX->LBReadMode.DataType = __GLINT_LBDEFAULT;     // default
    pSoftP3RX->LBReadMode.ReadSourceEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->LBReadMode.ReadDestinationEnable = __PERMEDIA_DISABLE;

    // Constant DitherMode setup
    pSoftP3RX->DitherMode.ColorOrder = COLOR_MODE;
    pSoftP3RX->DitherMode.XOffset = DITHER_XOFFSET;
    pSoftP3RX->DitherMode.YOffset = DITHER_YOFFSET;
    pSoftP3RX->DitherMode.UnitEnable = __PERMEDIA_ENABLE;

    // Alpha Blend Mode Setup
    pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = 0;
    pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = 0;
    pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.InvertSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.InvertDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_8888;
    pSoftP3RX->P3RXAlphaBlendColorMode.ColorOrder = COLOR_MODE;
    pSoftP3RX->P3RXAlphaBlendColorMode.ColorConversion = P3RX_ALPHABLENDMODE_CONVERT_SHIFT;
    pSoftP3RX->P3RXAlphaBlendColorMode.ConstantSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.ConstantDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.Operation = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.SwapSD = __PERMEDIA_DISABLE;

    pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = 0;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = 0;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.InvertSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.InvertDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.NoAlphaBuffer = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.AlphaType = 0; // Use GL Blend modes
    pSoftP3RX->P3RXAlphaBlendAlphaMode.AlphaConversion = P3RX_ALPHABLENDMODE_CONVERT_SCALE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.ConstantSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.ConstantDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.Operation = __PERMEDIA_DISABLE;
    DIRTY_ALPHABLEND(pContext);
    
    // Local Buffer Read format bits that don't change
    pSoftP3RX->P3RXLBReadFormat.GIDPosition = 0; 
    pSoftP3RX->P3RXLBReadFormat.GIDWidth = 0;                   // No GID
    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0;
    pSoftP3RX->P3RXLBReadFormat.StencilWidth = 0;               // No Stencil

    pSoftP3RX->P3RXLBWriteFormat.GIDPosition = 0; 
    pSoftP3RX->P3RXLBWriteFormat.GIDWidth = 0;                  // No GID
    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0;
    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = 0;              // No Stencil

    // Never do a source read operation
    pSoftP3RX->P3RXLBSourceReadMode.Enable = 0;
    pSoftP3RX->P3RXLBSourceReadMode.Origin = 0;
    pSoftP3RX->P3RXLBSourceReadMode.StripeHeight = 0;
    pSoftP3RX->P3RXLBSourceReadMode.StripePitch = 0;
    pSoftP3RX->P3RXLBSourceReadMode.PrefetchEnable = 0;

    // Default is to read the Z Buffer
    pSoftP3RX->P3RXLBDestReadMode.Enable = 1;
    pSoftP3RX->P3RXLBDestReadMode.Origin = 0;
    pSoftP3RX->P3RXLBDestReadMode.StripeHeight = 0;
    pSoftP3RX->P3RXLBDestReadMode.StripePitch = 0;
    pSoftP3RX->P3RXLBDestReadMode.PrefetchEnable = 0;

    // Local Buffer Write mode
    pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;    // Initially allow LB Writes
    pSoftP3RX->P3RXLBWriteMode.StripeHeight = 0;
    pSoftP3RX->P3RXLBWriteMode.StripePitch = 0;
    pSoftP3RX->P3RXLBWriteMode.Origin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;
    pSoftP3RX->P3RXLBWriteMode.Operation = __PERMEDIA_DISABLE;

    // Frame Buffer WriteMode
    pSoftP3RX->P3RXFBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXFBWriteMode.Replicate = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFBWriteMode.OpaqueSpan = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFBWriteMode.StripePitch = P3RX_STRIPE_1;
    pSoftP3RX->P3RXFBWriteMode.StripeHeight = P3RX_STRIPE_1;
    pSoftP3RX->P3RXFBWriteMode.Enable0 = __PERMEDIA_ENABLE;

    // FB Destination reads
    pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFBDestReadMode.Enable0 = __PERMEDIA_ENABLE;

    // FB Source reads
    pSoftP3RX->P3RXFBSourceReadMode.ReadEnable = __PERMEDIA_DISABLE;

    // Depth comparisons
    pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXDepthMode.CompareMode = __GLINT_DEPTH_COMPARE_MODE_ALWAYS;
    pSoftP3RX->P3RXDepthMode.NewDepthSource = __GLINT_DEPTH_SOURCE_DDA;
    pSoftP3RX->P3RXDepthMode.Enable = __PERMEDIA_DISABLE;

#define NLZ 0
#if NLZ
    pSoftP3RX->P3RXDepthMode.Normalise = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXDepthMode.NonLinearZ = __PERMEDIA_ENABLE;
#else
    pSoftP3RX->P3RXDepthMode.Normalise = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXDepthMode.NonLinearZ = __PERMEDIA_DISABLE;
#endif
    pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
    pSoftP3RX->P3RXDepthMode.ExponentWidth = 1;

    // Only setup to write to the chip after the above call, as 
    // we may upset the DMA buffer setup.
    P3_DMA_GET_BUFFER_ENTRIES(20);

    // Window Region data
    SEND_P3_DATA(FBSourceOffset, 0x0);

    // Write Masks
    SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
    SEND_P3_DATA(FBHardwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);

    // Host out unit
    SEND_P3_DATA(FilterMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(StatisticMode, __PERMEDIA_DISABLE);   // Disable Stats

    // Local Buffer
    SEND_P3_DATA(LBSourceOffset, 0);                   

    // Window setups
    SEND_P3_DATA(WindowOrigin, __GLINT_TOP_LEFT_WINDOW_ORIGIN);
    SEND_P3_DATA(FBWindowBase, 0x0);

    SEND_P3_DATA(RasterizerMode, 0);

    // Setup a step of -1, as this doesn't change very much
    SEND_P3_DATA(dY, 0xFFFF0000);

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(16);

    // Stencil mode setup
    pSoftP3RX->P3RXStencilMode.StencilWidth = 0;
    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_KEEP;
    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_KEEP;
    pSoftP3RX->P3RXStencilMode.Enable = __PERMEDIA_DISABLE;
    COPY_P3_DATA(StencilMode, pSoftP3RX->P3RXStencilMode);

    pSoftP3RX->P3RXFogMode.Enable = __PERMEDIA_ENABLE; // Qualified by the render command
    pSoftP3RX->P3RXFogMode.ColorMode = P3RX_FOGMODE_COLORMODE_RGB; // RGBA
    pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFogMode.ZShift = 23; // Take the top 8 bits of the z value
    pSoftP3RX->P3RXFogMode.InvertFI = __PERMEDIA_DISABLE;
    DIRTY_FOG(pContext);

    pSoftP3RX->P3RXWindow.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXWindow.CompareMode = 0;
    pSoftP3RX->P3RXWindow.ForceLBUpdate = 0;
    pSoftP3RX->P3RXWindow.LBUpdateSource = 0;
    pSoftP3RX->P3RXWindow.GID = 0;
    pSoftP3RX->P3RXWindow.FrameCount = 0;
    pSoftP3RX->P3RXWindow.StencilFCP = 0;
    pSoftP3RX->P3RXWindow.DepthFCP = 0;
    COPY_P3_DATA(Window, pSoftP3RX->P3RXWindow);

    SEND_P3_DATA(ChromaUpper, 0x00000000);
    SEND_P3_DATA(ChromaLower, 0x00000000);

    // Use a black border for the bilinear filter.
    // This will only work for certain types of texture...
    SEND_P3_DATA(BorderColor0, 0x0);
    SEND_P3_DATA(BorderColor1, 0x0);

    // Alpha Test - later we'll DIRTY_EVERYTHING
    pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaTestMode.Reference = 0x0;
    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_ALWAYS;

    SEND_P3_DATA(AreaStippleMode, (1 | (2 << 1) | (2 << 4)));

    pSoftP3RX->P3RX_P3DeltaMode.TargetChip = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.SpecularTextureEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.TextureParameterMode = 2; // Normalise
    pSoftP3RX->P3RX_P3DeltaMode.TextureEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DiffuseTextureEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaMode.SmoothShadingEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.SubPixelCorrectionEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DiamondExit = __PERMEDIA_ENABLE;

#if 1
    pSoftP3RX->P3RX_P3DeltaMode.NoDraw = __PERMEDIA_DISABLE;
#else
    pSoftP3RX->P3RX_P3DeltaMode.NoDraw = __PERMEDIA_ENABLE;
#endif

    pSoftP3RX->P3RX_P3DeltaMode.ClampEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.FillDirection = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DepthFormat = 3;    // Always 32 bits
    pSoftP3RX->P3RX_P3DeltaMode.ColorOrder = COLOR_MODE;
    pSoftP3RX->P3RX_P3DeltaMode.BiasCoordinates = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.Texture3DEnable = __PERMEDIA_DISABLE; // Always perspective correct (q is 1 otherwise)
    pSoftP3RX->P3RX_P3DeltaMode.TextureEnable1 = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DepthEnable = __PERMEDIA_ENABLE;
    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(18);
    
    {
        float ZBias;
            
        pContext->XBias = 0.5f;
        pContext->YBias = 0.5f;

        ZBias = 0.0f;
        SEND_P3_DATA(XBias, *(DWORD*)&pContext->XBias);
        SEND_P3_DATA(YBias, *(DWORD*)&pContext->YBias);
        SEND_P3_DATA(ZBias, *(DWORD*)&ZBias);
    }

    pSoftP3RX->P3RX_P3DeltaControl.FullScreenAA = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaControl.DrawLineEndPoint = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaControl.UseProvokingVertex = __PERMEDIA_DISABLE;
    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
    
    pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXTextureCoordMode.WrapS = __GLINT_TEXADDRESS_WRAP_REPEAT;
    pSoftP3RX->P3RXTextureCoordMode.WrapT = __GLINT_TEXADDRESS_WRAP_REPEAT;
    pSoftP3RX->P3RXTextureCoordMode.Operation = __GLINT_TEXADDRESS_OPERATION_3D; // Perspective correct
    pSoftP3RX->P3RXTextureCoordMode.InhibitDDAInitialisation = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureCoordMode.TextureMapType = __GLINT_TEXADDRESS_TEXMAP_2D;  // Always 2D
    pSoftP3RX->P3RXTextureCoordMode.DuplicateCoord = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);

    pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.Width = log2(256);
    pSoftP3RX->P3RXTextureReadMode0.Height = log2(256);
    pSoftP3RX->P3RXTextureReadMode0.TexelSize = P3RX_TEXREADMODE_TEXELSIZE_16;  // Pixel depth
    pSoftP3RX->P3RXTextureReadMode0.Texture3D = __PERMEDIA_DISABLE;    // 3D Texture coordinates
    pSoftP3RX->P3RXTextureReadMode0.CombineCaches = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.MapBaseLevel = 0;
    pSoftP3RX->P3RXTextureReadMode0.MapMaxLevel = 0;
    pSoftP3RX->P3RXTextureReadMode0.LogicalTexture = 0;
    pSoftP3RX->P3RXTextureReadMode0.Origin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;
    pSoftP3RX->P3RXTextureReadMode0.TextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
    pSoftP3RX->P3RXTextureReadMode0.ByteSwap = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.Mirror = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.Invert = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.OpaqueSpan = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);

    pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.Width = log2(256);
    pSoftP3RX->P3RXTextureReadMode1.Height = log2(256);
    pSoftP3RX->P3RXTextureReadMode1.TexelSize = P3RX_TEXREADMODE_TEXELSIZE_16;  // Pixel depth
    pSoftP3RX->P3RXTextureReadMode1.Texture3D = __PERMEDIA_DISABLE;    // 3D Texture coordinates
    pSoftP3RX->P3RXTextureReadMode1.CombineCaches = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.MapBaseLevel = 0;
    pSoftP3RX->P3RXTextureReadMode1.MapMaxLevel = 0;
    pSoftP3RX->P3RXTextureReadMode1.LogicalTexture = 0;
    pSoftP3RX->P3RXTextureReadMode1.Origin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;
    pSoftP3RX->P3RXTextureReadMode1.TextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
    pSoftP3RX->P3RXTextureReadMode1.ByteSwap = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.Mirror = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.Invert = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.OpaqueSpan = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);

    pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.Width = log2(256);
    pSoftP3RX->P3RXTextureIndexMode0.Height = log2(256);
    pSoftP3RX->P3RXTextureIndexMode0.Border = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.WrapU = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode0.WrapV = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode0.MapType = __GLINT_TEXADDRESS_TEXMAP_2D;
    pSoftP3RX->P3RXTextureIndexMode0.MagnificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode0.Texture3DEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.MipMapEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.NearestBias = 1;
    pSoftP3RX->P3RXTextureIndexMode0.LinearBias = 0;
    pSoftP3RX->P3RXTextureIndexMode0.SourceTexelEnable = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);

    pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.Width = log2(256);
    pSoftP3RX->P3RXTextureIndexMode1.Height = log2(256);
    pSoftP3RX->P3RXTextureIndexMode1.Border = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.WrapU = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode1.WrapV = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode1.MapType = __GLINT_TEXADDRESS_TEXMAP_2D;
    pSoftP3RX->P3RXTextureIndexMode1.MagnificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode1.Texture3DEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.MipMapEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.NearestBias = 1;
    pSoftP3RX->P3RXTextureIndexMode1.LinearBias = 0;
    pSoftP3RX->P3RXTextureIndexMode1.SourceTexelEnable = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

    pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = 1;

    pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeColorMode1.Scale = 1;

    pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = 1;

    pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeAlphaMode1.Scale = 1;

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(16);
    
    COPY_P3_DATA(TextureCompositeColorMode0, pSoftP3RX->P3RXTextureCompositeColorMode0);
    COPY_P3_DATA(TextureCompositeColorMode1, pSoftP3RX->P3RXTextureCompositeColorMode1);
    COPY_P3_DATA(TextureCompositeAlphaMode0, pSoftP3RX->P3RXTextureCompositeAlphaMode0);
    COPY_P3_DATA(TextureCompositeAlphaMode1, pSoftP3RX->P3RXTextureCompositeAlphaMode1);

    // Set up the TC TFACTOR defaults.
    SEND_P3_DATA(TextureCompositeFactor0, 0);
    SEND_P3_DATA(TextureCompositeFactor1, 0);

    SEND_P3_DATA(TextureCacheReplacementMode, 0 );

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(24);
    
    // Used for 3D Texture-maps
    SEND_P3_DATA(TextureMapSize, 0);

    SEND_P3_DATA(TextureLODBiasS, 0);
    SEND_P3_DATA(TextureLODBiasT, 0);

    {
        float f = 1.0f;
        COPY_P3_DATA(TextureLODScale, f);
        COPY_P3_DATA(TextureLODScale1, f);
    }    

    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);
    
    pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.EnableKd = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.MotionCompEnable = __PERMEDIA_DISABLE;
    
    // Put the texture application unit in pass-through
    pSoftP3RX->P3RXTextureApplicationMode.ColorA = 0;
    pSoftP3RX->P3RXTextureApplicationMode.ColorB = P3RX_TEXAPP_B_TC;
    pSoftP3RX->P3RXTextureApplicationMode.ColorI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.ColorInvertI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_PASS_B;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaA = 0;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaB = P3RX_TEXAPP_B_TA;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaInvertI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_B;
    COPY_P3_DATA(TextureApplicationMode, pSoftP3RX->P3RXTextureApplicationMode);

    // Set up the TA TFACTOR default.
    SEND_P3_DATA(TextureEnvColor, 0);
        
    // Turn on texture cache and invalidate it.
    SEND_P3_DATA(TextureCacheControl, 3);
        
    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(16);

    //pGlint->TextureMask = 0;
    SEND_P3_DATA(TextureBaseAddr0, 0);
    SEND_P3_DATA(TextureBaseAddr1, 0);

    pSoftP3RX->P3RXChromaTestMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXChromaTestMode.Source = __GLINT_CHROMA_FBSOURCE ;
    COPY_P3_DATA(ChromaTestMode, pSoftP3RX->P3RXChromaTestMode);

    pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXTextureFilterMode.Format0 = 0;
    pSoftP3RX->P3RXTextureFilterMode.ColorOrder0 = COLOR_MODE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable0 = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense0 = __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE;
    pSoftP3RX->P3RXTextureFilterMode.CombineCaches = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureFilterMode.Format1 = 0;
    pSoftP3RX->P3RXTextureFilterMode.ColorOrder1 = COLOR_MODE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable1 = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense1 = __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE;
    COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);

    pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXLUTMode.InColorOrder = P3RX_LUTMODE_INCOLORORDER_BGR;
    pSoftP3RX->P3RXLUTMode.LoadFormat = P3RX_LUTMODE_LOADFORMAT_COPY;
    pSoftP3RX->P3RXLUTMode.LoadColorOrder = P3RX_LUTMODE_LOADCOLORORDER_RGB;
    pSoftP3RX->P3RXLUTMode.FragmentOperation = P3RX_LUTMODE_FRAGMENTOP_INDEXEDTEXTURE;
    COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

    pSoftP3RX->P3RXRasterizerMode.D3DRules = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXRasterizerMode.MultiRXBlit = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.OpaqueSpan = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.WordPacking = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.StripeHeight = 0;
    pSoftP3RX->P3RXRasterizerMode.BitMaskRelative = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.YLimitsEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.MultiGLINT = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXRasterizerMode.HostDataByteSwapMode = 0;
    pSoftP3RX->P3RXRasterizerMode.BitMaskOffset = 0;
    pSoftP3RX->P3RXRasterizerMode.BitMaskPacking = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.BitMaskByteSwapMode = 0;
    pSoftP3RX->P3RXRasterizerMode.ForceBackgroundColor = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.BiasCoordinates = 0;
    pSoftP3RX->P3RXRasterizerMode.FractionAdjust = 0;
    pSoftP3RX->P3RXRasterizerMode.InvertBitMask = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.MirrorBitMask = __PERMEDIA_DISABLE;
    COPY_P3_DATA(RasterizerMode, pSoftP3RX->P3RXRasterizerMode);

    pSoftP3RX->P3RXScanlineOwnership.Mask = 0;
    pSoftP3RX->P3RXScanlineOwnership.MyId = 0;
    COPY_P3_DATA(ScanlineOwnership, pSoftP3RX->P3RXScanlineOwnership);
         
    P3_DMA_COMMIT_BUFFER();
    
} // __CTX_Perm3_SetupD3D_HWDefaults


//-----------------------------------------------------------------------------
//
// __CTX_SetupD3DContext_Defaults
//
// Initializes our private D3D context data (renderstates, TSS and other).
// 
//-----------------------------------------------------------------------------
void
__CTX_SetupD3DContext_Defaults(
    P3_D3DCONTEXT* pContext)
{   
    DWORD dwStageNum;
    
    // Set all the stages to 'unused' and disabled
    for (dwStageNum = 0; dwStageNum < D3DHAL_TSS_MAXSTAGES; dwStageNum++)
    {
        pContext->iTexStage[dwStageNum] = -1;
        pContext->TextureStageState[dwStageNum].m_dwVal[D3DTSS_COLOROP] =
                                                                D3DTOP_DISABLE;
    }
        
    // No texture at present. 
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_COLOROP] = D3DTOP_DISABLE;
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_ALPHAOP] = D3DTOP_DISABLE;

    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_TEXTUREMAP] = 0;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_TEXTUREMAP] = 0;

    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MIPFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MAGFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MAGFILTER] = D3DTFN_POINT;

    pContext->eChipBlendStatus = BSF_UNINITIALISED;
    
    // Initially set values to force change of texture
    pContext->bTextureValid = TRUE;
    
    // Defaults states
    pContext->RenderStates[D3DRENDERSTATE_TEXTUREMAPBLEND] = D3DTBLEND_COPY;
    pContext->fRenderStates[D3DRENDERSTATE_FOGTABLESTART] = 0.0f;
    pContext->fRenderStates[D3DRENDERSTATE_FOGTABLEEND] = 1.0f;
    pContext->RenderStates[D3DRENDERSTATE_CULLMODE] = D3DCULL_CCW;
    pContext->RenderStates[D3DRENDERSTATE_PLANEMASK] = 0xFFFFFFFF;
    pContext->RenderStates[D3DRENDERSTATE_LOCALVIEWER] = FALSE;
    pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE] = FALSE;    
    
#if DX8_DDI
    // New DX8 D3DRS_COLORWRITEENABLE default = allow write to all channels
    pContext->dwColorWriteHWMask = 0xFFFFFFFF;
    pContext->dwColorWriteSWMask = 0xFFFFFFFF;    
#endif //DX8_DDI  

    // On context creation, no render states are overridden (for legacy intfce's)
    STATESET_INIT(pContext->overrides); 

    // Set default culling state
    SET_CULLING_TO_CCW(pContext);

#if DX7_D3DSTATEBLOCKS
    // Default state block recording mode = no recording
    pContext->bStateRecMode = FALSE;
    pContext->pCurrSS = NULL;
    pContext->pIndexTableSS = NULL;
    pContext->dwMaxSSIndex = 0;
#endif //DX7_D3DSTATEBLOCKS


#if DX8_POINTSPRITES
    // Point sprite defaults
    pContext->PntSprite.bEnabled = FALSE; 
    pContext->PntSprite.fSize = 1.0f;
    pContext->PntSprite.fSizeMin = 1.0f;    
    pContext->PntSprite.fSizeMax = P3_MAX_POINTSPRITE_SIZE;    
#endif //DX8_POINTSPRITES

    // Multistreaming default setup
    pContext->lpVertices = NULL;
    pContext->dwVertexType = 0;
#if DX8_DDI
    pContext->lpIndices = NULL;
    pContext->dwIndicesStride = 0;    
    pContext->dwVerticesStride = 0;
#endif // DX8_DDI    

    //*********************************
    // INTERNAL CONTEXT RENDERING STATE
    //*********************************

    pContext->bKeptStipple  = FALSE;     // By default, stippling off.
    pContext->bCanChromaKey = FALSE;     // Turn Chroma keying off by default

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    pContext->dwAliasPixelOffset = 0x0;
    pContext->dwAliasZPixelOffset = 0x0;
    pContext->dwAliasZBuffer = 0x0;
    pContext->dwAliasBackBuffer = 0x0;
#if DX8_DDI
    if (pContext->pSurfRenderInt->dwSampling)
    {
        pContext->RenderStates[D3DRS_MULTISAMPLEANTIALIAS] = TRUE;
        pContext->Flags |= SURFACE_ANTIALIAS;
    }
#endif
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS    
 
    // Set texturing on
    pContext->Flags |= SURFACE_TEXTURING; 

    // Initialize the mipmap bias
    pContext->MipMapLODBias[0] = 0.0f;
    pContext->MipMapLODBias[1] = 0.0f;

    // Initialise the RenderCommand.  States will add to this
    pContext->RenderCommand = 0;
    RENDER_SUB_PIXEL_CORRECTION_ENABLE(pContext->RenderCommand);

    // Dirty all states
    DIRTY_EVERYTHING(pContext);

} // __CTX_SetupD3DContext_Defaults

//-----------------------------------------------------------------------------
// ****************************************************************************
// ***************************** D3D HAL Callbacks ****************************
// ****************************************************************************
//-----------------------------------------------------------------------------

//-----------------------------Public Routine----------------------------------
//
// D3DContextCreate
//
// The ContextCreate callback is invoked when a new Direct3D device is being 
// created by a Direct3D application. The driver is required to generate a 
// unique context id for this new context. Direct3D will then use this context 
// id in every subsequent callback invocation for this Direct3D device. 
//
// Context is the current rasterization state. For instance, if there are 3 
// applications running, each will have a different state at any point in time.
// When each one is running, the hardware has to make sure that the context, 
// (whether doing Gouraud shading, for example) is the same as the last time 
// that application got a time slice. 
//
// State is anything that the particular device needs to know per context 
// i.e. what surface is being rendered to, shading, texture, texture handles, 
// what physical surfaces those texture handles represent, etc. The context 
// encapsulates all state for the Direct3D device - state is not shared 
// between contexts. Therefore the driver needs to maintain full state 
// information for each context. This state will be changed by calls to the 
// RenderState callback. In the case of rasterization only hardware, the 
// driver need only maintain rasterization state. As well as state, the driver 
// will also want to store the lpDDS, lpDDSZ, and dwPid from the callback 
// data argument. 
//
// The driver should not create a context handle of zero. This is guaranteed 
// to be an invalid context handle. 
//
// Parameters
//      pccd
//           Pointer to a structure containing things including the current
//           rendering surface, the current Z surface, and the DirectX object
//           handle, etc.
//
//          .lpDDGbl    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDLcl(replaces lpDDGbl in DX7)    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDS      
//                This is the surface that is to be used as the rendering 
//                target, i.e., the 3D accelerator sprays its bits at this 
//                surface. 
//          .lpDDSZ     
//                The surface that is to be used as the Z buffer. If this 
//                is NULL, no Z buffering is to be performed. 
//          .dwPid      
//                The process id of the Direct3D application that initiated 
//                the creation of the Direct3D device. 
//          .dwhContext 
//                The driver should place the context ID that it wants Direct3D 
//                to use when communicating with the driver. This should be 
//                unique. 
//          .ddrval     
//                Return code. DD_OK indicates success. 
//
// Return Value
//      Returns one of the following values: 
//                DDHAL_DRIVER_HANDLED  
//                DDHAL_DRIVER_NOTHANDLED   
//
// Notes:
//
// Currently the context isn't locked, so we can't switch in a register context.
// All chip specific setup is therefore saved for the first execute.
// This is guaranteed to have the lock.
// Some chip state is duplicated in the context structure.  This 
// means that a software copy is kept to stop unnecessary changes to 
// the chip state.
// 
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DContextCreate(
    LPD3DHAL_CONTEXTCREATEDATA pccd)
{
    LPDDRAWI_DDRAWSURFACE_LCL lpLclFrame = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL lpLclZ = NULL;
    P3_D3DCONTEXT *pContext;
    P3_THUNKEDDATA *pThisDisplay;
    DWORD Result;
    DWORD dwSlotNum;
    ULONG_PTR dwDXInterface;
    BOOL bRet;

    DBG_CB_ENTRY(D3DContextCreate);

    // Get our pThisDisplay
    GET_THUNKEDDATA(pThisDisplay, pccd->lpDDLcl->lpGbl);

    //***********************************************************************
    // Create a new D3D context driver structure and asssociate an id with it
    //***********************************************************************

    // Find a context empty slot.
    dwSlotNum = __CTX_NewHandle();

    if (dwSlotNum == 0)
    {
        // no context slots left
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        DBG_CB_EXIT(D3DContextCreate,pccd->ddrval);        
        return (DDHAL_DRIVER_HANDLED);
    }

    // Return to the runtime the D3D context id that will be used to
    // identify calls for this context from now on. Store prev value
    // since that tells us which API are we being called from
    // (4=DX8, 3=DX7, 2=DX6, 1=DX5, 0=DX3)
    dwDXInterface = pccd->dwhContext;      // in: DX API version
    pccd->dwhContext = dwSlotNum;          // out: Context handle 

    // Now allocate the driver's d3d context structure in kernel memory.  
    pContext = (P3_D3DCONTEXT*)HEAP_ALLOC(FL_ZERO_MEMORY, 
                                          sizeof(P3_D3DCONTEXT), 
                                          ALLOC_TAG_DX(1));
    
    if (pContext == NULL)
    {
        DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem"));
        goto Error_OutOfMem_A;
    }
    else
    {
        DISPDBG((DBGLVL,"Allocated Context Mem - proceeding to clear"));
        memset((void *)pContext, 0, sizeof(P3_D3DCONTEXT));
    }   

    // This context id is now to be associated with this context pointer
    __CTX_AssocPtrToHandle(dwSlotNum, pContext);    

    //*************************************************************************
    //                  Initialize the D3D context structure
    //*************************************************************************

    //*******
    // HEADER
    //*******
    
    // Set up the magic number to perform sanity checks
    pContext->MagicNo = RC_MAGIC_NO;       
    
    // Record the usage of this context handle    
    pContext->dwContextHandle = dwSlotNum;

    // Keep (self) pointers to the structure for destroy time
    pContext->pSelf = pContext;

#if DX8_DDI
    // Remember which DX interface is creating this context 
    // - it will make things much easier later
    pContext->dwDXInterface = dwDXInterface;
#endif // DX8_DDI     

    //**********************
    // GLOBAL DRIVER CONTEXT
    //**********************

    // Remember the card we are running on
    pContext->pThisDisplay = pThisDisplay;

    // On DX7 we need to keep a copy of the local ddraw object
    // for surface handle management
    pContext->pDDLcl = pccd->lpDDLcl;
    pContext->pDDGbl = pccd->lpDDLcl->lpGbl;

    //*******************
    // RENDERING SURFACES
    //*******************

    // On DX7 we extract the local surface pointers directly
    lpLclFrame = pccd->lpDDSLcl;
    
    if (pccd->lpDDSZ)
    {
        lpLclZ = pccd->lpDDSZLcl;
    }

#if DBG
    // Spew debug rendering surfaces data on the debug build
    DISPDBG((DBGLVL,"Allocated Direct3D context: 0x%x",pccd->dwhContext));    
    DISPDBG((DBGLVL,"Driver Struct = %p, Surface = %p",
                    pContext->pDDGbl, lpLclFrame));
    DISPDBG((DBGLVL,"Z Surface = %p",lpLclZ));
    
    if ((DWORD*)lpLclZ != NULL)
    {
        DISPDBG((DBGLVL,"    ZlpGbl: %p", lpLclZ->lpGbl));

        DISPDBG((DBGLVL,"    fpVidMem = %08lx",lpLclZ->lpGbl->fpVidMem));
        DISPDBG((DBGLVL,"    lPitch = %08lx",lpLclZ->lpGbl->lPitch));
        DISPDBG((DBGLVL,"    wHeight = %08lx",lpLclZ->lpGbl->wHeight));
        DISPDBG((DBGLVL,"    wWidth = %08lx",lpLclZ->lpGbl->wWidth));
    }

    DISPDBG((DBGLVL,"Buffer Surface = %p",lpLclFrame));
    if ((DWORD*)lpLclFrame != NULL)
    {
        DISPDBG((DBGLVL,"    fpVidMem = %08lx",lpLclFrame->lpGbl->fpVidMem));
        DISPDBG((DBGLVL,"    lPitch = %08lx",lpLclFrame->lpGbl->lPitch));
        DISPDBG((DBGLVL,"    wHeight = %08lx",lpLclFrame->lpGbl->wHeight));
        DISPDBG((DBGLVL,"    wWidth = %08lx",lpLclFrame->lpGbl->wWidth));
    }
#endif // DBG

#if DX7_TEXMANAGEMENT
    // Initialize texture management for this context
    if(FAILED(_D3D_TM_Ctx_Initialize(pContext)))
    {
        // We failed. Cleanup before we leave
        DISPDBG((ERRLVL,"ERROR: Couldn't initialize Texture Management"));
        goto Error_OutOfMem_B;        
    }
#endif // DX7_TEXMANAGEMENT

    // There may not have been any textures (DD surfaces) created yet through
    // D3DCreateSurfaceEx.  If this is the  case, create a new DD locals hash 
    // entry and fill it will a pointer array
    pContext->pTexturePointerArray = 
            (PointerArray*)HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable, 
                                       (ULONG_PTR)pContext->pDDLcl);
    if (!pContext->pTexturePointerArray)
    {
        DISPDBG((DBGLVL,"Creating new pointer array for PDDLcl "
                        "0x%x in ContextCreate", pContext->pDDLcl));

        // Create a pointer array
        pContext->pTexturePointerArray = PA_CreateArray();

        if (!pContext->pTexturePointerArray)
        {
            // We ran out of memory. Cleanup before we leave
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem "
                            "for pTexturePointerArray"));
            goto Error_OutOfMem_B;            
        }
        
        // It is an array of surfaces, so set the destroy callback
        PA_SetDataDestroyCallback(pContext->pTexturePointerArray, 
                                  _D3D_SU_SurfaceArrayDestroyCallback);

        // Add this DD local to the hash table, and 
        // store the texture pointer array
        if(!HT_AddEntry(pThisDisplay->pDirectDrawLocalsHashTable, 
                        (ULONG_PTR)pContext->pDDLcl, 
                        pContext->pTexturePointerArray))
        {
            // failed to add entry, noe cleanup and exit
            // We ran out of memory. Cleanup before we leave
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem"));
            goto Error_OutOfMem_C;                     
        }
    }

    // Record the internal surface information
    pContext->pSurfRenderInt = 
                GetSurfaceFromHandle(pContext, 
                                     lpLclFrame->lpSurfMore->dwSurfaceHandle);

    if ( NULL == pContext->pSurfRenderInt)
    {
        // We ran out of memory when allocating for the rendertarget. 
        // Cleanup before we leave
        DISPDBG((ERRLVL,"ERROR: Couldn't allocate pSurfRenderInt mem"));
        goto Error_OutOfMem_D;            
    }
    
    if (lpLclZ) 
    {
        pContext->pSurfZBufferInt = 
                    GetSurfaceFromHandle(pContext,
                                         lpLclZ->lpSurfMore->dwSurfaceHandle);
                                         
        if ( NULL == pContext->pSurfZBufferInt)
        {
            // We ran out of memory when allocating for the depth buffer. 
            // Cleanup before we leave
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate pSurfZBufferInt mem"));   
            goto Error_OutOfMem_D;              
        }                                         
    }
    else 
    {
        pContext->pSurfZBufferInt = NULL;
    }    

    pContext->ModeChangeCount = pThisDisplay->ModeChangeCount;


    //******************
    // DEBUG USEFUL INFO
    //******************

    // Store the process id in which this d3d context was created 
    pContext->OwningProcess = pccd->dwPID;

    // Depth of the primary surface
    pContext->BPP = pContext->pThisDisplay->ddpfDisplay.dwRGBBitCount >> 3;
         
    //******************************
    // HW STATE FOR THIS D3D CONTEXT
    //******************************
    
    // Did we setup a DMA buffer at start of day, or FIFO's?
    if (pThisDisplay->DMAInfo.dwBuffSize == 0)
    {
        DISPDBG((WRNLVL, "No DMA buffer available - using FIFO's for 3D"));
        pContext->b3D_FIFOS = TRUE;
    }
    else
    {
        DISPDBG((WRNLVL, "Using shared DMA buffer"));    
        pContext->b3D_FIFOS = FALSE;        
    }

    //************************************
    // DEFAULT D3D OVERALL RENDERING STATE
    //************************************

    __CTX_SetupD3DContext_Defaults(pContext);
    
    //*************************************************************************
    //         ACTUALLY SETUP HARDWARE IN ORDER TO USE THIS D3D CONTEXT
    //*************************************************************************
 
    STOP_SOFTWARE_CURSOR(pThisDisplay);    

    // Setup default states values to the chip
    __CTX_Perm3_SetupD3D_HWDefaults(pContext);
    

    // Find out info for screen size and depth
    DISPDBG((DBGLVL, "ScreenWidth %d, ScreenHeight %d, Bytes/Pixel %d",
                     pContext->pThisDisplay->dwScreenWidth, 
                     pContext->pThisDisplay->dwScreenHeight, pContext->BPP));

    // Setup the relevent registers for the surfaces in use in this context.
    if ( FAILED( _D3D_OP_SetRenderTarget(pContext, 
                                         pContext->pSurfRenderInt, 
                                         pContext->pSurfZBufferInt,
                                         TRUE) ))
    {
        goto Error_OutOfMem_D;
    }

    // Process some defaults with which we initialize each D3D context
    _D3D_ST_ProcessOneRenderState(pContext,
                                  D3DRENDERSTATE_SHADEMODE,
                                  D3DSHADE_GOURAUD);

    _D3D_ST_ProcessOneRenderState(pContext,
                                  D3DRENDERSTATE_FOGCOLOR,
                                  0xFFFFFFFF);                                  
#if DX8_DDI
    // On DX8 D3DRENDERSTATE_TEXTUREPERSPECTIVE has been retired and is assumed 
    // to be set always to TRUE. We must make sure we are setting the hw up
    // correctly, so in order to do that we make an explicit setup call here 
    _D3D_ST_ProcessOneRenderState(pContext,
                                  D3DRENDERSTATE_TEXTUREPERSPECTIVE,
                                  1);
#endif // DX8_DDI                            

#if DX7_PALETTETEXTURE
    // Palette pointer array is per context, it is NOT associated with DD Local
    pContext->pPalettePointerArray = PA_CreateArray();
    
    if (! pContext->pPalettePointerArray) 
    {
        // We ran out of memory. Cleanup before we leave
        DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem "
                        "for pPalettePointerArray"));
        goto Error_OutOfMem_D;            
    }

    // It is an array of surfaces, so set the destroy callback
    PA_SetDataDestroyCallback(pContext->pTexturePointerArray, 
                              _D3D_SU_PaletteArrayDestroyCallback);
#endif

    START_SOFTWARE_CURSOR(pThisDisplay);

    pccd->ddrval = DD_OK;  // Call handled OK
    
    DBG_CB_EXIT(D3DContextCreate,pccd->ddrval);        
    
    return (DDHAL_DRIVER_HANDLED);

    //**************************************************************************
    // ERROR HANDLING CODE PATHS
    //**************************************************************************    
Error_OutOfMem_D:
    // Remove the texture pointer array from the hash table
    HT_RemoveEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                   (ULONG_PTR)pccd->lpDDLcl,
                   pThisDisplay);
    goto Error_OutOfMem_B;

Error_OutOfMem_C:
    // Free binding surface array (we'll no longer need it, and 
    // D3DCreateSurfaceEx will create a new one if necessary)
    PA_DestroyArray(pContext->pTexturePointerArray, pThisDisplay);
    
Error_OutOfMem_B:
    // Free D3D context data structure that we allocated
    HEAP_FREE(pContext->pSelf);      
        
Error_OutOfMem_A:
    // Release the context handle (otherwise it will remain in use forever)
    __CTX_HandleRelease((DWORD)pccd->dwhContext); 

    pccd->dwhContext = 0;
    pccd->ddrval = DDERR_OUTOFMEMORY;
    DBG_CB_EXIT(D3DContextCreate,pccd->ddrval);            
    return (DDHAL_DRIVER_HANDLED);
    
} // D3DContextCreate

//-----------------------------Public Routine----------------------------------
//
// D3DContextDestroy
//
// This callback is invoked when a Direct3D Device is being destroyed. As each
// device is represented by a context ID, the driver is passed a context to
// destroy.
//
// The driver should free all resources it allocated to the context being
// deleted. For example, the driver should free any texture resources it
// associated with the context. The driver should not free the DirectDraw
// surface(s) associated with the context because these will be freed by
// DirectDraw in response to an application or Direct3D runtime request.
//
// Parameters
//     pcdd
//          Pointer to Context destroy information.
//
//          .dwhContext
//               The ID of the context to be destroyed.
//          .ddrval
//               Return code. DD_OK indicates success.
//
// Return Value
//      Returns one of the following values:
//                DDHAL_DRIVER_HANDLED
//                DDHAL_DRIVER_NOTHANDLED
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DContextDestroy(
    LPD3DHAL_CONTEXTDESTROYDATA pccd)
{
    P3_D3DCONTEXT *pContext;
    P3_THUNKEDDATA *pThisDisplay;

    DBG_CB_ENTRY(D3DContextDestroy);
    
    // Deleting context
    DISPDBG((DBGLVL,"D3DContextDestroy Context = %08lx",pccd->dwhContext));

    pContext = _D3D_CTX_HandleToPtr(pccd->dwhContext);

    if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
    {
        pccd->ddrval = D3DHAL_CONTEXT_BAD;
        DISPDBG((WRNLVL,"Context not valid"));

        DBG_CB_EXIT(D3DContextDestroy,pccd->ddrval );        
        return (DDHAL_DRIVER_HANDLED);
    }

    pThisDisplay = pContext->pThisDisplay;

    // Flush any DMA and Sync the chip so that that DMA can complete
    // (deletecontexts aren't an every day occurance, so we may as well)

    STOP_SOFTWARE_CURSOR(pThisDisplay);

#if WNT_DDRAW
    if (pThisDisplay->ppdev->bEnabled)
    {
#endif
        DDRAW_OPERATION(pContext, pThisDisplay);

        {
            P3_DMA_DEFS();
            P3_DMA_GET_BUFFER();
            P3_DMA_FLUSH_BUFFER();
        }

        SYNC_WITH_GLINT;
#if WNT_DDRAW
    }
#endif

    START_SOFTWARE_CURSOR(pThisDisplay);

    // Mark the context as disabled
    pContext->MagicNo = RC_MAGIC_DISABLE;

#if DX7_TEXMANAGEMENT
    // Cleanup any texture management stuff before leaving
    _D3D_TM_Ctx_Destroy(pContext);
#endif // DX7_TEXMANAGEMENT    

    // Free and cleanup any associated hardware resources
    __CTX_CleanDirect3DContext(pContext);

    // Mark the context as now empty (dwhContext is ULONG_PTR for Win64)
    __CTX_HandleRelease((DWORD)pccd->dwhContext);

    // Finally, free up rendering context structure and set to NULL
    HEAP_FREE(pContext->pSelf);
    pContext = NULL;

    pccd->ddrval = DD_OK;

    DBG_CB_EXIT(D3DContextDestroy, pccd->ddrval);  

    return (DDHAL_DRIVER_HANDLED);       
} // D3DContextDestroy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3ddp2op.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddp2op.c
*
* Content: D3D DrawPrimitives2 command buffer operations support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
//
// __OP_IntersectRectl
//
// This function intersects two RECTLs. If no intersection exists returns FALSE
//
//-----------------------------------------------------------------------------
BOOL 
__OP_IntersectRectl(
    RECTL*  prcresult,
    RECTL*  prcin1,
    RECT*  prcin2)
{
    prcresult->left  = max(prcin1->left,  prcin2->left);
    prcresult->right = min(prcin1->right, prcin2->right);

    if (prcresult->left < prcresult->right)
    {
        prcresult->top    = max(prcin1->top,    prcin2->top);
        prcresult->bottom = min(prcin1->bottom, prcin2->bottom);

        if (prcresult->top < prcresult->bottom)
        {
            return TRUE;
        }
    }

    return FALSE;
} // __OP_IntersectRectl

#if DX7_TEXMANAGEMENT       
VOID __OP_MarkManagedSurfDirty(P3_D3DCONTEXT* pContext, 
                               DWORD dwSurfHandle,
                               P3_SURF_INTERNAL* pTexture);
#endif

//-----------------------------------------------------------------------------
//
// _D3D_OP_Clear2
//
// This function processes the D3DDP2OP_CLEAR DP2 command token.
//
// It builds a mask and a value for the stencil/depth clears. The mask is used 
// to stop unwanted bits being updated during the clear. The value is scaled in 
// the case of the Z depth, and is shifted in the case of the stencil.  This 
// results in the correct value being written, at the correct location in the 
// ZBuffer, while doing fast-block fills through SGRAM
//-----------------------------------------------------------------------------

#define P3RX_UPDATE_WRITE_MASK(a)                   \
if (dwCurrentMask != a)                             \
{                                                   \
    P3_DMA_GET_BUFFER_ENTRIES(2);                   \
    SEND_P3_DATA(FBHardwareWriteMask, a);           \
    P3_DMA_COMMIT_BUFFER();                         \
    dwCurrentMask = a;                              \
}

VOID 
_D3D_OP_Clear2( 
    P3_D3DCONTEXT* pContext,
    D3DHAL_DP2CLEAR* lpcd2,
    DWORD dwNumRects)
{
    DWORD i;
    RECTL rect, rect_vwport;
    DWORD dwDepthValue;
    DWORD dwStencilValue;
    DWORD dwStencilMask;
    DWORD dwDepthMask;
    DWORD color;
    DWORD dwCurrentMask = 0xFFFFFFFF;
    BOOL bNoBlockFillZ = FALSE;
    BOOL bNoBlockFillStencil = FALSE;
    BOOL bComputeIntersections = FALSE;
    BYTE Bytes[4];
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    HRESULT ddrval;
    D3DHAL_DP2CLEAR WholeViewport;

    P3_DMA_DEFS();

    DBG_CB_ENTRY(_D3D_OP_Clear2);
    
    // Check if we were asked to clear a valid buffer
    if ( (lpcd2->dwFlags & (D3DCLEAR_TARGET  | 
                            D3DCLEAR_ZBUFFER | 
                            D3DCLEAR_STENCIL) ) == 0)
    {
        // We have been asked to do nothing - and that's what we've done.
        DBG_CB_EXIT(_D3D_OP_Clear2, DD_OK);    
        return;
    }


#if DX8_DDI
    // When zero clear rects is passed to a DX8 driver with D3DDP2OP_CLEAR 
    // token, the driver should clear the whole viewport. The zero number 
    // of rects could be passed only if D3D is using a pure device. 

    // D3DCLEAR_COMPUTERECTS has been added to the dwFlags of D3DHAL_CLEARDATA.
    // When set, the flag means that user provided clear rects  should be 
    // culled against the current viewport.

    if (!(lpcd2->dwFlags & D3DCLEAR_COMPUTERECTS))
    {
        // Do nothing for non-pure device
    }
    else
    if (dwNumRects == 0)
    {
        // When wStateCount is zero we need to clear whole viewport
        WholeViewport.dwFlags = lpcd2->dwFlags;     
        WholeViewport.dwFillColor = lpcd2->dwFillColor; 
        WholeViewport.dvFillDepth = lpcd2->dvFillDepth; 
        WholeViewport.dwFillStencil = lpcd2->dwFillStencil;
        WholeViewport.Rects[0].left = pContext->ViewportInfo.dwX;
        WholeViewport.Rects[0].top = pContext->ViewportInfo.dwY;
        WholeViewport.Rects[0].right = pContext->ViewportInfo.dwX +
                                            pContext->ViewportInfo.dwWidth;
        WholeViewport.Rects[0].bottom = pContext->ViewportInfo.dwY + 
                                             pContext->ViewportInfo.dwHeight;    
        // Replace pointers and continue as usual
        lpcd2 = &WholeViewport;
        dwNumRects = 1;
    }
    else
    {
        // We need to cull all rects against the current viewport
        // but in order not to allocate a temporary RECT array in
        // kernel heap we'll compute this inside the clearing loop

        rect_vwport.left   = pContext->ViewportInfo.dwX;
        rect_vwport.top    = pContext->ViewportInfo.dwY;
        rect_vwport.right  = pContext->ViewportInfo.dwX + 
                             pContext->ViewportInfo.dwWidth;
        rect_vwport.bottom = pContext->ViewportInfo.dwY + 
                             pContext->ViewportInfo.dwHeight;

        bComputeIntersections = TRUE;

    }
#endif // DX8_DDI

    // Check if there is any rect to clear at all
    if ( dwNumRects == 0)
    {
        // We have been asked to do nothing - and that's what we've done.
        DBG_CB_EXIT(_D3D_OP_Clear2, DD_OK);    
        return;
    }   

    // Wait until we have we finished flipping before clearing anything
    do
    {
        ddrval = 
                _DX_QueryFlipStatus(pContext->pThisDisplay, 
                                    pContext->pSurfRenderInt->fpVidMem, 
                                    TRUE);
    } while ( FAILED (ddrval) );

    // Switch to hw Ddraw context in order to do the clears
    DDRAW_OPERATION(pContext, pThisDisplay);

    // Prepare any data necessary to clear the render target
    if ((lpcd2->dwFlags & D3DCLEAR_TARGET) && 
        (pContext->pSurfRenderInt != NULL))
    {
        color = lpcd2->dwFillColor;

        // Clear depending on depth
        switch (pContext->pSurfRenderInt->dwPixelSize)
        {
            // 16 Bit colors come in as 32 Bit RGB Values
            // Color will be packed in the clear function
            case __GLINT_16BITPIXEL:
                if (pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00) 
                {
                    color = ((color & 0xf8) >> 3)            | 
                            ((color & 0xf800) >> (16 - 10))  | 
                            ((color & 0xf80000) >> (24 - 15));
                } 
                else 
                {
                    color = ((color & 0xff) >> 3)             | 
                            ((color & 0xfc00) >> (16 - 11))   | 
                            ((color & 0xf80000) >> (24 - 16));
                }
                break;
                
            case __GLINT_24BITPIXEL:
                DISPDBG((ERRLVL,"P3 doesn't support 24 bpp render target"));
                break;
                
            default:
                break;
        }
    } // if (lpcd2->dwFlags & D3DCLEAR_TARGET)

    // Prepare any data necessary to clear the depth buffer
    if ((lpcd2->dwFlags & D3DCLEAR_ZBUFFER) && 
        (pContext->pSurfZBufferInt != NULL))
    {
        float fDepth;
        
        DDPIXELFORMAT* pPixFormat = &pContext->pSurfZBufferInt->pixFmt;
                
        DWORD dwZBitDepth = pPixFormat->dwZBufferBitDepth;

        // Find the depth bits, remembering to remove any stencil bits.
        if (pPixFormat->dwFlags & DDPF_STENCILBUFFER)
        {
            dwZBitDepth -= pPixFormat->dwStencilBitDepth;
        }

        dwDepthMask = (0xFFFFFFFF >> (32 - dwZBitDepth));

        // 32 bit depth buffers on Perm3 are really 
        // limited to 31 bits of precision
        if (dwZBitDepth == 32)
        {
            dwDepthMask = dwDepthMask >> 1; 
        }

        if (lpcd2->dvFillDepth == 1.0f)
        {
            dwDepthValue = dwDepthMask;
        }
        else
        {
            fDepth = lpcd2->dvFillDepth * (float)dwDepthMask;

            // This is a hardware dependency on how the Perm3 handles the 
            // limited precision of 32bit floats(24 bits of mantissa) and
            // converts the value into a 32bit z buffer value. This doesn't
            // happen with any other z bit depth but 32.
            if (dwZBitDepth == 32)
            {
                fDepth += 0.5f;
            }
            
            myFtoi((int*)&dwDepthValue, fDepth);
        }

        // As we are fast-block filling, make sure we copy the 
        // Mask to the top bits.
        switch (pContext->pSurfZBufferInt->dwPixelSize)
        {
            case __GLINT_16BITPIXEL:
                dwDepthMask &= 0xFFFF;
                dwDepthMask |= (dwDepthMask << 16);
                break;
            case __GLINT_8BITPIXEL:
                dwDepthMask &= 0xFF;
                dwDepthMask |= dwDepthMask << 8;
                dwDepthMask |= dwDepthMask << 16;
                break;
        }

        if (pThisDisplay->pGLInfo->bDRAMBoard)
        {
            // Check for a DRAM fill that the chip isn't emulating.
            Bytes[0] = (BYTE)(dwDepthMask & 0xFF);
            Bytes[1] = (BYTE)((dwDepthMask & 0xFF00) >> 8);
            Bytes[2] = (BYTE)((dwDepthMask & 0xFF0000) >> 16);
            Bytes[3] = (BYTE)((dwDepthMask & 0xFF000000) >> 24);
            if (((Bytes[0] != 0) && (Bytes[0] != 0xFF)) ||
                ((Bytes[1] != 0) && (Bytes[1] != 0xFF)) ||
                ((Bytes[2] != 0) && (Bytes[2] != 0xFF)) ||
                ((Bytes[3] != 0) && (Bytes[3] != 0xFF)))
            {
                bNoBlockFillZ = TRUE;
            }
        }

        DISPDBG((DBGLVL,"ZClear Value = 0x%x, ZClear Mask = 0x%x", 
                   dwDepthValue, dwDepthMask));
    } // if (lpcd2->dwFlags & D3DCLEAR_ZBUFFER)

    // Prepare any data necessary to clear the stencil buffer
    if ((lpcd2->dwFlags & D3DCLEAR_STENCIL) && 
        (pContext->pSurfZBufferInt != NULL))
    {
        int dwShiftCount = 0;
        DDPIXELFORMAT* pPixFormat = &pContext->pSurfZBufferInt->pixFmt;

        // Find out where to shift the 
        dwStencilMask = pPixFormat->dwStencilBitMask;

        if (dwStencilMask != 0)
        {
            while ((dwStencilMask & 0x1) == 0) 
            {
                dwStencilMask >>= 1;
                dwShiftCount++;
            }
            
            dwStencilValue = (lpcd2->dwFillStencil << dwShiftCount);
            dwStencilMask = pPixFormat->dwStencilBitMask;

            // As we are fast-block filling, make sure we copy the 
            // Mask to the top bits.
            switch (pContext->pSurfZBufferInt->dwPixelSize)
            {
                case __GLINT_16BITPIXEL:
                    dwStencilMask &= 0xFFFF;
                    dwStencilMask |= (dwStencilMask << 16);
                    break;
                    
                case __GLINT_8BITPIXEL:
                    dwStencilMask &= 0xFF;
                    dwStencilMask |= dwStencilMask << 8;
                    dwStencilMask |= dwStencilMask << 16;
                    break;
            }

            DISPDBG((DBGLVL,"Stencil Clear Value = 0x%x, Stencil Mask = 0x%x", 
                       dwStencilValue, dwStencilMask));
        }
        else
        {
            DISPDBG((ERRLVL,"ERROR: Stencil mask is not valid!"));
            dwStencilValue = 0;
            dwStencilMask = 0;
        }

        if (pThisDisplay->pGLInfo->bDRAMBoard)
        {
            // Check for a DRAM fill that the chip isn't emulating.
            Bytes[0] = (BYTE)(dwStencilMask & 0xFF);
            Bytes[1] = (BYTE)((dwStencilMask & 0xFF00) >> 8);
            Bytes[2] = (BYTE)((dwStencilMask & 0xFF0000) >> 16);
            Bytes[3] = (BYTE)((dwStencilMask & 0xFF000000) >> 24);
            if (((Bytes[0] != 0) && (Bytes[0] != 0xFF)) ||
                ((Bytes[1] != 0) && (Bytes[1] != 0xFF)) ||
                ((Bytes[2] != 0) && (Bytes[2] != 0xFF)) ||
                ((Bytes[3] != 0) && (Bytes[3] != 0xFF)))
            {
                bNoBlockFillStencil = TRUE;
            }
        }
    } // if (lpcd2->dwFlags & D3DCLEAR_STENCIL)


    // Loop through each clearing rect and perform the clearing hw operations
    i = dwNumRects;
    while (i-- > 0) 
    {
        if (bComputeIntersections)
        {
            // Compute intersection between the viewport and the incoming 
            // RECTLs. If no intersection exists skip into next one.

            if (!__OP_IntersectRectl(&rect, &rect_vwport, &lpcd2->Rects[i]))
            {
                // No intersection, so skip it
                goto Next_Rectl_To_Clear;
            }
        }
        else
        {
            // We already have the rects we need to clear, so 
            // just use them in reverse order
            rect.left   = lpcd2->Rects[i].left;
            rect.right  = lpcd2->Rects[i].right;
            rect.top    = lpcd2->Rects[i].top;
            rect.bottom = lpcd2->Rects[i].bottom;
        }

        // Clear the frame buffer
        if ((lpcd2->dwFlags & D3DCLEAR_TARGET) && 
            (pContext->pSurfRenderInt != NULL))        
        {
            P3RX_UPDATE_WRITE_MASK(__GLINT_ALL_WRITEMASKS_SET);

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                RECTL Temp = rect;
                Temp.left *= 2;
                Temp.right *= 2;
                Temp.top *= 2;
                Temp.bottom *= 2;
            
                _DD_BLT_P3Clear_AA(pThisDisplay, 
                                   &Temp, 
                                   pContext->dwAliasBackBuffer - 
                                        pThisDisplay->dwScreenFlatAddr, 
                                   color, 
                                   FALSE,
                                   pContext->pSurfRenderInt->dwPatchMode,
                                   pContext->pSurfRenderInt->dwPixelPitch,
                                   pContext->pSurfRenderInt->pixFmt.dwRGBBitCount,
                                   pContext->pSurfRenderInt->ddsCapsInt);
            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {

                _DD_BLT_P3Clear(pThisDisplay, 
                                &rect, 
                                color, 
                                FALSE, 
                                FALSE,
                                pContext->pSurfRenderInt->fpVidMem,
                                pContext->pSurfRenderInt->dwPatchMode,
                                pContext->pSurfRenderInt->dwPixelPitch,
                                pContext->pSurfRenderInt->pixFmt.dwRGBBitCount);

            }
            
        }


        // Clear the z buffer
        if ((lpcd2->dwFlags & D3DCLEAR_ZBUFFER) &&
            (pContext->pSurfZBufferInt != NULL) )
        {
            P3RX_UPDATE_WRITE_MASK(dwDepthMask);

            if (bNoBlockFillZ)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, dwDepthMask);
                SEND_P3_DATA(FBDestReadMode, 
                             P3RX_FBDESTREAD_READENABLE(__PERMEDIA_ENABLE) |
                             P3RX_FBDESTREAD_ENABLE0(__PERMEDIA_ENABLE));
                P3_DMA_COMMIT_BUFFER();
            }                   

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                RECTL Temp = rect;
                Temp.left *= 2;
                Temp.right *= 2;
                Temp.top *= 2;
                Temp.bottom *= 2;
                _DD_BLT_P3Clear_AA(pThisDisplay, 
                                   &Temp, 
                                   pContext->dwAliasZBuffer - 
                                        pThisDisplay->dwScreenFlatAddr, 
                                   dwDepthValue, 
                                   bNoBlockFillZ,
                                   pContext->pSurfZBufferInt->dwPatchMode,
                                   pContext->pSurfZBufferInt->dwPixelPitch,
                                   pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount,
                                   pContext->pSurfZBufferInt->ddsCapsInt);

            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {
                _DD_BLT_P3Clear(pThisDisplay, 
                                &rect, 
                                dwDepthValue, 
                                bNoBlockFillZ, 
                                TRUE,
                                pContext->pSurfZBufferInt->fpVidMem,
                                pContext->pSurfZBufferInt->dwPatchMode,
                                pContext->pSurfZBufferInt->dwPixelPitch,
                                pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount
                                );
            }
            
            if (bNoBlockFillZ)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
                SEND_P3_DATA(FBDestReadMode, __PERMEDIA_DISABLE);
                P3_DMA_COMMIT_BUFFER();
            }                   
        }

        // Clear the stencil buffer
        if ((lpcd2->dwFlags & D3DCLEAR_STENCIL) &&
            (pContext->pSurfZBufferInt != NULL) )
        {
            P3RX_UPDATE_WRITE_MASK(dwStencilMask);

            if (bNoBlockFillStencil)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, dwStencilMask);
                SEND_P3_DATA(FBDestReadMode, 
                             P3RX_FBDESTREAD_READENABLE(__PERMEDIA_ENABLE) |
                             P3RX_FBDESTREAD_ENABLE0(__PERMEDIA_ENABLE));
                P3_DMA_COMMIT_BUFFER();
            }                   

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                RECTL Temp = rect;
                Temp.left *= 2;
                Temp.right *= 2;
                Temp.top *= 2;
                Temp.bottom *= 2;
                _DD_BLT_P3Clear_AA(pThisDisplay, 
                                   &Temp, 
                                   pContext->dwAliasZBuffer - 
                                        pThisDisplay->dwScreenFlatAddr, 
                                   dwStencilValue, 
                                   bNoBlockFillStencil,
                                   pContext->pSurfZBufferInt->dwPatchMode,
                                   pContext->pSurfZBufferInt->dwPixelPitch,
                                   pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount,
                                   pContext->pSurfZBufferInt->ddsCapsInt
                                   );

            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {

                _DD_BLT_P3Clear(pThisDisplay, 
                                &rect, 
                                dwStencilValue, 
                                bNoBlockFillStencil, 
                                TRUE,
                                pContext->pSurfZBufferInt->fpVidMem,
                                pContext->pSurfZBufferInt->dwPatchMode,
                                pContext->pSurfZBufferInt->dwPixelPitch,
                                pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount
                                );
            }

            if (bNoBlockFillStencil)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
                SEND_P3_DATA(FBDestReadMode, __PERMEDIA_DISABLE);
                P3_DMA_COMMIT_BUFFER();
            }                   

        }
        
Next_Rectl_To_Clear:
        ;

    } // while

    // Make sure the WriteMask is reset to it's default value
    {                                               
        P3_DMA_GET_BUFFER_ENTRIES(4);          

        SEND_P3_DATA(FBHardwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
        SEND_P3_DATA(FBDestReadMode, __PERMEDIA_DISABLE);

        P3_DMA_COMMIT_BUFFER();
    }

    DBG_CB_EXIT(_D3D_OP_Clear2, DD_OK);     
    return;
    
} // _D3D_OP_Clear2

//-----------------------------------------------------------------------------
//
// _D3D_OP_TextureBlt
//
// This function processes the D3DDP2OP_TEXBLT DP2 command token.
//
//-----------------------------------------------------------------------------   
VOID _D3D_OP_TextureBlt(P3_D3DCONTEXT* pContext, 
                     P3_THUNKEDDATA*pThisDisplay,
                     D3DHAL_DP2TEXBLT* pBlt)
{
    LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL pDestLcl;
    P3_SURF_INTERNAL* pSrcTexture;
    P3_SURF_INTERNAL* pDestTexture;
    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest;
    MIPTEXTURE *pSrcMipLevel, *pDstMipLevel;
    RECTL rSrc, rDest;
    int iMaxLogWidth, iCurrLogWidth;
    int iSrcLOD, iDestLOD, iCurrSrcLOD, iCurrDstLOD;
    BOOL  bMipMap, bMipMapLevelsMatch;

    DISPDBG((DBGLVL, "TextureBlt Source %d Dest %d", 
                      pBlt->dwDDSrcSurface,
                      pBlt->dwDDDestSurface));

    if (0 == pBlt->dwDDSrcSurface)
    {
        DISPDBG((ERRLVL,"Invalid handle TexBlt from %08lx to %08lx",
                        pBlt->dwDDSrcSurface,pBlt->dwDDDestSurface));
        return;
    }

    // Get the source texture structure pointer
    pSrcTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDSrcSurface);    

    // Check that the source texture is valid
    if (pSrcTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Source texture %d is invalid!",
                         pBlt->dwDDSrcSurface));
        return;
    }

    // Validate the destination texture handle
    if (0 == pBlt->dwDDDestSurface)
    {
#if DX7_TEXMANAGEMENT  

        // If we do texture management then a destination handle of 0
        // has the special meaning of preloading the source texture.

        if (!_D3D_TM_Preload_Tex_IntoVidMem(pContext, pSrcTexture))
        {
            DISPDBG((ERRLVL,"_D3D_OP_TextureBlt unable to "
                            "preload texture"));
        }
        
        return;
        
#else
        // If there's no driver texture managament support we can't go
        // on if the destination handle is 0
        DISPDBG((ERRLVL,"Invalid handle TexBlt from %08lx to %08lx",
                        pBlt->dwDDSrcSurface,pBlt->dwDDDestSurface));
        return;
#endif        
    }
    
    // Get the destination texture structure pointer for regular TexBlts
    pDestTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDDestSurface);
    
    // Check that the destination texture is valid
    if (pDestTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Dest texture %d is invalid!",
                         pBlt->dwDDDestSurface));
        return;
    }

    // Make sure the textures are of the same proportion
    if ((pSrcTexture->wWidth * pDestTexture->wHeight) != 
        (pSrcTexture->wHeight * pDestTexture->wWidth)) 
    {
        DISPDBG((ERRLVL, "ERROR: TEXBLT the src and dest textures are not of the same proportion"));
        return;
    }

    // It is possible that the source and destination textures may contain 
    // different number of mipmap levels. In this case, the driver is 
    // expected to BitBlt the common levels. For example, if a 256x256 source 
    // texture has 8 mipmap levels, and if the destination is a 64x64 texture 
    // with 6 levels, then the driver should BitBlt the 6 corresponding levels 
    // from the source. The driver can expect the dimensions of the top mip 
    // level of destination texture to be always equal to or lesser than the 
    // dimensions of the top mip level of the source texture. 

    // It might also be the case that only one of the textures is mipmapped
    // Since we keep all relevant info also in the MipLevels substructre for
    // the surface, we can treat both surfaces as mipmapped even if only
    // one of them was created as such and proceed with the TexBlt.
    
    if (pSrcTexture->bMipMap || pDestTexture->bMipMap)
    {
        bMipMap = TRUE;
        iMaxLogWidth = max(pSrcTexture->logWidth, pDestTexture->logWidth);
        iCurrLogWidth = iMaxLogWidth;
        iSrcLOD = 0;                           // start LOD for src        
        iDestLOD = 0;                          // start LOD for dest
    }
    else
    {
        // just one level
        bMipMap = FALSE;       // No mipmapping cases to be handled
        iMaxLogWidth = iCurrLogWidth = iSrcLOD = iDestLOD = 0;           
    }

    // Init the rects from and into which we will blt . This is top level 
    // mipmap or non-mipmap texture,  just use rect from Blt.
    rSrc = pBlt->rSrc;

    // Create a destination rectangle for compatibility 
    // with the DD blitting function we are calling.
    rDest.left = pBlt->pDest.x;
    rDest.top = pBlt->pDest.y;
    rDest.right = (pBlt->rSrc.right - pBlt->rSrc.left) + rDest.left;
    rDest.bottom = (pBlt->rSrc.bottom - pBlt->rSrc.top) + rDest.top;
            
    // Traverse all the mip map levels and try to match them for a blt to be 
    // done. If no mipmaps are present just do for the "first" and only 
    // levels  present.
    do 
    {
        DISPDBG((DBGLVL,"TEXBLT iteration %d %d %d %d",
                        iMaxLogWidth,iCurrLogWidth,iSrcLOD,iDestLOD));
    
        // Get the local surface pointers and make sure the level sizes
        // match in the case of mip map Texblts.
        if (bMipMap)
        {        
            bMipMapLevelsMatch = FALSE;        
            
            // Verify you only look at valid mipmap levels - they might 
            // be incomplete (and we want not to AV or access garbage!)
            // for example, a source 256x256 texture may contain 5 levels, 
            // but the destination 256x256 texture may contain 8. The 
            // driver is expected to safely handle this case, but it is 
            // not expected to produce correct results            
            if ((iSrcLOD < pSrcTexture->iMipLevels) &&
                (iDestLOD < pDestTexture->iMipLevels))
            {          
                DISPDBG((DBGLVL,"Checking match! %d vs. %d", 
                                pSrcTexture->MipLevels[iSrcLOD].logWidth,
                                pDestTexture->MipLevels[iDestLOD].logWidth)); 
              
                // Do we currently have two levels that match in size ?
                bMipMapLevelsMatch = 
                        ( pSrcTexture->MipLevels[iSrcLOD].logWidth == 
                          pDestTexture->MipLevels[iDestLOD].logWidth);                
            }

            // Record which levels are we currently blitting
            iCurrSrcLOD = iSrcLOD;
            iCurrDstLOD = iDestLOD;
            
            // Get ready for next loop by updating the LODs to use
            // increment LOD# if we are currently looking at a level 
            // equal or smaller to mip maps level 0 size
            if (iCurrLogWidth <= pSrcTexture->logWidth)
            {
                iSrcLOD++;
            }

            if (iCurrLogWidth <= pDestTexture->logWidth)
            {
                iDestLOD++;
            }            

            // Decrease the width into next smaller level
            iCurrLogWidth--;
        }
        else
        {
            // Single level blt - we set bMipMapLevelsMatch in order to blt it!
            bMipMapLevelsMatch = TRUE;
            iCurrSrcLOD = 0;
            iCurrDstLOD = 0;
        }

        if (bMipMapLevelsMatch)
        {
            // Switch to the DirectDraw context
            DDRAW_OPERATION(pContext, pThisDisplay);

            DISPDBG((DBGLVL,"Blitting level %d into level %d",
                            iCurrSrcLOD,
                            iCurrDstLOD));

            pSrcMipLevel = &pSrcTexture->MipLevels[iCurrSrcLOD];
            pDstMipLevel = &pDestTexture->MipLevels[iCurrDstLOD];

            ///////////////////////////////////////////////////////////////////
            // Here we handle all possible blt cases between different types
            // of memory and different scenarios of managed/unmanaged surfaces
            ///////////////////////////////////////////////////////////////////

#if DX7_TEXMANAGEMENT
            if ((0 == (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) &&
                (0 == (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) )
#endif // DX7_TEXMANAGEMENT                
            {           
                //----------------------------------
                //----------------------------------
                // TEXBLT among non-managed textures
                //----------------------------------
                //----------------------------------

                if ((pSrcTexture->Location == SystemMemory) && 
                    (pDestTexture->Location == VideoMemory))
                {
                    //----------------------------
                    // Do the system->videomem blt
                    //----------------------------
                    _DD_P3Download(pThisDisplay,
                                   pSrcMipLevel->fpVidMem,
                                   pDstMipLevel->fpVidMem,
                                   pSrcTexture->dwPatchMode,
                                   pDestTexture->dwPatchMode,
                                   pSrcMipLevel->lPitch,
                                   pDstMipLevel->lPitch,                                                             
                                   pDstMipLevel->P3RXTextureMapWidth.Width,
                                   pDestTexture->dwPixelSize,
                                   &rSrc,
                                   &rDest);                                                           
                }
                else if ((pSrcTexture->Location == VideoMemory) && 
                         (pDestTexture->Location == VideoMemory))
                {
                    //------------------------------            
                    // Do the videomem->videomem blt
                    //------------------------------
                    _DD_BLT_P3CopyBlt(pThisDisplay,
                                      pSrcMipLevel->fpVidMem,
                                      pDstMipLevel->fpVidMem,
                                      pSrcTexture->dwPatchMode,
                                      pDestTexture->dwPatchMode,
                                      pSrcMipLevel->P3RXTextureMapWidth.Width,
                                      pDstMipLevel->P3RXTextureMapWidth.Width,
                                      pSrcMipLevel->dwOffsetFromMemoryBase,                                 
                                      pDstMipLevel->dwOffsetFromMemoryBase,
                                      pDestTexture->dwPixelSize,
                                      &rSrc,
                                      &rDest);
                }          
                else if ((pSrcTexture->Location == AGPMemory) && 
                         (pDestTexture->Location == VideoMemory))
                {
                    //-------------------------------           
                    // Do the AGP mem -> videomem blt
                    //-------------------------------    
                    DDCOLORKEY ddck_dummy = { 0 , 0 };

                    // We use the strecth blt because it handles AGP source 
                    // surfaces, not becuase we should stretch the surface in any way                
                    _DD_P3BltStretchSrcChDstCh(
                                      pThisDisplay,
                                      // src data
                                      pSrcMipLevel->fpVidMem,
                                      pSrcTexture->pFormatSurface,
                                      pSrcTexture->dwPixelSize,
                                      pSrcMipLevel->wWidth,
                                      pSrcMipLevel->wHeight,
                                      pSrcMipLevel->P3RXTextureMapWidth.Width,
                                      pSrcMipLevel->P3RXTextureMapWidth.Layout,
                                      pSrcMipLevel->dwOffsetFromMemoryBase,
                                      pSrcTexture->dwFlagsInt,
                                      &pSrcTexture->pixFmt,
                                      1,          // src IS AGP, otherwise we 
                                                  //would'nt call this
                                      // dest data
                                      pDstMipLevel->fpVidMem,
                                      pDestTexture->pFormatSurface,
                                      pDestTexture->dwPixelSize,
                                      pDstMipLevel->wWidth,
                                      pDstMipLevel->wHeight,
                                      pDstMipLevel->P3RXTextureMapWidth.Width,
                                      pDstMipLevel->P3RXTextureMapWidth.Layout,
                                      pDstMipLevel->dwOffsetFromMemoryBase,
                                      
                                      0,          // dwBltFlags no special blt effects
                                      0,          // dwBltDDFX  no special effects info
                                      ddck_dummy, // BltSrcColorKey dummy arg
                                      ddck_dummy, // BltDestColorKey dummy arg
                                      &rSrc,
                                      &rDest
                                      );
                }
                else            
                {
                    DISPDBG((ERRLVL,"Non-managed Tex Blt variation unimplemented! "
                                    "(from %d into %d)",
                                    pSrcTexture->Location,
                                    pDestTexture->Location));
                }
            }            
#if DX7_TEXMANAGEMENT              
            else if (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                //----------------------------------
                //----------------------------------
                // TEXBLT from a managed texture
                //----------------------------------
                //----------------------------------

                if ((pDestTexture->Location == SystemMemory) ||
                    (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
                {
                    //-------------------------------------------------
                    // Do the Managed surf -> sysmem | managed surf blt
                    //-------------------------------------------------    

                    // make sure we'll reload the vidmem copy of the dest surf
                    if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {
                        __OP_MarkManagedSurfDirty(pContext,
                                                  pBlt->dwDDDestSurface,
                                                  pDestTexture);                                              
                    }

                    _DD_BLT_SysMemToSysMemCopy(
                                pSrcMipLevel->fpVidMem,
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc,
                                &rDest);
                }
                else if (pDestTexture->Location == VideoMemory) 
                {
                    //-------------------------------------------------
                    // Do the Managed surf -> vidmem surf blt
                    //-------------------------------------------------                  

                    // This might be optimized by doing a vidmem->vidmem 
                    // when the source managed texture has a vidmem copy

                    _DD_P3Download(pThisDisplay,
                                   pSrcMipLevel->fpVidMem,
                                   pDstMipLevel->fpVidMem,
                                   pSrcTexture->dwPatchMode,
                                   pDestTexture->dwPatchMode,
                                   pSrcMipLevel->lPitch,
                                   pDstMipLevel->lPitch,                                                             
                                   pDstMipLevel->P3RXTextureMapWidth.Width,
                                   pDestTexture->dwPixelSize,
                                   &rSrc,
                                   &rDest);                                          
                }
                else            
                {
                    DISPDBG((ERRLVL,"Src-managed Tex Blt variation unimplemented! "
                                    "(from %d into %d)",
                                    pSrcTexture->Location,
                                    pDestTexture->Location));
                }
                
                
            }
            else if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                //--------------------------------------------------------------
                //--------------------------------------------------------------
                // TEXBLT into a managed texture (except from a managed texture)
                //--------------------------------------------------------------
                //--------------------------------------------------------------

                // managed->managed is handled in the previous case

                if (pSrcTexture->Location == SystemMemory)
                {                
                    //-------------------------------------------------
                    // Do the sysmem surf -> managed surf blt
                    //-------------------------------------------------    

                    // make sure we'll reload the vidmem copy of the dest surf
                    __OP_MarkManagedSurfDirty(pContext,
                                              pBlt->dwDDDestSurface,
                                              pDestTexture);                                              
                                                                  
                    _DD_BLT_SysMemToSysMemCopy(
                                pSrcMipLevel->fpVidMem,
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc, 
                                &rDest);
                }
                else if (pSrcTexture->Location == VideoMemory)                
                {
                    //-------------------------------------------------
                    // Do the vidmem surf -> Managed surf blt
                    //-------------------------------------------------                                  

                    if (0 != pSrcMipLevel->fpVidMemTM)
                    {
                        // Destination is already in vidmem so instead of
                        // "dirtying" the managed texture lets do the
                        // vidmem->vidmem blt which is faster than doing the
                        // update later (in the hope we'll really use it)

                        _DD_BLT_P3CopyBlt(pThisDisplay,
                                          pSrcMipLevel->fpVidMem,
                                          pDstMipLevel->fpVidMemTM,
                                          pSrcTexture->dwPatchMode,
                                          pDestTexture->dwPatchMode,
                                          pSrcMipLevel->P3RXTextureMapWidth.Width,
                                          pDstMipLevel->P3RXTextureMapWidth.Width,
                                          pSrcMipLevel->dwOffsetFromMemoryBase,                                 
                                          pDstMipLevel->dwOffsetFromMemoryBase,
                                          pDestTexture->dwPixelSize,
                                          &rSrc,
                                          &rDest);                        
                    } 
                    else
                    {
                        // make sure we'll reload the 
                        // vidmem copy of the dest surf
                        __OP_MarkManagedSurfDirty(pContext,
                                                  pBlt->dwDDDestSurface,
                                                  pDestTexture);   
                    }

                    // Do slow mem mapped framebuffer blt into sysmem
                    // The source surface lives in video mem so we need to get a
                    // "real" sysmem address for it:                    
                    _DD_BLT_SysMemToSysMemCopy(
                                D3DMIPLVL_GETPOINTER(pSrcMipLevel, pThisDisplay),
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc,
                                &rDest);                    
                }
                else if (pSrcTexture->Location == AGPMemory)                     
                {
                    // make sure we'll reload the vidmem copy of the dest surf
                    __OP_MarkManagedSurfDirty(pContext,
                                              pBlt->dwDDDestSurface,
                                              pDestTexture);                                              
                
                    _DD_BLT_SysMemToSysMemCopy(
                                pSrcMipLevel->fpVidMem,
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc,
                                &rDest);                
                }
                else            
                {
                    DISPDBG((ERRLVL,"Dest-managed Tex Blt variation unimplemented! "
                                    "(from %d into %d)",
                                    pSrcTexture->Location,
                                    pDestTexture->Location));
                }
                
            }
            else            
            {
                DISPDBG((ERRLVL,"Tex Blt variation unimplemented! "
                                "(from %d into %d)",
                                pSrcTexture->Location,
                                pDestTexture->Location));
            }
#endif // DX7_TEXMANAGEMENT        
            
        
            // Switch back to the Direct3D context
            D3D_OPERATION(pContext, pThisDisplay);
            
        } // if (bMipMapLevelsMatch)    


        // Update transfer rectangles if mip mapping
        if (bMipMap)
        {
            DWORD right, bottom;

            // Update source rectangle , the regions to be copied in mipmap 
            // sub-levels can be obtained by dividing rSrc and pDest by 
            // 2 at each level. 
            rSrc.left >>= 1;
            rSrc.top >>= 1;
            right = (rSrc.right + 1) >> 1;
            bottom = (rSrc.bottom + 1) >> 1;
            rSrc.right = ((right - rSrc.left) < 1) ? (rSrc.left + 1) : (right);
            rSrc.bottom = ((bottom - rSrc.top ) < 1) ? (rSrc.top + 1) : (bottom);     

            // Update destination rectangle   
            rDest.left >>= 1;
            rDest.top >>= 1;
            right = (rDest.right + 1) >> 1;
            bottom = (rDest.bottom + 1) >> 1;
            rDest.right = ((right - rDest.left) < 1) ? (rDest.left + 1) : (right);
            rDest.bottom = ((bottom - rDest.top ) < 1) ? (rDest.top + 1) : (bottom);              
        }

    } while (bMipMap && ((iSrcLOD < pSrcTexture->iMipLevels) &&
                         (iDestLOD < pDestTexture->iMipLevels))); // do until we're done looking at 1x1
                
} // _D3D_OP_TextureBlt

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetRenderTarget
//
// Sets up the hw for the chosen render target and depth buffer
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_OP_SetRenderTarget(
    P3_D3DCONTEXT* pContext, 
    P3_SURF_INTERNAL* pRenderInt,
    P3_SURF_INTERNAL* pZBufferInt,
    BOOL bNewAliasBuffers)
{

    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    DWORD AAMultiplier = 1;
    P3_DMA_DEFS();

    DBG_ENTRY(_D3D_OP_SetRenderTarget);

    // Verify the render target is in video memory
    if (pRenderInt)
    {    
        if (pRenderInt->ddsCapsInt.dwCaps & DDSCAPS_SYSTEMMEMORY) 
        {
            DISPDBG((ERRLVL, "ERROR: Render Surface in SYSTEM MEMORY"));
            return DDERR_GENERIC;
        }
    }
    else
    {
        // Must have a render target
        DISPDBG((ERRLVL, "ERROR: Render Surface is NULL"));
        return DDERR_GENERIC;
    }

    // If a Z Buffer verify it
    if (pZBufferInt)
    {
        if (pZBufferInt->ddsCapsInt.dwCaps & DDSCAPS_SYSTEMMEMORY) 
        {
            DISPDBG((ERRLVL, "ERROR: Z Surface in SYSTEM MEMORY, failing"));
            return DDERR_GENERIC;
        } 
    }    

    // Validate the RenderTarget to be 32 bit or 16 bit 565 
    if ((pRenderInt->pixFmt.dwRGBBitCount == 32     ) &&
        (pRenderInt->pixFmt.dwRBitMask == 0x00FF0000) &&
        (pRenderInt->pixFmt.dwGBitMask == 0x0000FF00) &&        
        (pRenderInt->pixFmt.dwBBitMask == 0x000000FF))
    {
        // were OK at 32bpp
    }
    else
    if ((pRenderInt->pixFmt.dwRGBBitCount == 16 ) &&
        (pRenderInt->pixFmt.dwRBitMask == 0xF800) &&
        (pRenderInt->pixFmt.dwGBitMask == 0x07E0) &&        
        (pRenderInt->pixFmt.dwBBitMask == 0x001F))    
    {
        // were OK at 16bpp
    }
    else
    {
        // we cant set our render target to this format !!!
        DISPDBG((WRNLVL, " SRT Error    !!!"));
        DISPDBG((WRNLVL, "    dwRGBBitCount:          0x%x", 
                                         pRenderInt->pixFmt.dwRGBBitCount));
        DISPDBG((WRNLVL, "    dwR/Y BitMask:          0x%x", 
                                         pRenderInt->pixFmt.dwRBitMask));
        DISPDBG((WRNLVL, "    dwG/U BitMask:          0x%x", 
                                         pRenderInt->pixFmt.dwGBitMask));
        DISPDBG((WRNLVL, "    dwB/V BitMask:          0x%x", 
                                         pRenderInt->pixFmt.dwBBitMask));
        DISPDBG((WRNLVL, "    dwRGBAlphaBitMask:      0x%x", 
                                         pRenderInt->pixFmt.dwRGBAlphaBitMask));
        return DDERR_GENERIC;          
    }

#if DX8_MULTISAMPLING
    // Decide whether antialising is requested and can be handled
    if ((pContext->pSurfRenderInt->dwSampling) &&
        (! _D3D_ST_CanRenderAntialiased(pContext, bNewAliasBuffers)))
    {
        return DDERR_OUTOFMEMORY;
    }
#endif // DX8_MULTISAMPLING

    // If we page flipped, clear the flag
    pThisDisplay->bFlippedSurface = FALSE;

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(46);
    WAIT_FIFO(26);
    
    pContext->pSurfRenderInt = pRenderInt;
    pContext->pSurfZBufferInt = pZBufferInt;

    // Check for Z Buffer
    if (pZBufferInt)
    {
        DDPIXELFORMAT* pZFormat = &pZBufferInt->pixFmt;

        if( pThisDisplay->dwDXVersion >= DX6_RUNTIME)
        {
            // On DX6 we look in the pixel format for the depth and stencil info.
            switch(pZFormat->dwZBufferBitDepth)
            {
            default:
                DISPDBG((ERRLVL,"ERROR: Unknown Z Pixel format!"));
                // Regard the buffer as 16 bit one and fall through

            case 16:
                if (pZFormat->dwStencilBitDepth == 1)
                {
                    // 15 bit Z, 1 bit stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_1; 
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_15;

                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_1;

                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_1;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_15;
                    
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_15;
                    
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x3;
                }
                else
                {
                    // 16 bit Z, no stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_0; 
                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_16;
                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_16;
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_16;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x3;
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 1;
                }
                break;
                
            case 32:
                if (pZFormat->dwStencilBitDepth == 8)
                {
                    // 24 bit Z, 8 bit stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = P3RX_STENCIL_POSITION_24; 
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_8; 
                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_8;
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_24;
                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = P3RX_STENCIL_POSITION_24; 
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_8;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_24;
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_24;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0xF;
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;
                }
                else
                {
                    // 32 bit Z, no stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0;
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_0; 
                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_32;
                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0; 
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_32;
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_32;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0xF;
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;

                }
                break;
            }

        }
        else
        // On DX5 we don't look at the pixel format, just the depth of the Z Buffer.
        {
            // Choose the correct Z Buffer depth
            switch(pZBufferInt->pixFmt.dwRGBBitCount)
            {
            default:
                DISPDBG((ERRLVL,"ERROR: Unknown depth format in _D3D_OP_SetRenderTarget!"));
                // Regard the buffer as 16 bit one and fall through

            case 16:
                pSoftP3RX->P3RXLBReadFormat.DepthWidth = __GLINT_DEPTH_WIDTH_16;
                pSoftP3RX->P3RXLBWriteFormat.DepthWidth = __GLINT_DEPTH_WIDTH_16;
                pSoftP3RX->P3RXDepthMode.Width = __GLINT_DEPTH_WIDTH_16;
                pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x3;
                pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 1;
                pSoftP3RX->P3RXLBDestReadMode.Packed16 = 1;
                pSoftP3RX->P3RXLBWriteMode.Packed16 = 1;
                break;
                
            case 24:
                pSoftP3RX->P3RXLBReadFormat.DepthWidth = __GLINT_DEPTH_WIDTH_24;
                pSoftP3RX->P3RXLBWriteFormat.DepthWidth = __GLINT_DEPTH_WIDTH_24;
                pSoftP3RX->P3RXDepthMode.Width = __GLINT_DEPTH_WIDTH_24;
                pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x7;
                pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;
                break;
                
            case 32:
                pSoftP3RX->P3RXLBReadFormat.DepthWidth = __GLINT_DEPTH_WIDTH_32;
                pSoftP3RX->P3RXLBWriteFormat.DepthWidth = __GLINT_DEPTH_WIDTH_32;
                pSoftP3RX->P3RXDepthMode.Width = __GLINT_DEPTH_WIDTH_32;
                pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0xF;
                pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;
                break;
                
            }
        }

        pSoftP3RX->P3RXLBSourceReadMode.Layout = pZBufferInt->dwPatchMode;
        pSoftP3RX->P3RXLBDestReadMode.Layout = pZBufferInt->dwPatchMode;
        pSoftP3RX->P3RXLBWriteMode.Layout = pZBufferInt->dwPatchMode;
    } //  if (pZBufferInt) 
    
    switch (pRenderInt->dwPixelSize)
    {
    case __GLINT_8BITPIXEL:
        // 8 Bit color index mode
        pSoftP3RX->DitherMode.ColorFormat = 
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_CI;
        SEND_P3_DATA(PixelSize, 2 - __GLINT_8BITPIXEL);
        break;
        
    case __GLINT_16BITPIXEL:
        if (pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00)
        {
            // 5551 format
            pSoftP3RX->DitherMode.ColorFormat = P3RX_DITHERMODE_COLORFORMAT_5551;   
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_5551;
        }
        else
        {
            // 565 format
            pSoftP3RX->DitherMode.ColorFormat = P3RX_DITHERMODE_COLORFORMAT_565;    
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_565;
        }
        SEND_P3_DATA(PixelSize, 2 - __GLINT_16BITPIXEL);
        break;
        
    case __GLINT_24BITPIXEL:
    case __GLINT_32BITPIXEL:
        // 32 Bit Color Index mode
        pSoftP3RX->DitherMode.ColorFormat =
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_8888;
        SEND_P3_DATA(PixelSize, 2 - __GLINT_32BITPIXEL);
        break;
    }

    pSoftP3RX->P3RXFBDestReadMode.Layout0 = pRenderInt->dwPatchMode;
    pSoftP3RX->P3RXFBWriteMode.Layout0 = pRenderInt->dwPatchMode;
    pSoftP3RX->P3RXFBSourceReadMode.Layout = pRenderInt->dwPatchMode;

    COPY_P3_DATA(FBWriteMode, pSoftP3RX->P3RXFBWriteMode);
    COPY_P3_DATA(FBDestReadMode, pSoftP3RX->P3RXFBDestReadMode);
    COPY_P3_DATA(FBSourceReadMode, pSoftP3RX->P3RXFBSourceReadMode);

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    if (!(pContext->Flags & SURFACE_ANTIALIAS) ||
         (pContext->dwAliasBackBuffer == 0))
    {
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS
        pContext->PixelOffset = (DWORD)(pRenderInt->fpVidMem - 
                                                 pThisDisplay->dwScreenFlatAddr );

        if (pContext->pSurfZBufferInt)
        {
            pContext->ZPixelOffset = (DWORD)(pZBufferInt->fpVidMem - 
                                                        pThisDisplay->dwScreenFlatAddr);
        }
        AAMultiplier = 1;

        SEND_P3_DATA(PixelSize, (2 - pRenderInt->dwPixelSize));
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    }
    else
    {
        pContext->PixelOffset = pContext->dwAliasPixelOffset;
        pContext->ZPixelOffset = pContext->dwAliasZPixelOffset;
        AAMultiplier = 2;
    }
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

    COPY_P3_DATA(AlphaBlendColorMode, pSoftP3RX->P3RXAlphaBlendColorMode);
    COPY_P3_DATA(DitherMode, pSoftP3RX->DitherMode);

    SEND_P3_DATA(FBWriteBufferAddr0, pContext->PixelOffset);
    SEND_P3_DATA(FBDestReadBufferAddr0, pContext->PixelOffset);
    SEND_P3_DATA(FBSourceReadBufferAddr, pContext->PixelOffset);

    SEND_P3_DATA(FBWriteBufferWidth0, 
                        pContext->pSurfRenderInt->dwPixelPitch  * AAMultiplier);
    SEND_P3_DATA(FBDestReadBufferWidth0, 
                        pContext->pSurfRenderInt->dwPixelPitch * AAMultiplier);
    SEND_P3_DATA(FBSourceReadBufferWidth, 
                        pContext->pSurfRenderInt->dwPixelPitch * AAMultiplier);

    WAIT_FIFO(20);

    // Is there a Z Buffer?
    if (pContext->pSurfZBufferInt != NULL)
    {
        // Offset is in BYTES
        SEND_P3_DATA(LBSourceReadBufferAddr, pContext->ZPixelOffset);
        SEND_P3_DATA(LBDestReadBufferAddr, pContext->ZPixelOffset);
        SEND_P3_DATA(LBWriteBufferAddr, pContext->ZPixelOffset);
        
        pSoftP3RX->P3RXLBWriteMode.Width = 
                        pContext->pSurfZBufferInt->dwPixelPitch * AAMultiplier;
        pSoftP3RX->P3RXLBSourceReadMode.Width = 
                        pContext->pSurfZBufferInt->dwPixelPitch * AAMultiplier;
        pSoftP3RX->P3RXLBDestReadMode.Width = 
                        pContext->pSurfZBufferInt->dwPixelPitch * AAMultiplier;
                        
        COPY_P3_DATA(LBDestReadMode, pSoftP3RX->P3RXLBDestReadMode);
        COPY_P3_DATA(LBSourceReadMode, pSoftP3RX->P3RXLBSourceReadMode);
        COPY_P3_DATA(LBWriteMode, pSoftP3RX->P3RXLBWriteMode);
        
        COPY_P3_DATA(StencilMode, pSoftP3RX->P3RXStencilMode);
        COPY_P3_DATA(LBReadFormat, pSoftP3RX->P3RXLBReadFormat);
        COPY_P3_DATA(LBWriteFormat, pSoftP3RX->P3RXLBWriteFormat);

        COPY_P3_DATA(DepthMode, pSoftP3RX->P3RXDepthMode);
    }

    DIRTY_VIEWPORT(pContext);

    P3_DMA_COMMIT_BUFFER();

    DBG_EXIT(_D3D_OP_SetRenderTarget,0);

    return DD_OK;
    
} // _D3D_OP_SetRenderTarget


//-----------------------------------------------------------------------------
//
// _D3D_OP_SceneCapture
//
// This function is called twice, once at the start of the rendering,
// and once at the end of the rendering.  The start is ignored, but 
// the end might be used to ensure that the DMA buffer has been flushed.
// This is needed for the case where a scene has little in it, and 
// doesn't fill the buffer up.
//
//-----------------------------------------------------------------------------
VOID  
_D3D_OP_SceneCapture(
    P3_D3DCONTEXT *pContext,
    DWORD dwFlag)
{
    P3_THUNKEDDATA *pThisDisplay;
    
    pThisDisplay = pContext->pThisDisplay;
    
    if (dwFlag == D3DHAL_SCENE_CAPTURE_START)
    {
        DISPDBG((DBGLVL,"Scene Start"));
    }
    else if (dwFlag == D3DHAL_SCENE_CAPTURE_END)    
    {   
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
        if (pContext->Flags & SURFACE_ANTIALIAS) 
        {
            // Since we were antialiasing we need to put the data where 
            // the user asked which requires a copy from our AA buffer 
            // into the true target buffer

            // P3 Shrinking is done in the DDRAW context. This means you 
            // don't have to save and restore the state around the call 
            // - the next D3D_OPERATION will recover for you
            DDRAW_OPERATION(pContext, pThisDisplay);

            P3RX_AA_Shrink(pContext);
        }
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

        DISPDBG((DBGLVL,"Scene End"));
    }
      
    return;
} // _D3D_OP_SceneCapture

#if DX7_TEXMANAGEMENT  
//-----------------------------------------------------------------------------
//
// __OP_MarkManagedSurfDirty
//
// Make sure textures are setup again if the texture is being used in any of
// the texture stages (for reloading purpouses) and make sure we mark it as
// dirty (since we're modifying the sysmem copy of the texture)
//
//-----------------------------------------------------------------------------   
VOID __OP_MarkManagedSurfDirty(P3_D3DCONTEXT* pContext, 
                               DWORD dwSurfHandle,
                               P3_SURF_INTERNAL* pTexture)
{
    // If the destination texture is in use in any of the texture
    // stages, make sure hw gets re-setup again before using it.
    if ((pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP] 
                                    == dwSurfHandle) ||
        (pContext->TextureStageState[1].m_dwVal[D3DTSS_TEXTUREMAP]
                                    == dwSurfHandle))
    {
        DIRTY_TEXTURE(pContext);
    }

    // Mark the destination texture as needing to be updated
    // into vidmem before using it.
    pTexture->m_bTMNeedUpdate = TRUE;
    
} // __OP_MarkManagedSurfDirty

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetTexLod
//
// This function processes the D3DDP2OP_SETTEXLOD DP2 command token.
// This communicates to the texture manager the most detailed mip map level
// required to load for a given managed surface. 
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_SetTexLod(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2SETTEXLOD* pSetTexLod)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
    pTexture = GetSurfaceFromHandle(pContext, pSetTexLod->dwDDSurface);    

    if (pTexture == NULL)
    {
        return;
    }

    // Set up the HW texture states again if this texture is in use
    // and the new LOD value is smaller than the current setting.
    if (((pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP]
                                    == pSetTexLod->dwDDSurface) ||
         (pContext->TextureStageState[1].m_dwVal[D3DTSS_TEXTUREMAP]
                                    == pSetTexLod->dwDDSurface)) &&
        (pSetTexLod->dwLOD < pTexture->m_dwTexLOD))
    {
        DIRTY_TEXTURE(pContext);
    }

    // Change the texture's largest level to be actually used
    pTexture->m_dwTexLOD = pSetTexLod->dwLOD; 

} // _D3D_OP_SetTexLod

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetPriority
//
// This function processes the D3DDP2OP_SETPRIORITY DP2 command token.
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_SetPriority(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2SETPRIORITY* pSetPriority)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
#if WNT_DDRAW
    pTexture = GetSurfaceFromHandle(pContext, pSetPriority->dwDDDestSurface);
#else
    pTexture = GetSurfaceFromHandle(pContext, pSetPriority->dwDDSurface);
#endif

    if (NULL != pTexture)
    {
        // Managed resources should be evicted depending on their priorities.
        // If of same priority then LRU is used to break the tie.
        pTexture->m_dwPriority = pSetPriority->dwPriority; 
    }

} // _D3D_OP_SetPriority

#if DX8_DDI
//-----------------------------------------------------------------------------
//
// _D3D_OP_AddDirtyRect
//
// This function processes the D3DDP2OP_ADDDIRTYRECT DP2 command token.
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_AddDirtyRect(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2ADDDIRTYRECT* pAddDirtyRect)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
    pTexture = GetSurfaceFromHandle(pContext, pAddDirtyRect->dwSurface);    

    if (NULL != pTexture)
    {
        //azn TODO
        // As a first implementation in this driver we mark the whole surface 
        // as dirty instead of marking just the indicated rect - which could be
        // transferred more efficiently
        __OP_MarkManagedSurfDirty(pContext, 
                                  pAddDirtyRect->dwSurface,
                                  pTexture);
    }

} // _D3D_OP_AddDirtyRect

//-----------------------------------------------------------------------------
//
// _D3D_OP_AddDirtyBox
//
// This function processes the D3DDP2OP_ADDDIRTYBOX DP2 command token.
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_AddDirtyBox(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2ADDDIRTYBOX* pAddDirtyBox)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
    pTexture = GetSurfaceFromHandle(pContext, pAddDirtyBox->dwSurface);    

    if (NULL != pTexture)
    {
        //azn TODO
        // As a first implementation in this driver we mark the whole surface 
        // as dirty instead of marking just the indicated rect - which could be
        // transferred more efficiently
        __OP_MarkManagedSurfDirty(pContext, 
                                  pAddDirtyBox->dwSurface,
                                  pTexture);
    }

} // _D3D_OP_AddDirtyBox
#endif
#endif // DX7_TEXMANAGEMENT
       


#if DX8_3DTEXTURES

//-----------------------------------------------------------------------------
//
// __OP_BasicVolumeBlt
//
// This function blts one single level/slice at a time for volume textures
//
//-----------------------------------------------------------------------------   
VOID __OP_BasicVolumeBlt(P3_D3DCONTEXT* pContext, 
                         P3_THUNKEDDATA*pThisDisplay,
                         P3_SURF_INTERNAL* pSrcTexture,
                         P3_SURF_INTERNAL* pDestTexture,
                         DWORD dwDestSurfHandle,
                         RECTL *prSrc, 
                         RECTL *prDest)
{
#if DX7_TEXMANAGEMENT
    if ((0 == (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) &&
        (0 == (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) )
#endif // DX7_TEXMANAGEMENT     
    {
        if ((pSrcTexture->Location == SystemMemory) && 
            (pDestTexture->Location == VideoMemory))
        {
            //----------------------------
            // Do the system->videomem blt
            //----------------------------
            _DD_P3Download(pThisDisplay,
                           pSrcTexture->fpVidMem,
                           pDestTexture->fpVidMem,
                           pSrcTexture->dwPatchMode,
                           pDestTexture->dwPatchMode,
                           pSrcTexture->lPitch,
                           pDestTexture->lPitch,
                           pDestTexture->dwPixelPitch,
                           pDestTexture->dwPixelSize,
                           prSrc,
                           prDest);
        }
        else
        {
            DISPDBG((ERRLVL, "ERROR: __OP_BasicVolumeBlt b3DTexture (%d -> %d)"
                             "not suported yet!",
                         pSrcTexture->Location,
                         pDestTexture->Location));
        }
    }
#if DX7_TEXMANAGEMENT              
    else if (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        //----------------------------------
        //----------------------------------
        // TEXBLT from a managed texture
        //----------------------------------
        //----------------------------------

        if ((pDestTexture->Location == SystemMemory) ||
            (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
        {
            //-------------------------------------------------
            // Do the Managed surf -> sysmem | managed surf blt
            //-------------------------------------------------    

            // make sure we'll reload the vidmem copy of the dest surf
            if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                __OP_MarkManagedSurfDirty(pContext,
                                          dwDestSurfHandle,
                                          pDestTexture);                                              
            }

            _DD_BLT_SysMemToSysMemCopy(
                        pSrcTexture->fpVidMem,
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc,
                        prDest);
        }
        else if (pDestTexture->Location == VideoMemory) 
        {
            //-------------------------------------------------
            // Do the Managed surf -> vidmem surf blt
            //-------------------------------------------------                  

            // This might be optimized by doing a vidmem->vidmem 
            // when the source managed texture has a vidmem copy
            
            _DD_P3Download(pThisDisplay,
                           pSrcTexture->fpVidMem,
                           pDestTexture->fpVidMem,
                           pSrcTexture->dwPatchMode,
                           pDestTexture->dwPatchMode,
                           pSrcTexture->lPitch,
                           pDestTexture->lPitch,                                                             
                           pDestTexture->dwPixelPitch,
                           pDestTexture->dwPixelSize,
                           prSrc,
                           prDest);                                          
        }
        else            
        {
            DISPDBG((ERRLVL,"Src-managed __OP_BasicVolumeBlt variation "
                            "unimplemented! (from %d into %d)",
                            pSrcTexture->Location,
                            pDestTexture->Location));
        }
        
        
    }
    else if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        //--------------------------------------------------------------
        //--------------------------------------------------------------
        // TEXBLT into a managed texture (except from a managed texture)
        //--------------------------------------------------------------
        //--------------------------------------------------------------

        // managed->managed is handled in the previous case

        if (pSrcTexture->Location == SystemMemory)
        {                
            //-------------------------------------------------
            // Do the sysmem surf -> managed surf blt
            //-------------------------------------------------    

            // make sure we'll reload the vidmem copy of the dest surf
            __OP_MarkManagedSurfDirty(pContext,
                                      dwDestSurfHandle,
                                      pDestTexture);                                              
                                                          
            _DD_BLT_SysMemToSysMemCopy(
                        pSrcTexture->fpVidMem,
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc, 
                        prDest);
        }
        else if (pSrcTexture->Location == VideoMemory)                
        {
            //-------------------------------------------------
            // Do the vidmem surf -> Managed surf blt
            //-------------------------------------------------                                  

              if (0 != pSrcTexture->MipLevels[0].fpVidMemTM)
            {
                // Destination is already in vidmem so instead of
                // "dirtying" the managed texture lets do the
                // vidmem->vidmem blt which is faster than doing the
                // update later (in the hope we'll really use it)

                _DD_BLT_P3CopyBlt(pThisDisplay,
                                  pSrcTexture->fpVidMem,
                                  pDestTexture->MipLevels[0].fpVidMemTM,
                                  pSrcTexture->dwPatchMode,
                                  pDestTexture->dwPatchMode,
                                  pSrcTexture->dwPixelPitch,
                                  pDestTexture->dwPixelPitch,
                                  pSrcTexture->MipLevels[0].dwOffsetFromMemoryBase,                                 
                                  pDestTexture->MipLevels[0].dwOffsetFromMemoryBase,
                                  pDestTexture->dwPixelSize,
                                  prSrc,
                                  prDest);                        
            } 
            else
            {
                // make sure we'll reload the 
                // vidmem copy of the dest surf
                __OP_MarkManagedSurfDirty(pContext,
                                          dwDestSurfHandle,
                                          pDestTexture);   
            }

            // Do slow mem mapped framebuffer blt into sysmem
            // The source surface lives in video mem so we need to get a
            // "real" sysmem address for it:                    
            _DD_BLT_SysMemToSysMemCopy(
                        D3DSURF_GETPOINTER(pSrcTexture, pThisDisplay),
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc,
                        prDest);
        }
        else if (pSrcTexture->Location == AGPMemory)                     
        {
            // make sure we'll reload the vidmem copy of the dest surf
            __OP_MarkManagedSurfDirty(pContext,
                                      dwDestSurfHandle,
                                      pDestTexture);                                              
        
            _DD_BLT_SysMemToSysMemCopy(
                        pSrcTexture->fpVidMem,
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc,
                        prDest);                
        }
        else            
        {
            DISPDBG((ERRLVL,"Dest-managed __OP_BasicVolumeBlt variation "
                            "unimplemented! (from %d into %d)",
                            pSrcTexture->Location,
                            pDestTexture->Location));
        }
        
    }
    else            
    {
        DISPDBG((ERRLVL,"__OP_BasicVolumeBlt variation unimplemented! "
                        "(from %d into %d)",
                        pSrcTexture->Location,
                        pDestTexture->Location));
    }
#endif // DX7_TEXMANAGEMENT        


} // __OP_BasicVolumeBlt

//-----------------------------------------------------------------------------
//
// _D3D_OP_VolumeBlt
//
// This function processes the D3DDP2OP_VOLUMEBLT DP2 command token.
//
//-----------------------------------------------------------------------------   
VOID _D3D_OP_VolumeBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2VOLUMEBLT* pBlt)
{
    LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL pDestLcl;
    P3_SURF_INTERNAL* pSrcTexture;
    P3_SURF_INTERNAL* pDestTexture;
    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest;
    RECTL rSrc, rDest;
    DWORD dwSrcCurrDepth, dwDestCurrDepth, dwEndDepth;

    // Get the texture structure pointers
    pSrcTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDSrcSurface);
    pDestTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDDestSurface);
    
    // Check that the textures are valid
    if (pSrcTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Source texture %d is invalid!",
                         pBlt->dwDDSrcSurface));
        return;
    }

    if (pDestTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Dest texture %d is invalid!",
                         pBlt->dwDDDestSurface));
        return;
    }

    // If we are going to blt 3D texture, both have to be 3D texture
    if ((pSrcTexture->b3DTexture == FALSE) != (pDestTexture->b3DTexture == FALSE))
    {
        DISPDBG((ERRLVL, "ERROR: TEXBLT b3DTexture (%d %d)does not match!",
                         pSrcTexture->b3DTexture,
                         pDestTexture->b3DTexture));
        return;
    }

    // Do we blt whole 3D texture ?
    if ((pBlt->srcBox.Left    == 0) &&
        (pBlt->srcBox.Top     == 0) &&
        (pBlt->srcBox.Right   == pSrcTexture->wWidth) &&
        (pBlt->srcBox.Bottom  == pSrcTexture->wHeight) &&
        (pBlt->srcBox.Front   == 0) &&
        (pBlt->srcBox.Back    == pSrcTexture->wDepth) &&
        (pBlt->dwDestX        == 0) &&
        (pBlt->dwDestY        == 0) &&
        (pBlt->dwDestZ        == 0) &&
        (pSrcTexture->wWidth  == pDestTexture->wWidth) &&
        (pSrcTexture->wHeight == pDestTexture->wHeight) &&
        (pSrcTexture->wDepth  == pDestTexture->wDepth))
    {
        // Build source rectangle

        rSrc.left   = 0;
        rSrc.top    = 0;
        rSrc.right  = pBlt->srcBox.Right;
        rSrc.bottom = pBlt->srcBox.Bottom * pBlt->srcBox.Back;

        // Destination rectangle is same as source.

        rDest = rSrc;

        // Switch to the DirectDraw context
        DDRAW_OPERATION(pContext, pThisDisplay);

        // Do the Blt!
        __OP_BasicVolumeBlt(pContext,
                            pThisDisplay,
                            pSrcTexture,
                            pDestTexture,
                            pBlt->dwDDDestSurface,
                            &rSrc,
                            &rDest);                                
      
        // Switch back to the Direct3D context
        D3D_OPERATION(pContext, pThisDisplay);

        return;
    }

    // Build source rectangle.
    rSrc.left   = pBlt->srcBox.Left;
    rSrc.top    = pBlt->srcBox.Top;
    rSrc.right  = pBlt->srcBox.Right;
    rSrc.bottom = pBlt->srcBox.Bottom;

    // Build destination rectangle.
    rDest.left   = pBlt->dwDestX;
    rDest.top    = pBlt->dwDestY;
    rDest.right  = pBlt->dwDestX + (rSrc.right - rSrc.left);
    rDest.bottom = pBlt->dwDestY + (rSrc.bottom - rSrc.top);

    // Adjust rectangle if blt from non-1st slice.
    if (pBlt->srcBox.Front)
    {
        ULONG ulOffset = pSrcTexture->wDepth * pBlt->srcBox.Front;
        rSrc.top    += ulOffset;
        rSrc.bottom += ulOffset;
    }

    // Adjust rectangle if blt to non-1st slice.
    if (pBlt->dwDestZ)
    {
        ULONG ulOffset = pDestTexture->wDepth * pBlt->dwDestZ;
        rDest.top    += ulOffset;
        rDest.bottom += ulOffset;
    }

    dwSrcCurrDepth  = pBlt->srcBox.Front;
    dwDestCurrDepth = pBlt->dwDestZ;

    dwEndDepth   = min(pBlt->dwDestZ + (pBlt->srcBox.Back - pBlt->srcBox.Front),
                       pDestTexture->wDepth);
    dwEndDepth   = min(dwEndDepth, pSrcTexture->wDepth);

    while(dwDestCurrDepth < dwEndDepth)
    {
        // Switch to the DirectDraw context
        DDRAW_OPERATION(pContext, pThisDisplay);

        // Do the Blt!
        __OP_BasicVolumeBlt(pContext,
                            pThisDisplay,
                            pSrcTexture,
                            pDestTexture,
                            pBlt->dwDDDestSurface,
                            &rSrc,
                            &rDest);  
                            
        // Switch back to the Direct3D context
        D3D_OPERATION(pContext, pThisDisplay);

        // Move the source and destination rect to next slice.
        rSrc.top     += pSrcTexture->wDepth;
        rSrc.bottom  += pSrcTexture->wDepth;
        rDest.top    += pDestTexture->wDepth;
        rDest.bottom += pDestTexture->wDepth;

        // Move on to next slice.
        dwSrcCurrDepth++;
        dwDestCurrDepth++;
    }
} // _D3D_OP_VolumeBlt

#endif // DX8_3DTEXTURES

#if DX8_DDI  

//-----------------------------------------------------------------------------
//
// _D3D_OP_BufferBlt
//
// This function processes the D3DDP2OP_BUFFERBLT DP2 command token.
//
//-----------------------------------------------------------------------------   
VOID _D3D_OP_BufferBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2BUFFERBLT* pBlt)
{

#if DX7_VERTEXBUFFERS
    // This command token is only sent to drivers 
    // supporting videomemory vertexbuffers. That is
    // why we won't see it come down to this driver.
#endif DX7_VERTEXBUFFERS

} // _D3D_OP_BufferBlt

#endif // DX8_DDI 

#if DX8_VERTEXSHADERS
//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_Create
//
// This function processes the D3DDP2OP_CREATEVERTEXSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_OP_VertexShader_Create(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVtxShaderHandle,
    DWORD dwDeclSize,
    DWORD dwCodeSize,
    BYTE *pShader)
{
    // Here we would use the data passed by the vertex shader
    // creation block in order to instantiate or compile the
    // given vertex shader. Since this hardware can't support
    // vertex shaders at this time, we just skip the data.
    
    return DD_OK;
    
} // _D3D_OP_VertexShader_Create

//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_Delete
//
// This function processes the D3DDP2OP_DELETEVERTEXSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_VertexShader_Delete(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVtxShaderHandle)
{
    // Here we would use the data passed by the vertex shader
    // delete block in order to destroy the given vertex shader.
    // Since this hardware can't support vertex shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_VertexShader_Delete

#define RDVSD_ISLEGACY(ShaderHandle) !(ShaderHandle & D3DFVF_RESERVED0)

//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_Set
//
// This function processes the D3DDP2OP_SETVERTEXSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_VertexShader_Set(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVtxShaderHandle)
{
    // Here we would use the data passed by the vertex shader
    // set block in order to setup the given vertex shader.
    // Since this hardware can't support vertex shaders at 
    // this time, we usually just skip the data. However under
    // the circumstances described below, we might be passed a
    // FVF vertex format

    DISPDBG((DBGLVL,"Setting up shader # 0x%x",dwVtxShaderHandle));

#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode ) 
    {
        _D3D_SB_Record_VertexShader_Set(pContext, dwVtxShaderHandle);
        return;
    }
#endif // DX7_D3DSTATEBLOCKS

    // Zero is a special handle that tells the driver to
    // invalidate the currently set shader.
    if( dwVtxShaderHandle == 0 )
    {
        DISPDBG((WRNLVL,"Invalidating the currently set shader"));
        return ;
    }    

    if( RDVSD_ISLEGACY(dwVtxShaderHandle) )
    {
        // Make it parse the FVF 
        pContext->dwVertexType = dwVtxShaderHandle;  
    }  
    else
    {
        DISPDBG((ERRLVL,"_D3D_OP_VertexShader_Set: Illegal shader handle "
                        "(This driver cant do vertex processing)"));
    }
    
} // _D3D_OP_VertexShader_Set

//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_SetConst
//
// This function processes the D3DDP2OP_SETVERTEXSHADERCONST DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_VertexShader_SetConst(
    P3_D3DCONTEXT* pContext, 
    DWORD dwRegister, 
    DWORD dwConst, 
    DWORD *pdwValues)
{
    // Here we would use the data passed by the vertex shader
    // constant block in order to set up the constant entry.
    // Since this hardware can't support vertex shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_VertexShader_SetConst

#endif // DX8_VERTEXSHADERS

#if DX8_PIXELSHADERS

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_Create
//
// This function processes the D3DDP2OP_CREATEPIXELSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_OP_PixelShader_Create(
    P3_D3DCONTEXT* pContext, 
    DWORD dwPxlShaderHandle,
    DWORD dwCodeSize,
    BYTE *pShader)
{
    // Here we would use the data passed by the pixel shader
    // creation block in order to instantiate or compile the
    // given pixel shader. 

    // Since this hardware can't support pixel shaders at this 
    // time, we fail the call in case we're called to create a
    // 255.255 version shader!

    return D3DERR_DRIVERINVALIDCALL;
    
} // _D3D_OP_PixelShader_Create

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_Delete
//
// This function processes the D3DDP2OP_DELETEPIXELSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_PixelShader_Delete(
    P3_D3DCONTEXT* pContext, 
    DWORD dwPxlShaderHandle)
{
    // Here we would use the data passed by the pixel shader
    // delete block in order to destroy the given pixel shader.
    // Since this hardware can't support pixel shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_PixelShader_Delete

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_Set
//
// This function processes the D3DDP2OP_SETPIXELSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_PixelShader_Set(
    P3_D3DCONTEXT* pContext, 
    DWORD dwPxlShaderHandle)
{
    // Here we would use the data passed by the pixel shader
    // set block in order to setup the given pixel shader.
    // Since this hardware can't support pixel shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_PixelShader_Set

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_SetConst
//
// This function processes the D3DDP2OP_SETPIXELSHADERCONST DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_PixelShader_SetConst(
    P3_D3DCONTEXT* pContext, 
    DWORD dwRegister, 
    DWORD dwCount, 
    DWORD *pdwValues)
{
    // Here we would use the data passed by the pixel shader
    // set block in order to setup the given pixel shader constants.
    // Since this hardware can't support pixel shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_PixelShader_SetConst
#endif // DX8_PIXELSHADERS

#if DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_SetSrc
//
// This function processes the D3DDP2OP_SETSTREAMSOURCE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_MStream_SetSrc(
    P3_D3DCONTEXT* pContext, 
    DWORD dwStream,
    DWORD dwVBHandle,
    DWORD dwStride)
{
    P3_SURF_INTERNAL *pSrcStream;
    
    DBG_ENTRY(_D3D_OP_MStream_SetSrc);

#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode ) 
    {
        _D3D_SB_Record_MStream_SetSrc(pContext, dwStream, dwVBHandle, dwStride);
        return;
    }
#endif // DX7_D3DSTATEBLOCKS

    if (dwVBHandle != 0)
    {
        if (dwStream == 0)
        {
            // Get the surface structure pointers for stream #0
            pSrcStream = GetSurfaceFromHandle(pContext, dwVBHandle);

            if (pSrcStream)
            {
                DISPDBG((DBGLVL,"Address of VB = 0x%x "
                                "dwVBHandle = %d , dwStride = %d",
                                pSrcStream->fpVidMem,dwVBHandle, dwStride));
                pContext->lpVertices = (LPDWORD)pSrcStream->fpVidMem;
                pContext->dwVerticesStride = dwStride;

                if (dwStride > 0)
                {
                    // DX8 has mixed types of vertices in one VB, size in bytes
                    // of the vertex buffer must be preserved
                    pContext->dwVBSizeInBytes = pSrcStream->lPitch;

                    // for VBs the wHeight should always be == 1.
                    // dwNumVertices stores the # of vertices in the VB
                    // On Win2K, both wWidth and lPitch are the buffer size
                    // On Win9x, only lPitch is the buffer size, wWidth is 0
                    // The same fact is also true for the index buffer
                    pContext->dwNumVertices = pSrcStream->lPitch / dwStride;

                    DISPDBG((DBGLVL,"dwVBHandle pContext->dwNumVertices = "
                                "pSrcStream->lPitch / dwStride = %d %d %d %d",
                                dwVBHandle,
                                pContext->dwNumVertices, 
                                pSrcStream->lPitch,dwStride));  
                    
#if DX7_D3DSTATEBLOCKS
                    pContext->dwVBHandle = dwVBHandle;
#endif // DX7_D3DSTATEBLOCKS
                }
                else
                {
                    pContext->dwVBSizeInBytes = 0;
                    pContext->dwNumVertices = 0;
                    DISPDBG((ERRLVL,"INVALID Stride is 0. VB Size undefined"));
                }
            }
            else
            {
                DISPDBG((ERRLVL,"ERROR Address of VB is NULL, "
                                "dwStream = %d dwVBHandle = %d , dwStride = %d",
                                dwStream, dwVBHandle, dwStride));
            }
        }
        else
        {
            DISPDBG((WRNLVL,"We don't handle other streams than #0"));
        }
    }
    else
    {
        // We are unsetting the stream
        pContext->lpVertices = NULL;

        DISPDBG((WRNLVL,"Unsetting a stream: "
                        "dwStream = %d dwVBHandle = %d , dwStride = %d",
                        dwStream, dwVBHandle, dwStride));
    }

    DBG_EXIT(_D3D_OP_MStream_SetSrc, 0);
} // _D3D_OP_MStream_SetSrc

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_SetSrcUM
//
// This function processes the D3DDP2OP_SETSTREAMSOURCEUM DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_SetSrcUM(
    P3_D3DCONTEXT* pContext, 
    DWORD dwStream,
    DWORD dwStride,
    LPBYTE pUMVtx,
    DWORD  dwVBSize)
{
    DBG_ENTRY(_D3D_OP_MStream_SetSrcUM);

    if (dwStream == 0)
    {
        // Set the stream # 0 information
        DISPDBG((DBGLVL,"_D3D_OP_MStream_SetSrcUM: "
                        "Setting VB@ 0x%x dwstride=%d", pUMVtx, dwStride));
        pContext->lpVertices = (LPDWORD)pUMVtx;
        pContext->dwVerticesStride = dwStride;
        pContext->dwVBSizeInBytes = dwVBSize  * dwStride;
        pContext->dwNumVertices = dwVBSize ;     // comes from the DP2 data 
                                                 // structure
    
    }
    else
    {
        DISPDBG((WRNLVL,"_D3D_OP_MStream_SetSrcUM: "
                        "We don't handle other streams than #0"));
    }
    
    DBG_EXIT(_D3D_OP_MStream_SetSrcUM, 0);
} // _D3D_OP_MStream_SetSrcUM

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_SetIndices
//
// This function processes the D3DDP2OP_SETINDICES DP2 command token.
//
//-----------------------------------------------------------------------------             
VOID
_D3D_OP_MStream_SetIndices(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVBHandle,
    DWORD dwStride)
{
    P3_SURF_INTERNAL *pIndxStream;
    
    DBG_ENTRY(_D3D_OP_MStream_SetIndices);

#if DX7_D3DSTATEBLOCKS    
    if ( pContext->bStateRecMode )
    {
        _D3D_SB_Record_MStream_SetIndices(pContext, dwVBHandle, dwStride);
        return;
    }
#endif // DX7_D3DSTATEBLOCKS    

    // NULL dwVBHandle just means that the Index should be unset
    if (dwVBHandle != 0)
    {
        // Get the indices surface structure pointer
        pIndxStream = GetSurfaceFromHandle(pContext, dwVBHandle);

        if (pIndxStream)
        {
            DISPDBG((DBGLVL,"Address of VB = 0x%x", pIndxStream->fpVidMem));

            pContext->lpIndices = (LPDWORD)pIndxStream->fpVidMem;
            pContext->dwIndicesStride = dwStride; // 2 or 4 for 16/32bit indices
#if DX7_D3DSTATEBLOCKS
            pContext->dwIndexHandle = dwVBHandle; // Index buffer handle
#endif
        }
        else
        {
            DISPDBG((ERRLVL,"ERROR Address of Index Surface is NULL, "
                            "dwVBHandle = %d , dwStride = %d",
                             dwVBHandle, dwStride));
        }
    }
    else
    {
        // We are unsetting the stream
        pContext->lpIndices = NULL;

        DISPDBG((WRNLVL,"Unsetting an index stream: "
                        "dwVBHandle = %d , dwStride = %d",
                         dwVBHandle, dwStride));
    }
    
    DBG_EXIT(_D3D_OP_MStream_SetIndices, 0);
} // _D3D_OP_MStream_SetIndices

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawPrim
//
// This function processes the D3DDP2OP_DRAWPRIMITIVE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_DrawPrim(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    DWORD VStart,
    DWORD PrimitiveCount)
{
    DBG_ENTRY(_D3D_OP_MStream_DrawPrim);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawPrim "
               "primType=0x%x VStart=%d PrimitiveCount=%d", 
               primType, VStart, PrimitiveCount));

   _D3D_OP_MStream_DrawPrim2(pContext, 
                             primType,
                             VStart * pContext->FVFData.dwStride,
                             PrimitiveCount);
    
    DBG_EXIT(_D3D_OP_MStream_DrawPrim, 0);
} // _D3D_OP_MStream_DrawPrim

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawIndxP
//
// This function processes the D3DDP2OP_DRAWINDEXEDPRIMITIVE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_DrawIndxP(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    DWORD BaseVertexIndex,
    DWORD MinIndex,
    DWORD NumVertices,
    DWORD StartIndex,
    DWORD PrimitiveCount)
{
    DBG_ENTRY(_D3D_OP_MStream_DrawIndxP);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawIndxP " 
               "primType=0x%x BaseVertexIndex=%d MinIndex=%d"
               "NumVertices =%d StartIndex=%d PrimitiveCount=%d", 
               primType, BaseVertexIndex, MinIndex,
               NumVertices, StartIndex, PrimitiveCount));

    _D3D_OP_MStream_DrawIndxP2(pContext, 
                               primType,
                               BaseVertexIndex * pContext->FVFData.dwStride,
                               MinIndex,
                               NumVertices,
                               StartIndex * pContext->dwIndicesStride,
                               PrimitiveCount);
                               
    DBG_EXIT(_D3D_OP_MStream_DrawIndxP, 0);
} // _D3D_OP_MStream_DrawIndxP

//-----------------------------------------------------------------------------
//
// Validate the context settings to use the current streams
//
//-----------------------------------------------------------------------------
BOOL
__OP_ValidateStreams(
    P3_D3DCONTEXT* pContext,
    BOOL bCheckIndexStream)
{
    if ((pContext->dwVerticesStride == 0) || 
        (pContext->FVFData.dwStride == 0))
    {
        DISPDBG((ERRLVL,"The zero'th stream is doesn't have a valid VB set"));
        return FALSE;        
    }

    if (pContext->dwVerticesStride < pContext->FVFData.dwStride)
    {
        DISPDBG((ERRLVL,"The stride set for the vertex stream is "
                        "less than the FVF vertex size"));
        return FALSE;
    }

//@@BEGIN_DDKSPLIT
    // This shouldn't happen, but lets watch for it since it would show
    // up as weird mangled & distorted triangles
    if (pContext->dwVerticesStride != pContext->FVFData.dwStride)
    {
        DISPDBG((ERRLVL,"Strides(indx-prim) <> %d %d ",
                         pContext->dwVerticesStride,pContext->FVFData.dwStride));
    }
//@@END_DDKSPLIT    

    if ((bCheckIndexStream) && (NULL == pContext->lpIndices))
    {
        DISPDBG((ERRLVL,"Pointer to index buffer is null"));
        return FALSE;    
    }

    if (NULL == pContext->lpVertices)
    {
        DISPDBG((ERRLVL,"Pointer to vertex buffer is null"));
        return FALSE;       
    }

    return TRUE;
} // __OP_ValidateStreams

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawPrim2
//
// This function processes the D3DDP2OP_DRAWPRIMITIVE2 DP2 command token.
//
//-----------------------------------------------------------------------------

VOID
_D3D_OP_MStream_DrawPrim2(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    DWORD FirstVertexOffset,
    DWORD PrimitiveCount)
{
    BOOL bError;
    WORD wVStart;
    DWORD dwFillMode = pContext->RenderStates[D3DRENDERSTATE_FILLMODE];
    LPBYTE lpVertices;
    DWORD dwNumVertices;

    DBG_ENTRY(_D3D_OP_MStream_DrawPrim2);

    DISPDBG((DBGLVL ,"_D3D_OP_MStream_DrawPrim2 "
               "primType=0x%x FirstVertexOffset=%d PrimitiveCount=%d", 
               primType, FirstVertexOffset, PrimitiveCount));

    if (!__OP_ValidateStreams(pContext, FALSE))
    {
        return;
    }

    // Watchout: Sometimes (particularly when CLIPPEDTRIFAN are drawn), 
    // FirstVertexOffset might not be divided evenly by the dwStride
    lpVertices = ((LPBYTE)pContext->lpVertices) + FirstVertexOffset;
    dwNumVertices = pContext->dwVBSizeInBytes - FirstVertexOffset;
    dwNumVertices /= pContext->dwVerticesStride;
    wVStart = 0;
    
    switch(primType)
    {
        case D3DPT_POINTLIST:
            {
                D3DHAL_DP2POINTS dp2Points;
                dp2Points.wVStart = wVStart;
                
#if DX8_POINTSPRITES
                if(IS_POINTSPRITE_ACTIVE(pContext))
                {
                    _D3D_R3_DP2_PointsSprite_DWCount(pContext,
                                                     PrimitiveCount,
                                                     (LPBYTE)&dp2Points,
                                                     (LPD3DTLVERTEX)lpVertices,
                                                     dwNumVertices,
                                                     &bError);
                }
                else
#endif // DX8_POINTSPRITES
                {
                  
                    _D3D_R3_DP2_Points_DWCount(pContext,
                                               PrimitiveCount,
                                               (LPBYTE)&dp2Points,
                                               (LPD3DTLVERTEX)lpVertices,
                                               dwNumVertices,
                                               &bError);

                }  
            
            }
            break;
                
        case D3DPT_LINELIST:

            _D3D_R3_DP2_LineList(pContext,
                                 PrimitiveCount,
                                 (LPBYTE)&wVStart,
                                 (LPD3DTLVERTEX)lpVertices,
                                 dwNumVertices,
                                 &bError);
            break;        
            
        case D3DPT_LINESTRIP:

            _D3D_R3_DP2_LineStrip(pContext,
                                 PrimitiveCount,
                                 (LPBYTE)&wVStart,
                                 (LPD3DTLVERTEX)lpVertices,
                                 dwNumVertices,
                                 &bError);
            break;   
            
        case D3DPT_TRIANGLELIST:        

            _D3D_R3_DP2_TriangleList(pContext,
                                     PrimitiveCount,
                                     (LPBYTE)&wVStart,
                                     (LPD3DTLVERTEX)lpVertices,
                                     dwNumVertices,
                                     &bError);
            break;  
            
        case D3DPT_TRIANGLESTRIP:
        
            _D3D_R3_DP2_TriangleStrip(pContext,
                                     PrimitiveCount,
                                     (LPBYTE)&wVStart,
                                     (LPD3DTLVERTEX)lpVertices,
                                     dwNumVertices,
                                     &bError);        
            break; 
            
        case D3DPT_TRIANGLEFAN:
        
            _D3D_R3_DP2_TriangleFan(pContext,
                                    PrimitiveCount,
                                    (LPBYTE)&wVStart,
                                    (LPD3DTLVERTEX)lpVertices,
                                    dwNumVertices,
                                    &bError);
            break;         
    }
    
    DBG_EXIT(_D3D_OP_MStream_DrawPrim2, 0);
} // _D3D_OP_MStream_DrawPrim2

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawIndxP2
//
// This function processes the D3DDP2OP_DRAWINDEXEDPRIMITIVE2 DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_DrawIndxP2(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    INT   BaseVertexOffset,
    DWORD MinIndex,
    DWORD NumVertices,
    DWORD StartIndexOffset,
    DWORD PrimitiveCount)
{
    INT      BaseIndexOffset;
    LPDWORD  lpVertices;
    LPBYTE   lpIndices;
    BOOL bError;

    R3_DP2_PRIM_TYPE_MS *pRenderFunc; 
    
    DBG_ENTRY(_D3D_OP_MStream_DrawIndxP2);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawIndxP2 "
               "primType=0x%x BaseVertexOffset=%d MinIndex=%d "
               "NumVertices=%d StartIndexOffset=%d PrimitiveCount=%d", 
               primType, BaseVertexOffset, MinIndex,
               NumVertices, StartIndexOffset, PrimitiveCount));

    if (!__OP_ValidateStreams(pContext, TRUE))
    {
        return;
    }

    // The MinIndex and NumVertices parameters specify the range of vertex i
    // ndices used for each DrawIndexedPrimitive call. These are used to 
    // optimize vertex processing of indexed primitives by processing a 
    // sequential range of vertices prior to indexing into these vertices

    // **********                IMPORTANT NOTE               **********
    //
    // BaseVertexOffset is a signed quantity (INT) unlike the other parameters
    // to this call which are DWORDS. This may appear strange. Why would
    // the offset into the vertex buffer be negative? Clearly you cannot access
    // vertex data before the start of the vertex buffer, and indeed, you never
    // do. When you have a negative BaseVertexOffset you will also receive
    // indices which are large enough that when applied to the start pointer
    // (obtained from adding a negative BaseVertexOffset to the vertex data
    // pointer) which fall within the correct range of the vertices in the
    // actual vertex buffer, i.e., the indices "undo" any negative vertex offset
    // and vertex accesses will end up being in the legal range for that vertex
    // buffer.
    //
    // Hence, you must write your driver code with this in mind. For example,
    // you can't assume that given an index i and with a current vertex buffer
    // of size v:
    //
    // ((StartIndexOffset + i) >= 0) && ((StartIndexOffset + i) < v)
    //
    // Your code needs to take into account that your indices are not offsets
    // from the start of the vertex buffer but rather from the start of the
    // vertex buffer plus BaseVertexOffset and that furthermore BaseVertexOffset
    // may be negative.
    //
    // The reason BaseVertexOffset can be negative is that it provides a
    // significant advantage to the runtime in certain vertex processing scenarios.

    lpVertices = (LPDWORD)((LPBYTE)pContext->lpVertices + BaseVertexOffset);

    lpIndices =  (LPBYTE)pContext->lpIndices + StartIndexOffset;  


    // Select the appropriate rendering function
    pRenderFunc = NULL;
    
    if (pContext->dwIndicesStride == 2)
    {   
        // Handle 16 bit indices
                                      
        switch(primType)
        {                    
            case D3DPT_LINELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedLineList_MS_16IND;
                break;        
                
            case D3DPT_LINESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedLineStrip_MS_16IND;            
                break;   
                
            case D3DPT_TRIANGLELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleList_MS_16IND;  
                break;
                
            case D3DPT_TRIANGLESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND;  
                break;            
                
            case D3DPT_TRIANGLEFAN:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleFan_MS_16IND;  
                break;                        
        }
    }
    else
    {
        // Handle 32 bit indices

        switch(primType)
        {                    
            case D3DPT_LINELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedLineList_MS_32IND;
                break;        
                
            case D3DPT_LINESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedLineStrip_MS_32IND;            
                break;   
                
            case D3DPT_TRIANGLELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleList_MS_32IND;  
                break;
                
            case D3DPT_TRIANGLESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND;  
                break;            
                
            case D3DPT_TRIANGLEFAN:
                pRenderFunc = _D3D_R3_D