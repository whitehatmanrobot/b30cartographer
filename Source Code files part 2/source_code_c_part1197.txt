;

    } else {

        status = STATUS_DEVICE_POWER_FAILURE;
    }
#else 

    status = STATUS_SUCCESS;

#endif // DONT_POWER_DOWN_PAGING_DEVICE


    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp (Irp);

    if (deviceExtensionHeader->AttacheeDeviceObject != NULL) {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        status = PoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);
    }
    else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }


    return status;
}


NTSTATUS
PciIdeSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS           status;

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        irpStack = IoGetCurrentIrpStackLocation (Irp);
        status   = STATUS_SUCCESS;
    
        if (irpStack->Parameters.Power.Type == SystemPowerState) {
    
            if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {
    
                POWER_STATE powerState;
    
                pdoExtension->SystemPowerState = irpStack->Parameters.Power.State.SystemState;
    
                DebugPrint ((1, "PciIdeX: New Pdo 0x%x system power state 0x%x\n", pdoExtension->ChannelNumber, irpStack->Parameters.Power.State.SystemState));
            }
    
        } else if (irpStack->Parameters.Power.Type == DevicePowerState) {
    
            if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
    
                //
                // checking old device state
                //
                if (pdoExtension->DevicePowerState == PowerDeviceD3) {
    
                    //
                    // waking up
                    //
                    IoMarkIrpPending(Irp);
                    Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;
                    status  = FdoChildRequestPowerUp (
                                  pdoExtension->ParentDeviceExtension,
                                  pdoExtension,
                                  Irp
                                  );
                    ASSERT (NT_SUCCESS(status));
                    status = STATUS_PENDING;
    
                } else {
    
                    if (pdoExtension->DevicePowerState == PowerDeviceD0) {
    
                        //
                        // getting out of D0 state, better call PoSetPowerState now
                        //
                        PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );
                    } 
                    
                    DebugPrint ((1, "PciIdeX: New Pdo 0x%x device power state 0x%x\n", pdoExtension->ChannelNumber, irpStack->Parameters.Power.State.DeviceState));
    
                    pdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;
        
                    if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {
        
                        //
                        // tell parent that we just fell to sleep
                        //
                        FdoChildReportPowerDown (
                            pdoExtension->ParentDeviceExtension,
                            pdoExtension
                            );
                    }
                }
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (status != STATUS_PENDING) {

        if (NT_SUCCESS(status)) {

            Irp->IoStatus.Information = irpStack->Parameters.Power.State.SystemState;
        }
        Irp->IoStatus.Status = status;

        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
} // PciIdeSetPdoPowerState

NTSTATUS
PciIdeSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status = STATUS_SUCCESS;
    PCTRLFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PFDO_POWER_CONTEXT context;
    BOOLEAN            noCompletionRoutine;
    BOOLEAN            systemPowerContext = FALSE;
    BOOLEAN            devicePowerContext = FALSE;

    fdoExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //context = ExAllocatePool (NonPagedPool, sizeof(FDO_POWER_CONTEXT));

    //
    // We need two pre-alloced context structures. This is because a system power irp
    // would result in a device power irp to be issued before the former is completed.
    // 
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[0]);
        systemPowerContext = TRUE;

    } else {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[1]);
        devicePowerContext = TRUE;

    }

    if (context == NULL) {
        
        ASSERT(context);
        status = STATUS_NO_MEMORY;
    } else {

        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        //irpStack = IoGetCurrentIrpStackLocation (Irp);

        context->OriginalPowerIrp = Irp;
        context->newPowerType     = irpStack->Parameters.Power.Type;
        context->newPowerState    = irpStack->Parameters.Power.State;
    
        noCompletionRoutine = FALSE;

        if (irpStack->Parameters.Power.Type == SystemPowerState) {
    
            if (fdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

                POWER_STATE powerState;
                BOOLEAN requestPowerState = FALSE;

                if ((irpStack->Parameters.Power.State.SystemState == PowerSystemShutdown) &&
                    (irpStack->Parameters.Power.ShutdownType == PowerActionShutdownReset)) {

                    //
                    // spin up for BIOS POST
                    //
                    requestPowerState = TRUE;
                    powerState.DeviceState = PowerDeviceD0;

                } else if (fdoExtension->SystemPowerState == PowerSystemWorking) {

                    //
                    // we are getting out of working state...power down
                    //
                    requestPowerState = TRUE;
                    powerState.DeviceState = PowerDeviceD3;
                }

                if (requestPowerState) {

                    IoMarkIrpPending(Irp);
                       
                    PoRequestPowerIrp (
                        fdoExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        FdoContingentPowerCompletionRoutine,
                        context,
                        NULL
                        );
    
                    return STATUS_PENDING;
                }


            } else {

                //
                // We are already in the given state
                //
                noCompletionRoutine = TRUE;
            }
    
        } else if (irpStack->Parameters.Power.Type == DevicePowerState) {
    
            if (fdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
    
                if (fdoExtension->DevicePowerState == PowerDeviceD0) {
    
                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State
                        );
                }

            } else {

                //
                // We are already in the given state
                //
                noCompletionRoutine = TRUE;
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (NT_SUCCESS(status)) {
    
		IoMarkIrpPending (Irp);

        IoCopyCurrentIrpStackLocationToNext (Irp);
    
        if (!noCompletionRoutine) {
        
            IoSetCompletionRoutine(Irp,
                                   FdoPowerCompletionRoutine,
                                   context,
                                   TRUE,
                                   TRUE,
                                   TRUE);
        } else {
        
            if (context) {
                //ExFreePool (context);
                if (systemPowerContext) {
                    ASSERT(devicePowerContext == FALSE);
                    ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);

                }

                if (devicePowerContext) {
                    ASSERT(systemPowerContext == FALSE);
                    ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
                }
            }
            PoStartNextPowerIrp (Irp);
        }
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
        return STATUS_PENDING;

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;

        if (context) {
            //ExFreePool (context);
            if (systemPowerContext) {
                ASSERT(devicePowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);

            }

            if (devicePowerContext) {
                ASSERT(systemPowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
            }
        }

        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }
} // PciIdeSetFdoPowerState

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDO_POWER_CONTEXT context = Context;
    PIRP irp;
    PCTRLFDO_EXTENSION fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

    irp = context->OriginalPowerIrp;

    if (NT_SUCCESS(IoStatus->Status)) {


        IoCopyCurrentIrpStackLocationToNext (irp);
    
        IoSetCompletionRoutine(irp,
                               FdoPowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, irp);

    } else {

        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = IoStatus->Status;
        //ExFreePool (context);
        ASSERT(context->newPowerType == SystemPowerState);
        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);

        PoStartNextPowerIrp (irp);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return IoStatus->Status;
} // FdoContingentPowerCompletionRoutine


NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState = FALSE;
    PCTRLFDO_EXTENSION fdoExtension;
    POWER_STATE        newPowerState;
    POWER_STATE_TYPE   newPowerType;
    BOOLEAN            unlocked = FALSE;
	BOOLEAN			   moreProcessingRequired = FALSE;
	NTSTATUS		   status;

    fdoExtension = DeviceObject->DeviceExtension;
    newPowerType = context->newPowerType;
    newPowerState = context->newPowerState;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) { 

            fdoExtension->SystemPowerState = context->newPowerState.SystemState;

            if (fdoExtension->SystemPowerState == PowerSystemWorking) {
                
                POWER_STATE powerState;

                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
                unlocked = TRUE;

				moreProcessingRequired = TRUE;

                //
                // initiate a D0 here to cause a re-enumuration
                //
                powerState.DeviceState = PowerDeviceD0;
				status = PoRequestPowerIrp ( 
									fdoExtension->DeviceObject, 
									IRP_MN_SET_POWER, 
									powerState,
									FdoSystemPowerUpCompletionRoutine,
									Irp,
									NULL
									);

				ASSERT(status == STATUS_PENDING);

            }

            DebugPrint ((1, "PciIdeX: New Fdo system power state 0x%x\n", fdoExtension->SystemPowerState));


        } else if (context->newPowerType == DevicePowerState) { 

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            fdoExtension->DevicePowerState = context->newPowerState.DeviceState;

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // Re-enumerate the devices on the channel
                //
                EnablePCIBusMastering (fdoExtension);

                IoInvalidateDeviceRelations (
                    fdoExtension->AttacheePdo,
                    BusRelations
                    );
            }

            DebugPrint ((1, "PciIdeX: New Fdo device power state 0x%x\n", fdoExtension->DevicePowerState));
        }

		if (callPoSetPowerState) {

			PoSetPowerState (
				DeviceObject,
				newPowerType,
				newPowerState                
				);
		}
    }

    //ExFreePool (Context);
    if (!unlocked) {

        if (context->newPowerType == SystemPowerState) {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
        } else {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
        }
    }

	//
	// wait for the device irp to complete
	//
	if (moreProcessingRequired) {
		return STATUS_MORE_PROCESSING_REQUIRED;
	}

    //
    // If pending has be returned for this irp then mark the current stack as
    // pending.
    //
   // if (Irp->PendingReturned) {
    //    IoMarkIrpPending(Irp);
    //}

	PoStartNextPowerIrp (Irp);
    return Irp->IoStatus.Status;
} // FdoPowerCompletionRoutine

                        
VOID
FdoChildReportPowerDown (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension
    )
{
    POWER_STATE powerState;
    ULONG       numChildrenPowerUp;

    ASSERT(FdoExtension->NumberOfChildrenPowerUp > 0);
    numChildrenPowerUp = InterlockedDecrement(&FdoExtension->NumberOfChildrenPowerUp);

    if (numChildrenPowerUp == 0) {

        DebugPrint ((1, "PciIdeX FdoChildReportPowerDown: sleep fdo 0x%x\n", FdoExtension));

        //
        // All the children are powered down, we can now power down 
        // the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD3;
        PoRequestPowerIrp (
            FdoExtension->DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            NULL,
            NULL,
            NULL
            );

    } 
   // else if (numChildrenPowerUp < 0) {

        //
        // should never happen. If it did, pretend it didn't
        //
    //    ASSERT (FALSE);
     //   InterlockedExchange(&FdoExtension->NumberOfChildrenPowerUp, 0);
    //}

    return;
} // FdoChildReportPowerDown
                        
                        
NTSTATUS
FdoChildRequestPowerUp (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension,
    IN PIRP               ChildPowerIrp
    )
{
    NTSTATUS            status;
    POWER_STATE         powerState;
    ULONG               numberOfChildrenPowerUp;
    IO_STATUS_BLOCK     IoStatus;

    status = STATUS_SUCCESS;

    numberOfChildrenPowerUp = InterlockedExchange (
                                  &FdoExtension->NumberOfChildrenPowerUp, 
                                  FdoExtension->NumberOfChildrenPowerUp
                                  );

    if (numberOfChildrenPowerUp == 0) {

        DebugPrint ((1, "PciIdeX FdoChildRequestPowerUp: wake up fdo 0x%x\n", FdoExtension));

        //
        // One of the children is coming out of sleep, 
        // we need to power up the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp (
                     FdoExtension->DeviceObject,
                     IRP_MN_SET_POWER,
                     powerState,
                     FdoChildRequestPowerUpCompletionRoutine,
                     ChildPowerIrp,
                     NULL
                     );

        ASSERT (NT_SUCCESS(status));
        status = STATUS_PENDING;

    } else {

        powerState.DeviceState = PowerDeviceD0;
        IoStatus.Information   = PowerDeviceD0;
        IoStatus.Status        = STATUS_SUCCESS;

        FdoChildRequestPowerUpCompletionRoutine (
            FdoExtension->DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            ChildPowerIrp,
            &IoStatus
            );

        status = STATUS_PENDING;
    }

    return status;
} // FdoChildRequestPowerUp

NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PIRP                childPowerIrp = Context;
    PCTRLFDO_EXTENSION  fdoExtension;
    PCHANPDO_EXTENSION  pdoExtension;
    PIO_STACK_LOCATION  irpStack;

    fdoExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoStatus->Status)) {

        ULONG numberOfChildrenPowerUp;

        numberOfChildrenPowerUp = InterlockedIncrement (&fdoExtension->NumberOfChildrenPowerUp);

        irpStack = IoGetCurrentIrpStackLocation (childPowerIrp);
        pdoExtension = irpStack->DeviceObject->DeviceExtension;
        pdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;

        if (numberOfChildrenPowerUp > fdoExtension->NumberOfChildren) {

            //
            // should never happen. If it did, pretend it didn't
            //
            ASSERT (FALSE);
            fdoExtension->NumberOfChildrenPowerUp = fdoExtension->NumberOfChildren;
        }

    }

    childPowerIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp (childPowerIrp);
    IoCompleteRequest(childPowerIrp, IO_NO_INCREMENT);

    return IoStatus->Status;
} // FdoChildRequestPowerUpCompletionRoutine
                        
                        
NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
	PIRP irp = Context; 

	//
	// start the next system power irp
	//
    PoStartNextPowerIrp (irp);

	if (!NT_SUCCESS(IoStatus->Status)) {
		irp->IoStatus.Status = IoStatus->Status;
	}
	IoCompleteRequest(irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\sync.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sync.h
//
//--------------------------------------------------------------------------

#if !defined (___sync_h___)
#define ___sync_h___

NTSTATUS
PciIdeCreateSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
);

VOID
PciIdeDeleteSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
);

NTSTATUS
PciIdeQuerySyncAccessInterface (
    PCHANPDO_EXTENSION            PdoExtension,
    PPCIIDE_SYNC_ACCESS_INTERFACE SyncAccessInterface
    );

NTSTATUS
PciIdeAllocateAccessToken (
    PVOID              Token,
    PDRIVER_CONTROL    Callback,
    PVOID              CallbackContext
);

NTSTATUS
PciIdeFreeAccessToken (
    PVOID              Token
);

BOOLEAN
PciIdeSyncAccessRequired (
    IN PCTRLFDO_EXTENSION FdoExtension
);

#endif // ___sync_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\pciidex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pciidex.h
//
//--------------------------------------------------------------------------

#if !defined (___pciide_h___)
#define ___pciide_h___

#define _NTSRV_
//#define _NTDDK_

#include "stdarg.h"
#include "stdio.h"

#include "ntosp.h"
//#include "pci.h"
#include "wdmguid.h"
#include "zwapi.h"

//#include "ntddk.h"
//#include "ntimage.h"
//#include "ntexapi.h"
//#include "ntrtl.h"

#include "scsi.h"
#include <initguid.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <string.h>
#include "wdmguid.h"
#include "pciintrf.h"

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'XedI')
#endif

#define FULL_RESOURCE_LIST_SIZE(n) (sizeof (CM_FULL_RESOURCE_DESCRIPTOR) + (sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (n - 1)))

#if DBG

#ifdef DebugPrint
#undef DebugPrint
#endif // DebugPrint

#define DebugPrint(x)   PciIdeDebugPrint x

VOID
PciIdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#else

#define DebugPrint(x)

#endif // DBG


//#define MAX_IDE_CHANNEL     2
//#define MAX_IDE_DEVICE      2

#define DRIVER_OBJECT_EXTENSION_ID DriverEntry


#include "idep.h"
#include "ctlrfdo.h"
#include "chanpdo.h"
#include "bm.h"
#include "sync.h"
#include "power.h"
#include "msg.h"

extern PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

extern PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

extern PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];

//
// Controller Op Mode
//
#define PCIIDE_CHAN1_DUAL_MODE_CAPABLE      (1 << 3)
#define PCIIDE_CHAN1_IS_NATIVE_MODE         (1 << 2)
#define PCIIDE_CHAN0_DUAL_MODE_CAPABLE      (1 << 1)
#define PCIIDE_CHAN0_IS_NATIVE_MODE         (1 << 0)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    );

NTSTATUS
PciIdeXAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
StatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
CompleteIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
NoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
AtapiHexToString (
    IN ULONG Value,
    IN OUT PCHAR *Buffer
    );

NTSTATUS
PciIdeXGetBusData(
    IN PVOID FdoExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

NTSTATUS
PciIdeXSetBusData(
    IN PVOID FdoExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

NTSTATUS
PciIdeBusData(
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN OUT PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength,
    IN BOOLEAN ReadConfigData
    );

NTSTATUS
PciIdeBusDataCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
PciIdeInternalDeviceIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeXRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);

NTSTATUS
PciIdeXGetDeviceParameterEx (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PVOID               *ParameterValue
    );

NTSTATUS
PciIdeXGetDeviceParameter (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    );

VOID
PciIdeUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PciIdeXSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
PciIdeXSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif // ___pciide_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\sync.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sync.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciIdeCreateSyncChildAccess)
#pragma alloc_text(PAGE, PciIdeDeleteSyncChildAccess)
#pragma alloc_text(PAGE, PciIdeQuerySyncAccessInterface)
#pragma alloc_text(PAGE, PciIdeSyncAccessRequired)

#pragma alloc_text(NONPAGE, PciIdeAllocateAccessToken)
#pragma alloc_text(NONPAGE, PciIdeFreeAccessToken)
#endif // ALLOC_PRAGMA


//
// Must match mshdc.inf
//                   
static PWCHAR SyncAccess = L"SyncAccess";

NTSTATUS
PciIdeCreateSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
)
{
    BOOLEAN syncAccessNeeded;

    PAGED_CODE();

    syncAccessNeeded = FALSE;

    if (FdoExtension->TranslatedBusMasterBaseAddress) {

        UCHAR    bmRawStatus;
    
        bmRawStatus = READ_PORT_UCHAR (&FdoExtension->TranslatedBusMasterBaseAddress->Status);

        if (bmRawStatus & BUSMASTER_DMA_SIMPLEX_BIT) {

            syncAccessNeeded = TRUE;
        }
    }

    if (syncAccessNeeded == FALSE) {

        syncAccessNeeded = PciIdeSyncAccessRequired (
                               FdoExtension
                               );
    }

    if (syncAccessNeeded) {

        DebugPrint ((1, "PCIIDEX: Serialize access to both channels\n"));

        FdoExtension->ControllerObject = IoCreateController (0);
    
        ASSERT (FdoExtension->ControllerObject);

        if (FdoExtension->ControllerObject) {
    
            return STATUS_SUCCESS;
        } else {
    
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return STATUS_SUCCESS;
} // PciIdeCreateSyncChildAccess

VOID
PciIdeDeleteSyncChildAccess (
    PCTRLFDO_EXTENSION FdoExtension
)
{
    PAGED_CODE();

    if (FdoExtension->ControllerObject) {

        IoDeleteController (FdoExtension->ControllerObject);

        FdoExtension->ControllerObject = NULL;
    }
    return;
} // PciIdeDeleteSyncChildAccess

NTSTATUS
PciIdeQuerySyncAccessInterface (
    PCHANPDO_EXTENSION             PdoExtension,
    PPCIIDE_SYNC_ACCESS_INTERFACE  SyncAccessInterface
)
{
    PAGED_CODE();

    if (SyncAccessInterface == NULL) {

        return STATUS_INVALID_PARAMETER;
    }


    if (!PdoExtension->ParentDeviceExtension->ControllerObject) {

        SyncAccessInterface->AllocateAccessToken = NULL;
        SyncAccessInterface->FreeAccessToken     = NULL;
        SyncAccessInterface->Token               = NULL;
        
    } else {

        SyncAccessInterface->AllocateAccessToken = PciIdeAllocateAccessToken;
        SyncAccessInterface->FreeAccessToken     = PciIdeFreeAccessToken;
        SyncAccessInterface->Token               = PdoExtension;
    }

    return STATUS_SUCCESS;
} // PciIdeQuerySyncAccessInterface


static ULONG tokenAccessCount=0;

//
// IRQL must be DISPATCH_LEVEL;
//
NTSTATUS
PciIdeAllocateAccessToken (
    PVOID              Token,
    PDRIVER_CONTROL    Callback,
    PVOID              CallbackContext
)
{
    PCHANPDO_EXTENSION pdoExtension = Token;
    PCTRLFDO_EXTENSION FdoExtension;

    ASSERT (Token);
    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    FdoExtension = pdoExtension->ParentDeviceExtension;

    tokenAccessCount++;

    IoAllocateController (
        FdoExtension->ControllerObject,
        FdoExtension->DeviceObject,
        Callback,
        CallbackContext
        );

    return STATUS_SUCCESS;
} // PciIdeAllocateAccessToken

NTSTATUS
PciIdeFreeAccessToken (
    PVOID              Token
)
{
    PCHANPDO_EXTENSION pdoExtension = Token;
    PCTRLFDO_EXTENSION FdoExtension;
    
    FdoExtension = pdoExtension->ParentDeviceExtension;

    tokenAccessCount--;

    IoFreeController (
        FdoExtension->ControllerObject
        );

    return STATUS_SUCCESS;
} // PciIdeFreeAccessToken


BOOLEAN
PciIdeSyncAccessRequired (
    IN PCTRLFDO_EXTENSION FdoExtension
)
{
    NTSTATUS status;
    ULONG syncAccess;

    PAGED_CODE();

    syncAccess = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension->AttacheePdo,
               SyncAccess,
               &syncAccess
               );
    if (NT_SUCCESS(status)) {

        return (syncAccess != 0);

    } else {

        DebugPrint ((1, "PciIdeX: Unable to get SyncAccess flag from the registry\n"));
    }

    if (FdoExtension->ControllerProperties.PciIdeSyncAccessRequired) {

        return FdoExtension->ControllerProperties.PciIdeSyncAccessRequired (
                   FdoExtension->VendorSpecificDeviceEntension
                   );
    }

    DebugPrint ((1, "PciIdeX: assume sync access not required\n"));
    return FALSE;
} // PciIdeSyncAccessRequired
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\power.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       power.h
//
//--------------------------------------------------------------------------

#if !defined (___power_h___)
#define ___power_h___

typedef struct _SET_POWER_STATE_CONTEXT {

    KEVENT       Event;
    NTSTATUS     Status;

} SET_POWER_STATE_CONTEXT, *PSET_POWER_STATE_CONTEXT;

typedef struct _FDO_POWER_CONTEXT *PFDO_POWER_CONTEXT;

NTSTATUS
PciIdeIssueSetPowerState (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State,
    IN BOOLEAN          Sync
    );
                       
NTSTATUS
PciIdePowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
                          
NTSTATUS
PciIdeXQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
FdoChildReportPowerDown (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension
    );
                       
NTSTATUS
FdoChildRequestPowerUp (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension,
    IN PIRP               ChildPowerIrp
    );

NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );
                       
NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );
#endif // ___power_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\share\util.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.c
//
//--------------------------------------------------------------------------

#include "ide.h"

#pragma alloc_text(NONPAGE, IdePortChannelEmpty)
#pragma alloc_text(PAGE, DigestResourceList)
#pragma alloc_text(PAGE, AtapiBuildIoAddress)
#pragma alloc_text(PAGE, IdeGetDeviceCapabilities)

#pragma alloc_text(NONPAGE, IdePortpWaitOnBusyEx)

#pragma alloc_text(PAGE, IdeCreateIdeDirectory)

#ifdef  DPC_FOR_EMPTY_CHANNEL
BOOLEAN
IdePortIdentifyDevice(
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice
    )
{
    UCHAR statusByte1;
    ULONG retryCount=4;
    BOOLEAN emptyChannel=TRUE;
    ULONG deviceNumber=0;
    ULONG i;
    
    retryCount = 4;
    emptyChannel = TRUE;
    deviceNumber = 0;

retryIdentifier:

    //
    // Select the master device
    //
    SelectIdeDevice(CmdRegBase, deviceNumber, 0);

    //
    // write out indentifier to readable and writable io registers
    //
    WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
    WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

    //
    // Check if indentifier can be read back.
    //
    if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
        (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

        statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

        DebugPrint((2,
                    "IdePortChannelEmpty: status read back from Master (%x)\n",
                    statusByte1));

        if (statusByte1 & IDE_STATUS_BUSY) {

            i = 0;

            //
            // Could be the TEAC in a thinkpad. Their dos driver puts it in a sleep-mode that
            // warm boots don't clear.
            //

            do {
                KeStallExecutionProcessor(1000);
                statusByte1 = READ_PORT_UCHAR(CmdRegBase->Command);
                DebugPrint((3,
                            "IdePortChannelEmpty: First access to status %x\n",
                            statusByte1));
            } while ((statusByte1 & IDE_STATUS_BUSY) && ++i < 10);

            if (retryCount-- && (!(statusByte1 & IDE_STATUS_BUSY))) {
                goto retryIdentifier;
            }
        }

        //
        // Select slave.
        //
        deviceNumber++;

        SelectIdeDevice(CmdRegBase, deviceNumber, 0);

        //
        // write out indentifier to readable and writable io registers
        //
        WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
        WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

        //
        // Check if indentifier can be read back.
        //
        if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
            (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

            statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

            DebugPrint((2,
                        "IdePortChannelEmpty: status read back from Slave (%x)\n",
                        statusByte1));

        } else {

            emptyChannel = FALSE;
        }

    } else {

        emptyChannel = FALSE;
    }

    deviceNumber++;

    if ( (deviceNumber < MaxIdeDevice) && emptyChannel ) {
        goto retryIdentifier;
    }

    return emptyChannel;

} //IdePortIdentifyDevice

ULONG
IdePortChannelEmptyQuick (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice,
    IN PULONG           CurrentDevice,
    IN PULONG           moreWait,
    IN PULONG           NoRetry
)
{
    //
    // try EXECUTE_DIAGNOSTICS. No.
    //

    //
    // statusByte1 needs to be initialized to ff
    //
    UCHAR statusByte1=0xff;

    UCHAR statusByte2;
    ULONG i;
    BOOLEAN allStatusBytesAllFs;

    allStatusBytesAllFs = TRUE;

    DebugPrint((1, "ChannelEmptyQuick: wait=%d, Device=%d\n",
                    *moreWait, *CurrentDevice));
    if (*moreWait) {

        (*moreWait)--;

        SelectIdeDevice(CmdRegBase, (*CurrentDevice), 0);

        IdePortWaitOnBusyExK (CmdRegBase, statusByte1, 0xff);

        DebugPrint((1, "ATAPI: Status after first retry=%x\n", statusByte1));

        if (statusByte1==0xff) {
            (*CurrentDevice)++;
            *moreWait=0;
        }
    }

    if (*moreWait && (statusByte1 & IDE_STATUS_BUSY)) {
        
        return STATUS_RETRY;
    }

    if (!(*NoRetry) && (statusByte1 & IDE_STATUS_BUSY) && 
        ((statusByte1 != 0xfe) &&
         (statusByte1 != 0xff))) {

        DebugPrint((1,
                    "ATAPI: IdePortChannelEmpty: channel looks busy 0x%x.  try a reset\n",
                    statusByte1));

        //
        // channel look hung or busy
        //
        // try a hard reset to bring it to idle
        WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_RESET_CONTROLLER);

        //
        // ATA-2 spec requires a minimum of 5 microsec stall here
        //
        KeStallExecutionProcessor (10);

        WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_REENABLE_CONTROLLER);

        i=*CurrentDevice;
        SelectIdeDevice(CmdRegBase, i, 0);
        IdePortWaitOnBusyExK (CmdRegBase, statusByte1, 0xff);
        if ((statusByte1 & IDE_STATUS_BUSY) && (statusByte1 != 0xff)) {
            *moreWait=2; //wait for 2 more timer ticks
            *NoRetry=1;
            return STATUS_RETRY;
        }
    }

    if (statusByte1 != 0xFF) {
        allStatusBytesAllFs = FALSE;
        (*CurrentDevice)++;
    }

    for (i=*CurrentDevice; i<MaxIdeDevice && allStatusBytesAllFs; i++) {

        //
        // make sure device is not busy
        //

        //
        // Select the master device
        //
        SelectIdeDevice(CmdRegBase, i, 0);

        if (Is98LegacyIde(CmdRegBase)) {
            if (READ_PORT_UCHAR(CmdRegBase->DriveSelect) != (((i & 0x1) << 4) | 0xA0)) {
                //
                // Bad controller.
                //
                continue;
            }
        }

        GetStatus(CmdRegBase, statusByte1);
        DebugPrint((1, "ATAPI:status for device %d after GetStatus=%x\n",i, statusByte1));

        if (statusByte1 == 0xff) {
            continue;
        }

        if (statusByte1 == 0xfe) {
            continue;
        }

        IdePortWaitOnBusyExK (CmdRegBase, statusByte1, 0xff);

        if ((statusByte1 & 0xfe) == 0xfe) {
            continue;
        }

        if (statusByte1 & IDE_STATUS_BUSY) {
            DebugPrint((1, "ATAPI: Re-init the counts:device=%d, status=%x",
                                i, statusByte1));
            *CurrentDevice=i;
            *moreWait=2;
            *NoRetry=0;
            return STATUS_RETRY;
        }

        if (statusByte1 != 0xFF) {
            allStatusBytesAllFs = FALSE;
        }
    }

    if (allStatusBytesAllFs) {

        //
        // all status bytes are 0xff,
        // no controller at this location
        //
        return 1;
    }

    i=(IdePortIdentifyDevice(CmdRegBase, CtrlRegBase, MaxIdeDevice)) ? 1: 0;
    return i;

}//IdePortChannelEmptyQuick


#endif

BOOLEAN
IdePortChannelEmpty (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice
)
/*++

Routine Description:

    quickly check whether a IDE channel exist at the given io location

Arguments:

    CmdRegBase - command registers

    CtrlRegBase - control registers

    MaxIdeDevice - number of max devices

Return Value:

    TRUE - Yes, the channel is empty
    FALSE - No, the channel is not empty

--*/
{

    UCHAR statusByte1;
    UCHAR statusByte2;
    ULONG retryCount;
    ULONG i;
    BOOLEAN emptyChannel;
    ULONG deviceNumber;
    BOOLEAN allStatusBytesAllFs;

    allStatusBytesAllFs = TRUE;
    for (i=0; i<MaxIdeDevice; i++) {

        //
        // make sure device is not busy
        //

        //
        // Select the master device
        //
        SelectIdeDevice(CmdRegBase, i, 0);

        if (Is98LegacyIde(CmdRegBase)) {
            if (READ_PORT_UCHAR(CmdRegBase->DriveSelect) != (((i & 0x1) << 4) | 0xA0)) {
                //
                // Bad controller.
                //
                continue;
            }
        }

        GetStatus(CmdRegBase, statusByte1);

        if (statusByte1 == 0xff) {
            continue;
        }

        if (statusByte1 == 0xfe) {
            continue;
        }

        IdePortWaitOnBusyEx (CmdRegBase, &statusByte1, 0xff);

        if ((statusByte1 & IDE_STATUS_BUSY) &&
            ((statusByte1 != 0xfe) &&
             (statusByte1 != 0xff))) {

            DebugPrint((1,
                        "IdePortChannelEmpty: channel looks busy 0x%x.  try a reset\n",
                        statusByte1));


            //
            // channel look hung or busy
            //
            // try a hard reset to bring it to idle
            WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_RESET_CONTROLLER);
            
            //
            // ATA-2 spec requires a minimum of 5 microsec stall here
            //
            KeStallExecutionProcessor (10);
    
            WRITE_PORT_UCHAR (CtrlRegBase->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
    
            SelectIdeDevice(CmdRegBase, i, 0);
            IdePortWaitOnBusyEx (CmdRegBase, &statusByte1, 0xff);
        }

        if (statusByte1 != 0xFF) {
            allStatusBytesAllFs = FALSE;
        }
    }

    if (allStatusBytesAllFs) {

        //
        // all status bytes are 0xff,
        // no controller at this location
        //
        return TRUE;
    }

#ifdef DPC_FOR_EMPTY_CHANNEL
    return IdePortIdentifyDevice(CmdRegBase, CtrlRegBase, MaxIdeDevice);
#endif
    retryCount = 4;
    emptyChannel = TRUE;
    deviceNumber = 0;

retryIdentifier:

    //
    // Select the master device
    //
    SelectIdeDevice(CmdRegBase, deviceNumber, 0);

    //
    // write out indentifier to readable and writable io registers
    //
    WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
    WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

    //
    // Check if indentifier can be read back.
    //
    if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
        (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

        statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

        DebugPrint((2,
                    "IdePortChannelEmpty: status read back from Master (%x)\n",
                    statusByte1));

        if (statusByte1 & IDE_STATUS_BUSY) {

            i = 0;

            //
            // Could be the TEAC in a thinkpad. Their dos driver puts it in a sleep-mode that
            // warm boots don't clear.
            //

            do {
                KeStallExecutionProcessor(1000);
                statusByte1 = READ_PORT_UCHAR(CmdRegBase->Command);
                DebugPrint((3,
                            "IdePortChannelEmpty: First access to status %x\n",
                            statusByte1));
            } while ((statusByte1 & IDE_STATUS_BUSY) && ++i < 10);

            if (retryCount-- && (!(statusByte1 & IDE_STATUS_BUSY))) {
                goto retryIdentifier;
            }
        }

        //
        // Select slave.
        //
        deviceNumber++;

        SelectIdeDevice(CmdRegBase, deviceNumber, 0);

        //
        // write out indentifier to readable and writable io registers
        //
        WRITE_PORT_UCHAR (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
        WRITE_PORT_UCHAR (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

        //
        // Check if indentifier can be read back.
        //
        if ((READ_PORT_UCHAR (CmdRegBase->CylinderHigh) != SAMPLE_CYLINDER_HIGH_VALUE) ||
            (READ_PORT_UCHAR (CmdRegBase->CylinderLow)  != SAMPLE_CYLINDER_LOW_VALUE)) {

            statusByte1 = READ_PORT_UCHAR (CmdRegBase->Command);

            DebugPrint((2,
                        "IdePortChannelEmpty: status read back from Slave (%x)\n",
                        statusByte1));

        } else {

            emptyChannel = FALSE;
        }

    } else {

        emptyChannel = FALSE;
    }

    deviceNumber++;

    if ( (deviceNumber < MaxIdeDevice) && emptyChannel ) {
        goto retryIdentifier;
    }

    return emptyChannel;

} //IdePortChannelEmpty

NTSTATUS
DigestResourceList (
    IN OUT PIDE_RESOURCE                IdeResource,
    IN  PCM_RESOURCE_LIST               ResourceList,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *IrqPartialDescriptors
    )
{
    NTSTATUS                        status;

    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    ULONG                           resourceListSize;
    ULONG                           i;
    ULONG                           j;

    BOOLEAN                         foundCommandBase;
    BOOLEAN                         foundControlBase;
    BOOLEAN                         foundIrqLevel;
    BOOLEAN                         resourceIsCommandPort;

    BOOLEAN                         AtdiskPrimaryClaimed;
    BOOLEAN                         AtdiskSecondaryClaimed;

    PHYSICAL_ADDRESS                tranlatedAddress;

    IDE_REGISTERS_1                 baseIoAddress1;
    ULONG                           baseIoAddress1Length;


    fullResourceList = ResourceList->List;
    resourceListSize = 0;

    DebugPrint ((5, "IdePort: DigestResourceList()\n"));

    foundCommandBase       = FALSE;
    foundControlBase       = FALSE;
    foundIrqLevel          = FALSE;
    *IrqPartialDescriptors = NULL;
    status                 = STATUS_SUCCESS;

    AtdiskPrimaryClaimed    = FALSE;
    AtdiskSecondaryClaimed  = FALSE;

    for (i = 0;
         (i < ResourceList->Count) && NT_SUCCESS(status);
         i++) {

        partialResourceList = &(fullResourceList->PartialResourceList);
        partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

        AtapiBuildIoAddress ((PUCHAR)partialDescriptors[0].u.Port.Start.QuadPart,
                             0,
                             &baseIoAddress1,
                             NULL,
                             &baseIoAddress1Length,
                             NULL,
                             NULL,
                             NULL);

        for (j = 0;
             (j < partialResourceList->Count) && NT_SUCCESS(status);
             j++) {

            resourceIsCommandPort = FALSE;

            if (!Is98LegacyIde(&baseIoAddress1)) {

                if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                    (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                    (partialDescriptors[j].u.Port.Length == baseIoAddress1Length)) {

                    resourceIsCommandPort = TRUE;

                }
            } else {

                if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                    (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                    (partialDescriptors[j].u.Port.Start.QuadPart == IDE_NEC98_COMMAND_PORT_ADDRESS)){

                    resourceIsCommandPort = TRUE;

                } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                            (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                           (partialDescriptors[j].u.Port.Start.QuadPart != IDE_NEC98_COMMAND_PORT_ADDRESS) &&
                           (partialDescriptors[j].u.Port.Start.QuadPart != (IDE_NEC98_COMMAND_PORT_ADDRESS + 0x10C))) {

                    //
                    // This is not the base port address for Legacy ide on NEC98;
                    //

                    continue;
                }
            }

            if (resourceIsCommandPort) {

                if (foundCommandBase) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    if (!Is98LegacyIde(&baseIoAddress1)) {

                        if (partialDescriptors[j].u.Port.Start.QuadPart == IDE_STANDARD_PRIMARY_ADDRESS) {

                            AtdiskPrimaryClaimed = TRUE;

                        } else if (partialDescriptors[j].u.Port.Start.QuadPart == IDE_STANDARD_SECONDARY_ADDRESS) {

                            AtdiskSecondaryClaimed = TRUE;
                        }

                    } else {

                        AtdiskPrimaryClaimed = TRUE;
                        AtdiskSecondaryClaimed = TRUE;
                    }

                    if (partialDescriptors[j].Type == CmResourceTypePort) {

                        IdeResource->TranslatedCommandBaseAddress =
                            (PUCHAR)(ULONG_PTR)partialDescriptors[j].u.Port.Start.QuadPart;

                        IdeResource->CommandBaseAddressSpace = IO_SPACE;

                    } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {

                        IdeResource->TranslatedCommandBaseAddress = MmMapIoSpace(
                                                                        partialDescriptors[j].u.Port.Start,
                                                                        baseIoAddress1Length,
                                                                        FALSE);

                        IdeResource->CommandBaseAddressSpace = MEMORY_SPACE;

                    } else {

                        IdeResource->TranslatedCommandBaseAddress = FALSE;
                        ASSERT (FALSE);
                    }

                    if (IdeResource->TranslatedCommandBaseAddress) {

                        foundCommandBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }
                }

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        ((partialDescriptors[j].u.Port.Length == 1) ||
                        (partialDescriptors[j].u.Port.Length == 2) ||
                        (partialDescriptors[j].u.Port.Length == 4))) {

                if (foundControlBase) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    PHYSICAL_ADDRESS p;
                    //
                    // Probably the control block register
                    //

                    p = partialDescriptors[j].u.Port.Start;

                    if (partialDescriptors[j].u.Port.Length == 4) {

                        p.QuadPart += 2;
                    }

                    if (partialDescriptors[j].Type == CmResourceTypePort) {

                        IdeResource->TranslatedControlBaseAddress =
                            (PUCHAR)(ULONG_PTR)partialDescriptors[j].u.Port.Start.QuadPart;

                        IdeResource->ControlBaseAddressSpace = IO_SPACE;

                    } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {

                        IdeResource->TranslatedControlBaseAddress = MmMapIoSpace(
                                                                         p,
                                                                         1,
                                                                         FALSE);

                        IdeResource->ControlBaseAddressSpace = MEMORY_SPACE;

                    } else {

                        IdeResource->TranslatedControlBaseAddress = FALSE;
                        ASSERT (FALSE);
                    }

                    if (IdeResource->TranslatedControlBaseAddress) {

                        foundControlBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }
                }

            } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {

                if (foundIrqLevel) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    //
                    // Probably the device IRQ
                    //

                    //
                    // May want to disable device interrupt here
                    //

                    //
                    // Save interrupt level.
                    //

                    IdeResource->InterruptLevel = partialDescriptors[j].u.Interrupt.Level;
                    IdeResource->InterruptMode  = partialDescriptors[j].Flags & CM_RESOURCE_INTERRUPT_LATCHED ?
                                                       Latched :
                                                       LevelSensitive;

                    *IrqPartialDescriptors       = partialDescriptors + j;

                    foundIrqLevel = TRUE;
                }

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        ((partialDescriptors[j].u.Port.Length >= 16) &&
                         (partialDescriptors[j].u.Port.Length <= 32)) ) {

                if (foundControlBase || foundCommandBase) {

                    //
                    // got this before, just ignore it
                    //
                    // status = STATUS_INVALID_PARAMETER;

                } else {

                    PHYSICAL_ADDRESS ctrlAddr;

                    //
                    // Probably a pcmcia device that has its command and control
                    // registers lumped into one I/O range
                    //
                    // We are guessing the control block register is the second
                    // from the last i/o space.  Some standard!
                    //

                    ctrlAddr.QuadPart = partialDescriptors[j].u.Port.Start.QuadPart +
                                        partialDescriptors[j].u.Port.Length - 2;

                    if (partialDescriptors[j].Type == CmResourceTypePort) {

                        IdeResource->TranslatedCommandBaseAddress =
                            (PUCHAR)(ULONG_PTR)partialDescriptors[j].u.Port.Start.QuadPart;

                        IdeResource->CommandBaseAddressSpace = IO_SPACE;

                        IdeResource->TranslatedControlBaseAddress =
                            (PUCHAR)(ULONG_PTR)ctrlAddr.QuadPart;

                        IdeResource->ControlBaseAddressSpace = IO_SPACE;

                    } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {

                        IdeResource->TranslatedCommandBaseAddress = MmMapIoSpace(
                                                                         partialDescriptors[j].u.Port.Start,
                                                                         baseIoAddress1Length,
                                                                         FALSE);

                        IdeResource->CommandBaseAddressSpace = MEMORY_SPACE;

                        IdeResource->TranslatedControlBaseAddress = MmMapIoSpace(
                                                                         ctrlAddr,
                                                                         1,
                                                                         FALSE);

                        IdeResource->ControlBaseAddressSpace = MEMORY_SPACE;

                    } else {

                        IdeResource->TranslatedCommandBaseAddress = FALSE;
                        IdeResource->TranslatedControlBaseAddress = FALSE;
                        ASSERT (FALSE);
                    }

                    if (IdeResource->TranslatedCommandBaseAddress) {

                        foundCommandBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }

                    if (IdeResource->TranslatedControlBaseAddress) {

                        foundControlBase = TRUE;

                    } else {

                        status = STATUS_INVALID_PARAMETER;
                    }
                }
            }
        }
        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
    }

    if (foundCommandBase && foundControlBase && NT_SUCCESS(status)) {

        IdeResource->AtdiskPrimaryClaimed   = AtdiskPrimaryClaimed;
        IdeResource->AtdiskSecondaryClaimed = AtdiskSecondaryClaimed;

        return STATUS_SUCCESS;

    } else {

        DebugPrint((0, "IdePort: pnp manager gave me bad ressources!\n"));

        if (foundCommandBase &&
            (IdeResource->CommandBaseAddressSpace == MEMORY_SPACE)) {

            MmUnmapIoSpace (
                IdeResource->TranslatedCommandBaseAddress,
                baseIoAddress1Length
                );

            IdeResource->TranslatedCommandBaseAddress = 0;
        }

        if (foundControlBase &&
            (IdeResource->ControlBaseAddressSpace == MEMORY_SPACE)) {

            MmUnmapIoSpace (
                IdeResource->TranslatedControlBaseAddress,
                1
                );

            IdeResource->TranslatedControlBaseAddress = 0;
        }

        return STATUS_INVALID_PARAMETER;
    }
} // DigestResourceList

VOID
AtapiBuildIoAddress (
    IN  PUCHAR            CmdBaseAddress,
    IN  PUCHAR            CtrlBaseAddress,
    OUT PIDE_REGISTERS_1  BaseIoAddress1,
    OUT PIDE_REGISTERS_2  BaseIoAddress2,
    OUT PULONG            BaseIoAddress1Length,
    OUT PULONG            BaseIoAddress2Length,
    OUT PULONG            MaxIdeDevice,
    OUT PULONG            MaxIdeTargetId
)
{
    PUCHAR      baseIoAddress;
    BOOLEAN     LegacyIdeOfNec98;

    LegacyIdeOfNec98 = FALSE;

    if (IsNEC_98) {
        if (CmdBaseAddress == (PUCHAR)IDE_NEC98_COMMAND_PORT_ADDRESS) {
            LegacyIdeOfNec98 = TRUE;
        }
    }

    if (!LegacyIdeOfNec98) {

        //
        // Build command registers.
        //

        baseIoAddress       = CmdBaseAddress;

        if (BaseIoAddress1) {
            BaseIoAddress1->RegistersBaseAddress = baseIoAddress;

            BaseIoAddress1->Data         = (PUSHORT)baseIoAddress;
            BaseIoAddress1->Error        = baseIoAddress + 1;
            BaseIoAddress1->BlockCount   = baseIoAddress + 2;
            BaseIoAddress1->BlockNumber  = baseIoAddress + 3;
            BaseIoAddress1->CylinderLow  = baseIoAddress + 4;
            BaseIoAddress1->CylinderHigh = baseIoAddress + 5;
            BaseIoAddress1->DriveSelect  = baseIoAddress + 6;
            BaseIoAddress1->Command      = baseIoAddress + 7;

        }

        //
        // Build control registers.
        //

        baseIoAddress = CtrlBaseAddress;

        if (BaseIoAddress2) {

            BaseIoAddress2->RegistersBaseAddress     = baseIoAddress;

            BaseIoAddress2->DeviceControl            = baseIoAddress;
            BaseIoAddress2->DriveAddress             = baseIoAddress + 1;
        }

        if (BaseIoAddress1Length) {
            *BaseIoAddress1Length                    = 8;
        }

        if (BaseIoAddress2Length) {
            *BaseIoAddress2Length                    = 1;
        }

        if (MaxIdeDevice) {
            *MaxIdeDevice                           = MAX_IDE_DEVICE;
        }

        if (MaxIdeTargetId) {
            *MaxIdeTargetId                         = MAX_IDE_DEVICE;
        }

    } else {

        //
        // Build command registers.
        //

        baseIoAddress = CmdBaseAddress;

        if (BaseIoAddress1) {
            BaseIoAddress1->RegistersBaseAddress = baseIoAddress;

            BaseIoAddress1->Data         = (PUSHORT)baseIoAddress;
            BaseIoAddress1->Error        = baseIoAddress + 2;
            BaseIoAddress1->BlockCount   = baseIoAddress + 4;
            BaseIoAddress1->BlockNumber  = baseIoAddress + 6;
            BaseIoAddress1->CylinderLow  = baseIoAddress + 8;
            BaseIoAddress1->CylinderHigh = baseIoAddress + 10;
            BaseIoAddress1->DriveSelect  = baseIoAddress + 12;
            BaseIoAddress1->Command      = baseIoAddress + 14;
        }

        //
        // Build control registers.
        //

        baseIoAddress = CtrlBaseAddress;

        if (BaseIoAddress2) {

            BaseIoAddress2->RegistersBaseAddress     = baseIoAddress;

            BaseIoAddress2->DeviceControl            = baseIoAddress;
            BaseIoAddress2->DriveAddress             = baseIoAddress + 2;
        }

        if (BaseIoAddress1Length) {
            *BaseIoAddress1Length                    = 1;
        }

        if (BaseIoAddress2Length) {
            *BaseIoAddress2Length                    = 1;
        }

        if (MaxIdeDevice) {
            *MaxIdeDevice                           = MAX_IDE_DEVICE * MAX_IDE_LINE;
        }

        if (MaxIdeTargetId) {
            *MaxIdeTargetId                         = MAX_IDE_DEVICE * MAX_IDE_LINE;
        }
    }

    return;

} // AtapiBuildIoAddress

NTSTATUS
IdePortpWaitOnBusyEx (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN OUT PUCHAR       Status,
    IN UCHAR            BadStatus
#if DBG
    ,
    IN PCSTR            FileName,
    IN ULONG            LineNumber
#endif
)
{
    UCHAR status;
    ULONG sec;
    ULONG i;

    for (sec=0; sec<2; sec++) {

        /**/
        /* one second loop */
        /**/

        for (i=0; i<200000; i++) {

            GetStatus(CmdRegBase, status);
            
            if (status == BadStatus) {

                break;

            } else if (status & IDE_STATUS_BUSY) {

                KeStallExecutionProcessor(5);
                continue;

            } else {

                break;
            }
        }

        if (status == BadStatus) {

           break;

        } else if (status & IDE_STATUS_BUSY) {

            DebugPrint ((1, "ATAPI: after 1 sec wait, device is still busy with 0x%x status = 0x%x\n", CmdRegBase->RegistersBaseAddress, (ULONG) (status)));

        } else {

            break;
        }
    }

    *Status = status;

    if ((status & IDE_STATUS_BUSY) && (status != BadStatus)) {

        DebugPrint ((0, "WaitOnBusy failed in %s line %u. 0x%x status = 0x%x\n", FileName, LineNumber, CmdRegBase->RegistersBaseAddress, (ULONG) (status)));

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
} // IdePortpWaitOnBusyEx

static PVOID IdeDirectory = NULL;
VOID
IdeCreateIdeDirectory(
    VOID
    )
{
    UNICODE_STRING unicodeDirectoryName;
    OBJECT_ATTRIBUTES objectAttributes;

    HANDLE directory;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(
        &unicodeDirectoryName,
        DEVICE_OJBECT_BASE_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeDirectoryName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL);

    status = ZwCreateDirectoryObject(&directory,
                                     DIRECTORY_ALL_ACCESS,
                                     &objectAttributes);

    if(NT_SUCCESS(status)) {

        ObReferenceObjectByHandle(directory,
                                  FILE_READ_ATTRIBUTES,
                                  NULL,
                                  KernelMode,
                                  &IdeDirectory,
                                  NULL);
        ZwClose(directory);

    }
    return;
}

NTSTATUS
IdeGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine sends the get capabilities irp to the given stack

Arguments:

    DeviceObject        A device object in the stack whose capabilities we want
    DeviceCapabilites   Where to store the answer

Return Value:

    NTSTATUS

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;

    PAGED_CODE();

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;
    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Get the irp that we will send the request to
    //
    targetObject = IoGetAttachedDeviceReference( DeviceObject );

    //
    // Build an Irp
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        targetObject,
        NULL,
        0,
        NULL,
        &pnpEvent,
        &ioStatus
        );
    if (pnpIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto IdeGetDeviceCapabilitiesExit;

    }

    //
    // Pnp Irps all begin life as STATUS_NOT_SUPPORTED;
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pnpIrp->IoStatus.Information = 0;

    //
    // Get the top of stack
    //
    irpStack = IoGetNextIrpStackLocation( pnpIrp );
    if (irpStack == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto IdeGetDeviceCapabilitiesExit;

    }

    //
    // Set the top of stack
    //
    RtlZeroMemory( irpStack, sizeof(IO_STACK_LOCATION ) );
    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    //
    // Make sure that there are no completion routines set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // Block until the irp comes back
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioStatus.Status;

    }

IdeGetDeviceCapabilitiesExit:
    //
    // Done with reference
    //
    ObDereferenceObject( targetObject );

    //
    // Done
    //
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\dispatch.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    dispatch.c

Abstract:

    This file contains code for dispatch routines for iScsiPort

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

PDRIVER_DISPATCH FdoMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
PDRIVER_DISPATCH PdoMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];


VOID
iScsiPortInitializeDispatchTables()
{
    ULONG inx;

    //
    // Initialize FDO dispatch table
    //
    for (inx = 0; inx <= IRP_MJ_MAXIMUM_FUNCTION; inx++) {
        FdoMajorFunctionTable[inx] = iScsiPortDispatchUnsupported;
    }

    FdoMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = iScsiPortFdoDeviceControl;
    FdoMajorFunctionTable[IRP_MJ_SCSI] = iScsiPortFdoDispatch;
    FdoMajorFunctionTable[IRP_MJ_PNP] = iScsiPortFdoPnp;
    FdoMajorFunctionTable[IRP_MJ_POWER] = iScsiPortPower;
    FdoMajorFunctionTable[IRP_MJ_CREATE] = iScsiPortFdoCreateClose;
    FdoMajorFunctionTable[IRP_MJ_CLOSE] = iScsiPortFdoCreateClose;
    FdoMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = iScsiPortSystemControl;

    //
    // Initialize PDO dispatch table
    //
    for(inx = 0; inx <= IRP_MJ_MAXIMUM_FUNCTION; inx++) {
        PdoMajorFunctionTable[inx] = iScsiPortDispatchUnsupported;
    }

    PdoMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = iScsiPortPdoDeviceControl;
    PdoMajorFunctionTable[IRP_MJ_SCSI] = iScsiPortPdoDispatch;
    PdoMajorFunctionTable[IRP_MJ_PNP] = iScsiPortPdoPnp;
    PdoMajorFunctionTable[IRP_MJ_POWER] = iScsiPortPower;
    PdoMajorFunctionTable[IRP_MJ_CREATE] = iScsiPortPdoCreateClose;
    PdoMajorFunctionTable[IRP_MJ_CLOSE] = iScsiPortPdoCreateClose;
    PdoMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = iScsiPortSystemControl;

    return;
}


NTSTATUS
iScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    return (commonExtension->MajorFunction[irpStack->MajorFunction])(DeviceObject,
                                                                     Irp);
}


NTSTATUS
iScsiPortDispatchUnsupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\inc\rbc.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    rbc.h

Abstract:

    These are the structures and defines used in the Reduced Block Command set

Authors:

    George Chrysanthakopoulos(georgioc) - April 1998

Revision History:

    Dan Knudson (DanKn), 23 Sep 1999 - updated per rev 10 of RBC spec

--*/
#ifndef _NTRBC_
#define _NTRBC_

#include "scsi.h"

//
// Command Descriptor Block. encapsulated under the bus/protocol specific request block
//

typedef union _CDB_RBC {

    //
    // format unit
    //
    
    struct _FORMAT_RBC {
        UCHAR OperationCode;
        UCHAR VendorSpecific;
        UCHAR Increment : 1;
        UCHAR Percent_Time : 1;
        UCHAR Reserved1 : 1;
        UCHAR VendorSpecific1 : 5;
        UCHAR Reserved2[2];
        UCHAR Control;
    } FORMAT_RBC, *PFORMAT_RBC;
    
    //
    // prevent/allow medium removal
    //

    struct _MEDIA_REMOVAL_RBC {
        UCHAR OperationCode;
        UCHAR Reserved[3];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL_RBC, *PMEDIA_REMOVAL_RBC;

    //
    // START_STOP_UNIT
    //

    struct _START_STOP_RBC {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 2;
        UCHAR PowerConditions : 4;
        UCHAR Control;
    } START_STOP_RBC, *PSTART_STOP_RBC;

    struct _SYNCHRONIZE_CACHE_RBC {

        UCHAR OperationCode;    // 0x35
        UCHAR Reserved[8];
        UCHAR Control;

    } SYNCHRONIZE_CACHE_RBC, *PSYNCHRONIZE_CACHE_RBC;


} CDB_RBC, *PCDB_RBC;


//
// START_STOP_UNIT Power Condition descriptions
//

#define START_STOP_RBC_POWER_CND_NO_CHANGE      0
#define START_STOP_RBC_POWER_CND_ACTIVE         1
#define START_STOP_RBC_POWER_CND_IDLE           2
#define START_STOP_RBC_POWER_CND_STANDBY        3
#define START_STOP_RBC_POWER_CND_SLEEP          5
#define START_STOP_RBC_POWER_CND_DEVICE_CTRL    7


//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_RBC_DEVICE_PARAMETERS 0x06


//
// DeviceType field in inquiry Data
//

#define RBC_DEVICE             0x0E

//
// Define Device Capabilities page.
//

typedef struct _MODE_RBC_DEVICE_PARAMETERS_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR WriteCacheDisable : 1;
    UCHAR Reserved1 : 7;
    UCHAR LogicalBlockSize[2];
    UCHAR NumberOfLogicalBlocks[5];
    UCHAR PowerPerformance;
    UCHAR LockDisabled : 1;
    UCHAR FormatDisabled : 1;
    UCHAR WriteDisabled : 1;
    UCHAR ReadDisabled : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;

}MODE_RBC_DEVICE_PARAMETERS_PAGE, *PMODE_RBC_DEVICE_PARAMETERS_PAGE;

typedef struct _MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE {

    MODE_PARAMETER_HEADER Header;
    MODE_RBC_DEVICE_PARAMETERS_PAGE Page;

}MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE,
    *PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE;


//
// unsolicited status sense code qualifier values
//

#define RBC_UNSOLICITED_STATUS              0x02
#define RBC_UNSOLICITED_SENSE_KEY           0x06

#define RBC_UNSOLICITED_SC_PWR_STATE_CHNG   0xFF
#define RBC_UNSOLICITED_SC_EVENT_STATUS     0xFE

#define RBC_UNSOLICITED_CLASS_ASQ_DEVICE    0x06
#define RBC_UNSOLICITED_CLASS_ASQ_MEDIA     0x04
#define RBC_UNSOLICITED_CLASS_ASQ_POWER     0x02




//
// Translation routine used to convert SCSI requests that differ from RBC
//

NTSTATUS
Rbc_Scsi_Conversion(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSCSI_REQUEST_BLOCK *OriginalSrb,
    IN PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE RbcHeaderAndPage,
    IN BOOLEAN OutgoingRequest,
    IN BOOLEAN RemovableMedia
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\init.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    init.c

Abstract:

    This file contains the initialization code for iSCSI port driver.

Environment:

    kernel mode only

Revision History:

--*/
#include "port.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*+++

Routine Description:

    Entry point for the driver. 
    
Arguements:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - Registry path for the driver
    
Return Value :

    STATUS_SUCCESS if initialization was successful
    Appropriate NTStatus code on failure 
--*/
{
    NTSTATUS status;
    PISCSIPORT_DRIVER_EXTENSION driverExtension = NULL;

    DebugPrint((3, "iSCSI Port DriverEntry\n"));

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             (PVOID) ISCSI_TAG_DRIVER_EXTENSION,
                                             sizeof(ISCSIPORT_DRIVER_EXTENSION),
                                             &driverExtension);
    if (NT_SUCCESS(status)) {
        RtlZeroMemory(driverExtension, 
                      sizeof(ISCSIPORT_DRIVER_EXTENSION));
        driverExtension->DriverObject = DriverObject;
        driverExtension->RegistryPath.Length = RegistryPath->Length;
        driverExtension->RegistryPath.MaximumLength = 
            RegistryPath->MaximumLength;
        driverExtension->RegistryPath.Buffer = 
            ExAllocatePoolWithTag(PagedPool,
                                  RegistryPath->MaximumLength,
                                  ISCSI_TAG_REGPATH);
        if (driverExtension->RegistryPath.Buffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlCopyUnicodeString(&(driverExtension->RegistryPath),
                             RegistryPath);

        //
        // Hard code bus type for now
        //
        driverExtension->BusType = BusTypeScsi;

    } else if (status == STATUS_OBJECT_NAME_COLLISION) {

        //
        // Extension already exists. Get a pointer to it
        //
        driverExtension = IoGetDriverObjectExtension(
                                   DriverObject,
                                   (PVOID) ISCSI_TAG_DRIVER_EXTENSION);
        ASSERT(driverExtension != NULL);
    } else {
        DebugPrint((1, "iSCSI : Could not allocate driver extension %lx\n",
                    status));
        return status;
    }

    //
    // Update the driver object with the entry points
    //
    DriverObject->MajorFunction[IRP_MJ_SCSI] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = iScsiPortGlobalDispatch;

    DriverObject->DriverUnload = iScsiPortUnload;
    DriverObject->DriverExtension->AddDevice = iScsiPortAddDevice;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\lock.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    lock.c

Abstract:

    This file contains code iSCSI Port driver

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


ULONG
iSpAcquireRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

    lockValue = InterlockedIncrement(&(commonExtension->RemoveLock));

    ASSERTMSG("iSpAcquireRemoveLock : lock value was negative ",
              (lockValue > 0));

    return (commonExtension->IsRemoved);
}


VOID
iSpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

    lockValue = InterlockedDecrement(&(commonExtension->RemoveLock));

    if (lockValue < 0) {
        ASSERTMSG("iSpReleaseRemoveLock : lock value was negative ",
                  (lockValue >= 0));
    }

    if (lockValue == 0) {
        DebugPrint((3, "Releaselock for device object %x\n",
                    DeviceObject));
        KeSetEvent(&(commonExtension->RemoveEvent),
                   IO_NO_INCREMENT,
                   FALSE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\enum.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    enum.c

Abstract:

    This file contains device enumeration routines

Environment:

    kernel mode only

Revision History:

--*/
#include "port.h"


VOID
iSpEnumerateDevicesAsynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension;
    PCOMMON_EXTENSION commonExtension;
    PISCSI_CONNECTION   iScsiConnection;
    PIRP Irp;
    LARGE_INTEGER Timeout;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR oldIrql;

    fdoExtension = (PISCSI_FDO_EXTENSION) Context;
    commonExtension = DeviceObject->DeviceExtension;

    IoFreeWorkItem(fdoExtension->EnumerationWorkItem);
    fdoExtension->EnumerationWorkItem = NULL;

    //
    // Local network nodes should be setup at this point.
    // If not, fail the enumeration irp
    //
    if ((fdoExtension->LocalNodesInitialized) == TRUE) {
        PDEVICE_OBJECT pdo;
        PISCSI_PDO_EXTENSION pdoExtension;
        ULONG inx;

        DebugPrint((3, "Number of targets : %d\n",
                    (fdoExtension->NumberOfTargets)));

        fdoExtension->TargetsYetToRespond = fdoExtension->NumberOfTargets;

        for (inx = 0; inx < (fdoExtension->NumberOfTargets); inx++) {

            pdo = fdoExtension->PDOList[inx];
            pdoExtension = (PISCSI_PDO_EXTENSION)(pdo->DeviceExtension);
            iScsiConnection = pdoExtension->ClientNodeInfo;

            DebugPrint((3, "Will connect to the server\n"));

            pdoExtension->LogonTickCount = 0;

            //
            // Connection timeout is 60 seconds. Is this enough???
            //
            Timeout.QuadPart = -600000000;
            status = iSpTdiConnect(iScsiConnection->ConnectionDeviceObject,
                                   iScsiConnection->ConnectionFileObject,
                                   pdoExtension->TargetIPAddress,
                                   htons(pdoExtension->TargetPortNumber),
                                   Timeout);
            if (NT_SUCCESS(status)) {
                DebugPrint((3, "Connected to the server\n"));

                iScsiConnection->ConnectionState = ConnectionStateConnected;

                pdoExtension->CurrentProtocolState = PSLogonInProgress;

                DebugPrint((3, "Will send logon packet\n"));

                status = iSpSendLoginCommand(pdoExtension);
                if (NT_SUCCESS(status)) {

                    pdoExtension->LogonTickCount = 0;

                    DebugPrint((3, "Login command sent successfully\n"));
                } else {

                    LARGE_INTEGER disconnectTimeout;

                    DebugPrint((1, 
                                "Send failed for logon. Status : %x\n", 
                                status));

                    InterlockedDecrement(&(fdoExtension->TargetsYetToRespond));
                    pdoExtension->CurrentProtocolState = PSLogonFailed;

                    disconnectTimeout.QuadPart = -100000000L;

                    iScsiConnection->ConnectionState = ConnectionStateStopping;

                    status = iSpTdiDisconnect(iScsiConnection->ConnectionDeviceObject,
                                              iScsiConnection->ConnectionFileObject,
                                              TDI_DISCONNECT_RELEASE,
                                              iSpTdiCompletionRoutine,
                                              iScsiConnection,
                                              disconnectTimeout);

                    DebugPrint((3, "iSpTdiDisconnect  returned : %x\n",
                                status));

                }
            } else {

                DebugPrint((1, "Could not connect to server. Status : %x\n",
                            status));
                pdoExtension->CurrentProtocolState = PSConnectToServerFailed;
                InterlockedDecrement(&(fdoExtension->TargetsYetToRespond));
            }
        }

        KeAcquireSpinLock(&(fdoExtension->EnumerationSpinLock),
                          &oldIrql);

        //
        // Launch the enum completion thread if all targets have
        // responded or none could be contacted.
        //
        if (((fdoExtension->TargetsYetToRespond) == 0) &&
            ((fdoExtension->EnumerationThreadLaunched) == FALSE)) {

            DebugPrint((0, 
                        "All or no targets responded. Will complete QDR\n"));

            iSpLaunchEnumerationCompletion(fdoExtension);

        }

        KeReleaseSpinLock(&(fdoExtension->EnumerationSpinLock),
                          oldIrql);

    } else {
        DebugPrint((1, "iSpEnumerateDevices : Client node not setup yet\n"));

        status = STATUS_UNSUCCESSFUL;

        Irp = fdoExtension->EnumerationIrp;
        fdoExtension->EnumerationIrp = NULL;

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return;
}

/*

NTSTATUS
iSpPerformDeviceEnumeration(
    IN PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PISCSI_CONNECTION iScsiConnection = fdoExtension->ClientNodeInfo;
    PISCSI_LOGIN_COMMAND iscsiLoginCommand;
    LARGE_INTEGER disconnectTimeout;
    NTSTATUS status;
    USHORT connectionID;

    ASSERT((iScsiConnection != NULL));
    ASSERT((iScsiConnection->Type) == ISCSI_CONNECTION_TYPE);
    ASSERT((iScsiConnection->ConnectionState) == ConnectionStateConnected);

    if ((fdoExtension->CurrentProtocolState) != PSConnectedToServer) {
        DebugPrint((1, "Probably already logged on. CurrentState : %d\n",
                    (fdoExtension->CurrentProtocolState)));
        return STATUS_UNSUCCESSFUL;
    } 

    //
    // First send logon packet
    //
    fdoExtension->CurrentIrp = Irp;
    fdoExtension->CurrentProtocolState = PSLogonInProgress;

    status = iSpSendLoginCommand(fdoExtension);
    if (NT_SUCCESS(status)) {
        DebugPrint((3, "Login command sent successfully\n"));
    } else {
        DebugPrint((1, "Send failed for logon. Status : %x\n", status));

        fdoExtension->CurrentIrp = NULL;
        fdoExtension->CurrentProtocolState = PSLogonFailed;

        disconnectTimeout.QuadPart = -100000000L;

        iScsiConnection->ConnectionState = ConnectionStateStopping;

        status = iSpTdiDisconnect(iScsiConnection->ConnectionDeviceObject,
                                  iScsiConnection->ConnectionFileObject,
                                  TDI_DISCONNECT_RELEASE,
                                  iSpTdiCompletionRoutine,
                                  iScsiConnection,
                                  disconnectTimeout);

        DebugPrint((3, "iSpTdiDisconnect  returned : %x\n",
                    status));

        return STATUS_UNSUCCESSFUL;
    }

    //
    // QDR Irp will be completed upon receipt of login response
    // 
    // ISSUE : nramas : 12/24/2000
    //    Should have a timer here to take care of the case where
    //    the server fails to send logon response.
    //
    return STATUS_SUCCESS;
}
*/


NTSTATUS
iSpQueryDeviceRelationsCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PISCSI_PDO_EXTENSION pdoExtension;

    PCOMMON_EXTENSION commonExtension;
    PISCSI_CONNECTION iScsiConnection;
    PISCSI_LOGIN_RESPONSE loginResponse;
    PIRP Irp;
    PDEVICE_OBJECT pdo;
    PDEVICE_RELATIONS deviceRelations;

    PACTIVE_REQUESTS activeClientRequests = NULL;

    ULONG relationSize;
    ULONG maxCmdRN = 0;
    ULONG inx;
    ULONG targetIndex;

    NTSTATUS status = STATUS_SUCCESS;

    IoFreeWorkItem((PIO_WORKITEM) Context);

    Irp = fdoExtension->EnumerationIrp;
    fdoExtension->EnumerationIrp = NULL;

    relationSize = sizeof(DEVICE_RELATIONS) + 
                   ((fdoExtension->NumberOfTargets) * sizeof(PDEVICE_OBJECT));

    deviceRelations = iSpAllocatePool(PagedPool,
                                      relationSize,
                                      ISCSI_TAG_DEVICE_RELATIONS);
    if (deviceRelations == NULL) {
        DebugPrint((1, "Failed to allocate memory for device relations\n"));

        for (inx = 0; inx < (fdoExtension->NumberOfTargets); inx++) {
            pdo = fdoExtension->PDOList[inx];

            iSpStopNetwork(pdo);

            IoDeleteDevice(pdo);

            fdoExtension->PDOList[inx] = NULL;
        }

        fdoExtension->NumberOfTargets = 0;

        fdoExtension->LocalNodesInitialized = FALSE;

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    deviceRelations->Count = 0;

    targetIndex = 0;
    for (inx = 0; inx < (fdoExtension->NumberOfTargets); inx++) {

        pdo = fdoExtension->PDOList[inx];

        pdoExtension = (PISCSI_PDO_EXTENSION)(pdo->DeviceExtension);

        iScsiConnection = pdoExtension->ClientNodeInfo;

        if ((pdoExtension->CurrentProtocolState) == PSLogonSucceeded) {

            loginResponse = (PISCSI_LOGIN_RESPONSE) (iScsiConnection->IScsiPacket);

            //
            // Allocate memory to keep active requests. Size of this
            // array is the value returned in MaxCmdRN field
            //
            GetUlongFromArray((loginResponse->InitStatRN),
                              (iScsiConnection->CurrentStatusRefNum));

            GetUlongFromArray((loginResponse->ExpCmdRN),
                              (iScsiConnection->CommandRefNum));

            GetUlongFromArray((loginResponse->MaxCmdRN), maxCmdRN);

            iScsiConnection->MaxCommandRefNum = maxCmdRN;

            DebugPrint((1, "InitStatRN : %d, ExpCmdRN : %d, MaxCmdRN : %d\n",
                        (iScsiConnection->CurrentStatusRefNum),
                        (iScsiConnection->CommandRefNum),
                        maxCmdRN));

            ASSERT((maxCmdRN != 0));

            ASSERT(((iScsiConnection->CommandRefNum) <= maxCmdRN));

            iScsiConnection->NumberOfReqsInProgress = 0;

            iScsiConnection->ReceiveState = ReceiveHeader;

            iScsiConnection->MaxPendingRequests = maxCmdRN;

            activeClientRequests = iSpAllocatePool(
                                      NonPagedPool,
                                      (sizeof(ACTIVE_REQUESTS) * (maxCmdRN + 1)),
                                      ISCSI_TAG_ACTIVE_REQ);

            if (activeClientRequests == NULL) {

                DebugPrint((1, "Failed to allocate ActiveClientRequests array\n"));

                iSpStopNetwork(pdo);

                IoDeleteDevice(pdo);

                fdoExtension->PDOList[inx] = NULL;
            } else {
                RtlZeroMemory(activeClientRequests, 
                              (sizeof(ACTIVE_REQUESTS) * (maxCmdRN + 1)));

                commonExtension = pdo->DeviceExtension;
                pdoExtension = pdo->DeviceExtension;
                pdo->StackSize = 1;
                pdo->Flags |= (DO_BUS_ENUMERATED_DEVICE | DO_DIRECT_IO);
                pdo->AlignmentRequirement = DeviceObject->AlignmentRequirement;

                commonExtension->DeviceObject = pdo;
                commonExtension->LowerDeviceObject = DeviceObject;
                commonExtension->IsPdo = TRUE;
                commonExtension->MajorFunction = PdoMajorFunctionTable;
                commonExtension->RemoveLock = 0;
                commonExtension->CurrentPnpState = 0xff;
                commonExtension->PreviousPnpState = 0xff;

                iScsiConnection->ActiveClientRequests = activeClientRequests;

                //
                // Inquiry data will be filled when we get the
                // first query id irp
                //
                pdoExtension->InquiryDataInitialized = FALSE;

                pdoExtension->CurrentProtocolState = PSFullFeaturePhase;

                pdoExtension->IsEnumerated = TRUE;

                //
                // Initialize the remove lock event.
                //

                KeInitializeEvent(
                    &(commonExtension->RemoveEvent),
                    SynchronizationEvent,
                    FALSE);

                //
                // Initialize the request list for this PDO
                //
                InitializeListHead(&(iScsiConnection->RequestList));

                pdo->Flags &= ~DO_DEVICE_INITIALIZING;

                fdoExtension->PDOList[targetIndex] = pdo;
                targetIndex++;

                ObReferenceObject(pdo);
                
                DebugPrint((1, "PDO %d : 0x%x\n",
                            (deviceRelations->Count), pdo));

                deviceRelations->Objects[deviceRelations->Count] = pdo;
                
                (deviceRelations->Count)++;

            }
        } else {
            iSpStopNetwork(pdo);

            IoDeleteDevice(pdo);

            fdoExtension->PDOList[inx] = NULL;
        }
    }

    //
    // Group all the targets to the beginning of the PDOList
    //
    for (inx = targetIndex; inx < MAX_TARGETS_SUPPORTED; inx++) {
        fdoExtension->PDOList[inx] = NULL;
    }

    DebugPrint((1, "Number of PDOs reported : %d\n",
                (deviceRelations->Count)));

    if ((deviceRelations->Count) > 0)  {
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

        fdoExtension->EnumerationComplete = TRUE;
        fdoExtension->NumberOfTargets = deviceRelations->Count;

        IoCopyCurrentIrpStackLocationToNext(Irp);

        return IoCallDriver((fdoExtension->CommonExtension.LowerDeviceObject), 
                            Irp);
    } else {
        DebugPrint((1, "No PDOs to report in QDR\n"));
        ExFreePool(deviceRelations);

        fdoExtension->NumberOfTargets = 0;

        fdoExtension->LocalNodesInitialized = FALSE;

        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        Irp->IoStatus.Information = 0L;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
IssueInquiry(
    IN PDEVICE_OBJECT LogicalUnit
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = LogicalUnit->DeviceExtension;
    PIRP irp;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    PVOID dataBuffer;
    PSENSE_DATA senseInfoBuffer;

    UCHAR allocationLength;
    ULONG bytesReturned;

    NTSTATUS status;

    PAGED_CODE();

    dataBuffer = &(pdoExtension->InquiryData);
    senseInfoBuffer = &(pdoExtension->InquirySenseBuffer);

    irp = IoAllocateIrp((LogicalUnit->StackSize) + 1, FALSE);
    if (irp == NULL) {
        DebugPrint((1, "IssueInquiry : Failed to allocate IRP.\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoInitializeIrp(irp,
                    IoSizeOfIrp((LogicalUnit->StackSize) + 1),
                    ((LogicalUnit->StackSize) + 1));

    //
    // Fill in SRB fields.
    //

    RtlZeroMemory(dataBuffer, sizeof(INQUIRYDATA));
    RtlZeroMemory(senseInfoBuffer, SENSE_BUFFER_SIZE);
    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set flags to disable synchronous negociation.
    //

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 4 seconds.
    //

    srb.TimeOutValue = 4;

    srb.CdbLength = 6;

    cdb = (PCDB)(srb.Cdb);

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    allocationLength = sizeof(INQUIRYDATA);

    cdb->CDB6INQUIRY3.AllocationLength = allocationLength;

    cdb->CDB6INQUIRY3.EnableVitalProductData = FALSE;


    cdb->CDB6INQUIRY3.PageCode = 0;

    status = iSpSendSrbSynchronous(LogicalUnit,
                                   &srb,
                                   irp,
                                   dataBuffer,
                                   allocationLength,
                                   senseInfoBuffer,
                                   SENSE_BUFFER_SIZE,
                                   &bytesReturned
                                   );

    ASSERT(bytesReturned <= allocationLength);

    //
    // Return the inquiry data for the device if the call was successful.
    // Otherwise cleanup.
    //

    if(NT_SUCCESS(status)) {

        pdoExtension->InquiryDataInitialized = TRUE;

        DebugPrint((3, "Inquiry data obtained successfully\n"));
    } else {
        DebugPrint((1, "Failed to obtain inquiry data. Status : %x\n",
                    status));
    }

    IoFreeIrp(irp);

    return status;
}



NTSTATUS
iSpSendSrbSynchronous(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIRP Irp,
    IN PVOID DataBuffer,
    IN ULONG TransferLength,
    IN OPTIONAL PVOID SenseInfoBuffer,
    IN OPTIONAL UCHAR SenseInfoBufferLength,
    OUT PULONG BytesReturned
    )
{
    KEVENT event;

    PIO_STACK_LOCATION irpStack;
    PMDL Mdl = NULL;

    PSENSE_DATA senseInfo = SenseInfoBuffer;

    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if(ARGUMENT_PRESENT(DataBuffer)) {
        ASSERT(TransferLength != 0);

        Mdl = IoAllocateMdl(DataBuffer,
                            TransferLength,
                            FALSE,
                            FALSE,
                            NULL);

        if(Mdl == NULL) {
            IoFreeIrp(Irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool(Mdl);
        Irp->MdlAddress = Mdl;
    } else {
        ASSERT(TransferLength == 0);
    }

    irpStack = IoGetNextIrpStackLocation(Irp);

    //
    // Mark the minor function to indicate that this is an internal scsiport
    // request and that the start state of the device can be ignored.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    irpStack->Parameters.Scsi.Srb = Srb;

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    Srb->OriginalRequest = Irp;

    //
    // Enable auto request sense.
    //

    if(ARGUMENT_PRESENT(SenseInfoBuffer)) {
        Srb->SenseInfoBuffer = SenseInfoBuffer;
        Srb->SenseInfoBufferLength = SenseInfoBufferLength;
    } else {
        Srb->SenseInfoBuffer = NULL;
        Srb->SenseInfoBufferLength = 0;
        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
    }

    if(ARGUMENT_PRESENT(Mdl)) {
        Srb->DataBuffer = MmGetMdlVirtualAddress(Mdl);
        Srb->DataTransferLength = TransferLength;
    } else {
        Srb->DataBuffer = NULL;
        Srb->DataTransferLength = 0;
    }

    IoSetCompletionRoutine(Irp,
                           iSpSetEvent,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    KeEnterCriticalRegion();

    status = IoCallDriver(LogicalUnit, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = Irp->IoStatus.Status;

    *BytesReturned = (ULONG) Irp->IoStatus.Information;

    IoFreeMdl(Mdl);

    KeLeaveCriticalRegion();

    return status;
}


VOID
iSpTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension;
    PISCSI_PDO_EXTENSION pdoExtension;
    PDEVICE_OBJECT pdo;
    ULONG inx;
    UCHAR oldIrql;

    fdoExtension = (PISCSI_FDO_EXTENSION) DeviceObject->DeviceExtension;

    KeAcquireSpinLock(&(fdoExtension->EnumerationSpinLock),
                      &oldIrql);

    if ((fdoExtension->TargetsYetToRespond) > 0) {

        for (inx = 0; inx < (fdoExtension->NumberOfTargets); inx++) {

            pdo = fdoExtension->PDOList[inx];
            if (pdo != NULL) {

                pdoExtension = (PISCSI_PDO_EXTENSION) (pdo->DeviceExtension);

                if ((pdoExtension->CurrentProtocolState) == PSLogonInProgress) {
                    (pdoExtension->LogonTickCount)++;
                }

                if ((pdoExtension->LogonTickCount) == MAX_LOGON_WAIT_TIME) {

                    DebugPrint((0, "Timeout waiting for logon response\n"));

                    pdoExtension->CurrentProtocolState = PSLogonTimedOut;

                    (fdoExtension->TargetsYetToRespond)--;

                    if ((fdoExtension->TargetsYetToRespond) == 0) {

                        DebugPrint((0, 
                                    "TickHandler : All targets responded.\n"));

                        iSpLaunchEnumerationCompletion(fdoExtension);
                    }
                }
            }

        }
    }

    KeReleaseSpinLock(&(fdoExtension->EnumerationSpinLock),
                      oldIrql);
}


VOID
iSpLaunchEnumerationCompletion(
    IN PISCSI_FDO_EXTENSION FdoExtension
    )
{
    PIO_WORKITEM workItem;

    if ((FdoExtension->EnumerationThreadLaunched) == FALSE) {
        
        workItem = IoAllocateWorkItem(FdoExtension->DeviceObject);
        if (workItem != NULL) {

            IoQueueWorkItem(workItem,
                            iSpQueryDeviceRelationsCompletion,
                            DelayedWorkQueue,
                            workItem);

            FdoExtension->EnumerationThreadLaunched = TRUE;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\internal.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    internal.c

Abstract:

    This file contains internal routines 

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, iScsiPortFdoDeviceControl)
#pragma alloc_text(PAGE, iScsiPortFdoCreateClose)
#endif // ALLOC_PRAGMA

/*
PISCSI_PDO_EXTENSION
GetPdoExtension(
    IN PISCSI_FDO_EXTENSION fdoExtension
    );
*/


NTSTATUS
iScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    ULONG isRemoved;
    ULONG ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    DebugPrint((1, "FDO DeviceControl - IO control code : 0x%08x\n",
                ioControlCode));

    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);
    if(isRemoved) {
        iSpReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    switch (ioControlCode) {
        case IOCTL_STORAGE_QUERY_PROPERTY: {

            PSTORAGE_PROPERTY_QUERY query = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_PROPERTY_QUERY)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // This routine will release the lock and complete the irp.
            //
            status = iScsiPortQueryProperty(DeviceObject, Irp);
            return status;

            break;
        }

        //
        // Get adapter capabilities.
        //
        case IOCTL_SCSI_GET_CAPABILITIES: {

            //
            // If the output buffer is equal to the size of the a PVOID then just
            // return a pointer to the buffer.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                == sizeof(PVOID)) {

                *((PVOID *)Irp->AssociatedIrp.SystemBuffer)
                    = &fdoExtension->IoScsiCapabilities;

                Irp->IoStatus.Information = sizeof(PVOID);
                status = STATUS_SUCCESS;
                break;

            }

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                < sizeof(IO_SCSI_CAPABILITIES)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                          &fdoExtension->IoScsiCapabilities,
                          sizeof(IO_SCSI_CAPABILITIES));

            Irp->IoStatus.Information = sizeof(IO_SCSI_CAPABILITIES);
            status = STATUS_SUCCESS;
            break;
        }

        case IOCTL_SCSI_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT: {

            status = STATUS_NOT_SUPPORTED;
            break;
        }

        case IOCTL_SCSI_MINIPORT: {

            status = STATUS_NOT_SUPPORTED;
            break;
        }

        case IOCTL_SCSI_GET_DUMP_POINTERS: {

            status = STATUS_NOT_SUPPORTED;
            break;
        }

        case IOCTL_SCSI_RESCAN_BUS:
        case IOCTL_SCSI_GET_INQUIRY_DATA: {
            status = STATUS_NOT_SUPPORTED;
            break;
        }

        default: {
            DebugPrint((1,
                       "iScsiPortFdoDeviceControl: Unsupported IOCTL (%x)\n",
                       ioControlCode));

            status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }
    }
    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    iSpReleaseRemoveLock(DeviceObject, Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
iScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PISCSI_PDO_EXTENSION pdoExtension;
    NTSTATUS status;
    ULONG isRemoved;
    BOOLEAN sendCommandToServer = FALSE;

    //
    // Should never get here. All SCSI requests are handled
    // by the PDO Dispatch routine
    //
    DebugPrint((0, "SRB function sent to FDO Dispatch\n"));

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;

/*
    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);

    if (isRemoved && !IS_CLEANUP_REQUEST(irpStack)) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        iSpReleaseRemoveLock(DeviceObject, Irp);

        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    if ((srb->Function) != SRB_FUNCTION_EXECUTE_SCSI) {
        DebugPrint((1, "FdoDispatch - SRB Function : 0x%x\n",
                    srb->Function));
    }

    pdoExtension = GetPdoExtension(fdoExtension);

    ASSERT(pdoExtension != NULL);

    switch (srb->Function) {

        case SRB_FUNCTION_SHUTDOWN:
        case SRB_FUNCTION_FLUSH:  
        case SRB_FUNCTION_LOCK_QUEUE:
        case SRB_FUNCTION_UNLOCK_QUEUE:
        case SRB_FUNCTION_IO_CONTROL:
        case SRB_FUNCTION_WMI:  {
    
            //
            // We won't handle these functions on the client
            // side for the timebeing. 
            //  
            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            break;
        }
    
        case SRB_FUNCTION_SHUTDOWN:
        case SRB_FUNCTION_FLUSH:  {

            //
            // Send SCSIOP_SYNCHRONIZE_CACHE command
            // to flush the queue
            //
            srb->CdbLength = 10;
            srb->Cdb[0] = SCSIOP_SYNCHRONIZE_CACHE;

            IoMarkIrpPending(Irp);
    
            sendCommandToServer = TRUE;

            status = STATUS_PENDING;

            break;
        }

        case SRB_FUNCTION_EXECUTE_SCSI: {
    
            //
            // Mark Irp status pending.
            //
    
            IoMarkIrpPending(Irp);
    
            sendCommandToServer = TRUE;

            status = STATUS_PENDING;
        }
    
        case SRB_FUNCTION_RELEASE_QUEUE:
        case SRB_FUNCTION_FLUSH_QUEUE: {
    
            //
            // These will be handled on the server
            // side. Here, just return STATUS_SUCCESS
            //
            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            break;
        }
    
        case SRB_FUNCTION_RESET_BUS: {
    
            DebugPrint((1, "FdoDospatch : Received reset request\n"));

            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
    
            break;
        }
    
        case SRB_FUNCTION_ABORT_COMMAND: {
    
            DebugPrint((1, "FdoDispatch: SCSI Abort command\n"));

            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;    
    
            break;
        }
    
        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_RELEASE_DEVICE: {
    
            iSpAcquireRemoveLock((pdoExtension->CommonExtension.DeviceObject),
                                 Irp);
    
            status = iSpClaimLogicalUnit(fdoExtension, 
                                         pdoExtension,
                                         Irp);
    
            iSpReleaseRemoveLock((pdoExtension->CommonExtension.DeviceObject),
                                 Irp);
    
            break;
        }
    
        default: {
    
            //
            // Found unsupported SRB function.
            //
            DebugPrint((1,
                        "FdoDispatch: Unsupported function, SRB %p\n",
                        srb));
    
            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    if (sendCommandToServer == FALSE) {
        iSpReleaseRemoveLock(DeviceObject, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    DebugPrint((3, "FdoDispatch : Will send the command to the server\n"));

    status = iSpSendScsiCommand(DeviceObject, Irp);

    //
    // The lock will be released and IRP will be completed in
    // iSpSendScsiCommand.
    //
    if (NT_SUCCESS(status)) {
        DebugPrint((3, 
                    "FdoDispatch : Command sent to the server.\n"));
        status = STATUS_PENDING;
    } else {
        DebugPrint((1, 
                    "FdoDispatch : Failed to send the command. Status : %x\n",
                    status));
    }
    
    return status;
    */
}



NTSTATUS
iScsiPortFdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    ULONG isRemoved;

    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);
    if(irpStack->MajorFunction == IRP_MJ_CREATE) {

        if(isRemoved != NO_REMOVE) {
            status = STATUS_DEVICE_DOES_NOT_EXIST;
        } else if(commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) {
            status = STATUS_DEVICE_NOT_READY;
        }
    }

    iSpReleaseRemoveLock(DeviceObject, Irp);
    status = STATUS_SUCCESS;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
iSpSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    KeSetEvent((PKEVENT)Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
iSpClaimLogicalUnit(
    IN PISCSI_FDO_EXTENSION FdoExtension,
    IN PISCSI_PDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PDEVICE_OBJECT saveDevice;

    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((3, "Entering iSpClaimLogicalUnit\n"));

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE) {

        PdoExtension->IsClaimed = FALSE;
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        return(STATUS_SUCCESS);
    }

    //
    // Check for a claimed device.
    //

    if (PdoExtension->IsClaimed) {

        DebugPrint((0, "Device already claimed\n"));
        srb->SrbStatus = SRB_STATUS_BUSY;
        return(STATUS_DEVICE_BUSY);
    }

    //
    // Save the current device object.
    //

    saveDevice = PdoExtension->CommonExtension.DeviceObject;

    //
    // Update the lun information based on the operation type.
    //

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE) {
        PdoExtension->IsClaimed = TRUE;
    }

    if (srb->Function == SRB_FUNCTION_ATTACH_DEVICE) {
        ASSERT(FALSE);
        PdoExtension->CommonExtension.DeviceObject = srb->DataBuffer;
    }

    srb->DataBuffer = saveDevice;

    srb->SrbStatus = SRB_STATUS_SUCCESS;

    DebugPrint((3, "Successfully claimed the device\n"));
    return(STATUS_SUCCESS);
}

/*

PISCSI_PDO_EXTENSION
GetPdoExtension(
    IN PISCSI_FDO_EXTENSION fdoExtension
    )
{
    return ((fdoExtension->UpperPDO)->DeviceExtension);
}
*/


NTSTATUS
iSpProcessScsiRequest(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = LogicalUnit->DeviceExtension;
    PIRP irp;

    ULONG bytesReturned;

    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp((LogicalUnit->StackSize) + 1, FALSE);
    if (irp == NULL) {
        DebugPrint((1, "IssueInquiry : Failed to allocate IRP.\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoInitializeIrp(irp,
                    IoSizeOfIrp((LogicalUnit->StackSize) + 1),
                    ((LogicalUnit->StackSize) + 1));

    status = iSpSendSrbSynchronous(LogicalUnit,
                                   Srb,
                                   irp,
                                   Srb->DataBuffer,
                                   Srb->DataTransferLength,
                                   Srb->SenseInfoBuffer,
                                   Srb->SenseInfoBufferLength,
                                   &bytesReturned
                                   );

    ASSERT(bytesReturned <= (Srb->DataTransferLength));

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "Failed to process SRB. Status : %x\n",
                    status));
    }

    IoFreeIrp(irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\port.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    port.c

Abstract:

    This file contains code iSCSI Port driver

Environment:

    kernel mode only

Revision History:

--*/
#include "iscsi.h"

#if DBG

#define ISCSI_DEBUG_BUFF_LEN 128
ULONG DebugLevel = 0x00;
UCHAR iScsiDebugBuff[ISCSI_DEBUG_BUFF_LEN];
VOID
iScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for iScsiPort
    
Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None    
--*/
{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel) {
        _vsnprintf(iScsiDebugBuff, ISCSI_DEBUG_BUFF_LEN,
                   DebugMessage, ap);
        DbgPrint(iScsiDebugBuff);
    }

    va_end(ap);
}

#else

VOID
iScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\network.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    network.c

Abstract:

    This file contains TDI support routines.

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

extern HANDLE iSpTdiNotificationHandle;

extern PISCSI_FDO_EXTENSION  iSpGlobalFdoExtension;

ISCSI_EVENT_HANDLER ClientEvents[] = {
    {TDI_EVENT_DISCONNECT, iSpDisconnectHandler},
    {TDI_EVENT_RECEIVE, iSpReceiveHandler}
};

ISCSI_TARGETS IScsiTargets[MAX_TARGETS_SUPPORTED + 1];

VOID
iSpNetworkReadyCallback(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING pTransportName,
    IN PWSTR BindingList
    );

NTSTATUS
iSpReceiveCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpTdiSendCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpGetTargetInfo(
    IN PDEVICE_OBJECT DeviceObject
    );


NTSTATUS
iSpInitializeLocalNodes(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PISCSI_PDO_EXTENSION pdoExtension;
    PDEVICE_OBJECT pdo;
    ULONG nodesInx;
    NTSTATUS status = STATUS_SUCCESS;
    WCHAR deviceNameBuffer[64];
    UNICODE_STRING deviceName;

    if ((fdoExtension->LocalNodesInitialized) == FALSE) {
        
        //
        // Fill up IScsiTargets array with the list
        // of target IP addresses
        //
        status = iSpGetTargetInfo(DeviceObject);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, 
                        "Unable to read target ip addresses. Status : %x\n",
                        status));

            return status;
        }

        fdoExtension->NumberOfTargets = 0;

        nodesInx = 0;
        while ((IScsiTargets[nodesInx].TargetAddress) != 0) {

            if (nodesInx >= MAX_TARGETS_SUPPORTED) {
                break;
            }

            swprintf(deviceNameBuffer,
                     L"\\Device\\iScsiDevice%d",
                     nodesInx);
            RtlInitUnicodeString(&deviceName,
                                 deviceNameBuffer);

            status = IoCreateDevice(DeviceObject->DriverObject,
                                    sizeof(ISCSI_PDO_EXTENSION),
                                    &deviceName,
                                    FILE_DEVICE_MASS_STORAGE,
                                    FILE_DEVICE_SECURE_OPEN,
                                    FALSE,
                                    &pdo);
            if (NT_SUCCESS(status)) {

                pdoExtension = (PISCSI_PDO_EXTENSION) pdo->DeviceExtension;

                RtlZeroMemory(pdoExtension,
                              sizeof(ISCSI_PDO_EXTENSION));

                //
                // Initialize the local network node
                // for this target device
                //
                status = iSpStartNetwork(pdo);
                if (NT_SUCCESS(status)) {
                    strncpy(pdoExtension->TargetName,
                            IScsiTargets[nodesInx].TargetName,
                            MAX_TARGET_NAME_LENGTH);
                    DebugPrint((3, "TargetName : %s\n",
                                pdoExtension->TargetName));
                    pdoExtension->TargetIPAddress = 
                        IScsiTargets[nodesInx].TargetAddress;

                    pdoExtension->TargetPortNumber = ISCSI_TARGET_PORT;
                        
                    pdoExtension->ParentFDOExtension = fdoExtension;

                    pdoExtension->TargetId = (UCHAR) nodesInx;

                    fdoExtension->PDOList[fdoExtension->NumberOfTargets] = pdo;

                    (fdoExtension->NumberOfTargets)++;
                } else {
                    IoDeleteDevice(pdo);
                }
            }

            nodesInx++;
        }

        if ((fdoExtension->NumberOfTargets) > 0) {
            fdoExtension->LocalNodesInitialized = TRUE;
            status = STATUS_SUCCESS;
        } else {
            //
            // No targets to use. Need a better status code 
            // to signify that
            //
            status = STATUS_UNSUCCESSFUL;
        }
    }

    return status;
}


NTSTATUS
iSpGetTargetInfo(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PISCSIPORT_DRIVER_EXTENSION driverExtension = NULL;
    HANDLE serviceKey = NULL;
    HANDLE targetKey = NULL;
    HANDLE targetInfoKey = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG targetCount;
    ULONG inx;
    UNICODE_STRING targetStr;
    UNICODE_STRING targetInfo;
    UNICODE_STRING targetUnicodeName;
    ANSI_STRING    targetAnsiName;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR targetBuff[32];
    
    RtlZeroMemory(IScsiTargets, sizeof(IScsiTargets));

    DebugPrint((3, "Will read registry values\n"));
    driverExtension = IoGetDriverObjectExtension(
                             DeviceObject->DriverObject,
                             (PVOID) ISCSI_TAG_DRIVER_EXTENSION);
    if (driverExtension == NULL) {

        DebugPrint((0, "DriverExtension NULL\n"));
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // open the service key for iScsiPrt.
    // 
    targetCount = MAX_TARGETS_SUPPORTED;

    InitializeObjectAttributes(&objectAttributes,
                               &(driverExtension->RegistryPath),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &objectAttributes);
    if (!NT_SUCCESS(status)) {

        DebugPrint((0, "Failed to open the service key. Status : %x\n",
                    status));

        return status;
    }

    DebugPrint((3, "Opened the service key\n"));

    //
    // Open "Targets" subkey under the service key
    //
    RtlInitUnicodeString(&targetStr, L"Targets");
    InitializeObjectAttributes(&objectAttributes,
                               &targetStr,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               NULL);

    status = ZwOpenKey(&targetKey,
                       KEY_READ,
                       &objectAttributes);
    if (!NT_SUCCESS(status)) {

        DebugPrint((0, "Failed to open Targets key. Status : %x\n",
                    status));

        ZwClose(serviceKey);

        return status;
    }

    DebugPrint((3, "Opened the targets key\n"));

    //
    // First read the number of targets
    //
    RtlZeroMemory(queryTable, sizeof(queryTable));
        
    queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].DefaultType   = REG_DWORD;
    queryTable[0].DefaultLength = 0;
    queryTable[0].Name          = L"TargetCount";
    queryTable[0].EntryContext  = &targetCount;
    queryTable[0].DefaultData   = &targetCount;
        
    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    targetKey,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "Failed to get TargetCount value. Status :\n",
                    status));

        ZwClose(targetKey);
        ZwClose(serviceKey);

        return status;
    } 

    //
    // Get the info about each target
    //

    if (targetCount > MAX_TARGETS_SUPPORTED) {
        DebugPrint((0, "TargetCount > MAX_TARGETS_SUPPORTED  : %d\n",
                    targetCount));
        targetCount = MAX_TARGETS_SUPPORTED;
    }

    DebugPrint((3, "Number of targets : %d\n", targetCount));

    RtlZeroMemory(queryTable, sizeof(queryTable));

    for (inx = 0; inx < targetCount; inx++) {
        WCHAR targetNameBuff[MAX_TARGET_NAME_LENGTH + 1];

        swprintf(targetBuff, L"TargetInfo%d", (inx + 1));
        RtlInitUnicodeString(&targetInfo, targetBuff);

        InitializeObjectAttributes(&objectAttributes,
                                   &targetInfo,
                                   OBJ_CASE_INSENSITIVE,
                                   targetKey,
                                   NULL);

        status = ZwOpenKey(&targetInfoKey,
                           KEY_READ,
                           &objectAttributes);
        if (!NT_SUCCESS(status)) {

            DebugPrint((0, "Failed to open target info key. Status %x\n",
                        status));

            break;
        }

        queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].DefaultType   = REG_SZ;
        queryTable[0].DefaultLength = 0;
        queryTable[0].Name          = L"TargetName";

        targetUnicodeName.Length = MAX_TARGET_NAME_LENGTH;
        targetUnicodeName.MaximumLength = MAX_TARGET_NAME_LENGTH;
        targetUnicodeName.Buffer = targetNameBuff;
        queryTable[0].EntryContext  = &targetUnicodeName;
        queryTable[0].DefaultData   = &targetUnicodeName;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        targetInfoKey,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Failed to get target name. Status %x\n",
                        status));

            ZwClose(targetInfoKey);

            break;
        }

        queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].DefaultType   = REG_DWORD;
        queryTable[0].DefaultLength = 0;
        queryTable[0].Name          = L"TargetAddress";
        queryTable[0].EntryContext  = &(IScsiTargets[inx].TargetAddress);
        queryTable[0].DefaultData   = &(IScsiTargets[inx].TargetAddress);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        targetInfoKey,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Failed to get target IP Address. Status %x\n",
                        status));

            ZwClose(targetInfoKey);

            break;
        }

        targetAnsiName.Length = MAX_TARGET_NAME_LENGTH;
        targetAnsiName.MaximumLength = MAX_TARGET_NAME_LENGTH;
        targetAnsiName.Buffer = (IScsiTargets[inx].TargetName);
        RtlUnicodeStringToAnsiString(&targetAnsiName, 
                                     &targetUnicodeName, 
                                     FALSE);

        ZwClose(targetInfoKey);

    }

    if (NT_SUCCESS(status)) {
        for (inx = 0; inx < targetCount; inx++) {
            DebugPrint((3, "Target Address %d : 0x%08x. Target Name : %s\n",
                        (inx + 1), (IScsiTargets[inx]).TargetAddress,
                        (IScsiTargets[inx]).TargetName));
        }
    }

    ZwClose(targetKey);

    ZwClose(serviceKey);

    return status;
}


NTSTATUS
iSpStartNetwork(
    IN PDEVICE_OBJECT DeviceObject
    )
/*+++

Routine Description :

    This routine sets up the TDI address for the server to which 
    the clients will connect to.
    
    It also sets up the address for the client. This address will 
    be later used by the client to connect to the server.
    
Arguement :

    DeviceObject : PDO for which we need to setup local network node
    
Return Value :

    STATUS_SUCCESS if the addresses were setup correctly.
    Appropriate NTStatus code on error.
--*/
{
    PISCSI_PDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIRP Irp = NULL;
    PISCSI_CONNECTION   iScsiConnection = NULL;
    NTSTATUS status;
    ULONG countOfEvents;

    status = STATUS_SUCCESS;

    if ((pdoExtension->IsClientNodeSetup) == FALSE) {
        //
        // Allocate an IRP to be used in various routines
        //
        if ((Irp = IoAllocateIrp((DeviceObject->StackSize) + 1, FALSE)) == NULL) {
            DebugPrint((1, "Failed to allocate Irp\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto iSpStartNetworkExit;
        }

        iScsiConnection = iSpAllocatePool(NonPagedPool,
                                          sizeof(ISCSI_CONNECTION),
                                          ISCSI_TAG_CONNECTION);
        if (iScsiConnection == NULL) {
            DebugPrint((1, "Failed to allocate iScsiConnection\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto iSpStartNetworkExit;
        }

        RtlZeroMemory(iScsiConnection, sizeof(ISCSI_CONNECTION));

        iScsiConnection->Type = ISCSI_CONNECTION_TYPE;
        iScsiConnection->Size = sizeof(ISCSI_CONNECTION);

        pdoExtension->CurrentProtocolState = PSNodeInitInProgress;

        DebugPrint((3, "Will setup client node\n"));
        status = iSpSetupNetworkNode(ISCSI_ANY_ADDRESS,
                                     ISCSI_CLIENT_ANY_PORT,
                                     Irp,
                                     (PVOID) DeviceObject,
                                     iScsiConnection);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1, "Failed to setup server node. Status %x\n",
                        status));
            goto iSpStartNetworkExit;
        }

        //
        // Set the event handlers for the client
        //
        DebugPrint((3, "Client node setup. Will register event handlers\n"));
        countOfEvents = countof(ClientEvents);
        status = iSpTdiSetEventHandler(Irp,
                                       iScsiConnection->AddressDeviceObject,
                                       iScsiConnection->AddressFileObject,
                                       ClientEvents,
                                       countOfEvents,
                                       (PVOID) pdoExtension);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1, "Failed to register event handlers for client\n"));
            iSpCloseNetworkNode(iScsiConnection);

            goto iSpStartNetworkExit;
        } else {
            DebugPrint((3, "Registered event handlers for client\n"));
            iScsiConnection->DeviceObject = DeviceObject;
            iScsiConnection->ConnectionState = ConnectionStateDisconnected;
            iScsiConnection->ReceiveState = ReceiveHeader;
            iScsiConnection->InitiatorTaskTag = 1;
            iScsiConnection->CompleteHeaderReceived = TRUE;
            KeInitializeSpinLock(&(iScsiConnection->RequestLock));
            KeInitializeSpinLock(&(iScsiConnection->ListSpinLock));
            pdoExtension->ClientNodeInfo = iScsiConnection;
            pdoExtension->IsClientNodeSetup = TRUE;
            pdoExtension->CurrentProtocolState = PSNodeInitialized;
        }
    }

iSpStartNetworkExit:

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "Failing StartNetwotk with status : %x\n",
                    status));

        if (iScsiConnection != NULL) {
            ExFreePool(iScsiConnection);
        }
    }

    return status;
}


NTSTATUS
iSpSetupNetworkNode(
    IN ULONG  InAddress,
    IN USHORT InPort,
    IN PIRP   Irp,
    IN PVOID ConnectionContext,
    OUT PISCSI_CONNECTION ConnectionInfo
    )
{
    NTSTATUS status;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO   tdiAddressInfo;
    PTA_ADDRESS         tdiTAAddress;
    PTRANSPORT_ADDRESS  tdiTransportAddress;
    PTDI_ADDRESS_IP     tdiIPAddress;

    HANDLE tdiAddrHandle;
    PFILE_OBJECT tdiAddrFileObject;
    PDEVICE_OBJECT tdiAddrDeviceObject;

    HANDLE tdiConnectionHandle;
    PFILE_OBJECT tdiConnectionFileObject;
    PDEVICE_OBJECT tdiConnectionDeviceObject;

    UCHAR  tdiAddressBuffer[TDI_QUERY_ADDRESS_LENGTH_IP];

    //
    // Create the address with wellknown port number for the server.
    // Clients will connect to this port to query for shared devices.
    //
    status = iSpCreateTdiAddressObject(InAddress,
                                       InPort,
                                       &tdiAddrHandle,
                                       &tdiAddrFileObject,
                                       &tdiAddrDeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Failed to setup address. Status %x\n",
                    status));
        return status;
    }

    //
    // Query information to retrieve address, port number, etc of 
    // the address we just setup.
    //
    status = iSpTdiQueryInformation(tdiAddrDeviceObject,
                                    tdiAddrFileObject,
                                    (PTDI_ADDRESS_INFO)tdiAddressBuffer,
                                    TDI_QUERY_ADDRESS_LENGTH_IP);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Could not query address info for the server. Status %x\n",
                    status));

        iSpCloseTdiAddress(tdiAddrHandle,
                           tdiAddrFileObject);

        return status;
    }

    tdiAddressInfo = (PTDI_ADDRESS_INFO) tdiAddressBuffer;
    tdiTransportAddress = (PTRANSPORT_ADDRESS) &(tdiAddressInfo->Address);
    tdiTAAddress = tdiTransportAddress->Address;
    ASSERT((tdiTAAddress->AddressType) == TDI_ADDRESS_TYPE_IP);
    ASSERT((tdiTAAddress->AddressLength) == sizeof(TDI_ADDRESS_IP));
    tdiIPAddress = (PTDI_ADDRESS_IP) tdiTAAddress->Address;

    DebugPrint((3, "Query succeeded. Address 0x%x, Port Number 0x%x\n",
                tdiIPAddress->in_addr,
                ntohs(tdiIPAddress->sin_port)));

    //
    // Create the connection endpoint for the server address
    //
    status = iSpCreateTdiConnectionObject(DD_TCP_DEVICE_NAME,
                                          ConnectionInfo,
                                          &tdiConnectionHandle,
                                          &tdiConnectionFileObject,
                                          &tdiConnectionDeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Could not create connection for the server. Status %x\n",
                    status));

        iSpCloseTdiAddress(tdiAddrHandle,
                           tdiAddrFileObject);
        return status;
    }

    //
    // Associate the address and the connection endpoint created above
    //
    status = iSpTdiAssociateAddress(Irp, 
                                    tdiAddrHandle,
                                    tdiConnectionFileObject,
                                    tdiConnectionDeviceObject
                                    );
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Could not associate address for server. Status %x\n",
                    status));

        iSpCloseTdiConnection(tdiConnectionHandle,
                              tdiConnectionFileObject);
        iSpCloseTdiAddress(tdiAddrHandle,
                           tdiAddrFileObject);
        return status;
    }

    //
    // Done setting up the server. Save all the relevant info
    // in our device extension
    //
    ConnectionInfo->AddressHandle = tdiAddrHandle;
    ConnectionInfo->AddressFileObject = tdiAddrFileObject;
    ConnectionInfo->AddressDeviceObject = tdiAddrDeviceObject;
    ConnectionInfo->ConnectionHandle = tdiConnectionHandle;
    ConnectionInfo->ConnectionFileObject = tdiConnectionFileObject;
    ConnectionInfo->ConnectionDeviceObject = tdiConnectionDeviceObject;
    RtlCopyMemory(&(ConnectionInfo->IPAddress),
                  tdiIPAddress,
                  sizeof(TDI_ADDRESS_IP));

    DebugPrint((3, "Node setup. Address 0x%08x, Port Number 0x%x\n",
                tdiIPAddress->in_addr,
                ntohs(tdiIPAddress->sin_port)));

    return STATUS_SUCCESS;
}


NTSTATUS
iSpCloseNetworkNode(
    PISCSI_CONNECTION iScsiConnection
    )
{
    NTSTATUS status;

    status = iSpTdiDisassociateAddress(iScsiConnection->ConnectionDeviceObject,
                                       iScsiConnection->ConnectionFileObject);

    if (NT_SUCCESS(status)) {
        iSpCloseTdiConnection(iScsiConnection->ConnectionHandle,
                              iScsiConnection->ConnectionFileObject);
        iSpCloseTdiAddress(iScsiConnection->AddressHandle,
                           iScsiConnection->AddressFileObject);
    }

    return status;
}


NTSTATUS
iSpCreateTdiAddressObject(
    IN ULONG InAddress,
    IN USHORT InPort,
    OUT PVOID *AddrHandle,
    OUT PFILE_OBJECT *AddrFileObject,
    OUT PDEVICE_OBJECT *AddrDeviceObject
    )
{
    TA_IP_ADDRESS IPAddress;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PVOID Handle;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock; 
    NTSTATUS status;
    UCHAR eaBufferBuffer[FILE_FULL_EA_INFO_ADDR_LENGTH];

    RtlZeroMemory(&IPAddress, sizeof(TA_IP_ADDRESS));
    IPAddress.TAAddressCount = 1;
    IPAddress.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    IPAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    IPAddress.Address[0].Address[0].in_addr = htonl(InAddress);
    IPAddress.Address[0].Address[0].sin_port = htons(InPort);

    RtlInitUnicodeString(&deviceName, DD_TCP_DEVICE_NAME);
    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    eaBuffer = (FILE_FULL_EA_INFORMATION UNALIGNED *)eaBufferBuffer;

    RtlZeroMemory(eaBuffer, sizeof(eaBufferBuffer));
    eaBuffer->NextEntryOffset = 0;
    eaBuffer->Flags = 0;
    eaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    eaBuffer->EaValueLength = sizeof(TA_IP_ADDRESS);

    //
    // Set EaName
    //
    RtlMoveMemory(&(eaBuffer->EaName[0]),
                  TdiTransportAddress,
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1);

    //
    // Set EaValue
    //
    RtlMoveMemory(&(eaBuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1]),
                  &IPAddress,
                  sizeof(TA_IP_ADDRESS)
                  );

    status = ZwCreateFile(&Handle,
                          (GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE),
                          &objectAttributes,
                          &ioStatusBlock,
                          0,
                          0,
                          (FILE_SHARE_READ | FILE_SHARE_WRITE),
                          FILE_CREATE,
                          0,
                          eaBuffer,
                          FILE_FULL_EA_INFO_ADDR_LENGTH);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "CreateTdiAddress failed. Status %x\n",
                    status));
        return status;
    }

    //
    // Get the associated fileobject
    //
    status = ObReferenceObjectByHandle(Handle,
                                       0,
                                       NULL,
                                       KernelMode,
                                       &FileObject,
                                       NULL);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "ObReferenceObjectByHandle failed. Status %x\n",
                    status));
        ZwClose(Handle);
        return status;
    }

    //
    // Get the associated deviceobject
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    *AddrHandle = Handle;
    *AddrFileObject = FileObject;
    *AddrDeviceObject = DeviceObject;

    return STATUS_SUCCESS;
}


NTSTATUS
iSpCreateTdiConnectionObject(
    IN PWCHAR DeviceName,
    IN CONNECTION_CONTEXT ConnectionContext,
    OUT PVOID *ConnectionHandle,
    OUT PFILE_OBJECT *ConnectionFileObject,
    OUT PDEVICE_OBJECT *ConnectionDeviceObject
    )
{
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PVOID Handle;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    CONNECTION_CONTEXT *eaCEPContext;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock; 
    NTSTATUS status;
    UCHAR eaBufferBuffer[FILE_FULL_EA_INFO_CEP_LENGTH];

    RtlInitUnicodeString(&deviceName, DD_TCP_DEVICE_NAME);
    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    eaBuffer = (FILE_FULL_EA_INFORMATION UNALIGNED *)eaBufferBuffer;

    eaBuffer->NextEntryOffset = 0;
    eaBuffer->Flags = 0;
    eaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    eaBuffer->EaValueLength = sizeof(CONNECTION_CONTEXT);

    //
    // Set EaName
    //
    RtlMoveMemory(eaBuffer->EaName,
                  TdiConnectionContext,
                  TDI_CONNECTION_CONTEXT_LENGTH + 1);

    //
    // Set EaValue
    //
    eaCEPContext = (CONNECTION_CONTEXT UNALIGNED *)
                   &(eaBuffer->EaName[TDI_CONNECTION_CONTEXT_LENGTH + 1]);
    *eaCEPContext = (CONNECTION_CONTEXT)ConnectionContext;

    status = ZwCreateFile(&Handle,
                          (GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE),
                          &objectAttributes,
                          &ioStatusBlock,
                          0,
                          0,
                          0,
                          FILE_CREATE,
                          0,
                          eaBuffer,
                          FILE_FULL_EA_INFO_CEP_LENGTH);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "CreateTdiConnection failed. Status %x\n",
                    status));
        return status;
    }

    //
    // Get the associated fileobject
    //
    status = ObReferenceObjectByHandle(Handle,
                                       0,
                                       NULL,
                                       KernelMode,
                                       &FileObject,
                                       NULL);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "ObReferenceObjectByHandle failed. Status %x\n",
                    status));
        ZwClose(Handle);
        return status;
    }

    //
    // Get the associated deviceobject
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    *ConnectionHandle = Handle;
    *ConnectionFileObject = FileObject;
    *ConnectionDeviceObject = DeviceObject;

    return STATUS_SUCCESS;
}


NTSTATUS
iSpTdiAssociateAddress(
    IN PIRP Irp,
    IN PVOID AddrHandle,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    NTSTATUS status;

    TdiBuildAssociateAddress(Irp,
                             ConnectionDeviceObject,
                             ConnectionFileObject,
                             iSpTdiCompletionRoutine,
                             NULL,
                             AddrHandle);

    status = iSpTdiSendIrpSynchronous(ConnectionDeviceObject,
                                      Irp);

    return status;
}


NTSTATUS
iSpTdiDisassociateAddress(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject
    )
{
    NTSTATUS status;
    PIRP Irp;

    Irp = IoAllocateIrp(ConnectionDeviceObject->StackSize, FALSE);
    if (Irp != NULL) {
        TdiBuildDisassociateAddress(Irp,
                                    ConnectionDeviceObject,
                                    ConnectionFileObject,
                                    iSpTdiCompletionRoutine,
                                    NULL);

        status = iSpTdiSendIrpSynchronous(ConnectionDeviceObject,
                                          Irp);

    } else {
        DebugPrint((1, 
                    "iSpTdiDisassociateAddress : Failed to allocate IRP\n"));
        status = STATUS_NO_MEMORY;
    }

    return status;
}


NTSTATUS
iSpTdiSetEventHandler(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER EventsToSet,
    IN ULONG CountOfEvents,
    IN PVOID EventContext
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS oldStatus = STATUS_SUCCESS;
    ULONG inx, tmp;

    for (inx = 0; inx < CountOfEvents; inx++) {
        TdiBuildSetEventHandler(Irp,
                                DeviceObject,
                                FileObject,
                                iSpTdiCompletionRoutine,
                                NULL,
                                EventsToSet[inx].EventId,
                                EventsToSet[inx].EventHandler,
                                EventContext);

        status = iSpTdiSendIrpSynchronous(DeviceObject,
                                          Irp);

        DebugPrint((3, "Status from iSpTdiSetEventHandler : %x\n",
                    status));

        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    oldStatus = status;
    if (!NT_SUCCESS(status)) {
        for (tmp = 0; tmp < inx; tmp++) {
            TdiBuildSetEventHandler(Irp,
                                    DeviceObject,
                                    FileObject,
                                    iSpTdiCompletionRoutine,
                                    NULL,
                                    EventsToSet[tmp].EventId,
                                    NULL,
                                    NULL);

            status = iSpTdiSendIrpSynchronous(DeviceObject,
                                              Irp);

            DebugPrint((3, "Status from iSpTdiSetEventHandler : %x\n",
                        status));
        }
    } 

    return oldStatus;
}


NTSTATUS
iSpTdiResetEventHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER EventsToSet,
    IN ULONG CountOfEvents
    )
{
    PIRP localIrp;
    ULONG inx;
    NTSTATUS status;

    localIrp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((1, "iSpTdiResetEventHandler : Failed to allocate IRP\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (inx = 0; inx < CountOfEvents; inx++) {
        TdiBuildSetEventHandler(localIrp,
                                DeviceObject,
                                FileObject,
                                iSpTdiCompletionRoutine,
                                NULL,
                                EventsToSet[inx].EventId,
                                NULL,
                                NULL);

        status = iSpTdiSendIrpSynchronous(DeviceObject,
                                          localIrp);

        DebugPrint((3, "Status from iSpTdiResetEventHandler : %x\n",
                    status));
    }

    IoFreeIrp(localIrp);

    return status;
}


NTSTATUS
iSpCloseTdiAddress(
    HANDLE AddrHandle,
    PFILE_OBJECT AddrFileObject
    )
{
    if (AddrFileObject != NULL) {
        ObDereferenceObject(AddrFileObject);
    }

    if (AddrHandle != NULL ) {
        ZwClose(AddrHandle);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpCloseTdiConnection(
    HANDLE ConnectionHandle,
    PFILE_OBJECT ConnectionFileObject
    )
{
    if (ConnectionFileObject != NULL) {
        ObDereferenceObject(ConnectionFileObject);
    }

    if (ConnectionHandle != NULL) {
        ZwClose(ConnectionHandle);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpTdiDeviceControl(
    IN PIRP Irp,
    IN PMDL Mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID IrpParameter,
    IN ULONG IrpParameterLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength
    )
{
    PIRP localIrp;
    PIO_STACK_LOCATION irpStack;
    PMDL localMdl;
    NTSTATUS status;

    //
    // If caller didn't provide an IRP, allocate one
    //
    if (Irp != NULL) {
        localIrp = Irp;
    } else {
        localIrp = IoAllocateIrp((DeviceObject->StackSize) + 1,
                                 FALSE);
        if (localIrp == NULL) {
            DebugPrint((1, "IoAllocateIrp failed in iSpTdiDeviceControl\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (MdlBuffer == NULL) {
        localIrp->MdlAddress = NULL;
        localMdl = NULL;
    } else {
        if (Mdl == NULL) {
            localMdl = IoAllocateMdl(MdlBuffer,
                                     MdlBufferLength,
                                     FALSE,
                                     FALSE,
                                     localIrp);
            if (localMdl == NULL) {
                DebugPrint((1, "Failed to allocate MDL\n"));

                if (Irp == NULL) {
                    IoFreeIrp(localIrp);
                }

                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            localMdl = Mdl;
            MmInitializeMdl(localMdl,
                            MdlBuffer,
                            MdlBufferLength);
        }

        MmBuildMdlForNonPagedPool(localMdl);
    }

    irpStack = IoGetCurrentIrpStackLocation(localIrp);
    irpStack->FileObject = FileObject;
    irpStack->DeviceObject = DeviceObject;
    irpStack->MajorFunction = MajorFunction;
    irpStack->MinorFunction = MinorFunction;
    RtlCopyMemory(&(irpStack->Parameters),
                  IrpParameter,
                  IrpParameterLength);

    status = iSpTdiSendIrpSynchronous(DeviceObject, localIrp);

    if (Irp != NULL) {
        IoFreeIrp(localIrp);
    }

    return status;
}


NTSTATUS
iSpTdiQueryInformation(
    IN PDEVICE_OBJECT TdiDeviceObject,
    IN PFILE_OBJECT TdiFileObject,
    IN PTDI_ADDRESS_INFO TdiAddressBuffer,
    IN ULONG TdiAddrBuffLen
    )
{
    PMDL queryMdl;
    PIRP queryIrp;
    NTSTATUS status;


    status = iSpAllocateMdlAndIrp(TdiAddressBuffer,
                                  TdiAddrBuffLen,
                                  (CCHAR)(TdiDeviceObject->StackSize),
                                  TRUE,
                                  &queryIrp,
                                  &queryMdl);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "iSpAllocateMdlAndIrp returned %x\n",
                    status));
        return status;
    }

    //
    // Build the IRP for sending the query information request
    //
    TdiBuildQueryInformation(queryIrp,
                             TdiDeviceObject,
                             TdiFileObject,
                             iSpTdiCompletionRoutine,
                             NULL,
                             TDI_QUERY_ADDRESS_INFO,
                             queryMdl);

    status = iSpTdiSendIrpSynchronous(TdiDeviceObject, queryIrp);

    //
    // Free MDLs and IRP
    //
    iSpFreeMdlAndIrp(queryMdl, queryIrp, FALSE);

    return status;
}


NTSTATUS
iSpRegisterForNetworkNotification(
    VOID
    )
{
    UNICODE_STRING clientName;
    NTSTATUS status;

    TDI_CLIENT_INTERFACE_INFO clientInterfaceInfo;

    if (iSpTdiNotificationHandle != NULL) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&(clientName), 
                         L"iScsiPort");

    clientInterfaceInfo.MajorTdiVersion = 2;
    clientInterfaceInfo.MinorTdiVersion = 0;

    clientInterfaceInfo.Unused = 0;
    clientInterfaceInfo.ClientName = &clientName;

    clientInterfaceInfo.BindingHandler = iSpNetworkReadyCallback;
    clientInterfaceInfo.AddAddressHandler = NULL;
    clientInterfaceInfo.DelAddressHandler = NULL;
    clientInterfaceInfo.PnPPowerHandler = NULL;

    status = TdiRegisterPnPHandlers(&(clientInterfaceInfo),
                                    sizeof(clientInterfaceInfo),
                                    &(iSpTdiNotificationHandle));

    return status;
}


VOID
iSpNetworkReadyCallback(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING pTransportName,
    IN PWSTR BindingList
    )
{
    PAGED_CODE();

    switch (PnPOpcode) {
    
        case TDI_PNP_OP_NETREADY: {
            BOOLEAN previousState;
             
            previousState = iSpGlobalFdoExtension->CommonExtension.IsNetworkReady;
            iSpGlobalFdoExtension->CommonExtension.IsNetworkReady = TRUE;

            //
            // State change from network "not ready" to
            // network "ready" state. Will initialize
            // device detection
            //
            if (previousState == FALSE) {
                //
                // Request device enumeration request from PnP.
                //
                DebugPrint((3, "Network ready. Will invoke QDR\n"));
                IoInvalidateDeviceRelations(
                    iSpGlobalFdoExtension->LowerPdo,
                    BusRelations
                    );
            }

            break;
        }

        default: {
            break;
        }
    }

    return;
}


NTSTATUS
iSpTdiConnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           TdiIPAddress,
    IN  USHORT          TdiPortNumber,
    IN  LARGE_INTEGER   ConnectionTimeout
    )
{
    TDI_CONNECTION_INFORMATION  requestConnectionInformation;
    TDI_CONNECTION_INFORMATION  returnConnectionInformation;

    PIRP                localIrp;
    PTRANSPORT_ADDRESS  tdiTransportAddress;
    PTA_ADDRESS         tdiTAAddress;
    PTDI_ADDRESS_IP     tdiIPAddress;
    NTSTATUS            status;

    UCHAR               tdiAddressBuffer[TDI_IP_ADDRESS_LENGTH];

    PAGED_CODE ();

    RtlZeroMemory(tdiAddressBuffer, TDI_IP_ADDRESS_LENGTH);
    RtlZeroMemory (&requestConnectionInformation,
                   sizeof (requestConnectionInformation));
    RtlZeroMemory (&returnConnectionInformation,
                   sizeof (returnConnectionInformation));
    tdiTransportAddress = (PTRANSPORT_ADDRESS) tdiAddressBuffer;
    tdiTransportAddress->TAAddressCount = 1;
    tdiTAAddress = tdiTransportAddress->Address;
    tdiTAAddress->AddressLength = sizeof (TDI_ADDRESS_IP);
    tdiTAAddress->AddressType = TDI_ADDRESS_TYPE_IP;
    tdiIPAddress = (PTDI_ADDRESS_IP) tdiTAAddress->Address;
    tdiIPAddress->in_addr = TdiIPAddress;
    tdiIPAddress->sin_port = TdiPortNumber;

    requestConnectionInformation.RemoteAddressLength = TDI_IP_ADDRESS_LENGTH;
    requestConnectionInformation.RemoteAddress = (PVOID) tdiTransportAddress;


    localIrp = IoAllocateIrp (TdiConnDeviceObject->StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((1, "iSpTdiConnect : Failed to allocate IRP\n"));
        return STATUS_NO_MEMORY;
    }

    TdiBuildConnect(
        localIrp,                      
        TdiConnDeviceObject,            
        TdiConnFileObject,              
        iSpTdiCompletionRoutine,                           
        NULL,                           
        &ConnectionTimeout,                       
        &requestConnectionInformation,  
        &returnConnectionInformation);  

    status = iSpTdiSendIrpSynchronous(TdiConnDeviceObject, localIrp);

    IoFreeIrp(localIrp);

    DebugPrint((3, "iSpTdiConnect : return status %x\n",
                status));

    return status;
}


NTSTATUS
iSpTdiDisconnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           DisconnectFlags,
    IN  PVOID           CompletionRoutine,
    IN  PVOID           CompletionContext,
    IN  LARGE_INTEGER   DisconnectTimeout
    )

{
    PIRP                        localIrp;
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status;
    TDI_CONNECTION_INFORMATION  disconnectRequest;
    TDI_CONNECTION_INFORMATION  disconnectReply;

    localIrp = IoAllocateIrp (TdiConnDeviceObject->StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((1, "iSpTdiDisconnect : Failed to allocate IRP\n"));
        return STATUS_NO_MEMORY;
    }

    localIrp->Flags = 0;
    localIrp->UserIosb = &ioStatusBlock;

    TdiBuildDisconnect(
        localIrp,             
        TdiConnDeviceObject,    
        TdiConnFileObject,      
        CompletionRoutine,      
        CompletionContext,      
        &DisconnectTimeout,       
        DisconnectFlags,        
        &disconnectRequest,        
        &disconnectReply);       

    status = iSpTdiSendIrpSynchronous(TdiConnDeviceObject, localIrp);

    IoFreeIrp(localIrp);

    DebugPrint((3, "Return value from iSpTdiDisconnect : %x\n",
                status));
    return status;
}


NTSTATUS
iSpDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = (PISCSI_PDO_EXTENSION) TdiEventContext;
    PISCSI_CONNECTION iScsiConnection = pdoExtension->ClientNodeInfo;
    LARGE_INTEGER disconnectTimeout;

    DebugPrint((0, "Disconnect flags is %x\n", DisconnectFlags));

    ASSERT((iScsiConnection != NULL));

    pdoExtension->CurrentProtocolState = PSDisconnected;

    pdoExtension->IsMissing = TRUE;

    if ((iScsiConnection->ConnectionState) == ConnectionStateStopping) {
        DebugPrint((0, "We initiated disconnect. Do nothing more here\n"));
        iScsiConnection->ConnectionState = ConnectionStateDisconnected;
        return STATUS_SUCCESS;
    }

    DebugPrint((0, "We were told to disconnect. Process that now\n"));
    iScsiConnection->ConnectionState = ConnectionStateDisconnected;

    if ((DisconnectFlags & TDI_DISCONNECT_RELEASE) &&
        ((pdoExtension->DeviceObject) != NULL)) {

        PIO_WORKITEM workItem;

        workItem = IoAllocateWorkItem(pdoExtension->DeviceObject);
        if (workItem != NULL) {
            IoQueueWorkItem(workItem, iSpPerformDisconnect,
                            DelayedWorkQueue,
                            workItem);

            DebugPrint((0, "Queued work item to do disconnect\n"));
        }

    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpPerformDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension; 
    PISCSI_CONNECTION iScsiConnection = pdoExtension->ClientNodeInfo;
    LARGE_INTEGER disconnectTimeout;
    NTSTATUS status;

    IoFreeWorkItem((PIO_WORKITEM) Context);

    disconnectTimeout.QuadPart = -100000000L;

    DebugPrint((3, "In iSpPerformDisconnect\n"));
    status = iSpTdiDisconnect(iScsiConnection->ConnectionDeviceObject,
                              iScsiConnection->ConnectionFileObject,
                              TDI_DISCONNECT_RELEASE,
                              iSpTdiCompletionRoutine,
                              iScsiConnection,
                              disconnectTimeout);

    DebugPrint((3, "iSpTdiDisconnect  returned : %x\n",
                status));

    return STATUS_SUCCESS;
}



NTSTATUS
iSpSendData(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLen,
    OUT PULONG BytesSent
    )
{
    PIRP sendIrp = NULL;
    PMDL sendMdl = NULL;
    KEVENT event;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    DebugPrint((3, "Entering SendData\n"));

    *BytesSent = 0;

    status = iSpAllocateMdlAndIrp(DataBuffer,
                                  DataBufferLen,
                                  (CCHAR)(ConnectionDeviceObject->StackSize),
                                  TRUE,
                                  &sendIrp,
                                  &sendMdl);
    if (NT_SUCCESS(status)) {
        TdiBuildSend(sendIrp,
                     ConnectionDeviceObject,
                     ConnectionFileObject,
                     iSpTdiSendCompletionRoutine,
                     NULL,
                     sendMdl,
                     0,
                     DataBufferLen);

        /*
        status = iSpTdiSendIrpSynchronous(ConnectionDeviceObject,
                                          sendIrp);
        if (NT_SUCCESS(status)) {
            *BytesSent = sendIrp->IoStatus.Information;
            DebugPrint((3, "Bytes sent : %d\n",
                        *BytesSent));

        }
        */

        status = IoCallDriver(ConnectionDeviceObject, sendIrp);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Send failed. Status 0x%x\n", status));
        }
    }

    DebugPrint((3, "Status in SendData : %x\n",
                status));
    return status;
}


NTSTATUS
iSpReceiveHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID DataBuffer,
    OUT PIRP *IoRequestPacket
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = (PISCSI_PDO_EXTENSION) TdiEventContext;

    PISCSI_CONNECTION iScsiConnection = pdoExtension->ClientNodeInfo;

    PISCSI_FDO_EXTENSION fdoExtension;

    PDEVICE_OBJECT connectionDeviceObject;
    PFILE_OBJECT connectionFileObject;

    PIRP receiveIrp;
    PMDL receiveMdl;

    NTSTATUS status;

    UCHAR  protocolState;

    UCHAR oldIrql;

    DebugPrint((3, "In receive handler. Receive flags : 0x%08x\n",
                ReceiveFlags));

    ASSERT((iScsiConnection != NULL));

    connectionDeviceObject = iScsiConnection->ConnectionDeviceObject;
    connectionFileObject = iScsiConnection->ConnectionFileObject;

    protocolState = pdoExtension->CurrentProtocolState;

    DebugPrint((3, 
                "PS State : %d, BytesIndicated : %d, BytesAvailable : %d\n",
                protocolState, BytesIndicated, BytesAvailable));

    ASSERT((iScsiConnection->ConnectionState) == ConnectionStateConnected);

    *IoRequestPacket = NULL;

    status = STATUS_SUCCESS;

    switch (protocolState) {
        case PSLogonInProgress: {
            PISCSI_LOGIN_RESPONSE loginResponse;
            ULONG packetSize;
             
            DebugPrint((3, "Received login response\n"));

            *BytesTaken = BytesIndicated;   

            packetSize = BytesIndicated;
            if (packetSize > sizeof(iScsiConnection->IScsiPacket)) {
                packetSize = sizeof(iScsiConnection->IScsiPacket);
            }

            RtlCopyMemory((iScsiConnection->IScsiPacket),
                          DataBuffer,
                          packetSize);

            loginResponse = 
                (PISCSI_LOGIN_RESPONSE)(iScsiConnection->IScsiPacket);

            ASSERT((loginResponse->OpCode) == ISCSIOP_LOGIN_RESPONSE);

            if ((loginResponse->Status) == ISCSI_LOGINSTATUS_ACCEPT) {
                pdoExtension->CurrentProtocolState = PSLogonSucceeded;
            } else {
                pdoExtension->CurrentProtocolState = PSLogonFailed;
            }

            fdoExtension = pdoExtension->ParentFDOExtension;

            KeAcquireSpinLock(&(fdoExtension->EnumerationSpinLock),
                              &oldIrql);

            ASSERT(((fdoExtension->TargetsYetToRespond) > 0));

            InterlockedDecrement(&(fdoExtension->TargetsYetToRespond));

            //
            // If this is the last target to repond,
            // launch enumeration completion thread.
            //
            if ((fdoExtension->TargetsYetToRespond) == 0) {

                if ((fdoExtension->EnumerationThreadLaunched) == FALSE) {

                    iSpLaunchEnumerationCompletion(fdoExtension);

                }

            }

            KeReleaseSpinLock(&(fdoExtension->EnumerationSpinLock),
                              oldIrql);

            break;
        }

        case PSFullFeaturePhase: {

            //
            // Process the received data
            //
            status = iSpProcessReceivedData(
                              iScsiConnection,
                              BytesIndicated,
                              BytesTaken,
                              DataBuffer
                              );

            if (BytesIndicated < BytesAvailable) {
                PUCHAR readBuffer = NULL;
                ULONG remainingBytes;

                //
                // Need to send read IRP to read  
                // the remaining bytes
                //
                remainingBytes = BytesAvailable - BytesIndicated;

                DebugPrint((0, "Bytes Available %d, Bytes Remaining : %d\n",
                            BytesAvailable,
                            remainingBytes));

                readBuffer = iSpAllocatePool(NonPagedPool,
                                             remainingBytes,
                                             ISCSI_TAG_READBUFF);
                if (readBuffer != NULL) {
                    status = iSpAllocateMdlAndIrp(
                                  readBuffer,
                                  remainingBytes,
                                  (CCHAR)(connectionDeviceObject->StackSize),
                                  TRUE,
                                  &receiveIrp,
                                  &receiveMdl);
                    if (NT_SUCCESS(status)) {

                        TdiBuildReceive(receiveIrp,
                                        connectionDeviceObject,
                                        connectionFileObject,
                                        iSpReceiveCompletion,
                                        iScsiConnection,
                                        receiveMdl,
                                        0,
                                        remainingBytes);

                        iScsiConnection->RemainingBytes = remainingBytes;

                        status = STATUS_MORE_PROCESSING_REQUIRED;

                        *IoRequestPacket = receiveIrp;

                        IoSetNextIrpStackLocation(receiveIrp);
                    } else {
                        ExFreePool(readBuffer);
                        status = STATUS_NO_MEMORY;
                    }
                } else {
                    status = STATUS_NO_MEMORY;
                }
            }

            break;  
        }

        default: {
            DebugPrint((1, "Unknown protocol state : %d\n",
                        protocolState));

            *BytesTaken = BytesIndicated;

            break;
        }
    }

    return status;
}


NTSTATUS
iSpReceiveCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PISCSI_CONNECTION iScsiConnection = (PISCSI_CONNECTION) Context;
    PVOID dataBuffer;
    NTSTATUS status;
    ULONG bytesTaken;
    ULONG inx;

    DebugPrint((0, "Inx in receive completion\n"));

    dataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Free the MDL and IRP
    //
    iSpFreeMdlAndIrp(Irp->MdlAddress,
                     Irp,
                     FALSE);

    status = iSpProcessReceivedData(
                      iScsiConnection,
                      (iScsiConnection->RemainingBytes),
                      &bytesTaken,
                      dataBuffer
                      );

    ExFreePool(dataBuffer);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
iSpStopNetwork(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PISCSI_CONNECTION iScsiConnection = pdoExtension->ClientNodeInfo;
    NTSTATUS status;
    ULONG countOfEvents;

    if (iScsiConnection == NULL) {
        //
        // Nothing to do
        // 
        DebugPrint((1, "iSpStopNetwork : No node info\n"));

        return STATUS_SUCCESS;
    }

    if ((iScsiConnection->ConnectionState) == ConnectionStateConnected) {
        LARGE_INTEGER disconnectTimeout;

        disconnectTimeout.QuadPart = -100000000L;

        iScsiConnection->ConnectionState = ConnectionStateStopping;

        pdoExtension->CurrentProtocolState = PSDisconnectPending;

        status = iSpTdiDisconnect(iScsiConnection->ConnectionDeviceObject,
                                  iScsiConnection->ConnectionFileObject,
                                  TDI_DISCONNECT_RELEASE,
                                  iSpTdiCompletionRoutine,
                                  iScsiConnection,
                                  disconnectTimeout);

        DebugPrint((1, "iSpTdiDisconnect  returned : %x\n",
                    status));
    }

    countOfEvents = countof(ClientEvents);
    status = iSpTdiResetEventHandler(iScsiConnection->AddressDeviceObject,
                                     iScsiConnection->AddressFileObject,
                                     ClientEvents,
                                     countOfEvents);

    status = iSpCloseNetworkNode(iScsiConnection);

    if ((iScsiConnection->ActiveClientRequests) != NULL) {
        ExFreePool(iScsiConnection->ActiveClientRequests);
    }

    ExFreePool(iScsiConnection);
    pdoExtension->ClientNodeInfo = NULL;

    pdoExtension->IsClientNodeSetup = FALSE;

    DebugPrint((1, "Status from iSpStopNetwork : %x\n",
                status));

    return status;
}


NTSTATUS
iSpTdiSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Initialize the IRP fields
    //
    Irp->UserEvent = &event;
    Irp->UserIosb = &ioStatusBlock;

    //
    // Submit the IRP and wait for it to complete, if necessary
    //
    status = IoCallDriver(DeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }

    return status;
}


NTSTATUS
iSpTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    //
    // Copy the IRP status and signal the event
    //
    *(Irp->UserIosb) = Irp->IoStatus;

    KeSetEvent(Irp->UserEvent,
               IO_NETWORK_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
iSpTdiSendCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PVOID bufferAddress = NULL;

    ASSERT(Irp != NULL);

    DebugPrint((3, "Send status : %x\n",
                Irp->IoStatus.Status));

    if ((Irp->MdlAddress) != NULL) {
        bufferAddress = MmGetMdlVirtualAddress(Irp->MdlAddress);
        DebugPrint((3, "Buffer address in send complete : %x\n",
                    bufferAddress));
    }

    //
    // Free MDLs and IRP
    //
    iSpFreeMdlAndIrp(Irp->MdlAddress, Irp, FALSE);

    if (bufferAddress != NULL) {
        ExFreePool(bufferAddress);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\pnp.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    pnp.c

Abstract:

    This file contains plug and play code for the NT iSCSI port driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, iScsiPortAddDevice)
#pragma alloc_text(PAGE, iScsiPortUnload)

#endif // ALLOC_PRAGMA

#define NUM_DEVICE_TYPE_INFO_ENTRIES 18

extern ISCSI_DEVICE_TYPE DeviceTypeInfo[];

VOID
iSpInitFdoExtension(
    IN OUT PISCSI_FDO_EXTENSION
    );

ISCSI_DEVICE_TYPE DeviceTypeInfo[NUM_DEVICE_TYPE_INFO_ENTRIES] = {
    {"Disk",        "GenDisk",          L"DiskPeripheral",                  TRUE},
    {"Sequential",  "",                 L"TapePeripheral",                  TRUE},
    {"Printer",     "GenPrinter",       L"PrinterPeripheral",               FALSE},
    {"Processor",   "",                 L"OtherPeripheral",                 FALSE},
    {"Worm",        "GenWorm",          L"WormPeripheral",                  TRUE},
    {"CdRom",       "GenCdRom",         L"CdRomPeripheral",                 TRUE},
    {"Scanner",     "GenScanner",       L"ScannerPeripheral",               FALSE},
    {"Optical",     "GenOptical",       L"OpticalDiskPeripheral",           TRUE},
    {"Changer",     "ScsiChanger",      L"MediumChangerPeripheral",         TRUE},
    {"Net",         "ScsiNet",          L"CommunicationsPeripheral",        FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"Array",       "ScsiArray",        L"ArrayPeripheral",                 FALSE},
    {"Enclosure",   "ScsiEnclosure",    L"EnclosurePeripheral",             FALSE},
    {"RBC",         "ScsiRBC",          L"RBCPeripheral",                   TRUE},
    {"CardReader",  "ScsiCardReader",   L"CardReaderPeripheral",            FALSE},
    {"Bridge",      "ScsiBridge",       L"BridgePeripheral",                FALSE},
    {"Other",       "ScsiOther",        L"OtherPeripheral",                 FALSE}
};

PISCSI_FDO_EXTENSION iSpGlobalFdoExtension = NULL;
HANDLE iSpTdiNotificationHandle = NULL;


NTSTATUS
iScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*+++
Routine Description:

    This routine handles add-device requests for the iSCSI port driver

Arguments:

    DriverObject - a pointer to the driver object for this device

    PhysicalDeviceObject - a pointer to the PDO we are being added to

Return Value:

    STATUS_SUCCESS if successful
    Appropriate NTStatus code on error

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT newDeviceObject;
    PISCSI_FDO_EXTENSION fdoExtension;
    PCOMMON_EXTENSION commonExtension;
    NTSTATUS status;
    UNICODE_STRING deviceName;

    RtlInitUnicodeString(&deviceName, ISCSI_FDO_DEVICE_NAME);
    status = IoCreateDevice(DriverObject,
                            sizeof(ISCSI_FDO_EXTENSION),
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            0,
                            FALSE,
                            &deviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1, "iScsiPortAddDevice failed. Status %lx\n",
                    status));
        return status;
    }
             
    newDeviceObject = IoAttachDeviceToDeviceStack(deviceObject,
                                                  PhysicalDeviceObject);
    if (newDeviceObject == NULL) {
        DebugPrint((0, 
                    "IoAttachDeviceToDeviceStack failed in iScsiAddDevice\n"));
        IoDeleteDevice(deviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;
    commonExtension = &(fdoExtension->CommonExtension);

    iSpGlobalFdoExtension = fdoExtension;

    RtlZeroMemory(fdoExtension, sizeof(ISCSI_FDO_EXTENSION));

    fdoExtension->LowerPdo = PhysicalDeviceObject;
    commonExtension->LowerDeviceObject = newDeviceObject;

    commonExtension->DeviceObject = deviceObject;
    commonExtension->IsPdo = FALSE;
    commonExtension->CurrentPnpState = 0xff;
    commonExtension->PreviousPnpState = 0xff;
    commonExtension->IsNetworkReady = FALSE;

    commonExtension->IsRemoved = NO_REMOVE;
    commonExtension->RemoveLock = 0;
    KeInitializeEvent(&(commonExtension->RemoveEvent),
                      SynchronizationEvent,
                      FALSE);

    KeInitializeSpinLock(&(fdoExtension->EnumerationSpinLock));

    IoInitializeTimer(deviceObject, iSpTickHandler, NULL);

    IoStartTimer(fdoExtension->DeviceObject);

    //
    // Initialize the entry points for this device
    //
    iScsiPortInitializeDispatchTables();
    commonExtension->MajorFunction = FdoMajorFunctionTable;

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DebugPrint((3, "Add Device was successful\n"));
    return STATUS_SUCCESS;
}


VOID
iScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PISCSIPORT_DRIVER_EXTENSION driverExtension;

    driverExtension = IoGetDriverObjectExtension( DriverObject,
                                                  (PVOID)ISCSI_TAG_DRIVER_EXTENSION);
    if (driverExtension != NULL) {
        ExFreePool(driverExtension->RegistryPath.Buffer);
        driverExtension->RegistryPath.Buffer = NULL;
        driverExtension->RegistryPath.Length = 0;
        driverExtension->RegistryPath.MaximumLength = 0;
    }

    iSpGlobalFdoExtension = NULL;
    iSpTdiNotificationHandle = NULL;

    return;
}


NTSTATUS
iScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG isRemoved;
    BOOLEAN forwardIrp = FALSE;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((1, "FdoPnp for DeviceObject %x, Irp %x, MN %x\n",
                DeviceObject, Irp, (irpStack->MinorFunction)));

    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);
    if (isRemoved) {

        iSpReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE: {

            status = iSpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                           Irp);
            if (NT_SUCCESS(status)) {

                //
                // Register for notification from network interface
                // to be notified of network ready state
                //
                if ((commonExtension->IsNetworkReady) == FALSE) {
                    iSpRegisterForNetworkNotification();
                }

                //
                // Initialize various fields in the 
                // FDO Extension. 
                //
                iSpInitFdoExtension(fdoExtension);
                Irp->IoStatus.Status = status;
            } 

            break;
        }

        case IRP_MN_QUERY_STOP_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }
    
        case IRP_MN_CANCEL_STOP_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }

        case IRP_MN_STOP_DEVICE: {

            if (iSpTdiNotificationHandle != NULL) {
                TdiDeregisterPnPHandlers(iSpTdiNotificationHandle);
                iSpTdiNotificationHandle = NULL;
            }

            //
            // If network node hasn't been released yet,
            // release it now
            //
            if ((fdoExtension->LocalNodesInitialized) == TRUE) {
                ULONG inx;

                for (inx = 0; inx < (fdoExtension->NumberOfTargets);
                     inx++) {
                    iSpStopNetwork(fdoExtension->PDOList[inx]);
                    fdoExtension->PDOList[inx] = NULL;
                }

                fdoExtension->LocalNodesInitialized = FALSE;
                fdoExtension->NumberOfTargets = 0;
            }

            fdoExtension->LocalNodesInitialized = FALSE;

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0L;

            if (NT_SUCCESS(status)) {
                forwardIrp = TRUE;
            } 

            break;
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: {
            DebugPrint((0, "Query remove received.\n"));
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }
    
        case IRP_MN_CANCEL_REMOVE_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }

        case IRP_MN_REMOVE_DEVICE: {

            //
            // Deregister network notification if we
            // already haven't
            //
            if (iSpTdiNotificationHandle != NULL) {
                TdiDeregisterPnPHandlers(iSpTdiNotificationHandle);
                iSpTdiNotificationHandle = NULL;
            }

            //
            // If network node hasn't been released yet,
            // release it now
            //
            if ((fdoExtension->LocalNodesInitialized) == TRUE) {
                ULONG inx;

                for (inx = 0; inx < (fdoExtension->NumberOfTargets);
                     inx++) {
                    iSpStopNetwork(fdoExtension->PDOList[inx]);
                    IoDeleteDevice(fdoExtension->PDOList[inx]);
                    fdoExtension->PDOList[inx] = NULL;
                }

                fdoExtension->LocalNodesInitialized = FALSE;
                fdoExtension->NumberOfTargets = 0;
            }

            fdoExtension->LocalNodesInitialized = FALSE;

            iSpReleaseRemoveLock(DeviceObject, Irp);
            commonExtension->IsRemoved = REMOVE_PENDING;

            DebugPrint((1, "Waiting for remove event.\n"));
            KeWaitForSingleObject(&(commonExtension->RemoveEvent),
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            DebugPrint((1, "Will process remove now.\n"));

            status = iSpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                           Irp);

            if (NT_SUCCESS(status)) {

                IoDetachDevice(commonExtension->LowerDeviceObject);

                IoDeleteDevice(commonExtension->DeviceObject);

                Irp->IoStatus.Status = STATUS_SUCCESS;
            } else {  
                commonExtension->IsRemoved = NO_REMOVE;

                Irp->IoStatus.Status = status;
            }
   
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            return status;

            break;
        }
    
        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PIO_WORKITEM workItem = NULL;
            PDEVICE_RELATIONS deviceRelations;
            PDEVICE_OBJECT lowerDevice; 

            ULONG relationSize;
            DEVICE_RELATION_TYPE relationType;

            relationType = 
                irpStack->Parameters.QueryDeviceRelations.Type;

            if (relationType != BusRelations) {
                forwardIrp = TRUE;
                break;
            }

            if ((fdoExtension->EnumerationComplete) == TRUE) {

                ASSERT((fdoExtension->NumberOfTargets) > 0);

                relationSize = sizeof(DEVICE_RELATIONS) + 
                               (sizeof(PDEVICE_OBJECT) * 
                                (fdoExtension->NumberOfTargets));

                deviceRelations = iSpAllocatePool(PagedPool,
                                                  relationSize,
                                                  ISCSI_TAG_DEVICE_RELATIONS);
                if (deviceRelations != NULL) {
                    PDEVICE_OBJECT pdo;
                    ULONG inx;

                    deviceRelations->Count = 
                        fdoExtension->NumberOfTargets; 
                    for (inx = 0; (inx < (fdoExtension->NumberOfTargets)); 
                         inx++) {

                        pdo = fdoExtension->PDOList[inx];
                        ASSERT(pdo != NULL);
                        ObReferenceObject(pdo);
                        deviceRelations->Objects[inx] = pdo;
                    }

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

                    IoCopyCurrentIrpStackLocationToNext(Irp);

                    lowerDevice = 
                        fdoExtension->CommonExtension.LowerDeviceObject;

                    iSpReleaseRemoveLock(DeviceObject, Irp);

                    return IoCallDriver(lowerDevice, Irp);   
                } else {
                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Information = 0L;

                    iSpReleaseRemoveLock(DeviceObject, Irp);

                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            status = STATUS_SUCCESS;

            //
            // Setup the local network nodes if not already done
            //
            if ((fdoExtension->LocalNodesInitialized) == FALSE) {
                status = iSpInitializeLocalNodes(DeviceObject);
            }
            
            if (NT_SUCCESS(status)) {

                //
                // Allocate a workitem to perform device
                // enumeration
                //
                fdoExtension->EnumerationThreadLaunched = FALSE;
                workItem = IoAllocateWorkItem(DeviceObject);
                if (workItem != NULL) {

                    IoMarkIrpPending(Irp);

                    fdoExtension->EnumerationIrp = Irp;
                    fdoExtension->EnumerationComplete = FALSE;
                    fdoExtension->EnumerationWorkItem = workItem;

                    IoQueueWorkItem(workItem, 
                                    iSpEnumerateDevicesAsynchronous,
                                    DelayedWorkQueue,
                                    fdoExtension);

                    iSpReleaseRemoveLock(DeviceObject, Irp);

                    return STATUS_PENDING;
                } else {
                    Irp->IoStatus.Information = 0L;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

                break;
            } else {
                DebugPrint((1, "Could not setup the node. Status : %x\n",
                            status));
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0L;
            }

            break;
        }
    
        default:   {
            forwardIrp = TRUE;
            break;
        }
    } // switch (irpStack->MinorFunction)

    iSpReleaseRemoveLock(DeviceObject, Irp);

    if (forwardIrp == TRUE) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(commonExtension->LowerDeviceObject,
                            Irp);
    } else {
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
iSpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    KEVENT event;

    PAGED_CODE();

    if (DeviceObject == NULL) {
        DebugPrint((1, "DeviceObject NULL. Irp %x\n",
                    Irp));
        return Irp->IoStatus.Status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           iSpSetEvent,
                           &event,
                           TRUE, 
                           TRUE,
                           TRUE);
    status = IoCallDriver(DeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}



NTSTATUS
iScsiPortGetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a device id string for
    the specified Pdo.  This string is generated from the bus type (scsi) and
    the type of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    PISCSI_PDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PINQUIRYDATA inquiryData = &(pdoExtension->InquiryData);

    UCHAR buffer[256];
    PUCHAR rawIdString = buffer;
    ANSI_STRING ansiIdString;

    ULONG whichString;

    PAGED_CODE();

    ASSERT(UnicodeString != NULL);

    RtlZeroMemory(buffer, sizeof(buffer));

    sprintf(rawIdString,
            "SCSI\\%s",
            iSpGetDeviceTypeInfo(inquiryData->DeviceType)->DeviceTypeString);

    rawIdString += strlen(rawIdString);

    ASSERT(*rawIdString == '\0');

    for(whichString = 0; whichString < 3; whichString++) {

        PUCHAR headerString;
        PUCHAR sourceString;
        ULONG sourceStringLength;

        ULONG i;

        switch(whichString) {

            //
            // Vendor Id
            //
            case 0: {
                sourceString = inquiryData->VendorId;
                sourceStringLength = sizeof(inquiryData->VendorId);
                headerString = "Ven";
                break;
            }

            //
            // Product Id
            //
            case 1: {
                sourceString = inquiryData->ProductId;
                sourceStringLength = sizeof(inquiryData->ProductId);
                headerString = "Prod";
                break;
            }

            //
            // Product Revision Level
            //
            case 2: {
                sourceString = inquiryData->ProductRevisionLevel;
                sourceStringLength = sizeof(inquiryData->ProductRevisionLevel);
                headerString = "Rev";
                break;
            }
        }

        //
        // Start at the end of the source string and back up until we find a
        // non-space, non-null character.
        //

        for(; sourceStringLength > 0; sourceStringLength--) {

            if((sourceString[sourceStringLength - 1] != ' ') &&
               (sourceString[sourceStringLength - 1] != '\0')) {
                break;
            }
        }

        //
        // Throw the header string into the block
        //

        sprintf(rawIdString, "&%s_", headerString);
        rawIdString += strlen(headerString) + 2;

        //
        // Spew the string into the device id
        //

        for(i = 0; i < sourceStringLength; i++) {
            *rawIdString = (sourceString[i] != ' ') ? (sourceString[i]) :
                                                      ('_');
            rawIdString++;
        }
        ASSERT(*rawIdString == '\0');
    }

    RtlInitAnsiString(&ansiIdString, buffer);

    DebugPrint((1, "DeviceId for logical unit %#p is %Z\n",
                Pdo, &ansiIdString));

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


NTSTATUS
iScsiPortGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in an instance id string for
    the specified Pdo.  This string will be generated either from the device
    type + serial number of the device (if it has a serial number) or from
    the address of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    PISCSI_PDO_EXTENSION pdoExtension = Pdo->DeviceExtension;

    PDRIVER_OBJECT driverObject = Pdo->DriverObject;
    PISCSI_DEVICE_TYPE deviceTypeInfo;

    UCHAR idStringBuffer[64];
    ANSI_STRING ansiIdString;

    PAGED_CODE();

    ASSERT(UnicodeString != NULL);

    //
    // can't use serial number even if it exists since a device which is 
    // multiply connected to the same bus (dual-ported device) will have 
    // the same serial number at each connection and would confuse the PNP.
    //

    sprintf(idStringBuffer,
            "%x%x%x",
            pdoExtension->PathId,
            pdoExtension->TargetId,
            pdoExtension->Lun
            );

    RtlInitAnsiString(&ansiIdString, idStringBuffer);

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


NTSTATUS
iScsiPortGetCompatibleIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a compatible id multi
    string for the specified Pdo.  This string is generated using the bus and
    device types for the device

Arguments:

    InquiryData - the inquiry data to generate compatible ids from.

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    UCHAR s[sizeof("SCSI\\DEVICE_TYPE_GOES_HERE")];
    PSTR stringBuffer[] = {
        s,
        "SCSI\\RAW",
        NULL};

    //
    // Fill in the scsi specific string
    //

    sprintf(stringBuffer[0],
            "SCSI\\%s",
            iSpGetDeviceTypeInfo(InquiryData->DeviceType)->DeviceTypeString);

    //
    // Set up the first id string
    //

    return iScsiPortStringArrayToMultiString(
        DriverObject, 
        UnicodeString, 
        stringBuffer);
}


NTSTATUS
iScsiPortGetHardwareIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a hardware id multi
    string for the specified Pdo.  This string is generated using the device
    type and the inquiry data.

Arguments:

    InquiryData - the inquiry data to be converted into id strings.

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

#define NUMBER_HARDWARE_STRINGS 6

{
    PISCSI_DEVICE_TYPE devTypeInfo =
        iSpGetDeviceTypeInfo(InquiryData->DeviceType);

    ULONG i;

    PSTR strings[NUMBER_HARDWARE_STRINGS + 1];
    UCHAR scratch[64];

    NTSTATUS status;

    PAGED_CODE();

    //
    // Zero out the string buffer
    //

    RtlZeroMemory(strings, sizeof(strings));

    try {

        for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

            RtlZeroMemory(scratch, sizeof(scratch));

            //
            // Build each of the hardware id's
            //

            switch(i) {

                //
                // Bus + Dev Type + Vendor + Product + Revision
                //

                case 0: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductRevisionLevel,
                              4,
                              '_');
                    break;
                }

                //
                // bus + device + vendor + product
                //

                case 1: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    break;
                }

                //
                // bus + device + vendor
                //

                case 2: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    break;
                }

                //
                // bus \ vendor + product + revision[0]
                //

                case 3: {
                    sprintf(scratch, "SCSI\\");

                    //
                    // Fall through to the next set.
                    //
                }

                //
                // vendor + product + revision[0] (win9x)
                //

                case 4: {

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductRevisionLevel,
                              1,
                              '_');

                    break;
                }

                case 5: {

                    sprintf(scratch, "%s", devTypeInfo->GenericTypeString);
                    break;
                }

                default: {
                    ASSERT(FALSE);
                    break;
                }
            }

            if(strlen(scratch) != 0) {
                strings[i] =
                    iSpAllocatePool(PagedPool,
                                    strlen(scratch) + sizeof(UCHAR),
                                    ISCSI_TAG_PNP_ID);

                if(strings[i] == NULL) {
                    status =  STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                strcpy(strings[i], scratch);

            } else {

                break;
            }
        }

        status = iScsiPortStringArrayToMultiString(DriverObject,
                                                   UnicodeString,
                                                   strings);
        leave;

    } finally {

        for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

            if(strings[i]) {
                ExFreePool(strings[i]);
            }
        }
    }

    return status;
}

#undef NUMBER_HARDWARE_STRINGS

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace spaces with the specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

    PAGED_CODE();

    for(i = 0; i < Count; i++) {

        if(!pastEnd) {

            if(Source[i] == 0) {

                pastEnd = TRUE;

                Destination[i] = Change;

            } else if(Source[i] == ' ') {

                Destination[i] = Change;

            } else {

                Destination[i] = Source[i];

            }
        } else {
            Destination[i] = Change;
        }
    }
    return;
}

PISCSI_DEVICE_TYPE
iSpGetDeviceTypeInfo(
    IN UCHAR DeviceType
    )
{
    PAGED_CODE();

    if(DeviceType >= NUM_DEVICE_TYPE_INFO_ENTRIES) {
        return &(DeviceTypeInfo[NUM_DEVICE_TYPE_INFO_ENTRIES - 1]);
    } else {
        return &(DeviceTypeInfo[DeviceType]);
    }
};

VOID
iSpInitFdoExtension(
    IN OUT PISCSI_FDO_EXTENSION FdoExtension
    )
{
    PIO_SCSI_CAPABILITIES capabilities;

    capabilities = &(FdoExtension->IoScsiCapabilities);

    //
    // For now, we are going to hard code most of the values
    //
    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    capabilities->MaximumTransferLength = 0x8000;

    capabilities->MaximumPhysicalPages = 9;

    capabilities->SupportedAsynchronousEvents = 0;

    capabilities->AlignmentMask = 0;

    capabilities->TaggedQueuing = FALSE;

    capabilities->AdapterScansDown = FALSE;

    capabilities->AdapterUsesPio = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\power.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    power.c

Abstract:

    This file contains the routines for power support

Environment:

    Kernel mode only

Revision History:

--*/

#include "port.h"


NTSTATUS
iScsiPortPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    DebugPrint((1, "iScsiPortPower : DeviceObject %x, Irp %x\n",
                DeviceObject, Irp));

    switch (irpStack->MinorFunction) {
        case IRP_MN_SET_POWER: {
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        default: {
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(commonExtension->LowerDeviceObject,
                        Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\port.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    port.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    iSCSI port driver.

Revision History:

--*/

#ifndef _PORT_H_
#define _PORT_H_

#include "iscsi.h"

extern PDRIVER_DISPATCH FdoMajorFunctionTable[];
extern PDRIVER_DISPATCH PdoMajorFunctionTable[];


#define INLINE __inline

#define ntohs(x)    (((x & 0xFF) << 8) | (( x >> 8) & 0xFF))

#define ntohl(x)    ((((x >>  0) & 0xFF) << 24) | \
                     (((x >>  8) & 0xFF) << 16) | \
                     (((x >> 16) & 0xFF) <<  8) | \
                     (((x >> 24) & 0xFF) <<  0))
                     
#define htonl(x)   ((((x) >> 24) & 0x000000FFL) | \
                    (((x) >>  8) & 0x0000FF00L) | \
                    (((x) <<  8) & 0x00FF0000L) | \
                    (((x) << 24) & 0xFF000000L))
                    
#define htons(x)   ((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))

#ifdef countof
#undef
#endif
#define countof(x) (sizeof(x) / sizeof((x)[0]))

#ifdef DebugPrint
#undef DebugPrint
#endif

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#define TEST(Value)             ((BOOLEAN) ((Value) ? TRUE : FALSE));

#define WaitForOneSecond() {                                            \
                                                                        \
                             LARGE_INTEGER delayTime;                   \
                             delayTime.QuadPart = -10000000L;           \
                             KeDelayExecutionThread( KernelMode,        \
                                                     FALSE,             \
                                                     &delayTime);       \
                           }  
                             
#define FILLUP_INQUIRYDATA(InquiryData)                  \
         InquiryData.DeviceType = 0;                     \
         InquiryData.DeviceTypeQualifier = 0;            \
         InquiryData.DeviceTypeModifier = 0;             \
         InquiryData.RemovableMedia = 0;                 \
         InquiryData.Versions = 0;                       \
         InquiryData.ResponseDataFormat = 2;             \
         RtlCopyMemory(InquiryData.VendorId,             \
                       "Seagate", 7);                    \
         RtlCopyMemory(InquiryData.ProductId,            \
                       "iSCSI Disk", 10);                \
         RtlCopyMemory(InquiryData.ProductRevisionLevel, \
                       "1.0", 3);                        


#define IS_CLEANUP_REQUEST(irpStack)                                                                    \
        (((irpStack)->MajorFunction == IRP_MJ_CLOSE) ||                                                 \
         ((irpStack)->MajorFunction == IRP_MJ_CLEANUP) ||                                               \
         ((irpStack)->MajorFunction == IRP_MJ_SHUTDOWN) ||                                              \
         (((irpStack)->MajorFunction == IRP_MJ_SCSI) &&                                                 \
          (((irpStack)->Parameters.Scsi.Srb->Function == SRB_FUNCTION_RELEASE_DEVICE) ||                \
           ((irpStack)->Parameters.Scsi.Srb->Function == SRB_FUNCTION_FLUSH_QUEUE) ||                   \
           (TEST_FLAG((irpStack)->Parameters.Scsi.Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE |        \
                                                                 SRB_FLAGS_BYPASS_LOCKED_QUEUE)))))
                                              
#if DBG
VOID
iScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x) iScsiDebugPrint x
#else
#define DebugPrint(x)
#endif

//
// Constants for TDI routines
//
#define TDI_QUERY_ADDRESS_LENGTH_IP (sizeof(TDI_ADDRESS_INFO) - 1 \
                                     + TDI_ADDRESS_LENGTH_IP)
                                     
#define FILE_FULL_EA_INFO_ADDR_LENGTH FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) \
                                      + TDI_TRANSPORT_ADDRESS_LENGTH + 1 \
                                      + sizeof(TA_IP_ADDRESS)
                                      
#define FILE_FULL_EA_INFO_CEP_LENGTH  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) \
                                      + TDI_CONNECTION_CONTEXT_LENGTH + 1 \
                                      + sizeof(CONNECTION_CONTEXT)

#define TDI_IP_ADDRESS_LENGTH        (sizeof (TRANSPORT_ADDRESS) - 1 + \
                                      TDI_ADDRESS_LENGTH_IP)


//
// IP Address and Port 
#define ISCSI_ANY_ADDRESS           0L
#define ISCSI_CLIENT_ANY_PORT       0L

//
// Size of ISCSI PACKET
//
#define ISCSI_PACKET_SIZE  48

//
// Temp read buffer size
//
#define READ_BUFFER_SIZE   4096

//
// Maximum time, in seconds, to wait for logon response
//
#define  MAX_LOGON_WAIT_TIME   120

//
// Maximum length of the iSCSI Target device name
//
#define MAX_TARGET_NAME_LENGTH 31

//
// Tag for iScsiPort
//
#define ISCSI_TAG_GENERIC            '00Si'
#define ISCSI_TAG_DRIVER_EXTENSION   '10Si'
#define ISCSI_TAG_REGPATH            '20Si'
#define ISCSI_TAG_CONNECTION         '30Si'
#define ISCSI_TAG_LOGIN_CMD          '40si'
#define ISCSI_TAG_LOGIN_RES          '50si'
#define ISCSI_TAG_READBUFF           '60si'
#define ISCSI_TAG_DEVICE_RELATIONS   '70si'
#define ISCSI_TAG_PNP_ID             '80si'
#define ISCSI_TAG_ACTIVE_REQ         '90si'
#define ISCSI_TAG_SCSI_CMD           'A0si'

//
// Tag to identify ISCSI_CONNECTION struct
//
#define ISCSI_CONNECTION_TYPE    0xACAC

//
// Device name for the FDO
//
#define ISCSI_FDO_DEVICE_NAME L"\\Device\\iScsi"

//
// Device name for the PDOs
//
#define ISCSI_PDO_DEVICE_NAME L"\\Device\\iScsiDevice"

//
// Value for IsRemoved
//
#define NO_REMOVE       0
#define REMOVE_PENDING  1
#define REMOVE_COMPLETE 2

typedef struct _ACTIVE_REQUESTS ACTIVE_REQUESTS, *PACTIVE_REQUESTS;

//
// device type table to build id's from
//
typedef const struct _ISCSI_DEVICE_TYPE {

    const PCSTR DeviceTypeString;

    const PCSTR GenericTypeString;

    const PCWSTR DeviceMapString;

    const BOOLEAN IsStorage;

} ISCSI_DEVICE_TYPE, *PISCSI_DEVICE_TYPE;

typedef enum _ISCSI_RECEIVE_STATE {
    ReceiveHeader = 1,
    ReceiveData
} ISCSI_RECEIVE_STATE, *PISCSI_RECEIVE_STATE;

typedef enum _ISCSI_PROTOCOL_STATE {
    PSNodeInitInProgress,
    PSNodeInitialized,
    PSNodeInitializeFailed,
    PSConnectedToServer,
    PSConnectToServerFailed,
    PSLogonInProgress,
    PSWaitingForLogon,
    PSLogonFailed,
    PSLogonSucceeded,
    PSLogonTimedOut,
    PSFullFeaturePhase,
    PSDisconnectPending,
    PSDisconnected
} ISCSI_PROTOCOL_STATE, *PISCSI_PROTOCOL_STATE;

typedef enum _ISCSI_CONNECTION_STATE {
    ConnectionStateConnecting,
    ConnectionStateConnected,
    ConnectionStateStopping,
    ConnectionStateDisconnected,
    ConnectionStateUnknown
} ISCSI_CONNECTION_STATE, *PISCSI_CONNECTION_STATE;


typedef struct _ISCSI_EVENT_HANDLER {
    USHORT EventId;
    PVOID  EventHandler;
} ISCSI_EVENT_HANDLER, *PISCSI_EVENT_HANDLER;

typedef struct _ISCSI_TARGETS {
    ULONG    TargetAddress;
    UCHAR    TargetName[MAX_TARGET_NAME_LENGTH + 1];
} ISCSI_TARGETS, *PISCSI_TARGETS;

//
// Represents a connection
//
typedef struct _ISCSI_CONNECTION {
    USHORT Type;

    USHORT Size;

    ISCSI_RECEIVE_STATE ReceiveState;

    ISCSI_CONNECTION_STATE ConnectionState;

    BOOLEAN CompleteHeaderReceived;

    struct _ISCSI_CONNECTION *Next;

    PACTIVE_REQUESTS CurrentRequest;

    ULONG CommandRefNum;

    ULONG MaxCommandRefNum;

    ULONG CurrentStatusRefNum;

    ULONG ExpStatusRefNum;

    ULONG MaxPendingRequests;

    ULONG NumberOfReqsInProgress;

    ULONG InitiatorTaskTag;

    ULONG RemainingBytes;

    PACTIVE_REQUESTS ActiveClientRequests;

    KSPIN_LOCK RequestLock;

    KSPIN_LOCK ListSpinLock;

    PVOID ConnectionHandle;

    PFILE_OBJECT ConnectionFileObject;

    PDEVICE_OBJECT ConnectionDeviceObject;

    PVOID ConnectionContext;

    PVOID AddressHandle;

    PFILE_OBJECT AddressFileObject;

    PDEVICE_OBJECT AddressDeviceObject;

    PDEVICE_OBJECT DeviceObject;

    //
    // List of request for this connection
    //
    LIST_ENTRY RequestList;

    TDI_ADDRESS_IP IPAddress;

    ULONG IScsiPacketOffset;

    UCHAR IScsiPacket[ISCSI_PACKET_SIZE * 3];

    UCHAR ReadBuffer[READ_BUFFER_SIZE];

} ISCSI_CONNECTION, *PISCSI_CONNECTION;

//
// Represents a session (set of connections)
//
typedef struct _ISCSI_SESSION {
    ULONG ConnectionCount;
    PISCSI_CONNECTION Connections;
    PVOID ClientContext;
} ISCSI_SESSION, *PISCSI_SESSION;

typedef struct _ISCSIPORT_DRIVER_EXTENSION {

    //
    // Pointer back to the driver object
    //
    PDRIVER_OBJECT DriverObject;

    //
    // Registrypath info for this driver
    //
    UNICODE_STRING RegistryPath;

    //
    // The bus type for this driver.
    // 
    STORAGE_BUS_TYPE BusType;

} ISCSIPORT_DRIVER_EXTENSION, *PISCSIPORT_DRIVER_EXTENSION;

typedef struct _COMMON_EXTENSION {

    //
    // Back pointer to the device object
    //
    PDEVICE_OBJECT DeviceObject;

    struct {

        //
        // TRUE if the device object is a physical device object
        //
        BOOLEAN IsPdo : 1;

        //
        // TRUE if the device has been initialized
        //
        BOOLEAN IsInitialized : 1;

        //
        // TRUE if the network interface is ready
        // to receive requests
        //
        BOOLEAN IsNetworkReady : 1;

        //
        // TRUE if the network address has been setup
        //
        BOOLEAN IsClientNodeSetup : 1;
    };

    UCHAR CurrentPnpState;

    UCHAR PreviousPnpState;

    ULONG IsRemoved;

    LONG RemoveLock;

    KEVENT RemoveEvent;

    PDEVICE_OBJECT LowerDeviceObject;

    PDRIVER_DISPATCH *MajorFunction;

} COMMON_EXTENSION, *PCOMMON_EXTENSION;

typedef struct _ISCSI_FDO_EXTENSION {
    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    BOOLEAN LocalNodesInitialized;

    ULONG TargetsYetToRespond;

    PDEVICE_OBJECT LowerPdo;

    //
    // List of PDOs
    //
    PDEVICE_OBJECT PDOList[MAX_TARGETS_SUPPORTED];

    ULONG NumberOfTargets;

    IO_SCSI_CAPABILITIES IoScsiCapabilities;

    //
    // Device enumeration related data
    //
    PIRP EnumerationIrp;

    PIO_WORKITEM EnumerationWorkItem;

    KSPIN_LOCK EnumerationSpinLock;

    BOOLEAN EnumerationComplete;

    BOOLEAN EnumerationThreadLaunched;
} ISCSI_FDO_EXTENSION, *PISCSI_FDO_EXTENSION;

typedef struct _ISCSI_PDO_EXTENSION {
    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    BOOLEAN IsClientNodeSetup;

    UCHAR CurrentProtocolState;

    ULONG LogonTickCount;

    ULONG  TargetIPAddress;

    USHORT TargetPortNumber;

    UCHAR  TargetName[MAX_TARGET_NAME_LENGTH + 1];

    //
    // Pointer to the parent extension
    //
    PISCSI_FDO_EXTENSION ParentFDOExtension;

    //
    // Pointer to ISCSI Connection extension
    //
    PISCSI_CONNECTION ClientNodeInfo;

    //
    // TRUE if InquiryData field has been 
    // initialized for this device
    //
    BOOLEAN InquiryDataInitialized;

    //
    // Inquiry Data
    //
    INQUIRYDATA InquiryData;

    //
    // Senseinfo buffer for Inquiry data
    //
    SENSE_DATA InquirySenseBuffer;
    
    //
    // Saved connection ID
    //
    UCHAR SavedConnectionID[2];

    //
    // Address of the device
    //
    UCHAR PortNumber;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;

    BOOLEAN IsClaimed;
    BOOLEAN IsMissing;
    BOOLEAN IsEnumerated;

    PVPD_IDENTIFICATION_PAGE DeviceIdentifierPage;
    ULONG DeviceIdentifierPageLength;

} ISCSI_PDO_EXTENSION, *PISCSI_PDO_EXTENSION;

//
// Stores the requests that have been sent to the server
// for processing, but not yet completed.
//
typedef struct _ACTIVE_REQUESTS {
    BOOLEAN IsPDO;

    BOOLEAN InUse;

    BOOLEAN Completed;

    UCHAR CommandStatus;

    UCHAR IScsiHeader[ISCSI_PACKET_SIZE];

    UCHAR SenseData[SENSE_BUFFER_SIZE * 3];

    PDEVICE_OBJECT DeviceObject;

    PIRP Irp;

    PUCHAR RequestBuffer;

    PVOID OriginalDataBuffer;

    ULONG RequestBufferOffset;

    ULONG ExpectedDataLength;

    ULONG ReceivedDataLength;

    ULONG TaskTag;

    ULONG CommandRefNum;

} ACTIVE_REQUESTS, *PACTIVE_REQUESTS;



NTSTATUS
INLINE
iSpDispatchRequest(
    IN PISCSI_PDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = &(PdoExtension->CommonExtension);
    PCOMMON_EXTENSION lowerCommonExtension =
        commonExtension->LowerDeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ASSERT(irpStack->MajorFunction == IRP_MJ_SCSI);

    return (lowerCommonExtension->MajorFunction[IRP_MJ_SCSI])(
                commonExtension->LowerDeviceObject,
                Irp);
}

//
// Function declarations
//

NTSTATUS
iScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortDispatchUnsupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
iScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
iScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
iScsiPortInitializeDispatchTables();

NTSTATUS
iSpSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
iSpEnumerateDevicesAsynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
iSpStartNetwork(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
iSpStopNetwork(
    IN PDEVICE_OBJECT DeviceObject
    );

PVOID
iSpAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

NTSTATUS
iSpCreateTdiAddressObject(
    IN ULONG  InAddress,
    IN USHORT InPort,
    OUT PVOID *AddrHandle,
    OUT PFILE_OBJECT *AddrFileObject,
    OUT PDEVICE_OBJECT *AddrDeviceObject
    );

NTSTATUS
iSpCreateTdiConnectionObject(
    IN PWCHAR DeviceName,
    IN CONNECTION_CONTEXT ConnectionContext,
    OUT PVOID *ConnectionHandle,
    OUT PFILE_OBJECT *ConnectionFileObject,
    OUT PDEVICE_OBJECT *ConnectionDeviceObject
    );

NTSTATUS
iSpTdiAssociateAddress(
    IN PIRP Irp,
    IN PVOID AddrHandle,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    );

NTSTATUS
iSpTdiSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iSpTdiSetEventHandler(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER eventsToSet,
    IN ULONG CountOfEvents,
    IN PVOID EventContext
    );

NTSTATUS
iSpTdiResetEventHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER EventsToSet,
    IN ULONG CountOfEvents
    );

NTSTATUS
iSpCloseTdiAddress(
    HANDLE AddrHandle,
    PFILE_OBJECT AddrFileObject
    );

NTSTATUS
iSpCloseTdiConnection(
    HANDLE ConnectionHandle,
    PFILE_OBJECT ConnectionFileObject
    );

NTSTATUS
iSpTdiDeviceControl(
    IN PIRP Irp,
    IN PMDL Mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID IrpParameter,
    IN ULONG IrpParameterLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength
    );

NTSTATUS
iSpConnectionHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

NTSTATUS
iSpDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
iSpReceiveHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
iSpTdiQueryInformation(
    IN PDEVICE_OBJECT TdiDeviceObject,
    IN PFILE_OBJECT TdiFileObject,
    IN PTDI_ADDRESS_INFO TdiAddressBuffer,
    IN ULONG TdiAddrBuffLen
    );

NTSTATUS
iSpTdiConnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           TdiIPAddress,
    IN  USHORT          TdiPortNumber,
    IN  LARGE_INTEGER   ConnectionTimeout
    );

NTSTATUS
iSpTdiDisconnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           DisconnectFlags,
    IN  PVOID           CompletionRoutine,
    IN  PVOID           CompletionContext,
    IN  LARGE_INTEGER   DisconnectTimeout
    );
NTSTATUS
iSpAllocateMdlAndIrp(
    IN PVOID Buffer,
    IN ULONG BufferLen,
    IN CCHAR StackSize,
    IN BOOLEAN NonPagedPool,
    OUT PIRP *Irp,
    OUT PMDL *Mdl
    );

VOID
iSpFreeMdlAndIrp(
    IN PMDL Mdl,
    IN PIRP Irp,
    BOOLEAN UnlockPages
    );

NTSTATUS
iSpRegisterForNetworkNotification(
    VOID
    );

NTSTATUS
iSpSetupNetworkNode(
    IN ULONG  InAddress,
    IN USHORT InPort,
    IN PIRP   Irp,
    IN PVOID ConnectionContext,
    OUT PISCSI_CONNECTION ConnectionInfo
    );

NTSTATUS
iSpCloseNetworkNode(
    PISCSI_CONNECTION iScsiConnection
    );

NTSTATUS
iSpTdiDisassociateAddress(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject
    );

NTSTATUS
iSpPerformDeviceEnumeration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iSpConnectionComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
iSpTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpPerformDisconnect(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PVOID Context
    );

NTSTATUS
iSpSendData(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLen,
    OUT PULONG BytesSent
    );

ULONG
iSpAcquireRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    );

VOID
iSpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    );

NTSTATUS
iSpQueryDeviceRelationsCompletion(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PVOID Context
    );

NTSTATUS
iSpSendLoginCommand(
    IN PISCSI_PDO_EXTENSION PdoExtension
    );

NTSTATUS
iSpSendLoginResponse(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
iScsiPortPdoDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortPdoPnp(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortPdoDispatch(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortPdoCreateClose(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    );
NTSTATUS
iScsiPortGetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
iScsiPortGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
iScsiPortGetCompatibleIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
iScsiPortGetHardwareIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    );

PISCSI_DEVICE_TYPE
iSpGetDeviceTypeInfo(
    IN UCHAR DeviceType
    );

NTSTATUS
iSpMultiStringToStringArray(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    OUT PWSTR *StringArray[],
    BOOLEAN Forward
    );

NTSTATUS
iScsiPortStringArrayToMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    );

NTSTATUS
iSpSendScsiCommand(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iSpProcessScsiResponse(
    PISCSI_CONNECTION IScsiConnection,
    PISCSI_SCSI_RESPONSE IScsiScsiResponse
    );

NTSTATUS
iSpSendSrbSynchronous(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIRP Irp,
    IN PVOID DataBuffer,
    IN ULONG TransferLength,
    IN OPTIONAL PVOID SenseInfoBuffer,
    IN OPTIONAL UCHAR SenseInfoBufferLength,
    OUT PULONG BytesReturned
    );

NTSTATUS
IssueInquiry(
    IN PDEVICE_OBJECT LogicalUnit
    );

NTSTATUS
iSpClaimLogicalUnit(
    IN PISCSI_FDO_EXTENSION FdoExtension,
    IN PISCSI_PDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortQueryProperty(
    IN PDEVICE_OBJECT Pdo, 
    PIRP Irp);

NTSTATUS
iSpQueryDeviceText(
    IN PDEVICE_OBJECT LogicalUnit,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    );

NTSTATUS
iSpProcessReceivedData(
    IN PISCSI_CONNECTION IScsiConnection,
    IN ULONG BytesIndicated,
    OUT ULONG *BytesTaken,
    IN PVOID DataBuffer
    );

NTSTATUS
iSpProcessScsiRequest(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
iSpInitializeLocalNodes(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
iSpTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
iSpLaunchEnumerationCompletion(
    IN PISCSI_FDO_EXTENSION FdoExtension
    );

#endif // _PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\pdo.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    pdo.c

Abstract:

    This file contains PDO routines

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


NTSTATUS
iScsiPortPdoDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status;
    ULONG isRemoved;

    isRemoved = iSpAcquireRemoveLock(Pdo, Irp);
    if(isRemoved) {

        iSpReleaseRemoveLock(Pdo, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    DebugPrint((3, "PDO DeviceControl - IO Control Code : 0x%08x\n", 
                ioControlCode));

    switch (ioControlCode) {
        case IOCTL_STORAGE_QUERY_PROPERTY: {

            //
            // Validate the query
            //

            PSTORAGE_PROPERTY_QUERY query = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_PROPERTY_QUERY)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status = iScsiPortQueryProperty(Pdo, Irp);

            return status;

            break;
        }

        case IOCTL_SCSI_GET_IP_ADDRESS: {
            PISCSI_IP_ADDRESS iScsiAddress = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
               sizeof(ISCSI_IP_ADDRESS)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            iScsiAddress->IPAddress = pdoExtension->TargetIPAddress;
            iScsiAddress->PortNumber = pdoExtension->TargetPortNumber;

            Irp->IoStatus.Information = sizeof(ISCSI_IP_ADDRESS);
            status = STATUS_SUCCESS;

            break;
        }

        case IOCTL_SCSI_GET_ADDRESS: {

            PSCSI_ADDRESS scsiAddress = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
               sizeof(SCSI_ADDRESS)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            scsiAddress->Length = sizeof(PSCSI_ADDRESS);
            scsiAddress->PortNumber = (UCHAR) pdoExtension->PortNumber;
            scsiAddress->PathId = pdoExtension->PathId;
            scsiAddress->TargetId = pdoExtension->TargetId;
            scsiAddress->Lun = pdoExtension->Lun;

            Irp->IoStatus.Information = sizeof(SCSI_ADDRESS);
            status = STATUS_SUCCESS;
            break;
        }

        default: {
            IoSkipCurrentIrpStackLocation(Irp);
            iSpReleaseRemoveLock(Pdo, Irp);
            return IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        }
    } // switch (ioControlCode)

    iSpReleaseRemoveLock(Pdo, Irp);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
iScsiPortPdoPnp(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = LogicalUnit->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = LogicalUnit->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG isRemoved;

    isRemoved = iSpAcquireRemoveLock(LogicalUnit, Irp);
    if(isRemoved) {

        iSpReleaseRemoveLock(LogicalUnit, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    DebugPrint((1, "PDO PnP - Minorfunction Code : 0x%x\n",
                irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        
        case IRP_MN_START_DEVICE: {
            commonExtension->CurrentPnpState = IRP_MN_START_DEVICE;
            commonExtension->PreviousPnpState = 0xff;

            commonExtension->IsInitialized = TRUE;

            //
            // Make up numbers here
            //
            pdoExtension->PortNumber = 5;
            pdoExtension->PathId = 0;

            //
            // N.B. TargetId is set in iSpInitializeLocalNodes
            // routine when the PDO is created.
            //
            pdoExtension->Lun = 0;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_DEVICE_RELATIONS: {
        
            PDEVICE_RELATIONS deviceRelations;
        
            if(irpStack->Parameters.QueryDeviceRelations.Type !=
               TargetDeviceRelation) {
        
                DebugPrint((1, "Not TargetDevicesRelations for PDO\n"));

                break;
            }
        
            //
            // DEVICE_RELATIONS definition contains one object pointer.
            //
        
            deviceRelations = iSpAllocatePool(PagedPool,
                                              sizeof(DEVICE_RELATIONS),
                                              ISCSI_TAG_DEVICE_RELATIONS);
        
            if(deviceRelations == NULL) {
        
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        
            RtlZeroMemory(deviceRelations, sizeof(DEVICE_RELATIONS));
        
            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = LogicalUnit;
        
            ObReferenceObject(deviceRelations->Objects[0]);
        
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
        
            DebugPrint((1, "Completing QDR for PDO successfully\n"));
            break;
        }

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_DEVICE_TEXT: {
    
            Irp->IoStatus.Status =
                iSpQueryDeviceText(
                    LogicalUnit,
                    irpStack->Parameters.QueryDeviceText.DeviceTextType,
                    irpStack->Parameters.QueryDeviceText.LocaleId,
                    (PWSTR *) &Irp->IoStatus.Information
                    );
    
            break;
        }

        case IRP_MN_QUERY_ID: {

            UCHAR rawIdString[64] = "UNKNOWN ID TYPE";
            ANSI_STRING ansiIdString;
            UNICODE_STRING unicodeIdString;
            BOOLEAN multiStrings;

            PINQUIRYDATA inquiryData = &(pdoExtension->InquiryData);

            if ((pdoExtension->InquiryDataInitialized) == FALSE) {
                DebugPrint((3, "PdoPnp : Will obtain inquiry data\n"));

                status = IssueInquiry(LogicalUnit);

                if (!NT_SUCCESS(status)) {
                    DebugPrint((1, 
                                "Failed to get inquiry data. Status : %x\n",
                                status));

                    Irp->IoStatus.Status = status;
                    iSpReleaseRemoveLock(LogicalUnit, Irp);
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    return status;
                } else {
                    DebugPrint((3, "PdoPnp : Obtained Inquiry data.\n"));
                }
            }


            //
            // We've been asked for the id of one of the physical device objects
            //

            DebugPrint((3, "PDO PnP: Got IRP_MN_QUERY_ID\n"));

            RtlInitUnicodeString(&unicodeIdString, NULL);
            RtlInitAnsiString(&ansiIdString, NULL);

            switch(irpStack->Parameters.QueryId.IdType) {

                case BusQueryDeviceID: {

                    DebugPrint((3, "BusQueryDeviceID\n"));
                    status = iScsiPortGetDeviceId(LogicalUnit, 
                                                  &unicodeIdString);
                    multiStrings = FALSE;

                    break;
                }

                case BusQueryInstanceID: {

                    DebugPrint((3, "BusQueryInstanceID\n"));
                    status = iScsiPortGetInstanceId(LogicalUnit, 
                                                    &unicodeIdString);
                    multiStrings = FALSE;

                    break;
                }

                case BusQueryHardwareIDs: {

                    DebugPrint((3, "BusQueryHardwareIDs\n"));
                    status = iScsiPortGetHardwareIds(
                                LogicalUnit->DriverObject,
                                &(pdoExtension->InquiryData),
                                &unicodeIdString);
                    multiStrings = TRUE;
                    break;
                }

                case BusQueryCompatibleIDs: {

                    DebugPrint((3, "BusQueryCompatibleIDs\n"));
                    status = iScsiPortGetCompatibleIds(
                                LogicalUnit->DriverObject,
                                &(pdoExtension->InquiryData),
                                &unicodeIdString);
                    multiStrings = TRUE;

                    break;
                }

                default: {

                    status = Irp->IoStatus.Status;
                    Irp->IoStatus.Information = 0;

                    break;

                }
            }

            Irp->IoStatus.Status = status;

            if(NT_SUCCESS(status)) {

                PWCHAR idString;

                DebugPrint((3, "Query ID successful\n"));

                //
                // fix up all invalid characters
                //
                idString = unicodeIdString.Buffer;
                while (*idString) {

                    if ((*idString <= L' ')  ||
                        (*idString > (WCHAR)0x7F) ||
                        (*idString == L',')) {
                        *idString = L'_';
                    }
                    idString++;

                    if ((*idString == L'\0') && multiStrings) {
                        idString++;
                    }
                }

                Irp->IoStatus.Information = (ULONG_PTR) unicodeIdString.Buffer;
            } else {
                DebugPrint((1, "Query ID failed\n"));
                Irp->IoStatus.Information = (ULONG_PTR) NULL;
            }

            iSpReleaseRemoveLock(LogicalUnit, Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            return status;
            break;
        }

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            break;
        }

        case IRP_MN_REMOVE_DEVICE: {
            PISCSI_FDO_EXTENSION fdoExtension;
            ULONG inx;
            BOOLEAN foundPDO = FALSE;

            iSpReleaseRemoveLock(LogicalUnit, Irp);

            //
            // Remove this PDO from FDO's PDO List
            //

            fdoExtension = pdoExtension->ParentFDOExtension;
            inx = 0;
            while (inx < (fdoExtension->NumberOfTargets)) {

                if (fdoExtension->PDOList[inx] == LogicalUnit) {
                    foundPDO = TRUE;
                    break;
                }

                inx++;
            }

            if (foundPDO == TRUE) {
                DebugPrint((1, "Found the PDO : 0x%x\n",
                            LogicalUnit));

                pdoExtension->IsClaimed = FALSE;

                commonExtension->IsRemoved = REMOVE_PENDING;

                if ((pdoExtension->IsMissing == TRUE) &&
                    (pdoExtension->IsEnumerated == FALSE)) {

                    (fdoExtension->NumberOfTargets)--;

                    DebugPrint((0, "Will remove the PDO\n"));

                    commonExtension->IsRemoved = REMOVE_COMPLETE;

                    pdoExtension->PathId = 0xff;
                    pdoExtension->TargetId = 0xff;
                    pdoExtension->Lun = 0xff;

                    DebugPrint((0, "Query remove received for the PDO\n"));

                    iSpStopNetwork(LogicalUnit);

                    IoDeleteDevice(LogicalUnit);

                } else {
                    DebugPrint((0, "Will not delete the PDO\n"));
                    commonExtension->IsRemoved = NO_REMOVE;
                }

                status = STATUS_SUCCESS;
            } else {
                DebugPrint((0, "Did not find the PDO\n"));
                status = STATUS_NO_SUCH_DEVICE;
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            return status;
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: 
        case IRP_MN_QUERY_STOP_DEVICE: {

            DebugPrint((0, "Query remove or query stop received\n"));
            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;
        }

        default: {
            DebugPrint((1, 
                        "Not handling PDO MN Code - 0x%x. Status - 0x%08x\n",
                        (irpStack->MinorFunction),
                        (Irp->IoStatus.Status)));
        }
    }

    iSpReleaseRemoveLock(LogicalUnit, Irp);

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
iScsiPortPdoDispatch(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    )
{
    PISCSI_PDO_EXTENSION pdoExtension = LogicalUnit->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = LogicalUnit->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    NTSTATUS status;
    ULONG isRemoved;
    BOOLEAN sendCommandToServer = FALSE;

    DebugPrint((3, "PdoDispatch - SRB Function : 0x%x\n",
                srb->Function));

    isRemoved = iSpAcquireRemoveLock(LogicalUnit, Irp);
    if (isRemoved &&
        !IS_CLEANUP_REQUEST(irpStack) &&
        (srb->Function != SRB_FUNCTION_CLAIM_DEVICE)) {

        iSpReleaseRemoveLock(LogicalUnit, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    switch(srb->Function) {

        case SRB_FUNCTION_ABORT_COMMAND: {
            DebugPrint((1, "Not handling abort command\n"));
            status = STATUS_NOT_SUPPORTED;
            break;

        }

        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_REMOVE_DEVICE: {

            status = iSpClaimLogicalUnit(
                        pdoExtension->CommonExtension.LowerDeviceObject->DeviceExtension,
                        pdoExtension,
                        Irp);

            break;
        }

        case SRB_FUNCTION_RELEASE_QUEUE:
        case SRB_FUNCTION_FLUSH_QUEUE: 
        case SRB_FUNCTION_SHUTDOWN:
        case SRB_FUNCTION_FLUSH:
        case SRB_FUNCTION_LOCK_QUEUE:
        case SRB_FUNCTION_UNLOCK_QUEUE:
        case SRB_FUNCTION_IO_CONTROL:
        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_WMI:  {

            //
            // We won't handle these functions on the client
            // side for the timebeing.
            //
            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            break;
        }

        case SRB_FUNCTION_EXECUTE_SCSI: {

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            sendCommandToServer = TRUE;

            status = STATUS_PENDING;

            break;
        }

        default: {
            //
            // Unsupported SRB function.
            //
            DebugPrint((0,
                        "PdoDispatch: Unsupported function, SRB %p\n",
                        srb));

            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    if (sendCommandToServer == FALSE) {
        DebugPrint((1, "Not sending the command to the server\n"));
        iSpReleaseRemoveLock(LogicalUnit, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    DebugPrint((3, "Will send the command to the server\n"));

    status = iSpSendScsiCommand(LogicalUnit, Irp);

    if (NT_SUCCESS(status)) {
        DebugPrint((3, "Command successfully sent to the server.\n"));
        status = STATUS_PENDING;
    } else {
        //
        // In case of error, the lock will be released and the irp will 
        // be completed in iSpSendScsiCommand routine.
        //
        DebugPrint((1, "Failed to send the command. Status : %x\n",
                    status));
    }

    return status;
}


NTSTATUS
iScsiPortPdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    ULONG isRemoved;
    NTSTATUS status = STATUS_SUCCESS;

    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_CREATE) {

       if(isRemoved) {
           status = STATUS_DEVICE_DOES_NOT_EXIST;
       } 
    }

    Irp->IoStatus.Status = status;

    iSpReleaseRemoveLock(DeviceObject, Irp);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\prop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998

Module Name:

    prop.c

Abstract:

    This is the NT SCSI port driver.  This module contains code relating to
    property queries

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

NTSTATUS
iSpBuildDeviceDescriptor(
    IN PISCSI_PDO_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
iSpBuildDeviceIdDescriptor(
    IN PISCSI_PDO_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
iSpBuildAdapterDescriptor(
    IN PISCSI_FDO_EXTENSION FdoExtension,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, iSpBuildDeviceDescriptor)
#pragma alloc_text(PAGE, iSpBuildDeviceIdDescriptor)
#pragma alloc_text(PAGE, iSpBuildAdapterDescriptor)
#pragma alloc_text(PAGE, iScsiPortQueryProperty)
#pragma alloc_text(PAGE, iSpQueryDeviceText)
#endif


NTSTATUS
iScsiPortQueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);

    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    ULONG queryLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    NTSTATUS status;

    PAGED_CODE();

    //
    // We don't actually support mask queries.
    //

    if(query->QueryType >= PropertyMaskQuery) {

        status = STATUS_INVALID_PARAMETER_1;
        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        iSpReleaseRemoveLock(DeviceObject, QueryIrp);
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    switch(query->PropertyId) {

        case StorageDeviceProperty: {

            //
            // Make sure this is a target device.
            //

            if(!commonExtension->IsPdo) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            if(query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = iSpBuildDeviceDescriptor(
                            (PISCSI_PDO_EXTENSION) commonExtension,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }
            break;
        }

        case StorageAdapterProperty: {

            PDEVICE_OBJECT adapterObject = DeviceObject;

            //
            // if this is a target device then forward it down to the
            // underlying device object.  This lets filters do their magic
            //

            if(commonExtension->IsPdo) {

                //
                // Call the lower device
                //

                IoSkipCurrentIrpStackLocation(QueryIrp);
                iSpReleaseRemoveLock(DeviceObject, QueryIrp);
                status = IoCallDriver(commonExtension->LowerDeviceObject, QueryIrp);

                return status;
            }

            if(query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = iSpBuildAdapterDescriptor(
                            (PISCSI_FDO_EXTENSION) commonExtension,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }
            break;
        }

        case StorageDeviceIdProperty: {

            PISCSI_PDO_EXTENSION logicalUnit;

            //
            // Make sure this is a target device.
            //

            if(!commonExtension->IsPdo) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            logicalUnit = DeviceObject->DeviceExtension;

            //
            // Check to see if we have a device identifier page.  If not then
            // fail any calls for this type of identifier.
            //

            if(logicalUnit->DeviceIdentifierPage != NULL) {

                if(query->QueryType == PropertyExistsQuery) {
                    status = STATUS_SUCCESS;
                } else {
                    status = iSpBuildDeviceIdDescriptor(
                                logicalUnit,
                                QueryIrp->AssociatedIrp.SystemBuffer,
                                &queryLength);

                    QueryIrp->IoStatus.Information = queryLength;
                }
            } else {
                status = STATUS_NOT_SUPPORTED;
            }

            break;
        }

        default: {

            //
            // If this is a target device then some filter beneath us may
            // handle this property.
            //

            if(commonExtension->IsPdo) {

                //
                // Call the lower device.
                //

                IoSkipCurrentIrpStackLocation(QueryIrp);
                iSpReleaseRemoveLock(DeviceObject, QueryIrp);
                status = IoCallDriver(commonExtension->LowerDeviceObject, QueryIrp);

                return status;
            }

            //
            // Nope, this property really doesn't exist
            //

            status = STATUS_INVALID_PARAMETER_1;
            QueryIrp->IoStatus.Information = 0;
            break;
        }
    }

    if(status != STATUS_PENDING) {
        QueryIrp->IoStatus.Status = status;
        iSpReleaseRemoveLock(DeviceObject, QueryIrp);
        IoCompleteRequest(QueryIrp, IO_DISK_INCREMENT);
    }

    return status;
}

NTSTATUS
iSpBuildDeviceDescriptor(
    IN PISCSI_PDO_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device descriptor based on the information in
    it's device extension.  It will copy as much data as possible into
    the Descriptor and will update the DescriptorLength to indicate the
    number of bytes copied

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    PISCSIPORT_DRIVER_EXTENSION driverExtension =
        IoGetDriverObjectExtension(LogicalUnit->DeviceObject->DriverObject,
                                   (PVOID)ISCSI_TAG_DRIVER_EXTENSION);

    LONG maxLength = *DescriptorLength;
    LONG bytesRemaining = maxLength;
    LONG realLength = sizeof(STORAGE_DEVICE_DESCRIPTOR);

    PUCHAR currentOffset = (PUCHAR) Descriptor;

    LONG inquiryLength;

    PINQUIRYDATA inquiryData = &(LogicalUnit->InquiryData);

    STORAGE_DEVICE_DESCRIPTOR tmp;

    PAGED_CODE();

    ASSERT(Descriptor != NULL);

    //
    // Figure out what the total size of this structure is going to be
    //

    inquiryLength = 4 + inquiryData->AdditionalLength;

    if(inquiryLength > INQUIRYDATABUFFERSIZE) {
        inquiryLength = INQUIRYDATABUFFERSIZE;
    }

    realLength += inquiryLength + 31;   // 31 = length of the 3 id strings +
                                        // 3 nuls

    //
    // Zero the buffer provided.
    //

    RtlZeroMemory(Descriptor, *DescriptorLength);

    //
    // Build the device descriptor structure on the stack then copy as much as
    // can be copied over
    //

    RtlZeroMemory(&tmp, sizeof(STORAGE_DEVICE_DESCRIPTOR));

    tmp.Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);
    tmp.Size = realLength;

    tmp.DeviceType = inquiryData->DeviceType;
    tmp.DeviceTypeModifier = inquiryData->DeviceTypeModifier;

    tmp.RemovableMedia = inquiryData->RemovableMedia;

    tmp.CommandQueueing = inquiryData->CommandQueue;

    tmp.SerialNumberOffset = 0xffffffff;

    tmp.BusType = driverExtension->BusType;

    RtlCopyMemory(currentOffset,
                  &tmp,
                  min(sizeof(STORAGE_DEVICE_DESCRIPTOR), bytesRemaining));

    bytesRemaining -= sizeof(STORAGE_DEVICE_DESCRIPTOR);

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // Copy over as much inquiry data as we can and update the raw byte count
    //

    RtlCopyMemory(currentOffset, inquiryData, min(inquiryLength, bytesRemaining));

    bytesRemaining -= inquiryLength;

    if(bytesRemaining <= 0) {

        *DescriptorLength = maxLength;

        Descriptor->RawPropertiesLength = maxLength -
                                          sizeof(STORAGE_DEVICE_DESCRIPTOR);

        return STATUS_SUCCESS;
    }

    Descriptor->RawPropertiesLength = inquiryLength;

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // Now we need to start copying inquiry strings
    //

    //
    // first the vendor id
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->VendorId,
                  min(bytesRemaining, sizeof(UCHAR) * 8));

    bytesRemaining -= sizeof(UCHAR) * 9;     // include trailing null

    if(bytesRemaining >= 0) {

        Descriptor->VendorIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                      (ULONG_PTR) Descriptor);

    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // now the product id
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->ProductId,
                  min(bytesRemaining, 16));
    bytesRemaining -= 17;                   // include trailing null

    if(bytesRemaining >= 0) {

        Descriptor->ProductIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                       (ULONG_PTR) Descriptor);
    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // And the product revision
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->ProductRevisionLevel,
                  min(bytesRemaining, 4));
    bytesRemaining -= 5;

    if(bytesRemaining >= 0) {
        Descriptor->ProductRevisionOffset = (ULONG)((ULONG_PTR) currentOffset -
                                             (ULONG_PTR) Descriptor);
    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    *DescriptorLength = maxLength - bytesRemaining;
    return STATUS_SUCCESS;
}


NTSTATUS
iSpBuildAdapterDescriptor(
    IN PISCSI_FDO_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )
{
    PISCSIPORT_DRIVER_EXTENSION driverExtension =
        IoGetDriverObjectExtension(Adapter->DeviceObject->DriverObject,
                                   (PVOID)ISCSI_TAG_DRIVER_EXTENSION);

    PIO_SCSI_CAPABILITIES capabilities = &(Adapter->IoScsiCapabilities);

    STORAGE_ADAPTER_DESCRIPTOR tmp;

    PAGED_CODE();

    //
    // Call to IoGetDriverObjectExtension can return NULL
    //
    if (driverExtension == NULL) {
        *DescriptorLength = 0;
        return STATUS_UNSUCCESSFUL;
    }

    tmp.Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
    tmp.Size = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    tmp.MaximumTransferLength = capabilities->MaximumTransferLength;
    tmp.MaximumPhysicalPages = capabilities->MaximumPhysicalPages;

    tmp.AlignmentMask = capabilities->AlignmentMask;

    tmp.AdapterUsesPio = capabilities->AdapterUsesPio;
    tmp.AdapterScansDown = capabilities->AdapterScansDown;
    tmp.CommandQueueing = capabilities->TaggedQueuing;
    tmp.AcceleratedTransfer = TRUE;

    tmp.BusType = (BOOLEAN) driverExtension->BusType;
    tmp.BusMajorVersion = 2;
    tmp.BusMinorVersion = 0;

    RtlCopyMemory(Descriptor,
                  &tmp,
                  min(*DescriptorLength, sizeof(STORAGE_ADAPTER_DESCRIPTOR)));

    *DescriptorLength = min(*DescriptorLength, sizeof(STORAGE_ADAPTER_DESCRIPTOR));

    return STATUS_SUCCESS;
}


NTSTATUS
iSpQueryDeviceText(
    IN PDEVICE_OBJECT LogicalUnit,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    )

{
    PISCSI_PDO_EXTENSION pdoExtension = LogicalUnit->DeviceExtension;

    UCHAR ansiBuffer[256];
    ANSI_STRING ansiText;

    UNICODE_STRING unicodeText;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeText, NULL);

    if(TextType == DeviceTextDescription) {

        PISCSI_DEVICE_TYPE deviceInfo =
            iSpGetDeviceTypeInfo(pdoExtension->InquiryData.DeviceType);

        PUCHAR c;
        LONG i;

        RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));
        RtlCopyMemory(ansiBuffer,
                      pdoExtension->InquiryData.VendorId,
                      sizeof(pdoExtension->InquiryData.VendorId));
        c = ansiBuffer;

        for(i = sizeof(pdoExtension->InquiryData.VendorId); i >= 0; i--) {
            if((c[i] != '\0') &&
               (c[i] != ' ')) {
                break;
            }
            c[i] = '\0';
        }
        c = &(c[i + 1]);

        sprintf(c, " ");
        c++;

        RtlCopyMemory(c,
                      pdoExtension->InquiryData.ProductId,
                      sizeof(pdoExtension->InquiryData.ProductId));

        for(i = sizeof(pdoExtension->InquiryData.ProductId); i >= 0; i--) {
            if((c[i] != '\0') &&
               (c[i] != ' ')) {
                break;
            }
            c[i] = '\0';
        }
        c = &(c[i + 1]);

        sprintf(c, " SCSI %s Device", deviceInfo->DeviceTypeString);

    } else if (TextType == DeviceTextLocationInformation) {

        sprintf(ansiBuffer, "Bus Number %d, Target ID %d, LUN %d",
                pdoExtension->PathId,
                pdoExtension->TargetId,
                pdoExtension->Lun);

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    RtlInitAnsiString(&ansiText, ansiBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeText,
                                          &ansiText,
                                          TRUE);

    *DeviceText = unicodeText.Buffer;
    return status;
}

NTSTATUS
iSpBuildDeviceIdDescriptor(
    IN PISCSI_PDO_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device id descriptor based on the device
    identifier page retrieved during discovery.  It is an error to call this
    routine if no device identifier page exists.

    This routine will copy as much data as possible into the Descriptor and
    will update the DescriptorLength to indicate the number of bytes copied.

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    PVPD_IDENTIFICATION_PAGE idPage = LogicalUnit->DeviceIdentifierPage;
    ULONG idOffset;

    ULONG maxLength = *DescriptorLength;
    PUCHAR destOffset;

    LONG identifierLength;
    ULONG identifierCount = 0;

    PAGED_CODE();

    ASSERT(Descriptor != NULL);
    ASSERT(LogicalUnit->DeviceIdentifierPage != NULL);

    if(maxLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the header of the descriptor.
    //

    RtlZeroMemory(Descriptor, *DescriptorLength);
    Descriptor->Version = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);

    Descriptor->Size = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

    //
    // Prepare to copy the identifiers directly into the buffer.
    //

    destOffset = Descriptor->Identifiers;

    //
    // Walk through the id page.  Count the number of descriptors and
    // calculate the size of the descriptor page.
    //

    for(idOffset = 0; idOffset < idPage->PageLength;) {
        PVPD_IDENTIFICATION_DESCRIPTOR src;
        USHORT identifierSize;

        src = (PVPD_IDENTIFICATION_DESCRIPTOR) &(idPage->Descriptors[idOffset]);

        identifierSize = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        identifierSize += src->IdentifierLength;

        //
        // Align the identifier size to 32-bits.
        //

        identifierSize += sizeof(ULONG);
        identifierSize &= ~(sizeof(ULONG) - 1);

        identifierCount += 1;

        Descriptor->Size += identifierSize;

        if(Descriptor->Size <= maxLength) {
            PSTORAGE_IDENTIFIER dest;

            dest = (PSTORAGE_IDENTIFIER) destOffset;

            dest->CodeSet = src->CodeSet;
            dest->Type = src->IdentifierType;

            dest->IdentifierSize = src->IdentifierLength;
            dest->NextOffset = identifierSize;

            RtlCopyMemory(dest->Identifier,
                          src->Identifier,
                          src->IdentifierLength);

            destOffset += dest->NextOffset;
        }

        idOffset += sizeof(PVPD_IDENTIFICATION_DESCRIPTOR);
        idOffset += src->IdentifierLength;
    }

    if(*DescriptorLength >= FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR,
                                        Identifiers)) {

        Descriptor->NumberOfIdentifiers = identifierCount;
    }

    *DescriptorLength = min(Descriptor->Size, *DescriptorLength);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\lock.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    lock.c

Abstract:

    This file contains code iSCSI Port driver

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


ULONG
iSpAcquireRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

    lockValue = InterlockedIncrement(&(commonExtension->RemoveLock));

    ASSERTMSG("iSpAcquireRemoveLock : lock value was negative ",
              (lockValue > 0));

    return (commonExtension->IsRemoved);
}


VOID
iSpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

    lockValue = InterlockedDecrement(&(commonExtension->RemoveLock));

    if (lockValue < 0) {
        ASSERTMSG("iSpReleaseRemoveLock : lock value was negative ",
                  (lockValue >= 0));
    }

    if (lockValue == 0) {
        DebugPrint((3, "Releaselock for device object %x\n",
                    DeviceObject));
        KeSetEvent(&(commonExtension->RemoveEvent),
                   IO_NO_INCREMENT,
                   FALSE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\protocol.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    protocol.c

Abstract:

    This file contains iSCSI protocol related routines.

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

LONG  GlobalSessionID;
LONG  InitiatorSessionID;

#define ISCSI_TARGET "target:"
#define ISCSI_TARGET_LENGTH 7
#define ISCSI_USE_RTT "UseRtt:no"
#define ISCSI_USE_RTT_LENGTH 9

ULONG
iSpGetActiveClientRequestIndex(
    PISCSI_CONNECTION IScsiConnection,
    ULONG TaskTag
    );

ULONG
iSpGetReqIndexUsingCmdRN(
    PISCSI_CONNECTION IScsiConnection,
    ULONG CmdRN
    );


NTSTATUS
iSpSendLoginCommand(
    IN PISCSI_PDO_EXTENSION PdoExtension
    )
{
    PISCSI_CONNECTION iScsiConnection;
    PISCSI_LOGIN_COMMAND iscsiLoginCommand;
    PUCHAR loginParameters;
    NTSTATUS status;
    ULONG bytesSent;
    ULONG tempULong;
    ULONG packetSize;
    ULONG targetLength;

    iScsiConnection = PdoExtension->ClientNodeInfo;

    ASSERT((iScsiConnection != NULL));
    ASSERT((iScsiConnection->Type) == ISCSI_CONNECTION_TYPE);

    targetLength = strlen(PdoExtension->TargetName);
    packetSize = (sizeof(ISCSI_LOGIN_COMMAND) + ISCSI_TARGET_LENGTH + 
                  targetLength + ISCSI_USE_RTT_LENGTH + 2);

    iscsiLoginCommand = iSpAllocatePool(
                          NonPagedPool,
                          packetSize,
                          ISCSI_TAG_LOGIN_CMD);
    if (iscsiLoginCommand == NULL) {
        DebugPrint((0, "Failed to allocate logon packet\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(iscsiLoginCommand, 
                  packetSize);

    iscsiLoginCommand->OpCode = ISCSIOP_LOGIN_COMMAND;

    //
    // No authentication performed
    //
    iscsiLoginCommand->LoginType = ISCSI_LOGINTYPE_NONE;

    //
    // Connection ID for this session
    //
    tempULong =  InterlockedIncrement(&GlobalSessionID);
    iscsiLoginCommand->ConnectionID[0] = (UCHAR) ((tempULong & 0xFF00) >> 8);
    iscsiLoginCommand->ConnectionID[1] = (UCHAR) (tempULong & 0xFF);

    //
    // Command Reference number starting from 1
    //
    iscsiLoginCommand->InitCmdRN[3] = 1;

    tempULong = InterlockedIncrement(&InitiatorSessionID);
    iscsiLoginCommand->ISID[0]      = (UCHAR) ((tempULong & 0xFF00) >> 8);
    iscsiLoginCommand->ISID[1] = (UCHAR) (tempULong & 0xFF);

    //
    // Identifier for the target device is passed as parameters 
    // in the Login packet
    //
    // "target:<TargetName>"  -- Target device name 
    // "UseRtt:no"     -- Do NOT use RTT
    //
    loginParameters = (PUCHAR) (iscsiLoginCommand + 1);

    RtlCopyMemory(loginParameters, ISCSI_TARGET, ISCSI_TARGET_LENGTH);
    loginParameters += ISCSI_TARGET_LENGTH;

    RtlCopyMemory(loginParameters, PdoExtension->TargetName, targetLength);    
    loginParameters += targetLength + 1;

    RtlCopyMemory(loginParameters, ISCSI_USE_RTT, ISCSI_USE_RTT_LENGTH);

    iscsiLoginCommand->Length[3] = 
        ISCSI_TARGET_LENGTH + (UCHAR) targetLength + ISCSI_USE_RTT_LENGTH + 2;

    /*
    {
        ULONG inx0, inx1, len;

        DebugPrint((1, "\n Logon Packet\n"));

        len = (ISCSI_TARGET_LENGTH + targetLength + 
               ISCSI_USE_RTT_LENGTH + 2 + 48);
        inx0 = 0;
        while(inx0 < len) {
            inx1 = 0;
            DebugPrint((1, "\t"));
            while ((inx1 < 4) &&
                   ((inx0+inx1) < len)) {
                DebugPrint((1, "0x%02x ", 
                            ((PUCHAR)iscsiLoginCommand)[inx0+inx1]));
                inx1++;
            }
            DebugPrint((1, "\n"));

            inx0 += 4;
        }
        DebugPrint((1, "\n"));
    }
    */

    //
    // Save away the connection ID in our device extension
    //
    PdoExtension->SavedConnectionID[0] = iscsiLoginCommand->ConnectionID[0];
    PdoExtension->SavedConnectionID[1] = iscsiLoginCommand->ConnectionID[1];

    status = iSpSendData(iScsiConnection->ConnectionDeviceObject,
                         iScsiConnection->ConnectionFileObject,
                         iscsiLoginCommand,
                         packetSize,
                         &bytesSent);
    if (NT_SUCCESS(status)) {

        DebugPrint((3, "Send succeeded for logon. Bytes sent : %d\n", 
                    bytesSent));
    } else {
        DebugPrint((0, "Failed to logon packet. Status : %x\n",
                    status));

        PdoExtension->SavedConnectionID[0] = 0;
        PdoExtension->SavedConnectionID[1] = 0;
    }

    return status;
}


NTSTATUS
iSpSendScsiCommand(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PISCSI_PDO_EXTENSION pdoExtension = NULL;
    PISCSI_CONNECTION iScsiConnection = NULL;

    PISCSI_SCSI_COMMAND iScsiScsiCommand = NULL;

    PACTIVE_REQUESTS currentRequest;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    PVOID requestBuffer = NULL;
    PVOID originalDataBuffer = NULL;
    ULONG_PTR offset;

    PVOID receiveBuffer = NULL;
    ULONG receiveBufferSize = 0;

    ULONG cmdRN;
    ULONG expectedDataLen;

    ULONG packetSize;
    ULONG inx;
    ULONG bytesSent;

    NTSTATUS status;

    KIRQL oldIrql;

    BOOLEAN writeToDevice;

    ASSERT(commonExtension->IsPdo);
    pdoExtension = (PISCSI_PDO_EXTENSION)(DeviceObject->DeviceExtension);

    iScsiConnection = pdoExtension->ClientNodeInfo;

    if ((iScsiConnection->ConnectionState) != ConnectionStateConnected) {
        DebugPrint((0, "Not connected to target. Connection State : %d\n",
                    (iScsiConnection->ConnectionState)));

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        Irp->IoStatus.Information = 0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_DEVICE_NOT_CONNECTED;
    }

    ASSERT((pdoExtension->CurrentProtocolState) == PSFullFeaturePhase);

    //
    // Get the lock to synchronize access to iSCSI
    // Connection structure
    //
    KeAcquireSpinLock(&(iScsiConnection->RequestLock), 
                      &oldIrql);

    if ((iScsiConnection->NumberOfReqsInProgress) >= 
        (iScsiConnection->MaxPendingRequests)) {

        //
        // Queue it to the request list for this connection
        //

        IoMarkIrpPending(Irp);

        ExInterlockedInsertTailList(&(iScsiConnection->RequestList),
                                    &(Irp->Tail.Overlay.ListEntry),
                                    &(iScsiConnection->ListSpinLock));

        KeReleaseSpinLock(&(iScsiConnection->RequestLock), 
                          oldIrql);

        return STATUS_PENDING;
    }

    expectedDataLen = 0;

    writeToDevice = FALSE;

    packetSize = sizeof(ISCSI_SCSI_COMMAND);

    if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        expectedDataLen = srb->DataTransferLength;

    } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

        //
        // If we are writing to the device, the data
        // is sent as immediate data
        //
        packetSize += srb->DataTransferLength;
        writeToDevice = TRUE;
    }

    if (Irp->MdlAddress) {

        offset = (ULONG_PTR) ((ULONG_PTR) srb->DataBuffer -
                         (ULONG_PTR) MmGetMdlVirtualAddress(Irp->MdlAddress));

        DebugPrint((3, "Srb DataBuffer : 0x%x, Offset into the MDL : 0x%x\n",
                    srb->DataBuffer, offset));

        requestBuffer = MmGetSystemAddressForMdlSafe(
                           Irp->MdlAddress,
                           ((Irp->RequestorMode == KernelMode) ?
                            HighPagePriority :
                            NormalPagePriority));
        if (requestBuffer != NULL) {
            UCHAR readChar;

            //
            // Save the original DataBuffer passed in the SRB
            //
            originalDataBuffer = srb->DataBuffer;

            DebugPrint((3, "SendCommand : Original DataBuffer - 0x%08x\n",
                        originalDataBuffer));

            srb->DataBuffer = (PVOID) ((ULONG_PTR) requestBuffer +
                                      (ULONG_PTR) offset);
            //
            // This is for catching the case where the Srb DataBuffer
            // we have generated is not valid
            //
            readChar = *((PUCHAR)(srb->DataBuffer));

            DebugPrint((3, 
                        "OpCode : %d, SRB DataBuffer : %x. ReadChar : %d\n", 
                        srb->Cdb[0],
                        srb->DataBuffer,
                        readChar));

            DebugPrint((3, "System address for requestBuffer : 0x%08x\n",
                        requestBuffer));
        } else {

            DebugPrint((1, "Failed to get System Address for MDL\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0L;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            goto iSpSendScsiCommandExit;
        }
    }

    iScsiScsiCommand = iSpAllocatePool(
                          NonPagedPool,
                          packetSize,
                          ISCSI_TAG_SCSI_CMD);
    if (iScsiScsiCommand == NULL) {

        DebugPrint((1, "Could not allocate iSCSI Command packet\n"));

        //
        // Restore the original DataBuffer in the SRB
        //
        if (originalDataBuffer != NULL) {
            srb->DataBuffer = originalDataBuffer;
        }

        status = STATUS_INSUFFICIENT_RESOURCES;

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        goto iSpSendScsiCommandExit;
    }

    RtlZeroMemory(iScsiScsiCommand, packetSize);

    iScsiScsiCommand->OpCode = ISCSIOP_SCSI_COMMAND;

    if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {
        iScsiScsiCommand->Read = SETBITON;  
    } 

    if (writeToDevice == TRUE) {

        SetUlongInArray((iScsiScsiCommand->Length),
                        (srb->DataTransferLength));

        SetUlongInArray((iScsiScsiCommand->ExpDataXferLength),
                        (srb->DataTransferLength));

        //
        // Issue : nramas : 01/02/2001
        //    This should be later changed to chained MDLs
        //
        RtlCopyMemory((iScsiScsiCommand + 1),
                      (srb->DataBuffer),
                      srb->DataTransferLength);
    }

    if (expectedDataLen != 0) {
        SetUlongInArray((iScsiScsiCommand->ExpDataXferLength),
                        expectedDataLen);
    }

    SetUlongInArray((iScsiScsiCommand->CmdRN),
                    (iScsiConnection->CommandRefNum));

    SetUlongInArray((iScsiScsiCommand->ExpStatRN),
                    (iScsiConnection->CurrentStatusRefNum));

    //DebugPrint((3, "Exp StatRN : 0x%x\n", 
    //          (iScsiConnection->ExpStatusRefNum)));

    SetUlongInArray((iScsiScsiCommand->TaskTag),
                    (iScsiConnection->InitiatorTaskTag));

    ASSERT((srb->CdbLength) <= 16);

    DebugPrint((3, "CDB : "));
    for (inx = 0; inx < (srb->CdbLength); inx++) {
        DebugPrint((3, "0x%02x ", srb->Cdb[inx]));
    }
    DebugPrint((3, "\n"));

    RtlCopyMemory((iScsiScsiCommand->Cdb),
                  (srb->Cdb),
                  (srb->CdbLength));

    cmdRN = (iScsiConnection->CommandRefNum); 
    inx = cmdRN % (iScsiConnection->MaxPendingRequests);
    if (inx == 0) {
        inx = (iScsiConnection->MaxPendingRequests);
    }
    
    DebugPrint((3, "Request will be added to slot %d\n",
                inx));

    currentRequest = &(iScsiConnection->ActiveClientRequests[inx]);

    ASSERT((currentRequest->InUse) == FALSE);

    currentRequest->CommandRefNum = iScsiConnection->CommandRefNum;

    currentRequest->Irp = Irp;

    currentRequest->DeviceObject = DeviceObject;

    currentRequest->TaskTag = iScsiConnection->InitiatorTaskTag;

    if (originalDataBuffer != NULL) {
        currentRequest->OriginalDataBuffer = originalDataBuffer;
    }

    currentRequest->RequestBuffer = srb->DataBuffer;

    currentRequest->RequestBufferOffset = 0;

    currentRequest->InUse = TRUE;

    currentRequest->Completed = FALSE;

    (iScsiConnection->InitiatorTaskTag)++;
    if ((iScsiConnection->InitiatorTaskTag) == 0) {
        iScsiConnection->InitiatorTaskTag = 1;
    }

    (iScsiConnection->CommandRefNum)++;

    (iScsiConnection->NumberOfReqsInProgress)++;

    DebugPrint((3, "Number of requests in progress %d\n",
                (iScsiConnection->NumberOfReqsInProgress)));

    DebugPrint((3, 
                "CmdRN %d. PacketSize %d, Expected Xfer Length %d\n",
                cmdRN, packetSize, expectedDataLen));

    DebugPrint((3, "SCSI packet : %x\n", iScsiScsiCommand));
    status = iSpSendData(iScsiConnection->ConnectionDeviceObject,
                         iScsiConnection->ConnectionFileObject,
                         iScsiScsiCommand,
                         packetSize,
                         &bytesSent);

    if (NT_SUCCESS(status)) {

        //
        // Command packet successfully sent. Mark the IRP pending,
        // and return STATUS_PENDING
        //
        IoMarkIrpPending(Irp);

        status = STATUS_PENDING;

    } else {
        DebugPrint((0, "Failed to send SCSI Command. Status : 0x%08x\n",
                    status));

        if (currentRequest->OriginalDataBuffer) {
            srb->DataBuffer = currentRequest->OriginalDataBuffer;
        }

        (iScsiConnection->InitiatorTaskTag)--;
        (iScsiConnection->CommandRefNum)--;
        (iScsiConnection->NumberOfReqsInProgress)--;

        RtlZeroMemory(currentRequest, sizeof(ACTIVE_REQUESTS));

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
 
iSpSendScsiCommandExit:

    KeReleaseSpinLock(&(iScsiConnection->RequestLock), 
                      oldIrql);

    return status;
}


NTSTATUS
iSpProcessScsiResponse(
    PISCSI_CONNECTION IScsiConnection,
    PISCSI_SCSI_RESPONSE IScsiScsiResponse
    )
{
    PISCSI_PDO_EXTENSION pdoExtension;
    PCOMMON_EXTENSION commonExtension; 
    PIO_STACK_LOCATION irpStack; 
    PSCSI_REQUEST_BLOCK srb;
    PIRP  irp;
    PDEVICE_OBJECT deviceObject;
    PACTIVE_REQUESTS currentRequest;
    ULONG inx;
    ULONG taskTag;
    ULONG cmdStatus;
    ULONG iScsiStatus;
    ULONG statusRN;
    ULONG length;
    ULONG expCmdRefNum;
    NTSTATUS status;

    ASSERT((IScsiScsiResponse->OpCode) == ISCSIOP_SCSI_RESPONSE);

    ASSERT(IScsiConnection->Type == ISCSI_CONNECTION_TYPE);

    currentRequest = IScsiConnection->CurrentRequest;

    GetUlongFromArray((IScsiScsiResponse->TaskTag),
                      taskTag);

    GetUlongFromArray((IScsiScsiResponse->StatusRN),
                      statusRN);

    IScsiConnection->CurrentStatusRefNum = statusRN;

    DebugPrint((3, "iSpProcessScsiResponse - TaskTag 0x%08x\n",
                taskTag));

    (IScsiConnection->NumberOfReqsInProgress)--;

    commonExtension = 
        (currentRequest->DeviceObject)->DeviceExtension;
        
    pdoExtension = (PISCSI_PDO_EXTENSION) commonExtension;

    irp = currentRequest->Irp;
    deviceObject = currentRequest->DeviceObject;
    irpStack = IoGetCurrentIrpStackLocation(irp);
    srb = irpStack->Parameters.Scsi.Srb;

    cmdStatus = IScsiScsiResponse->CmdStatus;
    iScsiStatus = IScsiScsiResponse->iSCSIStatus;

    GetUlongFromArray((IScsiScsiResponse->ExpCmdRN),
                      (expCmdRefNum));

    GetUlongFromArray((IScsiScsiResponse->MaxCmdRN),
                      (IScsiConnection->MaxCommandRefNum));

    DebugPrint((3, 
                "SCSI Response : Expected CmdRefNum %d, MaxCmdRN  %d\n",
                expCmdRefNum,
                (IScsiConnection->MaxCommandRefNum)));

    //
    // Retrieve the size of immediate data
    //
    GetUlongFromArray((IScsiScsiResponse->Length),
                      length);

    if (cmdStatus == SCSISTAT_GOOD) {

        ASSERT(iScsiStatus == ISCSISTAT_GOOD);

        irp->IoStatus.Status = STATUS_SUCCESS;

        if ((srb->SrbFlags) & SRB_FLAGS_DATA_IN) {

            //
            // Read request. Fill the number of bytes read
            //
            irp->IoStatus.Information = currentRequest->ReceivedDataLength;

            srb->DataTransferLength = currentRequest->ReceivedDataLength;

        } else if ((srb->SrbFlags) & SRB_FLAGS_DATA_OUT) {

            //
            // Write request. Set IoStatus Information to
            // number of bytes written (srb->DataTransferLength)
            //
            irp->IoStatus.Information = srb->DataTransferLength;

        } else {

            //
            // No I/O involved in this request.
            //
            irp->IoStatus.Information = 0;
        }

        srb->SrbStatus = SRB_STATUS_SUCCESS;

        srb->ScsiStatus = SCSISTAT_GOOD;

        DebugPrint((3, "Info : 0x%x\n", irp->IoStatus.Information));

    } else {

        DebugPrint((0, "Command failed\n"));
     
        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;

        //
        // Should map SRB status error using sense data
        //
        srb->SrbStatus = SRB_STATUS_ERROR;

        //
        // If the upper driver passed a valid senseinfo buffer,
        // and the target sent sense data, copy it to the buffer
        //
        if ((srb->SenseInfoBufferLength) && (length > 0)) {

            ULONG senseInx;

            if (length > (srb->SenseInfoBufferLength)) {
                DebugPrint((0, 
                            "Sense info greater than buffer size. Size %d\n",
                            length));

                length = srb->SenseInfoBufferLength;
            }

            DebugPrint((0, "Command 0x%02x failed. Sense Data : ",
                        srb->Cdb[0]));
            for (senseInx = 0; senseInx < length; senseInx++) {
                DebugPrint((0, "%02x ", currentRequest->SenseData[senseInx]));
            }
            DebugPrint((0, "\n"));

            RtlCopyMemory(srb->SenseInfoBuffer,
                          currentRequest->SenseData,
                          length);

            srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            srb->SenseInfoBufferLength = (UCHAR) length;
        }

        //
        // ISSUE : nramas : 01/15/2001
        //         Need to determine the correct NTSTATUS here
        //
        irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
        irp->IoStatus.Information = 0;

    }

    //
    // Restore the original DataBuffer in the SRB
    //
    if ((currentRequest->OriginalDataBuffer) != NULL) {

        DebugPrint((3, "ProcessResponse : Original DataBuffer - 0x%08x\n",
                    currentRequest->OriginalDataBuffer));

        srb->DataBuffer = currentRequest->OriginalDataBuffer;
    }

    DebugPrint((3, "Irp done : 0x%x\n", irp));

    IoCompleteRequest(irp, IO_NO_INCREMENT);

    RtlZeroMemory(currentRequest, sizeof(ACTIVE_REQUESTS));

    return STATUS_SUCCESS;
}


NTSTATUS
iSpProcessReceivedData(
    IN PISCSI_CONNECTION IScsiConnection,
    IN ULONG BytesIndicated,
    OUT ULONG *BytesTaken,
    IN PVOID DataBuffer
    )
{
    PUCHAR requestBuffer = NULL;
    PISCSI_GENERIC_HEADER iScsiHeader = NULL;
    PISCSI_SCSI_RESPONSE iScsiResponse = NULL;
    PISCSI_SCSI_DATA_READ iScsiDataRead = NULL;
    PACTIVE_REQUESTS currentRequest = NULL;
    ULONG length;
    ULONG receivedDataLen;
    ULONG inx;
    ULONG taskTag;
    ULONG statusRefNum;
    ULONG expCmdRN;
    LONG byteCount;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR opCode;
    KIRQL oldIrql;
   
    //
    // We always take all the data given to us 
    // in this routine. So set BytesTaken to
    // BytesIndicated
    *BytesTaken = BytesIndicated;

    byteCount = (LONG) BytesIndicated;

    DebugPrint((3, "Bytes indicated : %d\n", BytesIndicated));

    //
    // Get the lock to synchronize access to iSCSI
    // Connection structure
    //
    KeAcquireSpinLock(&(IScsiConnection->RequestLock), 
                      &oldIrql);

    while (byteCount > 0) {
        if ((IScsiConnection->ReceiveState) == ReceiveHeader) {

            DebugPrint((3, "Receiving header\n"));

            if ((IScsiConnection->CompleteHeaderReceived)== FALSE) {
                LONG bytesToCopy;
                BOOLEAN headerComplete = FALSE;

                bytesToCopy = sizeof(ISCSI_GENERIC_HEADER) -
                               (IScsiConnection->IScsiPacketOffset);

                DebugPrint((0, "CHR False. ToCopy : %d, Count : %d\n",
                            bytesToCopy, byteCount));

                if (byteCount < bytesToCopy) {
                    bytesToCopy = byteCount;
                } else {
                    headerComplete = TRUE;
                }
                
                RtlCopyMemory((IScsiConnection->IScsiPacket) +
                              (IScsiConnection->IScsiPacketOffset),
                              DataBuffer,
                              bytesToCopy);

                if (headerComplete == FALSE) {

                    DebugPrint((0, "CHR still FALSE\n"));

                    IScsiConnection->IScsiPacketOffset += bytesToCopy;
                    KeReleaseSpinLock(&(IScsiConnection->RequestLock), 
                                      oldIrql);

                    return STATUS_SUCCESS;
                } else {

                    DebugPrint((0, "Header complete\n"));

                    IScsiConnection->IScsiPacketOffset = 0;
                    IScsiConnection->CompleteHeaderReceived = TRUE;

                    byteCount -= bytesToCopy;
                    ASSERT(byteCount >= 0);
                    (PUCHAR) DataBuffer += bytesToCopy;
                }

            } else if (byteCount < sizeof(ISCSI_GENERIC_HEADER)) {
                DebugPrint((0, 
                            "Complete header NOT received. Count : %d\n",
                            byteCount));

                IScsiConnection->CompleteHeaderReceived = FALSE;

                RtlCopyMemory((IScsiConnection->IScsiPacket),
                              DataBuffer,
                              byteCount);

                IScsiConnection->IScsiPacketOffset = byteCount;

                KeReleaseSpinLock(&(IScsiConnection->RequestLock), 
                                  oldIrql);

                return STATUS_SUCCESS;
            } else {
                RtlCopyMemory((IScsiConnection->IScsiPacket),
                              DataBuffer,
                              sizeof(ISCSI_GENERIC_HEADER));

                byteCount -= sizeof(ISCSI_GENERIC_HEADER);
                ASSERT(byteCount >= 0);
                (PUCHAR) DataBuffer += sizeof(ISCSI_GENERIC_HEADER);
            }

            //
            // At this point, we should have the complete header
            // available
            //
            iScsiHeader = 
                (PISCSI_GENERIC_HEADER) (IScsiConnection->IScsiPacket);

            opCode = iScsiHeader->OpCode;

            //
            // Retrieve the length of immediate data
            // associated with this iSCSI packet
            //
            GetUlongFromArray((iScsiHeader->Length),
                              length);

            DebugPrint((3, "Opcode : %x, Length : %x\n",
                        opCode, length));

            switch (opCode) {
                case ISCSIOP_SCSI_DATA_READ: {
                    iScsiDataRead = (PISCSI_SCSI_DATA_READ) iScsiHeader;

                    GetUlongFromArray((iScsiDataRead->InitiatorTransferTag),
                                      taskTag);

                    DebugPrint((3, "XfrTag - 0x%08x\n", taskTag));

                    if ((IScsiConnection->CurrentRequest) == NULL) {

                        inx = iSpGetActiveClientRequestIndex(
                                        IScsiConnection,
                                        taskTag);

                        DebugPrint((3, "ActiveClientRequest index : %d\n", inx));

                        ASSERT((inx <= (IScsiConnection->MaxPendingRequests)));

                        currentRequest = &(IScsiConnection->ActiveClientRequests[inx]);

                        IScsiConnection->CurrentRequest = currentRequest;

                    } else {
                        DebugPrint((0, "CurrentRequest not null in data\n"));
                        currentRequest = IScsiConnection->CurrentRequest;
                    }

                    currentRequest->CommandStatus = iScsiDataRead->CommandStatus;

                    //
                    // If the command status is not SCSISTAT_GOOD, use
                    // SenseData buffer to read the sense info. Else, use
                    // RequestBuffer to read input data
                    //
                    if ((iScsiDataRead->CommandStatus) != SCSISTAT_GOOD) {
                        DebugPrint((0, "Command status is %x\n",
                                    iScsiDataRead->CommandStatus));
                        requestBuffer = currentRequest->SenseData;
                    } else {
                        requestBuffer = currentRequest->RequestBuffer;
                    }

                    //
                    // If immediate data is available, copy that
                    //
                    if (length != 0) {
                        ULONG receivedDataLen;

                        IScsiConnection->ReceiveState = ReceiveData;

                        if ((LONG)length <= byteCount ) {
                            receivedDataLen = length;
                        } else {
                            receivedDataLen = byteCount;
                        }

                        if ((iScsiDataRead->CommandStatus) != SCSISTAT_GOOD) {
                            ASSERT(receivedDataLen <= sizeof(currentRequest->SenseData));
                        }

                        RtlCopyMemory(requestBuffer,
                                      DataBuffer,
                                      receivedDataLen);

                        (PUCHAR) DataBuffer += receivedDataLen;
                        byteCount -= receivedDataLen;
                        ASSERT(byteCount >= 0);

                        if (byteCount != 0) {
                            DebugPrint((1, "More bytes available\n"));
                        }

                        currentRequest->ExpectedDataLength = length;

                        currentRequest->RequestBufferOffset = receivedDataLen;

                        currentRequest->ReceivedDataLength = receivedDataLen;

                        if ((currentRequest->ExpectedDataLength) ==
                            currentRequest->ReceivedDataLength) {
                            IScsiConnection->ReceiveState = ReceiveHeader;
                        }
                    } 

                    break;
                }

                case ISCSIOP_SCSI_RESPONSE: {
                    BOOLEAN responseComplete = FALSE;

                    iScsiResponse = (PISCSI_SCSI_RESPONSE) iScsiHeader;

                    IScsiConnection->ReceiveState = ReceiveHeader;

                    GetUlongFromArray((iScsiResponse->TaskTag),
                                      taskTag);

                    DebugPrint((3, "ResTag - 0x%08x\n", taskTag));

                    if ((IScsiConnection->CurrentRequest) == NULL) {

                        inx = iSpGetActiveClientRequestIndex(
                                        IScsiConnection,
                                        taskTag);

                        DebugPrint((3, "ActiveClientRequest index : %d\n", inx));

                        if (inx > (IScsiConnection->MaxPendingRequests)) {

                            ULONG cmdRN;

                            DebugPrint((0, 
                                        "Tag : %x. Will use cmdRN to search\n",
                                        taskTag));

                            GetUlongFromArray((iScsiResponse->ExpCmdRN),
                                              cmdRN);

                            inx = iSpGetReqIndexUsingCmdRN(IScsiConnection,
                                                           (cmdRN - 1));
                            DebugPrint((0, "Inx returned : 0x%x\n", inx));
                        }

                        ASSERT((inx <= (IScsiConnection->MaxPendingRequests)));

                        currentRequest = &(IScsiConnection->ActiveClientRequests[inx]);

                        IScsiConnection->CurrentRequest = currentRequest;

                    } else {
                        currentRequest = IScsiConnection->CurrentRequest;
                    }

                    currentRequest->CommandStatus = iScsiResponse->CmdStatus;

                    if ((iScsiResponse->CmdStatus) != SCSISTAT_GOOD) {
                        DebugPrint((0, "Command status is %x. Length : %d\n",
                                    iScsiResponse->CmdStatus,
                                    length));
                        requestBuffer = currentRequest->SenseData;
                    } else {
                        requestBuffer = currentRequest->RequestBuffer;
                    }

                    if (length != 0) {
                        ULONG receivedDataLen;

                        DebugPrint((3, "Non-zero length in response : %d\n",
                                    length));
                        IScsiConnection->ReceiveState = ReceiveData;

                        if ((LONG)length <= byteCount ) {
                            receivedDataLen = length;
                        } else {
                            receivedDataLen = byteCount;
                        }

                        if ((iScsiResponse->CmdStatus) != SCSISTAT_GOOD) { 
                            ASSERT(receivedDataLen <= sizeof(currentRequest->SenseData));
                        }

                        RtlCopyMemory(requestBuffer,
                                      DataBuffer,
                                      receivedDataLen);

                        (PUCHAR) DataBuffer += receivedDataLen;
                        byteCount -= receivedDataLen;
                        ASSERT(byteCount >= 0);

                        currentRequest->ExpectedDataLength = length;

                        currentRequest->RequestBufferOffset = receivedDataLen;

                        currentRequest->ReceivedDataLength = receivedDataLen;

                        if ((currentRequest->ExpectedDataLength) ==
                            currentRequest->ReceivedDataLength) {
                            IScsiConnection->ReceiveState = ReceiveHeader;

                            responseComplete = TRUE;
                            DebugPrint((3, "Response complete. Will process it\n"));
                        }
                    } else {
                        responseComplete = TRUE;
                    }

                    //
                    // Should use this field to determine
                    // Data Overrun\Underrun cases
                    //
                    if ((iScsiResponse->OverFlow) ||
                        (iScsiResponse->UnderFlow)) {
                        ULONG residualCount;

                        GetUlongFromArray((iScsiResponse->ResidualCount),
                                          residualCount);
                        DebugPrint((0, "Residualcount is : %d\n",
                                    residualCount));
                    }

                    if (responseComplete == TRUE) {

                        if ((iScsiResponse->CmdStatus) != SCSISTAT_GOOD) {

                            PUCHAR resBuff = 
                                (PUCHAR) (IScsiConnection->IScsiPacket);
                            ULONG inx0, inx1;
                            ULONG sizeRequired = sizeof(ISCSI_SCSI_RESPONSE);

                            DebugPrint((1, "\n Beginning Of Data\n"));
                            
                            inx0 = 0;
                            
                            while (inx0 < sizeRequired) {
                            
                                inx1 = 0;
                            
                                DebugPrint((1, "\t"));
                            
                                while ((inx1 < 4) && ((inx0+inx1) < sizeRequired)) {
                            
                                    DebugPrint((1, "%02x ",
                                                resBuff[inx0+inx1]));
                            
                                    inx1++;
                            
                                }
                            
                                DebugPrint((1, "\n"));
                            
                                inx0 += 4;
                            }
                            
                            DebugPrint((1, " End Of Data\n"));   

                        }

                        iSpProcessScsiResponse(
                            IScsiConnection,
                            (PISCSI_SCSI_RESPONSE)(IScsiConnection->IScsiPacket));

                        IScsiConnection->CurrentRequest = NULL;
                    }

                    break;
                }

                case ISCSIOP_NOP_IN_MESSAGE: {

                    PISCSI_NOP_IN iScsiNopIn = (PISCSI_NOP_IN) iScsiHeader;

                    IScsiConnection->ReceiveState = ReceiveHeader;

                    if (iScsiNopIn->Poll) {

                        //
                        // Need to handle this case. Should send
                        // response to the target
                        //
                        DebugPrint((0, "Target expects NOP OUT message\n"));
                    } else {
                        DebugPrint((1, "No NOP OUT message needed.\n"));
                    }

                    break;
                }

                default: {
                    ULONG inx0, inx1;

                    //
                    // Opcode that we don't currently handle.
                    // For the timebeing, just dump the iSCSI 
                    // packet.
                    //
                    DebugPrint((0, "Unknown opcode : 0x%02x\n", opCode));

                    inx0 = 0;
                    while(inx0 < 48) {
                        inx1 = 0;
                        DebugPrint((0, "\t"));
                        while ((inx1 < 4) &&
                               ((inx0+inx1) < 48)) {
                            DebugPrint((0, "0x%02x ", 
                                        ((PUCHAR)(iScsiHeader))[inx0+inx1]));
                            inx1++;
                        }
                        DebugPrint((0, "\n"));

                        inx0 += 4;
                    }
                    DebugPrint((0, "\n"));

                    break;
                }
            } // switch (opCode) 

        } else {
            ULONG bytesToCopy;
            UCHAR opCode;

            //
            // We are receiving the data portion of the packet
            //
            ASSERT((IScsiConnection->ReceiveState) == ReceiveData);

            ASSERT(IScsiConnection->CurrentRequest);

            DebugPrint((3, "Receiving data\n"));

            currentRequest = IScsiConnection->CurrentRequest;

            if ((currentRequest->CommandStatus) != SCSISTAT_GOOD) {
                requestBuffer = currentRequest->SenseData;
            } else {
                requestBuffer = currentRequest->RequestBuffer;
            }

            requestBuffer += currentRequest->RequestBufferOffset;

            bytesToCopy = ((currentRequest->ExpectedDataLength) -
                           (currentRequest->ReceivedDataLength));
            if ((LONG)bytesToCopy > byteCount)  {
                bytesToCopy = byteCount;
            } else {
                DebugPrint((3, "More bytes in current buffer than expected\n"));
            }

            RtlCopyMemory(requestBuffer, DataBuffer, bytesToCopy);
            byteCount -= bytesToCopy;
            (PUCHAR) DataBuffer += bytesToCopy;
            ASSERT(byteCount >= 0);

            currentRequest->RequestBufferOffset +=  bytesToCopy;

            currentRequest->ReceivedDataLength += bytesToCopy;

            if ((currentRequest->ExpectedDataLength) ==
                currentRequest->ReceivedDataLength) {

                DebugPrint((3, "Got all data. Bytes left %d\n", 
                            byteCount));

                IScsiConnection->ReceiveState = ReceiveHeader;

                opCode = IScsiConnection->IScsiPacket[0];
                if (opCode == ISCSIOP_SCSI_RESPONSE) {

                    DebugPrint((3, "Will process the response\n"));

                    iSpProcessScsiResponse(
                        IScsiConnection,
                        (PISCSI_SCSI_RESPONSE)(IScsiConnection->IScsiPacket));

                    IScsiConnection->CurrentRequest = NULL;
                }
            }
        }
    }

    KeReleaseSpinLock(&(IScsiConnection->RequestLock), 
                      oldIrql);

    return status;
}


ULONG
iSpGetActiveClientRequestIndex(
    PISCSI_CONNECTION IScsiConnection,
    ULONG TaskTag
    )
{
    ULONG retIndex = ~0;
    ULONG inx;

    DebugPrint((3, "Given Task Tag : 0x%08x\n", TaskTag));

    for (inx = 1; inx <= (IScsiConnection->MaxPendingRequests); inx++) {
        DebugPrint((3, "Index %d : CmdRN - 0x%08x\n",
                    inx, 
                    ((IScsiConnection->ActiveClientRequests[inx]).TaskTag)));

        if (((IScsiConnection->ActiveClientRequests[inx]).TaskTag)
            == TaskTag) {

            retIndex = inx;

            DebugPrint((1, "inx : 0x%04x\n", retIndex));

            break;
        }
    }

    if (retIndex > (IScsiConnection->MaxPendingRequests)) {
        DebugPrint((0, "Tag : Did not find the request for this response\n"));
    }

    return retIndex;
}



ULONG
iSpGetReqIndexUsingCmdRN(
    PISCSI_CONNECTION IScsiConnection,
    ULONG CmdRN
    )
{
    ULONG retIndex = ~0;
    ULONG inx;

    DebugPrint((3, "Given CmdRN : 0x%08x\n", CmdRN));

    for (inx = 1; inx <= (IScsiConnection->MaxPendingRequests); inx++) {

        if (((IScsiConnection->ActiveClientRequests[inx]).CommandRefNum)
            == CmdRN) {

            retIndex = inx;

            DebugPrint((1, "inx : 0x%04x\n", retIndex));

            break;
        }
    }

    if (retIndex > (IScsiConnection->MaxPendingRequests)) {
        ASSERTMSG("CmdRN : Did not find the request for this response\n", 
                  FALSE);
    }

    return retIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\wmi.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    wmi.c

Abstract:

    This module contains the WMI support code 

Environment:

    Kernel mode only.

Revision History:

--*/

#include "port.h"


NTSTATUS
iScsiPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\port.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    port.c

Abstract:

    This file contains code iSCSI Port driver

Environment:

    kernel mode only

Revision History:

--*/
#include "iscsi.h"

#if DBG

#define ISCSI_DEBUG_BUFF_LEN 128
ULONG DebugLevel = 0x00;
UCHAR iScsiDebugBuff[ISCSI_DEBUG_BUFF_LEN];
VOID
iScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for iScsiPort
    
Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None    
--*/
{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel) {
        _vsnprintf(iScsiDebugBuff, ISCSI_DEBUG_BUFF_LEN,
                   DebugMessage, ap);
        DbgPrint(iScsiDebugBuff);
    }

    va_end(ap);
}

#else

VOID
iScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\inc\iscsi.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    iscsi.h

Abstract:

    This file contains iSCSI protocol related data structures.

Revision History:

--*/

#ifndef _ISCSI_H_
#define _ISCSI_H_

#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"

#include "ntddk.h"
#include "scsi.h"
#include "tdi.h"
#include "tdikrnl.h"

#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddstor.h>
#include <ntddtcp.h>

#include "wmistr.h"

#include "wdmguid.h"
#include "devguid.h"

//
// MACRO to delay the thread execution. The parameter
// gives the number of seconds to wait
//
#define DelayThreadExecution(x) {                       \
                                                        \
             LARGE_INTEGER delayTime;                   \
             delayTime.QuadPart = -10000000L * x;       \
             KeDelayExecutionThread( KernelMode,        \
                                     FALSE,             \
                                     &delayTime);       \
        }
                           
#define IsEqual4Byte(a, b)   ((*((PUCHAR) a)) == (*((PUCHAR) b)) && \
                              (*((PUCHAR) a + 1)) == (*((PUCHAR) b + 1)) && \
                              (*((PUCHAR) a + 2)) == (*((PUCHAR) b + 2)) && \
                              (*((PUCHAR) a + 3)) == (*((PUCHAR) b + 3))
                              
#define IsEqual2Byte(a, b)   ((*((PUCHAR) a)) == (*((PUCHAR) b)) && \
                              (*((PUCHAR) a + 1)) == (*((PUCHAR) b + 1)) 
                       
#define CopyFourBytes(a, b)  ((*((PUCHAR) a) = (*((PUCHAR) b))));          \
                             ((*((PUCHAR) a + 1) = (*((PUCHAR) b + 1))));  \
                             ((*((PUCHAR) a + 2) = (*((PUCHAR) b + 2))));  \
                             ((*((PUCHAR) a + 3) = (*((PUCHAR) b + 3)))); 
                             
#define GetUlongFromArray(UCharArray, ULongValue)     \
         ULongValue = 0;                              \
         ULongValue |= ((PUCHAR)UCharArray)[0];       \
         ULongValue <<= 8;                            \
         ULongValue |= ((PUCHAR)UCharArray)[1];       \
         ULongValue <<= 8;                            \
         ULongValue |= ((PUCHAR)UCharArray)[2];       \
         ULongValue <<= 8;                            \
         ULongValue |= ((PUCHAR)UCharArray)[3]; 
         
#define SetUlongInArray(UCharArray, ULongValue)                                 \
         ((PUCHAR) UCharArray)[0] = (UCHAR) ((ULongValue & 0xFF000000) >> 24);  \
         ((PUCHAR) UCharArray)[1] = (UCHAR) ((ULongValue & 0x00FF0000) >> 16);  \
         ((PUCHAR) UCharArray)[2] = (UCHAR) ((ULongValue & 0x0000FF00) >> 8);   \
         ((PUCHAR) UCharArray)[3] = (UCHAR) (ULongValue & 0x000000FF);
  
//
// CDB Command Group Code
//
#define COMMAND_GROUP_0   0
#define COMMAND_GROUP_1   1
#define COMMAND_GROUP_2   2
#define COMMAND_GROUP_5   5
 
//
// Maximum number of targets supported by the Initiator
//
#define MAX_TARGETS_SUPPORTED  8

//
// ISCSI Target Port Number
//
#define ISCSI_TARGET_PORT 5003L

//
// iSCSI Packet Operation Codes
//
#define ISCSIOP_NOP_OUT_MESSAGE           0x00
#define ISCSIOP_SCSI_COMMAND              0x01
#define ISCSIOP_SCSI_MGMT_COMMAND         0x02
#define ISCSIOP_LOGIN_COMMAND             0x03
#define ISCSIOP_TEXT_COMMAND              0x04
#define ISCSIOP_SCSI_DATA_WRITE           0x05
#define ISCSIOP_PING_COMMAND              0x09
#define ISCSIOP_MAP_COMMAND               0x0A
#define ISCSIOP_NOP_IN_MESSAGE            0x40
#define ISCSIOP_SCSI_RESPONSE             0x41
#define ISCSIOP_SCSI_MGMT_RESPONSE        0x42
#define ISCSIOP_LOGIN_RESPONSE            0x43
#define ISCSIOP_TEXT_RESPONSE             0x44
#define ISCSIOP_SCSI_DATA_READ            0x45
#define ISCSIOP_RTT                       0x46
#define ISCSIOP_ASYCN_EVENT               0x47
#define ISCSIOP_UNKNOWN_OPCODE            0x48
#define ISCSIOP_PING_RESPONSE             0x49
#define ISCSIOP_MAP_RESPONSE              0x4A

//
// iSCSI Operation Code Mask
//
#define ISCSI_RETRY_COMMAND_RESPONSE      0xB7
#define ISCSI_RESPONSE                    0xB6

//
// Maximum and minimum values of iSCSI Opcode
//
#define ISCSI_MASK_MAX_OPCODE             0xB5
#define ISCSI_MASK_MIN_OPCODE             0x00
 
//
// Task Attribute field (ATTR) in SCSI Command Packet
//
#define ISCSI_TASKATTR_UNTAGGED           0x00
#define ISCSI_TASKATTR_SIMPLE             0x01
#define ISCSI_TASKATTR_ORDERED            0x02
#define ISCSI_TASKATTR_HEADOFQUEUE        0x03
#define ISCSI_TASKATTR_ACA                0x04

//
// ISCSI Status
//
#define ISCSISTAT_GOOD              0x00
#define ISCSISTAT_CHECK_CONDITION   0x01 

//
// Login Type
//
#define ISCSI_LOGINTYPE_NONE              0x00  // No authentication
#define ISCSI_LOGINTYPE_IMPLICIT          0x01
#define ISCSI_LOGINTYPE_PW_ATHENTICATION  0x02  // Clear text password authentication
#define ISCSI_LOGINTYPE_RSA_1_WAY         0x03
#define ISCSI_LOGINTYPE_RSA_2_WAY         0x04

//
// Login Status
//
#define ISCSI_LOGINSTATUS_ACCEPT          0x00
#define ISCSI_LOGINSTATUS_REJECT          0x01
#define ISCSI_LOGINSTATUS_AUTH_REQ        0x02
#define ISCSI_LOGINSTATUS_REJ_REC         0x03


//
// Forward declarations
//

typedef struct _ISCSI_LOGIN_COMMAND ISCSI_LOGIN_COMMAND, *PISCSI_LOGIN_COMMAND;
typedef struct _ISCSI_LOGIN_RESPONSE ISCSI_LOGIN_RESPONSE, *PISCSI_LOGIN_RESPONSE;
typedef struct _ISCSI_SCSI_COMMAND ISCSI_SCSI_COMMAND, *PISCSI_SCSI_COMMAND;
typedef struct _ISCSI_SCSI_RESPONSE ISCSI_SCSI_RESPONSE, *PISCSI_SCSI_RESPONSE;
typedef struct _ISCSI_GENERIC_HEADER ISCSI_GENERIC_HEADER, *PISCSI_GENERIC_HEADER;
typedef struct _ISCSI_SCSI_DATA_READ ISCSI_SCSI_DATA_READ, *PISCSI_SCSI_DATA_READ;
typedef struct _ISCSI_NOP_IN ISCSI_NOP_IN, *PISCSI_NOP_IN;
typedef struct _ISCSI_NOP_OUT ISCSI_NOP_OUT, *PISCSI_NOP_OUT;

//
// iSCSI message\response header
//

typedef union _ISCSI_HEADER {

    //
    // Generic 48-Byte Header
    //
    struct _ISCSI_GENERIC_HEADER {
        UCHAR OpCode;
        UCHAR OpCodeSpecificFields1[3];
        UCHAR Length[4];
        UCHAR OpCodeSpecificFields2[8];
        UCHAR InitiatorTaskTag[4];
        UCHAR OpCodeSpecificFields3[28];
    } ISCSI_GENERIC_HEADER, *PISCSI_GENERIC_HEADER;

    //
    // iSCSI Login command
    //
    struct _ISCSI_LOGIN_COMMAND {
        UCHAR OpCode;        // 0x03 - ISCSIOP_LOGIN_COMMAND
        UCHAR LoginType;
        UCHAR Reserved1[2];
        UCHAR Length[4];
        UCHAR ConnectionID[2];
        UCHAR RecoveredConnectionID[2];
        UCHAR Reserved2[4];
        UCHAR ISID[2];
        UCHAR TSID[2];
        UCHAR Reserved3[4];
        UCHAR InitCmdRN[4];
        UCHAR Reserved4[20];
    } ISCSI_LOGIN_COMMAND, *PISCSI_LOGIN_COMMAND;

    //
    // iSCSI Login response
    //
    struct _ISCSI_LOGIN_RESPONSE {
        UCHAR OpCode;       // 0x43 - ISCSIOP_LOGIN_RESPONSE
        UCHAR Reserved1[3];
        UCHAR Length[4];
        UCHAR Reserved2[8];
        UCHAR ISID[2];
        UCHAR TSID[2];
        UCHAR Reserved3[4];
        UCHAR InitStatRN[4];
        UCHAR ExpCmdRN[4];
        UCHAR MaxCmdRN[4];
        UCHAR Status;
        UCHAR Reserved4[3];
        UCHAR Reserved5[8];
    } ISCSI_LOGIN_RESPONSE, *PISCSI_LOGIN_RESPONSE;

    //
    // iSCSI SCSI Command
    //
    struct _ISCSI_SCSI_COMMAND {
        UCHAR OpCode;       // 0x01 - ISCSIOP_SCSI_COMMAND
        UCHAR Reserved1 : 5;
        UCHAR Read : 1;
        UCHAR ImmediateData : 2;
        UCHAR ATTR : 3;
        UCHAR Reserved2 : 4;
        UCHAR TurnOffAutoSense : 1;
        UCHAR Reserved3;
        UCHAR Length[4];
        UCHAR LogicalUnitNumber[8];
        UCHAR TaskTag[4];
        UCHAR ExpDataXferLength[4];
        UCHAR CmdRN[4];
        UCHAR ExpStatRN[4];
        UCHAR Cdb[16];
    } ISCSI_SCSI_COMMAND, *PISCSI_SCSI_COMMAND;

    //
    // iSCSI SCSI Response
    //
    struct _ISCSI_SCSI_RESPONSE {
        UCHAR OpCode;       // 0x41 - ISCSIOP_SCSI_RESPONSE
        UCHAR Reserved1 : 6;
        UCHAR OverFlow : 1;
        UCHAR UnderFlow : 1;
        UCHAR Reserved2[2];
        UCHAR Length[4];
        UCHAR Reserved3[8];
        UCHAR TaskTag[4];
        UCHAR ResidualCount[4];
        UCHAR StatusRN[4];
        UCHAR ExpCmdRN[4];
        UCHAR MaxCmdRN[4];
        UCHAR CmdStatus;
        UCHAR iSCSIStatus;
        UCHAR Reserved4[2];
        UCHAR ResponseLength[2];
        UCHAR SenseDataLength[2];
        UCHAR Reserved5[4];
    } ISCSI_SCSI_RESPONSE, *PISCSI_SCSI_RESPONSE;

    //
    // iSCSSI SCSI Data (WRITE - Initiator to Target)
    //
    struct _ISCSI_SCSI_DATA_WRITE {
        UCHAR OpCode;               // 0x05 - ISCSIOP_SCSI_DATA_WRITE
        UCHAR Reserved1[3];
        UCHAR Length[4];
        UCHAR BufferOffset[4];
        UCHAR TransferTag[4];
        UCHAR InitiatorTransferTag[4];
        UCHAR Reserved2[8];
        UCHAR CmdRN[4];
        UCHAR ExpStatRN[4];
        UCHAR Reserved[12];
    } ISCSI_SCSI_DATA_WRITE, *PISCSI_SCSI_DATA_WRITE;

    //
    // iSCSSI SCSI Data (READ - Target to Initiator)
    //
    struct _ISCSI_SCSI_DATA_READ {
        UCHAR OpCode;               // 0x45 - ISCSIOP_SCSI_DATA_READ
        UCHAR UnderFlow : 1;
        UCHAR OverFlow : 1;
        UCHAR IsScsiStatus : 1;
        UCHAR Reserved1 : 5;
        UCHAR Reserved2[2];
        UCHAR Length[4];
        UCHAR BufferOffset[4];
        UCHAR TransferTag[4];
        UCHAR InitiatorTransferTag[4];
        UCHAR ResidualCount[4];
        UCHAR StatusRN[4];
        UCHAR ExpCmdRN[4];
        UCHAR MaxCmdRN[4];
        UCHAR CommandStatus;
        UCHAR ISCSIStatus;
        UCHAR Reserved3[2];
        UCHAR Reserved4[8];
    } ISCSI_SCSI_DATA_READ, *PISCSI_SCSI_DATA_READ;

    //
    // iSCSI NOP-IN
    //
    struct _ISCSI_NOP_IN {
        UCHAR OpCode;              // 0x40 - ISCSIOP_NOP_IN_MESSAGE
        UCHAR Reserved1 : 7;
        UCHAR Poll : 1;
        UCHAR Reserved2[2];
        UCHAR Length[4];
        UCHAR Reserved3[20];
        UCHAR ExpCmdRN[4];
        UCHAR MaxCmdRN[4];
        UCHAR Reserved4[12];
    } ISCSI_NOP_IN, *PISCSI_NOP_IN;

    //
    // iSCSI NOP-OUT
    //
    struct _ISCSI_NOP_OUT {
        UCHAR OpCode;              // 0x00 - ISCSIOP_NOP_OUT_MESSAGE
        UCHAR Reserved1 : 7;
        UCHAR Poll : 1;
        UCHAR Reserved2[2];
        UCHAR Length[4];
        UCHAR Reserved3[20];
        UCHAR ExpStatRN[4];
        UCHAR Reserved4[16];
    } ISCSI_NOP_OUT, *PISCSI_NOP_OUT;

} ISCSI_HEADER, *PISCSI_HEADER;


#endif // _ISCSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\power.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    power.c

Abstract:

    This file contains the routines for power support

Environment:

    Kernel mode only

Revision History:

--*/

#include "port.h"


NTSTATUS
iScsiPortPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    DebugPrint((1, "iScsiPortPower : DeviceObject %x, Irp %x\n",
                DeviceObject, Irp));

    switch (irpStack->MinorFunction) {
        case IRP_MN_SET_POWER: {
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        default: {
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(commonExtension->LowerDeviceObject,
                        Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\dispatch.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    dispatch.c

Abstract:

    This file contains code for dispatch routines for iScsiPort

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


PDRIVER_DISPATCH FdoMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];


VOID
iScsiPortInitializeDispatchTables()
{
    ULONG inx;

    //
    // Initialize FDO dispatch table
    //
    for (inx = 0; inx <= IRP_MJ_MAXIMUM_FUNCTION; inx++) {
        FdoMajorFunctionTable[inx] = iScsiPortDispatchUnsupported;
    }

    FdoMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = iScsiPortFdoDeviceControl;
    FdoMajorFunctionTable[IRP_MJ_PNP] = iScsiPortFdoPnp;
    FdoMajorFunctionTable[IRP_MJ_POWER] = iScsiPortPower;
    FdoMajorFunctionTable[IRP_MJ_CREATE] = iScsiPortFdoCreateClose;
    FdoMajorFunctionTable[IRP_MJ_CLOSE] = iScsiPortFdoCreateClose;
    FdoMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = iScsiPortSystemControl;

    return;
}


NTSTATUS
iScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    return (commonExtension->MajorFunction[irpStack->MajorFunction])(DeviceObject,
                                                                     Irp);
}


NTSTATUS
iScsiPortDispatchUnsupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\init.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    init.c

Abstract:

    This file contains the initialization code for iSCSI port driver.

Environment:

    kernel mode only

Revision History:

--*/
#include "port.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif

PEPROCESS iScsiSystemProcess;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*+++

Routine Description:

    Entry point for the driver. 
    
Arguements:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - Registry path for the driver
    
Return Value :

    STATUS_SUCCESS if initialization was successful
    Appropriate NTStatus code on failure 
--*/
{
    NTSTATUS status;
    PISCSIPORT_DRIVER_EXTENSION driverExtension = NULL;

    DebugPrint((3, "iSCSI Port DriverEntry\n"));

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             (PVOID) ISCSI_TAG_DRIVER_EXTENSION,
                                             sizeof(ISCSIPORT_DRIVER_EXTENSION),
                                             &driverExtension);
    if (NT_SUCCESS(status)) {
        RtlZeroMemory(driverExtension, 
                      sizeof(ISCSIPORT_DRIVER_EXTENSION));
        driverExtension->DriverObject = DriverObject;
        driverExtension->RegistryPath.Length = RegistryPath->Length;
        driverExtension->RegistryPath.MaximumLength = 
            RegistryPath->MaximumLength;
        driverExtension->RegistryPath.Buffer = 
            ExAllocatePoolWithTag(PagedPool,
                                  RegistryPath->MaximumLength,
                                  ISCSI_TAG_REGPATH);
        if (driverExtension->RegistryPath.Buffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlCopyUnicodeString(&(driverExtension->RegistryPath),
                             RegistryPath);
    } else if (status == STATUS_OBJECT_NAME_COLLISION) {

        //
        // Extension already exists. Get a pointer to it
        //
        driverExtension = IoGetDriverObjectExtension(
                                   DriverObject,
                                   (PVOID) ISCSI_TAG_DRIVER_EXTENSION);
        ASSERT(driverExtension != NULL);
    } else {
        DebugPrint((1, "iSCSI : Could not allocate driver extension %lx\n",
                    status));
        return status;
    }

    //
    // Update the driver object with the entry points
    //
    DriverObject->MajorFunction[IRP_MJ_SCSI] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = iScsiPortGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = iScsiPortGlobalDispatch;

    DriverObject->DriverUnload = iScsiPortUnload;
    DriverObject->DriverExtension->AddDevice = iScsiPortAddDevice;

    iScsiSystemProcess = IoGetCurrentProcess ();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\internal.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    internal.c

Abstract:

    This file contains internal routines 

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, iScsiPortFdoDeviceControl)
#pragma alloc_text(PAGE, iScsiPortFdoCreateClose)
#endif // ALLOC_PRAGMA

extern PEPROCESS iScsiSystemProcess;


NTSTATUS
iScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION    commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG controlCode;
    ULONG isRemoved;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    controlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    DebugPrint((3, 
                "iSpFdoDeviceControl : DeviceObject %x, ControlCode 0x%08x\n",
                DeviceObject, controlCode));

    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);
    if (isRemoved) {

        iSpReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    switch (controlCode) {
        case IOCTL_ISCSI_SETUP_SERVER: {

            if (commonExtension->IsServerNodeSetup) {
                DebugPrint((1, "Server node already setup\n"));
                status = STATUS_SUCCESS;
            } else {
                iSpAttachProcess(iScsiSystemProcess);
                status = iSpStartNetwork(DeviceObject);
                if (NT_SUCCESS(status)) {
                    commonExtension->IsServerNodeSetup = TRUE;
                }
                iSpDetachProcess();
            }
            break;
        }

        case IOCTL_ISCSI_CLOSE_SERVER: {
            if ((commonExtension->IsServerNodeSetup) == FALSE) {
                DebugPrint((1, "Server node not setup\n"));
                status = STATUS_INVALID_DEVICE_REQUEST;
            } else {
                iSpAttachProcess(iScsiSystemProcess);
                status = iSpStopNetwork(DeviceObject);
                if (NT_SUCCESS(status)) {
                    commonExtension->IsServerNodeSetup = FALSE;
                }
                iSpDetachProcess();
            }

            break;
        }

        default: {
            //
            // Control code that we don't understand. Just pass
            // it to the lower driver
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            iSpReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject,
                                  Irp);
            return status;

            break;
        }
    } // switch (controlCode) 

    iSpReleaseRemoveLock(DeviceObject, Irp);
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
iScsiPortFdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((3, "iScsiPortFdoCreateClose : %s - DeviceObject %x, Irp %x\n",
                ((irpStack->MajorFunction) == IRP_MJ_CREATE) ? "Create" : "Close",
         DeviceObject, Irp));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
iSpSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    KeSetEvent((PKEVENT)Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
iScsiPortClaimDevice(
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN BOOLEAN Release
    )
{
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT             event;
    NTSTATUS           status;
    SCSI_REQUEST_BLOCK srb;

    PAGED_CODE();

    //
    // Clear the SRB fields.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Write length to SRB.
    //

    srb.Length = SCSI_REQUEST_BLOCK_SIZE;

    srb.Function = Release ? SRB_FUNCTION_RELEASE_DEVICE :
        SRB_FUNCTION_CLAIM_DEVICE;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_EXECUTE_NONE,
                                        LowerDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &event,
                                        &ioStatus);

    if (irp == NULL) {
        DebugPrint((1, "ClassClaimDevice: Can't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = &srb;

    //
    // Set up IRP Address.
    //

    srb.OriginalRequest = irp;

    //
    // Call the port driver with the request and wait for it to complete.
    //

    status = IoCallDriver(LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // If this is a release request, then just decrement the reference count
    // and return.  The status does not matter.
    //

    if (Release) {

        // ObDereferenceObject(LowerDeviceObject);
        return STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(srb.DataBuffer != NULL);

    return status;
} // end ClassClaimDevice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\client\utils.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    utils.c

Abstract:

    Utility routines for iScsi Port driver

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


PVOID
iSpAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    PVOID Block;
     
    Block = ExAllocatePoolWithTag(PoolType,
                                  NumberOfBytes,
                                  Tag);
    if (Block != NULL) {
        RtlZeroMemory(Block, NumberOfBytes);
    }

    return Block;
}


NTSTATUS
iSpAllocateMdlAndIrp(
    IN PVOID Buffer,
    IN ULONG BufferLen,
    IN CCHAR StackSize,
    IN BOOLEAN NonPagedPool,
    OUT PIRP *Irp,
    OUT PMDL *Mdl
    )
{
    PMDL localMdl = NULL;
    PIRP localIrp = NULL;
    NTSTATUS status;

    //
    // Allocate an MDL for this request
    //
    localMdl = IoAllocateMdl(Buffer,
                             BufferLen,
                             FALSE,
                             FALSE,
                             NULL);
    if (localMdl == NULL) {
        DebugPrint((1, "iSpAllocateMdlAndIrp : Failed to allocate MDL\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the MDL. If the buffer is from NonPaged pool
    // use MmBuildMdlForNonPagedPool. Else, use MmProbeAndLockPages
    //
    if (NonPagedPool == TRUE) {
        MmBuildMdlForNonPagedPool(localMdl);
    } else {

        try {
            MmProbeAndLockPages(localMdl, KernelMode, IoModifyAccess);
        } except(EXCEPTION_EXECUTE_HANDLER) {

              DebugPrint((1, 
                          "iSpAllocateMdlAndIrp : Failed to Lockpaged\n"));
              IoFreeMdl(localMdl);
              return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Allocate an IRP
    //
    localIrp = IoAllocateIrp(StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((1, "iSpAllocateMdlAndIrp. Failed to allocate IRP\n"));
        IoFreeMdl(localMdl);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DebugPrint((3, "Allocated IRP 0x%08x and MDL 0x%08x\n",
                localIrp, localMdl));

    *Irp = localIrp;
    *Mdl = localMdl;

    return STATUS_SUCCESS;
}


VOID
iSpFreeMdlAndIrp(
    IN PMDL Mdl,
    IN PIRP Irp,
    BOOLEAN UnlockPages
    )
{
    PMDL tmpMdlPtr = NULL;

    if (Irp == NULL) {
        return;
    }

    //
    // Free any MDLs allocated for this IRP
    //
    if (Mdl != NULL) {
        while ((Irp->MdlAddress) != NULL) {
            tmpMdlPtr = (Irp->MdlAddress)->Next;

            if (UnlockPages) {
                MmUnlockPages(Irp->MdlAddress);
            }

            IoFreeMdl(Irp->MdlAddress);
            Irp->MdlAddress = tmpMdlPtr;
        }
    }

    IoFreeIrp(Irp);
}


NTSTATUS
iScsiPortStringArrayToMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    )

/*++

Routine Description:

    This routine will take a null terminated array of ascii strings and merge
    them together into a unicode multi-string block.

    This routine allocates memory for the string buffer - is the caller's
    responsibility to free it.

Arguments:

    MultiString - a UNICODE_STRING structure into which the multi string will
                  be built.

    StringArray - a NULL terminated list of narrow strings which will be combined
                  together.  This list may not be empty.

Return Value:

    status

--*/

{
    ANSI_STRING ansiEntry;

    UNICODE_STRING unicodeEntry;
    PWSTR unicodeLocation;

    UCHAR i;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Make sure we aren't going to leak any memory
    //

    ASSERT(MultiString->Buffer == NULL);

    RtlInitUnicodeString(MultiString, NULL);

    for(i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        MultiString->Length += (USHORT) RtlAnsiStringToUnicodeSize(&ansiEntry);
    }

    ASSERT(MultiString->Length != 0);

    MultiString->MaximumLength = MultiString->Length + sizeof(UNICODE_NULL);

    MultiString->Buffer = iSpAllocatePool(PagedPool,
                                          MultiString->MaximumLength,
                                          ISCSI_TAG_PNP_ID);

    if(MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory(MultiString->Buffer, MultiString->MaximumLength);

    unicodeEntry = *MultiString;

    for(i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        status = RtlAnsiStringToUnicodeString(
                    &unicodeEntry,
                    &ansiEntry,
                    FALSE);

        //
        // Since we're not allocating any memory the only failure possible
        // is if this function is bad
        //

        ASSERT(NT_SUCCESS(status));

        //
        // Push the buffer location up and reduce the maximum count
        //

        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);

    };

    //
    // Stick the final NUL on the end of the multisz
    //

//    RtlZeroMemory(unicodeEntry.Buffer, unicodeEntry.MaximumLength);

    return STATUS_SUCCESS;
}


NTSTATUS
iSpMultiStringToStringArray(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    OUT PWSTR *StringArray[],
    BOOLEAN Forward
    )

{
    ULONG stringCount = 0;
    ULONG stringNumber;
    ULONG i;
    PWSTR *stringArray;

    PAGED_CODE();

    //
    // Pass one: count the number of string elements.
    //

    for(i = 0; i < (MultiString->MaximumLength / sizeof(WCHAR)); i++) {
        if(MultiString->Buffer[i] == UNICODE_NULL) {
            stringCount++;
        }
    }

    //
    // Allocate the memory for a NULL-terminated string array.
    //

    stringArray = iSpAllocatePool(PagedPool,
                                  (stringCount + 1) * sizeof(PWSTR),
                                  ISCSI_TAG_PNP_ID);

    if(stringArray == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(stringArray, (stringCount + 1) * sizeof(PWSTR));

    //
    // Pass two : Put the string pointers in place.
    //

    i = 0;

    for(stringNumber = 0; stringNumber < stringCount; stringNumber++) {

        ULONG arrayNumber;

        if(Forward) {
            arrayNumber = stringNumber;
        } else {
            arrayNumber = stringCount - stringNumber - 1;
        }

        //
        // Put a pointer to the head of the string into the array.
        //

        stringArray[arrayNumber] = &MultiString->Buffer[i];

        //
        // Scan for the end of the string.
        //

        while((i < (MultiString->MaximumLength / sizeof(WCHAR))) &&
              (MultiString->Buffer[i] != UNICODE_NULL)) {
            i++;
        }

        //
        // Jump past the NULL.
        //

        i++;
    }

    *StringArray = stringArray;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\wmi.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    wmi.c

Abstract:

    This module contains the WMI support code 

Environment:

    Kernel mode only.

Revision History:

--*/

#include "port.h"


NTSTATUS
iScsiPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\network.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    network.c

Abstract:

    This file contains TDI support routines.

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

extern HANDLE iSpTdiNotificationHandle;
extern PISCSI_FDO_EXTENSION  iSpGlobalFdoExtension;

ISCSI_EVENT_HANDLER ServerEvents[] = {
    {TDI_EVENT_CONNECT, iSpConnectionHandler},
    {TDI_EVENT_DISCONNECT, iSpDisconnectHandler},
    {TDI_EVENT_RECEIVE, iSpReceiveHandler}
};

NTSTATUS
iSpTdiSendCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpProcessReceivedData(
    IN PISCSI_CONNECTION IScsiConnection,
    IN ULONG BytesIndicated,
    OUT PULONG BytesTaken,
    IN PVOID DataBuffer
    );

NTSTATUS
iSpReceiveCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
iSpStartNetwork(
    IN PDEVICE_OBJECT DeviceObject
    )
/*+++

Routine Description :

    This routine sets up the TDI address for the server to which 
    the clients will connect to.
    
    It also sets up the address for the client. This address will 
    be later used by the client to connect to the server.
    
Arguement :

    DeviceObject
    
Return Value :

    STATUS_SUCCESS if the addresses were setup correctly.
    Appropriate NTStatus code on error.
--*/
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIRP Irp = NULL;
    PISCSI_CONNECTION   iScsiConnection = NULL;
    HANDLE threadHandle = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG countOfEvents;
    ULONG inx;
    OBJECT_ATTRIBUTES ObjAttributes;
    BOOLEAN nodeSetup = FALSE;

    if ((commonExtension->IsServerNodeSetup) == FALSE) {

        //
        // Allocate an IRP to be used in various routines
        //
        if ((Irp = IoAllocateIrp((DeviceObject->StackSize) + 1, FALSE)) == NULL) {
            DebugPrint((0, "Failed to allocate Irp\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DebugPrint((3, "Will setup Server node\n"));
        iScsiConnection = iSpAllocatePool(NonPagedPool,
                                          sizeof(ISCSI_CONNECTION),
                                          ISCSI_TAG_CONNECTION);
        if (iScsiConnection == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto iSpStartNetworkExit;
        }

        RtlZeroMemory(iScsiConnection, sizeof(ISCSI_CONNECTION));

        fdoExtension->ServerNodeInfo = iScsiConnection;

        KeInitializeSemaphore(&(iScsiConnection->RequestSemaphore),
                              0, MAXLONG);

        //
        //  Create the thread in which ISCSI requests
        //  will be processed.
        //
        InitializeObjectAttributes(&ObjAttributes, 
                                   NULL,
                                   OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);

        status = PsCreateSystemThread(&threadHandle,
                                      (ACCESS_MASK) 0L,
                                      &ObjAttributes,
                                      (HANDLE) 0L,
                                      NULL,
                                      iSpProcessScsiCommand,
                                      fdoExtension);

        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Failed to create thread. Status %x\n"));
            goto iSpStartNetworkExit;
        }

        status = ObReferenceObjectByHandle(threadHandle,
                                           SYNCHRONIZE,
                                           NULL,
                                           KernelMode,
                                           &(iScsiConnection->IScsiThread),
                                           NULL );

        ASSERT(NT_SUCCESS(status));

        ZwClose(threadHandle);
        threadHandle = NULL;

        //
        // Pre-Allocate buffers to process the requests from the client
        //
        for (inx = 0; inx <= MAX_PENDING_REQUESTS; inx++) {

            (iScsiConnection->ActiveRequests[inx]).CommandBuffer
                 = iSpAllocatePool(NonPagedPool,
                                   ISCSI_SCSI_COMMAND_BUFF_SIZE,
                                   ISCSI_TAG_SCSI_CMD_BUFF);
                
            if (((iScsiConnection->ActiveRequests[inx]).CommandBuffer) 
                == NULL) {
        
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto iSpStartNetworkExit;

            }
        }

        iScsiConnection->Type = ISCSI_CONNECTION_TYPE;
        iScsiConnection->Size = sizeof(ISCSI_CONNECTION);

        fdoExtension->CurrentProtocolState = PSNodeInitInProgress;
        status = iSpSetupNetworkNode(ISCSI_ANY_ADDRESS,
                                     ISCSI_TARGET_PORT,
                                     Irp,
                                     (PVOID) DeviceObject,
                                     iScsiConnection);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Failed to setup server node. Status %x\n",
                        status));

            goto iSpStartNetworkExit;
        }

        nodeSetup = TRUE;

        DebugPrint((3, "Server node setup. Will register event handlers\n"));
        //
        // Set the event handlers for the server
        //
        countOfEvents = countof(ServerEvents);
        status = iSpTdiSetEventHandler(Irp,
                                       iScsiConnection->AddressDeviceObject,
                                       iScsiConnection->AddressFileObject,
                                       ServerEvents,
                                       countOfEvents,
                                       (PVOID) fdoExtension);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Failed to register event handlers\n"));
            goto iSpStartNetworkExit;
        } else {
            DebugPrint((3, "Event handlers registered\n"));
            iScsiConnection->DeviceObject = DeviceObject;
            iScsiConnection->ConnectionState = ConnectionStateDisconnected;
            iScsiConnection->ReceiveState = ReceiveHeader;
            iScsiConnection->CompleteHeaderReceived = TRUE;
            fdoExtension->CurrentProtocolState = PSWaitingForLogon;
            commonExtension->IsServerNodeSetup = TRUE;
        }
    }

iSpStartNetworkExit:

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "Failure in StartNetwork. Status 0x%08x\n",
                    status));

        if (iScsiConnection != NULL) {

            if (iScsiConnection->IScsiThread) {
                iScsiConnection->TerminateThread = TRUE;
                KeReleaseSemaphore(&(iScsiConnection->RequestSemaphore),
                                   (KPRIORITY) 0,
                                   1,
                                   FALSE );
    
                KeWaitForSingleObject((iScsiConnection->IScsiThread),
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
    
                ObDereferenceObject(iScsiConnection->IScsiThread);
            }
    
            for (inx = 0; inx <= MAX_PENDING_REQUESTS; inx++) {
                if (((iScsiConnection->ActiveRequests[inx]).CommandBuffer)) {
                    ExFreePool(
                        ((iScsiConnection->ActiveRequests[inx]).CommandBuffer)
                        );
                }
            }

            if (nodeSetup == TRUE) {
                iSpStopNetwork(DeviceObject);
            }   

            ExFreePool(iScsiConnection);
        }
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    return status;
}


NTSTATUS
iSpSetupNetworkNode(
    IN ULONG  InAddress,
    IN USHORT InPort,
    IN PIRP   Irp,
    IN PVOID ConnectionContext,
    OUT PISCSI_CONNECTION ConnectionInfo
    )
{
    NTSTATUS status;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO   tdiAddressInfo;
    PTA_ADDRESS         tdiTAAddress;
    PTRANSPORT_ADDRESS  tdiTransportAddress;
    PTDI_ADDRESS_IP     tdiIPAddress;

    HANDLE tdiAddrHandle;
    PFILE_OBJECT tdiAddrFileObject;
    PDEVICE_OBJECT tdiAddrDeviceObject;

    HANDLE tdiConnectionHandle;
    PFILE_OBJECT tdiConnectionFileObject;
    PDEVICE_OBJECT tdiConnectionDeviceObject;

    UCHAR  tdiAddressBuffer[TDI_QUERY_ADDRESS_LENGTH_IP];

    //
    // Create the address with wellknown port number for the server.
    // Clients will connect to this port to query for shared devices.
    //
    status = iSpCreateTdiAddressObject(InAddress,
                                       InPort,
                                       &tdiAddrHandle,
                                       &tdiAddrFileObject,
                                       &tdiAddrDeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "Failed to setup address. Status %x\n", status));
        return status;
    }

    //
    // Query information to retrieve address, port number, etc of 
    // the address we just setup.
    //
    status = iSpTdiQueryInformation(tdiAddrDeviceObject,
                                    tdiAddrFileObject,
                                    (PTDI_ADDRESS_INFO)tdiAddressBuffer,
                                    TDI_QUERY_ADDRESS_LENGTH_IP);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Could not query address info for the server. Status %x\n",
                    status));

        iSpCloseTdiAddress(tdiAddrHandle,
                           tdiAddrFileObject);

        return status;
    }

    tdiAddressInfo = (PTDI_ADDRESS_INFO) tdiAddressBuffer;
    tdiTransportAddress = (PTRANSPORT_ADDRESS) &(tdiAddressInfo->Address);
    tdiTAAddress = tdiTransportAddress->Address;
    ASSERT((tdiTAAddress->AddressType) == TDI_ADDRESS_TYPE_IP);
    ASSERT((tdiTAAddress->AddressLength) == sizeof(TDI_ADDRESS_IP));
    tdiIPAddress = (PTDI_ADDRESS_IP) tdiTAAddress->Address;

    DebugPrint((3, "Query succeeded. Address 0x%x, Port Number 0x%x\n",
                tdiIPAddress->in_addr,
                ntohs(tdiIPAddress->sin_port)));

    //
    // Create the connection endpoint for the server address
    //
    status = iSpCreateTdiConnectionObject(DD_TCP_DEVICE_NAME,
                                          ConnectionInfo,
                                          &tdiConnectionHandle,
                                          &tdiConnectionFileObject,
                                          &tdiConnectionDeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Could not create connection for the server. Status %x\n",
                    status));

        iSpCloseTdiAddress(tdiAddrHandle,
                           tdiAddrFileObject);
        return status;
    }

    //
    // Associate the address and the connection endpoint created above
    //
    status = iSpTdiAssociateAddress(Irp, 
                                    tdiAddrHandle,
                                    tdiConnectionFileObject,
                                    tdiConnectionDeviceObject
                                    );
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, 
                    "Could not associate address for server. Status %x\n",
                    status));

        iSpCloseTdiConnection(tdiConnectionHandle,
                              tdiConnectionFileObject);
        iSpCloseTdiAddress(tdiAddrHandle,
                           tdiAddrFileObject);
        return status;
    }

    //
    // Done setting up the server. Save all the relevant info
    // in our device extension
    //
    ConnectionInfo->AddressHandle = tdiAddrHandle;
    ConnectionInfo->AddressFileObject = tdiAddrFileObject;
    ConnectionInfo->AddressDeviceObject = tdiAddrDeviceObject;
    ConnectionInfo->ConnectionHandle = tdiConnectionHandle;
    ConnectionInfo->ConnectionFileObject = tdiConnectionFileObject;
    ConnectionInfo->ConnectionDeviceObject = tdiConnectionDeviceObject;
    RtlCopyMemory(&(ConnectionInfo->IPAddress),
                  tdiIPAddress,
                  sizeof(TDI_ADDRESS_IP));

    DebugPrint((3, "Node setup. Address 0x%08x, Port Number 0x%x\n",
                tdiIPAddress->in_addr,
                ntohs(tdiIPAddress->sin_port)));

    return STATUS_SUCCESS;
}


NTSTATUS
iSpCloseNetworkNode(
    PISCSI_CONNECTION iScsiConnection
    )
{
    NTSTATUS status;

    status = iSpTdiDisassociateAddress(iScsiConnection->ConnectionDeviceObject,
                                       iScsiConnection->ConnectionFileObject);

    if (NT_SUCCESS(status)) {
        iSpCloseTdiConnection(iScsiConnection->ConnectionHandle,
                              iScsiConnection->ConnectionFileObject);
        iSpCloseTdiAddress(iScsiConnection->AddressHandle,
                           iScsiConnection->AddressFileObject);
    } else {
        DebugPrint((0, "iSpTdiDisassociateAddress failed. Status %x\n",
                    status));
    }

    DebugPrint((3, "Status from iSpCloseNetworkNode : %x\n",
                status));
    return status;
}


NTSTATUS
iSpCreateTdiAddressObject(
    IN ULONG InAddress,
    IN USHORT InPort,
    OUT PVOID *AddrHandle,
    OUT PFILE_OBJECT *AddrFileObject,
    OUT PDEVICE_OBJECT *AddrDeviceObject
    )
{
    TA_IP_ADDRESS IPAddress;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PVOID Handle;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock; 
    NTSTATUS status;
    UCHAR eaBufferBuffer[FILE_FULL_EA_INFO_ADDR_LENGTH];

    RtlZeroMemory(&IPAddress, sizeof(TA_IP_ADDRESS));
    IPAddress.TAAddressCount = 1;
    IPAddress.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    IPAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    IPAddress.Address[0].Address[0].in_addr = htonl(InAddress);
    IPAddress.Address[0].Address[0].sin_port = htons(InPort);

    RtlInitUnicodeString(&deviceName, DD_TCP_DEVICE_NAME);
    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    eaBuffer = (FILE_FULL_EA_INFORMATION UNALIGNED *)eaBufferBuffer;

    RtlZeroMemory(eaBuffer, sizeof(eaBufferBuffer));
    eaBuffer->NextEntryOffset = 0;
    eaBuffer->Flags = 0;
    eaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    eaBuffer->EaValueLength = sizeof(TA_IP_ADDRESS);

    //
    // Set EaName
    //
    RtlMoveMemory(&(eaBuffer->EaName[0]),
                  TdiTransportAddress,
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1);

    //
    // Set EaValue
    //
    RtlMoveMemory(&(eaBuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1]),
                  &IPAddress,
                  sizeof(TA_IP_ADDRESS)
                  );

    status = ZwCreateFile(&Handle,
                          (GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE),
                          &objectAttributes,
                          &ioStatusBlock,
                          0,
                          0,
                          (FILE_SHARE_READ | FILE_SHARE_WRITE),
                          FILE_CREATE,
                          0,
                          eaBuffer,
                          FILE_FULL_EA_INFO_ADDR_LENGTH);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "CreateTdiAddress failed. Status %x\n",
                    status));
        return status;
    }

    //
    // Get the associated fileobject
    //
    status = ObReferenceObjectByHandle(Handle,
                                       0,
                                       NULL,
                                       KernelMode,
                                       &FileObject,
                                       NULL);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "ObReferenceObjectByHandle failed. Status %x\n",
                    status));
        ZwClose(Handle);
        return status;
    }

    //
    // Get the associated deviceobject
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    *AddrHandle = Handle;
    *AddrFileObject = FileObject;
    *AddrDeviceObject = DeviceObject;

    return STATUS_SUCCESS;
}


NTSTATUS
iSpCreateTdiConnectionObject(
    IN PWCHAR DeviceName,
    IN CONNECTION_CONTEXT ConnectionContext,
    OUT PVOID *ConnectionHandle,
    OUT PFILE_OBJECT *ConnectionFileObject,
    OUT PDEVICE_OBJECT *ConnectionDeviceObject
    )
{
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PVOID Handle;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    CONNECTION_CONTEXT *eaCEPContext;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock; 
    NTSTATUS status;
    UCHAR eaBufferBuffer[FILE_FULL_EA_INFO_CEP_LENGTH];

    RtlInitUnicodeString(&deviceName, DD_TCP_DEVICE_NAME);
    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    eaBuffer = (FILE_FULL_EA_INFORMATION UNALIGNED *)eaBufferBuffer;

    eaBuffer->NextEntryOffset = 0;
    eaBuffer->Flags = 0;
    eaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    eaBuffer->EaValueLength = sizeof(CONNECTION_CONTEXT);

    //
    // Set EaName
    //
    RtlMoveMemory(eaBuffer->EaName,
                  TdiConnectionContext,
                  TDI_CONNECTION_CONTEXT_LENGTH + 1);

    //
    // Set EaValue
    //
    eaCEPContext = (CONNECTION_CONTEXT UNALIGNED *)
                   &(eaBuffer->EaName[TDI_CONNECTION_CONTEXT_LENGTH + 1]);
    *eaCEPContext = (CONNECTION_CONTEXT)ConnectionContext;

    status = ZwCreateFile(&Handle,
                          (GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE),
                          &objectAttributes,
                          &ioStatusBlock,
                          0,
                          0,
                          0,
                          FILE_CREATE,
                          0,
                          eaBuffer,
                          FILE_FULL_EA_INFO_CEP_LENGTH);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "CreateTdiConnection failed. Status %x\n",
                    status));
        return status;
    }

    //
    // Get the associated fileobject
    //
    status = ObReferenceObjectByHandle(Handle,
                                       0,
                                       NULL,
                                       KernelMode,
                                       &FileObject,
                                       NULL);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "ObReferenceObjectByHandle failed. Status %x\n",
                    status));
        ZwClose(Handle);
        return status;
    }

    //
    // Get the associated deviceobject
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    *ConnectionHandle = Handle;
    *ConnectionFileObject = FileObject;
    *ConnectionDeviceObject = DeviceObject;

    return STATUS_SUCCESS;
}


NTSTATUS
iSpTdiAssociateAddress(
    IN PIRP Irp,
    IN PVOID AddrHandle,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    NTSTATUS status;

    TdiBuildAssociateAddress(Irp,
                             ConnectionDeviceObject,
                             ConnectionFileObject,
                             iSpTdiCompletionRoutine,
                             NULL,
                             AddrHandle);

    status = iSpTdiSendIrpSynchronous(ConnectionDeviceObject,
                                      Irp);

    return status;
}


NTSTATUS
iSpTdiDisassociateAddress(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject
    )
{
    NTSTATUS status;
    PIRP Irp;

    Irp = IoAllocateIrp(ConnectionDeviceObject->StackSize, FALSE);
    if (Irp != NULL) {
        TdiBuildDisassociateAddress(Irp,
                                    ConnectionDeviceObject,
                                    ConnectionFileObject,
                                    iSpTdiCompletionRoutine,
                                    NULL);

        status = iSpTdiSendIrpSynchronous(ConnectionDeviceObject,
                                          Irp);

    } else {
        DebugPrint((0, 
                    "iSpTdiDisassociateAddress : Failed to allocate IRP\n"));
        status = STATUS_NO_MEMORY;
    }

    return status;
}


NTSTATUS
iSpTdiSetEventHandler(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER EventsToSet,
    IN ULONG CountOfEvents,
    IN PVOID EventContext
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS oldStatus = STATUS_SUCCESS;
    ULONG inx, tmp;

    for (inx = 0; inx < CountOfEvents; inx++) {
        TdiBuildSetEventHandler(Irp,
                                DeviceObject,
                                FileObject,
                                iSpTdiCompletionRoutine,
                                NULL,
                                EventsToSet[inx].EventId,
                                EventsToSet[inx].EventHandler,
                                EventContext);

        status = iSpTdiSendIrpSynchronous(DeviceObject,
                                          Irp);

        DebugPrint((3, "Status from iSpTdiSetEventHandler : %x\n",
                    status));

        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    oldStatus = status;
    if (!NT_SUCCESS(status)) {
        for (tmp = 0; tmp < inx; tmp++) {
            TdiBuildSetEventHandler(Irp,
                                    DeviceObject,
                                    FileObject,
                                    iSpTdiCompletionRoutine,
                                    NULL,
                                    EventsToSet[tmp].EventId,
                                    NULL,
                                    NULL);

            status = iSpTdiSendIrpSynchronous(DeviceObject,
                                              Irp);

            DebugPrint((3, "Status from iSpTdiSetEventHandler : %x\n",
                        status));
        }
    } 

    return oldStatus;
}


NTSTATUS
iSpTdiResetEventHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER EventsToSet,
    IN ULONG CountOfEvents
    )
{
    PIRP localIrp;
    ULONG inx;
    NTSTATUS status;

    localIrp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((0, "iSpTdiResetEventHandler : Failed to allocate IRP\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (inx = 0; inx < CountOfEvents; inx++) {
        TdiBuildSetEventHandler(localIrp,
                                DeviceObject,
                                FileObject,
                                iSpTdiCompletionRoutine,
                                NULL,
                                EventsToSet[inx].EventId,
                                NULL,
                                NULL);

        status = iSpTdiSendIrpSynchronous(DeviceObject,
                                          localIrp);

        DebugPrint((3, "Status from iSpTdiResetEventHandler : %x\n",
                    status));
    }

    IoFreeIrp(localIrp);

    return status;
}


NTSTATUS
iSpCloseTdiAddress(
    HANDLE AddrHandle,
    PFILE_OBJECT AddrFileObject
    )
{
    NTSTATUS status;

    if (AddrFileObject != NULL) {
        ObDereferenceObject(AddrFileObject);
    }

    if (AddrHandle != NULL ) {
        status = ZwClose(AddrHandle);

        DebugPrint((3, "Status from iSpCloseTdiAddress : %x\n",
                    status));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpCloseTdiConnection(
    HANDLE ConnectionHandle,
    PFILE_OBJECT ConnectionFileObject
    )
{
    NTSTATUS status;

    if (ConnectionFileObject != NULL) {
        ObDereferenceObject(ConnectionFileObject);
    }

    if (ConnectionHandle != NULL) {
        status = ZwClose(ConnectionHandle);
        DebugPrint((3, "Status from iSpCloseTdiConnection : %x\n",
                    status));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpTdiDeviceControl(
    IN PIRP Irp,
    IN PMDL Mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID IrpParameter,
    IN ULONG IrpParameterLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength
    )
{
    PIRP localIrp;
    PIO_STACK_LOCATION irpStack;
    PMDL localMdl;
    NTSTATUS status;

    //
    // If caller didn't provide an IRP, allocate one
    //
    if (Irp != NULL) {
        localIrp = Irp;
    } else {
        localIrp = IoAllocateIrp((DeviceObject->StackSize) + 1,
                                 FALSE);
        if (localIrp == NULL) {
            DebugPrint((0, "IoAllocateIrp failed in iSpTdiDeviceControl\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (MdlBuffer == NULL) {
        localIrp->MdlAddress = NULL;
        localMdl = NULL;
    } else {
        if (Mdl == NULL) {
            localMdl = IoAllocateMdl(MdlBuffer,
                                     MdlBufferLength,
                                     FALSE,
                                     FALSE,
                                     localIrp);
            if (localMdl == NULL) {
                DebugPrint((0, "Failed to allocate MDL\n"));

                if (Irp == NULL) {
                    IoFreeIrp(localIrp);
                }

                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            localMdl = Mdl;
            MmInitializeMdl(localMdl,
                            MdlBuffer,
                            MdlBufferLength);
        }

        MmBuildMdlForNonPagedPool(localMdl);
    }

    irpStack = IoGetCurrentIrpStackLocation(localIrp);
    irpStack->FileObject = FileObject;
    irpStack->DeviceObject = DeviceObject;
    irpStack->MajorFunction = MajorFunction;
    irpStack->MinorFunction = MinorFunction;
    RtlCopyMemory(&(irpStack->Parameters),
                  IrpParameter,
                  IrpParameterLength);

    status = iSpTdiSendIrpSynchronous(DeviceObject, localIrp);

    if (Irp == NULL) {
        IoFreeIrp(localIrp);
    }

    return status;
}


NTSTATUS
iSpTdiQueryInformation(
    IN PDEVICE_OBJECT TdiDeviceObject,
    IN PFILE_OBJECT TdiFileObject,
    IN PTDI_ADDRESS_INFO TdiAddressBuffer,
    IN ULONG TdiAddrBuffLen
    )
{
    PMDL queryMdl = NULL;
    PMDL tmpMdlPtr = NULL;
    PIRP queryIrp = NULL;
    NTSTATUS status;

    status = iSpAllocateMdlAndIrp(TdiAddressBuffer,
                                  TdiAddrBuffLen,
                                  (CCHAR)(TdiDeviceObject->StackSize),
                                  TRUE,
                                  &queryIrp,
                                  &queryMdl);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "iSpAllocateMdlAndIrp returned %x\n",
                    status));
        return status;
    }

    //
    // Build the IRP for sending the query information request
    //
    TdiBuildQueryInformation(queryIrp,
                             TdiDeviceObject,
                             TdiFileObject,
                             iSpTdiCompletionRoutine,
                             NULL,
                             TDI_QUERY_ADDRESS_INFO,
                             queryMdl);

    status = iSpTdiSendIrpSynchronous(TdiDeviceObject, queryIrp);

    //
    // Free MDLs and IRP
    //
    iSpFreeMdlAndIrp(queryMdl, queryIrp, FALSE);

    return status;
}


NTSTATUS
iSpTdiConnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           TdiIPAddress,
    IN  USHORT          TdiPortNumber,
    IN  LARGE_INTEGER   ConnectionTimeout
    )
{
    TDI_CONNECTION_INFORMATION  requestConnectionInformation;
    TDI_CONNECTION_INFORMATION  returnConnectionInformation;

    PIRP                localIrp;
    PTRANSPORT_ADDRESS  tdiTransportAddress;
    PTA_ADDRESS         tdiTAAddress;
    PTDI_ADDRESS_IP     tdiIPAddress;
    NTSTATUS            status;

    UCHAR               tdiAddressBuffer[TDI_IP_ADDRESS_LENGTH];

    PAGED_CODE ();

    RtlZeroMemory(tdiAddressBuffer, TDI_IP_ADDRESS_LENGTH);
    RtlZeroMemory (&requestConnectionInformation,
                   sizeof (requestConnectionInformation));
    RtlZeroMemory (&returnConnectionInformation,
                   sizeof (returnConnectionInformation));
    tdiTransportAddress = (PTRANSPORT_ADDRESS) tdiAddressBuffer;
    tdiTransportAddress->TAAddressCount = 1;
    tdiTAAddress = tdiTransportAddress->Address;
    tdiTAAddress->AddressLength = sizeof (TDI_ADDRESS_IP);
    tdiTAAddress->AddressType = TDI_ADDRESS_TYPE_IP;
    tdiIPAddress = (PTDI_ADDRESS_IP) tdiTAAddress->Address;
    tdiIPAddress->in_addr = TdiIPAddress;
    tdiIPAddress->sin_port = TdiPortNumber;

    requestConnectionInformation.RemoteAddressLength = TDI_IP_ADDRESS_LENGTH;
    requestConnectionInformation.RemoteAddress = (PVOID) tdiTransportAddress;


    localIrp = IoAllocateIrp (TdiConnDeviceObject->StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((0, "iSpTdiConnect : Failed to allocate IRP\n"));
        return STATUS_NO_MEMORY;
    }

    TdiBuildConnect(
        localIrp,                      
        TdiConnDeviceObject,            
        TdiConnFileObject,              
        iSpTdiCompletionRoutine,                           
        NULL,                           
        &ConnectionTimeout,                       
        &requestConnectionInformation,  
        &returnConnectionInformation);  

    status = iSpTdiSendIrpSynchronous(TdiConnDeviceObject, localIrp);

    IoFreeIrp(localIrp);

    DebugPrint((3, "iSpTdiConnect : return status %x\n",
                status));

    return status;
}


NTSTATUS
iSpTdiDisconnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           DisconnectFlags,
    IN  PVOID           CompletionRoutine,
    IN  PVOID           CompletionContext,
    IN  LARGE_INTEGER   DisconnectTimeout
    )

{
    PIRP                        localIrp;
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status;
    TDI_CONNECTION_INFORMATION  disconnectRequest;
    TDI_CONNECTION_INFORMATION  disconnectReply;

    localIrp = IoAllocateIrp (TdiConnDeviceObject->StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((0, "iSpTdiDisconnect : Failed to allocate IRP\n"));
        return STATUS_NO_MEMORY;
    }

    localIrp->Flags = 0;
    localIrp->UserIosb = &ioStatusBlock;

    TdiBuildDisconnect(
        localIrp,             
        TdiConnDeviceObject,    
        TdiConnFileObject,      
        CompletionRoutine,      
        CompletionContext,      
        &DisconnectTimeout,       
        DisconnectFlags,        
        &disconnectRequest,        
        &disconnectReply);       

    status = iSpTdiSendIrpSynchronous(TdiConnDeviceObject, localIrp);

    IoFreeIrp(localIrp);

    DebugPrint((3, "Return value from iSpTdiDisconnect : %x\n",
                status));
    return status;
}


NTSTATUS
iSpConnectionHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = (PISCSI_FDO_EXTENSION) TdiEventContext;
    PISCSI_CONNECTION    iScsiConnection = fdoExtension->ServerNodeInfo;
    PTA_IP_ADDRESS       receivedAddressPtr;
    PIRP                localIrp;
    ULONG   remoteAddress;
    USHORT  remotePortNumber;
    UCHAR  ipAddress[4];
    TA_IP_ADDRESS        receivedAddress;

    DebugPrint((3, "Received connect request\n"));

    receivedAddressPtr = RemoteAddress;
    ASSERT(RemoteAddressLength == sizeof(TA_IP_ADDRESS));
    ASSERT((receivedAddressPtr->TAAddressCount) == 1);
    ASSERT(((receivedAddressPtr->Address[0]).AddressType) == TDI_ADDRESS_TYPE_IP);

    RtlCopyMemory(&receivedAddress, receivedAddressPtr, sizeof(TA_IP_ADDRESS));
    remoteAddress = ntohl(receivedAddress.Address[0].Address[0].in_addr);
    ipAddress[0] = (UCHAR) ((remoteAddress >> 24) & 0xFF);
    ipAddress[1] = (UCHAR) ((remoteAddress >> 16) & 0xFF);
    ipAddress[2] = (UCHAR) ((remoteAddress >> 8) & 0xFF);
    ipAddress[3] = (UCHAR) (remoteAddress & 0xFF);
    remotePortNumber = ntohs(receivedAddress.Address[0].Address[0].sin_port);

    DebugPrint((3, "Remote address : %d.%d.%d.%d, Port Number : %x\n",
                ipAddress[0], ipAddress[1], ipAddress[2], ipAddress[3],
                remotePortNumber));

    *AcceptIrp = NULL;
    localIrp = IoAllocateIrp((iScsiConnection->ConnectionDeviceObject)->StackSize,
                              FALSE);
    if (localIrp != NULL) {
        TdiBuildAccept(localIrp,
                       iScsiConnection->ConnectionDeviceObject,
                       iScsiConnection->ConnectionFileObject,
                       iSpConnectionComplete,
                       fdoExtension,
                       NULL,
                       NULL);

        IoSetNextIrpStackLocation(localIrp);

        *AcceptIrp = localIrp;
        *ConnectionContext = (CONNECTION_CONTEXT) iScsiConnection;

        iScsiConnection->ConnectionState = ConnectionStateConnected;

        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        return STATUS_NO_MEMORY;
    }
}



NTSTATUS
iSpConnectionComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = (PISCSI_FDO_EXTENSION) Context;
    PISCSI_CONNECTION    iScsiConnection;

    iScsiConnection = fdoExtension->ServerNodeInfo;

    ASSERT(Irp);

    if (!NT_SUCCESS((Irp->IoStatus.Status))) {
        DebugPrint((0, "Failed to accept connection. Status %x\n",
                    (Irp->IoStatus.Status)));

        iScsiConnection->ConnectionState = ConnectionStateDisconnected;
    } else {
        DebugPrint((3, "Accepted connection\n"));
    }

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
iSpDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = (PISCSI_FDO_EXTENSION) TdiEventContext;
    PISCSI_CONNECTION iScsiConnection;
    LARGE_INTEGER disconnectTimeout;

    DebugPrint((0, "Disconnect flags is %x\n", DisconnectFlags));

    iScsiConnection = fdoExtension->ServerNodeInfo;

    ASSERT((iScsiConnection != NULL));

    if ((iScsiConnection->ConnectionState) == ConnectionStateStopping) {
        DebugPrint((0, "We initiated disconnect. Do nothing more here\n"));
        iScsiConnection->ConnectionState = ConnectionStateDisconnected;
        fdoExtension->CurrentProtocolState = PSWaitingForLogon;
        return STATUS_SUCCESS;
    }

    DebugPrint((0, "We were told to disconnect. Process that now\n"));
    iScsiConnection->ConnectionState = ConnectionStateDisconnected;

    if (DisconnectFlags & TDI_DISCONNECT_RELEASE) {
        PIO_WORKITEM workItem;

        workItem = IoAllocateWorkItem(fdoExtension->DeviceObject);
        if (workItem != NULL) {
            IoQueueWorkItem(workItem, iSpPerformDisconnect,
                            DelayedWorkQueue,
                            workItem);

            DebugPrint((3, "Queued work item to do disconnect\n"));
        }

    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpPerformDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension; 
    PISCSI_CONNECTION iScsiConnection;
    LARGE_INTEGER disconnectTimeout;
    NTSTATUS status;

    IoFreeWorkItem((PIO_WORKITEM) Context);

    iScsiConnection = fdoExtension->ServerNodeInfo;

    disconnectTimeout.QuadPart = -100000000L;

    DebugPrint((0, "In iSpPerformDisconnect\n"));
    status = iSpTdiDisconnect(iScsiConnection->ConnectionDeviceObject,
                              iScsiConnection->ConnectionFileObject,
                              TDI_DISCONNECT_RELEASE,
                              iSpTdiCompletionRoutine,
                              iScsiConnection,
                              disconnectTimeout);

    fdoExtension->CurrentProtocolState = PSWaitingForLogon;

    DebugPrint((3, "iSpTdiDisconnect  returned : %x\n",
                status));

    return STATUS_SUCCESS;
}



NTSTATUS
iSpSendData(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLen,
    OUT PULONG BytesSent
    )
{
    PIRP sendIrp = NULL;
    PMDL sendMdl = NULL;
    PMDL tmpMdlPtr = NULL;
    NTSTATUS status;

    DebugPrint((3, "Entering SendData\n"));

    *BytesSent = 0;

    status = iSpAllocateMdlAndIrp(DataBuffer,
                                  DataBufferLen,
                                  (CCHAR)(ConnectionDeviceObject->StackSize),
                                  TRUE,
                                  &sendIrp,
                                  &sendMdl);
    if (NT_SUCCESS(status)) {
        TdiBuildSend(sendIrp,
                     ConnectionDeviceObject,
                     ConnectionFileObject,
                     iSpTdiSendCompletionRoutine,
                     NULL,
                     sendMdl,
                     0,
                     DataBufferLen);

        /*
        status = iSpTdiSendIrpSynchronous(ConnectionDeviceObject,
                                          sendIrp);
        if (NT_SUCCESS(status)) {
            *BytesSent = sendIrp->IoStatus.Information;
            DebugPrint((3, "Bytes sent : %d\n",
                        *BytesSent));

        }
        */

        status = IoCallDriver(ConnectionDeviceObject, sendIrp);
        if (!NT_SUCCESS(status)) {
            DebugPrint((0, "Send failed. Status 0x%x\n", status));
        }
    }

    DebugPrint((3, "Status in SendData : %x\n",
                status));
    return status;
}


NTSTATUS
iSpReceiveHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID DataBuffer,
    OUT PIRP *IoRequestPacket
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = (PISCSI_FDO_EXTENSION) TdiEventContext;
    PISCSI_CONNECTION iScsiConnection;
    PDEVICE_OBJECT connectionDeviceObject;
    PFILE_OBJECT connectionFileObject;

    PIRP receiveIrp;
    PMDL receiveMdl;

    NTSTATUS status;

    UCHAR  protocolState;

    DebugPrint((3, "In receive handler. Receive flags : 0x%08x\n",
                ReceiveFlags));

    iScsiConnection = fdoExtension->ServerNodeInfo;

    ASSERT((iScsiConnection != NULL));

    connectionDeviceObject = iScsiConnection->ConnectionDeviceObject;
    connectionFileObject = iScsiConnection->ConnectionFileObject;

    DebugPrint((3, "FDO Extension : %x, CurrentProtocolState : %d\n",
                fdoExtension, fdoExtension->CurrentProtocolState));

    protocolState = fdoExtension->CurrentProtocolState;

    DebugPrint((3, 
                "PS State : %d, BytesIndicated : %d, BytesAvailable : %d\n",
                protocolState, BytesIndicated, BytesAvailable));

    ASSERT((iScsiConnection->ConnectionState) == ConnectionStateConnected);

    //
    // We won't send Read IRP for now
    //
    *IoRequestPacket = NULL;

    status = STATUS_SUCCESS;

    switch (protocolState) {
        case PSWaitingForLogon: {
            PIO_WORKITEM workItem;
            PISCSI_LOGIN_COMMAND loginCommand;

            ASSERT(BytesIndicated >= sizeof(ISCSI_LOGIN_COMMAND));

            //
            // Assuming that the entire packet is available
            // when logon command is received.
            //
            loginCommand =
                (PISCSI_LOGIN_COMMAND) iScsiConnection->IScsiHeader;
            RtlCopyMemory(loginCommand,
                          DataBuffer,
                          sizeof(ISCSI_LOGIN_RESPONSE));

            ASSERT(((loginCommand->OpCode) == ISCSIOP_LOGIN_COMMAND));

            DebugPrint((3, "Received login command.\n"));

            workItem = IoAllocateWorkItem(fdoExtension->DeviceObject);
            if (workItem != NULL)  {

                IoQueueWorkItem(workItem, iSpSendLoginResponse,
                                DelayedWorkQueue,
                                workItem);

                DebugPrint((3, "Queued work item to send login response\n"));
            } else {
                DebugPrint((0, "Failed to allocate workitem for logon\n"));                
            }

            *BytesTaken = BytesIndicated;

            break;
        }

        case PSFullFeaturePhase: {
            PUCHAR commandBuffer;
            PISCSI_SCSI_COMMAND iScsiCommand;
            PACTIVE_REQUESTS currentRequest = NULL;
            ULONG length;
            ULONG receivedDataLen;
            ULONG inx;

            *BytesTaken = BytesIndicated;

            //
            // Process the received data
            //
            status = iSpProcessReceivedData(
                            iScsiConnection,
                            BytesIndicated,
                            BytesTaken,
                            DataBuffer);

            if (BytesIndicated < BytesAvailable) {
                PUCHAR readBuffer = NULL;
                ULONG remainingBytes;                                          
                                                                               
                //                                                             
                // Need to send read IRP to read                               
                // the remaining bytes                                         
                //                                                             
                remainingBytes = BytesAvailable - BytesIndicated;              
                                                                               
                DebugPrint((0, "Bytes Available %d, Bytes Remaining : %d\n", 
                            BytesAvailable,
                            remainingBytes));                                  
                                                                               
                readBuffer = iSpAllocatePool(NonPagedPool,
                                             remainingBytes,
                                             ISCSI_TAG_READBUFFER);
                if (readBuffer != NULL) {

                    status = iSpAllocateMdlAndIrp(                                 
                                  readBuffer,                     
                                  remainingBytes,                                  
                                  (CCHAR)(connectionDeviceObject->StackSize),      
                                  TRUE,                                            
                                  &receiveIrp,                                     
                                  &receiveMdl);                                    
                    if (NT_SUCCESS(status)) {                                      
                        TdiBuildReceive(receiveIrp,                                
                                        connectionDeviceObject,                    
                                        connectionFileObject,                      
                                        iSpReceiveCompletion,                      
                                        iScsiConnection,                           
                                        receiveMdl,                                
                                        0,                                         
                                        remainingBytes);                           

                        iScsiConnection->RemainingBytes = remainingBytes;          
                        status = STATUS_MORE_PROCESSING_REQUIRED;                  
                        *IoRequestPacket = receiveIrp;   
                        IoSetNextIrpStackLocation(receiveIrp);
                    } else {
                        ExFreePool(readBuffer);
                        status = STATUS_NO_MEMORY;
                    }
                } else {
                    status = STATUS_NO_MEMORY;
                }
            } 

            break;
        }

        default: {
            DebugPrint((0, "Unknown protocol state : %d\n",
                       protocolState));

            *BytesTaken = BytesIndicated;

            ASSERT(FALSE);

            break;
        }
    } // switch (protocolState)

    return status;
}


NTSTATUS
iSpReceiveCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PISCSI_CONNECTION iScsiConnection = (PISCSI_CONNECTION) Context;
    PVOID dataBuffer;
    NTSTATUS status;
    ULONG bytesTaken;
    ULONG inx;

    DebugPrint((0, "Inx in receive completion\n"));

    dataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Free the MDL and IRP
    //
    iSpFreeMdlAndIrp(Irp->MdlAddress,
                     Irp,
                     FALSE);

    status = iSpProcessReceivedData(
                      iScsiConnection,
                      (iScsiConnection->RemainingBytes),
                      &bytesTaken,
                      dataBuffer
                      );

    ExFreePool(dataBuffer);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
iSpProcessReceivedData(
    IN PISCSI_CONNECTION IScsiConnection,
    IN ULONG BytesIndicated,
    OUT PULONG BytesTaken,
    IN PVOID DataBuffer
    )
{
    PISCSI_SCSI_COMMAND iScsiCommand;
    PACTIVE_REQUESTS currentRequest;
    PUCHAR commandBuffer;
    ULONG length;
    ULONG inx;

    LONG bytesToCopy;
    LONG byteCount;

    *BytesTaken = BytesIndicated;

    byteCount = (LONG) BytesIndicated;

    while (byteCount > 0) {
        if ((IScsiConnection->ReceiveState) == ReceiveHeader) {
            DebugPrint((3, "Receiving header\n"));

            if ((IScsiConnection->CompleteHeaderReceived) == FALSE) {
                BOOLEAN headerComplete = FALSE;
            
                bytesToCopy = sizeof(ISCSI_GENERIC_HEADER) -
                    (IScsiConnection->IScsiHeaderOffset);
            
                DebugPrint((0, "CHR False. ToCopy : %d, Count : %d\n",
                            bytesToCopy, byteCount));
            
                if (byteCount < bytesToCopy) {
                    bytesToCopy = byteCount;
                } else {
                    headerComplete = TRUE;
                }
            
                RtlCopyMemory((IScsiConnection->IScsiHeader) +
                              (IScsiConnection->IScsiHeaderOffset),
                              DataBuffer,
                              bytesToCopy);
            
                if (headerComplete == FALSE) {
            
                    DebugPrint((0, "CHR still FALSE\n"));
            
                    IScsiConnection->IScsiHeaderOffset += bytesToCopy;
                    return STATUS_SUCCESS;
                } else {
            
                    DebugPrint((0, "Header complete\n"));
            
                    IScsiConnection->IScsiHeaderOffset = 0;
                    IScsiConnection->CompleteHeaderReceived = TRUE;
                    byteCount -= bytesToCopy;
                    ASSERT(byteCount >= 0);
                    (PUCHAR) DataBuffer += bytesToCopy;

                }
            } else if (byteCount < sizeof(ISCSI_GENERIC_HEADER)) {
                DebugPrint((0,
                            "Complete header NOT received. Count : %d\n",
                            byteCount));

                IScsiConnection->CompleteHeaderReceived = FALSE;

                RtlCopyMemory((IScsiConnection->IScsiHeader),
                              DataBuffer,
                              byteCount);

                IScsiConnection->IScsiHeaderOffset = byteCount;

                return STATUS_SUCCESS;
            } else {
                RtlCopyMemory((IScsiConnection->IScsiHeader),
                              DataBuffer,
                              sizeof(ISCSI_GENERIC_HEADER));

                byteCount -= sizeof(ISCSI_GENERIC_HEADER);
                ASSERT(byteCount >= 0);
                (PUCHAR) DataBuffer += sizeof(ISCSI_GENERIC_HEADER);
            }

            iScsiCommand = (PISCSI_SCSI_COMMAND) (IScsiConnection->IScsiHeader);
            GetUlongFromArray((iScsiCommand->Length),
                              length);

            DebugPrint((3, "Size of immediate data : %d\n",
                        length));

            ASSERT(length <= ISCSI_SCSI_COMMAND_BUFF_SIZE);

            inx = iSpGetActiveClientRequestIndex(IScsiConnection,
                                                 iScsiCommand);

            currentRequest = &(IScsiConnection->ActiveRequests[inx]);

            IScsiConnection->CurrentRequest = currentRequest;

            RtlCopyMemory((currentRequest->IScsiHeader),
                          (IScsiConnection->IScsiHeader),
                          sizeof(ISCSI_SCSI_COMMAND));

            if (length != 0) {
                ULONG receivedDataLen;

                IScsiConnection->ReceiveState = ReceiveData;

                commandBuffer = currentRequest->CommandBuffer;

                if ((LONG)length <= byteCount ) {
                    receivedDataLen = length;
                } else {
                    receivedDataLen = byteCount;
                }

                RtlCopyMemory(commandBuffer,
                              DataBuffer,
                              receivedDataLen);

                byteCount -= receivedDataLen;
                ASSERT(byteCount >= 0);
                (PUCHAR) DataBuffer += receivedDataLen;

                currentRequest->ExpectedDataLength = length;

                currentRequest->CommandBufferOffset = receivedDataLen;

                currentRequest->ReceivedDataLength = receivedDataLen;
            }
        } else {
            ASSERT((IScsiConnection->ReceiveState) == ReceiveData);
            ASSERT(IScsiConnection->CurrentRequest);

            DebugPrint((3, "Receiving data\n"));

            currentRequest = IScsiConnection->CurrentRequest;

            commandBuffer = (currentRequest->CommandBuffer) +
                            (currentRequest->CommandBufferOffset);

            bytesToCopy = ((currentRequest->ExpectedDataLength) -
                           (currentRequest->ReceivedDataLength));
            if ((LONG)bytesToCopy > byteCount)  {
                bytesToCopy = byteCount;
            } else {
                DebugPrint((3, "More bytes in current buffer than expected\n"));
            }

            RtlCopyMemory(commandBuffer, DataBuffer, bytesToCopy);

            byteCount -= bytesToCopy;
            ASSERT(byteCount >= 0);
            (PUCHAR) DataBuffer += bytesToCopy;

            currentRequest->CommandBufferOffset +=  bytesToCopy;

            currentRequest->ReceivedDataLength += bytesToCopy;           
        }

        if ((currentRequest->ReceivedDataLength) ==
            (currentRequest->ExpectedDataLength)) {

            IScsiConnection->ReceiveState = ReceiveHeader;

            currentRequest->CommandBufferOffset = 0;

            currentRequest->ExpectedDataLength = 0;

            currentRequest->ReceivedDataLength = 0;

            IScsiConnection->CurrentRequest = NULL;

            DebugPrint((3, "Request complete. Will process it\n"));

            KeReleaseSemaphore(&(IScsiConnection->RequestSemaphore),
                               (KPRIORITY) 0,
                               1, 
                               FALSE);
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
iSpStopNetwork(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PISCSI_CONNECTION iScsiConnection = fdoExtension->ServerNodeInfo;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG countOfEvents;
    ULONG inx;

    if (iScsiConnection == NULL) {
        //
        // Nothing to do
        // 
        DebugPrint((1, "iSpStopNetwork : No node info\n"));

        return STATUS_SUCCESS;
    }

    countOfEvents = countof(ServerEvents);
    status = iSpTdiResetEventHandler(iScsiConnection->AddressDeviceObject,
                                     iScsiConnection->AddressFileObject,
                                     ServerEvents,
                                     countOfEvents);
    if (NT_SUCCESS(status)) {
        status = iSpCloseNetworkNode(iScsiConnection);

        for (inx = 0; inx <= MAX_PENDING_REQUESTS; inx++) {
            ExFreePool(
                (iScsiConnection->ActiveRequests[inx]).CommandBuffer
                );
        }

        ExFreePool(iScsiConnection);
        fdoExtension->ServerNodeInfo = NULL;
    } else {
        DebugPrint((0, "Failed to reset event handlers. Status %x\n",
                    status));
    }

    return status;
}


NTSTATUS
iSpTdiSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Initialize the IRP fields
    //
    Irp->UserEvent = &event;
    Irp->UserIosb = &ioStatusBlock;

    //
    // Submit the IRP and wait for it to complete, if necessary
    //
    status = IoCallDriver(DeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }

    return status;
}


NTSTATUS
iSpTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    //
    // Copy the IRP status and signal the event
    //
    *(Irp->UserIosb) = Irp->IoStatus;

    KeSetEvent(Irp->UserEvent,
               IO_NETWORK_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
iSpTdiSendCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PVOID bufferAddress = NULL;

    ASSERT(Irp != NULL);

    if ((Irp->MdlAddress) != NULL) {
        bufferAddress = MmGetMdlVirtualAddress(Irp->MdlAddress);
        DebugPrint((3, "Buffer address in send complete : %x\n",
                    bufferAddress));
    }

    //
    // Free MDLs and IRP
    //
    iSpFreeMdlAndIrp(Irp->MdlAddress, Irp, FALSE);

    if (bufferAddress != NULL) {
        ExFreePool(bufferAddress);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\pnp.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    pnp.c

Abstract:

    This file contains plug and play code for the NT iSCSI port driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, iScsiPortAddDevice)
#pragma alloc_text(PAGE, iScsiPortUnload)

#endif // ALLOC_PRAGMA

GUID iScsiServerGuid = iSCSI_SERVER_GUID;


NTSTATUS
iScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*+++
Routine Description:

    This routine handles add-device requests for the iSCSI port driver

Arguments:

    DriverObject - a pointer to the driver object for this device

    PhysicalDeviceObject - a pointer to the PDO we are being added to

Return Value:

    STATUS_SUCCESS if successful
    Appropriate NTStatus code on error

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT lowerDevice;
    PISCSI_FDO_EXTENSION fdoExtension;
    PCOMMON_EXTENSION commonExtension;
    NTSTATUS status;
    UNICODE_STRING deviceName;
    UNICODE_STRING dosUnicodeString;

    //
    // Claim the device
    //
    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    status = iScsiPortClaimDevice(lowerDevice, FALSE);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "Failed to claim the device. Status : %x\n",
                    status));
        ObDereferenceObject(lowerDevice);
        return status;
    }

    RtlInitUnicodeString(&deviceName, ISCSI_DEVICE_NAME);
    status = IoCreateDevice(DriverObject,
                            sizeof(ISCSI_FDO_EXTENSION),
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            0,
                            FALSE,
                            &deviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "iScsiPortAddDevice failed. Status %lx\n",
                    status));

        ObDereferenceObject(lowerDevice);

        return status;
    }
             
    newDeviceObject = IoAttachDeviceToDeviceStack(deviceObject,
                                                  PhysicalDeviceObject);
    if (newDeviceObject == NULL) {
        DebugPrint((0, 
                    "IoAttachDeviceToDeviceStack failed in iScsiAddDevice\n"));
        IoDeleteDevice(deviceObject);

        ObDereferenceObject(lowerDevice);
        return STATUS_UNSUCCESSFUL;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;
    commonExtension = &(fdoExtension->CommonExtension);

    RtlZeroMemory(fdoExtension, sizeof(ISCSI_FDO_EXTENSION));

    fdoExtension->LowerPdo = PhysicalDeviceObject;
    commonExtension->LowerDeviceObject = newDeviceObject;

    commonExtension->DeviceObject = deviceObject;
    commonExtension->IsPdo = FALSE;
    commonExtension->CurrentPnpState = 0xff;
    commonExtension->PreviousPnpState = 0xff;
    commonExtension->IsServerNodeSetup = FALSE;

    commonExtension->IsRemoved = NO_REMOVE;
    commonExtension->RemoveLock = 0;
    KeInitializeEvent(&(commonExtension->RemoveEvent),
                      SynchronizationEvent,
                      FALSE);

    //
    // Create the dos device name.
    // 
    if ((commonExtension->DosNameCreated) == FALSE) {
        RtlInitUnicodeString(&dosUnicodeString, 
                             ISCSI_DOS_DEVICE_NAME);

        //
        // Recreate the deviceName
        //
        RtlInitUnicodeString(&deviceName,
                             ISCSI_DEVICE_NAME);

        status = IoAssignArcName(&dosUnicodeString,
                                 &deviceName);
        if (NT_SUCCESS(status)) {
             commonExtension->DosNameCreated = TRUE;
        } else {
             commonExtension->DosNameCreated = FALSE;
        }
    }
    
    //
    // Initialize the entry points for this device
    //
    iScsiPortInitializeDispatchTables();
    commonExtension->MajorFunction = FdoMajorFunctionTable;

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ObDereferenceObject(lowerDevice);

    DebugPrint((3, "Add Device was successful\n"));
    return STATUS_SUCCESS;
}


VOID
iScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PISCSIPORT_DRIVER_EXTENSION driverExtension;

    driverExtension = IoGetDriverObjectExtension( DriverObject,
                                                  (PVOID)ISCSI_TAG_DRIVER_EXTENSION);
    if (driverExtension != NULL) {
        ExFreePool(driverExtension->RegistryPath.Buffer);
        driverExtension->RegistryPath.Buffer = NULL;
        driverExtension->RegistryPath.Length = 0;
        driverExtension->RegistryPath.MaximumLength = 0;
    }

    return;
}


NTSTATUS
iScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG isRemoved;
    BOOLEAN forwardIrp = FALSE;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((3, "FdoPnp for DeviceObject %x, Irp %x, MinorFunction %x\n",
                DeviceObject, Irp, (irpStack->MinorFunction)));

    isRemoved = iSpAcquireRemoveLock(DeviceObject, Irp);

    if (isRemoved) {

        iSpReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE: {

            status = iSpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                           Irp);

            RtlInitUnicodeString(&(fdoExtension->IScsiInterfaceName), NULL);
            status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                          (LPGUID) &iScsiServerGuid,
                          NULL,
                          &(fdoExtension->IScsiInterfaceName));
            if (!NT_SUCCESS(status)) {
                RtlInitUnicodeString(&(fdoExtension->IScsiInterfaceName), NULL);
            } else {
                status = IoSetDeviceInterfaceState(&(fdoExtension->IScsiInterfaceName),
                                                   TRUE);
            }

            DebugPrint((3, "Status from StartDevice : %x\n",
                        status));

            break;
        }

        case IRP_MN_QUERY_STOP_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }
    
        case IRP_MN_CANCEL_STOP_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }

        case IRP_MN_STOP_DEVICE: {

            //
            // Should stop the network and set state here
            //
            status = STATUS_SUCCESS;
            if (commonExtension->IsServerNodeSetup) {
                status = iSpStopNetwork(DeviceObject);
                commonExtension->IsServerNodeSetup = FALSE;
            }

            status = iSpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                           Irp);
            Irp->IoStatus.Status = status;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            break;
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }
    
        case IRP_MN_CANCEL_REMOVE_DEVICE: {
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            forwardIrp = TRUE;
            break;
        }

        case IRP_MN_REMOVE_DEVICE: {

            //
            // If network node hasn't been released yet,
            // release it now
            //
            if (commonExtension->IsServerNodeSetup) {
                iSpStopNetwork(DeviceObject);
                commonExtension->IsServerNodeSetup = FALSE;
            }

            iSpReleaseRemoveLock(DeviceObject, Irp);
            commonExtension->IsRemoved = REMOVE_PENDING;

            DebugPrint((0, "Waiting for remove event.\n"));
            KeWaitForSingleObject(&(commonExtension->RemoveEvent),
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            DebugPrint((0, "Will process remove now.\n"));

            status = iSpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                           Irp);

            if ((fdoExtension->IScsiInterfaceName.Buffer) != NULL) {
                IoSetDeviceInterfaceState(&(fdoExtension->IScsiInterfaceName),
                                          FALSE);
                RtlFreeUnicodeString(&(fdoExtension->IScsiInterfaceName));
                RtlInitUnicodeString(&(fdoExtension->IScsiInterfaceName), NULL);
            }

            if (fdoExtension->ServerNodeInfo) {
                ExFreePool(fdoExtension->ServerNodeInfo);
                fdoExtension->ServerNodeInfo = NULL;
            }

            if (commonExtension->DosNameCreated) {
                UNICODE_STRING dosDeviceName;
                RtlInitUnicodeString(&dosDeviceName,
                                     ISCSI_DOS_DEVICE_NAME);
                IoDeleteSymbolicLink(&dosDeviceName);
                commonExtension->DosNameCreated = FALSE;
            }

            IoDetachDevice(commonExtension->LowerDeviceObject);

            IoDeleteDevice(commonExtension->DeviceObject);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            return status;

            break;
        }
    
        default:   {
            forwardIrp = TRUE;
            break;
        }
    } // switch (irpStack->MinorFunction)

    iSpReleaseRemoveLock(DeviceObject, Irp);

    if (forwardIrp == TRUE) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(commonExtension->LowerDeviceObject,
                            Irp);
    } else {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
iSpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    KEVENT event;

    PAGED_CODE();

    if (DeviceObject == NULL) {
        DebugPrint((0, "DeviceObject NULL. Irp %x\n",
                    Irp));
        return Irp->IoStatus.Status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           iSpSetEvent,
                           &event,
                           TRUE, 
                           TRUE,
                           TRUE);
    status = IoCallDriver(DeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\sysutils.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    sysutils.c

Abstract:

    This file contains system utility routines

Environment:

    kernel mode only

Revision History:

--*/
#include <ntos.h>

VOID
iSpAttachProcess(
    IN PEPROCESS Process
    )
{
    KeAttachProcess((PKPROCESS) Process);
    return;
}

VOID
iSpDetachProcess(
    VOID
    )
{
    KeDetachProcess ();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\protocol.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    protocol.c

Abstract:

    This file contains iSCSI protocol related routines.

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

LONG  GlobalSessionID;

BOOLEAN PrintDataBuffer = FALSE;

UCHAR
GetCdbLength(
    IN UCHAR OpCode
    );


NTSTATUS
iSpSendLoginResponse(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PISCSI_CONNECTION iScsiConnection = fdoExtension->ServerNodeInfo;
    PISCSI_LOGIN_RESPONSE iscsiLoginResponse;
    PISCSI_LOGIN_COMMAND  loginCommand;
    NTSTATUS status;
    ULONG bytesSent;
    ULONG tempULong;


    DelayThreadExecution(1);

    IoFreeWorkItem((PIO_WORKITEM) Context);
     
    ASSERT((iScsiConnection != NULL));
    ASSERT((iScsiConnection->Type) == ISCSI_CONNECTION_TYPE);


    loginCommand = (PISCSI_LOGIN_COMMAND)(iScsiConnection->IScsiHeader);
                           
    iscsiLoginResponse = iSpAllocatePool(NonPagedPool,
                                         sizeof(ISCSI_LOGIN_RESPONSE),
                                         ISCSI_TAG_LOGIN_RES);
    if (iscsiLoginResponse == NULL) {
        DebugPrint((0, "Failed to allocate logon response packet\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(iscsiLoginResponse, sizeof(ISCSI_LOGIN_RESPONSE));

    iscsiLoginResponse->OpCode = ISCSIOP_LOGIN_RESPONSE;

    //
    // Copy client's Session ID
    //
    iscsiLoginResponse->ISID[0] = loginCommand->ISID[0];
    iscsiLoginResponse->ISID[1] = loginCommand->ISID[1];

    tempULong = InterlockedIncrement(&GlobalSessionID);
    iscsiLoginResponse->TSID[0] = (UCHAR) ((tempULong & 0xFF00) >> 8);
    iscsiLoginResponse->TSID[1] = (UCHAR) (tempULong & 0xFF);

    iscsiLoginResponse->ExpCmdRN[0] = loginCommand->InitCmdRN[0];
    iscsiLoginResponse->ExpCmdRN[1] = loginCommand->InitCmdRN[1];
    iscsiLoginResponse->ExpCmdRN[2] = loginCommand->InitCmdRN[2];
    iscsiLoginResponse->ExpCmdRN[3] = loginCommand->InitCmdRN[3];

    iscsiLoginResponse->MaxCmdRN[3] = MAX_PENDING_REQUESTS;

    iscsiLoginResponse->InitStatRN[3] = 1;

    iscsiLoginResponse->Status = ISCSI_LOGINSTATUS_ACCEPT;

    GetUlongFromArray((loginCommand->InitCmdRN),
                      (iScsiConnection->ExpCommandRefNum));

    iScsiConnection->MaxCommandRefNum = MAX_PENDING_REQUESTS;

    iScsiConnection->StatusRefNum = 1;

    //
    // Send logon response
    //
    fdoExtension->CurrentProtocolState = PSFullFeaturePhase;
    status = iSpSendData(iScsiConnection->ConnectionDeviceObject,
                         iScsiConnection->ConnectionFileObject,
                         iscsiLoginResponse,
                         sizeof(ISCSI_LOGIN_RESPONSE),
                         &bytesSent);
    if (NT_SUCCESS(status)) {

        DebugPrint((3, 
                    "Send succeeded for logon response. Bytes sent : %d\n", 
                    bytesSent));
    } else {
        DebugPrint((0, "Could not send logon response. Status %x\n",
                    status));

        fdoExtension->CurrentProtocolState = PSLogonFailed;
    }

    return status;
}


VOID
iSpProcessScsiCommand(
    IN PVOID Context
    )
{
    PISCSI_FDO_EXTENSION fdoExtension = (PISCSI_FDO_EXTENSION) Context;
    PISCSI_CONNECTION iScsiConnection = fdoExtension->ServerNodeInfo;
    PISCSI_SCSI_COMMAND  iScsiCommand;
    PISCSI_SCSI_RESPONSE iScsiResponse = NULL;
    PIRP irp = NULL;
    PMDL mdl = NULL;
    PACTIVE_REQUESTS currentRequest;
    PIO_STACK_LOCATION irpStack;
    PCDB cdb;
    SCSI_REQUEST_BLOCK srb;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    ULONG length =0;
    ULONG sizeRequired;
    ULONG inx;
    ULONG bytesSent;
    NTSTATUS status;

    while (TRUE) {

        KeWaitForSingleObject(
            (PVOID) &(iScsiConnection->RequestSemaphore),
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        if ((iScsiConnection->TerminateThread) == TRUE) {

            //
            // This is an indication to terminate this thread
            //
            PsTerminateSystemThread(STATUS_SUCCESS);
        }

        inx = (iScsiConnection->ExpCommandRefNum) % MAX_PENDING_REQUESTS;
        if (inx == 0) {
            inx = MAX_PENDING_REQUESTS;
        }

        DebugPrint((3, "Will process request at index %d\n", inx));

        currentRequest = &(iScsiConnection->ActiveRequests[inx]);

        iScsiCommand = (PISCSI_SCSI_COMMAND) (currentRequest->IScsiHeader);

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        //
        // Set the size of the SCSI Request Block
        //
        srb.Length = SCSI_REQUEST_BLOCK_SIZE;

        srb.Function = SRB_FUNCTION_EXECUTE_SCSI;

        if ((iScsiCommand->TurnOffAutoSense) == FALSE) {
            srb.SenseInfoBuffer = currentRequest->SenseData;

            srb.SenseInfoBufferLength = SENSE_BUFFER_SIZE;
        }

        //
        // Get the CDB Length based on the CDB OpCode
        //
        srb.CdbLength = GetCdbLength(iScsiCommand->Cdb[0]);

        cdb = (PCDB)(srb.Cdb);
        RtlCopyMemory(cdb, iScsiCommand->Cdb, srb.CdbLength);

        //
        // Set DataBuffer pointer to the command buffer in
        // the current request.
        //
        srb.DataBuffer = currentRequest->CommandBuffer;

        GetUlongFromArray((iScsiCommand->Length),
                          length);
        if (length == 0) {
            DebugPrint((3, "Length 0. Probably READ command\n"));
            GetUlongFromArray((iScsiCommand->ExpDataXferLength),
                              length);
        }

        //
        // If length is non-zero at this point, then it's
        // either a Read (ExpDataXferLength is non-zero), or
        // Write (Immediate data length is non-zero) command.
        //
        if (length != 0) {
            DebugPrint((3, "Read or Write data command\n"));

            //
            // Set the transfer length.
            //
            srb.DataTransferLength = length;

        }

        if (iScsiCommand->Read) {

            srb.SrbFlags = SRB_FLAGS_DATA_IN;

        } else if (length != 0) {

            //
            // If length is Non-Zero and Read bit is
            // NOT set, then it should be a Write command
            //
            srb.SrbFlags = SRB_FLAGS_DATA_OUT;

        }

        switch (iScsiCommand->ATTR) {
            case ISCSI_TASKATTR_UNTAGGED: 
            case ISCSI_TASKATTR_SIMPLE : {
                srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;
                break;
            }

            case ISCSI_TASKATTR_ORDERED: {
                srb.QueueAction = SRB_ORDERED_QUEUE_TAG_REQUEST;
                break;
            }

            case ISCSI_TASKATTR_HEADOFQUEUE: {
                srb.QueueAction = SRB_HEAD_OF_QUEUE_TAG_REQUEST;
                break;
            }

            default: {
                srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;
                break;
            }
        }

        srb.QueueTag = SP_UNTAGGED;

        SET_FLAG(srb.SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
        SET_FLAG(srb.SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

        //
        // Set the event object to the unsignaled state.
        // It will be used to signal request completion.
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Build device I/O control request with METHOD_NEITHER data transfer.
        // We'll queue a completion routine to cleanup the MDL's and such ourself.
        //

        irp = IoAllocateIrp(
                (CCHAR) (fdoExtension->CommonExtension.LowerDeviceObject->StackSize + 1),
                FALSE);

        if(irp == NULL) {

            DebugPrint((0, "Failed to allocate Irp\n"));

            //
            // ISSUE : Should handle this failure better
            //
            continue;
        }

        //
        // Get next stack location.
        //

        irpStack = IoGetNextIrpStackLocation(irp);

        //
        // Set up SRB for execute scsi request. Save SRB address in next stack
        // for the port driver.
        //

        irpStack->MajorFunction = IRP_MJ_SCSI;
        irpStack->Parameters.Scsi.Srb = &srb;

        IoSetCompletionRoutine(irp,
                               iSpSendSrbSynchronousCompletion,
                               &srb,
                               TRUE,
                               TRUE,
                               TRUE);

        irp->UserIosb = &ioStatus;
        irp->UserEvent = &event;

        if (srb.DataTransferLength) {
            //
            // Build an MDL for the data buffer and stick it into the irp.  The
            // completion routine will unlock the pages and free the MDL.
            //

            irp->MdlAddress = IoAllocateMdl(srb.DataBuffer,
                                            length,
                                            FALSE,
                                            FALSE,
                                            irp );
            if (irp->MdlAddress == NULL) {
                IoFreeIrp( irp );

                DebugPrint((0, "Failed to allocate MDL\n"));

                //
                // ISSUE : Should handle this failure better
                //
                continue;
            }

            try {

                MmProbeAndLockPages( irp->MdlAddress,
                                     KernelMode,
                                     (iScsiCommand->Read ? IoWriteAccess :
                                      IoWriteAccess));

            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();

                IoFreeMdl(irp->MdlAddress);

                IoFreeIrp( irp );

                DebugPrint((0,
                            "Could not lock pages. Status : %x\n",
                            status));

                //
                // ISSUE : Should handle this failure better
                //
                continue;
            }
        }

        //
        // Set timeout value for this request.
        //
        // N.B. The value should be chosen depending on
        // the type of the device, and type of command.
        // For now, just set some reasonable value
        //
        srb.TimeOutValue = 180;

        //
        // Zero out status.
        //

        srb.ScsiStatus = srb.SrbStatus = 0;

        srb.NextSrb = 0;

        //
        // Set up IRP Address.
        //

        srb.OriginalRequest = irp;

        //
        // Call the port driver with the request and wait for it to complete.
        //

        status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        //
        // Send the response to the client
        //
        sizeRequired = sizeof(ISCSI_SCSI_RESPONSE);
        if (!NT_SUCCESS(status)) {

            if (status == STATUS_BUFFER_OVERFLOW) {

                if (length >= srb.DataTransferLength) {
                    DebugPrint((1, "DataUnderrun. Xp Len %d, XFer Len %d\n",
                                length, srb.DataTransferLength));

                    status = STATUS_SUCCESS;

                    sizeRequired += srb.DataTransferLength;
                    length = srb.DataTransferLength;
                } else {
                    DebugPrint((0, 
                                "Buffer overflow error. XLen %d, XFer Len %d\n",
                                length, srb.DataTransferLength));

                    sizeRequired += srb.SenseInfoBufferLength;
                    length = srb.SenseInfoBufferLength;
                }

            } else {
                DebugPrint((0, 
                            "Command failed. OpCode : 0x%x, Status : 0x%x\n",
                            srb.Cdb[0], 
                            status));

                DebugPrint((1, "Expected length : %d, Transfered length : %d\n",
                            length, srb.DataTransferLength));

                sizeRequired += srb.SenseInfoBufferLength;
                length = srb.SenseInfoBufferLength;
            }

        } else if (iScsiCommand->Read) {

            ASSERT((length >= srb.DataTransferLength));

            sizeRequired += srb.DataTransferLength;
            length = srb.DataTransferLength;

        } else {

            length = 0;

        }

        DebugPrint((3, "Size of the response - %d. \n", sizeRequired));

        if ((PrintDataBuffer == TRUE) && (length != 0)) {

            for (inx = 0; inx < length; inx++) {
                DebugPrint((0, "%02x ", 
                            (((PUCHAR)(srb.DataBuffer))[inx])));
                if ((inx != 0) && ((inx % 16) == 0)) {
                    DebugPrint((0, "\n"));
                }
            }

            DebugPrint((0, "\n"));
        }

        iScsiResponse = iSpAllocatePool(NonPagedPool,
                                        sizeRequired,
                                        ISCSI_TAG_SCSIRES);
        if (iScsiResponse != NULL) {

            RtlZeroMemory(iScsiResponse, sizeRequired);

            iScsiResponse->OpCode = ISCSIOP_SCSI_RESPONSE;

            CopyFourBytes((iScsiResponse->TaskTag),
                          (iScsiCommand->TaskTag));

            if (NT_SUCCESS(status)) {

                iScsiResponse->CmdStatus = SCSISTAT_GOOD;
                iScsiResponse->iSCSIStatus = ISCSISTAT_GOOD;

            } else {

                DebugPrint((1, "Error. Response data size : %d\n",
                            sizeRequired));

                iScsiResponse->CmdStatus = SCSISTAT_CHECK_CONDITION;
                iScsiResponse->iSCSIStatus = ISCSISTAT_CHECK_CONDITION;
            }

            SetUlongInArray((iScsiResponse->StatusRN),
                            (iScsiConnection->StatusRefNum));
            (iScsiConnection->StatusRefNum)++;

            (iScsiConnection->ExpCommandRefNum)++;
            SetUlongInArray((iScsiResponse->ExpCmdRN),
                            (iScsiConnection->ExpCommandRefNum));

            SetUlongInArray((iScsiResponse->MaxCmdRN),
                            (iScsiConnection->ExpCommandRefNum) +
                            (MAX_PENDING_REQUESTS) - 1);

            if (!NT_SUCCESS(status)) {

                if (srb.SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
                    DebugPrint((1, "Sense Data is valid\n"));

                    if ((iScsiCommand->TurnOffAutoSense) == FALSE) {
                        ULONG inx;
                        RtlCopyMemory((iScsiResponse + 1),
                                      srb.SenseInfoBuffer,
                                      srb.SenseInfoBufferLength);

                        DebugPrint((0, "OpCode : %x, Sense Data : ",
                                    srb.Cdb[0]));
                        for (inx = 0; inx < (srb.SenseInfoBufferLength); inx++) {
                            DebugPrint((0, "%02x ", ((PUCHAR)(srb.SenseInfoBuffer))[inx]));
                        }
                        DebugPrint((0, "\n"));

                        SetUlongInArray((iScsiResponse->Length),
                                        srb.SenseInfoBufferLength);

                        iScsiResponse->SenseDataLength[0] = 
                            (UCHAR) ((srb.SenseInfoBufferLength) & 0x0000FF00);
                        iScsiResponse->SenseDataLength[1] = 
                            (UCHAR) ((srb.SenseInfoBufferLength) & 0x000000FF);
                    }

                } else {
                    ULONG inx0, inx1;
                    PUCHAR responseBuffer = (PUCHAR) iScsiResponse;

                    DebugPrint((0, "Sense Data is NOT valid\n"));

                    length = 0;
                    sizeRequired = sizeof(ISCSI_SCSI_RESPONSE);

                    DebugPrint((1, "\n Beginning Of Data\n"));

                    inx0 = 0;

                    while (inx0 < sizeRequired) {

                        inx1 = 0;

                        DebugPrint((1, "\t"));

                        while ((inx1 < 4) && ((inx0+inx1) < sizeRequired)) {

                            DebugPrint((1, "%02x ", 
                                        responseBuffer[inx0+inx1]));

                            inx1++;

                        }

                        DebugPrint((1, "\n"));
            
                        inx0 += 4;
                    }

                    DebugPrint((1, " End Of Data\n"));
                }

            } else if (length != 0) {

                RtlCopyMemory((iScsiResponse + 1),
                              srb.DataBuffer,
                              length);

                SetUlongInArray((iScsiResponse->Length),
                                length);

                iScsiResponse->ResponseLength[0] = (UCHAR) (length & 0x0000FF00);
                iScsiResponse->ResponseLength[1] = (UCHAR) (length & 0x000000FF);

            }  

            status = iSpSendData(iScsiConnection->ConnectionDeviceObject,
                                 iScsiConnection->ConnectionFileObject,
                                 iScsiResponse,
                                 sizeRequired,
                                 &bytesSent);
            if (NT_SUCCESS(status)) {
                DebugPrint((3, 
                            "Successfully sent SCSI Response. Bytes sent : %d\n",
                            bytesSent));
            } else {
                DebugPrint((0, "Failed to send SCSI response. Status : 0x%x\n",
                            status));
            }
        }

        if (irp->MdlAddress) {
            MmUnlockPages(irp->MdlAddress);

            IoFreeMdl(irp->MdlAddress);
        }

        IoFreeIrp( irp );
    }

    return;
}


NTSTATUS
iSpSendSrbSynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    *(Irp->UserIosb) = Irp->IoStatus;

    //
    // Signal the caller's event.
    //

    KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


UCHAR
GetCdbLength(
    IN UCHAR OpCode
    )
{
    UCHAR commandGroup;

    commandGroup = (OpCode >> 5) & 0x07;
    DebugPrint((3, "Command Group - %d\n", commandGroup));

    switch (commandGroup) {
        case COMMAND_GROUP_0: {
            return CDB6GENERIC_LENGTH;
        }

        case COMMAND_GROUP_1: 
        case COMMAND_GROUP_2: {
            return CDB10GENERIC_LENGTH;
        }

        case COMMAND_GROUP_5: {
            return CDB12GENERIC_LENGTH;
        }
    
        default: {
            ASSERTMSG("Unknown CDB Opcode type\n", 
                      FALSE);
        }
    } // switch (commandGroup) 

    return 0;
}


ULONG
iSpGetActiveClientRequestIndex(
    IN PISCSI_CONNECTION IScsiConnection,
    IN PISCSI_SCSI_COMMAND IScsiCommand
    )
{
    ULONG cmdRefNum;
    ULONG expCmdRefNum;
    ULONG inx;

    GetUlongFromArray((IScsiCommand->CmdRN), 
                      cmdRefNum);

    expCmdRefNum = IScsiConnection->ExpCommandRefNum;

    if ((cmdRefNum < expCmdRefNum) ||
        (cmdRefNum >=  (expCmdRefNum + MAX_PENDING_REQUESTS))) {

        DebugPrint((0, "Unexpected Command Ref Num : %d",
                    cmdRefNum));
        ASSERT(FALSE);
    }

    inx = cmdRefNum % MAX_PENDING_REQUESTS;
    if (inx == 0) {
        inx = MAX_PENDING_REQUESTS;
    }

    DebugPrint((3, "Will copy request to slot %d\n", inx));

    return inx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\port.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    port.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    iSCSI port driver.

Revision History:

--*/

#ifndef _PORT_H_
#define _PORT_H_

#include "iscsi.h"

extern PDRIVER_DISPATCH FdoMajorFunctionTable[];

#ifdef countof
#undef
#endif
#define countof(x) (sizeof(x) / sizeof((x)[0]))

#define ntohs(x)    (((x & 0xFF) << 8) | (( x >> 8) & 0xFF))

#define ntohl(x)    ((((x >>  0) & 0xFF) << 24) | \
                     (((x >>  8) & 0xFF) << 16) | \
                     (((x >> 16) & 0xFF) <<  8) | \
                     (((x >> 24) & 0xFF) <<  0))
                     
#define htonl(x)   ((((x) >> 24) & 0x000000FFL) | \
                    (((x) >>  8) & 0x0000FF00L) | \
                    (((x) <<  8) & 0x00FF0000L) | \
                    (((x) << 24) & 0xFF000000L));
                    
#define htons(x)   ((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))

#define INLINE __inline

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#define TEST(Value)             ((BOOLEAN) ((Value) ? TRUE : FALSE));

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
VOID
iScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x) iScsiDebugPrint x
#else
#define DebugPrint(x)
#endif

#define iSCSI_SERVER_GUID {0x2581dcfa, 0x7704, 0x47e2, {0xa4, 0xc0, 0x3b, 0x2b, 0x7b, 0xc0, 0x4a, 0x60}}

#define TDI_QUERY_ADDRESS_LENGTH_IP (sizeof(TDI_ADDRESS_INFO) - 1 \
                                     + TDI_ADDRESS_LENGTH_IP)
                                     
#define FILE_FULL_EA_INFO_ADDR_LENGTH FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) \
                                      + TDI_TRANSPORT_ADDRESS_LENGTH + 1 \
                                      + sizeof(TA_IP_ADDRESS)
                                      
#define FILE_FULL_EA_INFO_CEP_LENGTH  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) \
                                      + TDI_CONNECTION_CONTEXT_LENGTH + 1 \
                                      + sizeof(CONNECTION_CONTEXT)

#define TDI_IP_ADDRESS_LENGTH        (sizeof (TRANSPORT_ADDRESS) - 1 + \
                                      TDI_ADDRESS_LENGTH_IP)

#define ISCSI_ANY_ADDRESS           0L
#define ISCSI_TARGET_PORT           5003L

//
// IO Control codes for iSCSI server
//
#define IOCTL_ISCSI_BASE  FILE_DEVICE_NETWORK
#define IOCTL_ISCSI_SETUP_SERVER   CTL_CODE(IOCTL_ISCSI_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ISCSI_CLOSE_SERVER   CTL_CODE(IOCTL_ISCSI_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Size of an ISCSI packet
//
#define ISCSI_PACKET_SIZE   48

//
// Tag for iScsiPort
//
#define ISCSI_TAG_GENERIC            '00Si'
#define ISCSI_TAG_DRIVER_EXTENSION   '10Si'
#define ISCSI_TAG_REGPATH            '20Si'
#define ISCSI_TAG_CONNECTION         '30Si'
#define ISCSI_TAG_LOGIN_CMD          '40si'
#define ISCSI_TAG_LOGIN_RES          '50si'
#define ISCSI_TAG_SCSI_CMD_BUFF      '60si'
#define ISCSI_TAG_PNP_ID             '70si'
#define ISCSI_TAG_SENSEBUFF          '80si'
#define ISCSI_TAG_SCSICMD            '90si'
#define ISCSI_TAG_SCSIRES            'A0si'
#define ISCSI_TAG_READBUFFER         'B0si'

//
// Device name
//
#define ISCSI_DEVICE_NAME      L"\\Device\\iScsiServer"
#define ISCSI_DOS_DEVICE_NAME  L"\\DosDevices\\iScsiServer"

//
// Type for ISCSI_CONNECTION struct
//
#define ISCSI_CONNECTION_TYPE  0xACAC

//
// Maximum number of requests that can be queued 
// on the server. This value is returned to the 
// client in Login Response packet
//
#define MAX_PENDING_REQUESTS   10

//
// Preallocated buffer size for processing SCSI Commands
//
// 32K for immediate data
//
#define ISCSI_SCSI_COMMAND_BUFF_SIZE  32768 

//
// Temp buffer size used during read
//
#define READ_BUFFER_SIZE 4096

//
// Value for IsRemoved
//
#define NO_REMOVE       0
#define REMOVE_PENDING  1
#define REMOVE_COMPLETE 2
                                        
//
// Forward declarations
//
typedef struct _ISCSI_LOGIN_COMMAND ISCSI_LOGIN_COMMAND, *PISCSI_LOGIN_COMMAND;
typedef struct _ISCSI_LOGIN_RESPONSE ISCSI_LOGIN_RESPONSE, *PISCSI_LOGIN_RESPONSE;
typedef struct _ISCSI_SCSI_COMMAND ISCSI_SCSI_COMMAND, *PISCSI_SCSI_COMMAND;
typedef struct _ISCSI_SCSI_RESPONSE ISCSI_SCSI_RESPONSE, *PISCSI_SCSI_RESPONSE;
typedef struct _ISCSI_GENERIC_HEADER ISCSI_GENERIC_HEADER, *PISCSI_GENERIC_HEADER;

typedef enum _ISCSI_RECEIVE_STATE {
    ReceiveHeader = 1,
    ReceiveData
} ISCSI_RECEIVE_STATE, *PISCSI_RECEIVE_STATE;

typedef enum _ISCSI_PROTOCOL_STATE {
    PSNodeInitInProgress,
    PSNodeInitialized,
    PSNodeInitializeFailed,
    PSConnectedToServer,
    PSConnectToServerFailed,
    PSLogonInProgress,
    PSWaitingForLogon,
    PSLogonFailed,
    PSLogonSucceeded,
    PSFullFeaturePhase,
    PSDisconnectPending,
    PSDisconnected
} ISCSI_PROTOCOL_STATE, *PISCSI_PROTOCOL_STATE;

typedef enum _ISCSI_CONNECTION_STATE {
    ConnectionStateConnecting,
    ConnectionStateConnected,
    ConnectionStateStopping,
    ConnectionStateDisconnected,
    ConnectionStateUnknown
} ISCSI_CONNECTION_STATE, *PISCSI_CONNECTION_STATE;

typedef struct _ISCSI_EVENT_HANDLER {
    USHORT EventId;
    PVOID  EventHandler;
} ISCSI_EVENT_HANDLER, *PISCSI_EVENT_HANDLER;


typedef struct _ACTIVE_REQUESTS {
    PDEVICE_OBJECT DeviceObject;

    PUCHAR CommandBuffer;

    ULONG CommandBufferOffset;

    ULONG ExpectedDataLength;

    ULONG ReceivedDataLength;

    UCHAR IScsiHeader[ISCSI_PACKET_SIZE];

    UCHAR SenseData[SENSE_BUFFER_SIZE];

} ACTIVE_REQUESTS, *PACTIVE_REQUESTS;

//
// Represents a connection
//
typedef struct _ISCSI_CONNECTION {
    USHORT Type;

    USHORT Size;

    struct _ISCSI_CONNECTION *Next;

    BOOLEAN TerminateThread;

    BOOLEAN CompleteHeaderReceived;

    ISCSI_CONNECTION_STATE ConnectionState;

    ISCSI_RECEIVE_STATE ReceiveState;

    ULONG ExpCommandRefNum;

    ULONG MaxCommandRefNum;

    ULONG StatusRefNum;

    ULONG IScsiHeaderOffset;

    ULONG RemainingBytes;

    PACTIVE_REQUESTS CurrentRequest;

    PVOID ConnectionHandle;

    PFILE_OBJECT ConnectionFileObject;

    PDEVICE_OBJECT ConnectionDeviceObject;

    PVOID ConnectionContext;

    PVOID AddressHandle;

    PFILE_OBJECT AddressFileObject;

    PDEVICE_OBJECT AddressDeviceObject;

    PDEVICE_OBJECT DeviceObject;

    HANDLE IScsiThread;

    KSEMAPHORE RequestSemaphore;

    ACTIVE_REQUESTS ActiveRequests[MAX_PENDING_REQUESTS + 1];

    UCHAR IScsiHeader[ISCSI_PACKET_SIZE * 3];

    UCHAR ReadBuffer[READ_BUFFER_SIZE];

    TDI_ADDRESS_IP IPAddress;

} ISCSI_CONNECTION, *PISCSI_CONNECTION;

//
// Represents a session (set of connections)
//
typedef struct _ISCSI_SESSION {
    ULONG ConnectionCount;
    PISCSI_CONNECTION Connections;
    PVOID ClientContext;
} ISCSI_SESSION, *PISCSI_SESSION;

typedef struct _ISCSIPORT_DRIVER_EXTENSION {

    //
    // Pointer back to the driver object
    //
    PDRIVER_OBJECT DriverObject;

    //
    // Registrypath info for this driver
    //
    UNICODE_STRING RegistryPath;

} ISCSIPORT_DRIVER_EXTENSION, *PISCSIPORT_DRIVER_EXTENSION;

typedef struct _COMMON_EXTENSION {

    //
    // Back pointer to the device object
    //
    PDEVICE_OBJECT DeviceObject;

    struct {

        //
        // TRUE if the device object is a physical device object
        //
        BOOLEAN IsPdo : 1;

        //
        // TRUE if the device has been initialized
        //
        BOOLEAN IsInitialized : 1;

        //
        // TRUE if the network address has been setup
        //
        BOOLEAN IsServerNodeSetup : 1;

        //
        // TRUE if symbolic name has been created
        //
        BOOLEAN DosNameCreated : 1;
    };

    UCHAR CurrentPnpState;

    UCHAR PreviousPnpState;

    ULONG IsRemoved;

    LONG RemoveLock;

    KEVENT RemoveEvent;

    PDEVICE_OBJECT LowerDeviceObject;

    PDRIVER_DISPATCH *MajorFunction;

    PISCSI_SESSION IScsiSession;
} COMMON_EXTENSION, *PCOMMON_EXTENSION;

typedef struct _ISCSI_FDO_EXTENSION {
    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    BOOLEAN IsServer;

    BOOLEAN IsClient;

    UCHAR CurrentProtocolState;

    PDEVICE_OBJECT LowerPdo;

    PIRP CurrentIrp;

    PISCSI_CONNECTION ServerNodeInfo;

    PISCSI_CONNECTION ClientNodeInfo;

    UNICODE_STRING IScsiInterfaceName;

    UCHAR SavedConnectionID[2];
} ISCSI_FDO_EXTENSION, *PISCSI_FDO_EXTENSION;

//
// Function declarations
//

NTSTATUS
iScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortDispatchUnsupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
iScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
iScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortFdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iScsiPortPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
iScsiPortInitializeDispatchTables();

NTSTATUS
iSpSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
iSpEnumerateDevicesAsynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
iSpStartNetwork(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
iSpStopNetwork(
    IN PDEVICE_OBJECT DeviceObject
    );

PVOID
iSpAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

NTSTATUS
iSpCreateTdiAddressObject(
    IN ULONG  InAddress,
    IN USHORT InPort,
    OUT PVOID *AddrHandle,
    OUT PFILE_OBJECT *AddrFileObject,
    OUT PDEVICE_OBJECT *AddrDeviceObject
    );

NTSTATUS
iSpCreateTdiConnectionObject(
    IN PWCHAR DeviceName,
    IN CONNECTION_CONTEXT ConnectionContext,
    OUT PVOID *ConnectionHandle,
    OUT PFILE_OBJECT *ConnectionFileObject,
    OUT PDEVICE_OBJECT *ConnectionDeviceObject
    );

NTSTATUS
iSpTdiAssociateAddress(
    IN PIRP Irp,
    IN PVOID AddrHandle,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    );

NTSTATUS
iSpTdiSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iSpTdiSetEventHandler(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER eventsToSet,
    IN ULONG CountOfEvents,
    IN PVOID EventContext
    );

NTSTATUS
iSpTdiResetEventHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PISCSI_EVENT_HANDLER EventsToSet,
    IN ULONG CountOfEvents
    );

NTSTATUS
iSpCloseTdiAddress(
    HANDLE AddrHandle,
    PFILE_OBJECT AddrFileObject
    );

NTSTATUS
iSpCloseTdiConnection(
    HANDLE ConnectionHandle,
    PFILE_OBJECT ConnectionFileObject
    );

NTSTATUS
iSpTdiDeviceControl(
    IN PIRP Irp,
    IN PMDL Mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID IrpParameter,
    IN ULONG IrpParameterLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength
    );

NTSTATUS
iSpConnectionHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

NTSTATUS
iSpDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
iSpReceiveHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
iSpTdiQueryInformation(
    IN PDEVICE_OBJECT TdiDeviceObject,
    IN PFILE_OBJECT TdiFileObject,
    IN PTDI_ADDRESS_INFO TdiAddressBuffer,
    IN ULONG TdiAddrBuffLen
    );

NTSTATUS
iSpTdiConnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           TdiIPAddress,
    IN  USHORT          TdiPortNumber,
    IN  LARGE_INTEGER   ConnectionTimeout
    );

NTSTATUS
iSpTdiDisconnect(
    IN  PDEVICE_OBJECT  TdiConnDeviceObject,
    IN  PFILE_OBJECT    TdiConnFileObject,
    IN  ULONG           DisconnectFlags,
    IN  PVOID           CompletionRoutine,
    IN  PVOID           CompletionContext,
    IN  LARGE_INTEGER   DisconnectTimeout
    );
NTSTATUS
iSpAllocateMdlAndIrp(
    IN PVOID Buffer,
    IN ULONG BufferLen,
    IN CCHAR StackSize,
    IN BOOLEAN NonPagedPool,
    OUT PIRP *Irp,
    OUT PMDL *Mdl
    );

VOID
iSpFreeMdlAndIrp(
    IN PMDL Mdl,
    IN PIRP Irp,
    BOOLEAN UnlockPages
    );

NTSTATUS
iSpSetupNetworkNode(
    IN ULONG  InAddress,
    IN USHORT InPort,
    IN PIRP   Irp,
    IN PVOID ConnectionContext,
    OUT PISCSI_CONNECTION ConnectionInfo
    );

NTSTATUS
iSpCloseNetworkNode(
    PISCSI_CONNECTION iScsiConnection
    );

NTSTATUS
iSpTdiDisassociateAddress(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject
    );

NTSTATUS
iSpPerformDeviceEnumeration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
iSpConnectionComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
iSpTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
iSpPerformDisconnect(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PVOID Context
    );

NTSTATUS
iSpSendData(
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN PFILE_OBJECT ConnectionFileObject,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLen,
    OUT PULONG BytesSent
    );

NTSTATUS
iSpProcessReceivedBuffer(
    IN PISCSI_FDO_EXTENSION FdoExtension,
    IN PUCHAR ReadBuffer,
    IN ULONG  BytesRead
    );

ULONG
iSpAcquireRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    );

VOID
iSpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    );


NTSTATUS
iSpSendLoginCommand(
    IN PISCSI_FDO_EXTENSION FdoExtension
    );

NTSTATUS
iSpSendLoginResponse(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

VOID
iSpAttachProcess(
    IN PEPROCESS Process
    );

VOID
iSpDetachProcess(
    VOID
    );

VOID
iSpProcessScsiCommand(
    IN PVOID Context
    );

NTSTATUS
iSpSendSrbSynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
iScsiPortClaimDevice(
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN BOOLEAN Release
    );

ULONG
iSpGetActiveClientRequestIndex(
    IN PISCSI_CONNECTION IScsiConnection,
    IN PISCSI_SCSI_COMMAND IScsiCommand
    );

#endif // _PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\serverapp\serverapp.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#undef NDEBUG
#include <assert.h>

#include <windows.h>
#include <winsock.h>
#include <winioctl.h>

#define SETUP_SERVER  1
#define CLOSE_SERVER  2

#define IOCTL_ISCSI_BASE           FILE_DEVICE_NETWORK
#define IOCTL_ISCSI_SETUP_SERVER   CTL_CODE(IOCTL_ISCSI_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ISCSI_CLOSE_SERVER   CTL_CODE(IOCTL_ISCSI_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

int __cdecl main(int argc, char *argv[])
{
   HANDLE hDevice;
   ULONG  controlCode = 0;
   USHORT choice;
   DWORD nBytes = 0;
   BOOLEAN retVal;

   printf("\nThis program will setup or close iSCSI server node\n");
   printf("\n Select the operation to perform : \n\n");
   printf("     1. Setup server node\n");
   printf("     2. Close server node\n\n");
   printf("     Enter choice (1 or 2) : ");
   scanf("%d", &choice);

   switch (choice) {
       case SETUP_SERVER: {
           printf("\n Will setup iSCSI server\n\n");
           controlCode = IOCTL_ISCSI_SETUP_SERVER;
           break;
       }

       case CLOSE_SERVER: {
           printf("\n Will close iSCSI server\n\n");
           controlCode = IOCTL_ISCSI_CLOSE_SERVER;
           break;
       }

       default:   {
           printf("\n Invalid entry %d. Enter 1 or 2\n", choice);
           return 0;
       }
   } // switch (choice)

   hDevice = CreateFile("\\\\.\\iScsiServer", 
                        (GENERIC_READ | GENERIC_WRITE),
                        (FILE_SHARE_READ | FILE_SHARE_WRITE), 0, 
                        OPEN_EXISTING, 0, NULL
                        );
             
   if (hDevice != INVALID_HANDLE_VALUE) {
       if (!DeviceIoControl(hDevice,
                            controlCode,
                            NULL,
                            0,
                            NULL,
                            0,
                            &nBytes,
                            NULL )) {
           printf(" IOCTL failed. Error %d\n",
                  GetLastError());
       } else {
           printf(" IOCTL succeeded\n");
       }

        CloseHandle(hDevice);
   } else {
      printf(" Invalid Handle on opening iScsi server. Error : %d\n", 
             GetLastError());
   } 
   
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\atapi\help.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    i386kd Extension Api for interpretting ATAPI structures

Author:

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
        {"help",       "displays this message"},
        {"fdoext",     "dumps the specified FDO extension"},
	{"pdoext",     "dumps the specified PDO extension"},
	{"miniext", "dumps the specified miniport extension"},
        {NULL,          NULL}
};

DECLARE_API( help )
{
        int i = 0;

        dprintf("\nATAPI Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("\t%s - \t%s\n", extensions[i].extname, extensions[i].extdesc);
                i++;
        }
    dprintf("\n");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\server\utils.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    utils.c

Abstract:

    Utility routines for iScsi Port driver

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"


PVOID
iSpAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    PVOID Block;
     
    Block = ExAllocatePoolWithTag(PoolType,
                                  NumberOfBytes,
                                  Tag);
    if (Block != NULL) {
        RtlZeroMemory(Block, NumberOfBytes);
    }

    return Block;
}


NTSTATUS
iSpAllocateMdlAndIrp(
    IN PVOID Buffer,
    IN ULONG BufferLen,
    IN CCHAR StackSize,
    IN BOOLEAN NonPagedPool,
    OUT PIRP *Irp,
    OUT PMDL *Mdl
    )
{
    PMDL localMdl = NULL;
    PIRP localIrp = NULL;
    NTSTATUS status;

    //
    // Allocate an MDL for this request
    //
    localMdl = IoAllocateMdl(Buffer,
                             BufferLen,
                             FALSE,
                             FALSE,
                             NULL);
    if (localMdl == NULL) {
        DebugPrint((0, "iSpAllocateMdlAndIrp : Failed to allocate MDL\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the MDL. If the buffer is from NonPaged pool
    // use MmBuildMdlForNonPagedPool. Else, use MmProbeAndLockPages
    //
    if (NonPagedPool == TRUE) {
        MmBuildMdlForNonPagedPool(localMdl);
    } else {

        try {
            MmProbeAndLockPages(localMdl, KernelMode, IoModifyAccess);
        } except(EXCEPTION_EXECUTE_HANDLER) {

              DebugPrint((0, 
                          "iSpAllocateMdlAndIrp : Failed to Lockpaged\n"));
              IoFreeMdl(localMdl);
              return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Allocate an IRP
    //
    localIrp = IoAllocateIrp(StackSize, FALSE);
    if (localIrp == NULL) {
        DebugPrint((0, "iSpAllocateMdlAndIrp. Failed to allocate IRP\n"));
        IoFreeMdl(localMdl);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DebugPrint((3, "Allocated IRP 0x%08x and MDL 0x%08x\n",
                localIrp, localMdl));

    *Irp = localIrp;
    *Mdl = localMdl;
    return STATUS_SUCCESS;
}


VOID
iSpFreeMdlAndIrp(
    IN PMDL Mdl,
    IN PIRP Irp,
    BOOLEAN UnlockPages
    )
{
    PMDL tmpMdlPtr = NULL;

    if (Irp == NULL) {
        return;
    }

    //
    // Free any MDLs allocated for this IRP
    //
    if (Mdl != NULL) {
        while ((Irp->MdlAddress) != NULL) {
            tmpMdlPtr = (Irp->MdlAddress)->Next;

            if (UnlockPages) {
                MmUnlockPages(Irp->MdlAddress);
            }

            IoFreeMdl(Irp->MdlAddress);
            Irp->MdlAddress = tmpMdlPtr;
        }
    }

    IoFreeIrp(Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\iscsiprt\utils\address.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#undef NDEBUG
#include <assert.h>

#include <windows.h>
#include <winsock.h>
#include <winioctl.h>

int __cdecl main(int argc, char *argv[])
{
   WSADATA wsaData;
   DWORD address, err;
   WORD wVersionRequired;
   UCHAR nameBuff[128];

   if (argc != 2) {
       printf("Usage : address <IP Address>\n");
       return 0;
   }

   wVersionRequired = MAKEWORD(2, 0);
   err = WSAStartup(wVersionRequired, &wsaData);
   if (err != 0) {
       printf("WSAStartup returned %d\n", err);
       return 0;
   }

   printf("Socket initialized. Version : %d, High : %d\n",
          wsaData.wVersion,
          wsaData.wHighVersion);
   address = 0xffffffff;
   strcpy(nameBuff, argv[1]);
   address = inet_addr (nameBuff); 
   printf("Address in STRING : %s. Address in ULONG is 0x%08x\n",
          nameBuff, address);

   WSACleanup();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\atapi\atapikd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    atapikd.c

Abstract:

    Debugger Extension Api for interpretting atapi structures

Author:


Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#include "math.h"
#include "ideport.h"


VOID
AtapiDumpPdoExtension(
    IN ULONG64 PdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
AtapiDumpFdoExtension(
    IN ULONG64 FdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
DumpPdoState(
    IN ULONG Depth,
    IN ULONG State
    );

VOID
DumpFdoState(
    IN ULONG Depth,
    IN ULONG State
    );

#ifdef ENABLE_COMMAND_LOG
    VOID
    DumpCommandLog(
          IN ULONG Depth,
          IN ULONG64 SrbDataAddr
          );
#else
    #define DumpCommandLog(a, b)
#endif


VOID
DumpIdentifyData(
      IN ULONG Depth, 
      IN PIDENTIFY_DATA IdData
      );

PUCHAR DMR_Reason[] = {
   "",
   "Enum Failed",
   "Reported Missing",
   "Too Many Timeout",
   "Killed PDO",
   "Replaced By User"
};

PUCHAR DeviceType[] = {
   "DIRECT_ACCESS_DEVICE",
   "SEQUENTIAL_ACCESS_DEVICE",
   "PRINTER_DEVICE",
   "PROCESSOR_DEVICE",
   "WRITE_ONCE_READ_MULTIPLE_DEVICE",
   "READ_ONLY_DIRECT_ACCESS_DEVICE",
   "SCANNER_DEVICE",
   "OPTICAL_DEVICE",
   "MEDIUM_CHANGER",
   "COMMUNICATION_DEVICE"
};

PUCHAR PdoState[] = {
   "PDOS_DEVICE_CLAIMED",
   "PDOS_LEGACY_ATTACHER",
   "PDOS_STARTED",
   "PDOS_STOPPED",
   "PDOS_SURPRISE_REMOVED",
   "PDOS_REMOVED",
   "PDOS_DEADMEAT",
   "PDOS_NO_POWER_DOWN",
   "PDOS_QUEUE_FROZEN_BY_POWER_DOWN",
   "PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM",
   "PDOS_QUEUE_FROZEN_BY_STOP_DEVICE",
   "PDOS_QUEUE_FROZEN_BY_PARENT",
   "PDOS_QUEUE_FROZEN_BY_START",
   "PDOS_DISABLED_BY_USER",
   "PDOS_NEED_RESCAN",
   "PDOS_REPORTED_TO_PNP",
   "PDOS_INITIALIZED"
};

PUCHAR FdoState[] = {
   "FDOS_DEADMEAT",
   "FDOS_STARTED",
   "FDOS_STOPPED"
};

#define MAX_PDO_STATES 16
#define MAX_FDO_STATES  3

DECLARE_API(pdoext)

/*++

Routine Description:

    Dumps the pdo extension for a given device object, or dumps the
    given pdo extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 devObjAddr = 0;
    ULONG detail = 0;

   
    GetAddressAndDetailLevel64(args, &devObjAddr, &detail);

    if (devObjAddr){
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");

        if (objType == IO_TYPE_DEVICE){
            ULONG64 pdoExtAddr;

            pdoExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (pdoExtAddr != BAD_VALUE){
                AtapiDumpPdoExtension(pdoExtAddr, detail, 0);
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
        }
    }
    else {
        dprintf("\n usage: !atapikd.pdoext <atapi pdo> \n\n");
    }
    
    return S_OK;
}


VOID
AtapiDumpPdoExtension(
    IN ULONG64 PdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    UCHAR scsiDeviceType;
    ULONG pdoState;
    ULONG luFlags;
    ULONG64 attacheePdo;
    ULONG64 idleCounterAddr;
    ULONG64 srbDataAddr;
    ULONG devicePowerState, systemPowerState;
    
    xdprintf(Depth, ""), dprintf("\nATAPI physical device extension at address 0x%08p\n\n", PdoExtAddr);

    Depth++;

    scsiDeviceType = GetUCHARField(PdoExtAddr, "atapi!_PDO_EXTENSION", "ScsiDeviceType");
    pdoState = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "PdoState");
    luFlags = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "LuFlags");
    attacheePdo = GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "AttacheePdo");
    idleCounterAddr = GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "IdleCounter");
    srbDataAddr = GetFieldAddr(PdoExtAddr, "atapi!_PDO_EXTENSION", "SrbData");
    devicePowerState = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "DevicePowerState");
    systemPowerState = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "SystemPowerState");
    
    if ((scsiDeviceType != BAD_VALUE) && (pdoState != BAD_VALUE) && (luFlags != BAD_VALUE) &&
        (attacheePdo != BAD_VALUE) && (idleCounterAddr != BAD_VALUE) && (srbDataAddr != BAD_VALUE) &&
        (devicePowerState != BAD_VALUE) && (systemPowerState != BAD_VALUE)){

        ULONG idlecount;
        
        if ((scsiDeviceType >= 0) && (scsiDeviceType <= 9)) {
           xdprintf(Depth, ""), dprintf("SCSI Device Type : %s\n", DeviceType[scsiDeviceType]);
        } 
        else {
           xdprintf(Depth, ""), dprintf("Connected to Unknown Device\n");
        }

        DumpPdoState(Depth, pdoState);

        dprintf("\n");
        DumpFlags(Depth, "LU Flags", luFlags, LuFlags);

        xdprintf(Depth, ""), dprintf("PowerState (D%d, S%d)\n", devicePowerState-1, systemPowerState-1);

        if (idleCounterAddr){
            ULONG resultLen = 0;
            ReadMemory(idleCounterAddr, &idlecount, sizeof(ULONG), &resultLen);
            if (resultLen != sizeof(ULONG)){
                idlecount = 0;
            }
        } 
        else {
            idlecount = 0;
        }
        xdprintf(Depth, ""), dprintf("IdleCounter 0x%08x\n", idlecount);

        xdprintf(Depth, ""), dprintf("SrbData: (use ' dt atapi!_SRB_DATA %08p ')\n", srbDataAddr);
       
        dprintf("\n");
        xdprintf(Depth, ""), dprintf("(for more info, use ' dt atapi!_PDO_EXTENSION %08p ')\n", PdoExtAddr);
                    
        #ifdef LOG_DEADMEAT_EVENT
            {
                ULONG deadmeatReason;
                deadmeatReason = (ULONG)GetULONGField(PdoExtAddr, "atapi!_PDO_EXTENSION", "DeadmeatRecord.Reason");
                if ((deadmeatReason != BAD_VALUE) && (deadmeatReason > 0)){
                    dprintf("\n");
                    xdprintf(Depth, "Deadmeat Record: \n");
                    xdprintf(Depth+1, "Reason : %s\n", DMR_Reason[deadmeatReason]);
                    xdprintf(Depth+1, ""), dprintf("(for more info, use ' dt -r atapi!_PDO_EXTENSION %08p ')\n", PdoExtAddr);
                }
            }
        #endif 

        #ifdef ENABLE_COMMAND_LOG
            DumpCommandLog(Depth, srbDataAddr);
        #endif

    }
    
    dprintf("\n");

    
}


VOID DumpPdoState(IN ULONG Depth, IN ULONG State)
{
    int inx, statebit, count;

    count = 0;
    xdprintf(Depth, ""), dprintf("PDO State (0x%08x): \n", State);
   
    if (State & 0x80000000) {
        xdprintf(Depth+1, "Initialized ");
        count++;
    }

    for (inx = 0; inx < MAX_PDO_STATES; inx++) {
        statebit = (1 << inx);
        if (State & statebit) {
            xdprintf(Depth+1, "%s ", PdoState[inx]);
            count++;
            if ((count % 2) == 0) {
                dprintf("\n");
            }
        }
   }

   dprintf("\n");
}



DECLARE_API(fdoext)

/*++

Routine Description:

    Dumps the fdo extension for a given device object, or dumps the
    given fdo extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 devObjAddr;
    ULONG detail = 0;

    GetAddressAndDetailLevel64(args, &devObjAddr, &detail);
    if (devObjAddr){
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");

        if (objType == IO_TYPE_DEVICE){
            ULONG64 fdoExtAddr;

            fdoExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (fdoExtAddr != BAD_VALUE){
                AtapiDumpFdoExtension(fdoExtAddr, detail, 0);
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
        }
    }
    else {
        dprintf("\n usage: !atapikd.pdoext <atapi pdo> \n\n");
    }

    return S_OK;
}


DECLARE_API(miniext)

/*++

Routine Description:

    Dumps the Miniport device extension at the given address

Arguments:

    args - string containing the address of the miniport extension

Return Value:

    none

--*/

{
    ULONG64 hwDevExtAddr;
    ULONG Depth = 1;
    ULONG detail;
    
    GetAddressAndDetailLevel64(args, &hwDevExtAddr, &detail);

    if (hwDevExtAddr){
        ULONG64 deviceFlagsArrayAddr;
        ULONG64 lastLunArrayAddr;
        ULONG64 timeoutCountArrayAddr;
        ULONG64 numberOfCylindersArrayAddr;
        ULONG64 numberOHeadsArrayAddr;
        ULONG64 sectorsPerTrackArrayAddr;
        ULONG64 maxBlockTransferArrayAddr;
        ULONG64 identifyDataArrayAddr;
        
        deviceFlagsArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "DeviceFlags");
        lastLunArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "LastLun");
        timeoutCountArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "TimeoutCount");
        numberOfCylindersArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "NumberOfCylinders");
        numberOHeadsArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "NumberOfHeads");
        sectorsPerTrackArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "SectorsPerTrack");
        maxBlockTransferArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "MaximumBlockXfer");
        identifyDataArrayAddr = GetFieldAddr(hwDevExtAddr, "atapi!_HW_DEVICE_EXTENSION", "IdentifyData");

        if ((deviceFlagsArrayAddr != BAD_VALUE) && (lastLunArrayAddr != BAD_VALUE) &&
            (timeoutCountArrayAddr != BAD_VALUE) && (numberOfCylindersArrayAddr != BAD_VALUE) &&
            (numberOHeadsArrayAddr != BAD_VALUE) && (sectorsPerTrackArrayAddr != BAD_VALUE) &&
            (maxBlockTransferArrayAddr != BAD_VALUE) && (identifyDataArrayAddr != BAD_VALUE)){
            
            ULONG deviceFlagsArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG lastLunArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG timeoutCountArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG numberOfCylindersArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG numberOfHeadsArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            ULONG sectorsPerTrackArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            UCHAR maxBlockTransferArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            IDENTIFY_DATA identifyDataArray[MAX_IDE_DEVICE * MAX_IDE_LINE];
            
            
            ULONG resultLen;
            BOOLEAN ok;
            
            xdprintf(Depth, ""), dprintf("\nATAPI Miniport Device Extension at address 0x%08p\n\n", hwDevExtAddr);

            /*
             *  Read in arrays of info for child LUNs
             */
            ok = TRUE;
            if (ok) ok = (BOOLEAN)ReadMemory(deviceFlagsArrayAddr, (PVOID)deviceFlagsArray, sizeof(deviceFlagsArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(lastLunArrayAddr, (PVOID)lastLunArray, sizeof(lastLunArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(timeoutCountArrayAddr, (PVOID)timeoutCountArray, sizeof(timeoutCountArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(numberOfCylindersArrayAddr, (PVOID)numberOfCylindersArray, sizeof(numberOfCylindersArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(numberOHeadsArrayAddr, (PVOID)numberOfHeadsArray, sizeof(numberOfHeadsArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(sectorsPerTrackArrayAddr, (PVOID)sectorsPerTrackArray, sizeof(sectorsPerTrackArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(maxBlockTransferArrayAddr, (PVOID)maxBlockTransferArray, sizeof(maxBlockTransferArray), &resultLen);
            if (ok) ok = (BOOLEAN)ReadMemory(identifyDataArrayAddr, (PVOID)identifyDataArray, sizeof(identifyDataArray), &resultLen);
                
            if (ok){
                ULONG i;

                /*
                 *  Display details for each device
                 */
                dprintf("\n");
                for (i = 0; i < (MAX_IDE_DEVICE * MAX_IDE_LINE); i++) {
                    if (deviceFlagsArray[i] & DFLAGS_DEVICE_PRESENT){

                        xdprintf(Depth, "Device %d Details:\n", i);
                        
                        DumpFlags(Depth+1, "Device Flags", deviceFlagsArray[i], DevFlags);

                        xdprintf(Depth+1, "TimeoutCount %u, LastLun %u, MaxBlockXfer 0x%02x\n",
                                                    timeoutCountArray[i], lastLunArray[i], maxBlockTransferArray[i]);

                        xdprintf(Depth+1, "NumCylinders 0x%08x, NumHeads 0x%08x, SectorsPerTrack 0x%08x\n",
                                                    numberOfCylindersArray[i], numberOfHeadsArray[i], sectorsPerTrackArray[i]);

                        /*
                         *  Display DeviceParameters info
                         */
                        dprintf("\n");
                        if (IsPtr64()){
                            xdprintf(Depth+1, "(cannot display DeviceParameters[] info for 64-bit)\n");
                        }
                        else {
                            /*
                             *  DeviceParameters[] is an array of embedded structs.
                             *  Reading this in an architecture-agnostic way would be tricky, 
                             *  so we punt and only do it for 32-bit target and 32-bit debug extension.
                             */
                            #ifdef _X86_
                                HW_DEVICE_EXTENSION hwDevExt;
                                ok = (BOOLEAN)ReadMemory(hwDevExtAddr, (PVOID)&hwDevExt, sizeof(hwDevExt), &resultLen);
                                if (ok){
                                    #define IsInitXferMode(a) ((a == 0x7fffffff) ? -1 : a)
                                    xdprintf(Depth+1, "Device Parameters Summary :\n");
                                    xdprintf(Depth+2, "PioReadCommand 0x%02x, PioWriteCommand 0x%02x\n",
                                                                hwDevExt.DeviceParameters[i].IdePioReadCommand,
                                                                hwDevExt.DeviceParameters[i].IdePioWriteCommand);
                                    xdprintf(Depth+2, "IdeFlushCommand 0x%02x, MaxBytePerPioInterrupt %u\n",
                                                                hwDevExt.DeviceParameters[i].IdeFlushCommand,
                                                                hwDevExt.DeviceParameters[i].MaxBytePerPioInterrupt);
                                    xdprintf(Depth+2, "BestPioMode %d, BestSwDMAMode %d\n",
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestPioMode),
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestSwDmaMode));
                                    xdprintf(Depth+2, "BestMwDMAMode %d, BestUDMAMode %d\n",
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestMwDmaMode),
                                                                IsInitXferMode(hwDevExt.DeviceParameters[i].BestUDmaMode));
                                    xdprintf(Depth+2, "TMSupported 0x%08x, TMCurrent 0x%08x\n",
                                                                hwDevExt.DeviceParameters[i].TransferModeSupported,
                                                                hwDevExt.DeviceParameters[i].TransferModeCurrent);
                                    xdprintf(Depth+2, "TMMask 0x%08x, TMSelected 0x%08x\n",
                                                                hwDevExt.DeviceParameters[i].TransferModeMask,
                                                                hwDevExt.DeviceParameters[i].TransferModeSelected);
                                }
                                else {
                                    dprintf("\n failed to read HW_DEVICE_EXTENSION at 0x%08p\n", hwDevExtAddr);
                                }
                            #else
                                xdprintf(Depth+1, "(64-bit debug extension cannot display DeviceParameters[] info)\n");
                            #endif
                        }

                        /*
                         *  Display Identify Data
                         */
                        dprintf("\n");
                        xdprintf(Depth+1, ""), dprintf("Identify Data Summary :\n");
                        xdprintf(Depth+2, ""), dprintf("Word 1,3,6 (C-0x%04x, H-0x%04x, S-0x%04x) \n",
                                                                    identifyDataArray[i].NumCylinders,
                                                                    identifyDataArray[i].NumHeads,
                                                                    identifyDataArray[i].NumSectorsPerTrack);
                        xdprintf(Depth+2, ""), dprintf("Word 54,55,56 (C-0x%04x, H-0x%04x, S-0x%04x) \n",
                                                                    identifyDataArray[i].NumberOfCurrentCylinders,
                                                                    identifyDataArray[i].NumberOfCurrentHeads,
                                                                    identifyDataArray[i].CurrentSectorsPerTrack);
                        xdprintf(Depth+2, ""), dprintf("CurrentSectorCapacity 0x%08x, UserAddressableSectors 0x%08x\n",
                                                                    identifyDataArray[i].CurrentSectorCapacity,
                                                                    identifyDataArray[i].UserAddressableSectors);
                        xdprintf(Depth+2, ""), dprintf("Capabilities(word 49) 0x%04x, UDMASup 0x%02x, UDMAActive 0x%02x\n",
                                                                    identifyDataArray[i].Capabilities,
                                                                    identifyDataArray[i].UltraDMASupport,
                                                                    identifyDataArray[i].UltraDMAActive);
                        dprintf("\n");
                    }
                    else {
                        xdprintf(Depth, "Device %d not present\n", i);
                    }
                }
            }
            else {
                dprintf("\n ReadMemory failed to read one of the arrays from HW_DEVICE_EXTENSION @ 0x%08p\n", hwDevExtAddr);
            }
        }
        
        dprintf("\n");
        xdprintf(Depth+1, ""), dprintf("(for more info, use ' dt atapi!_HW_DEVICE_EXTENSION %08p ')\n", hwDevExtAddr);
    }
    else {
        dprintf("\n usage: !atapikd.miniext <PHW_DEVICE_EXTENSION> \n\n");
    }
    
    dprintf("\n");
    
    return S_OK;
}



VOID AtapiDumpFdoExtension(IN ULONG64 FdoExtAddr, IN ULONG Detail, IN ULONG Depth)
{
    ULONG devicePowerState, systemPowerState;
    ULONG flags, srbFlags, fdoState;
    ULONG64 interruptDataAddr;
    ULONG64 ideResourceAddr;
    
    xdprintf(Depth, ""), dprintf("\nATAPI Functional Device Extension @ 0x%08p\n\n", FdoExtAddr);

    devicePowerState = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "DevicePowerState");
    systemPowerState = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "SystemPowerState");
    flags = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "Flags");
    srbFlags = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "SrbFlags");
    fdoState = (ULONG)GetULONGField(FdoExtAddr, "atapi!_FDO_EXTENSION", "FdoState");
    interruptDataAddr = GetFieldAddr(FdoExtAddr, "atapi!_FDO_EXTENSION", "InterruptData");
    ideResourceAddr = GetFieldAddr(FdoExtAddr, "atapi!_FDO_EXTENSION", "IdeResource");
    
    if ((devicePowerState != BAD_VALUE) && (systemPowerState != BAD_VALUE) &&
        (flags  != BAD_VALUE) && (srbFlags != BAD_VALUE) && (fdoState != BAD_VALUE) &&
        (interruptDataAddr != BAD_VALUE) && (ideResourceAddr != BAD_VALUE)){

        ULONG interruptFlags, interruptMode, interruptLevel;
        BOOLEAN primaryDiskClaimed, secondaryDiskClaimed;
            
        xdprintf(Depth+1, "Power State (D%d, S%d)\n", devicePowerState-1, systemPowerState-1);

        DumpFlags(Depth+1, "Port Flags", flags, PortFlags);
        DumpFlags(Depth+1, "SRB Flags", srbFlags, SrbFlags);       

        DumpFdoState(Depth+1, fdoState);

        /*
         *  Display interrupt data
         */
        dprintf("\n");
        xdprintf(Depth+1, "Interrupt Data: \n");
        interruptFlags = (ULONG)GetULONGField(interruptDataAddr, "atapi!_INTERRUPT_DATA", "InterruptFlags");
        if (interruptFlags != BAD_VALUE){
            DumpFlags(Depth+2, "Port Flags", interruptFlags, PortFlags);
        }
        xdprintf(Depth+2, ""), dprintf("(for more info, use ' dt atapi!_INTERRUPT_DATA %08p ')\n", interruptDataAddr);

        /*
         *  Display IDE_RESOURCE info
         */
        dprintf("\n");
        xdprintf(Depth+1, " IDE Resources: \n");
        interruptMode = (ULONG)GetULONGField(ideResourceAddr, "atapi!_IDE_RESOURCE", "InterruptMode");
        interruptLevel = (ULONG)GetULONGField(ideResourceAddr, "atapi!_IDE_RESOURCE", "InterruptLevel");
        primaryDiskClaimed = (BOOLEAN)GetUCHARField(ideResourceAddr, "atapi!_IDE_RESOURCE", "AtdiskPrimaryClaimed");
        secondaryDiskClaimed = (BOOLEAN)GetUCHARField(ideResourceAddr, "atapi!_IDE_RESOURCE", "AtdiskSecondaryClaimed");
        if ((interruptMode != BAD_VALUE) && (interruptLevel != BAD_VALUE) &&
            (primaryDiskClaimed != BAD_VALUE) && (secondaryDiskClaimed != BAD_VALUE)){
            
            xdprintf(Depth+2, "Interrupt Mode : %s \n", interruptMode ? "Latched" : "Level Sensitive");
            xdprintf(Depth+2, "Interrupt Level 0x%x\n", interruptLevel);
            xdprintf(Depth+2, "Primary Disk %s.\n", primaryDiskClaimed ? "Claimed" : "Not Claimed");
            xdprintf(Depth+2, "Secondary Disk %s.\n", secondaryDiskClaimed ? "Claimed" : "Not Claimed");
        }
        xdprintf(Depth+2, ""), dprintf("(for more info use ' dt atapi!_IDE_RESOURCE %08p ')\n", ideResourceAddr);
        
    }

    dprintf("\n");
    xdprintf(Depth+1, ""), dprintf("(for more info, use ' dt atapi!_FDO_EXTENSION %08p ')\n", FdoExtAddr);
    
    dprintf("\n");
    
}

VOID DumpFdoState(IN ULONG Depth, IN ULONG State)
{
    int inx, count;

    count = 0;
    xdprintf(Depth, ""), dprintf("FDO State (0x%08x): \n", State);
   
    for (inx = 0; inx < MAX_FDO_STATES; inx++) {

        if (State & (1<<inx)) {
            xdprintf(Depth+1, "%s ", FdoState[inx]);
        }
    }

    dprintf("\n");
}


#ifdef ENABLE_COMMAND_LOG

    VOID ShowCommandLog(ULONG Depth, PCOMMAND_LOG CmdLogEntry, ULONG LogNumber)
    {
        if ((CmdLogEntry->FinalTaskFile.bCommandReg & IDE_STATUS_ERROR) || (CmdLogEntry->Cdb[0] == SCSIOP_REQUEST_SENSE)){ 
            xdprintf(Depth,  "Log[%03d]: Cmd(%02x), Sts(%02x), BmStat(%02x), Sense(%02x/%02x/%02x)", 
                                    LogNumber, CmdLogEntry->Cdb[0], CmdLogEntry->FinalTaskFile.bCommandReg, CmdLogEntry->BmStatus, 
                                    CmdLogEntry->SenseData[0], CmdLogEntry->SenseData[1], CmdLogEntry->SenseData[2]); 
        } 
        else { 
            xdprintf(Depth, "Log[%03d]: Cmd(%02x), Sts(%02x), BmStat(%02x)", 
                                    LogNumber, CmdLogEntry->Cdb[0], CmdLogEntry->FinalTaskFile.bCommandReg, CmdLogEntry->BmStatus); 
        }

        // BUGBUG - what's this ?
        if (CmdLogEntry->Cdb[0] == 0xc8){
            xdprintf(Depth, "CmdR(%02x)", CmdLogEntry->Cdb[7]); 
        } 
        dprintf("\n");
    }


    VOID DumpCommandLog(IN ULONG Depth, IN ULONG64 SrbDataAddr)
    {
        ULONG64 cmdLogAddr;
        ULONG cmdLogIndex;
       
        dprintf("\n");

        cmdLogAddr = GetULONGField(SrbDataAddr, "atapi!_SRB_DATA", "IdeCommandLog");
        cmdLogIndex = (ULONG)GetULONGField(SrbDataAddr, "atapi!_SRB_DATA", "IdeCommandLogIndex");

        if ((cmdLogAddr != BAD_VALUE) && (cmdLogIndex != BAD_VALUE)){
            UCHAR cmdLogBlock[MAX_COMMAND_LOG_ENTRIES*sizeof(COMMAND_LOG)];
            ULONG resultLen;
            BOOLEAN ok;
            
            xdprintf(Depth, ""), dprintf("Command Log Summary at 0x%08p:\n", cmdLogAddr);

            ok = (BOOLEAN)ReadMemory(cmdLogAddr, (PVOID)cmdLogBlock, sizeof(cmdLogBlock), &resultLen);
            if (ok){
                PCOMMAND_LOG cmdLog = (PCOMMAND_LOG)cmdLogBlock;
                ULONG logIndex, logNumber;

                /*
                 *  Print the log in temporal order, starting at the correct point in the circular log buffer.
                 */
                logNumber = 0;
                for (logIndex=cmdLogIndex+1; logIndex< MAX_COMMAND_LOG_ENTRIES; logIndex++, logNumber++) {
                    ShowCommandLog(Depth+1, &cmdLog[logIndex], logNumber);
                }
                for (logIndex=0; logIndex <= cmdLogIndex; logIndex++, logNumber++) {
                    ShowCommandLog(Depth+1, &cmdLog[logIndex], logNumber);
                }
            }
            else {
                dprintf("\n Error reading command log at address 0x%08p\n", cmdLogAddr);
            }
        }
        
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\minipkd\help.c ===
//depot/Lab01_N/drivers/storage/kdext/minipkd/help.c#2 - edit change 1877 (text)
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    SCSI Miniport debugger extension

Author:

    John Strange (JohnStra) 12-April-2000

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
    {"help",                    "displays this message"},
    {"adapters",                "dumps all the HBAs"},
    {"adapter <adapter>",       "dumps the specified Adapter Extension"},
    {"exports <adapter>",       "dumps the miniport exports for the given adapter"},
    {"lun <lun>",               "dumps the specified Logical Unit Extension"},
    {"portconfig <portconfig>", "dumps the specified PORT_CONFIGURATION_INFORMATION"},
    {"srb <srb>",               "dumps the specified SCSI_REQUEST_BLOCK"},
    {NULL, NULL}};

DECLARE_API (help)
{
        int i = 0;

        dprintf("\nSCSI Miniport Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("%-25s - \t%s\n",
                        extensions[i].extname,
                        extensions[i].extdesc);
                i++;
        }
        dprintf("\n");
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\atapi\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 2001

Module Name:

    util.c

Abstract:

    Utility library used for the various debugger extensions in this library.

Author:

    Peter Wieland (peterwie) 16-Oct-1995
    ervinp
    
Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#include "ideport.h"

PUCHAR devicePowerStateNames[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
    "Invalid"
};

FLAG_NAME SrbFlags[] = {
    FLAG_NAME(SRB_FLAGS_QUEUE_ACTION_ENABLE),
    FLAG_NAME(SRB_FLAGS_DISABLE_DISCONNECT),
    FLAG_NAME(SRB_FLAGS_DISABLE_SYNCH_TRANSFER),
    FLAG_NAME(SRB_FLAGS_BYPASS_FROZEN_QUEUE),
    FLAG_NAME(SRB_FLAGS_DISABLE_AUTOSENSE),
    FLAG_NAME(SRB_FLAGS_DATA_IN),
    FLAG_NAME(SRB_FLAGS_DATA_OUT),
    FLAG_NAME(SRB_FLAGS_NO_DATA_TRANSFER),
    FLAG_NAME(SRB_FLAGS_UNSPECIFIED_DIRECTION),
    FLAG_NAME(SRB_FLAGS_NO_QUEUE_FREEZE),
    FLAG_NAME(SRB_FLAGS_ADAPTER_CACHE_ENABLE),
    FLAG_NAME(SRB_FLAGS_IS_ACTIVE),
    FLAG_NAME(SRB_FLAGS_ALLOCATED_FROM_ZONE),
    FLAG_NAME(SRB_FLAGS_SGLIST_FROM_POOL),
    FLAG_NAME(SRB_FLAGS_BYPASS_LOCKED_QUEUE),
    FLAG_NAME(SRB_FLAGS_NO_KEEP_AWAKE),
    {0,0}
};

FLAG_NAME LuFlags[] = {
   FLAG_NAME(PD_QUEUE_FROZEN),
   FLAG_NAME(PD_LOGICAL_UNIT_IS_ACTIVE),
   FLAG_NAME(PD_NEED_REQUEST_SENSE),
   FLAG_NAME(PD_LOGICAL_UNIT_IS_BUSY),
   FLAG_NAME(PD_QUEUE_IS_FULL),
   FLAG_NAME(PD_RESCAN_ACTIVE),
   {0, 0}
};

FLAG_NAME PortFlags[] = {
   FLAG_NAME(PD_DEVICE_IS_BUSY),
   FLAG_NAME(PD_NOTIFICATION_REQUIRED),
   FLAG_NAME(PD_READY_FOR_NEXT_REQUEST),
   FLAG_NAME(PD_FLUSH_ADAPTER_BUFFERS),
   FLAG_NAME(PD_MAP_TRANSFER),
   FLAG_NAME(PD_LOG_ERROR),
   FLAG_NAME(PD_RESET_HOLD),
   FLAG_NAME(PD_HELD_REQUEST),
   FLAG_NAME(PD_RESET_REPORTED),
   FLAG_NAME(PD_PENDING_DEVICE_REQUEST),
   FLAG_NAME(PD_DISCONNECT_RUNNING),
   FLAG_NAME(PD_DISABLE_CALL_REQUEST),
   FLAG_NAME(PD_DISABLE_INTERRUPTS),
   FLAG_NAME(PD_ENABLE_CALL_REQUEST),
   FLAG_NAME(PD_TIMER_CALL_REQUEST),
   FLAG_NAME(PD_ALL_DEVICE_MISSING),
   FLAG_NAME(PD_RESET_REQUEST),
   {0,0}
};

FLAG_NAME DevFlags[] = {
   FLAG_NAME(DFLAGS_DEVICE_PRESENT),
   FLAG_NAME(DFLAGS_ATAPI_DEVICE),
   FLAG_NAME(DFLAGS_TAPE_DEVICE),
   FLAG_NAME(DFLAGS_INT_DRQ),
   FLAG_NAME(DFLAGS_REMOVABLE_DRIVE),
   FLAG_NAME(DFLAGS_MEDIA_STATUS_ENABLED),
   FLAG_NAME(DFLAGS_USE_DMA),
   FLAG_NAME(DFLAGS_LBA),
   FLAG_NAME(DFLAGS_MULTI_LUN_INITED),
   FLAG_NAME(DFLAGS_MSN_SUPPORT),
   FLAG_NAME(DFLAGS_AUTO_EJECT_ZIP),
   FLAG_NAME(DFLAGS_WD_MODE),
   FLAG_NAME(DFLAGS_LS120_FORMAT),
   FLAG_NAME(DFLAGS_USE_UDMA),
   FLAG_NAME(DFLAGS_IDENTIFY_VALID),
   FLAG_NAME(DFLAGS_IDENTIFY_INVALID),
   FLAG_NAME(DFLAGS_RDP_SET),
   FLAG_NAME(DFLAGS_SONY_MEMORYSTICK), 
   FLAG_NAME(DFLAGS_48BIT_LBA), 
   {0,0}
};

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64 Address
    )
{
    UCHAR addressBuffer[256];

    addressBuffer[0] = '\0';
    sscanf(Args, "%s", addressBuffer);
    addressBuffer[255] = '\0';

    *Address = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = (ULONG64)GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            return;

        }

    }
    return;
}

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64 Address,
    OUT PLONG      Detail
    )
{
    UCHAR addressBuffer[256];
    UCHAR detailBuffer[256];

    addressBuffer[0] = '\0';
    detailBuffer[0]  = '\0';
    sscanf(Args, "%s %s", addressBuffer, detailBuffer);
    addressBuffer[255] = '\0';
    detailBuffer[255]  = '\0';

    *Address = 0;
    *Detail  = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = (ULONG64) GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            *Detail = 0;
            return;

        }

        //
        // if they provided a detail level get it.
        //

        if (detailBuffer[0] == '\0') {

            *Detail = 0;

        } else {

            *Detail = (ULONG) GetExpression(detailBuffer);

        }
    }
    return;
}


VOID
GetAddressAndDetailLevel64(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    )
{
    UCHAR addressBuffer[256];
    UCHAR detailBuffer[256];

    addressBuffer[0] = '\0';
    detailBuffer[0]  = '\0';
    sscanf(Args, "%s %s", addressBuffer, detailBuffer);
    addressBuffer[255] = '\0';
    detailBuffer[255]  = '\0';

    *Address = 0;
    *Detail  = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //
        
        *Address = GetExpression(addressBuffer);
        
        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("Error while trying to evaluate the address.\n");
            *Address = 0;
            *Detail = 0;
            return;

        }

        //
        // if they provided a detail level get it.
        //

        if (detailBuffer[0] == '\0') {

            *Detail = 0;

        } 
        else {          
            *Detail = (ULONG)GetExpression(detailBuffer);
        }
    }
    return;
}


PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    )

{
    if(State > PowerDeviceMaximum) {
        return devicePowerStateNames[PowerDeviceMaximum + 1];
    } else {
        return devicePowerStateNames[(UCHAR) State];
    }
}


/*
 *  xdprintf
 *
 *      Prints formatted text with leading spaces.
 *
 *      WARNING:  DOES NOT HANDLE ULONG64 PROPERLY.
 */
VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG i;
    CCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (0x%08x): ", Name, Flags);

    xdprintf(Depth, "%s", prolog);

    if(Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}


BOOLEAN
GetAnsiString(
    IN ULONG64 Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    )
{
    ULONG i = 0;

    //
    // Grab the string in 64 character chunks until we find a NULL or the
    // read fails.
    //

    while((i < *Length) && (!CheckControlC())) {

        ULONG transferSize;
        ULONG result;

        if(*Length - i < 128) {
            transferSize = *Length - i;
        } else {
            transferSize = 128;
        }

        if(!ReadMemory(Address + i,
                       Buffer + i,
                       transferSize,
                       &result)) {
            //
            // read failed and we didn't find the NUL the last time.  Don't
            // expect to find it this time.
            // BUGBUG - figure out if i should expect it this time.
            //

            *Length = i;
            return FALSE;

        } else {

            ULONG j;

            //
            // Scan from where we left off looking for that NUL character.
            //

            for(j = 0; j < transferSize; j++) {

                if(Buffer[i + j] == '\0') {
                    *Length = i + j;
                    return TRUE;
                }
            }
        }

        i += transferSize;
    }

    //
    // We never found the NUL.  Don't need to update Length since it's currently
    // equal to i.
    //

    return FALSE;
}


/*
 *  GetULONGField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(ULONG64), &result);
    if (dbgStat != 0){
        dprintf("\n GetULONGField: GetFieldData failed with %xh retrieving field '%s' of struct '%s' @ %08p, returning bogus field value %08xh.\n", 
                    dbgStat, FieldName, StructType, StructAddr, BAD_VALUE);
        result = BAD_VALUE;
    }

    return result;
}


/*
 *  GetUSHORTField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    USHORT result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(USHORT), &result);
    if (dbgStat != 0){
        dprintf("\n GetUSHORTField: GetFieldData failed with %xh retrieving field '%s' of struct '%s' @ %08p, returning bogus field value %08xh.\n", 
                    dbgStat, FieldName, StructType, StructAddr, BAD_VALUE);
        result = (USHORT)BAD_VALUE;
    }

    return result;
}


/*
 *  GetUCHARField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    UCHAR result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(UCHAR), &result);
    if (dbgStat != 0){
        dprintf("\n GetUCHARField: GetFieldData failed with %xh retrieving field '%s' of struct '%s' @ %08p, returning bogus field value %08xh.\n", 
                    dbgStat, FieldName, StructType, StructAddr, BAD_VALUE);
        result = (UCHAR)BAD_VALUE;
    }

    return result;
}

ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;

    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = StructAddr+offset;
    }
    else {
        dprintf("\n GetFieldAddr: GetFieldOffset failed with %xh retrieving offset of struct '%s' (@ %08p) field '%s'.\n", 
                    dbgStat, StructType, StructAddr, FieldName);
        result = BAD_VALUE;
    }
    
    return result;
}


ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;
    
    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = FieldAddr-offset;
    }
    else {
        dprintf("\n GetContainingRecord: GetFieldOffset failed with %xh retrieving offset of struct '%s' field '%s', returning bogus address %08xh.\n", dbgStat, StructType, FieldName, BAD_VALUE);
        result = BAD_VALUE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\minipkd\kdext.cpp ===
//depot/Lab01_N/drivers/storage/kdext/minipkd/kdext.cpp#1 - add change 1876 (text)
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//

WINDBG_EXTENSION_APIS  ExtensionApis;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}



extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\atapi\kdext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


#if 0
            // BUGBUG REMOVE ?
    VOID
    WinDbgExtensionDllInit(
        PWINDBG_EXTENSION_APIS lpExtensionApis,
        USHORT MajorVersion,
        USHORT MinorVersion
        )
    {
        ExtensionApis = *lpExtensionApis;

        SavedMajorVersion = MajorVersion;
        SavedMinorVersion = MinorVersion;

        return;
    }


    VOID
    CheckVersion(
        VOID
        )
    {
    #if DBG
        if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
            dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                    VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
        }
    #else
        if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
            dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                    VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
        }
    #endif
    }

    LPEXT_API_VERSION ExtensionApiVersion(VOID)
    {
        return &ApiVersion;
    }
#endif

extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    IDebugControl *DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                          (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK DebugExtensionUninitialize(void)
{

}


DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\minipkd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <scsi.h>
#include <srb.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define MINIPKD_PRINT_ERROR(r)\
    dprintf("minipkd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);

#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

extern WINDBG_EXTENSION_APIS64 ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG_PTR Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\atapi\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

// #define KDEXTMODE // BUGBUG ?


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <scsi.h>
#include <srb.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension) CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#undef ASSERT
#undef ASSERTMSG
#if DBG
    #define ASSERT( exp ) if (!(exp)){ RtlAssert( #exp, __FILE__, __LINE__, NULL ); }
    #define ASSERTMSG( msg, exp ) if (!(exp)){ RtlAssert( #exp, __FILE__, __LINE__, msg ); }
#else
    #define ASSERT( exp )
    #define ASSERTMSG( msg, exp )
#endif 


#define PCI_SLOT_NUMBER ULONG



#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "ntdddisk.h"
#include "ntddscsi.h"
#include "ntddstor.h"

#include "wmistr.h"

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

#define BAD_VALUE  (ULONG64)-1

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];
extern FLAG_NAME LuFlags[];
extern FLAG_NAME PortFlags[];
extern FLAG_NAME DevFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64 Address,
    OUT PLONG      Detail
    );

VOID
GetAddressAndDetailLevel64(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64 Address
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG64 Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName);


extern WINDBG_EXTENSION_APIS ExtensionApis;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\minipkd\minipkd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    minipkd.c

Abstract:

    SCSI miniport debugger dxtension api

Author:

    John Strange (johnstra) 7-Apr-2000
        (Adapted from PeterWie's scsikd)

Environment:

    User Mode

Revision History:

--*/

#include "pch.h"
#include "port.h"

FLAG_NAME LuFlags[] = {
    FLAG_NAME(LU_QUEUE_FROZEN),             // 0001
    FLAG_NAME(LU_LOGICAL_UNIT_IS_ACTIVE),   // 0002
    FLAG_NAME(LU_NEED_REQUEST_SENSE),       // 0004
    FLAG_NAME(LU_LOGICAL_UNIT_IS_BUSY),     // 0008
    FLAG_NAME(LU_QUEUE_IS_FULL),            // 0010
    FLAG_NAME(LU_PENDING_LU_REQUEST),       // 0020
    FLAG_NAME(LU_QUEUE_LOCKED),             // 0040
    FLAG_NAME(LU_QUEUE_PAUSED),             // 0080
    {0,0}
};

FLAG_NAME AdapterFlags[] = {
    FLAG_NAME(PD_DEVICE_IS_BUSY),            // 0X00001
    FLAG_NAME(PD_NOTIFICATION_REQUIRED),     // 0X00004
    FLAG_NAME(PD_READY_FOR_NEXT_REQUEST),    // 0X00008
    FLAG_NAME(PD_FLUSH_ADAPTER_BUFFERS),     // 0X00010
    FLAG_NAME(PD_MAP_TRANSFER),              // 0X00020
    FLAG_NAME(PD_LOG_ERROR),                 // 0X00040
    FLAG_NAME(PD_RESET_HOLD),                // 0X00080
    FLAG_NAME(PD_HELD_REQUEST),              // 0X00100
    FLAG_NAME(PD_RESET_REPORTED),            // 0X00200
    FLAG_NAME(PD_PENDING_DEVICE_REQUEST),    // 0X00800
    FLAG_NAME(PD_DISCONNECT_RUNNING),        // 0X01000
    FLAG_NAME(PD_DISABLE_CALL_REQUEST),      // 0X02000
    FLAG_NAME(PD_DISABLE_INTERRUPTS),        // 0X04000
    FLAG_NAME(PD_ENABLE_CALL_REQUEST),       // 0X08000
    FLAG_NAME(PD_TIMER_CALL_REQUEST),        // 0X10000
    FLAG_NAME(PD_WMI_REQUEST),               // 0X20000
    {0,0}
};

char *MiniInterruptMode[] = {
    "LevelSensitive",
    "Latched"
};

char *MiniInterfaceTypes[] = {
    "Internal",
    "Isa",
    "Eisa",
    "MicroChannel",
    "TurboChannel",
    "PCIBus",
    "VMEBus",
    "NuBus",
    "PCMCIABus",
    "CBus",
    "MPIBus",
    "MPSABus",
    "ProcessorInternal",
    "InternalPowerBus",
    "PNPISABus",
    "PNPBus"
};

char *MiniDmaWidths[] = {
    "Width8Bits",
    "Width16Bits",
    "Width32Bits"
};

char *MiniDmaSpeed[] = {
    "Compatible",
    "TypeA",
    "TypeB",
    "TypeC",
    "TypeF"
};

#define MINIKD_MAX_SCSI_FUNCTION 26
char *MiniScsiFunction[] = {
   "SRB_FUNCTION_EXECUTE_SCSI",       // 0x00
   "SRB_FUNCTION_CLAIM_DEVICE",       // 0x01
   "SRB_FUNCTION_IO_CONTROL",         // 0x02
   "SRB_FUNCTION_RECEIVE_EVENT",      // 0x03
   "SRB_FUNCTION_RELEASE_QUEUE",      // 0x04
   "SRB_FUNCTION_ATTACH_DEVICE",      // 0x05
   "SRB_FUNCTION_RELEASE_DEVICE",     // 0x06
   "SRB_FUNCTION_SHUTDOWN",           // 0x07
   "SRB_FUNCTION_FLUSH",              // 0x08
   "***",                             // 0x09
   "***",                             // 0x0a
   "***",                             // 0x0b
   "***",                             // 0x0c
   "***",                             // 0x0d
   "***",                             // 0x0e
   "***",                             // 0x0f
   "SRB_FUNCTION_ABORT_COMMAND",      // 0x10
   "SRB_FUNCTION_RELEASE_RECOVERY",   // 0x11
   "SRB_FUNCTION_RESET_BUS",          // 0x12
   "SRB_FUNCTION_RESET_DEVICE",       // 0x13
   "SRB_FUNCTION_TERMINATE_IO",       // 0x14
   "SRB_FUNCTION_FLUSH_QUEUE",        // 0x15
   "SRB_FUNCTION_REMOVE_DEVICE",      // 0x16
   "SRB_FUNCTION_WMI",                // 0x17
   "SRB_FUNCTION_LOCK_QUEUE",         // 0x18
   "SRB_FUNCTION_UNLOCK_QUEUE"        // 0x19
};

#define MINIKD_MAX_SRB_STATUS 49
char *MiniScsiSrbStatus[] = {
   "SRB_STATUS_PENDING",                // 0x00
   "SRB_STATUS_SUCCESS",                // 0x01
   "SRB_STATUS_ABORTED",                // 0x02
   "SRB_STATUS_ABORT_FAILED",           // 0x03
   "SRB_STATUS_ERROR",                  // 0x04
   "SRB_STATUS_BUSY",                   // 0x05
   "SRB_STATUS_INVALID_REQUEST",        // 0x06
   "SRB_STATUS_INVALID_PATH_ID",        // 0x07
   "SRB_STATUS_NO_DEVICE",              // 0x08
   "SRB_STATUS_TIMEOUT",                // 0x09
   "SRB_STATUS_SELECTION_TIMEOUT",      // 0x0a
   "SRB_STATUS_COMMAND_TIMEOUT",        // 0x0b
   "***",                               // 0x0c
   "SRB_STATUS_MESSAGE_REJECTED",       // 0x0d
   "SRB_STATUS_BUS_RESET",              // 0x0e
   "SRB_STATUS_STATUS_PARITY_ERROR",    // 0x0f
   "SRB_STATUS_REQUEST_SENSE_FAILED",   // 0x10
   "SRB_STATUS_NO_HBA",                 // 0x11
   "SRB_STATUS_DATA_OVERRUN",           // 0x12
   "SRB_STATUS_UNEXPECTED_BUS_FREE",    // 0x13
   "SRB_STATUS_PHASE_SEQUENCE_FAILURE", // 0x14
   "SRB_STATUS_BAD_SRB_BLOCK_LENGTH",   // 0x15
   "SRB_STATUS_REQUEST_FLUSHED",        // 0x16
   "***",                               // 0x17
   "***",                               // 0x18
   "***",                               // 0x19
   "***",                               // 0x1a
   "***",                               // 0x1b
   "***",                               // 0x1c
   "***",                               // 0x1d
   "***",                               // 0x1e
   "***",                               // 0x1f
   "SRB_STATUS_INVALID_LUN",            // 0x20
   "SRB_STATUS_INVALID_TARGET_ID",      // 0x21
   "SRB_STATUS_BAD_FUNCTION",           // 0x22
   "SRB_STATUS_ERROR_RECOVERY",         // 0x23
   "SRB_STATUS_NOT_POWERED",            // 0x24
   "***",                               // 0x25
   "***",                               // 0x26
   "***",                               // 0x27
   "***",                               // 0x28
   "***",                               // 0x29
   "***",                               // 0x2a
   "***",                               // 0x2b
   "***",                               // 0x2c
   "***",                               // 0x2d
   "***",                               // 0x2e
   "***",                               // 0x2f
   "SRB_STATUS_INTERNAL_ERROR"          // 0x30
};

#define DumpUcharField(name, value, depth) \
    xdprintfEx((depth), ("%s: 0x%02X\n", (name), (value)))

#define DumpUshortField(name, value, depth) \
    xdprintfEx((depth), ("%s: 0x%04X\n", (name), (value)))

#define DumpUlongField(name, value, depth) \
    xdprintfEx((depth), ("%s: 0x%08X\n", (name), (value)))

#define DumpPointerField(name, value, depth) \
    xdprintfEx((depth), ("%s: %08p\n", (name), (value)))

#define DumpBooleanField(name, value, depth) \
    xdprintfEx((depth), ("%s: %s\n", (name), (value) ? "YES" : "NO"))
    

typedef struct _CommonExtensionFlags {

    //
    // True if this device object is a physical device object
    //

    BOOLEAN IsPdo : 1;

    //
    // True if this device object has processed it's first start and
    // has been initialized.
    //

    BOOLEAN IsInitialized : 1;

    //
    // Has WMI been initialized for this device object?
    //

    BOOLEAN WmiInitialized : 1;

    //
    // Has the miniport associated with this FDO or PDO indicated WMI
    // support?
    //

    BOOLEAN WmiMiniPortSupport : 1;

} CommonExtensionFlags, *PCommonExtensionFlags;

VOID
MpDumpPdo(
    IN ULONG64 Address,
    IN OPTIONAL PADAPTER_EXTENSION Adapter,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
MpDumpFdoExtension(
    ULONG64 Address,
    ULONG64 DeviceObject,
    ULONG Detail,
    ULONG Depth
    );

VOID
MpDumpExtension(
    IN ULONG64 Address,
    IN ULONG64 DeviceExtension,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
MpDumpPortConfigurationInformation(
    IN ULONG64 PortConfigInfo,
    IN ULONG Depth
    );

VOID
MpDumpSrb(
    IN ULONG64 Srb,
    IN ULONG Depth
    );

VOID
MpDumpAdapters(
    IN PDEVICE_OBJECT *Adapters,
    IN ULONG Depth
    );

VOID
MpDumpSrbData(
    PSRB_DATA SrbData,
    ULONG Depth
    );

VOID
MpDumpScatterGatherList(
    PSRB_SCATTER_GATHER List,
    ULONG Entries,
    ULONG Depth
    );

VOID
MpDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    );

VOID
MpDumpInterruptData(
    IN PINTERRUPT_DATA Data,
    IN PINTERRUPT_DATA RealData,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
MpDumpChildren(
    IN ULONG64 Adapter,
    IN ULONG Depth
    );

PUCHAR 
MpSecondsToString(
    ULONG Count
    );

VOID
MpDumpRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    );

VOID
MpDumpHwExports(
    IN ULONG64 Address
    );


DECLARE_API (exports)

/*++

Routine Description:

    Dumps the specified miniport's service routine pointers

Arguments:

Return Value:

    none

--*/

{
    ULONG64 address;

    //
    // Get the address of the struct.
    //

    GetExpressionEx(args, &address, &args);

    //
    // Dump the PORT_CONFIGURATION_INFORMATION
    //

    MpDumpHwExports(address);

    return S_OK;
}

DECLARE_API (adapters)

/*++

Routine Description:

    Dumps adapter information.

Arguments:

Return Value:

    none

--*/

{
    ULONG64 address;
    ULONG result;
    CHAR NameBuffer[512];
    ULONG status;
    ULONG CurrentAdapter = 0;
    ULONG Adapters;
    ULONG64 DriverObjectAddr;
    ULONG64 DriverNameLength;
    ULONG64 DriverNameBuffer;
    ULONG64 DeviceExtension;
    ULONG64 AdapterAddr;
    ULONG RemoveStatus;
    ULONG Type;
    BOOLEAN ValidAdapter;
    ULONG64 *AdapterArr;
    ULONG i;

    //
    // Get the address of scsiport's global adapter list element count.
    // and read the count from the debuggee.  If we can't get the address
    // or if we can't read the count, we give up.
    //

    address = GetExpression("scsiport!ScsiGlobalAdapterListElements");
    if (address != 0) {
        Adapters = 0;
        status = ReadMemory(address, (PVOID) &Adapters, sizeof(ULONG), &result);
        if (!status) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        } else if (Adapters == 0) {
            dprintf("There are no configured SCSI adapters.\n");
            return S_OK;
        }
    } else {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    //
    // Get the address of scsiport's global adapter list and read
    // the address from the debuggee.  If we can't get the address
    // or read it, we can't continue.
    //

    address = GetExpression("scsiport!ScsiGlobalAdapterList");
    if (address) {
        status = ReadMemory(address, (PVOID) &address, sizeof(ULONG64), &result);
        if (!status) {
            MINIPKD_PRINT_ERROR(status);
            return E_FAIL;
        } else if (address == (ULONG64)-1 || address == (ULONG64)0) {
            dprintf("There are no configured SCSI adapters.\n");
            return S_OK;
        }
    } else {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    //
    // Allocate memory to hold an array of addresses.  We use the array to
    // check for duplicate device objects.
    //

    AdapterArr = _alloca(sizeof(ULONG64) * Adapters);

    //
    // Display adapter information.
    //

    while (CurrentAdapter < Adapters) {

        ValidAdapter = TRUE;

        //
        // Read the address of the device object (fdo) and update address
        // to point to the next one.  The amount by which we bump the address
        // depends on the size of a pointer on the debuggee.
        //

        ReadPtr(address, &AdapterAddr);
        address += (IsPtr64()) ? sizeof(ULONG64) : sizeof(ULONG);
        
        //
        // Save the address of the adapter.
        //

        AdapterArr[CurrentAdapter] = AdapterAddr;

        //
        // If this address is a duplicate, we don't need to display info on it
        // again.
        //

        if (CurrentAdapter > 0) {
            for (i=0; i<CurrentAdapter-1; i++) {
                if (AdapterAddr == AdapterArr[i]) {
                    ValidAdapter = FALSE;
                    goto ShowIt;
                }
            }
        }

        //
        // Read device object data.
        //
        
        if (InitTypeRead(AdapterAddr, nt!_DEVICE_OBJECT)) {
            ValidAdapter = FALSE;
            goto ShowIt;
        }

        //
        // Let's make sure this is a valid device object by checking that
        // the Type field is valid.
        //

        Type = (ULONG)ReadField(Type);
        if (Type != IO_TYPE_DEVICE) {
            ValidAdapter = FALSE;
        } else {
            //
            // The DriverObject field will be non-null for a valid device object.
            //

            DriverObjectAddr = ReadField(DriverObject);
            if (!DriverObjectAddr) {
                ValidAdapter = FALSE;
                goto ShowIt;
            }

            //
            // The DeviceExtension field should also be non-null.
            //

            DeviceExtension = ReadField(DeviceExtension);
            if (!DeviceExtension) {
                ValidAdapter = FALSE;
                goto ShowIt;
            }

            //
            // Let's do one more check to be sure we're dealing with a valid
            // device object.  If it's valid, the extension's DeviceObject
            // field will point back to the device object.
            // 

            if (InitTypeRead(DeviceExtension, scsiport!COMMON_EXTENSION)) {
                ValidAdapter = FALSE;
            } else {
                RemoveStatus = (ULONG)ReadField(IsRemoved);
                if (RemoveStatus != NO_REMOVE && RemoveStatus != REMOVE_PENDING) {
                    ValidAdapter = FALSE;
                } else {
                    
                    //
                    // Ok, we know the device object is valid.  Go ahead and
                    // get the rest of the information we need.
                    //
                    
                    InitTypeRead(DriverObjectAddr, scsiport!DRIVER_OBJECT);
                    DriverNameBuffer = ReadField(DriverName.Buffer);
                    if (!DriverNameBuffer) {
                        MINIPKD_PRINT_ERROR(0);
                        return E_FAIL;
                    }
                    
                    DriverNameLength = ReadField(DriverName.Length);
                    if (!DriverNameLength) {
                        MINIPKD_PRINT_ERROR(0);
                        return E_FAIL;
                    }
                    
                    status = ReadMemory(
                                 DriverNameBuffer,
                                 (PVOID) NameBuffer,
                                 (ULONG)DriverNameLength * sizeof(WCHAR),
                                 &result);
                    if (!status) {
                        PWCHAR NoName = L"Driver name paged out";
                        RtlMoveMemory(NameBuffer,
                                      NoName,
                                      21 * sizeof(WCHAR));
                    }                
                }
            }
        }
ShowIt:        
        //
        // Display some information about the adapter.
        //

        if (ValidAdapter) {
            dprintf("%S %-20S DO %-16p DevExt %-16p %s\n", 
                    L"Adapter",
                    NameBuffer, 
                    AdapterAddr,
                    DeviceExtension,
                    (RemoveStatus == REMOVE_PENDING) ? "REMOVE PENDING" : "");

            MpDumpChildren(DeviceExtension, 0);

        }

        //
        // Advance current adapter index.
        //

        ++CurrentAdapter;
    }

    return S_OK;
}


DECLARE_API (portconfig)

/*++

Routine Description:

    Dumps supplied address as a PORT_CONFIGURATION_INFORMATION struct

Arguments:

    args - string containing the address of a 
           PORT_CONFIGURATION_INFORMATION struct
           
Return Value:

    none

--*/

{
    ULONG64 address;

    //
    // Get the address of the struct.
    //

    GetExpressionEx(args, &address, &args);

    //
    // Dump the PORT_CONFIGURATION_INFORMATION
    //

    MpDumpPortConfigurationInformation(
        address,
        0);

    return S_OK;
}


DECLARE_API (srb)

/*++

Routine Description:

    Dumps supplied address as a SCSI_REQUEST_BLOCK struct

Arguments:

    args - string containing the address of a 
           PORT_CONFIGURATION_INFORMATION struct
           
Return Value:

    none

--*/

{
    ULONG64 address;

    //
    // Get the address of the struct.
    //

    GetExpressionEx(args, &address, &args);

    //
    // Dump the PORT_CONFIGURATION_INFORMATION
    //

    MpDumpSrb(
        address,
        0);

    return S_OK;
}


DECLARE_API (adapter)

/*++

Routine Description:

    Dumps adapter information for the specified adapter.

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 Address;
    ULONG64 Type;
    ULONG64 DeviceExtension;
    ULONG detail = 0;
    UCHAR Block;
    PCommonExtensionFlags Flags = (PCommonExtensionFlags) &Block;

    //
    // Convert the argument string to an address.
    //

    GetExpressionEx(args, &Address, &args);

    //
    // If the supplied address points to a device, fixup the address to
    // that of the device's extension.
    //

    InitTypeRead(Address, nt!_DEVICE_OBJECT);
    Type = ReadField(Type);
    DeviceExtension = Address;
    
    if (Type == IO_TYPE_DEVICE) {
        DeviceExtension = ReadField(DeviceExtension);
        if (!DeviceExtension) {
            MINIPKD_PRINT_ERROR(0);
            return E_FAIL;
        }
        Address = DeviceExtension;
    }

    //
    // Make sure an ADAPTER_EXTENSION object lives at the address we have.
    //
    
    InitTypeRead(Address, scsiport!COMMON_EXTENSION);
    Block = (UCHAR)ReadField(IsPdo);
    if (Flags->IsPdo) {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    MpDumpExtension(Address,
                    DeviceExtension,
                    0,
                    0);

    return S_OK;
}


DECLARE_API (lun)

/*++

Routine Description:

    Dumps LUN extension information at the specified address.

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 Address;
    ULONG64 Type;
    ULONG64 DeviceExtension;
    ULONG detail = 0;
    UCHAR Block;
    PCommonExtensionFlags Flags = (PCommonExtensionFlags) &Block;

    //
    // Convert the argument string to an address.
    //

    GetExpressionEx(args, &Address, &args);

    //
    // Read the Type and DeviceExtension fields from the supplied address.
    //

    InitTypeRead(Address, nt!_DEVICE_OBJECT);
    Type = ReadField(Type);
    
    DeviceExtension = ReadField(DeviceExtension);
    if (!DeviceExtension) {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    //
    // If the supplied address points to a device, fixup the address to
    // that of the device's extension.
    //

    if (Type == IO_TYPE_DEVICE) {
        Address = DeviceExtension;
    }

    //
    // Make sure an LOGICAL_UNIT_EXTENSION object lives at the address we have.
    //
    
    InitTypeRead(Address, scsiport!COMMON_EXTENSION);
    Block = (UCHAR)ReadField(IsPdo);
    if (!Flags->IsPdo) {
        MINIPKD_PRINT_ERROR(0);
        return E_FAIL;
    }

    MpDumpExtension(Address,
                    DeviceExtension,
                    0,
                    0);
    return S_OK;
}



VOID
MpDumpExtension(
    IN ULONG64 Address,
    IN ULONG64 DeviceExtension,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG tmp;
    ULONG IsRemoved = 0;
    ULONG SrbFlags = 0;
    ULONG WmiScsiPortRegInfoBufSize = 0;
    ULONG PagingPathCount = 0;
    ULONG HibernatePathCount = 0;
    ULONG DumpPathCount = 0;
    ULONG64 WmiScsiPortRegInfoBuf = 0;
    ULONG64 DeviceObject = 0;
    ULONG64 LowerDeviceObject = 0;
    ULONG64 IdleTimer = 0;
    ULONG64 MajorFunction = 0;
    DEVICE_POWER_STATE CurrentDeviceState = 0;
    DEVICE_POWER_STATE DesiredDeviceState = 0;
    SYSTEM_POWER_STATE CurrentSystemState = 0;
#if 0
    BOOLEAN IsPdo = 0;
    BOOLEAN IsInitialized = 0;
    BOOLEAN WmiInitialized = 0;
    BOOLEAN WmiMiniPortSupport = 0;
    UCHAR CurrentPnpState = 0;    
    UCHAR PreviousPnpState = 0;
#else
    ULONG IsPdo = 0;
    ULONG IsInitialized = 0;
    ULONG WmiInitialized = 0;
    ULONG WmiMiniPortSupport = 0;
    ULONG CurrentPnpState = 0;    
    ULONG PreviousPnpState = 0;
#endif

    FIELD_INFO deviceFields[] = {
       {"IsPdo",                     NULL, 0, COPY, 0, (PVOID) &IsPdo                     },
       {"IsInitialized",             NULL, 0, COPY, 0, (PVOID) &IsInitialized             },
       {"WmiInitialized",            NULL, 0, COPY, 0, (PVOID) &WmiInitialized            },
       {"WmiMiniPortSupport",        NULL, 0, COPY, 0, (PVOID) &WmiMiniPortSupport        },
       {"IsRemoved",                 NULL, 0, COPY, 0, (PVOID) &IsRemoved                 },
       {"DeviceObject",              NULL, 0, COPY, 0, (PVOID) &DeviceObject              },
       {"LowerDeviceObject",         NULL, 0, COPY, 0, (PVOID) &LowerDeviceObject         },
       {"SrbFlags",                  NULL, 0, COPY, 0, (PVOID) &SrbFlags                  },
       {"CurrentDeviceState",        NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState        },
       {"CurrentSystemState",        NULL, 0, COPY, 0, (PVOID) &CurrentSystemState        },
       {"DesiredDeviceState",        NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState        },
       {"IdleTimer",                 NULL, 0, COPY, 0, (PVOID) &IdleTimer                 },
       {"CurrentPnpState",           NULL, 0, COPY, 0, (PVOID) &CurrentPnpState           },
       {"PreviousPnpState",          NULL, 0, COPY, 0, (PVOID) &PreviousPnpState          },
       {"MajorFunction",             NULL, 0, COPY, 0, (PVOID) &MajorFunction             },
       {"PagingPathCount",           NULL, 0, COPY, 0, (PVOID) &PagingPathCount           },
       {"HibernatePathCount",        NULL, 0, COPY, 0, (PVOID) &HibernatePathCount        },
       {"DumpPathCount",             NULL, 0, COPY, 0, (PVOID) &DumpPathCount             },
       {"WmiScsiPortRegInfoBuf",     NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBuf     },
       {"WmiScsiPortRegInfoBufSize", NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBufSize },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!COMMON_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    dprintf("Miniport %s device extension at address %08p\n",
            (IsPdo ? "physical" : "functional"),
            Address);

    xdprintfEx(Depth, ("Common Extension:\n"));

    Depth += 1;

    tmp = Depth;

    if(IsInitialized) {
        xdprintfEx(tmp, ("Initialized " ));
        tmp = 0;
    }

    if(IsRemoved) {
        xdprintfEx(tmp, ("Removed " ));
        tmp = 0;
    }

    switch(IsRemoved) {
        case REMOVE_PENDING: {
            xdprintfEx(tmp, ("RemovePending"));
            tmp = 0;
            break;
        }

        case REMOVE_COMPLETE: {
            xdprintfEx(tmp, ("RemoveComplete"));
            tmp = 0;
            break;
        }
    }

    if(WmiMiniPortSupport) {
        if(WmiInitialized) {
            xdprintfEx(tmp, ("WmiInit"));
        } else {
            xdprintfEx(tmp, ("Wmi"));
        }
        tmp = 0;
    }

    if(tmp == 0) {
        dprintf("\n");
    }

    tmp = 0;

    xdprintfEx(Depth, ("DO "));
    dprintf("%08p  LowerObject %08p  SRB Flags %#08lx\n",
            DeviceObject,
            LowerDeviceObject,
            SrbFlags
            );

    xdprintfEx(Depth, ("Current Power "));
    dprintf("(D%d,S%d)  Desired Power D%d Idle %#08lx\n",
            CurrentDeviceState - 1,
            CurrentSystemState - 1,
            DesiredDeviceState - 1,
            IdleTimer);

    xdprintfEx(Depth, ("Current Pnp state "));
    dprintf("%x    Previous state 0x%x\n",
            CurrentPnpState,
            PreviousPnpState);

    xdprintfEx(Depth, ("DispatchTable "));
    dprintf("%08p   UsePathCounts (P%d, H%d, C%d)\n",
            MajorFunction,
            PagingPathCount,
            HibernatePathCount,
            DumpPathCount);

    if(WmiMiniPortSupport) {
        xdprintfEx(Depth, ("WmiInfo "));
        dprintf("%08p   WmiInfoSize %#08lx\n",
                WmiScsiPortRegInfoBuf,
                WmiScsiPortRegInfoBufSize);
    }

    if(IsPdo) {
        xdprintfEx(Depth - 1, ("Logical Unit Extension:\n"));
        MpDumpPdo(Address,
                  NULL,
                  Detail,
                  Depth);
    } else {
        xdprintfEx(Depth - 1, ("Adapter Extension:\n"));
        MpDumpFdoExtension(Address, DeviceExtension, Detail, Depth);
    }

    return;
}

VOID
MpDumpHwExports(
    ULONG64 Address
    )
{
    ULONG result;

    ULONG64 HwFindAdapter;
    ULONG64 HwInitialize;
    ULONG64 HwStartIo;
    ULONG64 HwInterrupt;
    ULONG64 HwResetBus;
    ULONG64 HwDmaStarted;
    ULONG64 HwRequestInterrupt;
    ULONG64 HwTimerRequest;
    ULONG64 HwAdapterControl;

    FIELD_INFO deviceFields[] = {
        {"HwFindAdapter",      NULL, 0, COPY, 0, (PVOID) &HwFindAdapter },
        {"HwInitialize",       NULL, 0, COPY, 0, (PVOID) &HwInitialize  },
        {"HwStartIo",          NULL, 0, COPY, 0, (PVOID) &HwStartIo     },
        {"HwInterrupt",        NULL, 0, COPY, 0, (PVOID) &HwInterrupt   },
        {"HwResetBus",         NULL, 0, COPY, 0, (PVOID) &HwResetBus    },
        {"HwDmaStarted",       NULL, 0, COPY, 0, (PVOID) &HwDmaStarted  },
        {"HwRequestInterrupt", NULL, 0, COPY, 0, (PVOID) &HwRequestInterrupt },
        {"HwTimerRequest",     NULL, 0, COPY, 0, (PVOID) &HwTimerRequest     },
        {"HwAdapterControl",   NULL, 0, COPY, 0, (PVOID) &HwAdapterControl   },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    dprintf("HwFindAdapter     : %08p\n", HwFindAdapter);
    dprintf("HwInitialize      : %08p\n", HwInitialize);
    dprintf("HwStartIo         : %08p\n", HwStartIo);
    dprintf("HwInterrupt       : %08p\n", HwInterrupt);
    dprintf("HwResetBus        : %08p\n", HwResetBus);
    dprintf("HwDmaStarted      : %08p\n", HwDmaStarted);
    dprintf("HwRequestInterrupt: %08p\n", HwRequestInterrupt);
    dprintf("HwTimerRequest    : %08p\n", HwTimerRequest);
    dprintf("HwAdapterControl  : %08p\n", HwAdapterControl);

    return;
}


VOID
MpDumpFdoExtension(
    ULONG64 Address,
    ULONG64 DeviceExtension,
    ULONG Detail,
    ULONG Depth
    )

{
    PADAPTER_EXTENSION realAdapter = (PADAPTER_EXTENSION) Address;
    ULONG tmp = Depth;
    WCHAR name[256];
    ULONG Result;

    ULONG64 DeviceName = 0;
    ULONG64 InterfaceName = 0;
    ULONG64 InterfaceNameLen = 0;
    ULONG64 HwDeviceExtension = 0;
    ULONG64 SrbExtensionBuffer = 0; 
    ULONG64 NonCachedExtension = 0;
    ULONG64 PortNumber = 0;
    ULONG64 AdapterNumber = 0;
    ULONG64 ActiveRequestCount = 0;                    
    ULONG64 IsMiniportDetected = 0;
    ULONG64 IsInVirtualSlot = 0;
    ULONG64 IsPnp = 0;
    ULONG64 HasInterrupt = 0;
    ULONG64 DisablePower = 0;
    ULONG64 DisableStop = 0;
    ULONG VirtualSlotNumber = 0;
    ULONG RealBusNumber = 0;
    ULONG RealSlotNumber = 0;
    ULONG64 NumberOfBuses = 0;
    ULONG64 MaximumTargetIds = 0;
    ULONG64 MaxLuCount = 0;
    ULONG64 DisableCount = 0;
    ULONG64 SynchronizeExecution = 0;
    ULONG64 MapRegisterBase = 0;
    ULONG64 DmaAdapterObject = 0;
    ULONG64 PortConfig = 0;
    ULONG64 AllocatedResources = 0;
    ULONG64 TranslatedResources = 0;
    ULONG64 InterruptLevel = 0;
    ULONG64 IoAddress = 0;
    ULONG64 MapBuffers = 0;
    ULONG64 RemapBuffers = 0;
    ULONG64 MasterWithAdapter = 0;
    ULONG64 TaggedQueuing= 0;
    ULONG64 AutoRequestSense = 0;
    ULONG64 MultipleRequestPerLu = 0;
    ULONG64 ReceiveEvent = 0;
    ULONG64 CachesData = 0;
    ULONG64 Dma64BitAddresses = 0;
    ULONG64 Dma32BitAddresses = 0;
    ULONG64 DeviceState = 0;
    ULONG64 TickCount = 0;
    ULONG64 AdapterExtension = 0;
                                       
    FIELD_INFO deviceFields[] = {
        {"DeviceName",                      NULL, 0, COPY, 0, (PVOID) &DeviceName                   },
        {"InterfaceName.Buffer",            NULL, 0, COPY, 0, (PVOID) &InterfaceName                },
        {"InterfaceName.Length",            NULL, 0, COPY, 0, (PVOID) &InterfaceNameLen             },
        {"HwDeviceExtension",               NULL, 0, COPY, 0, (PVOID) &HwDeviceExtension            },
        {"SrbExtensionBuffer",              NULL, 0, COPY, 0, (PVOID) &SrbExtensionBuffer           },
        {"NonCachedExtension",              NULL, 0, COPY, 0, (PVOID) &NonCachedExtension           },
        {"PortNumber",                      NULL, 0, COPY, 0, (PVOID) &PortNumber                   },
        {"AdapterNumber",                   NULL, 0, COPY, 0, (PVOID) &AdapterNumber                },
        {"ActiveRequestCount",              NULL, 0, COPY, 0, (PVOID) &ActiveRequestCount           },
        {"SynchronizeExecution",            NULL, 0, COPY, 0, (PVOID) &SynchronizeExecution         },
        {"DeviceState",                     NULL, 0, COPY, 0, (PVOID) &DeviceState                  },
        {"TickCount",                       NULL, 0, COPY, 0, (PVOID) &TickCount                    },
        {"IsMiniportDetected",              NULL, 0, COPY, 0, (PVOID) &IsMiniportDetected           },
        {"IsInVirtualSlot",                 NULL, 0, COPY, 0, (PVOID) &IsInVirtualSlot              },
        {"IsPnp",                           NULL, 0, COPY, 0, (PVOID) &IsPnp                        },
        {"HasInterrupt",                    NULL, 0, COPY, 0, (PVOID) &HasInterrupt                 },
        {"DisablePower",                    NULL, 0, COPY, 0, (PVOID) &DisablePower                 },
        {"DisableStop",                     NULL, 0, COPY, 0, (PVOID) &DisableStop                  },
        {"RealBusNumber",                   NULL, 0, COPY, 0, (PVOID) &RealBusNumber                },
        {"RealSlotNumber",                  NULL, 0, COPY, 0, (PVOID) &RealSlotNumber               },
        {"VirtualSlotNumber.u.AsULONG",     NULL, 0, COPY, 0, (PVOID) &VirtualSlotNumber            },
        {"NumberOfBuses",                   NULL, 0, COPY, 0, (PVOID) &NumberOfBuses                },
        {"MaximumTargetIds",                NULL, 0, COPY, 0, (PVOID) &MaximumTargetIds             },
        {"MaxLuCount",                      NULL, 0, COPY, 0, (PVOID) &MaxLuCount                   },
        {"DisableCount",                    NULL, 0, COPY, 0, (PVOID) &DisableCount                 },
        {"MapRegisterBase",                 NULL, 0, COPY, 0, (PVOID) &MapRegisterBase              },
        {"DmaAdapterObject",                NULL, 0, COPY, 0, (PVOID) &DmaAdapterObject             },
        {"PortConfig",                      NULL, 0, COPY, 0, (PVOID) &PortConfig                   },
        {"AllocatedResources",              NULL, 0, COPY, 0, (PVOID) &AllocatedResources           },
        {"TranslatedResources",             NULL, 0, COPY, 0, (PVOID) &TranslatedResources          },
        {"InterruptLevel",                  NULL, 0, COPY, 0, (PVOID) &InterruptLevel               },
        {"IoAddress",                       NULL, 0, COPY, 0, (PVOID) &IoAddress                    },
        {"MapBuffers",                      NULL, 0, COPY, 0, (PVOID) &MapBuffers                   },
        {"RemapBuffers",                    NULL, 0, COPY, 0, (PVOID) &RemapBuffers                 },
        {"MasterWithAdapter",               NULL, 0, COPY, 0, (PVOID) &MasterWithAdapter            },
        {"TaggedQueuing",                   NULL, 0, COPY, 0, (PVOID) &TaggedQueuing                },
        {"AutoRequestSense",                NULL, 0, COPY, 0, (PVOID) &AutoRequestSense             },
        {"MultipleRequestPerLu",            NULL, 0, COPY, 0, (PVOID) &MultipleRequestPerLu         },
        {"ReceiveEvent",                    NULL, 0, COPY, 0, (PVOID) &ReceiveEvent                 },
        {"CachesData",                      NULL, 0, COPY, 0, (PVOID) &CachesData                   },
        {"Dma64BitAddresses",               NULL, 0, COPY, 0, (PVOID) &Dma64BitAddresses            },
        {"Dma32BitAddresses",               NULL, 0, COPY, 0, (PVOID) &Dma32BitAddresses            },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    if(!ReadMemory(DeviceName,
                   (PVOID) name,
                   sizeof(WCHAR) * 256,
                   &Result)) {
        dprintf("Error reading DeviceName at address %p\n", DeviceName);
        return;
    }

    xdprintfEx(Depth, ("Device: %S\n", name));

    if (!ReadMemory(InterfaceName,
                    (PVOID) name,
                    sizeof(WCHAR) * (ULONG)InterfaceNameLen,
                    &Result)) {
        dprintf("Error reading interface name at address %p\n", InterfaceName);
        return;
    }

    xdprintfEx(Depth, ("Interface: %S\n", name));

    DumpPointerField("Hw Device Extension", HwDeviceExtension, Depth);
    DumpPointerField("SRB Extension", SrbExtensionBuffer, Depth);
    DumpPointerField("Non-cached Extension", NonCachedExtension, Depth);
    DumpUlongField("Port", PortNumber, Depth);
    DumpUlongField("Adapter", AdapterNumber, Depth);
    DumpUlongField("Active Requests", ActiveRequestCount+1, Depth);
    DumpPointerField("Sync Routine", SynchronizeExecution, Depth);
    DumpUlongField("PNP State", DeviceState, Depth);
    DumpUlongField("Tick Count", TickCount, Depth);

    xdprintfEx(Depth, ("Adapter Info:\n"));
    Depth++;
    if (IsMiniportDetected)
        xdprintfEx(Depth, ("Miniport detected\n"));
    if (IsInVirtualSlot)
        xdprintfEx(Depth, ("In virtual slot\n"));
    if (IsPnp)
        xdprintfEx(Depth, ("PNP adapter\n"));
    if (HasInterrupt)
        xdprintfEx(Depth, ("Has interrupt connected\n"));
    if (DisablePower)
        xdprintfEx(Depth, ("Can be powered off\n"));
    if (DisableStop)
        xdprintfEx(Depth, ("Can be stopped\n"));
    Depth--;

    xdprintfEx(Depth, ("Real Bus/Slot: 0x%08X/0x%08X\n", RealBusNumber, RealSlotNumber));
    DumpUlongField("Virtual PCI Slot", VirtualSlotNumber, Depth);
    DumpUcharField("Buses", NumberOfBuses, Depth);
    DumpUcharField("Max Target IDs", MaximumTargetIds, Depth);
    DumpUcharField("Max LUs", MaxLuCount, Depth);
    DumpUlongField("Disables", DisableCount, Depth);
    DumpPointerField("Map Register Base", MapRegisterBase, Depth);
    DumpPointerField("DMA Adapter", DmaAdapterObject, Depth);
    DumpPointerField("Port Config Info", PortConfig, Depth);
    DumpPointerField("Allocated Resources", AllocatedResources, Depth);
    DumpPointerField("Translated Resources", TranslatedResources, Depth);
    DumpUlongField("Interrupt Lvl", InterruptLevel, Depth);
    DumpPointerField("IO Address", IoAddress, Depth);
    DumpBooleanField("Must map buffers", MapBuffers, Depth);
    DumpBooleanField("Must remap buffers", RemapBuffers, Depth);
    DumpBooleanField("Bus Master", MasterWithAdapter, Depth);
    DumpBooleanField("Supports Tagged Queuing", TaggedQueuing, Depth);
    DumpBooleanField("Supports auto request sense", AutoRequestSense, Depth);
    DumpBooleanField("Supports multiple requests per LU", MultipleRequestPerLu, Depth);
    DumpBooleanField("Supports receive event", ReceiveEvent, Depth);
    DumpBooleanField("Caches data", CachesData, Depth);
    DumpBooleanField("Handles 64b DMA", Dma64BitAddresses, Depth);
    DumpBooleanField("Handles 32b DMA", Dma32BitAddresses, Depth);
    
    xdprintfEx(Depth, ("Logical Unit Info:\n"));
    MpDumpChildren(DeviceExtension, Depth);
    return;
}


VOID
MpDumpChildren(
    IN ULONG64 AdapterExtensionAddr,
    IN ULONG Depth
    )

{
    ULONG i;
    ULONG64 realLun;
    ULONG64 realLuns[8];
    ULONG64 lun;
    ULONG CurrentPnpState=0, PreviousPnpState=0, CurrentDeviceState=0;
    ULONG DesiredDeviceState=0, CurrentSystemState=0;
    ULONG64 DeviceObject=0, NextLogicalUnit=0;
    ULONG result;
    ULONG PathId=0, TargetId=0, Lun=0, ucd;
    ULONG IsClaimed=0, IsMissing=0, IsEnumerated=0, IsVisible=0, IsMismatched=0;
    ULONG b6, b7, b8;

    InitTypeRead(AdapterExtensionAddr, scsiport!_ADAPTER_EXTENSION);
    realLuns[0] = ReadField(LogicalUnitList[0].List);
    realLuns[1] = ReadField(LogicalUnitList[1].List);
    realLuns[2] = ReadField(LogicalUnitList[2].List);
    realLuns[3] = ReadField(LogicalUnitList[3].List);
    realLuns[4] = ReadField(LogicalUnitList[4].List);
    realLuns[5] = ReadField(LogicalUnitList[5].List);
    realLuns[6] = ReadField(LogicalUnitList[6].List);
    realLuns[7] = ReadField(LogicalUnitList[7].List);

    Depth++;

    for (i = 0; i < NUMBER_LOGICAL_UNIT_BINS; i++) {

        realLun = realLuns[i];
        
        while ((realLun != 0) && (!CheckControlC())) {
            FIELD_INFO deviceFields[] = {
               {"PathId",          NULL, 0, COPY, 0, (PVOID) &PathId},
               {"TargetId",        NULL, 0, COPY, 0, (PVOID) &TargetId},
               {"IsClaimed",       NULL, 0, COPY, 0, (PVOID) &IsClaimed},
               {"IsMissing",       NULL, 0, COPY, 0, (PVOID) &IsMissing},
               {"IsEnumerated",    NULL, 0, COPY, 0, (PVOID) &IsEnumerated},
               {"IsVisible",       NULL, 0, COPY, 0, (PVOID) &IsVisible},
               {"IsMismatched",    NULL, 0, COPY, 0, (PVOID) &IsMismatched},
               {"DeviceObject",    NULL, 0, COPY, 0, (PVOID) &DeviceObject},
               {"NextLogicalUnit", NULL, 0, COPY, 0, (PVOID) &NextLogicalUnit},
               {"CommonExtension.CurrentPnpState",    NULL, 0, COPY, 0, (PVOID) &CurrentPnpState},
               {"CommonExtension.PreviousPnpState" ,  NULL, 0, COPY, 0, (PVOID) &PreviousPnpState},
               {"CommonExtension.CurrentDeviceState", NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState},
               {"CommonExtension.DesiredDeviceState", NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState},
               {"CommonExtension.CurrentSystemState", NULL, 0, COPY, 0, (PVOID) &CurrentSystemState},
            };
            SYM_DUMP_PARAM DevSym = {
               sizeof (SYM_DUMP_PARAM), 
               "scsiport!_LOGICAL_UNIT_EXTENSION", 
               DBG_DUMP_NO_PRINT, 
               realLun,
               NULL, NULL, NULL, 
               sizeof (deviceFields) / sizeof (FIELD_INFO), 
               &deviceFields[0]
            };
            
            xdprintfEx(Depth, ("LUN "));
            dprintf("%08p ", realLun);

            if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
                dprintf("%08lx: Could not read device object\n", realLun);
                return;
            }

            result = (ULONG) InitTypeRead(realLun, scsiport!_LOGICAL_UNIT_EXTENSION);
            if (result != 0) {
                dprintf("could not init read type (%x)\n", result);
                return;
            }
            lun = ReadField(Lun);
            Lun = (UCHAR) lun;

            dprintf("@ (%3d,%3d,%3d) %c%c%c%c%c pnp(%02x/%02x) pow(%d%c,%d) DevObj %08p\n",
                    PathId,
                    TargetId,
                    Lun,
                    (IsClaimed ? 'c' : ' '),
                    (IsMissing ? 'm' : ' '),
                    (IsEnumerated ? 'e' : ' '),
                    (IsVisible ? 'v' : ' '),
                    (IsMismatched ? 'r' : ' '),
                    CurrentPnpState,
                    PreviousPnpState,
                    CurrentDeviceState - 1,
                    ((DesiredDeviceState == PowerDeviceUnspecified) ? ' ' : '*'),
                    CurrentSystemState - 1,
                    DeviceObject);

            realLun = ReadField(NextLogicalUnit);
        }
    }

    return;
}


VOID
MpDumpInterruptData(
    IN PINTERRUPT_DATA Data,
    IN PINTERRUPT_DATA RealData,
    IN ULONG Detail,
    IN ULONG Depth
    )

{
    xdprintfEx(Depth, ("Interrupt Data @0x%p:\n", RealData));

    Depth++;

    DumpFlags(Depth, "Flags", Data->InterruptFlags, AdapterFlags);

    xdprintfEx(Depth, ("Ready LUN 0x%p   Wmi Events 0x%p\n",
                       Data->ReadyLogicalUnit,
                       Data->WmiMiniPortRequests));

    {
        ULONG count = 0;
        PSRB_DATA request = Data->CompletedRequests;

        xdprintfEx(Depth, ("Completed Request List (@0x%p): ",
                           &(RealData->CompletedRequests)));

        Depth += 1;

        while((request != NULL) && (!CheckControlC())) {
            SRB_DATA data;
            ULONG result;

            if(Detail != 0) {
                if(count == 0) {
                    dprintf("\n");
                }
                xdprintfEx(Depth, ("SrbData 0x%p   ", request));
            }

            count++;

            if(!ReadMemory((ULONG_PTR)request,
                           (PVOID) &data,
                           sizeof(SRB_DATA),
                           &result)) {
                dprintf("Error reading structure\n");
                break;
            }

            if(Detail != 0) {
                dprintf("Srb 0x%p   Irp 0x%p\n",
                        data.CurrentSrb,
                        data.CurrentIrp);
            }

            request = data.CompletedRequests;
        }

        Depth -= 1;

        if((Detail == 0) || (count == 0)) {
            dprintf("%d entries\n", count);
        } else {
            xdprintfEx(Depth + 1, ("%d entries\n", count));
        }
    }

    return;
}


VOID
MpDumpPdo(
    IN ULONG64 Address,
    IN OPTIONAL PADAPTER_EXTENSION Adapter,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG offset;

    ULONG   PortNumber = 0;
    ULONG   PathId = 0;
    ULONG   TargetId = 0;
    ULONG   Lun = 0;
    ULONG64 HwLogicalUnitExtension = 0;
    ULONG64 AdapterExtension = 0;
    ULONG   IsClaimed = 0;
    ULONG   IsMissing = 0;
    ULONG   IsEnumerated = 0;
    ULONG   IsVisible = 0;
    ULONG   IsMismatched = 0;
    ULONG   luflags = 0;
    ULONG   RetryCount = 0;
    ULONG   CurrentKey = 0;
    ULONG   QueueLockCount = 0;
    ULONG   QueuePauseCount = 0;
    ULONG   LockRequest = 0;
    ULONG   RequestTimeoutCounter = 0;
    ULONG64 NextLogicalUnit = 0;
    ULONG64 ReadyLogicalUnit = 0;
    ULONG64 PendingRequest = 0;
    ULONG64 BusyRequest = 0;
    ULONG64 CurrentUntaggedRequest = 0;
    ULONG64 AbortSrb = 0;
    ULONG64 CompletedAbort = 0;
    ULONG   QueueCount = 0;
    ULONG   MaxQueueDepth = 0;
    ULONG64 TargetDeviceMapKey = 0;
    ULONG64 LunDeviceMapKey = 0;
    ULONG64 ActiveFailedRequest = 0;
    ULONG64 BlockedFailedRequest = 0;
    ULONG64 RequestSenseIrp = 0;
    ULONG64 RequestListFlink = 0;
    ULONG64 RequestList = 0;
    ULONG64 CommonExtensionDeviceObject = 0;
    ULONG64 RequestSenseSrb = 0;
    ULONG64 RequestSenseMdl = 0;
    ULONG Fields;
    ULONG TickCount;

    FIELD_INFO deviceFields[] = {
        {"PortNumber",                      "", 0, COPY, 0, (PVOID) &PortNumber                   },
        {"PathId",                          "", 0, COPY, 0, (PVOID) &PathId                       },
        {"TargetId",                        "", 0, COPY, 0, (PVOID) &TargetId                     },
        {"Lun",                             "", 0, COPY, 0, (PVOID) &Lun                          },
        {"HwLogicalUnitExtension",          "", 0, COPY, 0, (PVOID) &HwLogicalUnitExtension       },
        {"AdapterExtension",                "", 0, COPY, 0, (PVOID) &AdapterExtension             },
        {"IsClaimed",                       "", 0, COPY, 0, (PVOID) &IsClaimed                    },
        {"IsMissing",                       "", 0, COPY, 0, (PVOID) &IsMissing                    },
        {"IsEnumerated",                    "", 0, COPY, 0, (PVOID) &IsEnumerated                 },
        {"IsVisible",                       "", 0, COPY, 0, (PVOID) &IsVisible                    },
        {"IsMismatched",                    "", 0, COPY, 0, (PVOID) &IsMismatched                 },
        {"LuFlags",                         "", 0, COPY, 0, (PVOID) &luflags                      },
        {"RetryCount",                      "", 0, COPY, 0, (PVOID) &RetryCount                   },
        {"CurrentKey",                      "", 0, COPY, 0, (PVOID) &CurrentKey                   },
        {"QueueLockCount",                  "", 0, COPY, 0, (PVOID) &QueueLockCount               },
        {"QueuePauseCount",                 "", 0, COPY, 0, (PVOID) &QueuePauseCount              },
        {"LockRequest",                     "", 0, COPY, 0, (PVOID) &LockRequest                  },
        {"RequestTimeoutCounter",           "", 0, COPY, 0, (PVOID) &RequestTimeoutCounter        },
        {"RetryCount",                      "", 0, COPY, 0, (PVOID) &RetryCount                   },
        {"CurrentKey",                      "", 0, COPY, 0, (PVOID) &CurrentKey                   },
        {"QueueLockCount",                  "", 0, COPY, 0, (PVOID) &QueueLockCount               },
        {"QueuePauseCount",                 "", 0, COPY, 0, (PVOID) &QueuePauseCount              },
        {"LockRequest",                     "", 0, COPY, 0, (PVOID) &LockRequest                  },
        {"RequestTimeoutCounter",           "", 0, COPY, 0, (PVOID) &RequestTimeoutCounter        },
        {"NextLogicalUnit",                 "", 0, COPY, 0, (PVOID) &NextLogicalUnit              },
        {"ReadyLogicalUnit",                "", 0, COPY, 0, (PVOID) &ReadyLogicalUnit             },
        {"PendingRequest",                  "", 0, COPY, 0, (PVOID) &PendingRequest               },
        {"BusyRequest",                     "", 0, COPY, 0, (PVOID) &BusyRequest                  },
        {"CurrentUntaggedRequest",          "", 0, COPY, 0, (PVOID) &CurrentUntaggedRequest       },
        {"AbortSrb",                        "", 0, COPY, 0, (PVOID) &AbortSrb                     },
        {"CompletedAbort",                  "", 0, COPY, 0, (PVOID) &CompletedAbort               },
        {"QueueCount",                      "", 0, COPY, 0, (PVOID) &QueueCount                   },
        {"MaxQueueDepth",                   "", 0, COPY, 0, (PVOID) &MaxQueueDepth                },
        {"TargetDeviceMapKey",              "", 0, COPY, 0, (PVOID) &TargetDeviceMapKey           },
        {"LunDeviceMapKey",                 "", 0, COPY, 0, (PVOID) &LunDeviceMapKey              },
        {"ActiveFailedRequest",             "", 0, COPY, 0, (PVOID) &ActiveFailedRequest          },
        {"BlockedFailedRequest",            "", 0, COPY, 0, (PVOID) &BlockedFailedRequest         },
        {"RequestSenseIrp",                 "", 0, COPY, 0, (PVOID) &RequestSenseIrp              },
        {"CommonExtension.DeviceObject",    "", 0, COPY, 0, (PVOID) &CommonExtensionDeviceObject  },
        {"RequestList.Flink",               "", 0, COPY, 0, (PVOID) &RequestListFlink             },
        {"RequestList",                     "", 0, ADDROF, 0, NULL },
        {"RequestSenseSrb",                 "", 0, ADDROF, 0, NULL },
        {"RequestSenseMdl",                 "", 0, ADDROF, 0, NULL },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_LOGICAL_UNIT_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("%08p: Could not read device object\n", Address);
        return;
    }

    Fields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    RequestList = deviceFields[Fields-3].address;
    RequestSenseSrb = deviceFields[Fields-2].address;
    RequestSenseMdl = deviceFields[Fields-1].address;

    InitTypeRead(AdapterExtension, scsiport!_ADAPTER_EXTENSION);
    TickCount = (ULONG) ReadField(TickCount);

    xdprintfEx(Depth, ("Address (Port, PathId, TargetId, Lun): (%d, %d, %d, %d)\n",
                       PortNumber, PathId, TargetId, Lun));

    DumpPointerField("HW Logical Unit Ext", HwLogicalUnitExtension, Depth);
    DumpPointerField("Adapter Ext", AdapterExtension, Depth);

    xdprintfEx(Depth, ("State:"));
    if (IsClaimed)    xdprintf(0, " Claimed");
    if (IsMissing)    xdprintf(0, " Missing");
    if (IsEnumerated) xdprintf(0, " Enumerated");
    if (IsVisible)    xdprintf(0, " Visible");
    if (IsMismatched) xdprintf(0, " Mismatched");
    dprintf("\n");

    DumpFlags(Depth, "LuFlags", luflags, LuFlags);

    DumpUcharField("Retries      ", RetryCount, Depth);
    DumpUlongField("Key          ", CurrentKey, Depth);
    DumpUlongField("Locks        ", QueueLockCount, Depth);
    DumpUlongField("Pauses       ", QueuePauseCount, Depth);
    DumpUlongField("Current Lock ", LockRequest, Depth);
    DumpUlongField("Timeou       ", RequestTimeoutCounter, Depth);
    xdprintfEx(Depth, ("Next LUN: %p   Ready LUN: %p\n", 
                       NextLogicalUnit, ReadyLogicalUnit));

    xdprintfEx(Depth, ("Requests:\n"));
    Depth++;
    DumpPointerField("Pending  ", PendingRequest, Depth);
    DumpPointerField("Busy     ", BusyRequest, Depth);
    DumpPointerField("Untagged ", CurrentUntaggedRequest, Depth);
    Depth--;

    xdprintfEx(Depth, ("Abort SRB Info:\n"));
    Depth++;
    DumpPointerField("Current  ", AbortSrb, Depth);
    DumpPointerField("Completed", CompletedAbort, Depth);
    Depth--;

    xdprintfEx(Depth, ("Queue Depth: %03d (Max: %03d)\n", QueueCount, MaxQueueDepth));

    xdprintfEx(Depth, ("Device Map Keys:\n"));
    Depth++;
    DumpUlongField("Target ", (ULONG)TargetDeviceMapKey, Depth);
    DumpUlongField("Lun    ", (ULONG)LunDeviceMapKey, Depth);
    Depth--;

    if(((PVOID)ActiveFailedRequest != NULL) ||
       ((PVOID)BlockedFailedRequest != NULL)) {
        xdprintfEx(Depth, ("Failed Requests:\n"));
        Depth++;

        if((PVOID)ActiveFailedRequest != NULL) {
            DumpPointerField("Active", ActiveFailedRequest, Depth);
        }

        if((PVOID)BlockedFailedRequest != NULL) {
            DumpPointerField("Blocked", BlockedFailedRequest, Depth);
        }
        Depth--;
    }

    xdprintfEx(Depth, ("Request Sense:\n"));
    Depth++;
    DumpPointerField("IRP", RequestSenseIrp, Depth);
    DumpPointerField("SRB", RequestSenseSrb, Depth);
    DumpPointerField("MDL", RequestSenseMdl, Depth);
    Depth--;

    if (RequestListFlink == RequestList) {
        xdprintfEx(Depth, ("Request List @"));
        dprintf("%08p is empty\n", RequestList);
    } else {
        xdprintfEx(Depth, ("Request list @"));
        dprintf("%08p:\n", RequestList);
        MpDumpActiveRequests(RequestList,
                             TickCount,
                             Depth + 2);
    }
#if 0
//    if(Detail != 0) {
        xdprintfEx(Depth, ("Queued requests:\n"));

        MpDumpRequests(
            CommonExtensionDeviceObject,       
            TickCount,
            Depth + 2
            );
//    }
#endif
    return;
}

ULONG64
MpGetOffsetOfField(
    IN PCCHAR Type,
    IN PCCHAR Field
    )
{
    FIELD_INFO offsetField[] = {
        {Field, NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       Type, 
       DBG_DUMP_NO_PRINT, 
       0,
       NULL, NULL, NULL, 
       1,
       &offsetField[0]
    };

    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        return (ULONG)-1;
    }

    return offsetField[0].address;
}

VOID
MpDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG64 lastEntry;
    ULONG64 entry;
    ULONG64 realEntry;
    ULONG64 OffsetOfRequestList;
    ULONG64 CurrentSrb = 0;
    ULONG64 CurrentIrp = 0;
    ULONG64 RequestList = 0;
    ULONG SrbTickCount = 0;

    FIELD_INFO deviceFields[] = {
        {"CurrentSrb",          NULL, 0, COPY, 0, (PVOID) &CurrentSrb          },
        {"CurrentIrp",          NULL, 0, COPY, 0, (PVOID) &CurrentIrp          },
        {"TickCount",           NULL, 0, COPY, 0, (PVOID) &SrbTickCount        },
        {"RequestList",         NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       0,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    OffsetOfRequestList = MpGetOffsetOfField("scsiport!_SRB_DATA", "RequestList");
    
    entry = ListHead;
    realEntry = entry;
    
    InitTypeRead(ListHead, nt!_LIST_ENTRY);
    lastEntry = ReadField(Blink);

    xdprintf(Depth, "Tick count is %d\n", TickCount);
    do {
        ULONG64 realSrbData;

        ULONG result;

        InitTypeRead(realEntry, nt!_LIST_ENTRY);
        entry = ReadField(Flink);

        //
        // entry points to the list entry element of the srb data.  Calculate
        // the address of the start of the srb data block.
        //

        realSrbData = entry - OffsetOfRequestList;

        xdprintfEx(Depth, ("SrbData "));
        dprintf("%08p   ", realSrbData);

        //
        // Read the SRB_DATA information we need.
        //

        DevSym.addr = realSrbData;
        if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
            dprintf("%08p: Could not read device object\n", realSrbData);
            return;
        }
        RequestList = deviceFields[3].address;
        
        //
        // Update realEntry.
        //

        realEntry = RequestList;

        dprintf("Srb %08p   Irp %08p   %s\n",
                CurrentSrb,
                CurrentIrp,
                MpSecondsToString(TickCount - SrbTickCount));

    } while((entry != lastEntry) && (!CheckControlC()));

    return;
}

VOID
MpDumpSrbData(
    PSRB_DATA SrbData,
    ULONG Depth
    )
{
    if (SrbData->Type != SRB_DATA_TYPE) {
        dprintf("Type (%#x) does not match SRB_DATA_TYPE (%#x)\n", SrbData->Type, SRB_DATA_TYPE);
    }

    xdprintfEx(Depth, ("Lun  0x%p   Srb 0x%p   Irp 0x%p\n", SrbData->LogicalUnit, SrbData->CurrentSrb, SrbData->CurrentIrp));
    xdprintfEx(Depth, ("Sense 0x%p  Tag  0x%08lx  Next Completed 0x%p\n", SrbData->RequestSenseSave, SrbData->QueueTag, SrbData->CompletedRequests));
    xdprintfEx(Depth, ("Retry 0x%02x        Seq 0x%08lx   Flags 0x%08lx\n", SrbData->ErrorLogRetryCount, SrbData->SequenceNumber, SrbData->Flags));
    xdprintfEx(Depth, ("Request List:     Next 0x%p  Previous 0x%p\n", SrbData->RequestList.Flink, SrbData->RequestList.Blink));
    xdprintfEx(Depth, ("Data Offset 0x%p    Original Data Buffer 0x%p\n", SrbData->DataOffset, SrbData->OriginalDataBuffer));
    xdprintfEx(Depth, ("Map Registers 0x%p (0x%02x)    SG List 0x%p\n", SrbData->MapRegisterBase, SrbData->NumberOfMapRegisters, SrbData->ScatterGatherList));

    if (SrbData->ScatterGatherList != NULL) {
        UCHAR buffer[512];
        PSRB_SCATTER_GATHER scatterGatherList = (PSRB_SCATTER_GATHER) &buffer;
        ULONG result;

        result = ReadMemory((ULONG_PTR)SrbData->ScatterGatherList,
                            (PVOID) scatterGatherList,
                            (sizeof(SRB_SCATTER_GATHER) * SrbData->NumberOfMapRegisters),
                            &result);
       
        if (result == 0) {
            xdprintfEx(Depth+1, ("Error reading scatter gather list %#p\n", SrbData->ScatterGatherList));
            return;
        }
       
        MpDumpScatterGatherList(scatterGatherList, SrbData->NumberOfMapRegisters, Depth + 1);
    }

    return;
}


VOID
MpDumpScatterGatherList(
    PSRB_SCATTER_GATHER List,
    ULONG Entries,
    ULONG Depth
    )
{
    ULONG i;
    BOOLEAN start = TRUE;

    for (i = 0; i < Entries; i++) {

        if (start) {
            // BUGBUG - PhysicalAddress should be 64 bits but isn't
            xdprintfEx(Depth, ("0x%016I64x (0x%08lx), ", List[i].Address, List[i].Length));
        } else {
            // BUGBUG - PhysicalAddress should be 64 bits but isn't
            dprintf("0x%016I64x (0x%08lx),\n", List[i].Address, List[i].Length);
        }

        start = !start;
    }

    if (start == FALSE) {
        dprintf("\n");
    }
}

PUCHAR 
MpSecondsToString(
    ULONG Count
    )  
{
    static UCHAR string[64] = "";
    UCHAR tmp[16];
    ULONG seconds = 0;
    ULONG minutes = 0;
    ULONG hours = 0;
    ULONG days = 0;
    
    string[0] = '\0';

    if (Count == 0) {
        sprintf(string, "<1s");
        return string;
    }

    seconds = Count % 60;
    Count /= 60;
    
    if (Count != 0) {
        minutes = Count % 60;
        Count /= 60;
    }
        
    if (Count != 0) {
        hours = Count % 24;
        Count /= 24;
    }

    if (Count != 0) {
        days = Count;
    }

    if (days != 0) {
        sprintf(tmp, "%dd", days);
        strcat(string, tmp);
    }

    if (hours != 0) {
        sprintf(tmp, "%dh", hours);
        strcat(string, tmp);
    }

    if (minutes != 0) {
        sprintf(tmp, "%dm", minutes);
        strcat(string, tmp);
    }

    if (seconds != 0) {
        sprintf(tmp, "%ds", seconds);
        strcat(string, tmp);
    }

    return string;
}

VOID
MpDumpRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG result;
    LIST_ENTRY listHead;
    PLIST_ENTRY realEntry;
    ULONG64 DeviceQueue;
    ULONG offset;

    //
    // Read the queue out of the device object.
    //

    result = GetFieldData(DeviceObject, "nt!_DEVICE_OBJECT", "DeviceQueue.DeviceListHead", sizeof(LIST_ENTRY), &listHead);
    if (result) {
        dprintf("GetFieldValue @(%s %d) failed (%08X)\n", __FILE__, __LINE__, result);
        return;
    }

    if (listHead.Flink == listHead.Blink) {
        xdprintf(Depth, "Device Queue is empty\n");
        return;
    }

    result = GetFieldData(DeviceObject, "nt!_DEVICE_OBJECT", "DeviceQueue", sizeof(ULONG64), &DeviceQueue);
    if (result) {
        dprintf("GetFieldData @(%s %d) failed (%08X)\n", __FILE__, __LINE__, result);
        return;
    }
    
    result = GetFieldOffset("nt!_KDEVICE_QUEUE", "DeviceListHead", &offset);

    realEntry = (LIST_ENTRY*)(DeviceQueue + offset);
    
    return;
#if 0

    do {

        LIST_ENTRY entry;

        PIRP realIrp;
        PIO_STACK_LOCATION realStack;
        PSCSI_REQUEST_BLOCK realSrb;
        PSRB_DATA realSrbData;

        SRB_DATA srbData;

        ULONG result;

        //
        // we've got a pointer to the first list_entry in the list.  Read the 
        // whole thing in so we can see where the next entry will be.
        //

        if(!ReadMemory((ULONG_PTR) realEntry, 
                       &entry,
                       sizeof(LIST_ENTRY),
                       &result)) {
            dprintf("Error reading list entry\n");
            break;
        }

        realEntry = entry.Flink;

        //
        // entry points to the middle of an irp.  Figure out the address of 
        // of the beginning of the irp (save it) and then figure out the 
        // address of the current irp stack location from there.
        //

        realIrp = CONTAINING_RECORD(
                    realEntry, 
                    IRP, 
                    Tail.Overlay.DeviceQueueEntry.DeviceListEntry);

        if(!ReadMemory((ULONG_PTR) &(realIrp->Tail.Overlay.CurrentStackLocation),
                       &realStack,
                       sizeof(PIO_STACK_LOCATION), 
                       &result)) {
            dprintf("Error reading stack address %p\n", &(realIrp->Tail.Overlay.CurrentStackLocation));
            break;
        }

        //
        // Load the SRB field of the stack location.
        //

        if(!ReadMemory(
                (ULONG_PTR) &(realStack->Parameters.Scsi.Srb),
                &realSrb,
                sizeof(PSCSI_REQUEST_BLOCK),
                &result)) {
            dprintf("Error reading srb address\n");
            break;
        }

        //
        // Pick out the pointer to the srb data and read that in.
        //

        if(!ReadMemory(
                (ULONG_PTR) &(realSrb->OriginalRequest),
                &realSrbData,
                sizeof(PSRB_DATA),
                &result)) {
            dprintf("Error reading srbData address\n");
            break;
        }

        xdprintf(Depth, "SrbData 0x%p   ", realSrbData);

        if(!ReadMemory((ULONG_PTR)realSrbData,
                       (PVOID) &srbData,
                       sizeof(SRB_DATA),
                       &result)) {
            dprintf("Error reading structure\n");
            break;
        }

        dprintf("Srb 0x%p   Irp 0x%p   %s\n",
                srbData.CurrentSrb,
                srbData.CurrentIrp,
                MpSecondsToString(TickCount - srbData.TickCount));

    } while((realEntry != listHead.Blink) && (!CheckControlC()));

    return;
#endif
}

VOID
MpDumpAccessRange(
    IN ULONG64 address,
    IN ULONG Depth
    )
{
    ULONG64 RangeStart;
    ULONG RangeLength;
    BOOLEAN RangeInMemory;

    InitTypeRead(address, scsiport!_ACCESS_RANGE);
    RangeStart = ReadField(RangeStart.QuadPart);
    RangeLength = (ULONG) ReadField(RangeLength);
    RangeInMemory = (BOOLEAN) ReadField(RangeInMemory);

    xdprintfEx(Depth, ("@ %08p  %08p   %08x   %s\n",
                       address,
                       RangeStart,
                       RangeLength,
                       RangeInMemory ? "YES" : "NO"));

    return;
}

VOID
MpDumpSrb(
    IN ULONG64 Srb,
    IN ULONG Depth
    )
{
    ULONG   result = 0;

    USHORT  Length = 0;
    UCHAR   Function = 0;
    UCHAR   SrbStatus = 0;
    UCHAR   ScsiStatus = 0;
    UCHAR   PathId = 0;
    UCHAR   TargetId = 0;
    UCHAR   Lun = 0;
    UCHAR   QueueTag = 0;
    UCHAR   QueueAction = 0;
    UCHAR   CdbLength = 0;
    UCHAR   SenseInfoBufferLength = 0;
    ULONG   Flags = 0;
    ULONG   DataTransferLength = 0;
    ULONG   TimeOutValue = 0;
    ULONG64 DataBuffer = 0;
    ULONG64 SenseInfoBuffer = 0;
    ULONG64 NextSrb = 0;
    ULONG64 OriginalRequest = 0;
    ULONG64 SrbExtension = 0;
    ULONG   InternalStatus = 0;
    ULONG64 AddrOfCdb = 0;
    UCHAR   Cdb[16];
    ULONG   i;
    
    FIELD_INFO deviceFields[] = {
        {"Length",                 NULL, 0, COPY, 0, (PVOID) &Length                 },
        {"Function",               NULL, 0, COPY, 0, (PVOID) &Function               },
        {"SrbStatus",              NULL, 0, COPY, 0, (PVOID) &SrbStatus              },
        {"ScsiStatus",             NULL, 0, COPY, 0, (PVOID) &ScsiStatus             },
        {"PathId",                 NULL, 0, COPY, 0, (PVOID) &PathId                 },
        {"TargetId",               NULL, 0, COPY, 0, (PVOID) &TargetId               },
        {"Lun",                    NULL, 0, COPY, 0, (PVOID) &Lun                    },
        {"QueueTag",               NULL, 0, COPY, 0, (PVOID) &QueueTag               },
        {"QueueAction",            NULL, 0, COPY, 0, (PVOID) &QueueAction            },
        {"CdbLength",              NULL, 0, COPY, 0, (PVOID) &CdbLength              },
        {"SenseInfoBufferLength",  NULL, 0, COPY, 0, (PVOID) &SenseInfoBufferLength  },
        {"SrbFlags",               NULL, 0, COPY, 0, (PVOID) &Flags                  },
        {"DataTransferLength",     NULL, 0, COPY, 0, (PVOID) &DataTransferLength     },
        {"TimeOutValue",           NULL, 0, COPY, 0, (PVOID) &TimeOutValue           },
        {"DataBuffer",             NULL, 0, COPY, 0, (PVOID) &DataBuffer             },
        {"SenseInfoBuffer",        NULL, 0, COPY, 0, (PVOID) &SenseInfoBuffer        },
        {"NextSrb",                NULL, 0, COPY, 0, (PVOID) &NextSrb                },
        {"OriginalRequest",        NULL, 0, COPY, 0, (PVOID) &OriginalRequest        },
        {"SrbExtension",           NULL, 0, COPY, 0, (PVOID) &SrbExtension           },
        {"InternalStatus",         NULL, 0, COPY, 0, (PVOID) &InternalStatus         },
        {"Cdb",                    NULL, 0, ADDROF, 0, NULL   },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SCSI_REQUEST_BLOCK", 
       DBG_DUMP_NO_PRINT, 
       Srb,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("Could not read SRB @ %08p\n", Srb);
        return;
    }

    AddrOfCdb = deviceFields[(sizeof (deviceFields) / sizeof (FIELD_INFO)) - 1].address;
    if (!ReadMemory((ULONG64)AddrOfCdb, Cdb, sizeof(UCHAR) * 16, &result)) {
        dprintf("Error reading access range\n");
        return;
    }

    xdprintf(Depth, "SCSI_REQUEST_BLOCK:\n");
    DumpUshortField("Length", Length, Depth);

    if (Function < MINIKD_MAX_SCSI_FUNCTION) {
        xdprintfEx(Depth, ("%s: 0x%02X (%s)\n", "Function", Function, MiniScsiFunction[Function]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%02X (???)\n", "Function", Function));
    }

    xdprintfEx(Depth, ("%s: 0x%02X (", "Status", SrbStatus));
    if (SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        dprintf("SRB_STATUS_AUTOSENSE_VALID | ");
    } 
    if (SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
        dprintf("SRB_STATUS_QUEUE_FROZEN | ");
    }
    if (SRB_STATUS(SrbStatus) < MINIKD_MAX_SCSI_FUNCTION) {
        dprintf("%s)", MiniScsiSrbStatus[SRB_STATUS(SrbStatus)]);
    } else {
        dprintf("???)");
    }
    dprintf("\n");

    DumpUcharField("ScsiStatus ", ScsiStatus, Depth);
    DumpUcharField("PathId     ", PathId, Depth);
    DumpUcharField("TargetId   ", TargetId, Depth);
    DumpUcharField("Lun        ", Lun, Depth);
    DumpUcharField("QueueTag   ", QueueTag, Depth);
    DumpUcharField("QueueAction", QueueAction, Depth);
    DumpUcharField("CdbLength  ", CdbLength, Depth);
    DumpUcharField("SenseInfoBufferLength", SenseInfoBufferLength, Depth);

    DumpFlags(Depth, "SrbFlags", Flags, SrbFlags);

    DumpUlongField("DataTransferLength", DataTransferLength, Depth);
    DumpUlongField("TimeOutValue      ", TimeOutValue, Depth);
    DumpPointerField("DataBuffer      ", DataBuffer, Depth);
    DumpPointerField("SenseInfoBuffer ", SenseInfoBuffer, Depth);
    DumpPointerField("NextSrb         ", NextSrb, Depth);
    DumpPointerField("OriginalRequest ", OriginalRequest, Depth);
    DumpPointerField("SrbExtension    ", SrbExtension, Depth);
    DumpUlongField("InternalStatus  ", InternalStatus, Depth);

    xdprintfEx(Depth, ("%s: ", "Cdb"));
    for (i=0; i<CdbLength; i++) {
        dprintf("%x ", Cdb[i]);
    }
    dprintf("\n");

    return;
}

VOID
MpDumpPortConfigurationInformation(
    IN ULONG64 PortConfigInfo,
    IN ULONG Depth
    )
{
    ULONG i;
    ULONG_PTR range;
    ULONG Fields;
    UCHAR BusId[8];
    ULONG status;
    ULONG result;

    ULONG           Length                              = 0;
    ULONG           SystemIoBusNumber                   = 0;
    INTERFACE_TYPE  AdapterInterfaceType                = 0;
    ULONG           BusInterruptLevel                   = 0;
    ULONG           BusInterruptVector                  = 0;
    KINTERRUPT_MODE InterruptMode                       = 0;
    ULONG           MaximumTransferLength               = 0;
    ULONG           NumberOfPhysicalBreaks              = 0;
    ULONG           DmaChannel                          = 0;
    ULONG           DmaPort                             = 0;
    DMA_WIDTH       DmaWidth                            = 0;
    DMA_SPEED       DmaSpeed                            = 0;
    ULONG           AlignmentMask                       = 0;
    ULONG           NumberOfAccessRanges                = 0;
    PVOID           Reserved                            = 0;
    UCHAR           NumberOfBuses                       = 0;
    BOOLEAN         ScatterGather                       = 0;
    BOOLEAN         Master                              = 0;
    BOOLEAN         CachesData                          = 0;
    BOOLEAN         AdapterScansDown                    = 0;
    BOOLEAN         AtdiskPrimaryClaimed                = 0;
    BOOLEAN         AtdiskSecondaryClaimed              = 0;
    BOOLEAN         Dma32BitAddresses                   = 0;
    BOOLEAN         DemandMode                          = 0;
    BOOLEAN         MapBuffers                          = 0;
    BOOLEAN         NeedPhysicalAddresses               = 0;
    BOOLEAN         TaggedQueuing                       = 0;
    BOOLEAN         AutoRequestSense                    = 0;
    BOOLEAN         MultipleRequestPerLu                = 0;
    BOOLEAN         ReceiveEvent                        = 0;
    BOOLEAN         RealModeInitialized                 = 0;
    BOOLEAN         BufferAccessScsiPortControlled      = 0;
    UCHAR           MaximumNumberOfTargets              = 0;
    ULONG           SlotNumber                          = 0;
    ULONG           BusInterruptLevel2                  = 0;
    ULONG           BusInterruptVector2                 = 0;
    KINTERRUPT_MODE InterruptMode2                      = 0;
    ULONG           DmaChannel2                         = 0;
    ULONG           DmaPort2                            = 0;
    DMA_WIDTH       DmaWidth2                           = 0;
    DMA_SPEED       DmaSpeed2                           = 0;
    ULONG           DeviceExtensionSize                 = 0;
    ULONG           SpecificLuExtensionSize             = 0;
    ULONG           SrbExtensionSize                    = 0;
    UCHAR           Dma64BitAddresses                   = 0;
    BOOLEAN         ResetTargetSupported                = 0;
    UCHAR           MaximumNumberOfLogicalUnits         = 0;
    BOOLEAN         WmiDataProvider                     = 0;
    ULONG64         InitiatorBusId                      = 0;
    ULONG64         AccessRanges                        = 0;
    
    FIELD_INFO deviceFields[] = {
        {"Length",                           NULL, 0, COPY, 0, (PVOID) &Length                        },
        {"SystemIoBusNumber",                NULL, 0, COPY, 0, (PVOID) &SystemIoBusNumber             },
        {"AdapterInterfaceType",             NULL, 0, COPY, 0, (PVOID) &AdapterInterfaceType          },
        {"BusInterruptLevel",                NULL, 0, COPY, 0, (PVOID) &BusInterruptLevel             },
        {"BusInterruptVector",               NULL, 0, COPY, 0, (PVOID) &BusInterruptVector            },
        {"InterruptMode",                    NULL, 0, COPY, 0, (PVOID) &InterruptMode                 },
        {"MaximumTransferLength",            NULL, 0, COPY, 0, (PVOID) &MaximumTransferLength         },
        {"NumberOfPhysicalBreaks",           NULL, 0, COPY, 0, (PVOID) &NumberOfPhysicalBreaks        },
        {"DmaChannel",                       NULL, 0, COPY, 0, (PVOID) &DmaChannel                    },
        {"DmaPort",                          NULL, 0, COPY, 0, (PVOID) &DmaPort                       },
        {"DmaWidth",                         NULL, 0, COPY, 0, (PVOID) &DmaWidth                      },
        {"DmaSpeed",                         NULL, 0, COPY, 0, (PVOID) &DmaSpeed                      },
        {"AlignmentMask",                    NULL, 0, COPY, 0, (PVOID) &AlignmentMask                 },
        {"NumberOfAccessRanges",             NULL, 0, COPY, 0, (PVOID) &NumberOfAccessRanges          },
        {"Reserved",                         NULL, 0, COPY, 0, (PVOID) &Reserved                      },
        {"NumberOfBuses",                    NULL, 0, COPY, 0, (PVOID) &NumberOfBuses                 },
        {"ScatterGather",                    NULL, 0, COPY, 0, (PVOID) &ScatterGather                 },
        {"Master",                           NULL, 0, COPY, 0, (PVOID) &Master                        },
        {"CachesData",                       NULL, 0, COPY, 0, (PVOID) &CachesData                    },
        {"AdapterScansDown",                 NULL, 0, COPY, 0, (PVOID) &AdapterScansDown              },
        {"AtdiskPrimaryClaimed",             NULL, 0, COPY, 0, (PVOID) &AtdiskPrimaryClaimed          },
        {"AtdiskSecondaryClaimed",           NULL, 0, COPY, 0, (PVOID) &AtdiskSecondaryClaimed        },
        {"Dma32BitAddresses",                NULL, 0, COPY, 0, (PVOID) &Dma32BitAddresses             },
        {"DemandMode",                       NULL, 0, COPY, 0, (PVOID) &DemandMode                    },
        {"MapBuffers",                       NULL, 0, COPY, 0, (PVOID) &MapBuffers                    },
        {"NeedPhysicalAddresses",            NULL, 0, COPY, 0, (PVOID) &NeedPhysicalAddresses         },
        {"TaggedQueuing",                    NULL, 0, COPY, 0, (PVOID) &TaggedQueuing                 },
        {"AutoRequestSense",                 NULL, 0, COPY, 0, (PVOID) &AutoRequestSense              },
        {"MultipleRequestPerLu",             NULL, 0, COPY, 0, (PVOID) &MultipleRequestPerLu          },
        {"ReceiveEvent",                     NULL, 0, COPY, 0, (PVOID) &ReceiveEvent                  },
        {"RealModeInitialized",              NULL, 0, COPY, 0, (PVOID) &RealModeInitialized           },
        {"BufferAccessScsiPortControlled",   NULL, 0, COPY, 0, (PVOID) &BufferAccessScsiPortControlled},
        {"MaximumNumberOfTargets",           NULL, 0, COPY, 0, (PVOID) &MaximumNumberOfTargets        },
        {"SlotNumber",                       NULL, 0, COPY, 0, (PVOID) &SlotNumber                    },
        {"BusInterruptLevel2",               NULL, 0, COPY, 0, (PVOID) &BusInterruptLevel2            },
        {"BusInterruptVector2",              NULL, 0, COPY, 0, (PVOID) &BusInterruptVector2           },
        {"InterruptMode2",                   NULL, 0, COPY, 0, (PVOID) &InterruptMode2                },
        {"DmaChannel2",                      NULL, 0, COPY, 0, (PVOID) &DmaChannel2                   },
        {"DmaPort2",                         NULL, 0, COPY, 0, (PVOID) &DmaPort2                      },
        {"DmaWidth2",                        NULL, 0, COPY, 0, (PVOID) &DmaWidth2                     },
        {"DmaSpeed2",                        NULL, 0, COPY, 0, (PVOID) &DmaSpeed2                     },
        {"DeviceExtensionSize",              NULL, 0, COPY, 0, (PVOID) &DeviceExtensionSize           },
        {"SpecificLuExtensionSize",          NULL, 0, COPY, 0, (PVOID) &SpecificLuExtensionSize       },
        {"SrbExtensionSize",                 NULL, 0, COPY, 0, (PVOID) &SrbExtensionSize              },
        {"Dma64BitAddresses",                NULL, 0, COPY, 0, (PVOID) &Dma64BitAddresses             },
        {"ResetTargetSupported",             NULL, 0, COPY, 0, (PVOID) &ResetTargetSupported          },
        {"MaximumNumberOfLogicalUnits",      NULL, 0, COPY, 0, (PVOID) &MaximumNumberOfLogicalUnits   },
        {"WmiDataProvider",                  NULL, 0, COPY, 0, (PVOID) &WmiDataProvider               },
        {"AccessRanges",                     NULL, 0, COPY, 0, (PVOID) &AccessRanges                  },
        {"InitiatorBusId[0]",                NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL          },
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_PORT_CONFIGURATION_INFORMATION", 
       DBG_DUMP_NO_PRINT, 
       PortConfigInfo,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
        dprintf("Could not read _PORT_CONFIGURATION_INFORMATION @ %08p\n", PortConfigInfo);
        return;
    }

    Fields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    InitiatorBusId = deviceFields[Fields-1].address;

    xdprintfEx(Depth, ("PORT_CONFIGURATION_INFORMATION:\n"));
    DumpUlongField("Length", Length, Depth);
    DumpUlongField("SysIoBus", SystemIoBusNumber, Depth);

    if (AdapterInterfaceType >= 0 &&
        AdapterInterfaceType < MaximumInterfaceType) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n",  "AdapterInterfaceType", AdapterInterfaceType, MiniInterfaceTypes[AdapterInterfaceType]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "AdapterInterfaceType", AdapterInterfaceType));
    }

    DumpUlongField("BusIntLvl", BusInterruptLevel, Depth);
    DumpUlongField("BusIntVector", BusInterruptVector, Depth);

    if (InterruptMode >= 0 &&
        InterruptMode <= Latched) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "InterruptMode", InterruptMode, MiniInterruptMode[InterruptMode]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "InterruptMode", InterruptMode));
    }
    
    DumpUlongField("MaximumTransferLength", MaximumTransferLength, Depth);
    DumpUlongField("NumberOfPhysicalBreaks", NumberOfPhysicalBreaks, Depth);
    DumpUlongField("DmaChannel", DmaChannel, Depth);
    DumpUlongField("DmaPort", DmaPort, Depth);

    if (DmaWidth >= 0 &&
        DmaWidth < MaximumDmaWidth) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "DmaWidth", DmaWidth, MiniDmaWidths[DmaWidth]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "DmaWidth", DmaWidth));
    }

    if (DmaSpeed >= 0 &&
        DmaSpeed < MaximumDmaSpeed) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "DmaSpeed", DmaSpeed, MiniDmaWidths[DmaSpeed]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "DmaSpeed", DmaSpeed));
    }
    
    DumpUlongField("AlignmentMask", AlignmentMask, Depth);
    DumpPointerField("Reserved", (ULONG_PTR)Reserved, Depth);
    DumpUlongField("NumberOfBuses", NumberOfBuses, Depth);

    status = ReadMemory(InitiatorBusId, (PVOID) BusId, sizeof(UCHAR) * 8, &result);
    if (!status) {
        dprintf("Error reading initiator bus id @ %08p\n", InitiatorBusId);
        return;
    }
    
    xdprintfEx(Depth, ("%s: ", "InitiatorBusId"));
    for (i = 0; i < 8; i++) {
        xdprintfEx(Depth, ("%02x ", BusId[i]));
    }
    xdprintfEx(Depth, ("\n"));

    DumpBooleanField("ScatterGather          ", ScatterGather, Depth);
    DumpBooleanField("Master                 ", Master, Depth);
    DumpBooleanField("AdapterScansDown       ", AdapterScansDown, Depth);
    DumpBooleanField("AtdiskPrimaryClaimed   ", AtdiskPrimaryClaimed, Depth);
    DumpBooleanField("AtdiskSecondaryClaimed ", AtdiskSecondaryClaimed, Depth);
    DumpBooleanField("Dma32BitAddresses      ", Dma32BitAddresses, Depth);
    DumpBooleanField("DemandMode             ", DemandMode, Depth);
    DumpBooleanField("MapBuffers             ", MapBuffers, Depth);
    DumpBooleanField("NeedPhysicalAddresses  ", NeedPhysicalAddresses, Depth);
    DumpBooleanField("TaggedQueuing          ", TaggedQueuing, Depth);
    DumpBooleanField("AutoRequestSense       ", AutoRequestSense, Depth);
    DumpBooleanField("MultipleRequestPerLu   ", MultipleRequestPerLu, Depth);
    DumpBooleanField("ReceiveEvent           ", ReceiveEvent, Depth);
    DumpBooleanField("RealModeInitialized    ", RealModeInitialized, Depth);
    DumpBooleanField("BufScsiPortControlled  ", BufferAccessScsiPortControlled, Depth);

    DumpUlongField("MaximumNumberOfTargets", MaximumNumberOfTargets, Depth);
    DumpUlongField("SlotNumber", SlotNumber, Depth);

    DumpUlongField("BusInterruptLevel2", BusInterruptLevel2, Depth);
    DumpUlongField("BusInterruptVector2", BusInterruptVector2, Depth);

    if (InterruptMode2 >= 0 &&
        InterruptMode2 <= Latched) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "InterruptMode2", InterruptMode2, MiniInterruptMode[InterruptMode2]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "InterruptMode2", InterruptMode2));
    }

    DumpUlongField("DmaChannel2", DmaChannel2, Depth);
    DumpUlongField("DmaPort2", DmaPort2, Depth);

    if (DmaWidth2 >= 0 &&
        DmaWidth2 < MaximumDmaWidth) {
        xdprintfEx(Depth, ("%s: 0x%X (%s)\n", "DmaWidth2", DmaWidth2, MiniDmaWidths[DmaWidth2]));
    } else {
        xdprintfEx(Depth, ("%s: 0x%X (???)\n", "DmaWidth2", DmaWidth2));
    }

    DumpUlongField("DeviceExtensionSize     ", DeviceExtensionSize, Depth);
    DumpUlongField("SpecificLuExtensionSize ", SpecificLuExtensionSize, Depth);
    DumpUlongField("SrbExtensionSize        ", SrbExtensionSize, Depth);
    DumpUlongField("Dma64BitAddresses       ", Dma64BitAddresses, Depth);
    DumpUlongField("ResetTargetSupported    ", ResetTargetSupported, Depth);
    DumpUlongField("MaxLogicalUnits         ", MaximumNumberOfLogicalUnits, Depth);
    DumpUlongField("WmiDataProvider         ", WmiDataProvider, Depth);
    
    DumpUlongField("NumberOfAccessRanges", NumberOfAccessRanges, Depth);
    xdprintfEx(Depth, ("Access Ranges...\n"));

    Depth++;
    for (i = 0; i < NumberOfAccessRanges; i++) {
        MpDumpAccessRange(AccessRanges, Depth);
        AccessRanges += sizeof(ACCESS_RANGE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\minipkd\minipkd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       minipkd.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\cdromkd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    cdromkd.c

Abstract:

    Debugger Extension Api for interpretting cdrom structure

Author:

    Henry Gabryjelski  (henrygab) 16-Feb-1999

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#include "classpnp.h" // #defines ALLOCATE_SRB_FROM_POOL as needed
#include "classp.h"   // Classpnp's private definitions
#include "cdrom.h"

#include "classkd.h"  // routines that are useful for all class drivers


FLAG_NAME XAFlags[] = {
    FLAG_NAME(XA_USE_6_BYTE),    // 0x01
    FLAG_NAME(XA_USE_10_BYTE),   // 0x02
    FLAG_NAME(XA_USE_READ_CD),   // 0x04
    FLAG_NAME(XA_NOT_SUPPORTED), // 0x08
    FLAG_NAME(XA_PLEXTOR_CDDA),  // 0x10
    FLAG_NAME(XA_NEC_CDDA),      // 0x20
    {0,0}
};

VOID
ClassDumpCdromData(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    );

DECLARE_API(cdromext)

/*++

Routine Description:

    Dumps the cdrom specific data for a given device object or
    given device extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 address;
    ULONG result;
    ULONG detail = 0;
    ULONG length;
    BOOLEAN IsFdo;
    ULONG64 DriverData;

    ASSERTMSG("data block too small to hold CDROM_DATA\n",
              sizeof(FUNCTIONAL_DEVICE_EXTENSION) > sizeof(CDROM_DATA));
    ASSERTMSG("data block too small to hold DEVICE_OBJECT\n",
              sizeof(FUNCTIONAL_DEVICE_EXTENSION) > sizeof(DEVICE_OBJECT));

    GetAddressAndDetailLevel64(args, &address, &detail);

    //
    // Convert the supplied address into a device extension if it is
    // the address of a device object.
    //

    address = GetDeviceExtension(address);

    //
    // Get the IsFdo flag which we use to determine how many bytes
    // to actually read.
    //

    result = GetFieldData(address,
                          "cdrom!COMMON_DEVICE_EXTENSION",
                          "IsFdo",
                          sizeof(BOOLEAN),
                          &IsFdo);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return E_FAIL;
    }

    if(!IsFdo) {
        xdprintfEx(0, ("Not an FDO\n"));
        return E_FAIL;
    }

    //
    // Dump the class-specific information
    //

    if (detail != 0) {
        ClassDumpCommonExtension(address,
                                 detail,
                                 0);
    }

    //
    // Now grab the pointer to our driver-specific data.
    //

    result = GetFieldData(address,
                          "cdrom!_COMMON_DEVICE_EXTENSION",
                          "DriverData",
                          sizeof(ULONG64),
                          &DriverData);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return E_FAIL;
    }

    //
    // And dump the driver-specific data.
    //

    ClassDumpCdromData(DriverData,
                       detail,
                       0);
    return S_OK;
}


VOID
ClassDumpCdromData(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG offset;

    ULONG CdDataXAFlags;
    BOOLEAN PlayActive;
    BOOLEAN RawAccess;
    BOOLEAN IsDecRrd;
    ULONG64 DelayedRetrySpinLock;
    ULONG64 DelayedRetryIrp;
    BOOLEAN DelayedRetryResend;
    ULONG DelayedRetryInterval;
    ULONG PickDvdRegion;
    BOOLEAN DvdRpc0Device;
    UCHAR Rpc0SystemRegion;
    UCHAR Rpc0SystemRegionResetCount;
   
    FIELD_INFO deviceFields[] = {
       {"XAFlags", NULL, 0, COPY, 0, (PVOID) &CdDataXAFlags},
       {"PlayActive", NULL, 0, COPY, 0, (PVOID) &PlayActive},
       {"RawAccess", NULL, 0, COPY, 0, (PVOID) &RawAccess},
       {"IsDecRrd", NULL, 0, COPY, 0, (PVOID) &IsDecRrd},
       {"DelayedRetrySpinLock", NULL, 0, COPY, 0, (PVOID) &DelayedRetrySpinLock},
       {"DelayedRetryIrp", NULL, 0, COPY, 0, (PVOID) &DelayedRetryIrp},
       {"DelayedRetryResend", NULL, 0, COPY, 0, (PVOID) &DelayedRetryIrp},
       {"DelayedRetryResend", NULL, 0, COPY, 0, (PVOID) &DelayedRetryResend},
       {"DelayedRetryInterval", NULL, 0, COPY, 0, (PVOID) &DelayedRetryInterval},
       {"PickDvdRegion", NULL, 0, COPY, 0, (PVOID) &PickDvdRegion},
       {"DvdRpc0Device", NULL, 0, COPY, 0, (PVOID) &DvdRpc0Device},
       {"Rpc0SystemRegion", NULL, 0, COPY, 0, (PVOID) &Rpc0SystemRegion},
       {"Rpc0SystemRegionResetCount", NULL, 0, COPY, 0, (PVOID) &Rpc0SystemRegionResetCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "cdrom!_CDROM_DATA", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }
    
    xdprintfEx(Depth, ("CdData @ %p:\n", Address));
    Depth +=1;

    DumpFlags(Depth, "XAFlags", CdDataXAFlags, XAFlags);
    if (TEST_FLAG(CdDataXAFlags,XA_USE_6_BYTE)) {
        result = GetFieldOffset("cdrom!CDROM_DATA",
                                "Header",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }
        xdprintfEx(Depth, ("%s-byte mode switching, buffer @ %p\n", "6",
                   Address + offset));
    } else if (TEST_FLAG(CdDataXAFlags,XA_USE_10_BYTE)) {
        result = GetFieldOffset("cdrom!CDROM_DATA",
                                "Header10",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }
        xdprintfEx(Depth, ("%s-byte mode switching, buffer @ %p\n", "10",
                   Address + offset));
    }

    { // sanity check the XA flags
        ULONG readBits = 0;
        if (TEST_FLAG(CdDataXAFlags,XA_USE_6_BYTE))   readBits++;
        if (TEST_FLAG(CdDataXAFlags,XA_USE_10_BYTE))  readBits++;
        if (TEST_FLAG(CdDataXAFlags,XA_USE_READ_CD))  readBits++;
        if (TEST_FLAG(CdDataXAFlags,XA_NOT_SUPPORTED)) readBits++;
        if (readBits > 1) {
            xdprintfEx(Depth, ("INVALID combination of XAFlags\n"));
        }
    }

    xdprintfEx(Depth, ("PlayActive: %x    RawAccess %x    IsDecRrd: %x\n",
               (PlayActive ? 1 : 0),
               (RawAccess  ? 1 : 0),
               (IsDecRrd   ? 1 : 0)));


    if (DelayedRetrySpinLock) {

        xdprintfEx(Depth, ("RetryIrp data in intermediate state\n"));

    } else if (DelayedRetryIrp) {

        xdprintfEx(Depth, ("RetryIrp @ %p will be sent to %s in %x seconds\n",
                   DelayedRetryIrp,
                   (DelayedRetryResend ? "lower driver" : "startio"),
                   DelayedRetryInterval));

    } else {

        xdprintfEx(Depth, ("No RetryIrp currently waiting\n"));

    }

    if (PickDvdRegion) {
        xdprintfEx(Depth, ("DVD Region has not been selected or unneeded yet.\n"));
    } else {
        xdprintfEx(Depth, ("DVD Region already chosen.\n"));
    }

    if (DvdRpc0Device) {

        xdprintfEx(Depth, ("DVD Info is faked due to Rpc0 device):\n"));
        xdprintfEx(Depth+1, ("Region: %x (%x)  Region Reset Count: %x\n",
                   (UCHAR)(Rpc0SystemRegion),
                   (UCHAR)(~Rpc0SystemRegion),
                   Rpc0SystemRegionResetCount));
        
        result = GetFieldOffset("cdrom!CDROM_DATA",
                                "Rpc0RegionMutex",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }

        xdprintfEx(Depth+1, ("Mutex at %p\n",
                   Address + offset));

    } else {

        xdprintfEx(Depth, ("Not an RPC0 DVD device\n"));

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\redbook\kdext.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

BOOLEAN                VersionWarningAlreadyPrinted = FALSE;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
    if (VersionWarningAlreadyPrinted) {
        return;
    }
    VersionWarningAlreadyPrinted = TRUE;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** RedBook Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** RedBook Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\redbook\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#ifndef REDKDEXT
#define REDKDEXT

//
// allow this to compile at /W4
//

#pragma warning(disable:4115) // named type definition in parenthesis
#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int
#pragma warning(disable:4057) // char * == char[]

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <zwapi.h>


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <imagehlp.h>

#include <memory.h>

// Stolen from ntrtl.h to override RECOMASSERT
#ifdef ASSERT
    #undef ASSERT
#endif
#ifdef ASSERTMSG
    #undef ASSERTMSG
#endif

#if DBG
    #define ASSERT( exp ) \
        if (!(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, NULL )

    #define ASSERTMSG( msg, exp ) \
        if (!(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, msg )
#else
    #define ASSERT( exp )
    #define ASSERTMSG( msg, exp )
#endif // DBG

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

// grab the redbook related headers too
#include <ntddredb.h>
#include <redbook.h>
#include "wmistr.h"

#endif //REDKDEXT
//#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\redbook\help.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    WinDbg Extension Api for interpretting redbook debugging structures

Author:

    Henry Gabryjelski (henrygab) 21-Sep-1998

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
    {"------------", "----------------------------------------------"},
    {"help"        , "displays this help -- all commands take devobj"},
    {"ext"         , "dumps the redbook device  extension"           },
    {"silence"     , "toggles sending only silent buffers to ks"     },
    {"toc"         , "dumps a CDROM_TOC  *** takes TOC pointer *** " },
    {"wmiperfclear", "clears the wmi performance counters"           },
    {"------------", "----------------------------------------------"},
    {NULL,      NULL}
};

DECLARE_API(help)
{
        int i = 0;

        dprintf("\nRedbook Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("\t%-12s - \t%s\n", extensions[i].extname, extensions[i].extdesc);
                i++;
        }
        dprintf("\n");
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\minipkd\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    util.c

Abstract:

    Utility library used for the various debugger extensions in this library.

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

PUCHAR devicePowerStateNames[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
    "Invalid"
};

FLAG_NAME SrbFlags[] = {
    FLAG_NAME(SRB_FLAGS_QUEUE_ACTION_ENABLE),
    FLAG_NAME(SRB_FLAGS_DISABLE_DISCONNECT),
    FLAG_NAME(SRB_FLAGS_DISABLE_SYNCH_TRANSFER),
    FLAG_NAME(SRB_FLAGS_BYPASS_FROZEN_QUEUE),
    FLAG_NAME(SRB_FLAGS_DISABLE_AUTOSENSE),
    FLAG_NAME(SRB_FLAGS_DATA_IN),
    FLAG_NAME(SRB_FLAGS_DATA_OUT),
    FLAG_NAME(SRB_FLAGS_NO_QUEUE_FREEZE),
    FLAG_NAME(SRB_FLAGS_ADAPTER_CACHE_ENABLE),
    FLAG_NAME(SRB_FLAGS_IS_ACTIVE),
    FLAG_NAME(SRB_FLAGS_ALLOCATED_FROM_ZONE),
    FLAG_NAME(SRB_FLAGS_SGLIST_FROM_POOL),
    FLAG_NAME(SRB_FLAGS_BYPASS_LOCKED_QUEUE),
    FLAG_NAME(SRB_FLAGS_NO_KEEP_AWAKE),
    FLAG_NAME(SRB_FLAGS_PORT_DRIVER_ALLOCSENSE),
    FLAG_NAME(SRB_FLAGS_PORT_DRIVER_SENSEHASPORT),
    FLAG_NAME(SRB_FLAGS_DONT_START_NEXT_PACKET),
    FLAG_NAME(SRB_FLAGS_PORT_DRIVER_RESERVED),
    FLAG_NAME(SRB_FLAGS_CLASS_DRIVER_RESERVED),
    {0,0}
};



PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    )

{
    if(State > PowerDeviceMaximum) {
        return devicePowerStateNames[PowerDeviceMaximum + 1];
    } else {
        return devicePowerStateNames[(UCHAR) State];
    }
}

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG i;
    CCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (0x%08x): ", Name, Flags);

    xdprintfEx(Depth, ("%s", prolog));

    if(Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintfEx(Depth, ("%s", prolog));
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintfEx(Depth, ("%sUnknown flags %#010lx\n", prolog, (Flags & (~mask))));
    }

    return;
}


BOOLEAN
GetAnsiString(
    IN ULONG_PTR Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    )
{
    ULONG i = 0;

    //
    // Grab the string in 64 character chunks until we find a NULL or the
    // read fails.
    //

    while((i < *Length) && (!CheckControlC())) {

        ULONG transferSize;
        ULONG result;

        if(*Length - i < 128) {
            transferSize = *Length - i;
        } else {
            transferSize = 128;
        }

        if(!ReadMemory(Address + i,
                       Buffer + i,
                       transferSize,
                       &result)) {
            //
            // read failed and we didn't find the NUL the last time.  Don't
            // expect to find it this time.
            // BUGBUG - figure out if i should expect it this time.
            //

            *Length = i;
            return FALSE;

        } else {

            ULONG j;

            //
            // Scan from where we left off looking for that NUL character.
            //

            for(j = 0; j < transferSize; j++) {

                if(Buffer[i + j] == '\0') {
                    *Length = i + j;
                    return TRUE;
                }
            }
        }

        i += transferSize;
    }

    //
    // We never found the NUL.  Don't need to update Length since it's currently
    // equal to i.
    //

    return FALSE;
}

PCHAR
GuidToString(
    GUID* Guid
    )
{
    static CHAR Buffer [64];
    
    sprintf (Buffer,
             "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             Guid->Data1,
             Guid->Data2,
             Guid->Data3,
             Guid->Data4[0],
             Guid->Data4[1],
             Guid->Data4[2],
             Guid->Data4[3],
             Guid->Data4[4],
             Guid->Data4[5],
             Guid->Data4[6],
             Guid->Data4[7]
             );

    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\redbook\redbook.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    redbook.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    Henry Gabryjelski 23-Oct-1998

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#define INDENT 2

//#define PRINT_LINE()  dprintf("Line %4d File %s\n", __LINE__, __FILE__)

#define DUMP_STRUCT(v,d,x,y) \
    if ((v) <= Detail) { xdprintf( (d), "%-20s - %#010x\n",     (x), (y) ); }
#define DUMP_STRUCT_P(v,d,x,y) \
    if ((v) <= Detail) { xdprintf( (d), "%-20s - %#p\n",       (x), (y) ); }
#define DUMP_STRUCT64(v,d,x,y) \
    if ((v) <= Detail) { xdprintf( (d), "%-20s - %#016I64x\n", (x), (y) ); }

#define PRINT_FLAGS(Flags,b) \
    if (Flags & b)    { dprintf( #b ", " ); }

typedef struct _FLAG_NAME {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

FLAG_NAME CdFlags[] = {
    FLAG_NAME(CD_STOPPED),         // 0000 0001
    FLAG_NAME(CD_PAUSED),          // 0000 0002
    FLAG_NAME(CD_PLAYING),         // 0000 0004

    FLAG_NAME(CD_STOPPING),        // 0000 0010
    FLAG_NAME(CD_PAUSING),         // 0000 0020

    {0,0}
};

PUCHAR const REDBOOK_CC_STRINGS[5] = {
    "   Read   ",
    "  Stream  ",
    " Read Com ",
    "Stream Com",
    "*Unknown* "
    };



VOID
DumpToc(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpContext(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpFlags(
    LONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );
VOID
DumpList(
    PVOID AddressOfListHead
    );
VOID
DumpRedBookBufferData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookCdromInfo(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookExtension(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookStreamData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookThreadData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookWmiData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
DumpRedBookWmiPerf(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    );
VOID
GetPointer(
    IN ULONG_PTR Address,
    OUT ULONG_PTR *Value
    );
VOID
GetAddressAndDetailLevelFromArgs(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail
    );
VOID
ParseArguments(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail,
    PVOID      Block
    );
VOID
xdprintf(
    LONG  Depth,
    PCCHAR S,
    ...
    );
////////////////////////////////////////////////////////////////////////////////


DECLARE_API(ext)
/*++

Routine Description:
    Dumps the device extension for a given device object, or dumps the
    given device extension

--*/

{
    ULONG_PTR address;
    ULONG detail = 0;
    UCHAR block[sizeof(REDBOOK_DEVICE_EXTENSION)];
    PUCHAR blah;

    ParseArguments(args, &address, &detail, block);

    if (address == 0) {
        return;
    }

    blah = block;  // no field offset
    // address = FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, .);

    DumpRedBookExtension(block, address, detail, 0);
    return;
}


DECLARE_API(toc)
/*++

Routine Description:
    Dumps the device extension for a given device object, or dumps the
    given device extension

--*/

{
    ULONG_PTR address;
    ULONG detail = 0;
    UCHAR block[sizeof(CDROM_TOC)];
    ULONG result;

    GetAddressAndDetailLevelFromArgs(args, &address, &detail);

    if (address == 0) {
        return;
    }

    if(!ReadMemory(address, block, sizeof(CDROM_TOC), &result)) {
        xdprintf(0, "Error reading CDROM_TOC at address %p\n", address);
        return;
    }

    DumpToc(block, address, detail, 0);
    return;
}

DECLARE_API(context)
/*++

Routine Description:
    Dumps the device extension for a given device object, or dumps the
    given device extension

--*/

{
    ULONG_PTR address;
    ULONG detail = 0;
    UCHAR block[sizeof(REDBOOK_COMPLETION_CONTEXT)];
    ULONG result;

    GetAddressAndDetailLevelFromArgs(args, &address, &detail);

    if (address == 0) {
        return;
    }

    if(!ReadMemory(address, block, sizeof(REDBOOK_COMPLETION_CONTEXT), &result)) {
        xdprintf(0, "Error reading CDROM_TOC at address %p\n", address);
        return;
    }

    DumpContext(block, address, detail, 0);
    return;
}



DECLARE_API(silence)
{
    ULONG_PTR silenceAddress;
    ULONG silence;
    ULONG result;

    UCHAR * silenceString = "redbook!RedBookForceSilence";

    silenceAddress = (ULONG_PTR) GetExpression(silenceString);

    if (!silenceAddress) {

        dprintf(
            "Unable to get address of %s\n"
            "It could be that redbook is not loaded,"
            "was build FRE, or the symbols are wrong\n",
            silenceString
            );
        return;

    }

    if (!ReadMemory(silenceAddress, &silence, sizeof(ULONG), &result)) {

        dprintf("Unable to read current value for silence (%p)!\n",
                silenceAddress);
        return;

    }

    //
    // allow them to provide an argument?
    //

    if (args[0]) {

        silence = (ULONG) GetExpression(args);
        dprintf("Setting ForceSilence %s\n", (silence?"on":"off"));

    } else {

        dprintf("Toggling ForceSilence from %s to %s\n",
                (silence?"on":"off"),
                (silence?"off":"on"));
        silence = (silence?0:1);

    }

    if(!WriteMemory(silenceAddress, &silence, sizeof(ULONG), &result)) {

        dprintf("Unable to set ForceSilence %s\n", (silence?"on":"off"));
        return;
    }

    return;

}


DECLARE_API(wmiperfclear)
{
    ULONG_PTR address;
    ULONG detail = 0;
    ULONG result;
    UCHAR block[sizeof(REDBOOK_DEVICE_EXTENSION)];
    PREDBOOK_DEVICE_EXTENSION deviceExtension;

    ParseArguments(args, &address, &detail, block);

    if (address == 0) {
        return;
    }

    deviceExtension = (PREDBOOK_DEVICE_EXTENSION)block;
    deviceExtension->WmiPerf.TimeReadDelay     = 0;
    deviceExtension->WmiPerf.TimeReading       = 0;
    deviceExtension->WmiPerf.TimeStreamDelay   = 0;
    deviceExtension->WmiPerf.TimeStreaming     = 0;
    deviceExtension->WmiPerf.DataProcessed     = 0;
    deviceExtension->WmiPerf.StreamPausedCount = 0;

    if(!WriteMemory(address, (PVOID)block, sizeof(REDBOOK_DEVICE_EXTENSION), &result)) {
        xdprintf(0, "Error writing redbook wmi data to address %p\n", address);
        return;
    }
    return;

}

////////////////////////////////////////////////////////////////////////////////


PUCHAR ErrorText[REDBOOK_ERR_MAXIMUM] = {
    "Errors Reading Raw Audio",
    "Errors Streaming Raw Audio",
    "Errors opening SysAudio Mixer",
    "Errors creating virtual source",
    "Errors opening preferred waveout device",
    "Errors getting number of pins on waveout device",
    "Errors connecting to playback pins on waveout device",
    "Errors initializing WMI",
    "Errors creating thread",
    "Warning due to insufficient data (stream paused)",
    "This is an unsupported drive"
};

VOID
DumpRedBookErrors(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_DEVICE_EXTENSION DeviceExtension = X;
    ULONG_PTR errorCountAddress;
    ULONG tmp;

    ULONG errors[REDBOOK_ERR_MAXIMUM];

    Depth += INDENT;

    errorCountAddress =
        (ULONG_PTR)((PUCHAR)Address +
                    FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, ErrorLog.RCount[0]));

    xdprintf(Depth, "%x Errors Reported.  Error Counts at %p\n",
             DeviceExtension->ErrorLog.Count, errorCountAddress);

    if (!ReadMemory(errorCountAddress, &errors,
                    sizeof(ULONG) * REDBOOK_ERR_MAXIMUM, &tmp)) {
        xdprintf(Depth, "Unable to read error information\n");
        return;
    }

    Depth += INDENT;

    for (tmp = 0; tmp < REDBOOK_ERR_MAXIMUM; tmp++) {
        if (errors[tmp] != 0) {
            xdprintf(Depth, "%2x - %s\n", errors[tmp], ErrorText[tmp]);
        }
    }

    Depth -= INDENT;

}
////////////////////////////////////////////////////////////////////////////////


VOID
DumpRedBookExtension(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_DEVICE_EXTENSION DeviceExtension = X;

    Depth += INDENT;

    dprintf("\n");

    xdprintf(Depth, "Device Extension at %p\n", Address);
    xdprintf(Depth, "TargetDevObj %p  TargetPdo %p  SelfDevObj %p\n",
             DeviceExtension->TargetDeviceObject,
             DeviceExtension->TargetPdo,
             DeviceExtension->SelfDeviceObject);
    xdprintf(Depth, "PNP: CurrentState %x  PreviousState %x\n",
             DeviceExtension->Pnp.CurrentState,
             DeviceExtension->Pnp.PreviousState);
    xdprintf(Depth, "     RemovePending %x  IoRemoveLock %p\n",
             DeviceExtension->Pnp.RemovePending,
             Address+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, RemoveLock));
    xdprintf(Depth, "WmiLibInfo: %p  (%x bytes)  Paging Path Count: %x\n",
             Address+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION, WmiLibInfo),
             sizeof(WMILIB_CONTEXT),
             DeviceExtension->PagingPathCount);

    dprintf("\n");

    DumpRedBookErrors(X, Address, Detail, Depth);


    DumpRedBookCdromInfo((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,CDRom),
                         Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,CDRom),
                         Detail,
                         Depth
                         );
    DumpRedBookStreamData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Stream),
                          Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Stream),
                          Detail,
                          Depth
                          );
    DumpRedBookThreadData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Thread),
                          Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Thread),
                          Detail,
                          Depth
                          );
    DumpRedBookWmiData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiData),
                       Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiData),
                       Detail,
                       Depth
                       );
    DumpRedBookWmiPerf((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiPerf),
                       Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,WmiPerf),
                       Detail,
                       Depth
                       );
    DumpRedBookBufferData((PUCHAR)X+FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Buffer),
                          Address  +FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,Buffer),
                          Detail,
                          Depth
                          );

    if (Detail) {

        ULONG Index;
        ULONG i;
        PUCHAR savedIo;

        Index = DeviceExtension->SavedIoCurrentIndex + (SAVED_IO_MAX - 1);
        Index %= SAVED_IO_MAX;

        savedIo = (PUCHAR)Address;
        savedIo += FIELD_OFFSET(REDBOOK_DEVICE_EXTENSION,SavedIo[0].IrpWithoutStack);

        xdprintf(Depth, "Irp History: \n");

        for (i=0; i < SAVED_IO_MAX; i++) {

            ULONG realIndex;

            realIndex = Index + i;
            realIndex %= SAVED_IO_MAX;

            xdprintf(Depth, "Irp %p:  !irp %p\n",
                     DeviceExtension->SavedIo[realIndex].OriginalIrp,
                     savedIo + (sizeof(SAVED_IO) * realIndex)
                     );

        }

    }

    dprintf("\n");
    return;
}


VOID
DumpRedBookCdromInfo(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_CDROM_INFO Cdrom = X;

    xdprintf(Depth, "CDROM INFO at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "CachedToc %p  MediaChangeCount %x\n",
             Cdrom->Toc,
             Cdrom->CheckVerify);
    DumpFlags(Depth, "CdState", Cdrom->StateNow, CdFlags);
    xdprintf(Depth, "Sector information:\n");
    xdprintf(Depth, "NextToRead %x  NextToStream %x  FinishedStreaming %x\n",
             Cdrom->NextToRead,
             Cdrom->NextToStream,
             Cdrom->FinishedStreaming);
    xdprintf(Depth, "EndPlay %x  ReadErrors %x  StreamErrors %x\n",
             Cdrom->EndPlay,
             Cdrom->ReadErrors,
             Cdrom->StreamErrors);
    xdprintf(Depth, "Volume for ports 0-3:  %x %x %x %x\n",
             Cdrom->Volume.PortVolume[0],
             Cdrom->Volume.PortVolume[1],
             Cdrom->Volume.PortVolume[2],
             Cdrom->Volume.PortVolume[3]);

    Depth -= INDENT;

    return;
}


VOID
DumpRedBookWmiData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_WMI_STD_DATA WmiData = X;

    xdprintf(Depth, "WMIDATA at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "Number of buffers: %x\n",
             WmiData->NumberOfBuffers
             );

    xdprintf(Depth, "Sectors: Per Read %x  Mask %x  Maximum\n",
             WmiData->SectorsPerRead,
             WmiData->SectorsPerReadMask,
             WmiData->MaximumSectorsPerRead
             );
    xdprintf(Depth, "Enabled %x  CDDASupported %x  CDDAAccurate %x\n",
             WmiData->PlayEnabled,
             WmiData->CDDASupported,
             WmiData->CDDAAccurate
             );

    Depth -= INDENT;

    return;
}


VOID
DumpRedBookWmiPerf(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_WMI_PERF_DATA WmiPerf = X;

    xdprintf(Depth, "WMIPERF at %p\n", Address);

    //
    // problems printing the info below.
    // it actually crashes the debugger.
    //


    Depth += INDENT;

    xdprintf(Depth, "ReadDelay %I64x      Reading %I64x\n",
             WmiPerf->TimeReadDelay,
             WmiPerf->TimeReading
             );
    xdprintf(Depth, "StreamDelay %I64x    Streaming %I64x\n",
             WmiPerf->TimeStreamDelay,
             WmiPerf->TimeStreaming
             );
    xdprintf(Depth, "DataProcessed %I64x  StreamPausedCount %x\n",
             WmiPerf->DataProcessed,
             WmiPerf->StreamPausedCount
             );
    return;

#if 0
    if (WmiPerf->DataRead != 0) {
        xdprintf( Depth, "\n" );
        xdprintf( Depth, "     stat                seconds\n" );
        xdprintf( Depth, "-------------  -----------------------------\n" );

#define TIME_FORMAT_STRINGa "%12s:  %7I64d.%-02I64d\n"
#define TIME_FORMAT_STRING  "%12s:  %7I64d.%-07I64d\n"
#define UNITS_PER_SECOND ((LONG64)10000000)

        xdprintf( Depth, TIME_FORMAT_STRINGa,
                  "audio data",
                  WmiPerf->DataRead / (RAW_SECTOR_SIZE * 75),
                  (WmiPerf->DataRead / RAW_SECTOR_SIZE) % 75
                  );

        //
        // what is the approximate transfer speed of the drive?
        // in kb/s, but actually calculated as b/(s / 1024^2)
        //

        tempStat = WmiPerf->DataRead / 0x00000400;           // kb
        xdprintf( Depth, " Kbytes read: %I64d\n", tempStat );
        xdprintf( Depth, "     seconds: %I64d . %I64d\n",
                  WmiPerf->TimeReading / UNITS_PER_SECOND,
                  WmiPerf->TimeReading % UNITS_PER_SECOND
                  );
        //
        // need to keep the numbers large, so:
        //

        tempStat  = WmiPerf->TimeReading;
        tempStat /= (UNITS_PER_SECOND / 0x00000400);

        xdprintf( Depth, "   approx drive speed: %I64d kb/s\n",
                  WmiPerf->DataRead / tempStat );

        tempStat  = WmiPerf->TimeReading +
            WmiPerf->TimeReadDelay +
            WmiPerf->TimeStreamDelay;
        tempStat /= (UNITS_PER_SECOND / 0x00000400);

        xdprintf( Depth, "effective drive speed: %I64d kb/s\n",
                  WmiPerf->DataRead / tempStat );

/*
        tempStat /= WmiPerf->TimeReading / UNITS_PER_SECOND; // per second
        xdprintf( Depth, "Approximate drive speed: %I64d kb/s\n", tempStat );

        xdprintf( Depth, TIME_FORMAT_STRING
                  "reading",
                  WmiPerf->TimeReading / UNITS_PER_SECOND,
                  WmiPerf->TimeReading % UNITS_PER_SECOND
                  );
        xdprintf( Depth, TIME_FORMAT_STRING
                  "streaming",
                  WmiPerf->TimeStreaming / UNITS_PER_SECOND,
                  WmiPerf->TimeStreaming % UNITS_PER_SECOND
                  );
        xdprintf( Depth, TIME_FORMAT_STRING
                  "read delay",
                  WmiPerf->TimeReadDelay / UNITS_PER_SECOND,
                  WmiPerf->TimeReadDelay % UNITS_PER_SECOND
                  );
        xdprintf( Depth, TIME_FORMAT_STRING
                  "stream delay",
                  WmiPerf->TimeStreaming / UNITS_PER_SECOND,
                  WmiPerf->TimeStreaming % UNITS_PER_SECOND
                  );
        //
        // now do some simple analysis, use seconds as unit
        //

*/
    }
    Depth -= INDENT;
    return;

#endif // 0

}


VOID
DumpRedBookBufferData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_BUFFER_DATA Buffer = X;
    ULONG numBuf;
    ULONG sectorsPerRead;
    ULONG i;
    PULONG readOk_X;
    PULONG streamOk_X;
    ULONG result;

    xdprintf(Depth, "BUFFERS at %p\n", Address);

    numBuf = CONTAINING_RECORD(X, REDBOOK_DEVICE_EXTENSION, Buffer)->WmiData.NumberOfBuffers;
    sectorsPerRead = CONTAINING_RECORD(X, REDBOOK_DEVICE_EXTENSION, Buffer)->WmiData.SectorsPerRead;

    Depth += INDENT;

    if (Buffer->ReadOk_X == NULL ||
        Buffer->StreamOk_X == NULL ||
        Buffer->Contexts == NULL) {

        xdprintf(Depth, "One of the pointers is NULL\n");
        return;

    }


    readOk_X   = (PULONG)LocalAlloc(LPTR, sizeof(ULONG)*numBuf);
    streamOk_X = (PULONG)LocalAlloc(LPTR, sizeof(ULONG)*numBuf);
    if (readOk_X == NULL ||
        streamOk_X == NULL) {
        if (readOk_X) {
            LocalFree(readOk_X);
        }
        if (streamOk_X) {
            LocalFree(streamOk_X);
        }
        xdprintf(Depth, "Can't Alloc Memory\n");
        return;
    }

    if(!ReadMemory((ULONG_PTR)(Buffer->ReadOk_X),
                   readOk_X,
                   sizeof(ULONG)*numBuf,
                   &result)) {
        xdprintf(0, "Error reading ReadOk_X\n");
        LocalFree(readOk_X);
        LocalFree(streamOk_X);
        return;
    }
    if(!ReadMemory((ULONG_PTR)(Buffer->StreamOk_X),
                   streamOk_X,
                   sizeof(ULONG)*numBuf,
                   &result)) {
        xdprintf(0, "Error reading StreamOk_X\n");
        LocalFree(readOk_X);
        LocalFree(streamOk_X);
        return;
    }

    //
    // now just parse and print
    //

    xdprintf(Depth, "SkipBuffer %p  to  %p  (%x bytes)\n",
             Buffer->SkipBuffer,
             Buffer->SkipBuffer + (RAW_SECTOR_SIZE * sectorsPerRead * numBuf),
             RAW_SECTOR_SIZE * sectorsPerRead
             );

    xdprintf(Depth, "IrpStack %x  Stream is %s\n",
             Buffer->MaxIrpStack,
             (Buffer->Paused ?
              (Buffer->FirstPause ? "in its first pause" : "paused")
              : "not paused")
             );
    xdprintf(Depth, "Silent Buffer %p  Silent Mdl %p\n",
             Buffer->SilentBuffer,
             Buffer->SilentMdl
             );

    dprintf("\n");
    xdprintf(Depth, "PRINTING %x BUFFERS (does it match?)\n", numBuf);

    xdprintf(Depth, " %8s | %10s | %8s | %8s | %8s | %8s\n",
             " Index  ",
             " Reason ",
             " Buffer ",
             "  Mdl   ",
             "  Irp   ",
             " R/S OK "
             );
    xdprintf(Depth, "----------+------------+----------+----------+----------+"
             "----------\n");

    for (i=0;i<numBuf;i++) {
        REDBOOK_COMPLETION_CONTEXT context;

        if(!ReadMemory((ULONG_PTR)(Buffer->Contexts+i),
                       &context,
                       sizeof(REDBOOK_COMPLETION_CONTEXT),
                       &result)) {
            xdprintf(0, "Error reading CompletionContext at address %p\n",
                     Buffer->Contexts + i);
        } else {

            xdprintf(Depth, "");
            dprintf(" %8x |",
                    context.Index);

            if        (context.Reason > 4) {
                dprintf(" %s |", REDBOOK_CC_STRINGS[4]);
            } else {
                dprintf(" %s |", REDBOOK_CC_STRINGS[context.Reason]);
            }

            dprintf(" %8p |",
                    context.Buffer);
            dprintf(" %8p |",
                    context.Mdl);
            dprintf(" %8p |",
                    context.Irp);
            dprintf(" %4s\n",
                    (readOk_X[i] ? "R" : (streamOk_X[i] ? "S" : "-")));
        }
    }
    dprintf("\n");
    LocalFree(readOk_X);
    LocalFree(streamOk_X);


    Depth -= INDENT;
    return;
}


VOID
DumpRedBookStreamData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_STREAM_DATA Stream = X;

    xdprintf(Depth, "STREAM DATA at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "  Pin: FileObject %p  DeviceObject %p\n",
             Stream->PinFileObject,
             Stream->PinDeviceObject);
    xdprintf(Depth, "Mixer: FileObject %p  PinId %x    VolumeNodeId %x\n",
             Stream->MixerFileObject,
             Stream->MixerPinId,
             Stream->VolumeNodeId);
    xdprintf(Depth, "Connect@ %p  Format@ %p  (%x and %x bytes)\n",
             Address+FIELD_OFFSET(REDBOOK_STREAM_DATA,Connect),
             Address+FIELD_OFFSET(REDBOOK_STREAM_DATA,Format),
             sizeof(KSPIN_CONNECT),
             sizeof(KSDATAFORMAT_WAVEFORMATEX));

    Depth -= INDENT;

    return;
}


VOID
DumpRedBookThreadData(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_THREAD_DATA Thread = X;
    PUCHAR X2 = (PUCHAR)Address;

    xdprintf(Depth, "THREAD DATA at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "Handle %x  Pointer %p  ",
             Thread->SelfHandle,
             Thread->SelfPointer
             );

    if (Thread->IoctlCurrent) {
        dprintf("Current Ioctl: %p\n", Thread->IoctlCurrent);
    } else {
        dprintf("Current Ioctl: None\n");
    }

    Thread = X;  // BUGBUG - remove this, and Thread gets set to zero above?

    xdprintf(Depth, "PendingRead %x  Pending Stream %x\n",
             Thread->PendingRead,
             Thread->PendingStream
             );

    xdprintf(Depth, "IoctlList:");
    DumpList(X2 + FIELD_OFFSET(REDBOOK_THREAD_DATA, IoctlList));
    dprintf("\n");

    xdprintf(Depth, "WmiList:");
    DumpList(X2 + FIELD_OFFSET(REDBOOK_THREAD_DATA, WmiList));
    dprintf("\n");

    xdprintf(Depth, "DigitalList:");
    DumpList(X2 + FIELD_OFFSET(REDBOOK_THREAD_DATA, DigitalList));
    dprintf("\n");

    Depth -= INDENT;
}


VOID
xdprintf(
    LONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    LONG i;
    CCHAR DebugBuffer[256];

    // Tree output as follows:
    //
    // +- Item
    // |
    //
    //

    for (i=0;i<Depth;i++) {
        dprintf(" ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}


VOID
DumpFlags(
    LONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (0x%08x): ", Name, Flags);

    xdprintf(Depth, "%s", prolog);

    if(Flags == 0) {
        dprintf("NONE\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %lx\n", prolog, (Flags & (~mask)));
    }

    return;
}


VOID
GetPointer(
    IN ULONG_PTR Address,
    OUT ULONG_PTR *Value
    )
{
    ULONG result;

    if(!ReadMemory(Address, (PVOID)*Value, sizeof(ULONG_PTR), &result) ||
       result != sizeof(ULONG_PTR)) {
        *Value = 0;
    }
    return;
}


VOID
DumpList(
    PVOID AddressOfListHead
    )
{
    LIST_ENTRY listHead;
    LIST_ENTRY current;
    LIST_ENTRY slow;
    ULONG result;
    BOOLEAN advanceSlowList;

    if (!ReadMemory((ULONG_PTR)AddressOfListHead,
                    &listHead,
                    sizeof(LIST_ENTRY),
                    &result)) {
        dprintf("Unable to read head of list at %p", AddressOfListHead);
        return;
    }

    slow = listHead;
    current = listHead;
    advanceSlowList = FALSE;

    if (current.Flink == AddressOfListHead) {
        dprintf("Empty");
        return;
    }

    //
    // list is empty when FLink points is AddressOfListHead
    // list is looping when Current.BLink == Slow.Blink
    //


    while (!CheckControlC()) {

        if (current.Flink == AddressOfListHead) {
            return;
        }

        //
        // print it
        //

        dprintf(" %p", current.Flink);

        //
        // advance the list pointers
        //

        if (!ReadMemory((ULONG_PTR)current.Flink,
                        &current,
                        sizeof(LIST_ENTRY),
                        &result)) {
            dprintf(" !! Unable to read memory at %p", AddressOfListHead);
            return;
        }
        if (advanceSlowList) {
            // won't fail since current already read this in successfully
            ReadMemory((ULONG_PTR)slow.Flink,
                       &slow,
                       sizeof(LIST_ENTRY),
                       &result);
        }
        advanceSlowList = !advanceSlowList;

        //
        // check for loops
        //

        if (current.Blink == slow.Blink) {
            dprintf(" !! List %p has a loop!", AddressOfListHead);
            return;
        }

    }
    //
    // should always exit from above loop
    //
}

VOID
GetAddressAndDetailLevelFromArgs(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail
    )
{
    UCHAR addressBuffer[256];
    UCHAR detailBuffer[256];
    
    addressBuffer[0] = '\0';
    detailBuffer[0]  = '\0';
    (VOID)sscanf(Args, "%s %s", addressBuffer, detailBuffer);
    addressBuffer[255] = '\0';
    detailBuffer[255]  = '\0';

    *Address = 0;
    *Detail  = 0;


    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = (ULONG_PTR) GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            *Detail = 0;
            return;

        }

        //
        // if they provided a detail level get it.
        //

        if (detailBuffer[0] == '\0') {

            *Detail = 0;

        } else {

            *Detail = (ULONG) GetExpression(detailBuffer);

        }
    }

}


VOID
ParseArguments(
    PCSTR      Args,
    PULONG_PTR Address,
    PULONG     Detail,
    PVOID      Block
    )
{
    ULONG result;
    PDEVICE_OBJECT deviceObject = (PDEVICE_OBJECT)Block;

    GetAddressAndDetailLevelFromArgs(Args, Address, Detail);

    //
    // grab this thing as a device object.  If it's type field matches what
    // we expect then adjust address to point to the actual device extension
    //

    if(!ReadMemory(*Address, Block, sizeof(DEVICE_OBJECT), &result)) {
        xdprintf(0, "Error reading data at address %p\n", *Address);
        return;
    }

    if(deviceObject->Type == IO_TYPE_DEVICE) {
        *Address = (ULONG_PTR)deviceObject->DeviceExtension;
    }

    //
    // now get the device extension
    //

    if(!ReadMemory(*Address, Block, sizeof(REDBOOK_DEVICE_EXTENSION), &result)) {
        xdprintf(0, "Error reading device extension at address %p\n", *Address);
        return;
    }

    return;
}

VOID
DumpToc(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PCDROM_TOC Toc = X;
    PTRACK_DATA trackData;
    ULONG numberOfTracks;
    ULONG i;

    numberOfTracks = Toc->LastTrack - Toc->FirstTrack;

    xdprintf(Depth, "TOC at %p\n", Address);

    Depth += INDENT;

    xdprintf(Depth, "Key for Control Field:\n");
    xdprintf(Depth, "    P   - Preemphasis\n");
    xdprintf(Depth, "    C   - Copy Protect\n");
    xdprintf(Depth, "    D,A - Data or Audio Track\n");
    xdprintf(Depth, "    #   - Number of Audio Channels\n\n");


    xdprintf(Depth, "FirstTrack %x  LastTrack %x  NumberOfTracks %x  Size: %x\n",
             Toc->FirstTrack,
             Toc->LastTrack,
             numberOfTracks,
             (Toc->Length[0] << 8) | (Toc->Length[1])
             );

    xdprintf(Depth, "Index   Track   Control   MSF        Address\n");
    xdprintf(Depth, "---------------------------------------------\n");

    for (i=0,trackData = Toc->TrackData;
         (!CheckControlC()) && i<numberOfTracks+2; // lead-in, lead-out track
         i++,trackData++) {

        ULONG lba;
        UCHAR m,s,f;

        if (trackData->Reserved || trackData->Reserved1) {
            xdprintf(Depth, "TrackData[%x] has reserved fields filled in. "
                     "Most likely not a TOC\n", i);
            return;
        }

        lba =
            (trackData->Address[0] << 24) |
            (trackData->Address[1] << 16) |
            (trackData->Address[2] <<  8) |
            (trackData->Address[3] <<  0);
        LBA_TO_MSF(lba, m, s, f);

        m = s = f = 0;

        xdprintf(Depth, " %2x      %2x     %s %s %s %s   %02x:%02x:%02x   0x%06x\n",
                 i,
                 trackData->TrackNumber,
                 TEST_FLAG(trackData->Control, AUDIO_WITH_PREEMPHASIS) ? "P" : "-",
                 TEST_FLAG(trackData->Control, DIGITAL_COPY_PERMITTED) ? "C" : "-",
                 TEST_FLAG(trackData->Control, AUDIO_DATA_TRACK)       ? "D" : "A",
                 TEST_FLAG(trackData->Control, TWO_FOUR_CHANNEL_AUDIO) ? "4" : "2",
                 m, s, f, lba
                 );
    }



    Depth -= INDENT;

    return;
}


VOID
DumpContext(
    IN PVOID     X,
    IN ULONG_PTR Address,
    IN ULONG     Detail,
    IN LONG      Depth
    )
{
    PREDBOOK_COMPLETION_CONTEXT Context = X;
    ULONG i;

    xdprintf(Depth, "Context %x for devext %p at %p\n",
             Context->Index, Context->DeviceExtension, Address);

    Depth += INDENT;

    if (Context->ListEntry.Flink != Context->ListEntry.Blink) {

        if (Context->Reason > 4) {
            xdprintf(Depth, "Context is queued for %s\n",
                     REDBOOK_CC_STRINGS[ Context->Reason ]);
        } else {
            xdprintf(Depth, "Context is queued for %s\n",
                     REDBOOK_CC_STRINGS[ 4 ]);
        }

    }

    xdprintf(Depth, "\\");

    for (i=0;i<2000;i++) {
        UCHAR array[5] = "|/-\\";

        dprintf("\b%c", array[ i%4 ]);
    }

    dprintf("\b \n");

    xdprintf(Depth, "Irp %p  Buffer %p  Mdl %p\n",
             Context->Irp, Context->Buffer, Context->Mdl);

    xdprintf(Depth,
             "KSSTREAM Header at %p\n",
             Address + FIELD_OFFSET(REDBOOK_COMPLETION_CONTEXT, Header)
             );
    xdprintf(Depth,
             "Size              = %x\n",
             Context->Header.Size
             );
    xdprintf(Depth,
             "TypeSpecificFlags = %x\n",
             Context->Header.TypeSpecificFlags
             );
    xdprintf(Depth,
             "Duration          = %I64x\n",
             Context->Header.Duration
             );
    xdprintf(Depth,
             "FrameExtent       = %x\n",
             Context->Header.FrameExtent
             );
    xdprintf(Depth,
             "DataUsed          = %x\n",
             Context->Header.DataUsed
             );
    xdprintf(Depth,
             "Data              = %p\n",
             Context->Header.Data
             );
    xdprintf(Depth,
             "OptionsFlags      = %x\n",
             Context->Header.OptionsFlags
             );
    xdprintf(Depth,
             "PresentationTime.Time        = %I64x\n",
             Context->Header.PresentationTime.Time
             );
    xdprintf(Depth,
             "PresentationTime.Numerator   = %x\n",
             Context->Header.PresentationTime.Numerator
             );
    xdprintf(Depth,
             "PresentationTime.Denominator = %x\n",
             Context->Header.PresentationTime.Denominator
             );


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\classkd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    classkd.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995
    johnstra
    ervinp

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"


#include "classpnp.h" // #defines ALLOCATE_SRB_FROM_POOL as needed

#include "classp.h"   // Classpnp's private definitions
#include "cdrom.h"

#include "classkd.h"  // routines that are useful for all class drivers

typedef struct _REMOVE_TRACKING_BLOCK
               REMOVE_TRACKING_BLOCK,
               *PREMOVE_TRACKING_BLOCK;

struct _REMOVE_TRACKING_BLOCK {
    PREMOVE_TRACKING_BLOCK NextBlock;
    PVOID Tag;
    LARGE_INTEGER TimeLocked;
    PCSTR File;
    ULONG Line;
};

FLAG_NAME FdoFlags[] = {
    FLAG_NAME(DEV_WRITE_CACHE),     // 0x00000001
    FLAG_NAME(DEV_USE_SCSI1),       // 0x00000002
    FLAG_NAME(DEV_SAFE_START_UNIT), // 0x00000004
    FLAG_NAME(DEV_NO_12BYTE_CDB),   // 0x00000008
    {0,0}
};

DECLARE_API(classext)

/*++

Routine Description:

    Dumps the device extension for a given device object, or dumps the
    given device extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 devObjAddr = 0;
    ULONG detail = 0;
    

    GetAddressAndDetailLevel64(args, &devObjAddr, &detail);
    
    /*
     *  Read the device object and extension into the debugger's address space.
     */
    if (devObjAddr == 0){
        xdprintf(0, "\n usage: !classext <class fdo> <level [0-2]>\n\n");
    }
    else {
        CSHORT objType = GetUSHORTField(devObjAddr, "nt!_DEVICE_OBJECT", "Type");
            
        if (objType == IO_TYPE_DEVICE){
            ULONG64 devExtAddr;

            devExtAddr = GetULONGField(devObjAddr, "nt!_DEVICE_OBJECT", "DeviceExtension");
            if (devExtAddr != BAD_VALUE){
                ULONG64 commonExtAddr = devExtAddr;
                ULONG64 tmpDevObjAddr;
                BOOLEAN isFdo;

                /*
                 *  To sanity-check our device context, check that the 'DeviceObject' field matches our device object.
                 */
                tmpDevObjAddr = GetULONGField(devExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "DeviceObject");
                isFdo = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsFdo");
                if ((tmpDevObjAddr == devObjAddr) && isFdo && (isFdo != BAD_VALUE)){
                    ULONG64 fdoDataAddr;

                    fdoDataAddr = GetULONGField(devExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "PrivateFdoData");
                    if (fdoDataAddr != BAD_VALUE){
                        
                        ClassDumpFdoExtensionInternal(fdoDataAddr, detail, 0);
                        
                        ClassDumpFdoExtensionExternal(devExtAddr, detail, 0);

                        // this hasn't worked in some time
                        // ClassDumpCommonExtension(devObjAddr, detail, 0);                             
                    }
                }
                else {
                    dprintf("%08p is not a storage class FDO (for PDO information, use !classext on the parent FDO) \n", devObjAddr);
                    dprintf(g_genericErrorHelpStr);
                }
            }
        }
        else {
            dprintf("Error: 0x%08p is not a device object\n", devObjAddr);
            dprintf(g_genericErrorHelpStr);
        }
    }
        
    return S_OK;
}


VOID
ClassDumpCommonExtension(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG offset;
    ULONG tmp;

    BOOLEAN IsFdo;
    BOOLEAN IsInitialized;
    ULONG IsRemoved;
    ULONG64 DeviceObject;
    ULONG64 LowerDeviceObject;
    UCHAR CurrentState;
    UCHAR PreviousState;
    ULONG64 DriverData;
    ULONG PagingPathCount;
    ULONG DumpPathCount;
    ULONG HibernationPathCount;

    FIELD_INFO deviceFields[] = {
       {"IsFdo", NULL, 0, COPY, 0, (PVOID) &IsFdo},
       {"IsInitialized", NULL, 0, COPY, 0, (PVOID) &IsInitialized},
       {"IsRemoved", NULL, 0, COPY, 0, (PVOID) &IsRemoved},
       {"DeviceObject", NULL, 0, COPY, 0, (PVOID) &DeviceObject},
       {"LowerDeviceObject", NULL, 0, COPY, 0, (PVOID) &LowerDeviceObject},
       {"CurrentState", NULL, 0, COPY, 0, (PVOID) &CurrentState},
       {"PreviousState", NULL, 0, COPY, 0, (PVOID) &PreviousState},
       {"DriverData", NULL, 0, COPY, 0, (PVOID) &DriverData},
       {"PagingPathCount", NULL, 0, COPY, 0, (PVOID) &PagingPathCount},
       {"DumpPathCount", NULL, 0, COPY, 0, (PVOID) &DumpPathCount},
       {"HibernationPathCount", NULL, 0, COPY, 0, (PVOID) &HibernationPathCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "classpnp!_COMMON_DEVICE_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }
    
    xdprintfEx(Depth, ("Classpnp %s device extension at address %p\n",
               (!IsFdo ? "physical" : "functional"),
               Address));

    xdprintfEx(Depth, ("Common Extension:\n"));

    Depth += 1;

    tmp = Depth;

    if(IsInitialized) {
        xdprintfEx(tmp, ("Initialized " ));
        tmp = 0;
    }

    switch(IsRemoved) {
        case REMOVE_PENDING: {
            xdprintfEx(tmp, ("RemovePending"));
            tmp = 0;
            break;
        }

        case REMOVE_COMPLETE: {
            xdprintfEx(tmp, ("RemoveComplete"));
            tmp = 0;
            break;
        }
    }

    if(tmp == 0) {
        dprintf("\n");
    }

    tmp = 0;

    //
    // Calculate the runtime address of the first field to follow the common
    // device extension.  To do this, we query the type info for the offset
    // of the last field, then increment it by the appropriate amount.
    // 

    result = GetFieldOffset("classpnp!_COMMON_DEVICE_EXTENSION",
                            "Reserved4",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }
    offset += IsPtr64() ? sizeof(ULONG64) : sizeof(ULONG32);

    xdprintfEx(Depth, ("DO 0x%p  LowerObject 0x%p  Other Extension 0x%p\n",
               DeviceObject,
               LowerDeviceObject,
               Address + offset
               ));

    xdprintfEx(Depth, ("Current PnP state 0x%x    Previous state 0x%x\n",
               CurrentState,
               PreviousState));

    xdprintfEx(Depth, ("DriverData 0x%p UsePathCounts (P%d, C%d, H%d)\n",
               DriverData,
               PagingPathCount,
               DumpPathCount,
               HibernationPathCount
               ));

    if(!IsFdo) {
        xdprintfEx(Depth - 1, ("PhysicalExtension:\n"));
        ClassDumpPdo(Address,
                     Detail,
                     Depth);
    } else {
        xdprintfEx(Depth - 1, ("FunctionalExtension:\n"));
        ClassDumpFdo(Address,
                     Detail,
                     Depth);
    }

    ClassDumpLocks(Address, Depth - 1);

    return;
}



VOID 
ClassDumpFdoExtensionExternal(
    IN ULONG64 FdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG64 commonExtAddr = FdoExtAddr;
    ULONG64 mediaChangeInfoAddr;
    ULONG64 childPdoExtAddr;
    ULONG isRemoved;
    UCHAR isInitialized;
    ULONG removeLock;
    UCHAR currentState, previousState;
    ULONG64 lowerDevObjAddr;
    
    xdprintf(Depth, "\n");
    xdprintf(Depth, "Classpnp _EXTERNAL_ data:\n\n");
     
    /*
     *  Print the media change information (which only exists for removable media like cdrom)
     */
    mediaChangeInfoAddr = GetULONGField(FdoExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "MediaChangeDetectionInfo");
    if (mediaChangeInfoAddr != BAD_VALUE){
        
        if (mediaChangeInfoAddr){
            ULONG64 mediaChangeIrpAddr = GetULONGField(mediaChangeInfoAddr, "classpnp!_MEDIA_CHANGE_DETECTION_INFO", "MediaChangeIrp");
            UCHAR gesnSupported = GetUCHARField(mediaChangeInfoAddr, "classpnp!_MEDIA_CHANGE_DETECTION_INFO", "Gesn.Supported");
                            
            xdprintf(Depth+1, ""), dprintf("MEDIA_CHANGE_DETECTION_INFO @ %08p:\n", mediaChangeInfoAddr);
            if (gesnSupported){
                xdprintf(Depth+2, "GESN is supported\n");
            }
            else {
                xdprintf(Depth+2, "GESN is NOT supported\n");
            }
            xdprintf(Depth+2, ""), dprintf("MediaChangeIrp = %08p\n", mediaChangeIrpAddr);
            xdprintf(Depth+2, ""), dprintf("(for more info, use 'dt classpnp!_MEDIA_CHANGE_DETECTION_INFO %08p')\n", mediaChangeInfoAddr);
            dprintf("\n");
        }
        else {
            xdprintf(Depth+1, "MediaChangeDetectionInfo is NULL\n");
        }
    }

    /*
     *  Print the media type and geometry information
     */
    {
        ULONG64 geometryInfoAddr = GetFieldAddr(FdoExtAddr, "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", "DiskGeometry");

        if (geometryInfoAddr != BAD_VALUE){
            ULONG64 numCylinders = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "Cylinders");
            ULONG mediaType = (ULONG)GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "MediaType");
            ULONG64 tracksPerCylinder = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "TracksPerCylinder");
            ULONG64 sectorsPerTrack = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "SectorsPerTrack");
            ULONG64 bytesPerSector = GetULONGField(geometryInfoAddr, "classpnp!_DISK_GEOMETRY", "BytesPerSector");

            if ((numCylinders != BAD_VALUE) && (mediaType != BAD_VALUE) && (tracksPerCylinder != BAD_VALUE) && (sectorsPerTrack != BAD_VALUE) && (bytesPerSector != BAD_VALUE)){
                ULONG64 totalVolume = numCylinders*tracksPerCylinder*sectorsPerTrack*bytesPerSector;
                xdprintf(Depth+1, ""), dprintf("Media type: %s(%xh)\n", DbgGetMediaTypeStr(mediaType), mediaType);
                xdprintf(Depth+1, ""), dprintf("Geometry: %d(%xh)cyl x %d(%xh)tracks x %d(%xh)sectors x %d(%xh)bytes\n",
                                                              (ULONG)numCylinders, (ULONG)numCylinders, 
                                                              (ULONG)tracksPerCylinder, (ULONG)tracksPerCylinder, 
                                                              (ULONG)sectorsPerTrack, (ULONG)sectorsPerTrack, 
                                                              (ULONG)bytesPerSector, (ULONG)bytesPerSector);
                xdprintf(Depth+1+4, ""), dprintf("= %x'%xh", (ULONG)(totalVolume>>32), (ULONG)totalVolume);
                if (totalVolume > (ULONG64)(1 << 30)){
                    dprintf(" = ~%d GB\n", (ULONG)(totalVolume >> 30));
                }
                else {
                    dprintf(" = ~%d MB\n", (ULONG)(totalVolume >> 20));
                }
            }
        }
    }

    /*
     *  Print 'IsInitialized' state.
     */
    isInitialized = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsInitialized");
    xdprintf(Depth+1, "IsInitialized = %d\n", isInitialized);
    
    /*
     *  Print the 'IsRemoved' state.
     */
    isRemoved = (ULONG)GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "IsRemoved");
    removeLock = (ULONG)GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "RemoveLock");
    xdprintf(Depth+1, "Remove lock count = %d\n", removeLock);
    switch (isRemoved){
        #undef MAKE_CASE
        #define MAKE_CASE(remCase) case remCase: xdprintf(Depth+1, "IsRemoved = " #remCase "(%d)\n", isRemoved); break; 
        MAKE_CASE(NO_REMOVE)
        MAKE_CASE(REMOVE_PENDING)
        MAKE_CASE(REMOVE_COMPLETE)
    }

    /*
     *  Print the PnP state.
     */
    currentState = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "CurrentState");
    previousState = GetUCHARField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "PreviousState");
    xdprintf(Depth+1, "PnP state:  CurrentState:"); 
    switch (currentState){
        #undef MAKE_CASE
        #define MAKE_CASE(pnpCase) case pnpCase: xdprintf(0, #pnpCase "(%xh)", pnpCase); break;
        MAKE_CASE(IRP_MN_START_DEVICE)
        MAKE_CASE(IRP_MN_STOP_DEVICE)
        MAKE_CASE(IRP_MN_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
        default: xdprintf(0, "???(%xh)", currentState); break;
    }
    xdprintf(0, "  PreviousState:");
    switch (previousState){
        #undef MAKE_CASE
        #define MAKE_CASE(pnpCase) case pnpCase: xdprintf(0, #pnpCase "(%xh)", pnpCase); break;
        MAKE_CASE(IRP_MN_START_DEVICE)
        MAKE_CASE(IRP_MN_STOP_DEVICE)
        MAKE_CASE(IRP_MN_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
        case 0x0FF: xdprintf(0, "(None)"); break;
        default: xdprintf(0, "???(%xh)", previousState); break;
    }
    xdprintf(0, "\n");

    /*
     *  Print target device
     */
    lowerDevObjAddr = GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "LowerDeviceObject");
    xdprintf(Depth+1, ""), dprintf("Target device=%08p\n", lowerDevObjAddr);

    /*
     *  Dump child PDO list
     */
    xdprintf(Depth+1, "Child PDOs:\n");
    childPdoExtAddr = GetULONGField(commonExtAddr, "classpnp!_COMMON_DEVICE_EXTENSION", "ChildList");
    while (childPdoExtAddr && (childPdoExtAddr != BAD_VALUE)){
        ULONG64 pdoAddr = GetULONGField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "DeviceObject");
        UCHAR isEnumerated = GetUCHARField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "IsEnumerated");
        UCHAR isMissing = GetUCHARField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "IsMissing");
        
        xdprintf(Depth+2, ""), dprintf("PDO=%08p IsEnumerated=%d IsMissing=%d\n", pdoAddr, isEnumerated, isMissing);
                
        childPdoExtAddr = GetULONGField(childPdoExtAddr, "classpnp!_PHYSICAL_DEVICE_EXTENSION", "CommonExtension.ChildList");    
    }
    dprintf("\n");
        
    dprintf("\n");
    xdprintf(Depth+2, ""), dprintf("(for more info use 'dt classpnp!_FUNCTIONAL_DEVICE_EXTENSION %08p')\n", FdoExtAddr);
    xdprintf(0, "\n");
    
}


VOID
ClassDumpFdoExtensionInternal(
    IN ULONG64 FdoDataAddr,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG64 keTickCountAddr;
    ULONG keTickCount;
    ULONG len;
    
    dprintf("\n");
    xdprintf(Depth, ""), dprintf("Classpnp _INTERNAL_ data (%08p):\n", FdoDataAddr);
    
    /*
     *  Dump TRANSFER_PACKET lists
     */
    ClassDumpTransferPacketLists(FdoDataAddr, Detail, Depth+1);

    /*
     *  Dump private error logs
     */
    ClassDumpPrivateErrorLogs(FdoDataAddr, Detail, Depth+1);          

    /*
     *  Show time at trap (for comparison with error log timestamps)
     */
    keTickCountAddr = GetExpression("nt!KeTickCount");
    if (ReadMemory(keTickCountAddr, &keTickCount, sizeof(ULONG), &len)){
        dprintf("\n");
        xdprintf(Depth, ""), dprintf("KeTickCount trap time: %08xh = %d.%d\n", keTickCount, (ULONG)(keTickCount/1000), (ULONG)(keTickCount%1000));
    }
    
    dprintf("\n");
    xdprintf(Depth+2, ""), dprintf("(for more info use 'dt classpnp!_CLASS_PRIVATE_FDO_DATA %08p')\n", FdoDataAddr);
        
}



VOID ClassDumpTransferPacketLists(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth)
{
    ULONG64 allxferPktsListAddr;

    /*
     *  Print transfer packet lists
     */
    allxferPktsListAddr = GetFieldAddr(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "AllTransferPacketsList");
    if (allxferPktsListAddr != BAD_VALUE){
        ULONG64 listEntryAddr;
        ULONG numTotalXferPkts = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "NumTotalTransferPackets");
        ULONG numFreeXferPkts = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "NumFreeTransferPackets");
        ULONG numPackets;
        char *extraSpaces = IsPtr64() ? "        " : "";
        
        /*
         *  Walk AllTransferPacketsList and print only the outstanding packets with full SRB info.
         */
        xdprintf(Depth, "\n");
        xdprintf(Depth, "Outstanding transfer packets:  (out of %d total)\n", numTotalXferPkts);
        xdprintf(Depth, "\n");
        xdprintf(Depth+1, " packet %s   irp %s     srb %s    sense %s   status \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
        xdprintf(Depth+1, "--------%s --------%s --------%s --------%s -------- \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
        numPackets = 0; 
        listEntryAddr = GetULONGField(allxferPktsListAddr, "nt!_LIST_ENTRY", "Flink");
        while ((listEntryAddr != allxferPktsListAddr) && (listEntryAddr != BAD_VALUE)){
            ULONG64 pktAddr;

            pktAddr = GetContainingRecord(listEntryAddr, "classpnp!_TRANSFER_PACKET", "AllPktsListEntry");
            if (pktAddr == BAD_VALUE){
                break;
            }
            else {
                ClassDumpTransferPacket(pktAddr, TRUE, FALSE, TRUE, Depth+1);

                numPackets++;
                listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");                
            }
        }
        if (numPackets != numTotalXferPkts){
            xdprintf(Depth, "*** Warning: NumTotalTransferPackets(%d) doesn't match length of queue(%d) ***\n", numTotalXferPkts, numPackets);
        }


        if (Detail > 0){
            ULONG64 slistEntryAddr;
            
            /*
             *  Print all transfer packets
             */
            xdprintf(Depth, "\n");
            xdprintf(Depth, "All transfer packets:  (%d total, %d free)\n", numTotalXferPkts, numFreeXferPkts);
            xdprintf(Depth, "\n");
            xdprintf(Depth+1, " packet %s   irp %s     srb %s    sense %s   status \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
            xdprintf(Depth+1, "--------%s --------%s --------%s --------%s -------- \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
            numPackets = 0; 
            listEntryAddr = GetULONGField(allxferPktsListAddr, "nt!_LIST_ENTRY", "Flink");
            while ((listEntryAddr != allxferPktsListAddr) && (listEntryAddr != BAD_VALUE)){
                ULONG64 pktAddr;

                pktAddr = GetContainingRecord(listEntryAddr, "classpnp!_TRANSFER_PACKET", "AllPktsListEntry");
                if (pktAddr == BAD_VALUE){
                    break;
                }
                else {
                    ClassDumpTransferPacket(pktAddr, TRUE, TRUE, FALSE, Depth+1);

                    listEntryAddr = GetULONGField(listEntryAddr, "nt!_LIST_ENTRY", "Flink");                
                }
            }

            /*
             *  Print free packets sList
             */
            xdprintf(Depth, "\n");
            xdprintf(Depth, "Free transfer packets in fast SLIST: (%d free)\n", numFreeXferPkts);
            if (IsPtr64()){
                xdprintf(Depth, "(Cannot display fast SLIST on 64-bit system)\n");
            }
            else {
                xdprintf(Depth+1, " packet %s   irp %s     srb %s    sense %s   status \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
                xdprintf(Depth+1, "--------%s --------%s --------%s --------%s -------- \n", extraSpaces, extraSpaces, extraSpaces, extraSpaces);
                numPackets = 0;         
                slistEntryAddr = GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "FreeTransferPacketsList.Next.Next");
                while (slistEntryAddr && (slistEntryAddr != BAD_VALUE)){
                    ULONG64 pktAddr;

                    pktAddr = GetContainingRecord(slistEntryAddr, "classpnp!_TRANSFER_PACKET", "SlistEntry");
                    if (pktAddr == BAD_VALUE){
                        break;
                    }
                    else {
                        ClassDumpTransferPacket(pktAddr, TRUE, TRUE, FALSE, Depth+1);
                        
                        numPackets++;
                        slistEntryAddr = GetULONGField(pktAddr, "classpnp!_TRANSFER_PACKET", "SlistEntry.Next");
                    }
                }
                if (numPackets != numFreeXferPkts){
                    xdprintf(Depth, "*** Warning: NumFreeTransferPackets(%d) doesn't match length of queue(%d) ***\n", numFreeXferPkts, numPackets);
                }
            }
                
        }
                
    }

}


/*
 *  ClassDumpTransferPacket
 *
 *      Dump TRANSFER_PACKET contents under the following heading:
 *
 *      "  packet    irp      srb     sense    status "
 *      " -------- -------- -------- -------- -------- "
 *
 */
VOID ClassDumpTransferPacket(
    ULONG64 PktAddr, 
    BOOLEAN DumpPendingPkts, 
    BOOLEAN DumpFreePkts, 
    BOOLEAN DumpFullInfo, 
    ULONG Depth)
{

    ULONG64 irpAddr = GetULONGField(PktAddr, "classpnp!_TRANSFER_PACKET", "Irp");
    ULONG64 srbAddr = GetFieldAddr(PktAddr, "classpnp!_TRANSFER_PACKET", "Srb");
    ULONG64 senseAddr = GetFieldAddr(PktAddr, "classpnp!_TRANSFER_PACKET", "SrbErrorSenseData");

    if ((irpAddr == BAD_VALUE) || (srbAddr == BAD_VALUE) || (senseAddr == BAD_VALUE)){
        dprintf("\n ClassDumpTransferPacket: error retrieving contents of packet %08p.\n", PktAddr);
    }
    else {
        UCHAR currentStackLoc = GetUCHARField(irpAddr, "nt!_IRP", "CurrentLocation");
        UCHAR stackCount = GetUCHARField(irpAddr, "nt!_IRP", "StackCount");
        BOOLEAN isPending;
        
        isPending = (currentStackLoc != stackCount+1);
            
        if ((isPending && DumpPendingPkts) || (!isPending && DumpFreePkts)){
            
            /*
             *  Print the transfer packet description line
             */
            xdprintf(Depth, "");
            dprintf("%08p", PktAddr);
            dprintf(" %08p", irpAddr);
            dprintf(" %08p", srbAddr);
            dprintf(" %08p", senseAddr);
            if (isPending){
                xdprintf(0, " pending*");
            }
            else {
                xdprintf(0, " (free)");
            }
            xdprintf(0, "\n");

            if (DumpFullInfo){
                ULONG64 bufLen = GetULONGField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "DataTransferLength");
                ULONG64 cdbAddr = GetFieldAddr(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "Cdb");
                ULONG64 origIrpAddr = GetULONGField(PktAddr, "classpnp!_TRANSFER_PACKET", "OriginalIrp");
                ULONG64 mdlAddr = GetULONGField(origIrpAddr, "nt!_IRP", "MdlAddress");
                UCHAR scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                UCHAR srbStat = GetUCHARField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "SrbStatus");
                ULONG64 bufAddr;

                /*
                 *  The the buffer address from the MDL if possible; 
                 *  else from the SRB (which may not be valid).
                 */
                bufAddr = GetULONGField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "DataBuffer");
                if (mdlAddr && (mdlAddr != BAD_VALUE)){
                    ULONG mdlFlags = (ULONG)GetULONGField(mdlAddr, "nt!_MDL", "MdlFlags");
                    if ((mdlFlags != BAD_VALUE) && (mdlFlags & MDL_PAGES_LOCKED)){
                        bufAddr = GetULONGField(mdlAddr, "nt!_MDL", "MappedSystemVa");
                    }
                }
                else {
                    /*
                     *  There's no MDL, so bufAddr should be the actual kernel-space pointer.  
                     *  Sanity-check it.
                     */
                    if (!IsPtr64() && !(bufAddr & 0x80000000)){ 
                        bufAddr = BAD_VALUE;
                    }
                }
                
                /*
                 *  Print the SRB description line
                 */
                xdprintf(Depth+1, "(");
                dprintf("%s ", DbgGetScsiOpStr(scsiOp));
                dprintf("status=%s ", DbgGetSrbStatusStr(srbStat));

                if (mdlAddr && (mdlAddr != BAD_VALUE)){
                    if (bufAddr == BAD_VALUE){
                        dprintf("mdl=%08p ", mdlAddr);
                    }
                    else {
                        dprintf("mdl+%08p ", bufAddr);
                    }
                }
                else if (bufAddr == BAD_VALUE){
                        dprintf("buf=??? ");
                }
                else {
                    dprintf("buf=%08p ", bufAddr);
                }
                                
                dprintf("len=%08lx", bufLen);
                dprintf(")\n");

                /*
                 *  Print a line with original irp if appropriate
                 */
                if (cdbAddr != BAD_VALUE){ 
                    UCHAR scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                    
                    if ((scsiOp == SCSIOP_READ) || (scsiOp == SCSIOP_WRITE)){
                        xdprintf(Depth+1, ""), dprintf("(OriginalIrp=%08p)\n", origIrpAddr);
                    }
                }
            }
        }
        
    }


}

    

VOID ClassDumpPrivateErrorLogs(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth)
{
    ULONG64 errLogsAddr;
    
    errLogsAddr = GetFieldAddr(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "ErrorLogs");
    if (errLogsAddr != BAD_VALUE){
        ULONG errLogSize = GetTypeSize("classpnp!_CLASS_ERROR_LOG_DATA");
        if (errLogSize != BAD_VALUE){
            ULONG nextErrLogIndex, firstErrLogIndex, lastErrLogIndex;
            
            /*
             *  Find what should be the index of the last error log (if there were any error logs)
             *  See if it is valid by checking for a non-zero timestamp.
             */
            nextErrLogIndex = (ULONG)GetULONGField(FdoDataAddr, "classpnp!_CLASS_PRIVATE_FDO_DATA", "ErrorLogNextIndex");
            if (nextErrLogIndex != BAD_VALUE){
                ULONG64 tickCount;
                
                lastErrLogIndex = (nextErrLogIndex+NUM_ERROR_LOG_ENTRIES-1) % NUM_ERROR_LOG_ENTRIES;

                tickCount = GetULONGField(errLogsAddr+lastErrLogIndex*errLogSize, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");                   
                if (tickCount == BAD_VALUE){
                }
                else if (tickCount == 0){
                    /*
                     *  The "latest" error log is not initialized, so there are no error logs
                     */
                    dprintf("\n"), xdprintf(Depth, "No Error Logs:\n");  
                }
                else {                    
                    /*
                     *  Search forward through the circular list for the first valid error log.
                     */
                    for (firstErrLogIndex = (lastErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES;
                        firstErrLogIndex != lastErrLogIndex;
                        firstErrLogIndex = (firstErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES){

                        ULONG64 thisErrLogAddr = errLogsAddr+firstErrLogIndex*errLogSize;
                        
                        tickCount = GetULONGField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");                   
                        if (tickCount == BAD_VALUE){
                            /*
                             *  something's screwed up; abort
                             */
                            break;
                        }
                        else if (tickCount != 0){
                            /*
                             *  found the earliest of the recorded error logs, break
                             */
                            break;
                        }
                    }

                    if (tickCount != BAD_VALUE){
                        /*
                         *  Now that we've found the valid range of error logs, print them out.
                         */
                        ULONG numErrLogs = (lastErrLogIndex >= firstErrLogIndex) ? 
                                             lastErrLogIndex-firstErrLogIndex+1 :
                                             lastErrLogIndex+NUM_ERROR_LOG_ENTRIES-firstErrLogIndex+1;
                        
                        dprintf("\n\n"), xdprintf(Depth, "ERROR LOGS (%d):\n", numErrLogs);  
                        xdprintf(Depth, "---------------------------------------------------\n"); 
                        
                        do {
                            ULONG64 thisErrLogAddr = errLogsAddr+firstErrLogIndex*errLogSize;
                            ULONG64 tickCount = GetFieldAddr(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");
                            ULONG64 senseDataAddr = GetFieldAddr(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "SenseData");
                            ULONG64 srbAddr = GetFieldAddr(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "Srb");
                            ULONG64 cdbAddr;

                            // GetFieldOffset of an embedded struct gets the wrong address for some reason,
                            // so do this manually.
                            #if 0
                                cdbAddr = GetFieldAddr(thisErrLogAddr, "classpnp!_SCSI_REQUEST_BLOCK", "Cdb");
                            #else
                                cdbAddr = (srbAddr == BAD_VALUE) ? BAD_VALUE :
                                          IsPtr64() ? srbAddr + 0x48 :
                                          srbAddr + 0x30;  
                            #endif
                                    

                            if ((thisErrLogAddr != BAD_VALUE) && (srbAddr != BAD_VALUE) && (senseDataAddr != BAD_VALUE) && (cdbAddr != BAD_VALUE)){                              
                                UCHAR scsiOp = GetUCHARField(cdbAddr, "classpnp!_CDB", "CDB6GENERIC.OperationCode");
                                UCHAR srbStat = GetUCHARField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "SrbStatus");
                                UCHAR scsiStat = GetUCHARField(srbAddr, "classpnp!_SCSI_REQUEST_BLOCK", "ScsiStatus");
                                UCHAR isPaging = GetUCHARField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "ErrorPaging");
                                UCHAR isRetried = GetUCHARField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "ErrorRetried");
                                UCHAR isUnhandled = GetUCHARField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "ErrorUnhandled");
                                
                                tickCount = GetULONGField(thisErrLogAddr, "classpnp!_CLASS_ERROR_LOG_DATA", "TickCount");                                               

                                if ((scsiOp != BAD_VALUE) && (tickCount != BAD_VALUE)){

                                    xdprintf(Depth+1, "");
                                    dprintf("<tick %d.%d>:  ", (ULONG)(tickCount/1000), (ULONG)(tickCount%1000));
                                    dprintf("%s(%xh)\n",
                                            DbgGetScsiOpStr(scsiOp),
                                            (ULONG)scsiOp);
                                        
                                    xdprintf(Depth+2, "");
                                    dprintf("srbStat=%s(%xh) scsiStat=%xh \n",
                                            DbgGetSrbStatusStr(srbStat),
                                            (ULONG)srbStat,
                                            (ULONG)scsiStat
                                            );
                                    
                                    xdprintf(Depth+2, "");
                                    dprintf("SenseData = %s/%s/%s \n",
                                            DbgGetSenseCodeStr(srbStat, senseDataAddr),
                                            DbgGetAdditionalSenseCodeStr(srbStat, senseDataAddr),
                                            DbgGetAdditionalSenseCodeQualifierStr(srbStat, senseDataAddr));
                                    
                                    xdprintf(Depth+2, "");
                                    if (isPaging) dprintf("Paging; "); else dprintf("(not paging); ");
                                    if (isRetried) dprintf("Retried; "); else dprintf("(not retried); ");
                                    if (isUnhandled) dprintf("Unhandled; ");
                                    dprintf("\n");
                                        
                                    xdprintf(Depth+2, "");
                                    dprintf("(for more info, use 'dt classpnp!_CLASS_ERROR_LOG_DATA %08p'\n\n", thisErrLogAddr);
                                    
                                    firstErrLogIndex = (firstErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES;
                                }
                                else {
                                    break;
                                }
                            }
                            else {
                                break;
                            }
                        } while (firstErrLogIndex != (lastErrLogIndex+1)%NUM_ERROR_LOG_ENTRIES);
                        
                        xdprintf(Depth, "---------------------------------------------------\n");                         
                    }
                }
            }        
        }
    }


}


VOID
ClassDumpMediaChangeInfo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    )
{
    PUCHAR states[] = {"Unknown", "Present", "Not Present"};
    ULONG result;
    ULONG64 MediaChangeDetectionInfo;
    ULONG offset;
    LONG MediaChangeDetectionDisableCount;
    ULONG MediaChangeDetectionState;
    BOOLEAN MediaChangeIrpLost;
    LONG MediaChangeIrpTimeInUse;
    ULONG64 MediaChangeIrp;
    ULONG64 SenseBuffer;

    result = GetFieldData(Address,
                          "classpnp!_FUNCTIONAL_DEVICE_EXTENSION",
                          "MediaChangeDetectionInfo",
                          sizeof(ULONG64),
                          &MediaChangeDetectionInfo);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    xdprintfEx(Depth, ("MediaChangeNotification:\n"));
    Depth++;

    if (MediaChangeDetectionInfo == 0) {
        xdprintfEx(Depth, ("MCN is not enabled for this device\n"));
        return;
    }

    InitTypeRead(MediaChangeDetectionInfo, 
                 classpnp!_MEDIA_CHANGE_DETECTION_INFO);
    MediaChangeDetectionDisableCount = (LONG) ReadField(MediaChangeDetectionDisableCount);
    MediaChangeDetectionState = (ULONG) ReadField(MediaChangeDetectionState);
    MediaChangeIrpLost = (BOOLEAN) ReadField(MediaChangeIrpLost);
    MediaChangeIrpTimeInUse = (LONG) ReadField(MediaChangeIrpTimeInUse);
    MediaChangeIrp = ReadField(MediaChangeIrp);
    SenseBuffer = ReadField(SenseBuffer);

    result = GetFieldOffset("classpnp!_MEDIA_CHANGE_DETECTION_INFO",
                            "MediaChangeSrb",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    xdprintfEx(Depth, ("MCN is ")); // indent
    if (MediaChangeDetectionDisableCount == 0) {
        dprintf("Enabled ");
    } else {
        dprintf("Disabled ");
    }
    dprintf("Current State %s", states[MediaChangeDetectionState] );
    if (MediaChangeIrpLost != 0) {
        dprintf("  *** MCN Irp Lost for %x ticks ***  ",
                MediaChangeIrpTimeInUse);
    }
    dprintf("\n"); // end indent

    xdprintfEx(Depth, ("Irp %p  Srb %p  SenseBuffer %p\n",
               MediaChangeIrp,
               MediaChangeDetectionInfo + offset,
               SenseBuffer
               ));
    return;
}


VOID
ClassDumpFdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    )

{
    ULONG result;
    ULONG offset;
    ULONG tmp;

    ULONG64 LowerPdo;
    ULONG64 DeviceDescriptor;
    ULONG64 AdapterDescriptor;
    ULONG   DevicePowerState;
    ULONG   ErrorCount;
    BOOLEAN DMActive;
    ULONG   DMByteSkew;
    ULONG   DMSkew;
    ULONG64 SenseData;
    ULONG   TimeOutValue;
    ULONG   DeviceNumber;
    ULONG   FSrbFlags;
    USHORT  DeviceFlags;
    ULONG64 DiskGeometryCylinders;
    ULONG   DiskGeometryMediaType;
    ULONG   DiskGeometryTracksPerCylinder;
    ULONG   DiskGeometrySectorsPerTrack;
    ULONG   DiskGeometryBytesPerSector;
    LONG    LockCount;
    LONG    ProtectedLockCount;
    LONG    InternalLockCount;
    ULONG   MediaChangeCount;
    ULONG64 ChildLockOwner;
    ULONG   ChildLockAcquisitionCount;

    FIELD_INFO deviceFields[] = {
       {"LowerPdo", NULL, 0, COPY, 0, (PVOID) &LowerPdo},
       {"DeviceDescriptor", NULL, 0, COPY, 0, (PVOID) &DeviceDescriptor},
       {"AdapterDescriptor", NULL, 0, COPY, 0, (PVOID) &AdapterDescriptor},
       {"DevicePowerState", NULL, 0, COPY, 0, (PVOID) &DevicePowerState},
       {"ErrorCount", NULL, 0, COPY, 0, (PVOID) &ErrorCount},
       {"DMActive", NULL, 0, COPY, 0, (PVOID) &DMActive},
       {"DMByteSkew", NULL, 0, COPY, 0, (PVOID) &DMByteSkew},
       {"DMSkew", NULL, 0, COPY, 0, (PVOID) &DMSkew},
       {"SenseData", NULL, 0, COPY, 0, (PVOID) &SenseData},
       {"TimeOutValue", NULL, 0, COPY, 0, (PVOID) &TimeOutValue},
       {"DeviceNumber", NULL, 0, COPY, 0, (PVOID) &DeviceNumber},
       {"SrbFlags", NULL, 0, COPY, 0, (PVOID) &FSrbFlags},
       {"DeviceFlags", NULL, 0, COPY, 0, (PVOID) &DeviceFlags},
       {"DiskGeometry.Cylinders", NULL, 0, COPY, 0, (PVOID) &DiskGeometryCylinders},
       {"DiskGeometry.MediaType", NULL, 0, COPY, 0, (PVOID) &DiskGeometryMediaType},
       {"DiskGeometry.TracksPerCylinder", NULL, 0, COPY, 0, (PVOID) &DiskGeometryTracksPerCylinder},
       {"DiskGeometry.SectorsPerTrack", NULL, 0, COPY, 0, (PVOID) &DiskGeometrySectorsPerTrack},
       {"DiskGeometry.BytesPerSector", NULL, 0, COPY, 0, (PVOID) &DiskGeometryBytesPerSector},
       {"LockCount", NULL, 0, COPY, 0, (PVOID) &LockCount},
       {"ProtectedLockCount", NULL, 0, COPY, 0, (PVOID) &ProtectedLockCount},
       {"InternalLockCount", NULL, 0, COPY, 0, (PVOID) &InternalLockCount},
       {"MediaChangeCount", NULL, 0, COPY, 0, (PVOID) &MediaChangeCount},
       {"ChildLockOwner", NULL, 0, COPY, 0, (PVOID) &ChildLockOwner},
       {"ChildLockAcquisitionCount", NULL, 0, COPY, 0, (PVOID) &ChildLockAcquisitionCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "classpnp!_FUNCTIONAL_DEVICE_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }
    
    tmp = Depth;

    xdprintfEx(Depth, ("LowerPdo 0x%p   DeviceDesc 0x%p   AdapterDesc 0x%p\n",
               LowerPdo,
               DeviceDescriptor,
               AdapterDescriptor));

    xdprintfEx(Depth, ("DevicePowerState %d    ErrorCount %#x\n",
              DevicePowerState,
              ErrorCount
              ));

    if(DMActive) {
        xdprintfEx(Depth, ("DMByteSkew 0x%08lx  DmSkew 0x%08lx\n",
                   DMByteSkew,
                   DMSkew));
    } else {
        xdprintfEx(Depth, ("DM Not Found\n"));
    }

    xdprintfEx(Depth, ("Sense Data 0x%p   Timeout %d     DeviceNumber %d\n",
               SenseData,
               TimeOutValue,
               DeviceNumber));

    DumpFlags(Depth, "Srb Flags", FSrbFlags, SrbFlags);
    DumpFlags(Depth, "Device Flags", DeviceFlags, FdoFlags);

    xdprintfEx(Depth, ("DiskGeometry:\n"));
    {
        Depth++;

        xdprintfEx(Depth, ("Cylinders %#I64x       MediaType %#x\n",
                  DiskGeometryCylinders,
                  DiskGeometryMediaType
                  ));

        xdprintfEx(Depth, ("Tracks %#x   Sectors %#x   Bytes %#x\n",
                   DiskGeometryTracksPerCylinder,
                   DiskGeometrySectorsPerTrack,
                   DiskGeometryBytesPerSector));
        Depth--;
    }

    xdprintfEx(Depth, ("Lock Counts: Normal %#x  Protected %#x  Internal %#x\n",
               LockCount,
               ProtectedLockCount,
               InternalLockCount));

    ClassDumpMediaChangeInfo(Address, Detail, Depth);

    xdprintfEx(Depth, ("Media Change Count %#x\n", MediaChangeCount));

    result = GetFieldOffset("classpnp!_FUNCTIONAL_DEVICE_EXTENSION",
                            "ChildLock",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    xdprintfEx(Depth, ("ChildLock: Event %08p,  Owner %08p, Count %#x\n",
               Address + offset,
               ChildLockOwner,
               ChildLockAcquisitionCount
               ));

    ClassDumpChildren(Address, Detail, Depth);
    return;
}


VOID
ClassDumpChildren(
    IN ULONG64 Fdo,
    IN ULONG Detail,
    IN ULONG Depth
    )

{
    ULONG i;
    ULONG64 ChildList;
    ULONG result;

    xdprintfEx(Depth, ("Children: \n"));

    Depth++;

    result = GetFieldData(Fdo,
                          "classpnp!_COMMON_DEVICE_EXTENSION",
                          "ChildList",
                          sizeof(ULONG64),
                          &ChildList);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    if (ChildList == 0) {
        xdprintfEx(Depth, ("No Children\n"));
    }

    while((ChildList != 0) && (!CheckControlC())) {

        ULONG64 DeviceObject;

        xdprintfEx(Depth, ("Child 0x%p ", ChildList));
/*
        result = GetFieldData(ChildList,
                              "classpnp!_PHYSICAL_DEVICE_EXTENSION",
                              "DeviceObject",
                              sizeof(ULONG64),
                              &DeviceObject);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }
*/
        if(Detail > 1) {

            dprintf("\n");
            ClassDumpCommonExtension(ChildList,
                                     Detail,
                                     Depth + 1);

        } else {

            dprintf("DevObj 0x%p\n", ChildList);
        }

        //
        // Get the next child.
        //

        result = GetFieldData(ChildList,
                              "classpnp!_COMMON_DEVICE_EXTENSION",
                              "ChildList",
                              sizeof(ULONG64),
                              &ChildList);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }
    }

    return;
}

VOID
ClassDumpPdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    )

{
    ULONG tmp;
    BOOLEAN IsMissing;
    BOOLEAN IsEnumerated;

    tmp = Depth;

    InitTypeRead(Address, classpnp!_PHYSICAL_DEVICE_EXTENSION);
    IsMissing = (BOOLEAN)ReadField(IsMissing);
    IsEnumerated = (BOOLEAN)ReadField(IsEnumerated);

    if(IsMissing) {
        xdprintfEx(tmp, ("Missing " ));
        tmp = 0;
    }

    if(IsEnumerated) {
        xdprintfEx(tmp, ("Enumerated"));
        tmp = 0;
    }

    if(tmp == 0) {
        dprintf("\n");
    }

    tmp = 0;

    return;
}

BOOLEAN
ClassIsCheckedVersion(
    ULONG64 RemoveTrackingSpinlock
    )
{
    if ((PVOID)RemoveTrackingSpinlock == (PVOID)-1) {
        //
        // negative one is an invalid value for a spinlock,
        // therefore this is a FRE build
        //
        return FALSE;
    } else {
        return TRUE;
    }
}

VOID
ClassDumpLocks(
    ULONG64 CommonExtension,
    ULONG Depth
    )

/*++

Routine Description:

    dumps the remove locks for a given device object

Arguments:

    CommonExtension - a pointer to the local copy of the device object
                      common extension

Return Value:

    None

--*/

{
    ULONG result;
    ULONG64 lockEntryAddress;
    ULONG64 RemoveLock;
    ULONG64 RemoveTrackingSpinlock;
    ULONG64 RemoveTrackingList;

    InitTypeRead(CommonExtension, classpnp!_COMMON_DEVICE_EXTENSION);
    RemoveLock = ReadField(RemoveLock);
    RemoveTrackingSpinlock = ReadField(RemoveTrackingSpinlock);

    xdprintfEx(Depth, ("RemoveLock count is %d", RemoveLock));

    //
    // seeing if RemoveTrackingSpinLock is -1 is our check for the
    // FRE version, which does not contain useful data.
    //

    if(!ClassIsCheckedVersion(RemoveTrackingSpinlock)) {
        dprintf(" (not tracked on free build)\n");
        return;
    }

    RemoveTrackingList = ReadField(RemoveTrackingList);
    lockEntryAddress = RemoveTrackingList;
    dprintf(":\n");
    Depth++;

    if(RemoveTrackingSpinlock != 0) {
        xdprintfEx(Depth, ("RemoveTrackingList at %p is in intermediate state\n",
                 RemoveTrackingList));
        return;
    }

    while((lockEntryAddress != 0L) && !CheckControlC()) {
        
        UCHAR buffer[512];
        ULONG64 Tag;
        ULONG64 File;
        ULONG64 Line;
        ULONG64 NextBlock;

        InitTypeRead(lockEntryAddress, classpnp!_REMOVE_TRACKING_BLOCK);
        Tag = ReadField(Tag);
        File = ReadField(File);
        Line = ReadField(Line);
        NextBlock = ReadField(NextBlock);

        result = sizeof(buffer)-sizeof(UCHAR);

        if(!GetAnsiString(File,
                          buffer,
                          &result)) {

            xdprintfEx(Depth, ("Tag 0x%p File 0x%p Line %d\n",
                       Tag,
                       File,
                       Line));

        } else {

            PUCHAR name;

            name = &buffer[result];

            while((result > 0) &&
                  (*(name - 1) != '\\') &&
                  (*(name - 1)  != '/') &&
                  (!CheckControlC())) {
                name--;
                result--;
            }

            xdprintfEx(Depth, ("Tag 0x%p   File %8s   Line %d\n",
                       Tag,
                       name,
                       Line));
        }

        lockEntryAddress = NextBlock;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\sbp2kdx\sbp2kdx.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sbp2kdx.c

Abstract

    Kernel debugger extension dll for sbp2port.sys (1394 sbp2 protocol driver)

Author:

    Dan Knudson (dankn) 25 Jun 1999

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntverp.h>
#include <windows.h>
#include <ntosp.h>
#include <wdbgexts.h>
#include <sbp2port.h>

//
// Utility routine prototypes
//

void
DisplayAddressContext(
    char               *Name,
    PADDRESS_CONTEXT    Context,
    char               *Indent
    );

void
DisplayAsyncContextFlags(
    ULONG   Flags
    );

void
DisplayDeviceFlags(
    ULONG   Flags
    );

void
DisplayDeviceInformation(
    PDEVICE_INFORMATION     Info,
    ULONG                   Index
    );

void
DisplayLeaf(
    char           *Name,
    PTEXTUAL_LEAF   Leaf,
    char           *Indent
    );

void
DisplayStatusFifoBlock(
    char               *Name,
    PSTATUS_FIFO_BLOCK  Block
    );


//
//  Global variables
//

char                    Indent0[] = "", Indent1[] = "  ", Indent2[] = "    ";
EXT_API_VERSION         ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;
BOOLEAN                 Verbose, OrbFields;

char *Help[] =
{
    "\n",

    "    *** SBP2PORT.SYS Debugger Extensions ***\n\n",

    "Command                  Displays...\n",
    "---------------------------------------------------------------\n",
    "arc    <addr>            async request context\n",
    "fdoext <fdo> [-v]        fdo device extension (-v = verbose)\n",
    "help                     this\n",
    "pdoext <pdo> [-v] [-o]   pdo device extension (-o = Orb fields)\n\n",

    "NOTE: ' !devnode 0 1 ohci1394 ' shows the pdo device stack\n",
    "NOTE: pdoext.BusFdo shows the fdo address\n",

    "\n",
    NULL
};


BOOL
WINAPI
DLLMain(
    HINSTANCE   hInstance,
    ULONG       ulReason,
    LPVOID      pvReserved
    )
{
    return (TRUE);

}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )
{
    ExtensionApis = *pExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}


void
CheckVersion(
    void
    )
{
    // no-op?
}


LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )
{
    return (&ApiVersion);
}


DECLARE_API(arc)
{
    ULONG                   bytesRead;
    ULONG_PTR               p;
    ASYNC_REQUEST_CONTEXT   context, *pcontext;


    dprintf ("\n");

    if (args[0] == 0)
    {
        dprintf ("usage: arc <address> \n\n");
        return;
    }

    sscanf (args, "%lx", &p);

    if (!ReadMemory (p, &context, sizeof (context), &bytesRead))
    {
        dprintf ("Unable to read context\n\n");
        return;
    }

    if (bytesRead < sizeof (context))
    {
        dprintf(
            "Only read %d bytes of context, expected %d\n\n",
            bytesRead,
            sizeof (context)
            );

        return;
    }

    OrbFields = TRUE; // so address context below will get displayed

    // BUGUG  validation? like :  if (context.Tag != SBP2_ASYNC_CONTEXT_TAG)

    pcontext = (PASYNC_REQUEST_CONTEXT) p;

    dprintf ("&OrbList              = x%p\n", &pcontext->OrbList);
    dprintf ("  Flink               = x%p\n", context.OrbList.Flink);
    dprintf ("  Blink               = x%p\n", context.OrbList.Blink);
    dprintf ("&LookasideList        = x%p\n", &pcontext->LookasideList);
    dprintf ("  Next                = x%p\n", context.LookasideList.Next);
    dprintf ("Tag                   = x%x\n", context.Tag);
    dprintf ("DeviceObject          = x%p\n", context.DeviceObject);
    dprintf ("Srb                   = x%p\n", context.Srb);

    DisplayAsyncContextFlags (context.Flags);

    dprintf ("CmdOrb                = x%p\n", context.CmdOrb);
    dprintf ("CmdOrbAddress         = x%x%08x\n", context.CmdOrbAddress.u.HighQuad, context.CmdOrbAddress.u.LowQuad);
    dprintf ("PartialMdl            = x%p\n", context.PartialMdl);
    dprintf ("RequestMdl            = x%p\n", context.RequestMdl);
    dprintf ("PageTableContext\n");
    dprintf ("  MaxPages            = x%x\n", context.PageTableContext.MaxPages);
    dprintf ("  NumberOfPages       = x%x\n", context.PageTableContext.NumberOfPages);
    dprintf ("  PageTable           = x%p\n", context.PageTableContext.PageTable);

    DisplayAddressContext ("  AddressContext\n", &context.PageTableContext.AddressContext, Indent2);

    dprintf ("DataMappingHandle     = x%p\n", context.DataMappingHandle);
    dprintf ("Packet                = x%p\n", context.Packet);

    dprintf ("\n");
}


DECLARE_API(fdoext)
{
    ULONG                   bytesRead, i;
    ULONG_PTR               p;
    DEVICE_OBJECT           obj;
    FDO_DEVICE_EXTENSION    ext;


    dprintf ("\n");


    //
    // Get the fdo pointer & any args from the cmd line
    //

    if (args[0] == 0)
    {
        dprintf ("usage: fdoext <fdo address> [-v]\n\n");
        return;
    }

    sscanf (args, "%lx", &p);

    Verbose = (BOOLEAN) strstr (args, "-v");


    //
    // Read the DEVICE_OBJECT to retrieve the device extension pointer
    //

    if (!ReadMemory (p, &obj, sizeof (obj), &bytesRead))
    {
        dprintf ("Unable to read pdo\n\n");
        return;
    }

    if (bytesRead < sizeof (obj))
    {
        dprintf(
            "Only read %d bytes of pdo, expected %d\n\n",
            bytesRead,
            sizeof (obj)
            );

        return;
    }

    p = (ULONG_PTR) obj.DeviceExtension;


    //
    // Read the device extension
    //

    if (!ReadMemory (p, &ext, sizeof (ext), &bytesRead))
    {
        dprintf ("Unable to read pdo extension\n\n");
        return;
    }

    if (bytesRead < sizeof (ext))
    {
        dprintf(
            "Only read %d bytes of fdo extension, expected %d\n\n",
            bytesRead,
            sizeof (ext)
            );

        return;
    }

    if (ext.Type != SBP2_FDO)
    {
        dprintf ("Not a fdo extension (ext.Type=x%x)\n\n", ext.Type);
        return;
    }


    //
    // Display the extension fields
    //

    dprintf ("DeviceObject          = x%p\n", ext.DeviceObject);
    dprintf ("LowerDeviceObject     = x%p\n", ext.LowerDeviceObject);

    DisplayDeviceFlags (ext.DeviceFlags);

    dprintf ("ConfigRom\n");
    dprintf ("  CR_Info             = x%x\n", ext.ConfigRom.CR_Info);
    dprintf ("  CR_Signiture        = x%x\n", ext.ConfigRom.CR_Signiture);
    dprintf ("  CR_BusInfoBlockCaps = x%x\n", ext.ConfigRom.CR_BusInfoBlockCaps);
    dprintf ("  CR_Node_UniqueID[0] = x%x\n", ext.ConfigRom.CR_Node_UniqueID[0]);
    dprintf ("  CR_Node_UniqueID[1] = x%x\n", ext.ConfigRom.CR_Node_UniqueID[1]);
    dprintf ("  CR_Root_Info        = x%x\n", ext.ConfigRom.CR_Root_Info);

    for (i = 0; i < SBP2_MAX_LUNS_PER_NODE; i++)
    {
        DisplayDeviceInformation (ext.DeviceList + i, i);
    }

    dprintf ("DeviceListSize        = x%x\n", ext.DeviceListSize);

    DisplayLeaf ("VendorLeaf", ext.VendorLeaf, Indent1);

    dprintf ("MaxClassTransferSize  = x%x\n", ext.MaxClassTransferSize);
    dprintf ("Sbp2ObjectDirectory   = x%p\n", ext.Sbp2ObjectDirectory);


    dprintf ("\n");
}


DECLARE_API(help)
{
    ULONG   i;


    for (i = 0; Help[i]; i++)
    {
        dprintf (Help[i]);
    }

    return;
}


DECLARE_API(pdoext)
{
    ULONG               bytesRead;
    ULONG_PTR           p;
    DEVICE_OBJECT       obj;
    DEVICE_EXTENSION    ext;


    dprintf ("\n");


    //
    // Get the fdo pointer & any args from the cmd line
    //

    if (args[0] == 0)
    {
        dprintf ("usage: pdoext <pdo address> [-v]\n\n");
        return;
    }

    sscanf (args, "%lx", &p);

    Verbose = (BOOLEAN) strstr (args, "-v");

    OrbFields = (BOOLEAN) strstr (args, "-o");


    //
    // Read the DEVICE_OBJECT to retrieve the device extension pointer
    //

    if (!ReadMemory (p, &obj, sizeof (obj), &bytesRead))
    {
        dprintf ("Unable to read pdo\n\n");
        return;
    }

    if (bytesRead < sizeof (obj))
    {
        dprintf(
            "Only read %d bytes of pdo, expected %d\n\n",
            bytesRead,
            sizeof (obj)
            );

        return;
    }

    p = (ULONG_PTR) obj.DeviceExtension;


    //
    // Read the device extension
    //

    if (!ReadMemory (p, &ext, sizeof (ext), &bytesRead))
    {
        dprintf ("Unable to read pdo extension\n\n");
        return;
    }

    if (bytesRead < sizeof (ext))
    {
        dprintf(
            "Only read %d bytes of pdo extension, expected %d\n\n",
            bytesRead,
            sizeof (ext)
            );

        return;
    }

    if (ext.Type != SBP2_PDO)
    {
        dprintf ("Not a pdo extension (ext.Type=x%x)\n\n", ext.Type);
        return;
    }


    //
    // Display the extension fields
    //

    dprintf ("DeviceObject          = x%p\n", ext.DeviceObject);
    dprintf ("LowerDeviceObject     = x%p\n", ext.LowerDeviceObject);

    DisplayDeviceFlags (ext.DeviceFlags);

    dprintf ("BusFdo                = x%p\n", ext.BusFdo);

    DisplayDeviceInformation (ext.DeviceInfo, 0xffffffff);

    dprintf ("MaxOrbListDepth       = %d\n", ext.MaxOrbListDepth);

    dprintf ("&PendingOrbList       = x%p\n", &((PDEVICE_EXTENSION) p)->PendingOrbList);

    if (Verbose)
    {
    dprintf ("  Flink               = x%p\n", ext.PendingOrbList.Flink);
    dprintf ("  Blink               = x%p\n", ext.PendingOrbList.Blink);
    }

    dprintf ("OrbListDepth          = %d\n", ext.OrbListDepth);
    dprintf ("CurrentKey            = x%x\n", ext.CurrentKey);
    dprintf ("LastFetchedContext    = x%p\n", ext.LastFetchedContext);
    dprintf ("NextContextToFree     = x%p\n", ext.NextContextToFree);
    dprintf ("DevicePowerState      = %d\n", (ULONG) ext.DevicePowerState);
    dprintf ("SystemPowerState      = %d\n", (ULONG) ext.SystemPowerState);
    dprintf ("PowerDeferredIrp      = x%p\n", ext.PowerDeferredIrp);
    dprintf ("DeferredPowerRequest  = x%p\n", ext.DeferredPowerRequest);
    dprintf ("PagingPathCount       = %d\n", (ULONG) ext.PagingPathCount);
    dprintf ("HibernateCount        = %d\n", (ULONG) ext.HibernateCount);
    dprintf ("CrashDumpCount        = %d\n", (ULONG) ext.CrashDumpCount);
    dprintf ("HandleCount           = %d\n", (ULONG) ext.HandleCount);
    dprintf ("IdleCounter           = x%p\n", &((PDEVICE_EXTENSION) p)->IdleCounter);

    // DueTime

    dprintf ("Reserved              = x%x (%d)\n", ext.Reserved, ext.Reserved);
    dprintf ("LastTransactionStatus = x%x\n", ext.LastTransactionStatus);
    dprintf ("ReservedMdl           = x%p\n", ext.ReservedMdl);
    dprintf ("&InquiryData          = x%p\n", &((PDEVICE_EXTENSION) p)->InquiryData);
    dprintf ("InitiatorAddressId    = x%d\n", ext.InitiatorAddressId);
    dprintf ("CurrentGeneration     = x%d\n", ext.CurrentGeneration);
    dprintf ("MaxControllerPhySpeed = x%d\n", ext.MaxControllerPhySpeed);
    dprintf ("OrbReadPayloadMask    = x%d\n", (ULONG) ext.OrbReadPayloadMask);
    dprintf ("OrbWritePayloadMask   = x%d\n", (ULONG) ext.OrbWritePayloadMask);

    if (Verbose)
    {
    dprintf ("HostControllerInformation\n");
    dprintf ("  HostCapabilities    = x%d\n", ext.HostControllerInformation.HostCapabilities);
    dprintf ("  MaxAsyncReadReq     = x%d\n", ext.HostControllerInformation.MaxAsyncReadRequest);
    dprintf ("  MaxAsyncWriteReq    = x%d\n", ext.HostControllerInformation.MaxAsyncWriteRequest);

    dprintf ("HostRoutineAPI\n");
    dprintf ("  PhysAddrMappingRtn  = x%p\n", ext.HostRoutineAPI.PhysAddrMappingRoutine);
    dprintf ("  Context             = x%p\n", ext.HostRoutineAPI.Context);
    }

    if (OrbFields)
    {
    dprintf ("TaskOrb\n");
    dprintf ("  OrbAddress          = x%x%08x\n", ext.TaskOrb.OrbAddress.u.HighQuad, ext.TaskOrb.OrbAddress.u.LowQuad);
    dprintf ("  Reserved            = x%x%08x\n", ext.TaskOrb.Reserved.u.HighQuad, ext.TaskOrb.Reserved.u.LowQuad);
    dprintf ("  OrbInfo             = x%x\n", ext.TaskOrb.OrbInfo);
    dprintf ("  Reserved1           = x%x\n", ext.TaskOrb.Reserved1);
    dprintf ("  StatusBlockAddress  = x%x%08x\n", ext.TaskOrb.StatusBlockAddress.u.HighQuad, ext.TaskOrb.StatusBlockAddress.u.LowQuad);

    dprintf ("ManagementOrb\n");
    dprintf ("  Reserved[0]         = x%x%08x\n", ext.ManagementOrb.Reserved[0].u.HighQuad, ext.ManagementOrb.Reserved[0].u.LowQuad);
    dprintf ("  Reserved[1]         = x%x%08x\n", ext.ManagementOrb.Reserved[1].u.HighQuad, ext.ManagementOrb.Reserved[1].u.LowQuad);
    dprintf ("  OrbInfo             = x%x\n", ext.ManagementOrb.OrbInfo);
    dprintf ("  Reserved1           = x%x\n", ext.ManagementOrb.Reserved1);
    dprintf ("  StatusBlockAddress  = x%x%08x\n", ext.ManagementOrb.StatusBlockAddress.u.HighQuad, ext.ManagementOrb.StatusBlockAddress.u.LowQuad);
    }

    DisplayAddressContext ("TaskOrbContext\n", &ext.TaskOrbContext, Indent1);
    DisplayAddressContext ("ManagementOrbContext\n", &ext.ManagementOrbContext, Indent1);
    DisplayStatusFifoBlock ("ManagementOrbStatusBlock\n", &ext.ManagementOrbStatusBlock);
    DisplayAddressContext ("ManagementOrbStatusContext\n", &ext.ManagementOrbStatusContext, Indent1);
    DisplayStatusFifoBlock ("TaskOrbStatusBlock\n", &ext.TaskOrbStatusBlock);
    DisplayAddressContext ("TaskOrbStatusContext\n", &ext.TaskOrbStatusContext, Indent1);
    DisplayAddressContext ("GlobalStatusContext\n", &ext.GlobalStatusContext, Indent1);

    if (Verbose)
    {
    dprintf ("LoginResponse\n");
    dprintf ("  LengthAndLoginId    = x%x\n", ext.LoginResponse.LengthAndLoginId);
    dprintf ("  Csr_Off_High        = x%x\n", ext.LoginResponse.Csr_Off_High);
    dprintf ("  Csr_Off_Low         = x%x\n", ext.LoginResponse.Csr_Off_Low);
    dprintf ("  Reserved            = x%x\n", ext.LoginResponse.Reserved);
    }

    DisplayAddressContext ("LoginRespContext\n", &ext.LoginRespContext, Indent1);

    if (Verbose)
    {
    dprintf ("&QueryLoginResponse   = x%p\n", &((PDEVICE_EXTENSION) p)->QueryLoginResponse);
    dprintf ("  LengthAndNumLogins  = x%x\n", ext.QueryLoginResponse.LengthAndNumLogins);
    dprintf ("  Elements[0]\n");
    dprintf ("    NodeAndLoginId    = x%x\n", ext.QueryLoginResponse.Elements[0].NodeAndLoginId);
    dprintf ("    EUI64             = x%x%08x\n", ext.QueryLoginResponse.Elements[0].EUI64.u.HighQuad, ext.QueryLoginResponse.Elements[0].EUI64.u.LowQuad);
    }

    // there's 3 more elements in the Elements[] array above we could display

    DisplayAddressContext ("QueryLoginRespContext\n", &ext.QueryLoginRespContext, Indent1);

    dprintf ("&StatusFifoListHead   = x%p\n", &((PDEVICE_EXTENSION) p)->StatusFifoListHead);

//    KSPIN_LOCK StatusFifoLock;

    dprintf ("StatusFifoBase        = x%p\n", ext.StatusFifoBase);

    dprintf ("&FreeContextListHead  = x%p\n", &((PDEVICE_EXTENSION) p)->FreeContextListHead);
    dprintf ("&BusReqContxtListHead = x%p\n", &((PDEVICE_EXTENSION) p)->BusRequestContextListHead);
    dprintf ("&BusReqIrpIrbListHead = x%p\n", &((PDEVICE_EXTENSION) p)->BusRequestIrpIrbListHead);

//    KSPIN_LOCK  BusRequestLock;

//    KSPIN_LOCK FreeContextLock;

    dprintf ("AsyncContextBase      = x%p\n", ext.AsyncContextBase);

    DisplayAddressContext ("OrbPoolContext\n", &ext.OrbPoolContext, Indent1);

//    KSPIN_LOCK  ExtensionDataSpinLock;
//    KDPC DeviceManagementTimeoutDpc;
//    KTIMER DeviceManagementTimer;

    dprintf ("\n");
}


//
// Utility funcs
//

void
DisplayAddressContext(
    char               *Name,
    PADDRESS_CONTEXT    pContext,
    char               *Indent
    )
{
    char   *postIndent = (Indent == Indent1 ? Indent1 : Indent0);


    if (!OrbFields)
    {
        return;
    }

    dprintf (Name);

    dprintf ("%sDeviceObject%s      = x%p\n", Indent, postIndent, pContext->DeviceObject);
    dprintf ("%sAddress%s           = x%x%08x\n", Indent, postIndent, pContext->Address.u.HighQuad, pContext->Address.u.LowQuad);
    dprintf ("%sReservedAddr%s      = x%x%08x\n", Indent, postIndent, pContext->ReservedAddr.u.HighQuad, pContext->ReservedAddr.u.LowQuad);
    dprintf ("%sAddressHandle%s     = x%p\n", Indent, postIndent, pContext->AddressHandle);
    dprintf ("%sRequestMdl%s        = x%p\n", Indent, postIndent, pContext->RequestMdl);
    dprintf ("%sTransactionType%s   = x%x\n", Indent, postIndent, pContext->TransactionType);
    dprintf ("%sReserved%s          = x%p\n", Indent, postIndent, pContext->Reserved);
}


void
DisplayAsyncContextFlags(
    ULONG   Flags
    )
{
    ULONG   i;
    char   *flagNames[] =
    {
        "TIMER_STARTED",
        "COMPLETED",
        "PAGE_ALLOC",
        "DATA_ALLOC",
        NULL
    };


    dprintf ("DeviceFlags           = x%x, ", Flags);

    for (i = 0; Flags  &&  flagNames[i]; i++)
    {
        if (Flags & (1 << i))
        {
            dprintf (flagNames[i]);

            Flags &= ~(1 << i);
        }
    }

    if (Flags)
    {
        dprintf ("<inval flag(s)=x%x>", Flags);
    }

    dprintf ("\n");
}


void
DisplayDeviceFlags(
    ULONG   Flags
    )
{
    ULONG   i;
    char   *flagNames[] =
    {
        "STOPPED ",
        "RESET_IN_PROGRESS ",
        "REMOVED ",
        "LOGIN_IN_PROGRESS ",
        "RECONNECT ",
        "CLAIMED ",
        "INITIALIZING ",
        "QUEUE_LOCKED ",
        "SPC_CMD_SET ",
        "INITIALIZED ",
        "REMOVE_PENDING ",
        "DEVICE_FAILED ",
        NULL
    };


    dprintf ("DeviceFlags           = x%x, ", Flags);

    for (i = 0; Flags  &&  flagNames[i]; i++)
    {
        if (Flags & (1 << i))
        {
            dprintf (flagNames[i]);

            Flags &= ~(1 << i);
        }
    }

    if (Flags)
    {
        dprintf ("<inval flag(s)=x%x>", Flags);
    }

    dprintf ("\n");
}


void
DisplayDeviceInformation(
    PDEVICE_INFORMATION     Info,
    ULONG                   Index
    )
{
    ULONG               bytesRead;
    DEVICE_INFORMATION  info;


    if (Index == 0xffffffff)
    {
        //
        // Called from pdoext(), Info is simple a debugee pointer, need
        // to read in the data
        //

            dprintf ("DeviceInfo            = x%p\n", Info);

        if (!Verbose)
        {
            return;
        }

        if (!ReadMemory ((ULONG_PTR) Info, &info, sizeof (info), &bytesRead))
        {
            dprintf ("  <Unable to read device information>\n");
            return;
        }

        if (bytesRead < sizeof (info))
        {
            dprintf(
                "  <Only read %d bytes of device information, expected %d>\n",
                bytesRead,
                sizeof (info)
                );

            return;
        }

        Info = &info;
    }
    else
    {
        //
        // Called from fdoext(), Info data is valid
        //

        if (!Verbose  ||  !Info->DeviceObject)
        {
            return;
        }

        dprintf ("DeviceInfo[%d]\n", Index);
    }

    dprintf ("  DeviceObject        = x%p\n", Info->DeviceObject);
    dprintf ("  Lun                 = x%x\n", Info->Lun);
    dprintf ("  CmdSetId            = x%x\n", Info->CmdSetId);
    dprintf ("  UnitCharactristics  = x%x\n", Info->UnitCharacteristics);
    dprintf ("  MgmtAgentBaseReg    = x%x%08x\n", Info->ManagementAgentBaseReg.u.HighQuad, Info->ManagementAgentBaseReg.u.LowQuad);
    dprintf ("  CsrRegisterBase     = x%x%08x\n", Info->CsrRegisterBase.u.HighQuad, Info->CsrRegisterBase.u.LowQuad);
    dprintf ("  ConfigRom           = x%p\n", Info->ConfigRom);

    // display crom

    DisplayLeaf ("  ModelLeaf", Info->ModelLeaf, Indent2);
    DisplayLeaf ("  VendorLeaf", Info->VendorLeaf, Indent2);

    dprintf ("  GenericName         = %s\n", Info->GenericName);
    dprintf ("  MaxClassXferSize    = x%x\n", Info->MaxClassTransferSize);
}


void
DisplayLeaf(
    char           *Name,
    PTEXTUAL_LEAF   Leaf,
    char           *Indent
    )
{
    char           *postIndent = (Indent == Indent1 ? Indent1 : Indent0);
    BYTE            buf[sizeof (TEXTUAL_LEAF) + SBP2_MAX_TEXT_LEAF_LENGTH];
    ULONG           bytesRead, length;
    ULONG_PTR       p = (ULONG_PTR) Leaf;
    PTEXTUAL_LEAF   leaf = (PTEXTUAL_LEAF) buf;


    dprintf ("%-22.22s= x%p\n", Name, p);

    if (Leaf  &&  Verbose)
    {
        //
        // First read in, byte swap, & display the fixed size of the leaf
        //

        if (!ReadMemory (p, buf, sizeof (*leaf), &bytesRead))
        {
            dprintf ("  <Unable to read leaf>\n");
            return;
        }

        if (bytesRead < sizeof (*leaf))
        {
            dprintf(
                "  <Only read %d bytes of leaf, expected %d>\n",
                bytesRead,
                sizeof (buf)
                );

            return;
        }

        {
            ULONG   *p = (ULONG *) &leaf->TL_CRC;

            *p = bswap (*p);
        }

        leaf->TL_Spec_Id = bswap (leaf->TL_Spec_Id);
        leaf->TL_Language_Id = bswap (leaf->TL_Language_Id);

        dprintf ("%sTL_CRC%s            = x%x\n", Indent, postIndent, (ULONG) leaf->TL_CRC);
        dprintf ("%sTL_Length%s         = x%x\n", Indent, postIndent, (ULONG) leaf->TL_Length);
        dprintf ("%sTL_Spec_Id%s        = x%x\n", Indent, postIndent, leaf->TL_Spec_Id);
        dprintf ("%sTL_Language_Id%s    = x%x\n", Indent, postIndent, leaf->TL_Language_Id);


        //
        // Now read in the whole leaf (but not more than will fit in
        // our stack buffer).  Display only the first 50 chars
        //

        length = (ULONG) (leaf->TL_Length * sizeof (QUADLET)) +
            sizeof (*leaf) - sizeof (leaf->TL_Data);

        length = (length > sizeof (buf) ? sizeof (buf) : length);

        if (!ReadMemory (p, buf, length, &bytesRead))
        {
            dprintf ("  <Unable to read variable-length portion of leaf>\n");
            return;
        }

        if (bytesRead < sizeof (*leaf))
        {
            dprintf(
                "  <Only read %d bytes of leaf, expected %d>\n",
                bytesRead,
                sizeof (buf)
                );

            return;
        }

        leaf->TL_Spec_Id = bswap (leaf->TL_Spec_Id);

        if (leaf->TL_Spec_Id  &  0x80000000) // unicode
        {
            dprintf ("%sTL_Data%s           = %ws\n", Indent, postIndent, &leaf->TL_Data);
        }
        else // ascii
        {
            dprintf ("%sTL_Data%s           = %s\n", Indent, postIndent, &leaf->TL_Data);
        }

    }
}


void
DisplayStatusFifoBlock(
    char               *Name,
    PSTATUS_FIFO_BLOCK  Block
    )
{
    if (!OrbFields)
    {
        return;
    }

    dprintf (Name);

    dprintf ("  AddressAndStatus    = x%x%08x\n", Block->AddressAndStatus.u.HighQuad, Block->AddressAndStatus.u.LowQuad);
    dprintf ("  Contents[0]         = x%x%08x\n", Block->Contents[0].u.HighQuad, Block->Contents[0].u.LowQuad);
    dprintf ("  Contents[1]         = x%x%08x\n", Block->Contents[1].u.HighQuad, Block->Contents[1].u.LowQuad);
    dprintf ("  Contents[2]         = x%x%08x\n", Block->Contents[2].u.HighQuad, Block->Contents[2].u.LowQuad);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\him_scb.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    him_scb.c

Abstract:

    WinDbg Extension Api for interpretting AIC78XX debugging structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#define DBG_TRACE
#define _DRIVER
#include "him_scb.h"

void dumpScb_struct(ULONG_PTR addr, spx_struct *scb);
void dumpCfp_struct(ULONG_PTR addr, cfp_struct *cfp);
void dumpHsp_struct(ULONG_PTR addr, hsp_struct *hsp);
void dumpScbQueue(ULONG_PTR addr);

DECLARE_API( scbqueue )
{
        ULONG_PTR addr;
        ULONG detail; // not really used

        GetAddressAndDetailLevel(args, &addr, &detail);

        dumpScbQueue(addr);
        return;
}

DECLARE_API( scb )

/*++

Routine Description:

    Dumps the specified AIC78xx debugging data structure

Arguments:

    Ascii bits for address.

Return Value:

    None.

--*/

{
    ULONG_PTR   addr;
    ULONG detail; // not really used
    spx_struct  scb;

    GetAddressAndDetailLevel(args, &addr, &detail);

    if (!ReadMemory( addr, &scb, sizeof(scb), NULL )) {
        dprintf("%p: Could not read Scb\n", addr);
        return;
    }

        dumpScb_struct(addr, &scb);

        return;
}

DECLARE_API( cfp )
{
        ULONG_PTR addr;
        ULONG detail; // not really used
        cfp_struct cfp;

        GetAddressAndDetailLevel(args, &addr, &detail);

        if(!ReadMemory(addr, &cfp, sizeof(cfp), NULL))  {
                dprintf("%p: Could not read Cfp\n", addr);
                return;
        }

        dumpCfp_struct(addr, &cfp);

        return;
}

DECLARE_API( hsp )
{
        ULONG_PTR addr;
        ULONG detail; // not really used
        hsp_struct hsp;

        GetAddressAndDetailLevel(args, &addr, &detail);

        if(!ReadMemory(addr, &hsp, sizeof(hsp), NULL))  {
                dprintf("%p: Could not read Hsp\n", addr);
                return;
        }

        dumpHsp_struct(addr, &hsp);

        return;
}

void dumpScb_struct(ULONG_PTR addr, spx_struct *scb)        {

        int i;
        ULONG tmp;

        dprintf("AIC78xx scb (%p):\n", addr);

        dprintf("\tSp_queue.Next = %p\n", (DWORD) scb->Sp_queue.Next);
        dprintf("\tSp_config = %lx\n", (DWORD) scb->Sp_config.ConfigPtr);

        //figure out addr of scb->Sp_control
        dprintf("\tSp_control = %08lx\n", addr + OFFSET(scb, Sp_control));

#define DUMP(name)      \
        dprintf("\t\t" #name " = %lx\n", scb->Sp_seq_scb.seq_scb_struct.name)
#define DUMP_P(name)      \
        dprintf("\t\t" #name " = %p\n", scb->Sp_seq_scb.seq_scb_struct.name)
#define DUMP64(name)      \
        dprintf("\t\t" #name " = %p\n", scb->Sp_seq_scb.seq_scb_struct.name)

        dprintf("\tSp_seq_scb:\n");
        DUMP(Tarlun);
        DUMP(TagType);
        DUMP(Discon);
        DUMP(SpecFunc);
        DUMP(TagEnable);
        DUMP(DisEnable);
        DUMP(RejectMDP);
        DUMP(CDBLen);
        DUMP(SegCnt);
        DUMP(SegPtr);
        DUMP(CDBPtr);
        DUMP(TargStat);
        DUMP(Holdoff);
        DUMP(Concurrent);
        DUMP(Abort);
        DUMP(Aborted);
        DUMP(Progress);
        DUMP(NextPtr);
        DUMP(Offshoot);
        DUMP(ResCnt);
        DUMP(Address);
        DUMP(Length);
        DUMP(HaStat);

#undef DUMP
#undef DUMP_P
#undef DUMP64

        dprintf("\tSp_SensePtr = %p\n", scb->Sp_SensePtr);
        dprintf("\tSp_SenseLen = %d\n", scb->Sp_SenseLen);

        dprintf("\tSp_CDB[] = ");
        for(i = 0; i < MAX_CDB_LEN; i++)
                dprintf("%x ", scb->Sp_CDB[i]);
        dprintf("\n");

        dprintf("\tSp_ExtMsg[] = ");
        for(i = 0; i < 8; i++)
                dprintf("%x ", scb->Sp_ExtMsg[i]);
        dprintf("\n");

        dprintf("\tSp_OSspecific = %lx\n", scb->Sp_OSspecific);

        return;
}

void dumpCfp_struct(ULONG_PTR addr, cfp_struct *cfp)        {

        ULONG tmp;

        dprintf("AIC78xx cfp (%p):\n", addr);

        dprintf("\tAdapterId = %x\n", cfp->Cf_id.AdapterId);
        dprintf("\tBaseAddress = %p\n", cfp->Cf_base_addr.BaseAddress);

        dprintf("\tCf_flags = %08lx\n", cfp->Cf_flags.ConfigFlags);

        dprintf("\tHaDataPtr = (hsp *) %p\n",
                cfp->Cf_hsp_ptr.HaDataPtrField);

        dprintf("\tMaxNonTagScbs = %x\n", cfp->Cf_MaxNonTagScbs);
        dprintf("\tMaxTagScbs = %x\n", cfp->Cf_MaxTagScbs);
        dprintf("\tNumberScbs = %x\n", cfp->Cf_NumberScbs);
        dprintf("\tOSspecific = %p\n", cfp->Cf_OSspecific);

        tmp = addr + ((char *) &(cfp->TRACE) - (char *) cfp);

        dprintf("\ttraceinfo address = %08lx\n", tmp);

        return;
}

void dumpHsp_struct(ULONG_PTR addr, hsp_struct *hsp)        {

        dprintf("AIC78xx hsp %p\n", addr);

        dprintf("\tHead of work queue = %p\n", hsp->Head_Of_Q);
        dprintf("\tEnd of work queue = %p\n", hsp->End_Of_Q);

        dprintf("\tNumber read scb's = %d\n", hsp->ready_cmd);
        dprintf("\tMax nontagged scb's per target = %d\n", hsp->Hsp_MaxNonTagScbs);
        dprintf("\tMax tagged scb's per target = %d\n", hsp->Hsp_MaxTagScbs);
        dprintf("\tIndex to done SCB array = %d\n", hsp->done_cmd);
        dprintf("\tHigh free SCB index = %d\n", hsp->free_hi_scb);

        dprintf("\tactive ptr = %p\n", hsp->a_ptr.active_ptr_field);
        dprintf("\tfree stack = %p\n", hsp->f_ptr.free_stack_field);
        dprintf("\tdone stack = %p\n", hsp->d_ptr.done_stack_field);

        dprintf("\tSemState = %d\n", hsp->SemState);
        dprintf("\tHA Flags = %x\n", hsp->HaFlags);

        return;
}

void dumpScbQueue(ULONG_PTR addr)   {

        spx_struct tmp;
        ULONG last = 0;

        dprintf("AIC78xx scb queue dump:\n");

        while((addr != (ULONG_PTR)NOT_DEFINED) && (addr != NULL)) {

            dprintf("%p, ", addr);

            if (!ReadMemory( addr, &tmp, sizeof(tmp), NULL )) {
                dprintf("!aic78kd.dumpScbQueue : couldn't read address %p\n",
                        addr);
                break;
            }

            if(addr == (ULONG_PTR)tmp.Sp_queue.Next)   {
                dprintf("work queue is circular\n");
                        break;
                }
                addr = (ULONG_PTR)tmp.Sp_queue.Next;

                if (CheckControlC()) break;
            }
        }
        printf("\n");
        return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\classkd.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    classkd.h

Abstract:

    Debugger Extension header file

Author:

Environment:

Revision History:

--*/


#define BAD_VALUE  (ULONG64)-1


VOID
ClassDumpPdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    );

VOID
ClassDumpFdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    );

VOID
ClassDumpLocks(
    ULONG64 CommonExtension,
    ULONG Depth
    );

VOID
ClassDumpChildren(
    IN ULONG64 Pdo,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ClassDumpCommonExtension(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ClassDumpFdoExtensionExternal(
    IN IN ULONG64 FdoExtAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ClassDumpFdoExtensionInternal(
    IN ULONG64 FdoDataAddr,
    IN ULONG Detail,
    IN ULONG Depth
    );

BOOLEAN
ClassIsCheckedVersion(
    ULONG64 RemoveTrackingSpinlock
    );

char *DbgGetIoctlStr(ULONG ioctl);
char *DbgGetScsiOpStr(UCHAR ScsiOp);
char *DbgGetSrbStatusStr(UCHAR SrbStat);
char *DbgGetSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr);
char *DbgGetAdditionalSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr);
char *DbgGetAdditionalSenseCodeQualifierStr(UCHAR SrbStat, ULONG64 SenseDataAddr);
char *DbgGetMediaTypeStr(ULONG MediaType);
ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName);
ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName);

VOID ClassDumpTransferPacket(
    ULONG64 PktAddr, 
    BOOLEAN DumpPendingPkts, 
    BOOLEAN DumpFreePkts, 
    BOOLEAN DumpFullInfo, 
    ULONG Depth);

VOID ClassDumpTransferPacketLists(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth);
VOID ClassDumpPrivateErrorLogs(ULONG64 FdoDataAddr, ULONG Detail, ULONG Depth);


extern char *g_genericErrorHelpStr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\help.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    help.c

Abstract:

    WinDbg Extension Api for interpretting AIC78XX debugging structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

typedef struct {
        char *extname;
        char *extdesc;
} exthelp;

exthelp extensions[] =  {
        {"help",            "displays this message"},
        {"srbdata",         "dumps the specified SRB_DATA tracking block"},
        {"",                ""},
        {"The following take either the device object or device extension", ""},
        {"scsiext",         "dumps the specified scsiport extension"},
        {"classext",        "dumps the specified classpnp extension"},
        {"cdromext",        "dumps the specified cdrom extension"},
        {"diskext",         "dumps the specified disk extension"},
        {"",                ""},
        {"Commands for partition tables", ""},
        {"layout",          "dumps the drive layout at the the specified address"},
        {"layoutex",        "dumps the extended drive layout at the specified address"},
        {"part",            "dumps the partition at the specified address"},
        {"partex",          "dumps the extended partition at the specified address"},
        {NULL,          NULL}};

DECLARE_API( help )
{
        int i = 0;

        dprintf("\nSCSIPORT Debugger Extension\n");
        while(extensions[i].extname != NULL)    {
                dprintf("\t%10s - \t%s\n",
                        extensions[i].extname,
                        extensions[i].extdesc);
                i++;
        }
        dprintf("\n");
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\kdext.cpp ===
//depot/Lab01_N/drivers/storage/kdext/minipkd/kdext.cpp#1 - add change 1876 (text)
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>

WINDBG_EXTENSION_APIS  ExtensionApis;

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    IDebugControl *DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                          (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\diskkd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    diskkd.c

Abstract:

    Debugger Extension Api for interpretting cdrom structure

Author:

    Henry Gabryjelski  (henrygab) 16-Feb-1999

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#include "classpnp.h" // #defines ALLOCATE_SRB_FROM_POOL as needed
#include "classp.h"   // Classpnp's private definitions
#include "disk.h"

#include "classkd.h"  // routines that are useful for all class drivers

/*
FLAG_NAME XAFlags[] = {
    FLAG_NAME(XA_USE_6_BYTE),    // 0x01
    FLAG_NAME(XA_USE_10_BYTE),   // 0x02
    FLAG_NAME(XA_USE_READ_CD),   // 0x04
    FLAG_NAME(XA_NOT_SUPPORTED), // 0x08
    FLAG_NAME(XA_PLEXTOR_CDDA),     // 0x10
    FLAG_NAME(XA_NEC_CDDA),         // 0x20
    {0,0}
};
*/

VOID
ClassDumpDiskData(
    IN ULONG64 CdData,
    ULONG Detail,
    ULONG Depth
    );

DECLARE_API(diskext)

/*++

Routine Description:

    Dumps the cdrom specific data for a given device object or
    given device extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 address;
    ULONG result;
    ULONG detail = 0;
    BOOLEAN IsFdo;
    ULONG64 DriverData;

    ASSERTMSG("data block too small to hold CDROM_DATA\n",
              sizeof(FUNCTIONAL_DEVICE_EXTENSION) > sizeof(DISK_DATA));
    ASSERTMSG("data block too small to hold DEVICE_OBJECT\n",
              sizeof(FUNCTIONAL_DEVICE_EXTENSION) > sizeof(DEVICE_OBJECT));

    GetAddressAndDetailLevel64(args, &address, &detail);

    //
    // Convert the supplied address into a device extension if it is
    // the address of a device object.
    //
    address = GetDeviceExtension(address);
dprintf("DeviceExtension:%p\n", address);
    InitTypeRead(address, classpnp!_COMMON_DEVICE_EXTENSION);
    IsFdo = (BOOLEAN)ReadField(IsFdo);
    DriverData = ReadField(DriverData);
dprintf("DriverData:%p\n", DriverData);

    if(!IsFdo) {
        xdprintfEx(0, ("Not an FDO\n"));
        return E_FAIL;
    }

    //
    // dump the class-specific information if detail != 0
    //
    
    if (detail != 0) {
        ClassDumpCommonExtension(address,
                                 detail,
                                 0);
    }

    ClassDumpDiskData(DriverData,
                      detail,
                      0);
    return S_OK;
}


VOID
ClassDumpDiskData(
    IN ULONG64 DiskData,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;

    ULONG PartitionStyle;
    ULONG PartitionOrdinal;
    ULONG MbrSignature;
    ULONG MbrCheckSum;
    UCHAR MbrPartitionType;
    BOOLEAN MbrBootIndicator;
    ULONG MbrHiddenSectors;
    ULONG GeometrySource;
    ULONG64 RGCylinders;
    ULONG RGMediaType;
    ULONG RGTracksPerCylinder;
    ULONG RGSectorsPerTrack;
    ULONG RGBytesPerSector;
    ULONG ReadyStatus;
    ULONG FailurePredictionCapability;
    BOOLEAN AllowFPPerfHit;
    BOOLEAN LSWellKnownNameCreated;
    BOOLEAN LSPhysicalDriveLinkCreated;
    ULONG64 PartitionInterfaceStringBuffer;
    USHORT PartitionInterfaceStringLength;
    ULONG64 DiskInterfaceStringBuffer;
    USHORT DiskInterfaceStringLength;

    FIELD_INFO deviceFields[] = {
       {"PartitionStyle", NULL, 0, COPY, 0, (PVOID) &PartitionStyle},
       {"PartitionOrdinal", NULL, 0, COPY, 0, (PVOID) &PartitionOrdinal},
       {"Mbr.Signature", NULL, 0, COPY, 0, (PVOID) &MbrSignature},
       {"Mbr.MbrCheckSum", NULL, 0, COPY, 0, (PVOID) &MbrCheckSum},
       {"Mbr.PartitionType", NULL, 0, COPY, 0, (PVOID) &MbrPartitionType},
       {"Mbr.BootIndicator", NULL, 0, COPY, 0, (PVOID) &MbrBootIndicator},
       {"Mbr.HiddenSectors", NULL, 0, COPY, 0, (PVOID) &MbrHiddenSectors},
       {"GeometrySource", NULL, 0, COPY, 0, (PVOID) &GeometrySource},
       {"RealGeometry.Cylinders", NULL, 0, COPY, 0, (PVOID) &RGCylinders},
       {"RealGeometry.MediaType", NULL, 0, COPY, 0, (PVOID) &RGMediaType},
       {"RealGeometry.TracksPerCylinder", NULL, 0, COPY, 0, (PVOID) &RGTracksPerCylinder},
       {"RealGeometry.SectorsPerTrack", NULL, 0, COPY, 0, (PVOID) &RGSectorsPerTrack},
       {"RealGeometry.BytesPerSector", NULL, 0, COPY, 0, (PVOID) &RGBytesPerSector},
       {"ReadyStatus", NULL, 0, COPY, 0, (PVOID) &ReadyStatus},
       {"FailurePredictionCapability", NULL, 0, COPY, 0, (PVOID) &FailurePredictionCapability},
       {"AllowFPPerfHit", NULL, 0, COPY, 0, (PVOID) &AllowFPPerfHit},
       {"LinkStatus.WellKnownNameCreated", NULL, 0, COPY, 0, (PVOID) &LSWellKnownNameCreated},
       {"LinkStatus.PhysicalDriveLinkCreated", NULL, 0, COPY, 0, (PVOID) &LSPhysicalDriveLinkCreated},
       {"PartitionInterfaceString.Buffer", NULL, 0, COPY, 0, (PVOID) &PartitionInterfaceStringBuffer},
       {"PartitionInterfaceString.Length", NULL, 0, COPY, 0, (PVOID) &PartitionInterfaceStringLength},
       {"DiskInterfaceString.Buffer", NULL, 0, COPY, 0, (PVOID) &DiskInterfaceStringBuffer},
       {"DiskInterfaceString.Length", NULL, 0, COPY, 0, (PVOID) &DiskInterfaceStringLength},
    };

    FIELD_INFO deviceFields64[] = {
       {"PartitionStyle", NULL, 0, COPY, 0, (PVOID) &PartitionStyle},
       {"PartitionOrdinal", NULL, 0, COPY, 0, (PVOID) &PartitionOrdinal},
       {"Mbr.Signature", NULL, 0, COPY, 0, (PVOID) &MbrSignature},
       {"Mbr.MbrCheckSum", NULL, 0, COPY, 0, (PVOID) &MbrCheckSum},
       {"Mbr.PartitionType", NULL, 0, COPY, 0, (PVOID) &MbrPartitionType},
       {"Mbr.BootIndicator", NULL, 0, COPY, 0, (PVOID) &MbrBootIndicator},
       {"Mbr.HiddenSectors", NULL, 0, COPY, 0, (PVOID) &MbrHiddenSectors},
       {"ReadyStatus", NULL, 0, COPY, 0, (PVOID) &ReadyStatus},
       {"FailurePredictionCapability", NULL, 0, COPY, 0, (PVOID) &FailurePredictionCapability},
       {"AllowFPPerfHit", NULL, 0, COPY, 0, (PVOID) &AllowFPPerfHit},
       {"LinkStatus.WellKnownNameCreated", NULL, 0, COPY, 0, (PVOID) &LSWellKnownNameCreated},
       {"LinkStatus.PhysicalDriveLinkCreated", NULL, 0, COPY, 0, (PVOID) &LSPhysicalDriveLinkCreated},
       {"PartitionInterfaceString.Buffer", NULL, 0, COPY, 0, (PVOID) &PartitionInterfaceStringBuffer},
       {"PartitionInterfaceString.Length", NULL, 0, COPY, 0, (PVOID) &PartitionInterfaceStringLength},
       {"DiskInterfaceString.Buffer", NULL, 0, COPY, 0, (PVOID) &DiskInterfaceStringBuffer},
       {"DiskInterfaceString.Length", NULL, 0, COPY, 0, (PVOID) &DiskInterfaceStringLength},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "disk!_DISK_DATA", 
       DBG_DUMP_NO_PRINT, 
       DiskData,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    SYM_DUMP_PARAM DevSym64 = {
       sizeof (SYM_DUMP_PARAM), 
       "disk!_DISK_DATA", 
       DBG_DUMP_NO_PRINT, 
       DiskData,
       NULL, NULL, NULL, 
       sizeof (deviceFields64) / sizeof (FIELD_INFO), 
       &deviceFields64[0]
    };
    
    if (IsPtr64()) {
        result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym64, DevSym64.size);
    } else {
        result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    }
    
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    xdprintfEx(Depth, ("DiskData @ %p:\n", DiskData));
    Depth +=1;

    if (PartitionStyle == PARTITION_STYLE_GPT) {
        xdprintfEx (Depth, ("ERROR: GPT disks are not yet supported\n"));
        return;
    }
    
    xdprintfEx(Depth, ("Signature %x  MbrCheckSum %x\n",
               MbrSignature,
               MbrCheckSum
               ));
    xdprintfEx(Depth, ("Partition %x  Type %x  Bootable %x  HiddenSectors %x\n",
               PartitionOrdinal,
               MbrPartitionType,
               MbrBootIndicator,
               MbrHiddenSectors
               ));

    if (!IsPtr64()) {
        PUCHAR source[] = {
            "Unknown", "FromBios", "FromPort", "FromNec98",
            "GuessedFromBios", "FromDefault"
            };
        PUCHAR media[]  = {
            "Unknown",
            "5.25\"  1.20MB  512 bytes per sector",
            "3.5\"  1.44MB  512 bytes per sector",
            "3.5\"  2.88MB  512 bytes per sector",
            "3.5\"  20.8MB  512 bytes per sector",
            "3.5\"  720KB  512 bytes per sector",
            "5.25\"  360KB  512 bytes per sector",
            "5.25\"  320KB  512 bytes per sector",
            "5.25\"  320KB  1024 bytes per sector",
            "5.25\"  180KB  512 bytes per sector",
            "5.25\"  160KB  512 bytes per sector",
            "Removable media other than floppy",
            "Fixed hard disk media",
            "3.5\" 120MB Floppy",
            "3.5\"  640KB  512 bytes per sector",
            "5.25\"  640KB  512 bytes per sector",
            "5.25\"  720KB  512 bytes per sector",
            "3.5\"  1.20MB  512 bytes per sector",
            "3.5\"  1.23MB  1024 bytes per sector",
            "5.25\"  1.23MB  1024 bytes per sector",
            "3.5\" MO  128MB  512 bytes per sector",
            "3.5\" MO  230MB  512 bytes per sector",
            "8\"  256KB  128 bytes per sector"
        };

        if (RGMediaType >
            (sizeof(media)/sizeof(PUCHAR))
            ) {

            xdprintfEx(Depth, ("New Media Type: %x (?)\n",
                     RGMediaType
                     ));
            RGMediaType = 0;

        }

        xdprintfEx(Depth, ("MediaType: %s\n",
                   media[RGMediaType]
                   ));
        xdprintfEx(Depth, ("Geometry Source: %s\n",
                   source[GeometrySource]
                   ));
        xdprintfEx(Depth, ("Cylinders: %I64x  Tracks Per Cylinder %x\n",
                   RGCylinders,
                   RGTracksPerCylinder
                   ));
        xdprintfEx(Depth, ("Sectors Per Track %x  Bytes Per Sector %x\n",
                   RGSectorsPerTrack,
                   RGBytesPerSector
                   ));
    }
 
    if (!NT_SUCCESS(ReadyStatus)) {
        xdprintfEx(Depth, ("Disk is in non-ready status %x\n",
                   ReadyStatus
                   ));
    }

    //
    // print fault-predication state
    //

    {
        PUCHAR fpTypes[] = {
            "No fault prediction available",
            "IOCTL available to derive fault prediction",
            "S.M.A.R.T. available to report fault prediction",
            "Sense data available to derive fault prediction"
        };

        if (FailurePredictionCapability >
            (sizeof(fpTypes)/sizeof(PUCHAR))
            ) {
            xdprintfEx(Depth, ("Unknown fault-prediction method %x\n",
                       FailurePredictionCapability));
        } else {
            xdprintfEx(Depth, ("%s\n",
                       fpTypes[FailurePredictionCapability]
                       ));
        }

        xdprintfEx(Depth, ("Performance hit%s allowed for fault-prediction code\n",
                   (AllowFPPerfHit ? "" : " not")
                   ));
    }

    xdprintfEx(Depth, ("Well-known name was%s created\n",
               (LSWellKnownNameCreated ? "" : " not")
               ));
    xdprintfEx(Depth, ("Physical drive link was%s created\n",
               (LSPhysicalDriveLinkCreated ? "" : " not")
               ));

    {
        UNICODE_STRING string;
        WCHAR buffer[250];
        ULONG64 stringAddress;
        ULONG result;

        string.MaximumLength = 250;
        string.Buffer = buffer;

        xdprintfEx(Depth, ("Partition Name: "));
        stringAddress = PartitionInterfaceStringBuffer;
        string.Length = PartitionInterfaceStringLength;

        if (string.Length == 0) {

            dprintf("NULL\n");

        } else if (string.Length > string.MaximumLength) {

            dprintf("Too long (@ %p)\n", stringAddress);

        } else if (!ReadMemory(stringAddress,
                        (PVOID)buffer,
                        string.Length,
                        &result)) {

            dprintf("Cound not be read (@ %p)\n", stringAddress);

        } else {

            dprintf("trying\n\t\t");
            dprintf("%wZ\n", &string);

        }

        xdprintfEx(Depth, ("Partition Name: "));
        stringAddress = DiskInterfaceStringBuffer;
        string.Length = DiskInterfaceStringLength;

        if (string.Length == 0) {

            dprintf("NULL\n");

        } else if (string.Length > string.MaximumLength) {

            dprintf("Too long (@ %p)\n", stringAddress);

        } else if (!ReadMemory(stringAddress,
                        (PVOID)buffer,
                        string.Length,
                        &result)) {

            dprintf("Cound not be read (@ %p)\n", stringAddress);

        } else {

            dprintf("%wZ\n", &string);

        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\partition.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    partition.c

Abstract:

    Debugger extension for dumping partition structures:

        DRIVE_LAYOUT_INFORMATION

        DRIVE_LAYOUT_INFORMATION_EX

        PARTITION_INFORMATION

        PARTITION_INFORMATION_EX

Author:

    Matthew D Hendel (math) 19-Jan-2000

Revision History:

--*/

#include "pch.h"
#include <ntdddisk.h>



VOID
DumpPartition(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth,
    IN ULONG PartitionCount
    )

/*++

Routine Description:

    Dump a PARTITION_INFORMATION structure.

Arguments:

    Address - The address of the partition information structure to dump.

    Detail - The detail level. Currently unused.

    Depth - The depth to indent to.

    PartitionCount - The number of partitions. This is used to determine
            whether a particular partition ordinal is valid or not.

Return Value:

    None.

--*/

{
    BOOL Succ;
    ULONG Size;
    ULONG64 StartingOffset;
    ULONG64 PartitionLength;
    ULONG PartitionNumber;
    UCHAR PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;

    InitTypeRead(Address, nt!PARTITION_INFORMATION);
    StartingOffset = ReadField(StartingOffset.QuadPart);
    PartitionLength = ReadField(PartitionLength.QuadPart);
    PartitionType = (UCHAR) ReadField(PartitionType);
    BootIndicator = (BOOLEAN) ReadField(BootIndicator);
    RecognizedPartition = (BOOLEAN) ReadField(RecognizedPartition);
    RewritePartition = (BOOLEAN) ReadField(RewritePartition);
    PartitionNumber = (ULONG) ReadField(PartitionNumber);
    
    //
    // Sanity check the data.
    //
    
    if ( (BootIndicator != TRUE && BootIndicator != FALSE) ||
         (RecognizedPartition != TRUE && RecognizedPartition != FALSE) ||
         (RewritePartition != TRUE && RewritePartition != FALSE) ) {

        xdprintfEx (Depth, ("Invalid partition information at %p\n", Address));
    }

    if (PartitionNumber > PartitionCount) {
        PartitionNumber = (ULONG)-1;
    }
    
    xdprintfEx (Depth, ("[%-2d] %-16I64x %-16I64x %2.2x   %c  %c  %c\n",
                PartitionNumber,
                StartingOffset,
                PartitionLength,
                PartitionType,
                BootIndicator ? 'x' : ' ',
                RecognizedPartition ? 'x' : ' ',
                RewritePartition ? 'x' : ' '
                ));
}

VOID
DumpDriveLayout(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    BOOL Succ;
    ULONG Size;
    ULONG i;
    ULONG64 PartAddress;
    ULONG result;
    ULONG offset;
    ULONG PartitionCount;
    ULONG Signature;
    ULONG OffsetOfFirstPartitionInfo;
    ULONG SizeOfPartitionInfo;

    InitTypeRead(Address, nt!_DRIVE_LAYOUT_INFORMATION);
    PartitionCount = (ULONG) ReadField(PartitionCount);
    Signature = (ULONG) ReadField(Signature);

    xdprintfEx (Depth, ("\nDRIVE_LAYOUT %p\n", Address));

    //
    // Warn if the partition count is not a factor of 4. This is probably a
    // bad partition information structure, but we'll continue on anyway.
    //
    
    if (PartitionCount % 4 != 0) {
        xdprintfEx (Depth, ("WARNING: Partition count should be a factor of 4.\n"));
    }

    xdprintfEx (Depth, ("PartitionCount: %d\n", PartitionCount));
    xdprintfEx (Depth, ("Signature: %8.8x\n\n", Signature));
    xdprintfEx (Depth+1, (" ORD Offset           Length           Type BI RP RW\n"));
    xdprintfEx (Depth+1, ("------------------------------------------------------------\n"));
    
    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION",
                            "PartitionEntry[0]",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    OffsetOfFirstPartitionInfo = offset;

    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION",
                            "PartitionEntry[1]",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    SizeOfPartitionInfo = offset - OffsetOfFirstPartitionInfo;
    
    PartAddress = Address + OffsetOfFirstPartitionInfo;
    for (i = 0; i < PartitionCount; i++) {

        if (CheckControlC()) {
            return;
        }
        
        DumpPartition(PartAddress, Detail, Depth+1, PartitionCount);
        PartAddress += SizeOfPartitionInfo;
    }
}


VOID
DumpPartitionEx(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth,
    IN ULONG PartitionCount
    )

/*++

Routine Description:

    Dump a PARTITION_INFORMATION_EX structure.

Arguments:

    Address - The address of the partition information structure to dump.

    Detail - The detail level. Currently unused.

    Depth - The depth to indent to.

    PartitionCount - The number of partitions. This is used to determine
            whether a particular partition ordinal is valid or not.

Return Value:

    None.

--*/
{
    BOOL Succ;
    ULONG Size;
    ULONG result;
    ULONG offset;
    ULONG PartitionStyle;
    ULONG PartitionNumber;
    ULONG64 StartingOffset;
    ULONG64 PartitionLength;
    BOOLEAN RewritePartition;
    UCHAR MbrPartitionType; 
    BOOLEAN MbrBootIndicator;
    BOOLEAN MbrRecognizedPartition;
    ULONG64 GptAttributes;
    GUID GptPartitionType;
    GUID GptPartitionId;
    ULONG64 AddrOfGuid;
    WCHAR GptName[36];

    InitTypeRead (Address, nt!_PARTITION_INFORMATION_EX);
    PartitionStyle = (ULONG) ReadField(PartitionStyle);

    if (PartitionStyle != PARTITION_STYLE_MBR &&
        PartitionStyle != PARTITION_STYLE_GPT) {

        SCSIKD_PRINT_ERROR(0);
        return;
    }

    PartitionNumber = (ULONG) ReadField(PartitionNumber);
    StartingOffset = ReadField(StartingOffset.QuadPart);
    PartitionLength = ReadField(PartitionLength.QuadPart);
    RewritePartition = (BOOLEAN) ReadField(RewritePartition);

    //
    // We use -1 to denote an invalid partition ordinal.
    //
    
    if (PartitionNumber >= PartitionCount) {
        PartitionNumber = (ULONG)-1;
    }
        
    InitTypeRead (Address, nt!_PARTITION_INFORMATION_EX);
    
    if (PartitionStyle == PARTITION_STYLE_MBR) {

        MbrPartitionType = (UCHAR) ReadField(Mbr.PartitionType);
        MbrBootIndicator = (BOOLEAN) ReadField(Mbr.BootIndicator);
        MbrRecognizedPartition = (BOOLEAN) ReadField(Mbr.RecognizedPartition);

        xdprintfEx (Depth, ("[%-2d] %-16I64x %-16I64x %2.2x   %c  %c  %c\n",
                    PartitionNumber,
                    StartingOffset,
                    PartitionLength,
                    MbrPartitionType,
                    MbrBootIndicator ? 'x' : ' ',
                    MbrRecognizedPartition ? 'x' : ' ',
                    RewritePartition ? 'x' : ' '
                    ));
    } else {

        GptAttributes = ReadField(Gpt.Attributes);

        result = GetFieldOffset("nt!_PARTITION_INFORMATION_EX",
                                "Gpt.PartitionType",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }

        AddrOfGuid = Address + offset;

        Succ = ReadMemory (
                    AddrOfGuid,
                    &GptPartitionType,
                    sizeof (GUID),
                    &Size
                    );

        if (!Succ || Size != sizeof (GUID)) {
            SCSIKD_PRINT_ERROR(0);
            return;
        }

        //
        // PartitionId immediately follows the PartitionType.  So all we have to do
        // is add sizeof(GUID) to the address and read PartitionId.
        //

        AddrOfGuid += sizeof(GUID);

        Succ = ReadMemory (
                    AddrOfGuid,
                    &GptPartitionId,
                    sizeof (GUID),
                    &Size
                    );

        if (!Succ || Size != sizeof (GUID)) {
            SCSIKD_PRINT_ERROR(0);
            return;
        }

        //
        // Read in the Gpt.Name.
        //

        result = GetFieldOffset("nt!_PARTITION_INFORMATION_EX",
                                "Gpt.Name",
                                &offset);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return;
        }

        Succ = ReadMemory (
                    Address + offset,
                    &GptName,
                    sizeof (WCHAR) * 36,
                    &Size
                    );

        if (!Succ || Size != sizeof (GUID)) {
            SCSIKD_PRINT_ERROR(0);
            return;
        }

        xdprintfEx (Depth, ("[%-2d] %S\n",
                    PartitionNumber, GptName));
        xdprintfEx (Depth, ("OFF %-16I64x LEN %-16I64x ATTR %-16I64x R/W %c\n",
                    StartingOffset,
                    PartitionLength,
                    GptAttributes,
                    RewritePartition ? 'T' : 'F'));
        xdprintfEx (Depth, ("TYPE %s\n",
                    GuidToString (&GptPartitionType)));
        xdprintfEx (Depth, ("ID %s\n",
                    GuidToString (&GptPartitionId)));
        xdprintfEx (Depth, ("\n"));
    }
}

VOID
DumpDriveLayoutEx(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    BOOL Succ;
    ULONG Size;
    ULONG i;
    ULONG offset;
    ULONG64 AddrOfDiskId;
    ULONG PartitionStyle;
    ULONG PartitionCount;
    ULONG MbrSignature;
    GUID    GptDiskId;
    ULONG64 GptStartingUsableOffset;
    ULONG64 GptUsableLength;
    ULONG   GptMaxPartitionCount;
    ULONG SizeOfPartitionEntry;
    ULONG OffsetOfFirstPartitionEntry;

    InitTypeRead(Address, nt!_DRIVE_LAYOUT_INFORMATION_EX);
    PartitionStyle = (ULONG)ReadField(PartitionStyle);
    PartitionCount = (ULONG)ReadField(PartitionCount);
    MbrSignature = (ULONG)ReadField(Mbr.Signature);
    GptStartingUsableOffset = ReadField(Gpt.StartingUsableOffset.QuadPart);
    GptUsableLength = ReadField(Gpt.UsableLength.QuadPart);
    GptMaxPartitionCount = (ULONG)ReadField(Gpt.MaxPartitionCount);

    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION_EX",
                            "Gpt.DiskId",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    AddrOfDiskId = Address + offset;
    Succ = ReadMemory(
                AddrOfDiskId,
                &GptDiskId,
                sizeof(GUID),
                &Size);
    if (!Succ || Size != sizeof(GUID)) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    xdprintfEx (Depth, ("\nDRIVE_LAYOUT_EX %p\n", Address));

    if (PartitionStyle != PARTITION_STYLE_MBR &&
        PartitionStyle != PARTITION_STYLE_GPT) {

        xdprintfEx (Depth, ("ERROR: invalid partition style %d\n", PartitionStyle));
        return;
    }

    if (PartitionStyle == PARTITION_STYLE_MBR &&
        PartitionCount % 4 != 0) {

        xdprintfEx (Depth, ("WARNING: Partition count is not a factor of 4, (%d)\n",
                    PartitionCount));
    }

    if (PartitionStyle == PARTITION_STYLE_MBR) {

        xdprintfEx (Depth, ("Signature: %8.8x\n", MbrSignature));
        xdprintfEx (Depth, ("PartitionCount %d\n\n", PartitionCount));

        xdprintfEx (Depth+1, (" ORD Offset           Length           Type BI RP RW\n"));
        xdprintfEx (Depth+1, ("------------------------------------------------------------\n"));

    } else {

        xdprintfEx (Depth, ("DiskId: %s\n", GuidToString (&GptDiskId)));
        xdprintfEx (Depth, ("StartingUsableOffset: %I64x\n", GptStartingUsableOffset));
        xdprintfEx (Depth, ("UsableLength:  %I64x\n", GptUsableLength));
        xdprintfEx (Depth, ("MaxPartitionCount: %d\n", GptMaxPartitionCount));
        xdprintfEx (Depth, ("PartitionCount %d\n\n", PartitionCount));
    }

    
    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION_EX",
                            "PartitionEntry[i]",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    OffsetOfFirstPartitionEntry = offset;
    Address += offset;

    result = GetFieldOffset("nt!_DRIVE_LAYOUT_INFORMATION_EX",
                            "PartitionEntry[1]",
                            &offset);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    SizeOfPartitionEntry = offset - OffsetOfFirstPartitionEntry;

    for (i = 0; i < PartitionCount; i++) {

        if (CheckControlC()) {
            return;
        }
        
        DumpPartitionEx(Address, Detail, Depth+1, PartitionCount);

        Address += SizeOfPartitionEntry;
    }
}



DECLARE_API (layout)

/*++

Routine Description:

    Dump a DRIVE_LAYOUT structure with all it's partitions.

Arguments:

    args - A string containing the address of the DRIVE_LAYOUT structure to
           be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address;
    ULONG Detail = 0;
    
    GetAddressAndDetailLevel64 (args, &Address, &Detail);
    DumpDriveLayout (Address, Detail, 0);

    return S_OK;
}

DECLARE_API (layoutex)


/*++

Routine Description:

    Dump a DRIVE_LAYOUT_EX structure and it's partitions.

Usage:

    layoutex <address>

Arguments:

    args - A string containing the address of the DRIVE_LAYOUT_EX structure
           to be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address;
    ULONG Detail = 0;

    GetAddressAndDetailLevel64 (args, &Address, &Detail);
    DumpDriveLayoutEx (Address, Detail, 0);

    return S_OK;
}


DECLARE_API (part)

/*++

Routine Description:

    Dump a PARTITION_INFORMATION structure.

Usage:

    part <address>
    
Arguments:

    args - A string containing the address of the PARTITION_INFORMATION
           structure to be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address;
    ULONG Detail = 0;

    GetAddressAndDetailLevel64 (args, &Address, &Detail);
    DumpPartition (Address, Detail, 0, 0);

    return S_OK;
}

DECLARE_API (partex)


/*++

Routine Description:

    Dump a PARTITION_INFORMATION_EX structure.

Usage:

    partex <address>

Arguments:

    args - A string containing the address of the PARTITION_INFORMATION_EX
           structure to be dumped.

Return Value:

    None.

--*/

{
    ULONG64 Address;
    ULONG Detail = 0;

    GetAddressAndDetailLevel64 (args, &Address, &Detail);
    DumpPartitionEx (Address, Detail, 0, 0);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <scsi.h>
#include <srb.h>


#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#define EXIT_API     ExtRelease

extern WINDBG_EXTENSION_APIS ExtensionApis;

#define SCSIKD_PRINT_ERROR(r)\
    dprintf("scsikd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);


#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

//#define KDBG_EXT

#include "wmistr.h"

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddressAndDetailLevel64(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64   Address
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG64 Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

ULONG64
GetDeviceExtension(
    ULONG64 address
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\stor\kdext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"


//
// globals
//

WINDBG_EXTENSION_APIS  ExtensionApis;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}



extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\scsikd.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    scsikd.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

    John Strange (johnstra) 17-Apr-2000 : make 64b friendly

--*/

#include "pch.h"

#include "port.h"

FLAG_NAME LuFlags[] = {
    FLAG_NAME(LU_QUEUE_FROZEN),             // 0001
    FLAG_NAME(LU_LOGICAL_UNIT_IS_ACTIVE),   // 0002
    FLAG_NAME(LU_NEED_REQUEST_SENSE),       // 0004
    FLAG_NAME(LU_LOGICAL_UNIT_IS_BUSY),     // 0008
    FLAG_NAME(LU_QUEUE_IS_FULL),            // 0010
    FLAG_NAME(LU_PENDING_LU_REQUEST),       // 0020
    FLAG_NAME(LU_QUEUE_LOCKED),             // 0040
    FLAG_NAME(LU_QUEUE_PAUSED),             // 0080
    {0,0}
};

FLAG_NAME AdapterFlags[] = {
    FLAG_NAME(PD_DEVICE_IS_BUSY),            // 0X00001
    FLAG_NAME(PD_NOTIFICATION_REQUIRED),     // 0X00004
    FLAG_NAME(PD_READY_FOR_NEXT_REQUEST),    // 0X00008
    FLAG_NAME(PD_FLUSH_ADAPTER_BUFFERS),     // 0X00010
    FLAG_NAME(PD_MAP_TRANSFER),              // 0X00020
    FLAG_NAME(PD_LOG_ERROR),                 // 0X00040
    FLAG_NAME(PD_RESET_HOLD),                // 0X00080
    FLAG_NAME(PD_HELD_REQUEST),              // 0X00100
    FLAG_NAME(PD_RESET_REPORTED),            // 0X00200
    FLAG_NAME(PD_PENDING_DEVICE_REQUEST),    // 0X00800
    FLAG_NAME(PD_DISCONNECT_RUNNING),        // 0X01000
    FLAG_NAME(PD_DISABLE_CALL_REQUEST),      // 0X02000
    FLAG_NAME(PD_DISABLE_INTERRUPTS),        // 0X04000
    FLAG_NAME(PD_ENABLE_CALL_REQUEST),       // 0X08000
    FLAG_NAME(PD_TIMER_CALL_REQUEST),        // 0X10000
    FLAG_NAME(PD_WMI_REQUEST),               // 0X20000
    {0,0}
};

VOID
ScsiDumpPdo(
    IN ULONG64 LunAddress,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ScsiDumpFdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    );

VOID
ScsiDumpSrbData(
    ULONG64 SrbData,
    ULONG Depth
    );
VOID
ScsiDumpAdapterPerfCounters(
    ULONG64 Adapter,
    ULONG Depth
    );

VOID
ScsiDumpScatterGatherList(
    ULONG64 List,
    ULONG Entries,
    ULONG Depth
    );

VOID
ScsiDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    );

VOID
ScsiDumpScsiportExtension(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ScsiDumpInterruptData(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    );

VOID
ScsiDumpChildren(
    IN ULONG64 Adapter,
    IN ULONG Depth
    );

PUCHAR 
SecondsToString(
    ULONG Count
    );

VOID
ScsiDumpLocks(
    ULONG64 CommonExtension,
    ULONG Depth
    );

VOID
ScsiDumpQueuedRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    );

DECLARE_API(scsiext)

/*++

Routine Description:

    Dumps the device extension for a given device object, or dumps the
    given device extension

Arguments:

    args - string containing the address of the device object or device
           extension

Return Value:

    none

--*/

{
    ULONG64 address;
    ULONG result;
    ULONG detail = 0;
    CSHORT Type;

    //
    // Parse the argument string for the address to dump and for any additional
    // details the caller wishes to have dumped.
    //

    GetAddressAndDetailLevel64(args, &address, &detail);

    //
    // The supplied address may be either the address of a device object or the
    // address of a device extension.  To distinguish which, we treat the 
    // address as a device object and read what would be its type field.  If
    // the 
    //

    result = GetFieldData(address,
                          "scsiport!_DEVICE_OBJECT",
                          "Type",
                          sizeof(CSHORT),
                          &Type
                          );
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return E_FAIL;
    }
    
    //
    // See if the supplied address holds a device object.  If it does, read the
    // address of the device extension.  Otherwise, we assume the supplied
    // addres holds a device extension and we use it directly.
    //

    if (Type == IO_TYPE_DEVICE) {

        result = GetFieldData(address,
                              "scsiport!_DEVICE_OBJECT",
                              "DeviceExtension",
                              sizeof(ULONG64),
                              &address
                              );
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return E_FAIL;
        }
    }

    //
    // Call worker routine to dump the information.
    //

    ScsiDumpScsiportExtension(address, detail, 0);

    return S_OK;
}


VOID
ScsiDumpScsiportExtension(
    IN ULONG64 CommonExtension,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG tmp;
    ULONG result;

    ULONG64 DeviceObject = 0;
    ULONG IsPdo = 0;
    ULONG IsInitialized = 0;
    ULONG WmiInitialized = 0;
    ULONG WmiMiniPortSupport = 0;
    ULONG CurrentPnpState = 0;    
    ULONG PreviousPnpState = 0;
    ULONG IsRemoved = 0;
    ULONG64 LowerDeviceObject = 0;
    ULONG SrbFlags = 0;
    ULONG64 MajorFunction = 0;
    SYSTEM_POWER_STATE CurrentSystemState = 0;
    DEVICE_POWER_STATE CurrentDeviceState = 0;
    DEVICE_POWER_STATE DesiredDeviceState = 0;
    ULONG64 IdleTimer = 0;
    ULONG64 WmiScsiPortRegInfoBuf = 0;
    ULONG WmiScsiPortRegInfoBufSize = 0;   
    ULONG PagingPathCount = 0;
    ULONG HibernatePathCount = 0;
    ULONG DumpPathCount = 0;
    
    FIELD_INFO deviceFields[] = {
       {"DeviceObject", NULL, 0, COPY, 0, (PVOID) &DeviceObject},
       {"IsPdo", NULL, 0, COPY, 0, (PVOID) &IsPdo},
       {"IsInitialized", NULL, 0, COPY, 0, (PVOID) &IsInitialized},
       {"WmiInitialized", NULL, 0, COPY, 0, (PVOID) &WmiInitialized},
       {"WmiMiniPortSupport", NULL, 0, COPY, 0, (PVOID) &WmiMiniPortSupport},
       {"CurrentPnpState", NULL, 0, COPY, 0, (PVOID) &CurrentPnpState},
       {"PreviousPnpState", NULL, 0, COPY, 0, (PVOID) &PreviousPnpState},
       {"IsRemoved", NULL, 0, COPY, 0, (PVOID) &IsRemoved},
       {"LowerDeviceObject", NULL, 0, COPY, 0, (PVOID) &LowerDeviceObject},
       {"SrbFlags", NULL, 0, COPY, 0, (PVOID) &SrbFlags},
       {"MajorFunction", NULL, 0, COPY, 0, (PVOID) &MajorFunction},
       {"CurrentSystemState", NULL, 0, COPY, 0, (PVOID) &CurrentSystemState},
       {"CurrentDeviceState", NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState},
       {"DesiredDeviceState", NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState},
       {"IdleTimer", NULL, 0, COPY, 0, (PVOID) &IdleTimer},
       {"WmiScsiPortRegInfoBuf", NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBuf},
       {"WmiScsiPortRegInfoBufSize", NULL, 0, COPY, 0, (PVOID) &WmiScsiPortRegInfoBufSize},
       {"PagingPathCount", NULL, 0, COPY, 0, (PVOID) &PagingPathCount},
       {"HibernatePathCount", NULL, 0, COPY, 0, (PVOID) &HibernatePathCount},
       {"DumpPathCount", NULL, 0, COPY, 0, (PVOID) &DumpPathCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_COMMON_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       CommonExtension,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        dprintf("%08p: Could not read device object\n", CommonExtension);
        return;
    }
    
    xdprintfEx(Depth, ("Scsiport %s device extension at address %p\n",
               IsPdo ? "physical" : "functional", CommonExtension));

    xdprintfEx(Depth, ("Common Extension:\n"));

    Depth += 1;

    tmp = Depth;

    if(IsInitialized) {
        xdprintfEx(tmp, ("Initialized "));
        tmp = 0;
    }

    if(IsRemoved) {
        xdprintfEx(tmp, ("Removed " ));
        tmp = 0;
    }

    switch(IsRemoved) {
        case REMOVE_PENDING: {
            xdprintfEx(tmp, ("RemovePending"));
            tmp = 0;
            break;
        }

        case REMOVE_COMPLETE: {
            xdprintfEx(tmp, ("RemoveComplete"));
            tmp = 0;
            break;
        }
    }

    if(WmiMiniPortSupport) {
        if(WmiInitialized) {
            xdprintfEx(tmp, ("WmiInit"));
        } else {
            xdprintfEx(tmp, ("Wmi"));
        }
        tmp = 0;
    }

    if(tmp == 0) {
        dprintf("\n");
    }

    tmp = 0;

    xdprintfEx(Depth, ("DO 0x%08p  LowerObject 0x%08p  SRB Flags %#08lx\n",
               DeviceObject,
               LowerDeviceObject,
               SrbFlags));

    xdprintfEx(Depth, ("Current Power (D%d,S%d)  Desired Power D%d Idle %#08lx\n",
               CurrentDeviceState - 1,
               CurrentSystemState - 1,
               DesiredDeviceState - 1,
               IdleTimer));

    xdprintfEx(Depth, ("Current PnP state 0x%x    Previous state 0x%x\n",
               CurrentPnpState,
               PreviousPnpState));

    xdprintfEx(Depth, ("DispatchTable %08p   UsePathCounts (P%d, H%d, C%d)\n",
               MajorFunction,
               PagingPathCount,
               HibernatePathCount,
               DumpPathCount));

    if(WmiMiniPortSupport) {
        xdprintfEx(Depth, ("DispatchTable 0x%08p   WmiInfoSize %#08lx\n",
                   WmiScsiPortRegInfoBuf,
                   WmiScsiPortRegInfoBufSize));
    }

    if(IsPdo) {
        xdprintfEx(Depth - 1, ("Logical Unit Extension:\n"));
        ScsiDumpPdo(CommonExtension, Detail, Depth);
    } else {
        xdprintfEx(Depth - 1, ("Adapter Extension:\n"));
        ScsiDumpFdo(CommonExtension, Detail, Depth);
    }

    if(Detail > 1) {
        ScsiDumpLocks(CommonExtension, Depth - 1);
    }

    return;
}

VOID
ScsiDumpFdo(
    ULONG64 Address,
    ULONG Detail,
    ULONG Depth
    )
{
    ULONG tmp = Depth;
    ULONG result;
    ULONG NumOfFields;

    ULONG   PortNumber = 0;
    UCHAR   IsPnp = 0;
    UCHAR   IsMiniportDetected = 0;
    UCHAR   IsInVirtualSlot = 0;
    UCHAR   HasInterrupt = 0;
    UCHAR   DisablePower = 0;
    UCHAR   DisableStop = 0;
    ULONG64 LowerPdo = 0;
    ULONG64 HwDeviceExtension = 0;
    LONG    ActiveRequestCount = 0;
    ULONG   NumberOfBuses = 0;
    ULONG   MaximumTargetIds = 0;
    ULONG   MaxLuCount = 0;
    ULONG   Flags = 0;
    ULONG64 NonCachedExtension = 0;
    ULONG   IoAddress = 0;
    ULONG   InterruptLevel = 0;
    ULONG   RealBusNumber = 0;
    ULONG   RealSlotNumber = 0;
    LONG    PortTimeoutCounter = 0;
    ULONG   DpcFlags = 0;
    ULONG   SequenceNumber = 0;
    ULONG64 SrbExtensionListHeader = 0;
    ULONG   NumberOfRequests = 0;
    ULONG64 QueueTagBitMap = 0;
    ULONG   QueueTagHint = 0;
    ULONG   HwLogicalUnitExtensionSize = 0;
    ULONG   SrbExtensionSize = 0;
    ULONG   LargeScatterGatherListSize = 0;
    ULONG64 EmergencySrbData = 0;
    ULONG   CommonBufferSize = 0;
    ULONG64 PhysicalCommonBuffer = 0;
    ULONG64 SrbExtensionBuffer = 0;
    ULONG64 InterruptObject = 0;
    ULONG64 InterruptObject2 = 0;
    ULONG64 DmaAdapterObject = 0;
    ULONG64 AllocatedResources = 0;
    ULONG64 TranslatedResources = 0;
    ULONG64 PortConfig = 0;
    ULONG64 PortDeviceMapKey = 0;
    ULONG64 BusDeviceMapKeys = 0;
    UCHAR   RemoveTrackingLookasideListInitialized = 0;
    ULONG64 AddrOfMaxQueueTag = 0;
    ULONG64 SrbDataBlockedRequests = 0;
    ULONG64 SrbDataLookasideList = 0;
    ULONG64 MediumScatterGatherLookasideList = 0;
    ULONG64 RemoveTrackingLookasideList = 0;
    ULONG64 InterruptData = 0;
    UCHAR   MaxQueueTag = 0;
    
    FIELD_INFO deviceFields[] = {
       {"PortNumber", NULL, 0, COPY, 0, (PVOID) &PortNumber},
       {"IsPnp", NULL, 0, COPY, 0, (PVOID) &IsPnp},
       {"IsMiniportDetected", NULL, 0, COPY, 0, (PVOID) &IsMiniportDetected},
       {"IsInVirtualSlot", NULL, 0, COPY, 0, (PVOID) &IsInVirtualSlot},
       {"HasInterrupt", NULL, 0, COPY, 0, (PVOID) &HasInterrupt},
       {"DisablePower", NULL, 0, COPY, 0, (PVOID) &DisablePower},
       {"DisableStop", NULL, 0, COPY, 0, (PVOID) &DisableStop},
       {"LowerPdo", NULL, 0, COPY, 0, (PVOID) &LowerPdo},
       {"HwDeviceExtension", NULL, 0, COPY, 0, (PVOID) &HwDeviceExtension},
       {"ActiveRequestCount", NULL, 0, COPY, 0, (PVOID) &ActiveRequestCount},
       {"NumberOfBuses", NULL, 0, COPY, 0, (PVOID) &NumberOfBuses},
       {"MaximumTargetIds", NULL, 0, COPY, 0, (PVOID) &MaximumTargetIds},
       {"MaxLuCount", NULL, 0, COPY, 0, (PVOID) &MaxLuCount},
       {"Flags", NULL, 0, COPY, 0, (PVOID) &Flags},
       {"NonCachedExtension", NULL, 0, COPY, 0, (PVOID) &NonCachedExtension},
       {"IoAddress", NULL, 0, COPY, 0, (PVOID) &IoAddress},
       {"InterruptLevel", NULL, 0, COPY, 0, (PVOID) &InterruptLevel},
       {"RealBusNumber", NULL, 0, COPY, 0, (PVOID) &RealBusNumber},
       {"RealSlotNumber", NULL, 0, COPY, 0, (PVOID) &RealSlotNumber},
       {"PortTimeoutCounter", NULL, 0, COPY, 0, (PVOID) &PortTimeoutCounter},
       {"DpcFlags", NULL, 0, COPY, 0, (PVOID) &DpcFlags},
       {"SequenceNumber", NULL, 0, COPY, 0, (PVOID) &SequenceNumber},
       {"SrbExtensionListHeader", NULL, 0, COPY, 0, (PVOID) &SrbExtensionListHeader},
       {"NumberOfRequests", NULL, 0, COPY, 0, (PVOID) &NumberOfRequests},
       {"QueueTagBitMap", NULL, 0, COPY, 0, (PVOID) &QueueTagBitMap},
       {"QueueTagHint", NULL, 0, COPY, 0, (PVOID) &QueueTagHint},
       {"HwLogicalUnitExtensionSize", NULL, 0, COPY, 0, (PVOID) &HwLogicalUnitExtensionSize},
       {"SrbExtensionSize", NULL, 0, COPY, 0, (PVOID) &SrbExtensionSize},
       {"LargeScatterGatherListSize", NULL, 0, COPY, 0, (PVOID) &LargeScatterGatherListSize},
       {"EmergencySrbData", NULL, 0, COPY, 0, (PVOID) &EmergencySrbData},
       {"CommonBufferSize", NULL, 0, COPY, 0, (PVOID) &CommonBufferSize},
       {"PhysicalCommonBuffer.QuadPart", NULL, 0, COPY, 0, (PVOID) &PhysicalCommonBuffer},
       {"SrbExtensionBuffer", NULL, 0, COPY, 0, (PVOID) &SrbExtensionBuffer},
       {"InterruptObject", NULL, 0, COPY, 0, (PVOID) &InterruptObject},
       {"InterruptObject2", NULL, 0, COPY, 0, (PVOID) &InterruptObject2},
       {"DmaAdapterObject", NULL, 0, COPY, 0, (PVOID) &DmaAdapterObject},
       {"AllocatedResources", NULL, 0, COPY, 0, (PVOID) &AllocatedResources},
       {"TranslatedResources", NULL, 0, COPY, 0, (PVOID) &TranslatedResources},
       {"PortConfig", NULL, 0, COPY, 0, (PVOID) &PortConfig},
       {"PortDeviceMapKey", NULL, 0, COPY, 0, (PVOID) &PortDeviceMapKey},
       {"BusDeviceMapKeys", NULL, 0, COPY, 0, (PVOID) &BusDeviceMapKeys},
       {"CommonExtension.RemoveTrackingLookasideListInitialized", NULL, 0, COPY, 0, (PVOID) &RemoveTrackingLookasideListInitialized},
       {"MaxQueueTag", NULL, 0, ADDROF, 0, NULL},
       {"SrbDataBlockedRequests", NULL, 0, ADDROF, 0, NULL},
       {"SrbDataLookasideList", NULL, 0, ADDROF, 0, NULL},
       {"MediumScatterGatherLookasideList", NULL, 0, ADDROF, 0, NULL},
       {"CommonExtension.RemoveTrackingLookasideList", NULL, 0, ADDROF, 0, NULL},
       {"InterruptData", NULL, 0, ADDROF, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };
    
    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    result = GetFieldData(Address,
                          "scsiport!_ADAPTER_EXTENSION",
                          "MaxQueueTag",
                          sizeof(UCHAR),
                          &MaxQueueTag
                          );
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    NumOfFields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    InterruptData = deviceFields[NumOfFields-1].address;
    RemoveTrackingLookasideList = deviceFields[NumOfFields-2].address;
    MediumScatterGatherLookasideList = deviceFields[NumOfFields-3].address;
    SrbDataLookasideList = deviceFields[NumOfFields-4].address;
    SrbDataBlockedRequests = deviceFields[NumOfFields-5].address;
    AddrOfMaxQueueTag = deviceFields[NumOfFields-6].address;

    xdprintfEx(Depth, ("Port %d   ", PortNumber));

    if(IsPnp) {
        xdprintfEx(tmp, ("IsPnp "));
        tmp = 0;
    }

    if(IsMiniportDetected) {
        xdprintfEx(tmp, ("MpDetected "));
        tmp = 0;
    }

    if(IsInVirtualSlot) {
        xdprintfEx(tmp, ("VirtualSlot "));
        tmp = 0;
    }

    if(HasInterrupt) {
        xdprintfEx(tmp, ("HasInterrupt"));
        tmp = 0;
    }

    if(DisablePower) {
        xdprintfEx(tmp, ("NoPower"));
        tmp = 0;
    }

    if(DisableStop) {
        xdprintfEx(tmp, ("NoStop"));
        tmp = 0;
    }

    dprintf("\n");

    xdprintfEx(Depth, ("LowerPdo 0x%08p   HwDevExt 0x%08p   Active Requests 0x%08lx\n",
               LowerPdo,
               HwDeviceExtension,
               ActiveRequestCount));

    xdprintfEx(Depth, ("MaxBus 0x%02x   MaxTarget 0x%02x   MaxLun 0x%02x\n",
               NumberOfBuses,
               MaximumTargetIds,
               MaxLuCount));

    DumpFlags(Depth, "Port Flags", Flags, AdapterFlags);

    xdprintfEx(Depth, ("NonCacheExt 0x%08p  IoBase 0x%08x   Int 0x%02x\n",
               NonCachedExtension,
               IoAddress,
               InterruptLevel));

    xdprintfEx(Depth, ("RealBus# 0x%0x  RealSlot# 0x%0x\n",
               RealBusNumber,
               RealSlotNumber));

    xdprintfEx(Depth, ("Timeout 0x%08x   DpcFlags 0x%08x   Sequence 0x%08x\n",
               PortTimeoutCounter,
               DpcFlags,
               SequenceNumber));

    xdprintfEx(Depth, ("Srb Ext Header 0x%08p   No. Requests 0x%08lx\n",
               SrbExtensionListHeader, NumberOfRequests));

    xdprintfEx(Depth, ("QueueTag BitMap 0x%08p   Hint 0x%08lx\n",
               QueueTagBitMap, QueueTagHint));

    xdprintfEx(Depth, ("MaxQueueTag 0x%2x (@0x%08p)\n",
               MaxQueueTag, AddrOfMaxQueueTag));

    xdprintfEx(Depth, ("LuExt Size 0x%08lx   SrbExt Size 0x%08lx\n",
               HwLogicalUnitExtensionSize,
               SrbExtensionSize));

    xdprintfEx(Depth + 1, ("SG List Size - Small %d   Large %d\n",
               SP_SMALL_PHYSICAL_BREAK_VALUE,
               LargeScatterGatherListSize));

    Depth++;

    xdprintfEx(Depth, ("Emergency  - SrbData 0x%08p  Blocked List @0x%08p\n",
               EmergencySrbData,
               SrbDataBlockedRequests));

    xdprintfEx(Depth, ("CommonBuff - Size: 0x%08lx    PA: 0x%016I64x  VA: 0x%08p\n",
               CommonBufferSize,
               PhysicalCommonBuffer,
               SrbExtensionBuffer));

    xdprintfEx(Depth, ("Ke Objects - Int1: 0x%08p    Int2: 0x%08p        Dma: 0x%08p\n",
               InterruptObject,
               InterruptObject2,
               DmaAdapterObject));

    xdprintfEx(Depth, ("Lookaside  - SrbData @ 0x%08p SgList @0x%08p  Remove: @0x%08p\n",
               SrbDataLookasideList,
               MediumScatterGatherLookasideList,
               (RemoveTrackingLookasideListInitialized ?
                  RemoveTrackingLookasideList : 0)));

    xdprintfEx(Depth, ("Resources  - Raw: 0x%08p     Translated: 0x%08p\n",
               AllocatedResources,
               TranslatedResources));

    xdprintfEx(Depth, ("Port Config %08p\n", PortConfig));

    xdprintfEx(Depth, ("DeviceMap Handles: Port %p    Busses %p\n",
               PortDeviceMapKey, BusDeviceMapKeys));

    Depth--;
    ScsiDumpInterruptData(InterruptData,
                          Detail,
                          Depth);

    ScsiDumpAdapterPerfCounters(Address, Depth);

    ScsiDumpChildren(Address, Depth);
    return;
}


VOID
ScsiDumpChildren(
    IN ULONG64 AdapterExtensionAddr,
    IN ULONG Depth
    )

{
    ULONG i;
    ULONG64 realLun;
    ULONG64 realLuns[8];
    ULONG64 lun;
    UCHAR   CurrentPnpState=0, PreviousPnpState=0;
    ULONG   CurrentDeviceState=0;
    ULONG   DesiredDeviceState=0, CurrentSystemState=0;
    ULONG64 DeviceObject=0, NextLogicalUnit=0;
    ULONG   result;
    UCHAR   PathId=0, TargetId=0, Lun=0;
    UCHAR   IsClaimed=0, IsMissing=0, IsEnumerated=0, IsVisible=0, IsMismatched=0;
    ULONG64 b6, b7, b8;

    InitTypeRead(AdapterExtensionAddr, scsiport!_ADAPTER_EXTENSION);
    realLuns[0] = ReadField(LogicalUnitList[0].List);
    realLuns[1] = ReadField(LogicalUnitList[1].List);
    realLuns[2] = ReadField(LogicalUnitList[2].List);
    realLuns[3] = ReadField(LogicalUnitList[3].List);
    realLuns[4] = ReadField(LogicalUnitList[4].List);
    realLuns[5] = ReadField(LogicalUnitList[5].List);
    realLuns[6] = ReadField(LogicalUnitList[6].List);
    realLuns[7] = ReadField(LogicalUnitList[7].List);

    Depth++;

    for (i = 0; i < NUMBER_LOGICAL_UNIT_BINS; i++) {

        realLun = realLuns[i];
        
        while ((realLun != 0) && (!CheckControlC())) {

            FIELD_INFO deviceFields[] = {
               {"PathId",          NULL, 0, COPY, 0, (PVOID) &PathId},
               {"TargetId",        NULL, 0, COPY, 0, (PVOID) &TargetId},
               {"IsClaimed",       NULL, 0, COPY, 0, (PVOID) &IsClaimed},
               {"IsMissing",       NULL, 0, COPY, 0, (PVOID) &IsMissing},
               {"IsEnumerated",    NULL, 0, COPY, 0, (PVOID) &IsEnumerated},
               {"IsVisible",       NULL, 0, COPY, 0, (PVOID) &IsVisible},
               {"IsMismatched",    NULL, 0, COPY, 0, (PVOID) &IsMismatched},
               {"DeviceObject",    NULL, 0, COPY, 0, (PVOID) &DeviceObject},
               {"NextLogicalUnit", NULL, 0, COPY, 0, (PVOID) &NextLogicalUnit},
               {"CommonExtension.CurrentPnpState",    NULL, 0, COPY, 0, (PVOID) &CurrentPnpState},
               {"CommonExtension.PreviousPnpState" ,  NULL, 0, COPY, 0, (PVOID) &PreviousPnpState},
               {"CommonExtension.CurrentDeviceState", NULL, 0, COPY, 0, (PVOID) &CurrentDeviceState},
               {"CommonExtension.DesiredDeviceState", NULL, 0, COPY, 0, (PVOID) &DesiredDeviceState},
               {"CommonExtension.CurrentSystemState", NULL, 0, COPY, 0, (PVOID) &CurrentSystemState},
            };
            SYM_DUMP_PARAM DevSym = {
               sizeof (SYM_DUMP_PARAM), 
               "scsiport!_LOGICAL_UNIT_EXTENSION", 
               DBG_DUMP_NO_PRINT, 
               realLun,
               NULL, NULL, NULL, 
               sizeof (deviceFields) / sizeof (FIELD_INFO), 
               &deviceFields[0]
            };
            
            xdprintfEx(Depth, ("LUN "));
            dprintf("%08p ", realLun);

            if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
                dprintf("%08lx: Could not read device object\n", realLun);
                return;
            }

            result = (ULONG) InitTypeRead(realLun, scsiport!_LOGICAL_UNIT_EXTENSION);
            if (result != 0) {
                dprintf("could not init read type (%x)\n", result);
                return;
            }
            lun = ReadField(Lun);
            Lun = (UCHAR) lun;
#if 0
            PathId = ReadField(PathId);
            TargetId = ReadField(TargetId);
            IsClaimed = ReadField(IsClaimed);
            IsMissing = ReadField(IsMissing);
            IsEnumerated = ReadField(IsEnumerated);
            IsVisible = ReadField(IsVisible);
            IsMismatched = ReadField(IsMismatched);
#endif
            dprintf("@ (%3d,%3d,%3d) %c%c%c%c%c pnp(%02x/%02x) pow(%d%c,%d) DevObj %08p\n",
                    PathId,
                    TargetId,
                    Lun,
                    (IsClaimed ? 'c' : ' '),
                    (IsMissing ? 'm' : ' '),
                    (IsEnumerated ? 'e' : ' '),
                    (IsVisible ? 'v' : ' '),
                    (IsMismatched ? 'r' : ' '),
                    CurrentPnpState,
                    PreviousPnpState,
                    CurrentDeviceState - 1,
                    ((DesiredDeviceState == PowerDeviceUnspecified) ? ' ' : '*'),
                    CurrentSystemState - 1,
                    DeviceObject);

            realLun = ReadField(NextLogicalUnit);
        }
    }

    return;
}



VOID
ScsiDumpInterruptData(
    IN ULONG64 Address,
    IN ULONG Detail,
    IN ULONG Depth
    )

{
    ULONG result;
    ULONG NumOfFields;

    //
    // Architecture independent fields declarations.
    //
    //

    ULONG   InterruptFlags;
    ULONG64 CompletedRequests;
    ULONG64 AddrOfCompletedRequests;
    ULONG64 ReadyLogicalUnit;
    ULONG64 WmiMiniPortRequests;
    
    FIELD_INFO deviceFields[] = {
       {"InterruptFlags",      NULL, 0, COPY,   0, (PVOID) &InterruptFlags},
       {"ReadyLogicalUnit",    NULL, 0, COPY,   0, (PVOID) &ReadyLogicalUnit},
       {"WmiMiniPortRequests", NULL, 0, COPY,   0, (PVOID) &WmiMiniPortRequests},
       {"CompletedRequests",   NULL, 0, ADDROF, 0, NULL},
    };
    
    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_INTERRUPT_DATA", 
       DBG_DUMP_NO_PRINT, 
       Address,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    //
    // Read in the top-level field data.  Quit on failure.
    //

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        dprintf("error reading INTERRUPT_DATA @ %08p\n", Address);
        return;
    }

    //
    // Get address-of information.
    //

    NumOfFields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    AddrOfCompletedRequests = deviceFields[NumOfFields-1].address;

    //
    // Do a separate get of the CompleteRequests field.  This is necessary
    // because the typedump Ioctl doesn't like retreiving both the addr-of
    // and the data-of a field.
    //

    result = GetFieldData(Address,
                          "scsiport!_INTERRUPT_DATA",
                          "CompletedRequests",
                          sizeof(ULONG64),
                          &CompletedRequests
                          );
    if (result) {
        dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
        return;
    }
    
    xdprintfEx(Depth, ("Interrupt Data @0x%08p:\n", Address));

    Depth++;

    DumpFlags(Depth, "Flags", InterruptFlags, AdapterFlags);

    xdprintfEx(Depth, ("Ready LUN 0x%08p   Wmi Events 0x%08p\n",
               ReadyLogicalUnit,
               WmiMiniPortRequests));

    {
        ULONG count = 0;
        ULONG64 request = CompletedRequests;

        xdprintfEx(Depth, ("Completed Request List (@0x%08p): ",
                   AddrOfCompletedRequests));

        Depth += 1;

        while((request != 0) && (!CheckControlC())) {
            ULONG64 CompletedRequests;

            if(Detail != 0) {
                if(count == 0) {
                    dprintf("\n");
                }
                xdprintfEx(Depth, ("SrbData 0x%08p   ", request));
            }

            count++;

            result = GetFieldData(request,
                                  "scsiport!_SRB_DATA",
                                  "CompletedRequests",
                                  sizeof(ULONG64),
                                  &CompletedRequests
                                  );
            if (result) {
                dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
                return;
            }

            if(Detail != 0) {
                ULONG64 CurrentSrb, CurrentIrp;
                result = GetFieldData(request,
                                      "scsiport!_SRB_DATA",
                                      "CurrentSrb",
                                      sizeof(ULONG64),
                                      &CurrentSrb
                                      );
                if (result) {
                    dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
                    return;
                }
                result = GetFieldData(request,
                                      "scsiport!_SRB_DATA",
                                      "CurrentIrp",
                                      sizeof(ULONG64),
                                      &CurrentIrp
                                      );
                if (result) {
                    dprintf("error (%08x): @ %s %d\n", result, __FILE__, __LINE__);
                    return;
                }
                dprintf("Srb 0x%08p   Irp 0x%08p\n",
                        CurrentSrb,
                        CurrentIrp);
            }

            request = CompletedRequests;
        }

        Depth -= 1;

        if((Detail == 0) || (count == 0)) {
            dprintf("%d entries\n", count);
        } else {
            xdprintfEx(Depth + 1, ("%d entries\n", count));
        }
    }

    return;
}


VOID
ScsiDumpPdo(
    IN ULONG64 LunAddress,
    IN ULONG Detail,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG Fields;

    UCHAR   PathId;
    UCHAR   TargetId;
    UCHAR   Lun;
    ULONG   PortNumber;
    UCHAR   IsClaimed;
    UCHAR   IsMissing;
    UCHAR   IsEnumerated;
    UCHAR   IsVisible;
    UCHAR   IsMismatched;
    ULONG   LunLuFlags;
    UCHAR   RetryCount;
    ULONG   CurrentKey;
    ULONG   QueueLockCount;
    ULONG   QueuePauseCount;
    ULONG64 HwLogicalUnitExtension;
    ULONG64 AdapterExtension;
    LONG    RequestTimeoutCounter;
    ULONG64 NextLogicalUnit;
    ULONG64 ReadyLogicalUnit;
    ULONG64 PendingRequest;
    ULONG64 BusyRequest;
    ULONG64 CurrentUntaggedRequest;
    ULONG64 CompletedAbort;
    ULONG64 AbortSrb;
    ULONG   QueueCount;
    ULONG   MaxQueueDepth;
    ULONG64 TargetDeviceMapKey;
    ULONG64 LunDeviceMapKey;
    ULONG64 ActiveFailedRequest;
    ULONG64 BlockedFailedRequest;
    ULONG64 RequestSenseIrp;
    ULONG64 BypassSrbDataList_Next;
    ULONG64 RequestList_Flink;
    ULONG64 CommonExtension_DeviceObject;
    ULONG64 AddrOf_InquiryData;
    ULONG64 AddrOf_RequestSenseSrb;
    ULONG64 AddrOf_RequestSenseMdl;
    ULONG64 AddrOf_BypassSrbDataBlocks;
    ULONG64 AddrOf_RequestList;

    ULONG Adapter_TickCount;

    FIELD_INFO deviceFields[] = {
       {"PathId", NULL, 0, COPY, 0, (PVOID) &PathId},
       {"TargetId", NULL, 0, COPY, 0, (PVOID) &TargetId},
       {"Lun", NULL, 0, COPY, 0, (PVOID) &Lun},
       {"PortNumber", NULL, 0, COPY, 0, (PVOID) &PortNumber},
       {"IsClaimed", NULL, 0, COPY, 0, (PVOID) &IsClaimed},
       {"IsMissing", NULL, 0, COPY, 0, (PVOID) &IsMissing},
       {"IsEnumerated", NULL, 0, COPY, 0, (PVOID) &IsEnumerated},
       {"IsVisible", NULL, 0, COPY, 0, (PVOID) &IsVisible},
       {"IsMismatched", NULL, 0, COPY, 0, (PVOID) &IsMismatched},
       {"LuFlags", NULL, 0, COPY, 0, (PVOID) &LunLuFlags},
       {"RetryCount", NULL, 0, COPY, 0, (PVOID) &RetryCount},
       {"CurrentKey", NULL, 0, COPY, 0, (PVOID) &CurrentKey},
       {"QueueCount", NULL, 0, COPY, 0, (PVOID) &QueueCount},
       {"QueueLockCount", NULL, 0, COPY, 0, (PVOID) &QueueLockCount},
       {"QueuePauseCount", NULL, 0, COPY, 0, (PVOID) &QueuePauseCount},       
       {"HwLogicalUnitExtension", NULL, 0, COPY, 0, (PVOID) &HwLogicalUnitExtension},
       {"AdapterExtension", NULL, 0, COPY, 0, (PVOID) &AdapterExtension},
       {"RequestTimeoutCounter", NULL, 0, COPY, 0, (PVOID) &RequestTimeoutCounter},
       {"NextLogicalUnit", NULL, 0, COPY, 0, (PVOID) &NextLogicalUnit},
       {"ReadyLogicalUnit", NULL, 0, COPY, 0, (PVOID) &ReadyLogicalUnit},
       {"PendingRequest", NULL, 0, COPY, 0, (PVOID) &PendingRequest},       
       {"BusyRequest", NULL, 0, COPY, 0, (PVOID) &BusyRequest},
       {"CurrentUntaggedRequest", NULL, 0, COPY, 0, (PVOID) &CurrentUntaggedRequest},
       {"CompletedAbort", NULL, 0, COPY, 0, (PVOID) &CompletedAbort},    
       {"AbortSrb", NULL, 0, COPY, 0, (PVOID) &AbortSrb},
       {"MaxQueueDepth", NULL, 0, COPY, 0, (PVOID) &MaxQueueDepth},
       {"TargetDeviceMapKey", NULL, 0, COPY, 0, (PVOID) &TargetDeviceMapKey},
       {"LunDeviceMapKey", NULL, 0, COPY, 0, (PVOID) &LunDeviceMapKey},
       {"ActiveFailedRequest", NULL, 0, COPY, 0, (PVOID) &ActiveFailedRequest},
       {"BlockedFailedRequest", NULL, 0, COPY, 0, (PVOID) &BlockedFailedRequest},
       {"RequestSenseIrp", NULL, 0, COPY, 0, (PVOID) &RequestSenseIrp},
       {"BypassSrbDataList.Next", NULL, 0, COPY, 0, (PVOID) &BypassSrbDataList_Next},
       {"InquiryData", NULL, 0, ADDROF, 0, NULL},
       {"RequestSenseSrb", NULL, 0, ADDROF, 0, NULL},
       {"RequestSenseMdl", NULL, 0, ADDROF, 0, NULL},
       {"BypassSrbDataBlocks", NULL, 0, ADDROF, 0, NULL},
       {"RequestList", NULL, 0, ADDROF, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_LOGICAL_UNIT_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       LunAddress,
       NULL, NULL, NULL,
       sizeof (deviceFields) / sizeof (FIELD_INFO),
       &deviceFields[0]
    };

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        dprintf("%08p: Could not read _LOGICAL_UNIT_EXTENSION\n", LunAddress);
        return;
    }

    Fields = sizeof (deviceFields) / sizeof (FIELD_INFO);
    AddrOf_RequestList = deviceFields[Fields-1].address;
    AddrOf_BypassSrbDataBlocks = deviceFields[Fields-2].address;
    AddrOf_RequestSenseMdl = deviceFields[Fields-3].address;
    AddrOf_RequestSenseSrb = deviceFields[Fields-4].address;
    AddrOf_InquiryData = deviceFields[Fields-5].address;

    result = GetFieldData(AddrOf_RequestList,
                          "scsiport!LIST_ENTRY",
                          "Flink",
                          sizeof(ULONG64),
                          &RequestList_Flink);
    if (result) {
        dprintf("Error reading request list from adapter extension @%p\n", AdapterExtension);
        return;
    }

    result = GetFieldData(AdapterExtension,
                          "scsiport!_ADAPTER_EXTENSION",
                          "TickCount",
                          sizeof(ULONG),
                          &Adapter_TickCount);
    if (result) {
        dprintf("Error reading TickCount from adapter extension @%p\n", AdapterExtension);
        return;
    }

    InitTypeRead(LunAddress, scsiport!_LOGICAL_UNIT_EXTENSION);
    QueueCount = (ULONG)ReadField(QueueCount);

    xdprintfEx(Depth, ("Address (%d, %d, %d, %d) %s %s %s %s %s\n",
               PortNumber, PathId, TargetId, Lun,
               (IsClaimed ? "Claimed" : ""),
               (IsMissing ? "Missing" : ""),
               (IsEnumerated ? "Enumerated" : ""),
               (IsVisible ? "Visible" : ""),
               (IsMismatched ? "Mismatched" : "")));

    //
    // Print out the various LU flags
    //

    DumpFlags(Depth, "LuFlags", LunLuFlags, LuFlags);

    xdprintfEx(Depth, ("Retry 0x%02x          Key 0x%08lx\n",
               RetryCount, CurrentKey));

    xdprintfEx(Depth, ("Lock 0x%08lx  Pause 0x%08lx   CurrentLock: 0x%p\n",
               QueueLockCount, QueuePauseCount, NULL));

    xdprintfEx(Depth, ("HwLuExt 0x%08p  Adapter 0x%08p  Timeout 0x%08x\n",
               HwLogicalUnitExtension, AdapterExtension,
               RequestTimeoutCounter));

    xdprintfEx(Depth, ("NextLun 0x%p  ReadyLun 0x%p\n",
               NextLogicalUnit, ReadyLogicalUnit));

    xdprintfEx(Depth, ("Pending 0x%p  Busy 0x%p     Untagged 0x%p\n",
               PendingRequest,
               BusyRequest,
               CurrentUntaggedRequest));

    if((CompletedAbort != 0) || (AbortSrb != 0)) {
        xdprintfEx(Depth, ("Abort 0x%p    Completed Abort 0x%p\n",
                   AbortSrb, CompletedAbort));
    }

    xdprintfEx(Depth, ("Q Depth %03d (%03d)   InquiryData 0x%p\n",
               QueueCount, MaxQueueDepth, AddrOf_InquiryData));

    xdprintfEx(Depth, ("DeviceMap Keys: Target %#08lx   Lun %#08lx\n",
               TargetDeviceMapKey, LunDeviceMapKey));

    xdprintfEx(Depth, ("Bypass SRB_DATA blocks %d @ %08p   List %08p\n", 
               NUMBER_BYPASS_SRB_DATA_BLOCKS, 
               AddrOf_BypassSrbDataBlocks,
               BypassSrbDataList_Next));

    if((ActiveFailedRequest != 0) ||
       (BlockedFailedRequest != 0)) {
        xdprintfEx(Depth, ("Failed Requests - "));

        if(ActiveFailedRequest != 0) {
            dprintf("Active %#08I ", ActiveFailedRequest);
        }

        if(BlockedFailedRequest != 0) {
            dprintf("Blocked %#08I ", BlockedFailedRequest);
        }
        dprintf("\n");
    }

    xdprintfEx(Depth, ("RS Irp %p  Srb @ %p   MDL @ %p\n", 
               RequestSenseIrp,
               AddrOf_RequestSenseSrb,
               AddrOf_RequestSenseMdl));

    if((RequestList_Flink) == AddrOf_RequestList) {
        xdprintfEx(Depth, ("Request List @0x%p is empty\n",
                   AddrOf_RequestList));
    } else {
        xdprintfEx(Depth, ("Request list @0x%p:\n", AddrOf_RequestList));
        ScsiDumpActiveRequests(AddrOf_RequestList,
                               Adapter_TickCount,
                               Depth + 2);
    }

    if (Detail != 0) {

        //
        // The caller wants additional detail.  Dump the queued requests.
        // Extract the address of the device object from the common extension
        // and pass it to the routine that dumps queued requests.
        //

        ULONG64 DeviceObject;
        result = GetFieldData(LunAddress,
                              "scsiport!_COMMON_EXTENSION",
                              "DeviceObject",
                              sizeof(ULONG64),
                              &DeviceObject);
        if (result) {
            dprintf("Error reading DeviceObject @%p\n", LunAddress);
            return;
        }
        
        xdprintfEx(Depth, ("Queued requests:\n"));
        ScsiDumpQueuedRequests(
            DeviceObject,       
            Adapter_TickCount,
            Depth + 2
            );
    }
    return;
}

VOID
ScsiDumpActiveRequests(
    IN ULONG64 ListHead,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG result;

    ULONG64 lastEntry = 0;
    ULONG64 entry = 0;
    ULONG64 realEntry = 0;
    ULONG64 CurrentSrb = 0;
    ULONG64 CurrentIrp = 0;
    ULONG64 RequestList = 0;
    ULONG OffsetOfRequestList = 0;
    ULONG SrbTickCount = 0;
    ULONG Key = 0;

    FIELD_INFO deviceFields[] = {
        {"CurrentSrb", NULL, 0, COPY, 0, (PVOID) &CurrentSrb},
        {"CurrentIrp", NULL, 0, COPY, 0, (PVOID) &CurrentIrp},
        {"TickCount", NULL, 0, COPY, 0, (PVOID) &SrbTickCount},
        {"RequestList", NULL, 0, ADDROF, 0, NULL},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       0,
       NULL, NULL, NULL, 
       sizeof (deviceFields) / sizeof (FIELD_INFO), 
       &deviceFields[0]
    };

    result = GetFieldOffset("scsiport!_SRB_DATA", 
                            "RequestList",
                            &OffsetOfRequestList);
    if (result) {
        dprintf("failed to get offset of request list (%08X)\n", result);
        return;
    }
    
    entry = ListHead;
    realEntry = entry;
    
    InitTypeRead(ListHead, nt!_LIST_ENTRY);
    lastEntry = ReadField(Blink);

    xdprintfEx(Depth, ("Tick count is %d\n", TickCount));

    do {

        ULONG64 realSrbData;
        ULONG result;

        GetFieldData(realEntry,
                     "scsiport!_LIST_ENTRY",
                     "Flink",
                     sizeof(ULONG64),
                     &entry);

        //
        // entry points to the list entry element of the srb data.  Calculate
        // the address of the start of the srb data block.
        //

        realSrbData = entry - OffsetOfRequestList;

        xdprintfEx(Depth, ("SrbData %08p   ", realSrbData));

        //
        // Read the SRB_DATA information we need.
        //

        DevSym.addr = realSrbData;
        if ((Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size))) {
            dprintf("%08p: Could not read device object\n", realSrbData);
            return;
        }
        RequestList = deviceFields[3].address;
        

        InitTypeRead(CurrentSrb, scsiport!_SCSI_REQUEST_BLOCK);
        Key = (ULONG)ReadField(QueueSortKey);

        //
        // Update realEntry.
        //

        realEntry = RequestList;

        dprintf("Srb %08p   Irp %08p   Key %x  %s\n",
                CurrentSrb,
                CurrentIrp,
                Key,
                SecondsToString(TickCount - SrbTickCount));

    } while((entry != lastEntry) && (!CheckControlC()));

    return;
}

VOID
ScsiDumpLocks(
    ULONG64 CommonExtension,
    ULONG Depth
    )

/*++

Routine Description:

    dumps the remove locks for a given device object

Arguments:

    CommonExtension - a pointer to the local copy of the device object
                      common extension

Return Value:

    None

--*/

{
    ULONG result;

    LONG RemoveLock;
    ULONG64 RemoveTrackingSpinlock;
    ULONG64 RemoveTrackingList;

    InitTypeRead(CommonExtension, scsiport!_COMMON_EXTENSION);
    RemoveLock = (ULONG) ReadField(RemoveLock);
    RemoveTrackingSpinlock = ReadField(RemoveTrackingSpinlock);
    RemoveTrackingList = ReadField(RemoveTrackingList);

    xdprintfEx(Depth, ("RemoveLock count is %d", RemoveLock));

    if((PVOID)RemoveTrackingSpinlock != (PVOID)-1) {

        ULONG64 lockEntryAddress = RemoveTrackingList;

        dprintf(":\n");
        Depth++;

        if(RemoveTrackingSpinlock != 0) {
            xdprintfEx(Depth, ("RemoveTrackingList is in intermediate state"
                       "@ %p\n", RemoveTrackingList));
            return;
        }

        while((lockEntryAddress != 0L) && !CheckControlC()) {

            UCHAR buffer[512];
            ULONG64 File;
            ULONG64 Tag;
            ULONG64 NextBlock;
            ULONG Line;
            
            InitTypeRead(lockEntryAddress, scsiport!REMOVE_TRACKING_BLOCK);
            File = ReadField(File);
            Tag = ReadField(Tag);
            Line = (ULONG) ReadField(Line);
            NextBlock = ReadField(NextBlock);

            result = sizeof(buffer);

            if(!GetAnsiString(File,
                              buffer,
                              &result)) {

                xdprintfEx(Depth, ("Tag 0x%p File 0x%p Line %d\n",
                           Tag,
                           File,
                           Line));
            } else {

                PUCHAR name;

                name = &buffer[result];

                while((result > 0) &&
                      (*(name - 1) != '\\') &&
                      (*(name - 1)  != '/') &&
                      (!CheckControlC())) {
                    name--;
                    result--;
                }

                xdprintfEx(Depth, ("Tag 0x%p   File %s   Line %d\n",
                           Tag,
                           name,
                           Line));
            }

            lockEntryAddress = NextBlock;
        }
    } else {
        dprintf(" (not tracked on free build)\n");
    }
    return;
}

VOID
ScsiDumpSrbData(
    ULONG64 SrbData,
    ULONG Depth
    )
{
    ULONG result;

    CSHORT Type;
    ULONG64 LogicalUnit;
    ULONG64 CurrentSrb;
    ULONG64 CurrentIrp;
    ULONG64 RequestSenseSave;
    ULONG QueueTag;
    ULONG64 CompletedRequests;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
    ULONG Flags;
    ULONG64 RequestListFlink;
    ULONG64 RequestListBlink;
    ULONG64 DataOffset;
    ULONG64 OriginalDataBuffer;
    ULONG64 MapRegisterBase;
    ULONG NumberOfMapRegisters;
    ULONG64 ScatterGatherList;

    FIELD_INFO deviceFields[] = {
       {"Type", NULL, 0, COPY, 0, (PVOID) &Type},
       {"LogicalUnit", NULL, 0, COPY, 0, (PVOID) &LogicalUnit},
       {"CurrentSrb", NULL, 0, COPY, 0, (PVOID) &CurrentSrb},
       {"CurrentIrp", NULL, 0, COPY, 0, (PVOID) &CurrentIrp},
       {"RequestSenseSave", NULL, 0, COPY, 0, (PVOID) &RequestSenseSave},
       {"QueueTag", NULL, 0, COPY, 0, (PVOID) &QueueTag},
       {"CompletedRequests", NULL, 0, COPY, 0, (PVOID) &CompletedRequests},
       {"ErrorLogRetryCount", NULL, 0, COPY, 0, (PVOID) &ErrorLogRetryCount},
       {"SequenceNumber", NULL, 0, COPY, 0, (PVOID) &SequenceNumber},
       {"Flags", NULL, 0, COPY, 0, (PVOID) &Flags},
       {"RequestList.Flink", NULL, 0, COPY, 0, (PVOID) &RequestListFlink},
       {"RequestList.Blink", NULL, 0, COPY, 0, (PVOID) &RequestListBlink},
       {"DataOffset", NULL, 0, COPY, 0, (PVOID) &DataOffset},
       {"OriginalDataBuffer", NULL, 0, COPY, 0, (PVOID) &OriginalDataBuffer},
       {"MapRegisterBase", NULL, 0, COPY, 0, (PVOID) &MapRegisterBase},
       {"NumberOfMapRegisters", NULL, 0, COPY, 0, (PVOID) &NumberOfMapRegisters},
       {"ScatterGatherList", NULL, 0, COPY, 0, (PVOID) &ScatterGatherList},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_SRB_DATA", 
       DBG_DUMP_NO_PRINT, 
       SrbData,
       NULL, NULL, NULL,
       sizeof (deviceFields) / sizeof (FIELD_INFO),
       &deviceFields[0]
    };

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    if(Type != SRB_DATA_TYPE) {
        dprintf("Type (%#x) does not match SRB_DATA_TYPE (%#x)\n",
                Type, SRB_DATA_TYPE);
    }

    xdprintfEx(Depth, ("Lun  0x%p   Srb 0x%p   Irp 0x%p\n",
             LogicalUnit, CurrentSrb, CurrentIrp));

    xdprintfEx(Depth, ("Sense 0x%p  Tag  0x%08lx  Next Completed 0x%p\n",
             RequestSenseSave,
             QueueTag, CompletedRequests));

    xdprintfEx(Depth, ("Retry 0x%02x        Seq 0x%08lx   Flags 0x%08lx\n",
             ErrorLogRetryCount, SequenceNumber,
             Flags));

    xdprintfEx(Depth, ("Request List:     Next 0x%p  Previous 0x%p\n",
             RequestListFlink, RequestListBlink));

    xdprintfEx(Depth, ("Data Offset 0x%p    Original Data Buffer 0x%p\n", DataOffset, OriginalDataBuffer));

    xdprintfEx(Depth, ("Map Registers 0x%p (0x%02x)    SG List 0x%p\n",
             MapRegisterBase,
             NumberOfMapRegisters,
             ScatterGatherList));

    if(ScatterGatherList != 0) {
        
        ScsiDumpScatterGatherList(ScatterGatherList, 
                                  NumberOfMapRegisters, 
                                  Depth + 1);
    }

    return;

}


VOID
ScsiDumpScatterGatherList(
    ULONG64 List,
    ULONG Entries,
    ULONG Depth
    )
{
    ULONG result;
    ULONG i;
    ULONG start = TRUE;
    ULONG64 PhysicalAddress;
    ULONG Length;

    for(i = 0; i < Entries; i++) {

        InitTypeRead(List, nt!_SCATTER_GATHER_ELEMENT);
        PhysicalAddress = ReadField(Address);
        Length = (ULONG) ReadField(Length);

        if(start) {
            xdprintfEx(Depth, ("0x%016I64x (0x%08lx), ",
                     PhysicalAddress,
                     Length));
        } else {
            dprintf("0x%016I64x (0x%08lx),\n",
                    PhysicalAddress,
                    Length);
        }

        start = !start;
        List += (IsPtr64() != 0) ? 0x18 : 0xc;
    }

    if(!start) {
        dprintf("\n");
    }
}

DECLARE_API(srbdata)
{
    ULONG64 address;

    GetAddress(args, &address);

    dprintf("SrbData structure at %#p\n", address);

    ScsiDumpSrbData(address, 1);

    return S_OK;
}

VOID
ScsiDumpAdapterPerfCounters(
    ULONG64 Adapter,
    ULONG Depth
    )
{
#if TEST_LISTS
    ULONG result;

    ULONG SmallAllocationCount;
    ULONG LargeAllocationCount;
    ULONG64 ScatterGatherAllocationCount;
    ULONG64 SmallAllocationSize;
    ULONG64 MediumAllocationSize;
    ULONG64 LargeAllocationSize;
    ULONG64 SrbDataAllocationCount;
    ULONG64 SrbDataResurrectionCount;
    ULONG64 SrbDataEmergencyFreeCount;

    FIELD_INFO deviceFields[] = {
       {"SmallAllocationCount", NULL, 0, COPY, 0, (PVOID) &SmallAllocationCount},
       {"LargeAllocationCount", NULL, 0, COPY, 0, (PVOID) &LargeAllocationCount},
       {"ScatterGatherAllocationCount", NULL, 0, COPY, 0, (PVOID) &ScatterGatherAllocationCount},
       {"SmallAllocationSize", NULL, 0, COPY, 0, (PVOID) &SmallAllocationSize},
       {"MediumAllocationSize", NULL, 0, COPY, 0, (PVOID) &MediumAllocationSize},
       {"LargeAllocationSize", NULL, 0, COPY, 0, (PVOID) &LargeAllocationSize},
       {"SrbDataAllocationCount", NULL, 0, COPY, 0, (PVOID) &SrbDataAllocationCount},
       {"SrbDataResurrectionCount", NULL, 0, COPY, 0, (PVOID) &SrbDataResurrectionCount},
       {"SrbDataEmergencyFreeCount", NULL, 0, COPY, 0, (PVOID) &SrbDataEmergencyFreeCount},
    };

    SYM_DUMP_PARAM DevSym = {
       sizeof (SYM_DUMP_PARAM), 
       "scsiport!_ADAPTER_EXTENSION", 
       DBG_DUMP_NO_PRINT, 
       Adapter,
       NULL, NULL, NULL,
       sizeof (deviceFields) / sizeof (FIELD_INFO),
       &deviceFields[0]
    };

    result = Ioctl(IG_DUMP_SYMBOL_INFO, &DevSym, DevSym.size);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    ULONG mediumAllocationCount = (ULONG)
        (ScatterGatherAllocationCount -
         (SmallAllocationCount +
          LargeAllocationCount));

    double average;

    xdprintfEx(Depth, ("Performance Counters:\n"));

    Depth++;

    xdprintfEx(Depth, ("SGList Allocs - "));
    dprintf("Small: %d, ", SmallAllocationCount);
    dprintf("Med: %d, ",
            (ScatterGatherAllocationCount -
             SmallAllocationCount -
             LargeAllocationCount));
    dprintf("Large: %d, ", LargeAllocationCount);
    dprintf("Total: %I64d\n",
            ScatterGatherAllocationCount);

    xdprintfEx(Depth, ("Average SG Entries - "));

    if(SmallAllocationCount != 0) {
        average = ((double) (SmallAllocationSize)) / SmallAllocationCount;
        dprintf("Small: %.2f   ", average);
    }

    if(mediumAllocationCount != 0) {
        average = ((double) (MediumAllocationSize)) / mediumAllocationCount;
        dprintf("Medium: %.2f   ", average);
    }

    if(Adapter->LargeAllocationCount != 0) {
        average = ((double) (Adapter->LargeAllocationSize)) / LargeAllocationCount;
        dprintf("Large: %.2f", average);
    }

    dprintf("\n");

    xdprintfEx(Depth, ("SrbData - Allocs: %I64d, ",
               SrbDataAllocationCount));

    dprintf("Resurrected: %I64d, ",
            SrbDataResurrectionCount);

    dprintf("Timer Serviced: %I64d,\n",
            SrbDataServicedFromTickHandlerCount);

    xdprintfEx(Depth, ("          Queued: %I64d, ",
               SrbDataQueueInsertionCount));

    dprintf("Emergency Freed: %I64d\n",
            SrbDataEmergencyFreeCount);

#endif
    return;
}

PUCHAR
SecondsToString(
    ULONG Count
    )  
{
    static UCHAR string[64] = "";
    UCHAR tmp[16];

    ULONG seconds = 0;
    ULONG minutes = 0;
    ULONG hours = 0;
    ULONG days = 0;

    string[0] = '\0';

    if(Count == 0) {
        sprintf(string, "<1s");
        return string;
    }

    seconds = Count % 60;
    Count /= 60;

    if(Count != 0) {
        minutes = Count % 60;
        Count /= 60;
    }
        
    if(Count != 0) {
        hours = Count % 24;
        Count /= 24;
    }

    if(Count != 0) {
        days = Count;
    }

    if(days != 0) {
        sprintf(tmp, "%dd", days);
        strcat(string, tmp);
    }

    if(hours != 0) {
        sprintf(tmp, "%dh", hours);
        strcat(string, tmp);
    }

    if(minutes != 0) {
        sprintf(tmp, "%dm", minutes);
        strcat(string, tmp);
    }

    if(seconds != 0) {
        sprintf(tmp, "%ds", seconds);
        strcat(string, tmp);
    }

    return string;
}

VOID
ScsiDumpQueuedRequests(
    IN ULONG64 DeviceObject,
    IN ULONG TickCount,
    IN ULONG Depth
    )
{
    ULONG result;
    ULONG64 ListHeadFlink;
    ULONG64 ListHeadBlink;
    ULONG64 DeviceListHead;
    ULONG64 realEntry;

    //
    // Get the address of the head of the device list in the device queue.
    //

    result = GetFieldData(
                 DeviceObject,
                 "scsiport!_DEVICE_OBJECT",
                 "DeviceQueue.DeviceListHead",
                 sizeof(ULONG64),
                 &DeviceListHead);
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return;
    }

    //
    // Get the forward and backward link fields from the list head.  If
    // the queue is empty, we're done.
    //

    InitTypeRead(DeviceListHead, scsiport!_LIST_ENTRY);
    ListHeadFlink = ReadField(CurrentSrb);
    ListHeadBlink = ReadField(CurrentIrp);
                 
    if (ListHeadFlink == ListHeadBlink) {
        xdprintfEx(Depth, ("Device Queue is empty\n"));
        return;
    }

    //
    // Initialize a pointer the head of the list.
    //

    realEntry = DeviceListHead;

    do {

        ULONG result;
        ULONG64 realIrp;
        ULONG64 realStack;
        ULONG64 realSrb;
        ULONG64 realSrbData;
        ULONG64 CurrentSrb;
        ULONG64 CurrentIrp;
        ULONG OffsetOfDeviceListEntry;
        ULONG SrbDataTickCount;

        //
        // Get the address of the next entry in the queue.
        //

        result = GetFieldData(realEntry,
                              "scsiport!_LIST_ENTRY",
                              "Flink",
                              sizeof(ULONG64),
                              &realEntry);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }
        
        //
        // We to calculate the address of the IRP using the address of the 
        // list entry.  Can't use static CONTAINING_RECORD; we need a runtime 
        // equivalent.  So we use type info to get the offset of the list 
        // entry and calculate the address of the beginning of the IRP.  This
        // makes the extension work for 32b and 64b debuggees.
        //

        result = GetFieldOffset(
                     "scsiport!_IRP",
                     "Tail.Overlay.DeviceQueueEntry.DeviceListEntry",
                     &OffsetOfDeviceListEntry);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        realIrp = realEntry - OffsetOfDeviceListEntry;

        //
        // Now we need to read in the address of the current IO stack 
        // location.
        //

        result = GetFieldData(
                     realIrp,
                     "scsiport!_IRP",
                     "Tail.Overlay.CurrentStackLocation",
                     sizeof(ULONG64),
                     &realStack);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        //
        // Load the SRB field of the stack location.
        //

        result = GetFieldData(
                     realStack,
                     "scsiport!_IO_STACK_LOCATION",
                     "Parameters.Scsi.Srb",
                     sizeof(ULONG64),
                     &realSrb);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        //
        // Pick out the pointer to the srb data and read that in.
        //

        result = GetFieldData(
                     realSrb,
                     "scsiport!_SCSI_REQUEST_BLOCK",
                     "OriginalRequest",
                     sizeof(ULONG64),
                     &realSrbData);
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            break;
        }

        xdprintfEx(Depth, ("SrbData 0x%p   ", realSrbData));

        //
        // Read the SRB_DATA information we need.
        //

        InitTypeRead(realSrb, scsiport!_SRB_DATA);
        CurrentSrb = ReadField(CurrentSrb);
        CurrentIrp = ReadField(CurrentIrp);
        SrbDataTickCount = (ULONG)ReadField(TickCount);

        dprintf("Srb 0x%p   Irp 0x%p   %s\n",
                CurrentSrb,
                CurrentIrp,
                SecondsToString(TickCount - SrbDataTickCount));

    } while((realEntry != ListHeadBlink) && (!CheckControlC()));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\trace.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    aic.c

Abstract:

    WinDbg Extension Api for interpretting AIC78XX debugging structures

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/
#define DBG_TRACE


#include "pch.h"
#include "trace.h"

extern char *eventTypes[];
void dumpTraceInfo(traceinfo *ti);

DECLARE_API( trace )

/*++

Routine Description:

    Dumps the specified AIC78xx debugging data structure

Arguments:

    Ascii bits for address.

Return Value:

    None.

--*/

{
    ULONG_PTR  traceinfoAddr;
    traceinfo  ti;

    GetAddress(args, &traceinfoAddr);

    if (!ReadMemory( traceinfoAddr, &ti, sizeof(ti), NULL )) {
        dprintf("%p: Could not read Srb\n", traceinfoAddr);
        return;
    }

    dumpTraceInfo(&ti);
    return;
}

void dumpTraceInfo(traceinfo *ti)       {

    UCHAR   i,j;
    DWORD   result;
    char    buf[64];

    dprintf("AIC78xx Debugging Trace - %d total entries\n", ti->num);

    for (i = 0; i < ti->num; i++) {

        j = (ti->next + i) % ti->num;

        if (ti->table[i].type == TRACE_TYPE_EMPTY)       continue;

        dprintf("event %d: ", ti->num - i);

        dprintf("%s\t", eventTypes[ti->table[j].type]);

//              dprintf("%lx(", ti->table[j].func);

        if (ti->table[j].func != NULL) {
            GetSymbol((LPVOID)ti->table[j].func, buf, &result);
            dprintf("%s(", buf);
        } else {
            dprintf("NULL(", buf);
        }

        dprintf("%lx, %lx, %lx)\n", ti->table[j].arg[0],
                ti->table[j].arg[1],
                ti->table[j].arg[2]);
    }

    return;
}

char *eventTypes[] = {"EMPTY", "ENTRY", "EXIT", "EVENT"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\string.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    classkd.c

Abstract:

    Debugger Extension Api for interpretting scsiport structures

Author:

    ervinp

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#include "classpnp.h" // #defines ALLOCATE_SRB_FROM_POOL as needed
#include "classp.h"   // Classpnp's private definitions
#include "cdrom.h"

#include "classkd.h"  // routines that are useful for all class drivers



char *DbgGetIoctlStr(ULONG ioctl)
{
    char *ioctlStr = "?";
    
    switch (ioctl){
        
        #undef MAKE_CASE             
        #define MAKE_CASE(ioctlCode) case ioctlCode: ioctlStr = #ioctlCode; break;

        MAKE_CASE(IOCTL_STORAGE_CHECK_VERIFY)
        MAKE_CASE(IOCTL_STORAGE_CHECK_VERIFY2)
        MAKE_CASE(IOCTL_STORAGE_MEDIA_REMOVAL)
        MAKE_CASE(IOCTL_STORAGE_EJECT_MEDIA)
        MAKE_CASE(IOCTL_STORAGE_LOAD_MEDIA)
        MAKE_CASE(IOCTL_STORAGE_LOAD_MEDIA2)
        MAKE_CASE(IOCTL_STORAGE_RESERVE)
        MAKE_CASE(IOCTL_STORAGE_RELEASE)
        MAKE_CASE(IOCTL_STORAGE_FIND_NEW_DEVICES)
        MAKE_CASE(IOCTL_STORAGE_EJECTION_CONTROL)
        MAKE_CASE(IOCTL_STORAGE_MCN_CONTROL)
        MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_TYPES)
        MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_TYPES_EX)
        MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER)
        MAKE_CASE(IOCTL_STORAGE_GET_HOTPLUG_INFO)
        MAKE_CASE(IOCTL_STORAGE_RESET_BUS)
        MAKE_CASE(IOCTL_STORAGE_RESET_DEVICE)
        MAKE_CASE(IOCTL_STORAGE_GET_DEVICE_NUMBER)
        MAKE_CASE(IOCTL_STORAGE_PREDICT_FAILURE)
        MAKE_CASE(IOCTL_STORAGE_QUERY_PROPERTY)
        MAKE_CASE(OBSOLETE_IOCTL_STORAGE_RESET_BUS)
        MAKE_CASE(OBSOLETE_IOCTL_STORAGE_RESET_DEVICE)
    }
  
    return ioctlStr;
}


char *DbgGetScsiOpStr(UCHAR ScsiOp)
{
    char *scsiOpStr = "?";
    
    switch (ScsiOp){

        #undef MAKE_CASE             
        #define MAKE_CASE(scsiOpCode) case scsiOpCode: scsiOpStr = #scsiOpCode; break;
        
        MAKE_CASE(SCSIOP_TEST_UNIT_READY)
        MAKE_CASE(SCSIOP_REWIND)    // aka SCSIOP_REZERO_UNIT
        MAKE_CASE(SCSIOP_REQUEST_BLOCK_ADDR)
        MAKE_CASE(SCSIOP_REQUEST_SENSE)
        MAKE_CASE(SCSIOP_FORMAT_UNIT)
        MAKE_CASE(SCSIOP_READ_BLOCK_LIMITS)
        MAKE_CASE(SCSIOP_INIT_ELEMENT_STATUS)   // aka SCSIOP_REASSIGN_BLOCKS
        MAKE_CASE(SCSIOP_RECEIVE)       // aka SCSIOP_READ6
        MAKE_CASE(SCSIOP_SEND)  // aka SCSIOP_WRITE6, SCSIOP_PRINT
        MAKE_CASE(SCSIOP_SLEW_PRINT)    // aka SCSIOP_SEEK6, SCSIOP_TRACK_SELECT
        MAKE_CASE(SCSIOP_SEEK_BLOCK)
        MAKE_CASE(SCSIOP_PARTITION)
        MAKE_CASE(SCSIOP_READ_REVERSE)
        MAKE_CASE(SCSIOP_FLUSH_BUFFER)      // aka SCSIOP_WRITE_FILEMARKS
        MAKE_CASE(SCSIOP_SPACE)
        MAKE_CASE(SCSIOP_INQUIRY)
        MAKE_CASE(SCSIOP_VERIFY6)
        MAKE_CASE(SCSIOP_RECOVER_BUF_DATA)
        MAKE_CASE(SCSIOP_MODE_SELECT)
        MAKE_CASE(SCSIOP_RESERVE_UNIT)
        MAKE_CASE(SCSIOP_RELEASE_UNIT)
        MAKE_CASE(SCSIOP_COPY)
        MAKE_CASE(SCSIOP_ERASE)
        MAKE_CASE(SCSIOP_MODE_SENSE)
        MAKE_CASE(SCSIOP_START_STOP_UNIT)   // aka SCSIOP_STOP_PRINT, SCSIOP_LOAD_UNLOAD
        MAKE_CASE(SCSIOP_RECEIVE_DIAGNOSTIC)
        MAKE_CASE(SCSIOP_SEND_DIAGNOSTIC)
        MAKE_CASE(SCSIOP_MEDIUM_REMOVAL)
        MAKE_CASE(SCSIOP_READ_FORMATTED_CAPACITY)
        MAKE_CASE(SCSIOP_READ_CAPACITY)
        MAKE_CASE(SCSIOP_READ)
        MAKE_CASE(SCSIOP_WRITE)
        MAKE_CASE(SCSIOP_SEEK)  // aka SCSIOP_LOCATE, SCSIOP_POSITION_TO_ELEMENT
        MAKE_CASE(SCSIOP_WRITE_VERIFY)
        MAKE_CASE(SCSIOP_VERIFY)
        MAKE_CASE(SCSIOP_SEARCH_DATA_HIGH)
        MAKE_CASE(SCSIOP_SEARCH_DATA_EQUAL)
        MAKE_CASE(SCSIOP_SEARCH_DATA_LOW)
        MAKE_CASE(SCSIOP_SET_LIMITS)
        MAKE_CASE(SCSIOP_READ_POSITION)
        MAKE_CASE(SCSIOP_SYNCHRONIZE_CACHE)
        MAKE_CASE(SCSIOP_COMPARE)
        MAKE_CASE(SCSIOP_COPY_COMPARE)
        MAKE_CASE(SCSIOP_WRITE_DATA_BUFF)
        MAKE_CASE(SCSIOP_READ_DATA_BUFF)
        MAKE_CASE(SCSIOP_CHANGE_DEFINITION)
        MAKE_CASE(SCSIOP_READ_SUB_CHANNEL)
        MAKE_CASE(SCSIOP_READ_TOC)
        MAKE_CASE(SCSIOP_READ_HEADER)
        MAKE_CASE(SCSIOP_PLAY_AUDIO)
        MAKE_CASE(SCSIOP_GET_CONFIGURATION)
        MAKE_CASE(SCSIOP_PLAY_AUDIO_MSF)
        MAKE_CASE(SCSIOP_PLAY_TRACK_INDEX)
        MAKE_CASE(SCSIOP_PLAY_TRACK_RELATIVE)
        MAKE_CASE(SCSIOP_GET_EVENT_STATUS)
        MAKE_CASE(SCSIOP_PAUSE_RESUME)
        MAKE_CASE(SCSIOP_LOG_SELECT)
        MAKE_CASE(SCSIOP_LOG_SENSE)
        MAKE_CASE(SCSIOP_STOP_PLAY_SCAN)
        MAKE_CASE(SCSIOP_READ_DISK_INFORMATION)
        MAKE_CASE(SCSIOP_READ_TRACK_INFORMATION)
        MAKE_CASE(SCSIOP_RESERVE_TRACK_RZONE)
        MAKE_CASE(SCSIOP_SEND_OPC_INFORMATION)
        MAKE_CASE(SCSIOP_MODE_SELECT10)
        MAKE_CASE(SCSIOP_MODE_SENSE10)
        MAKE_CASE(SCSIOP_CLOSE_TRACK_SESSION)
        MAKE_CASE(SCSIOP_READ_BUFFER_CAPACITY)
        MAKE_CASE(SCSIOP_SEND_CUE_SHEET)
        MAKE_CASE(SCSIOP_PERSISTENT_RESERVE_IN)
        MAKE_CASE(SCSIOP_PERSISTENT_RESERVE_OUT)
        MAKE_CASE(SCSIOP_REPORT_LUNS)
        MAKE_CASE(SCSIOP_BLANK)
        MAKE_CASE(SCSIOP_SEND_KEY)
        MAKE_CASE(SCSIOP_REPORT_KEY)
        MAKE_CASE(SCSIOP_MOVE_MEDIUM)
        MAKE_CASE(SCSIOP_LOAD_UNLOAD_SLOT)  // aka SCSIOP_EXCHANGE_MEDIUM
        MAKE_CASE(SCSIOP_SET_READ_AHEAD)
        MAKE_CASE(SCSIOP_READ_DVD_STRUCTURE)
        MAKE_CASE(SCSIOP_REQUEST_VOL_ELEMENT)
        MAKE_CASE(SCSIOP_SEND_VOLUME_TAG)
        MAKE_CASE(SCSIOP_READ_ELEMENT_STATUS)
        MAKE_CASE(SCSIOP_READ_CD_MSF)
        MAKE_CASE(SCSIOP_SCAN_CD)
        MAKE_CASE(SCSIOP_SET_CD_SPEED)
        MAKE_CASE(SCSIOP_PLAY_CD)
        MAKE_CASE(SCSIOP_MECHANISM_STATUS)
        MAKE_CASE(SCSIOP_READ_CD)
        MAKE_CASE(SCSIOP_SEND_DVD_STRUCTURE)
        MAKE_CASE(SCSIOP_INIT_ELEMENT_RANGE)
    }

    return scsiOpStr;
}


char *DbgGetSrbStatusStr(UCHAR SrbStat)
{
    char *srbStatStr = "?";
    
    switch (SrbStat){

        #undef MAKE_CASE
        #define MAKE_CASE(srbStat) \
                    case srbStat: \
                        srbStatStr = #srbStat; \
                        break; \
                    case srbStat|SRB_STATUS_QUEUE_FROZEN: \
                        srbStatStr = #srbStat "|SRB_STATUS_QUEUE_FROZEN"; \
                        break; \
                    case srbStat|SRB_STATUS_AUTOSENSE_VALID: \
                        srbStatStr = #srbStat "|SRB_STATUS_AUTOSENSE_VALID"; \
                        break; \
                    case srbStat|SRB_STATUS_QUEUE_FROZEN|SRB_STATUS_AUTOSENSE_VALID: \
                        srbStatStr = #srbStat "|SRB_STATUS_QUEUE_FROZEN|SRB_STATUS_AUTOSENSE_VALID"; \
                        break; 

        MAKE_CASE(SRB_STATUS_PENDING)
        MAKE_CASE(SRB_STATUS_SUCCESS)
        MAKE_CASE(SRB_STATUS_ABORTED)
        MAKE_CASE(SRB_STATUS_ABORT_FAILED)
        MAKE_CASE(SRB_STATUS_ERROR)
        MAKE_CASE(SRB_STATUS_BUSY)
        MAKE_CASE(SRB_STATUS_INVALID_REQUEST)
        MAKE_CASE(SRB_STATUS_INVALID_PATH_ID)
        MAKE_CASE(SRB_STATUS_NO_DEVICE)
        MAKE_CASE(SRB_STATUS_TIMEOUT)
        MAKE_CASE(SRB_STATUS_SELECTION_TIMEOUT)
        MAKE_CASE(SRB_STATUS_COMMAND_TIMEOUT)
        MAKE_CASE(SRB_STATUS_MESSAGE_REJECTED)
        MAKE_CASE(SRB_STATUS_BUS_RESET)
        MAKE_CASE(SRB_STATUS_PARITY_ERROR)
        MAKE_CASE(SRB_STATUS_REQUEST_SENSE_FAILED)
        MAKE_CASE(SRB_STATUS_NO_HBA)
        MAKE_CASE(SRB_STATUS_DATA_OVERRUN)
        MAKE_CASE(SRB_STATUS_UNEXPECTED_BUS_FREE)
        MAKE_CASE(SRB_STATUS_PHASE_SEQUENCE_FAILURE)
        MAKE_CASE(SRB_STATUS_BAD_SRB_BLOCK_LENGTH)
        MAKE_CASE(SRB_STATUS_REQUEST_FLUSHED)
        MAKE_CASE(SRB_STATUS_INVALID_LUN)
        MAKE_CASE(SRB_STATUS_INVALID_TARGET_ID)
        MAKE_CASE(SRB_STATUS_BAD_FUNCTION)
        MAKE_CASE(SRB_STATUS_ERROR_RECOVERY)
        MAKE_CASE(SRB_STATUS_NOT_POWERED)
        MAKE_CASE(SRB_STATUS_INTERNAL_ERROR)
    }

    return srbStatStr;
}



char *DbgGetSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr)
{
    char *senseCodeStr = "?";

    if (SrbStat & SRB_STATUS_AUTOSENSE_VALID){
        UCHAR senseCode;

        senseCode = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "SenseKey");
        if (senseCode != BAD_VALUE){
            
            senseCode &= 0x0f;
                         
            switch (senseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(snsCod) case snsCod: senseCodeStr = #snsCod; break;
            
                MAKE_CASE(SCSI_SENSE_NO_SENSE)
                MAKE_CASE(SCSI_SENSE_RECOVERED_ERROR)
                MAKE_CASE(SCSI_SENSE_NOT_READY)
                MAKE_CASE(SCSI_SENSE_MEDIUM_ERROR)
                MAKE_CASE(SCSI_SENSE_HARDWARE_ERROR)
                MAKE_CASE(SCSI_SENSE_ILLEGAL_REQUEST)
                MAKE_CASE(SCSI_SENSE_UNIT_ATTENTION)
                MAKE_CASE(SCSI_SENSE_DATA_PROTECT)
                MAKE_CASE(SCSI_SENSE_BLANK_CHECK)
                MAKE_CASE(SCSI_SENSE_UNIQUE)
                MAKE_CASE(SCSI_SENSE_COPY_ABORTED)
                MAKE_CASE(SCSI_SENSE_ABORTED_COMMAND)
                MAKE_CASE(SCSI_SENSE_EQUAL)
                MAKE_CASE(SCSI_SENSE_VOL_OVERFLOW)
                MAKE_CASE(SCSI_SENSE_MISCOMPARE)
                MAKE_CASE(SCSI_SENSE_RESERVED)               
            }
        }                
    }

    return senseCodeStr;
}


char *DbgGetAdditionalSenseCodeStr(UCHAR SrbStat, ULONG64 SenseDataAddr)
{
    char *adSenseCodeStr = "?";

    if (SrbStat & SRB_STATUS_AUTOSENSE_VALID){
        UCHAR adSenseCode;

        adSenseCode = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "AdditionalSenseCode");
        if (adSenseCode != BAD_VALUE){
            
            switch (adSenseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(adSnsCod) case adSnsCod: adSenseCodeStr = #adSnsCod; break;

                MAKE_CASE(SCSI_ADSENSE_NO_SENSE)
                MAKE_CASE(SCSI_ADSENSE_LUN_NOT_READY)
                MAKE_CASE(SCSI_ADSENSE_TRACK_ERROR)
                MAKE_CASE(SCSI_ADSENSE_SEEK_ERROR)
                MAKE_CASE(SCSI_ADSENSE_REC_DATA_NOECC)
                MAKE_CASE(SCSI_ADSENSE_REC_DATA_ECC)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_COMMAND)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_BLOCK)
                MAKE_CASE(SCSI_ADSENSE_INVALID_CDB)
                MAKE_CASE(SCSI_ADSENSE_INVALID_LUN)
                MAKE_CASE(SCSI_ADSENSE_WRITE_PROTECT)   // aka SCSI_ADWRITE_PROTECT
                MAKE_CASE(SCSI_ADSENSE_MEDIUM_CHANGED)
                MAKE_CASE(SCSI_ADSENSE_BUS_RESET)
                MAKE_CASE(SCSI_ADSENSE_INVALID_MEDIA)
                MAKE_CASE(SCSI_ADSENSE_NO_MEDIA_IN_DEVICE)
                MAKE_CASE(SCSI_ADSENSE_POSITION_ERROR)
                MAKE_CASE(SCSI_ADSENSE_OPERATOR_REQUEST)
                MAKE_CASE(SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED)
                MAKE_CASE(SCSI_ADSENSE_COPY_PROTECTION_FAILURE)
                MAKE_CASE(SCSI_ADSENSE_VENDOR_UNIQUE)
                MAKE_CASE(SCSI_ADSENSE_MUSIC_AREA)
                MAKE_CASE(SCSI_ADSENSE_DATA_AREA)
                MAKE_CASE(SCSI_ADSENSE_VOLUME_OVERFLOW)
            }
        }
    }

    return adSenseCodeStr;
}


char *DbgGetAdditionalSenseCodeQualifierStr(UCHAR SrbStat, ULONG64 SenseDataAddr)
{
    char *adSenseCodeQualStr = "?";
    
    if (SrbStat & SRB_STATUS_AUTOSENSE_VALID){
        UCHAR adSenseCode, adSenseCodeQual;

        adSenseCode = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "AdditionalSenseCode");
        adSenseCodeQual = GetUCHARField(SenseDataAddr, "classpnp!_SENSE_DATA", "AdditionalSenseCodeQualifier");
        
        if ((adSenseCode != BAD_VALUE) && (adSenseCodeQual != BAD_VALUE)){
    
            switch (adSenseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(adSnsCodQual) case adSnsCodQual: adSenseCodeQualStr = #adSnsCodQual; break;

                case SCSI_ADSENSE_LUN_NOT_READY:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)
                        MAKE_CASE(SCSI_SENSEQ_BECOMING_READY)
                        MAKE_CASE(SCSI_SENSEQ_INIT_COMMAND_REQUIRED)
                        MAKE_CASE(SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)
                        MAKE_CASE(SCSI_SENSEQ_FORMAT_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_REBUILD_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_RECALCULATION_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_OPERATION_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS)                        
                    }
                    break;
                case SCSI_ADSENSE_NO_SENSE:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_FILEMARK_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_END_OF_MEDIA_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_SETMARK_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED)
                    }
                    break;
                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR)
                    }
                    break;
                case SCSI_ADSENSE_POSITION_ERROR:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_DESTINATION_FULL)
                        MAKE_CASE(SCSI_SENSEQ_SOURCE_EMPTY)
                    }
                    break;
                case SCSI_ADSENSE_INVALID_MEDIA:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED)
                        MAKE_CASE(SCSI_SENSEQ_UNKNOWN_FORMAT)
                        MAKE_CASE(SCSI_SENSEQ_INCOMPATIBLE_FORMAT)
                        MAKE_CASE(SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)
                    }
                    break;
                case SCSI_ADSENSE_OPERATOR_REQUEST:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_STATE_CHANGE_INPUT)
                        MAKE_CASE(SCSI_SENSEQ_MEDIUM_REMOVAL)
                        MAKE_CASE(SCSI_SENSEQ_WRITE_PROTECT_ENABLE)
                        MAKE_CASE(SCSI_SENSEQ_WRITE_PROTECT_DISABLE)
                    }
                    break;
                case SCSI_ADSENSE_COPY_PROTECTION_FAILURE:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_AUTHENTICATION_FAILURE)
                        MAKE_CASE(SCSI_SENSEQ_KEY_NOT_PRESENT)
                        MAKE_CASE(SCSI_SENSEQ_KEY_NOT_ESTABLISHED)
                        MAKE_CASE(SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION)
                        MAKE_CASE(SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT)
                        MAKE_CASE(SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR)
                    }
                    break;
            }
        }
    }

    return adSenseCodeQualStr;
}


/*
 *  DbgGetMediaTypeStr
 *
 *      Convert MEDIA_TYPE (defined in ntdddisk.h) to a string.
 */
char *DbgGetMediaTypeStr(ULONG MediaType)
{
    char *mediaTypeStr = "?";
    
    switch (MediaType){

        #undef MAKE_CASE             
        #define MAKE_CASE(mtype) case mtype: mediaTypeStr = #mtype; break;

        MAKE_CASE(Unknown)
        MAKE_CASE(F5_1Pt2_512)
        MAKE_CASE(F3_1Pt44_512)
        MAKE_CASE(F3_2Pt88_512)
        MAKE_CASE(F3_20Pt8_512)
        MAKE_CASE(F3_720_512)
        MAKE_CASE(F5_360_512)
        MAKE_CASE(F5_320_512)
        MAKE_CASE(F5_320_1024)
        MAKE_CASE(F5_180_512)
        MAKE_CASE(F5_160_512)
        MAKE_CASE(RemovableMedia)
        MAKE_CASE(FixedMedia)
        MAKE_CASE(F3_120M_512)
        MAKE_CASE(F3_640_512)
        MAKE_CASE(F5_640_512)
        MAKE_CASE(F5_720_512)
        MAKE_CASE(F3_1Pt2_512)
        MAKE_CASE(F3_1Pt23_1024)
        MAKE_CASE(F5_1Pt23_1024)
        MAKE_CASE(F3_128Mb_512)
        MAKE_CASE(F3_230Mb_512)
        MAKE_CASE(F8_256_128)
        MAKE_CASE(F3_200Mb_512)
        MAKE_CASE(F3_240M_512)
        MAKE_CASE(F3_32M_512)
    }

    return mediaTypeStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\stor\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <storport.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define MINIPKD_PRINT_ERROR(r)\
    dprintf("minipkd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);

#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

extern WINDBG_EXTENSION_APIS64 ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64   Address
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG_PTR Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    util.c

Abstract:

    Utility library used for the various debugger extensions in this library.

Author:

    Peter Wieland (peterwie) 16-Oct-1995

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#include "classkd.h"  // routines that are useful for all class drivers

PUCHAR devicePowerStateNames[] = {
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum",
    "Invalid"
};

FLAG_NAME SrbFlags[] = {
    FLAG_NAME(SRB_FLAGS_QUEUE_ACTION_ENABLE),
    FLAG_NAME(SRB_FLAGS_DISABLE_DISCONNECT),
    FLAG_NAME(SRB_FLAGS_DISABLE_SYNCH_TRANSFER),
    FLAG_NAME(SRB_FLAGS_BYPASS_FROZEN_QUEUE),
    FLAG_NAME(SRB_FLAGS_DISABLE_AUTOSENSE),
    FLAG_NAME(SRB_FLAGS_DATA_IN),
    FLAG_NAME(SRB_FLAGS_DATA_OUT),
    FLAG_NAME(SRB_FLAGS_NO_DATA_TRANSFER),
    FLAG_NAME(SRB_FLAGS_UNSPECIFIED_DIRECTION),
    FLAG_NAME(SRB_FLAGS_NO_QUEUE_FREEZE),
    FLAG_NAME(SRB_FLAGS_ADAPTER_CACHE_ENABLE),
    FLAG_NAME(SRB_FLAGS_IS_ACTIVE),
    FLAG_NAME(SRB_FLAGS_ALLOCATED_FROM_ZONE),
    FLAG_NAME(SRB_FLAGS_SGLIST_FROM_POOL),
    FLAG_NAME(SRB_FLAGS_BYPASS_LOCKED_QUEUE),
    FLAG_NAME(SRB_FLAGS_NO_KEEP_AWAKE),
    {0,0}
};


char *g_genericErrorHelpStr =   "\n" \
                                "**************************************************************** \n" \
                                "  Make sure you have _private_ symbols for classpnp.sys loaded.\n" \
                                "  The FDO parameter should be the upper AttachedDevice of the disk/cdrom/etc PDO\n" \
                                "  as returned by '!devnode 0 1 {disk|cdrom|4mmdat|etc}'.\n" \
                                "**************************************************************** \n\n" \
                                ;

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64   Address
    )
{
    UCHAR addressBuffer[256];

    addressBuffer[0] = '\0';
    sscanf(Args, "%s", addressBuffer);
    addressBuffer[255] = '\0';

    *Address = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            return;

        }

    }
    return;
}

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    )
{
    UCHAR addressBuffer[256];
    UCHAR detailBuffer[256];

    addressBuffer[0] = '\0';
    detailBuffer[0]  = '\0';
    sscanf(Args, "%s %s", addressBuffer, detailBuffer);
    addressBuffer[255] = '\0';
    detailBuffer[255]  = '\0';

    *Address = 0;
    *Detail  = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            *Detail = 0;
            return;

        }

        //
        // if they provided a detail level get it.
        //

        if (detailBuffer[0] == '\0') {

            *Detail = 0;

        } else {

            *Detail = (ULONG)GetExpression(detailBuffer);

        }
    }
    return;
}


VOID
GetAddressAndDetailLevel64(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    )
{
    UCHAR addressBuffer[256];
    UCHAR detailBuffer[256];

    addressBuffer[0] = '\0';
    detailBuffer[0]  = '\0';
    sscanf(Args, "%s %s", addressBuffer, detailBuffer);
    addressBuffer[255] = '\0';
    detailBuffer[255]  = '\0';

    *Address = 0;
    *Detail  = 0;

    if (addressBuffer[0] != '\0') {

        //
        // they provided an address
        //

        *Address = GetExpression(addressBuffer);

        //
        // if that still doesn't parse, print an error
        //

        if (*Address==0) {

            dprintf("An error occured trying to evaluate the address\n");
            *Address = 0;
            *Detail = 0;
            return;

        }

        //
        // if they provided a detail level get it.
        //

        if (detailBuffer[0] == '\0') {

            *Detail = 0;

        } else {

            *Detail = (ULONG)GetExpression(detailBuffer);

        }
    }
    return;
}


PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    )

{
    if(State > PowerDeviceMaximum) {
        return devicePowerStateNames[PowerDeviceMaximum + 1];
    } else {
        return devicePowerStateNames[(UCHAR) State];
    }
}

//
// Translates various printf formats to account for the target platform.
//
// This looks for %p type format and truncates the top 4 bytes of the ULONG64
// address argument if the debugee is a 32 bit machine.
// The %p is replaced by %I64x in format string.
//
BOOL
TranslateFormat(
    LPSTR formatOut,
    LPCSTR format,
    va_list args,
    ULONG formatOutSize
    )
{
#define Duplicate(j,i) (formatOut[j++] = format[i++])
    ULONG minSize = strlen(format), i = 0, j = 0;
    CHAR c;
    BOOL TypeFormat = FALSE;
    BOOL FormatChanged = FALSE;

    do
    {
        c = format[i];

        if (c=='%')
        {
            TypeFormat = !TypeFormat;
        }
        if (TypeFormat)
        {
            switch (c)
            {
            case 'c': case 'C': case 'i': case 'd':
            case 'o': case 'u': case 'x': case 'X':
                Duplicate(j,i);
                va_arg(args, int);
                TypeFormat = FALSE;
                break;
            case 'e': case 'E': case 'f': case 'g':
            case 'G':
                Duplicate(j,i);
                va_arg(args, double);
                TypeFormat = FALSE;
                break;
            case 'n':
                Duplicate(j,i);
                va_arg(args, int*);
                TypeFormat = FALSE;
                break;
            case 'N':
                // Native pointer, turns into %p.
                formatOut[j++] = 'p';
                FormatChanged = TRUE;
                i++;
                va_arg(args, void*);
                TypeFormat = FALSE;
                break;
            case 's': case 'S':
                Duplicate(j,i);
                va_arg(args, char*);
                TypeFormat = FALSE;
                break;

            case 'I':
                if ((format[i+1] == '6') && (format[i+2] == '4'))
                {
                    Duplicate(j,i);
                    Duplicate(j,i);
                    va_arg(args, ULONG64);
                    TypeFormat = FALSE;
                }
                // dprintf("I64 a0 %lx, off %lx\n", args.a0, args.offset);
                Duplicate(j,i);
                break;
            
            case 'z': case 'Z':
                // unicode string
                Duplicate(j,i);
                va_arg(args, void*);
                TypeFormat = FALSE;
                break;

            case 'p':
            case 'P':
                minSize +=3;
                if (format[i-1] == '%')
                {
                    minSize++;
                    if (IsPtr64())
                    {
                        minSize += 2;
                        if (minSize > formatOutSize)
                        {
                            return FALSE;
                        }
                        formatOut[j++] = '0';
                        formatOut[j++] = '1';
                        formatOut[j++] = '6';
                    }
                    else
                    {
                        if (minSize > formatOutSize)
                        {
                            return FALSE;
                        }
                        formatOut[j++] = '0';
                        formatOut[j++] = '8';
                    }
                }

                if (minSize > formatOutSize)
                {
                    return FALSE;
                }
                formatOut[j++] = 'I';
                formatOut[j++] = '6';
                formatOut[j++] = '4';
                formatOut[j++] = (c == 'p') ? 'x' : 'X'; ++i;
                FormatChanged = TRUE;

                if (!IsPtr64())
                {
                    PULONG64 Arg;

#ifdef  _M_ALPHA
                    Arg = (PULONG64) ((args.a0)+args.offset);
                    //dprintf("a0 %lx, off %lx\n", args.a0, args.offset);
#else
                    Arg = (PULONG64) (args);
#endif

                    //
                    // Truncate signextended addresses
                    //
                    *Arg = (ULONG64) (ULONG) *Arg;
                }

                va_arg(args, ULONG64);
                TypeFormat = FALSE;
                break;

            default:
                Duplicate(j,i);
            } /* switch */
        }
        else
        {
            Duplicate(j,i);
        }
    }
    while (format[i] != '\0');

    formatOut[j] = '\0';
    return FormatChanged;
#undef Duplicate
}


/*
 *  xdprintf
 *
 *      Prints formatted text with leading spaces.
 *
 *      WARNING:  DOES NOT HANDLE ULONG64 PROPERLY.
 */
VOID
xdprintf(
    ULONG  Depth,
    PCCHAR Format,
    ...
    )
{
    va_list args;
    ULONG i;
    CCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(args, Format);
    _vsnprintf(DebugBuffer, 255, Format, args);
    dprintf (DebugBuffer);
    va_end(args);
}

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (0x%08x): ", Name, Flags);

    xdprintf(Depth, "%s", prolog);

    if(Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}


BOOLEAN
GetAnsiString(
    IN ULONG64 Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    )
{
    ULONG i = 0;

    //
    // Grab the string in 64 character chunks until we find a NULL or the
    // read fails.
    //

    while((i < *Length) && (!CheckControlC())) {

        ULONG transferSize;
        ULONG result;

        if(*Length - i < 128) {
            transferSize = *Length - i;
        } else {
            transferSize = 128;
        }

        if(!ReadMemory(Address + i,
                       Buffer + i,
                       transferSize,
                       &result)) {
            //
            // read failed and we didn't find the NUL the last time.  Don't
            // expect to find it this time.
            //

            *Length = i;
            return FALSE;

        } else {

            ULONG j;

            //
            // Scan from where we left off looking for that NUL character.
            //

            for(j = 0; j < transferSize; j++) {

                if(Buffer[i + j] == '\0') {
                    *Length = i + j;
                    return TRUE;
                }
            }
        }

        i += transferSize;
    }

    //
    // We never found the NUL.  Don't need to update Length since it's currently
    // equal to i.
    //

    return FALSE;
}

PCHAR
GuidToString(
    GUID* Guid
    )
{
    static CHAR Buffer [64];
    
    sprintf (Buffer,
             "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             Guid->Data1,
             Guid->Data2,
             Guid->Data3,
             Guid->Data4[0],
             Guid->Data4[1],
             Guid->Data4[2],
             Guid->Data4[3],
             Guid->Data4[4],
             Guid->Data4[5],
             Guid->Data4[6],
             Guid->Data4[7]
             );

    return Buffer;
}


ULONG64
GetDeviceExtension(
    ULONG64 address
    )

/*++

Routine Description:

    The function accepts the address of either a device object or a device
    extension.  If the supplied address is that of a device object, the
    device extension is retrieved and returned.  If the address is that of
    a device extension, the address is returned unmodified.

Arguments:

    Address - address of a device extension or a device object

Return Value:

    The address of the device extension or 0 if an error occurs.

--*/

{
    ULONG result;
    CSHORT Type;
    ULONG64 Address = address;

    //
    // The supplied address may be either the address of a device object or the
    // address of a device extension.  To distinguish which, we treat the 
    // address as a device object and read what would be its type field.  If
    // the 
    //

    result = GetFieldData(Address,
                          "scsiport!_DEVICE_OBJECT",
                          "Type",
                          sizeof(CSHORT),
                          &Type
                          );
    if (result) {
        SCSIKD_PRINT_ERROR(result);
        return 0;
    }
    
    //
    // See if the supplied address holds a device object.  If it does, read the
    // address of the device extension.  Otherwise, we assume the supplied
    // addres holds a device extension and we use it directly.
    //

    if (Type == IO_TYPE_DEVICE) {

        result = GetFieldData(Address,
                              "scsiport!_DEVICE_OBJECT",
                              "DeviceExtension",
                              sizeof(ULONG64),
                              &Address
                              );
        if (result) {
            SCSIKD_PRINT_ERROR(result);
            return 0;
        }
    }

    return Address;
}



/*
 *  GetULONGField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
ULONG64 GetULONGField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(ULONG64), &result);
    if (dbgStat != 0){
        dprintf("\n GetULONGField: GetFieldData failed with %xh retrieving field '%s' of struct '%s', returning bogus field value %08xh.\n", dbgStat, FieldName, StructType, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);        
        result = BAD_VALUE;
    }

    return result;
}


/*
 *  GetUSHORTField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
USHORT GetUSHORTField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    USHORT result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(USHORT), &result);
    if (dbgStat != 0){
        dprintf("\n GetUSHORTField: GetFieldData failed with %xh retrieving field '%s' of struct '%s', returning bogus field value %08xh.\n", dbgStat, FieldName, StructType, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);
        result = (USHORT)BAD_VALUE;
    }

    return result;
}


/*
 *  GetUCHARField
 *
 *      Return the field or -1 in case of error.
 *      Yes, it screws up if the field is actually -1.
 */
UCHAR GetUCHARField(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    UCHAR result;
    ULONG dbgStat;
    
    dbgStat = GetFieldData(StructAddr, StructType, FieldName, sizeof(UCHAR), &result);
    if (dbgStat != 0){
        dprintf("\n GetUCHARField: GetFieldData failed with %xh retrieving field '%s' of struct '%s', returning bogus field value %08xh.\n", dbgStat, FieldName, StructType, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);
        result = (UCHAR)BAD_VALUE;
    }

    return result;
}

ULONG64 GetFieldAddr(ULONG64 StructAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;

    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = StructAddr+offset;
    }
    else {
        dprintf("\n GetFieldAddr: GetFieldOffset failed with %xh retrieving offset of struct '%s' field '%s'.\n", dbgStat, StructType, FieldName);
        dprintf(g_genericErrorHelpStr);
        result = BAD_VALUE;
    }
    
    return result;
}


ULONG64 GetContainingRecord(ULONG64 FieldAddr, LPCSTR StructType, LPCSTR FieldName)
{
    ULONG64 result;
    ULONG offset;
    ULONG dbgStat;
    
    dbgStat = GetFieldOffset(StructType, FieldName, &offset);
    if (dbgStat == 0){
        result = FieldAddr-offset;
    }
    else {
        dprintf("\n GetContainingRecord: GetFieldOffset failed with %xh retrieving offset of struct '%s' field '%s', returning bogus address %08xh.\n", dbgStat, StructType, FieldName, BAD_VALUE);
        dprintf(g_genericErrorHelpStr);        
        result = BAD_VALUE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\stor\stordbgext.c ===
#include "pch.h"
#include "precomp.h"


PCHAR DeviceStateTable [] = {
        "Not Present",	// not present
	    "Working",	// working
	    "Stopped",	// stopped
	    "P-Stop",	// pending stop
	    "P-Remove",	// pending remove
	    "Surprise",	// surprise remove
        "Removed",  // removed
        "Invalid"   // invalid state
};


PCHAR SystemPowerTable [] = {
        "Unspecified",
        "Working",
        "Sleeping1",
        "Sleeping2",
        "Sleeping3",
        "Hibernate",
        "Shutdown",
        "Maximum",
        "Invalid"
};


PCHAR DevicePowerTable [] = {
        "Unspecified",
        "D0",
        "D1",
        "D2",
        "D3",
        "Maximum",
        "Invalid"
};


/*
char *SCSI6byteOpCode[] = {      
    "SCSI/TEST UNIT READY",
    "SCSI/REZERO UNIT",
    "SCSI/REQUEST BLOCK ADDRESS",
    "SCSI/REQUEST SENSE",
    "SCSI/FORMAT UNIT",
    "SCSI/READ BLOCK LIMITS",
    "SCSI/NO OPCODE",
    "SCSI/REASSIGN BLOCKS",
    "SCSI/READ (06)"
    "SCSI/INVALID",
    "SCSI/WRITE (06)",
    "SCSI/SEEK (06)",
    "SCSI/SEEK BLOCK",
    "SCSI/PARTITION",
    "SCSI/NO OPCODE",
    "SCSI/READ REVERSE",
    "SCSI/WRITE FILEMARKS",
    "SCSI/SPACE",
    "SCSI/INQUIRY",
    "SCSI/VERIFY (06)",
    "SCSI/RECOVER BUFFERED DATA",
    "SCSI/MODE SELECT(06)",
    "SCSI/RESERVE UNIT",
    "SCSI/RELEASE UNIT",
    "SCSI/COPY",
    "SCSI/ERASE",
    "SCSI/MODE SENSE(06)",
    "SCSI/START/STOP UNIT",
    "SCSI/RECEIVE DIAGNOSTIC",
    "SCSI/SEND DIAGNOSTIC",
    "SCSI/MEDIUM REMOVAL"
 };


char *SCSI10byteOpCode[] = {    
    "SCSI/READ FORMATTED CAPACITY", 
    "SCSI/NO OPCODE",
    "SCSI/READ CAPACITY",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/READ (10)",
    "SCSI/NO OPCODE",
    "SCSI/WRITE (10)",
    "SCSI/SEEK (10)",          
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/WRITE & VERIFY (10)",
    "SCSI/VERIFY (10)"
    "SCSI/SEARCH DATA HIGH (10)",
    "SCSI/SEARCH DATA EQUAL (10)",
    "SCSI/SEARCH DATA LOW (10)",
    "SCSI/SET LIMITS (10)",
    "SCSI/PRE-FETCH",
    "SCSI/SYNCHRONIZE CACHE",
    "SCSI/LOCK/UNLOCK CACHE",
    "SCSI/READ DEFECT DATA (10)",
    "SCSI/NO OPCODE",
    "SCSI/COMPARE",
    "SCSI/COPY & VERIFY",
    "SCSI/WRITE DATA BUFFER",
    "SCSI/READ DATA BUFFER",
    "SCSI/NO OPCODE",
    "SCSI/READ LONG",
    "SCSI/WRITE LONG",
    "SCSI/CHANGE DEFINITION",
    "SCSI/READ SUB-CHANNEL",
    "SCSI/READ TOC",
    "SCSI/READ HEADER",
    "SCSI/PLAY AUDIO (10)",
    "SCSI/GET CONFIGURATION",
    "SCSI/PLAY AUDIO MSF",
    "SCSI/PLAY TRACK INDEX",
    "SCSI/PLAY TRACK RELATIVE",
    "SCSI/GET EVENT STATUS",
    "SCSI/PAUSE/RESUME",
    "SCSI/LOG SELECT",
    "SCSI/LOG SENSE",
    "SCSI/STOP/PLAY SCAN",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/READ DISK INFORMATION",
    "SCSI/READ TRACK INFORMATION",
    "SCSI/RESERVE TRACK RZONE",
    "SCSI/SEND OPC INFORMATION",
    "SCSI/MODE SELECT (10)",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/MODE SENSE (10)",
    "SCSI/CLOSE TRACK SESSION",
    "SCSI/READ BUFFER CAPACITY",
    "SCSI/SEND CUE SHEET",
    "SCSI/PERSISTENT RESERVE IN",
    "SCSI/PERSISTENT RESERVE OUT"
};


char *SCSI12byteOpCode[] = {    
    "SCSI/REPORT LUNS",
    "SCSI/BLANK",
    "SCSI/NO OPCODE",
    "SCSI/SEND KEY",
    "SCSI/REPORT KEY",
    "SCSI/MOVE MEDIUM",
    "SCSI/LOAD/UNLOAD SLOT",
    "SCSI/SET READ AHEAD",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/READ DVD STRUCTURE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/NO OPCODE",
    "SCSI/REQUEST VOLUME ELEMENT ADDRESS",
    "SCSI/SEND VOLUME TAG",
    "SCSI/NO OPCODE",
    "SCSI/READ ELEMENT STATUS",
    "SCSI/READ CD MSF",
    "SCSI/SCAN CD",
    "SCSI/SET CD SPEED",
    "SCSI/PLAY CD",
    "SCSI/MECHANISM STATUS",
    "SCSI/READ CD"
    "SCSI/SEND DVD STRUCTURE",
    "SCSI/INIT ELEMENT RANGE",       
};


char *SCSIRequestBlockFunction[] = {
    "EXECUTE SCSI",
    "ABORT COMMAND",
    "RESET DEVICE",
    "RESET BUS",
    "TERMINATE IO",
    "RELEASE RECOVERY",
    "RECEIVE EVENT",
    "SHUTDOWN",
    "FLUSH",
    "IO CONTROL",
    "LOCK QUEUE",
    "UNLOCK QUEUE"
};
*/


char *SCSI6byteOpCode[] = {      /* 0x00 - 0x1E */
    "SCSI/TEST UNT RDY",
    "SCSI/REZERO UNIT ",
    "SCSI/REQ BLK ADDR",
    "SCSI/REQ SENSE   ",
    "SCSI/FORMAT UNIT ",
    "SCSI/RD BLK LMTS ",
    "SCSI/NO OPCODE   ",
    "SCSI/REASSGN BLKS",
    "SCSI/READ (06)   ",
    "SCSI/INVALID     ",
    "SCSI/WRITE (06)  ",
    "SCSI/SEEK (06)   ",
    "SCSI/SEEK BLOCK  ",
    "SCSI/PARTITION   ",
    "SCSI/NO OPCODE   ",
    "SCSI/READ REVERSE",
    "SCSI/WRTE FILEMKS",
    "SCSI/SPACE       ",
    "SCSI/INQUIRY     ",
    "SCSI/VERIFY (06) ",
    "SCSI/RECVR BUFFRD",
    "SCSI/MODE SEL(06)",
    "SCSI/RESERVE UNIT",
    "SCSI/RELEASE UNIT",
    "SCSI/COPY        ",
    "SCSI/ERASE       ",
    "SCSI/MOD SNSE(06)",
    "SCSI/STRT/STP UNT",
    "SCSI/RECV DIAGNOS",
    "SCSI/SEND DIAGNOS",
    "SCSI/MEDIUM REMVL"
 };


char *SCSI10byteOpCode[] = {    /* 0x23 - 0x5F */
    "SCSI/RD FRMTD CAP", 
    "SCSI/NO OPCODE   ",
    "SCSI/READ CAP    ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/READ (10)   ",
    "SCSI/NO OPCODE   ",
    "SCSI/WRITE (10)  ",
    "SCSI/SEEK (10)   ",          
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/WRT&VRF (10)",
    "SCSI/VERIFY (10) ",
    "SCSI/SC DT H (10)",
    "SCSI/SC DT E (10)",
    "SCSI/SC DT L (10)",
    "SCSI/ST LMTS (10)",
    "SCSI/PRE-FETCH   ",
    "SCSI/SYNC   CACHE",
    "SCSI/LCK/UN CACHE",
    "SCSI/RD DF D (10)",
    "SCSI/NO OPCODE   ",
    "SCSI/COMPARE     ",
    "SCSI/CPY & VERIFY",
    "SCSI/WRT DAT BUFF",
    "SCSI/RD DAT BUFF ",
    "SCSI/NO OPCODE   ",
    "SCSI/READ LONG   ",
    "SCSI/WRITE LONG  ",
    "SCSI/CHGE DEF    ",
    "SCSI/RD SUB-CHNL ",
    "SCSI/READ TOC    ",
    "SCSI/READ HEADER ",
    "SCSI/PLY AUD (10)",
    "SCSI/GET CONFIG  ",
    "SCSI/PLY AUD MSF ",
    "SCSI/PLY TRK INDX",
    "SCSI/PLY TRK REL ",
    "SCSI/GET EVT STAT",
    "SCSI/PAUSE/RESUME",
    "SCSI/LOG SELECT  ",
    "SCSI/LOG SENSE   ",
    "SCSI/STP/PLY SCAN",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/RD DSK INFO ",
    "SCSI/RD TRK INFO ",
    "SCSI/RSRV TRCK RZ",
    "SCSI/SND OPC INFO",
    "SCSI/MOD SEL (10)",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/MOD SNS (10)",
    "SCSI/CLS TRCK SES",
    "SCSI/RD BUFF CAP ",
    "SCSI/SND CUE SHT ",
    "SCSI/PRS RSRV IN ",
    "SCSI/PRS RSRV OUT"
};


char *SCSI12byteOpCode[] = {    /* 0xA0 - 0xBF, 0xE7 */
    "SCSI/REPORT LUNS ",
    "SCSI/BLANK       ",
    "SCSI/NO OPCODE   ",
    "SCSI/SEND KEY    ",
    "SCSI/REPORT KEY  ",
    "SCSI/MOVE MEDIUM ",
    "SCSI/LD/UNLD SLOT",
    "SCSI/SET RD AHEAD",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/RD DVD STRUC",
    "SCSI/NO OPCODE   ", 
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/NO OPCODE   ",
    "SCSI/REQ VOL ELMT",
    "SCSI/SEND VOL TAG",
    "SCSI/NO OPCODE   ",
    "SCSI/RD ELMT STAT",
    "SCSI/READ CD MSF ",
    "SCSI/SCAN CD     ",
    "SCSI/SET CD SPEED",
    "SCSI/PLAY CD     ",
    "SCSI/MECHNSM STAT",
    "SCSI/READ CD     ",
    "SCSI/SND DVD STRC",
    "SCSI/INIT ELM RNG",       /* 0xE7 */
};


char *SCSIRequestBlockFunction[] = {
    "EXECUTE SCSI     ",
    "ABORT COMMAND    ",
    "RESET DEVICE     ",
    "RESET BUS        ",
    "TERMINATE IO     ",
    "RELEASE RECOVERY ",
    "RECEIVE EVENT    ",
    "SHUTDOWN         ",
    "FLUSH            ",
    "IO CONTROL       ",
    "LOCK QUEUE       ",
    "UNLOCK QUEUE     "
};







VOID
FixString (
    PSZ Id
    )

{
    ULONG Pos;

    Pos = strlen(Id);
    if (Pos > 0) {
        Pos--;
    }

    while ( (Pos > 0) && (Id[Pos] == ' ') ) {
        Id[Pos]='\0';
        Pos--;
    }
}


VOID
GetUnitProductInfo (
    IN ULONG64 UnitExtension,
    PSZ VendorId,
    PSZ ProductId
    )

{
    ULONG64 UnitInfoPtr;
    ULONG64 UnitInfo;
    ULONG offset;
    
    
    ZeroMemory(VendorId, 9);
    ZeroMemory(ProductId, 17);
    if (!GetFieldOffset("storport!RAID_UNIT_EXTENSION", "Identity", &offset)) {
        UnitInfoPtr = UnitExtension + offset;
        if (!GetFieldOffset("storport!STOR_SCSI_IDENTITY", "InquiryData", &offset)) {
            UnitInfoPtr = UnitInfoPtr + offset;
            ReadPointer(UnitInfoPtr, &UnitInfo);
            if (GetFieldData(UnitInfo, "storport!INQUIRYDATA", "VendorId", 8, VendorId)) {
                dprintf("ERROR: Unable to retrieve VendorId field\n");
            }
            if (GetFieldData(UnitInfo, "storport!INQUIRYDATA", "ProductId", 16, ProductId)) {
                dprintf("ERROR: Unable to retrieve ProductId field\n");
            }
            FixString(VendorId);
            FixString(ProductId);
        }
        else {
            dprintf("ERROR: Unable to retrieve InquiryData offset\n");
        }
    }
    else {
        dprintf("ERROR: Unable to retrieve Identity offset\n");
    }
}


VOID
PrintAddressList (
    IN ULONG64 Address
    )

{ 
    if (IsPtr64()) {
        dprintf("%16.16x  ", Address);
    }
    else {
        dprintf("%8.8x  ", Address);
    }
}


VOID
PrintCommand (
    IN UCHAR Command
    )

{
    UCHAR Index;

    if ((Command >= 0x00) && (Command <= 0x1E)) {
        Index = Command;
        dprintf("%s ", SCSI6byteOpCode[Index]); 
        return;
    }
    if ((Command >= 0x23) && (Command <= 0x5F)) {
        Index = Command - 0x23;
        dprintf("%s ", SCSI10byteOpCode[Index]);
        return;
    }
    if ((Command >= 0xA0) && (Command <= 0xBF)) {
        Index = Command - 0xA0;
        dprintf("%s ", SCSI12byteOpCode[Index]); 
        return;
    }
    if (Command == 0xE7) {
        dprintf("%s ", SCSI12byteOpCode[32]); 
        return;
    }
    dprintf("NO OPCODE         ");
    return;
}


VOID
PrintAddress (
    IN PSZ Name,
    IN ULONG64 Address
    )

{
    if (IsPtr64()) {
        dprintf("%s %16.16x   ", Name, Address);
    }
    else {
        dprintf("%s %8.8x   ", Name, Address);
    }
}


ULONG64
ContainingRecord (
        IN ULONG64  Object,
        IN PSZ Type,
        IN PSZ Field
        )

{
    ULONG offset;

    
    if (GetFieldOffset(Type, Field, &offset)) {
        return 0;
    }
    else {
        return (Object - offset);
    }
}


BOOLEAN
CheckRaidObject (
    IN ULONG64 Object,
    IN RAID_OBJECT_TYPE Type
    )

{
    RAID_OBJECT_TYPE RetType;

    if (GetFieldValue(Object, "storport!RAID_COMMON_EXTENSION", "ObjectType", RetType )) {
        return FALSE;
    }
    else if (Type != RetType) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
IsDeviceObject (
    IN ULONG64 address
    )

{
    CSHORT Type;

    if (GetFieldValue(address, "storport!DEVICE_OBJECT", "Type", Type)) {
        return FALSE;
    }
    else {
        return (Type == IO_TYPE_DEVICE);
    }
}


ULONG64
GetExtension (
    IN ULONG64 address,
    IN RAID_OBJECT_TYPE Object
    )

{
    ULONG64 Extension;
    ULONG64 DeviceObject;
    ULONG64 temp;
    ULONG offset;
    
    if (CheckRaidObject(address, Object)) {
        Extension = address;
        if (Object == RaidAdapterObject) {
            InitTypeRead(Extension, storport!RAID_ADAPTER_EXTENSION);
        }
        else if (Object == RaidUnitObject) {
            InitTypeRead(Extension, storport!RAID_UNIT_EXTENSION);
        }

        DeviceObject = ReadField(DeviceObject);
        
        if (IsDeviceObject(DeviceObject)) {
            if (GetFieldOffset("storport!DEVICE_OBJECT", "DeviceExtension", &offset)) {
                dprintf("ERROR: Unable to retrieve Device Extension offset\n");
                temp = 0;
            }
            else {
                ReadPointer(DeviceObject + offset, &temp);
            }
            
            if (temp == Extension) {
                return Extension;
            }
        }
    }

    DeviceObject = address;            
    if (IsDeviceObject(DeviceObject)) {
        if (GetFieldOffset("storport!DEVICE_OBJECT", "DeviceExtension", &offset)) {
            dprintf("ERROR: Unable to retrieve Device Extension offset\n");
            Extension = 0;
        }
        else {
            ReadPointer(DeviceObject + offset, &Extension);
        }

        if (CheckRaidObject(Extension, Object)) {
            if (Object == RaidAdapterObject) {
                InitTypeRead(Extension, storport!RAID_ADAPTER_EXTENSION);
            }
            else if (Object == RaidUnitObject) {
                InitTypeRead(Extension, storport!RAID_UNIT_EXTENSION);
            }
            DeviceObject = ReadField(DeviceObject);
            
            if (DeviceObject == address) {
                return Extension;
            }
        }
    }
    else {
        dprintf("ERROR: Invalid Device Object\n");
    }

    return 0;
}


PCHAR
DeviceStateToString (
    IN ULONG State
    )

{
    if (State > 6) {
        return DeviceStateTable[7];
    }

    return DeviceStateTable[State];
}


PCHAR
SystemPower (
    IN ULONG State
    )

{
    if (State > 7) {
        return SystemPowerTable[8];
    }

    return SystemPowerTable[State];
}


PCHAR
DevicePower (
    IN ULONG State
    )

{
    if (State > 5) {
        return DevicePowerTable[6];
    }

    return DevicePowerTable[State];
}


ULONG
GetRemLockCount (
    IN ULONG64 Object,
    IN PSZ Type,
    IN PSZ Field
    )

{
    ULONG64 address;
    ULONG offset;
    ULONG IOCount;
    
    IOCount = -1;

    if (!GetFieldOffset(Type, Field, &offset)) {
        address = Object + offset;
        if (!GetFieldOffset("storport!IO_REMOVE_LOCK", "Common", &offset)) {
            address = address + offset;
            GetFieldValue(address,"storport!IO_REMOVE_LOCK_COMMON_BLOCK", "IoCount", IOCount);
        }
    }
    return IOCount;
}


VOID
dindentf(
    IN ULONG Depth
    )

{
    ULONG i;
    
    for (i = 1; i <= Depth; i++) {
        dprintf("   ");
    }
}


VOID
DumpQueuedRequests (
    IN ULONG64 DeviceQueue
    )

{
    ULONG64 ListHead;
    ULONG64 NextRequest;
    ULONG64 IRP;
    ULONG64 StackLocation;
    ULONG64 SRB;
    ULONG offset;
    ULONG CommandLength;
    ULONG TimeOut;
    UCHAR Command;
    UCHAR SrbFunction;
    
    if (GetFieldOffset("storport!EXTENDED_DEVICE_QUEUE", "DeviceListHead", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return;
    }

    ListHead = DeviceQueue + offset;

    for (GetFieldValue(ListHead, "storport!LIST_ENTRY", "Flink", NextRequest); NextRequest != 0 && NextRequest != ListHead; GetFieldValue(NextRequest, "storport!LIST_ENTRY", "Flink", NextRequest)) {
        IRP = ContainingRecord(NextRequest, "storport!IRP", "Tail.Overlay.DeviceQueueEntry.DeviceListEntry");
        dprintf("Queued  ");
        PrintAddressList(IRP);
        
        if (GetFieldOffset("storport!IRP", "Tail.Overlay.CurrentStackLocation", &offset)) {
            dprintf("ERROR: Unable to retrieve Current Stack Location offset\n");
            return;
        }
        StackLocation = IRP + offset;
        ReadPtr(StackLocation, &StackLocation);

        if (GetFieldOffset("storport!IO_STACK_LOCATION", "Parameters.Scsi.Srb", &offset)) {
            dprintf("ERROR: Unable to retrieve Srb offset\n");
            return;
        }
        SRB = StackLocation + offset;
        ReadPtr(SRB, &SRB);
        PrintAddressList(SRB);

        dprintf("  n/a     ");

        if (GetFieldOffset("storport!SCSI_REQUEST_BLOCK", "Function", &offset)) {
                dprintf("ERROR: Unable to retrieve Function offset\n");
                return;
        }
        else {
            GetFieldValue(SRB, "storport!SCSI_REQUEST_BLOCK", "Function", SrbFunction);
            if (SrbFunction == 0x00) {
                if (GetFieldOffset("storport!SCSI_REQUEST_BLOCK", "Cdb", &offset)) {
                    dprintf("ERROR: Unable to retrieve Command Block offset\n");
                    return;
                }
                ReadMemory(SRB + offset, &Command, 2, NULL);     
                PrintCommand(Command);
            }
            else {
                if ((SrbFunction >= 0x00) && (SrbFunction <= 0x0b)) {
                    dprintf("%s  ", SCSIRequestBlockFunction[SrbFunction]); 
                }
            }
        }

        
        InitTypeRead(IRP, storport!IRP);
        PrintAddressList(ReadField(MdlAddress));
        dprintf("  n/a     ");


        GetFieldValue(SRB, "Storport!SCSI_REQUEST_BLOCK", "TimeOutValue", TimeOut);
        dprintf("%d\n", TimeOut);
    }
}


VOID
DumpOutstdCompltdRequests (
    IN ULONG64 UnitExtension
    )

{
    ULONG64 AdapterExtension;
    ULONG64 address;
    ULONG64 NextRequest;
    ULONG64 Xrb;
    ULONG64 Srb;
    ULONG64 LastOutstdXrb;
    ULONG64 ptr;
    ULONG offset;
    ULONG TimeOut;
    ULONG CommandLength;
    UCHAR SrbFunction;
    BOOLEAN Ret;
    UCHAR Command;

    
    if (!GetFieldValue(UnitExtension, "storport!RAID_UNIT_EXTENSION", "Adapter", AdapterExtension)) {
        if (!GetFieldOffset("storport!RAID_ADAPTER_EXTENSION", "CompletedList", &offset)) {
            address = AdapterExtension + offset;
            if (!GetFieldOffset("storport!SLIST_HEADER", "Next", &offset)) {
                address = address + offset;
                GetFieldValue(address, "storport!SINGLE_LIST_ENTRY", "Next", ptr);
                while (ptr != 0) {
                    LastOutstdXrb = ptr;
                    GetFieldValue(LastOutstdXrb, "storport!SINGLE_LIST_ENTRY", "Next", ptr);
                }
                LastOutstdXrb = ContainingRecord(LastOutstdXrb, "storport!EXTENDED_REQUEST_BLOCK", "CompletedLink");
            }
            else {
                LastOutstdXrb = 0;
            }
        }
        else {
            LastOutstdXrb = 0;
        }
    }
    else {
        dprintf("ERROR: Unable to retrieve Adapter Extension\n");
        return;
    }
    
    if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "PendingQueue", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return;
    }
    
    address = UnitExtension + offset;

    if (GetFieldOffset("storport!STOR_EVENT_QUEUE", "List", &offset)) {
        dprintf("ERROR: Unable to retrieve PendingQueue offset\n");
        return;
    }

    address = address + offset;

    dprintf("\n");
  
    dprintf("Type    IRP       SRB       XRB       Command           MDL       SGList    TO\n");
    dprintf("------------------------------------------------------------------------------\n");

    for (GetFieldValue(address, "storport!LIST_ENTRY", "Flink", NextRequest); NextRequest != 0 && NextRequest != address; GetFieldValue(NextRequest, "storport!LIST_ENTRY", "Flink", NextRequest)) {
        Xrb = ContainingRecord(NextRequest, "storport!EXTENDED_REQUEST_BLOCK", "PendingLink.NextLink");
        
        InitTypeRead(Xrb, storport!EXTENDED_REQUEST_BLOCK);
        if ((ULONG)ReadField(Signature) == 0x1F2E3D4CUL) {
            if (!ReadField(CompletedLink.Next)) {
                if (Xrb == LastOutstdXrb) {
                    dprintf("Cmpltd  ");
                } 
                else {
                    dprintf("Outstd  ");
                }
            }
            else {
                dprintf("Cmpltd  ");
            }

            PrintAddressList(ReadField(Irp));
            Srb = ReadField(Srb);
            PrintAddressList(Srb);
            PrintAddressList(Xrb);
            
            if (GetFieldOffset("storport!SCSI_REQUEST_BLOCK", "Function", &offset)) {
                dprintf("ERROR: Unable to retrieve Function offset\n");
                return;
            }
            else {
                GetFieldValue(Srb, "storport!SCSI_REQUEST_BLOCK", "Function", SrbFunction);
                if (SrbFunction == 0x00) {
                    if (GetFieldOffset("storport!SCSI_REQUEST_BLOCK", "Cdb", &offset)) {
                        dprintf("ERROR: Unable to retrieve Command Block offset\n");
                        return;
                    }
                    ReadMemory(Srb + offset, &Command, 2, NULL);      
                    PrintCommand(Command);

                }
                else {
                    if ((SrbFunction >= 0x00) && (SrbFunction <= 0x0b)) {
                        dprintf("%s  ", SCSIRequestBlockFunction[SrbFunction]); 
                    }
                }
            }
            PrintAddressList(ReadField(Mdl));
            PrintAddressList(ReadField(SgList));
            GetFieldValue(Srb, "Storport!SCSI_REQUEST_BLOCK", "TimeOutValue", TimeOut);
            dprintf("%d\n", TimeOut);

        }
    }
}


VOID
DumpUnit (
    IN ULONG64 address,
    IN ULONG Level,
    IN ULONG Depth
    )

{
    ULONG64 UnitExtension;
    ULONG64 VirtualBase;
    ULONG64 QueueTagList;
    ULONG64 IoQueue;
    ULONG64 DeviceQueue;
    ULONG offset;
    ULONG RemLock_IOCount;
    UCHAR VendorId[9];
    UCHAR ProductId[17];
    PSZ SlowLock;

    UnitExtension = GetExtension(address, RaidUnitObject);

    if (UnitExtension == 0) {
        dprintf("ERROR: Unable to retrieve Unit Extension address\n");
        return;
    }

    InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);

    if (Level == 0) {
        GetUnitProductInfo(UnitExtension, VendorId, ProductId);
            
        dindentf(Depth);
        if (!GetFieldOffset("storport!RAID_UNIT_EXTENSION", "Address", &offset)) {
            InitTypeRead(UnitExtension + offset, storport!STOR_SCSI_ADDRESS);
        }
        else {
            dprintf("ERROR: Unable to retrieve STOR_SCSI_ADDRESS structure offset\n");
        }
        dprintf("%-10s %-10s   %d %d %d    ", VendorId, ProductId, (ULONG)ReadField(PathId), (ULONG)ReadField(TargetId), (ULONG)ReadField(Lun));
        InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);
        PrintAddressList(ReadField(DeviceObject));
        PrintAddressList(UnitExtension);
           
        if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "IoQueue", &offset)) {
            dprintf("ERROR: Unable to retrieve IoQueue offset\n");
            return;
        }
        IoQueue = UnitExtension + offset;
        if (GetFieldOffset("storport!IO_QUEUE", "DeviceQueue", &offset)) {
            dprintf("ERROR: Unable to retreive DeviceQueue offset\n");
            return;
        }
        DeviceQueue = IoQueue + offset;

        InitTypeRead(DeviceQueue, storport!EXTENDED_DEVICE_QUEUE);

        dprintf("    %d %d %d  ",(ULONG)ReadField(OutstandingRequests), (ULONG)ReadField(DeviceRequests), (ULONG)ReadField(ByPassRequests));
        
        InitTypeRead(UnitExtension, storport!RAID_UNIT_EXTENSION);
        dprintf("  %s\n", DeviceStateToString((ULONG)ReadField(DeviceState))); 
    }
    else {
        dprintf("LUN\n");
        Depth++;
        dindentf(Depth);
        PrintAddress("DO", ReadField(DeviceObject));
        PrintAddress("Ext", UnitExtension);
        PrintAddress("Adapter", ReadField(Adapter));
        dprintf("%s\n", DeviceStateToString((ULONG)ReadField(DeviceState)));
        GetUnitProductInfo(UnitExtension, VendorId, ProductId);
            
        dindentf(Depth);
        dprintf("Vendor: %s   Product: %s   SCSI ID: (%d, %d, %d)   %c %c %c %c\n", VendorId, ProductId, (ULONG)ReadField(PathId), (ULONG)ReadField(TargetId), (ULONG)ReadField(Lun), (ReadField(Flags.DeviceClaimed) ? 'c' : ' '), (ReadField(Flags.QueueFrozen) ? 'f' : ' '), (ReadField(Flags.QueueLocked) ? 'l' : ' '), (ReadField(Flags.Enumerated) ? 'e' : ' '));

        SlowLock = ReadField(SlowLock) ? "Held" : "Free";
        RemLock_IOCount = GetRemLockCount(UnitExtension, "storport!RAID_UNIT_EXTENSION", "RemoveLock");
        dindentf(Depth);
        dprintf("SlowLock %s   RemLock %d   PageCount %d\n", SlowLock, RemLock_IOCount, (ULONG)ReadField(PagingPathCount));

        VirtualBase = ReadField(SrbExtensionRegion.VirtualBase);
        dindentf(Depth);
        PrintAddress("SrbExtensionRegion (Virtual Base)", VirtualBase);
        dprintf("(%d bytes)\n", (ULONG)ReadField(SrbExtensionRegion.Length));

        if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "TagList", &offset)) {
            dprintf("ERROR: Unable to retrieve TagList offset\n");
            return;
        }
        QueueTagList = UnitExtension + offset;

        dindentf(Depth);
        PrintAddress("QueueTagList:", QueueTagList);
        dprintf("(%d of %d used)\n", (ULONG)ReadField(TagList.OutstandingTags), (ULONG)ReadField(TagList.Count));

        if (GetFieldOffset("storport!RAID_UNIT_EXTENSION", "IoQueue", &offset)) {
            dprintf("ERROR: Unable to retrieve IoQueue offset\n");
            return;
        }
        IoQueue = UnitExtension + offset;
        if (GetFieldOffset("storport!IO_QUEUE", "DeviceQueue", &offset)) {
            dprintf("ERROR: Unable to retreive DeviceQueue offset\n");
            return;
        }
        DeviceQueue = IoQueue + offset;

        dindentf(Depth);
        dprintf("IOQueue: %s %s %s %s \n", (ReadField(Flags.DeviceClaimed) ? "Claimed" : ""), (ReadField(Flags.QueueFrozen) ? "Frozen" : ""), (ReadField(Flags.QueueLocked) ? "Locked" : ""), (ReadField(Flags.Enumerated) ? "Enumrated" : ""));
    
        InitTypeRead(DeviceQueue, storport!EXTENDED_DEVICE_QUEUE);

        dindentf(Depth);
        PrintAddress("DeviceQueue", DeviceQueue);
        dprintf("\n");
        dindentf(Depth);
        dprintf("Requests: Outstanding %d   Device %d   ByPass %d\n", (ULONG)ReadField(OutstandingRequests), (ULONG)ReadField(DeviceRequests), (ULONG)ReadField(ByPassRequests));

        DumpOutstdCompltdRequests(UnitExtension);
        DumpQueuedRequests(DeviceQueue);

    }
}


VOID
ListAdapterUnits(
    IN ULONG64 AdapterExtension,
    IN ULONG Level,
    IN ULONG Depth
    )

{
    ULONG64 Units;
    ULONG64 NextUnit;
    ULONG64 UnitExtension;

    ULONG offset;

    if (!GetFieldOffset("storport!RAID_ADAPTER_EXTENSION", "UnitList.List", &offset)) {
        Units = AdapterExtension + offset;
    }
    else {
        dprintf("ERROR: Unable to retrieve Unit List offset\n");
        return;
    }

    for (GetFieldValue(Units, "storport!LIST_ENTRY", "Flink", NextUnit); NextUnit != 0 && NextUnit != Units; GetFieldValue(NextUnit, "storport!LIST_ENTRY", "Flink", NextUnit)) {
        UnitExtension = ContainingRecord(NextUnit, "storport!RAID_UNIT_EXTENSION", "NextUnit");

        if (!CheckRaidObject(UnitExtension, RaidUnitObject)) {
                dprintf("ERROR: Invalid RAID unit object\n");
                return;
        }

        DumpUnit(UnitExtension, 0, Depth); 
    }
}


VOID
DumpAdapter (
    IN ULONG64 address,
    IN ULONG Level,
    IN ULONG Depth
    )

{
    ULONG64 AdapterExtension;
    ULONG64 DriverNameBuffer;
    ULONG64 DriverNameLength;
    ULONG64 DriverObject;
    ULONG64 MiniportObject;
    ULONG64 HwInitData;
    ULONG64 HwDeviceExt;
    CHAR NameBuffer[512];
    PSZ SlowLock;
    ULONG RemLock;
    ULONG offset;
    ULONG debugtemp;
    ULONG debugoffset;
    
    AdapterExtension = GetExtension(address, RaidAdapterObject);
    if (AdapterExtension == 0) {
        dprintf("ERROR: Unable to retrieve Adapter Extension address\n");
        return;
    }

    InitTypeRead (AdapterExtension, storport!RAID_ADAPTER_EXTENSION);

    if (Level == 0) {
        if (GetFieldValue(ReadField(Driver), "storport!RAID_DRIVER_EXTENSION", "DriverObject", DriverObject)) {
            dprintf("ERROR: Unable to retrieve Driver Extension address\n");
            return;
        }   

        GetFieldValue(DriverObject, "storport!DRIVER_OBJECT", "DriverName.Buffer", DriverNameBuffer);
        GetFieldValue(DriverObject, "storport!DRIVER_OBJECT", "DriverName.Length", DriverNameLength);
        ReadMemory(DriverNameBuffer, (PVOID)NameBuffer, (ULONG)DriverNameLength*sizeof(WCHAR), NULL);
        
        dprintf("%-20S   ", NameBuffer);
        PrintAddressList(ReadField(DeviceObject));
        PrintAddressList(AdapterExtension);
        dprintf(" %s\n", DeviceStateToString((ULONG)ReadField(DeviceState)));
    }
    else {
        dprintf("ADAPTER\n");
        Depth++;
        dindentf(Depth);
        PrintAddress("DO", ReadField(DeviceObject));
        PrintAddress("Ext", AdapterExtension);
        PrintAddress("Driver", ReadField(Driver));
        dprintf("%s\n", DeviceStateToString((ULONG)ReadField(DeviceState)));
        
        dindentf(Depth);
        PrintAddress("LDO", ReadField(LowerDeviceObject));
        PrintAddress("PDO", ReadField(PhysicalDeviceObject)); 
        dprintf("\n");
        
        SlowLock = ReadField(SlowLock) ? "Held" : "Free";
        RemLock = GetRemLockCount(AdapterExtension, "storport!RAID_ADAPTER_EXTENSION", "RemoveLock");

        dindentf(Depth);
        dprintf("SlowLock %s   RemLock %d   \n", SlowLock, RemLock);
        
        dindentf(Depth);
        dprintf("Power: %s %s   %s\n",SystemPower((ULONG)ReadField(Power.SystemState)), 
                                      DevicePower((ULONG)ReadField(Power.DeviceState)), 
                (ReadField(IoModel) == StorSynchronizeFullDuplex ? "Full Duplex" : "Half Duplex")); 
        
        dindentf(Depth);
        dprintf("Bus %d   Slot %d   ", (ULONG)ReadField(BusNumber), (ULONG)ReadField(SlotNumber));
        PrintAddress("DMA", ReadField(Dma.DmaAdapter));
        PrintAddress("Interrupt", ReadField(Interrupt));
        dprintf("\n");

        dindentf(Depth);
        PrintAddress("ResourceList: Allocated", ReadField(ResourceList.AllocatedResources));
        PrintAddress("Translated", ReadField(ResourceList.TranslatedResources));
        
        dprintf("\n");
        dindentf(Depth);
        dprintf("Gateway: Outstanding %d   Lower %d   High %d\n", 
                (ULONG)ReadField(Gateway.Outstanding), 
                (ULONG)ReadField(Gateway.LowWaterMark), 
                (ULONG)ReadField(Gateway.HighWaterMark));
        
        GetFieldOffset("storport!RAID_ADAPTER_EXTENSION", "Miniport", &offset);
        MiniportObject = AdapterExtension + offset;
        InitTypeRead(MiniportObject, storport!RAID_MINIPORT);

        HwInitData = ReadField(HwInitializationData);
        GetFieldOffset("storport!RAID_MINIPORT", "PortConfiguration", &offset);
        
        dindentf(Depth);
        PrintAddress("PortConfigInfo", (MiniportObject + offset));
        dprintf("\n");
        
        dindentf(Depth);
        PrintAddress("HwInit", HwInitData);
        HwDeviceExt = ReadField(PrivateDeviceExt);
        if (!GetFieldOffset("storport!RAID_HW_DEVICE_EXT", "HwDeviceExtension", &offset)) {
            HwDeviceExt = HwDeviceExt + offset;
        }
        else {
            HwDeviceExt = 0;
        }
        PrintAddress("HwDeviceExt", HwDeviceExt);

        InitTypeRead(HwInitData, storport!HW_INITIALIZATION_DATA);
        
        dprintf("(%d bytes)\n", (ULONG)ReadField(DeviceExtensionSize));

        dindentf(Depth);
        dprintf("SrbExt %d bytes   LUExt %d bytes\n", 
                (ULONG)ReadField(SrbExtensionSize), 
                (ULONG)ReadField(SpecificLuExtensionSize));

        dindentf(Depth);
        dprintf("Logical Units: \n");
        dprintf("\n");
        dindentf(Depth);
        dprintf("Product                 SCSI ID  Object    Extension  Reqs Q\\O\\C  State\n");
        dindentf(Depth);
        dprintf("----------------------------------------------------------------------------\n");


        
        ListAdapterUnits(AdapterExtension, Level, Depth);

    }
}


VOID
ListGeneral (
    IN ULONG Level,
    IN ULONG Depth,
    IN CHAR Type
    )

{
    ULONG64 address;
    ULONG64 Drivers;
    ULONG64 Adapters;
    ULONG64 PortData;
    ULONG64 NextDriver;
    ULONG64 NextAdapter;
    ULONG64 DriverExtension;
    ULONG64 AdapterExtension;
    ULONG   offset;

    address = GetExpression("storport!RaidpPortData");
    if ((address != 0)) {
        ReadPointer(address, &PortData);
        if (!GetFieldOffset("storport!RAID_PORT_DATA", "DriverList.List", &offset)) {
            Drivers = PortData + offset;
        }
        else {
            dprintf("ERROR: Unable to retrieve Driver List offset\n");
            return;
        }
    }
    else {
        dprintf("ERROR: Unable to lookup RAID_PORT_DATA structure\n");
        return;
    }

    for (GetFieldValue(Drivers, "storport!LIST_ENTRY", "Flink", NextDriver); NextDriver != 0 && NextDriver != Drivers; GetFieldValue(NextDriver, "storport!LIST_ENTRY", "Flink", NextDriver)) {
        DriverExtension = ContainingRecord(NextDriver, "storport!RAID_DRIVER_EXTENSION", "DriverLink");

        if (!CheckRaidObject(DriverExtension, RaidDriverObject)) {
            dprintf("ERROR: Not a valid RAID Driver Object\n");
            return;
        }

        if (!GetFieldOffset("storport!RAID_DRIVER_EXTENSION", "AdapterList.List", &offset)) {
            Adapters = DriverExtension + offset;
        }
        else {
            dprintf("ERROR: Unable to retrieve Adapter List offset\n");
            return; 
        }

        if (Type == 'A') {
            dprintf("Driver                 Object    Extension  State\n");
            dprintf("----------------------------------------------------\n");
        }
        else if (Type == 'U') {
            dprintf("Product                 SCSI ID  Object    Extension  Reqs Q\\O\\C  State\n");
            dprintf("----------------------------------------------------------------------------\n");
        }

        
        for (GetFieldValue(Adapters, "storport!LIST_ENTRY", "Flink", NextAdapter); NextAdapter != 0 && NextAdapter != Adapters; NextAdapter = GetFieldValue(NextAdapter, "storport!LIST_ENTRY", "Flink", NextAdapter) ) {
            AdapterExtension = ContainingRecord(NextAdapter, "storport!RAID_ADAPTER_EXTENSION", "NextAdapter");
            if (!CheckRaidObject(AdapterExtension, RaidAdapterObject)) {
                dprintf("ERROR: Not a valid RAID Adapter Object\n");
                return;
            }
            
            if (Type == 'A') {
                DumpAdapter(AdapterExtension, Level, Depth);
            }
            else if (Type == 'U') {
                ListAdapterUnits(AdapterExtension, Level, Depth);
            }
            else {
                dprintf("ERROR: Wrong Type\n");
                return;
            }
        }
    }
}


__inline BOOL
GetHelpExpressionEx(
    PCSTR Expression,
    PCSTR* Command
    )
{
    if (Expression[0] != '\0' ) {
        *Command = Expression;
        return TRUE;
    }

    return FALSE;
}


DECLARE_API (help)

{
    PCSTR command;
    
    if(GetHelpExpressionEx(args, &command)) {
        if ((strcmp(command, "adapter") == 0) || (strcmp(command, "Adapter") == 0)) {
            dprintf("\nNAME: \n");
            dprintf("\t!storkd.adapter\n");
            dprintf("\nUSAGE: \n");
            dprintf("\t!adapter [ADAPTER-OBJECT]\n");
            dprintf("\nARGUMENTS: \n");
            dprintf("\tADAPTER-OBJECT - pointer to a device object or an adapter extension\n");
            dprintf("\tfor a given unit.  If no ADAPTER-OBJECT is specified, all STOR adapters\n");
            dprintf("\tused in the system are listed.\n");

            return S_OK;
        }
        else if ((strcmp(command, "unit") == 0) || (strcmp(command, "UNIT") == 0) || (strcmp(command, "Unit") == 0)) {
            dprintf("\nNAME: \n");
            dprintf("\t!storkd.unit\n");
            dprintf("\nUSAGE: \n");
            dprintf("\t!lun [UNIT-OBJECT]\n");
            dprintf("\nARGUMENTS: \n");
            dprintf("\tUNIT-OBJECT - pointer to a device object or an unit extension for a\n");
            dprintf("\tgiven logical unit.  If no UNIT-OBJECT is specified, all STOR logical\n");
            dprintf("\tunits used in the system is listed.\n");

            return S_OK;
        }
        else if ((strcmp(command, "help") == 0) || (strcmp(command, "HELP") == 0) || (strcmp(command, "Help") == 0)) {
            dprintf("\nNAME: \n");
            dprintf("\t!storkd.help\n");
            dprintf("\nUSAGE: \n");
            dprintf("\t!help [COMMAND]\n");
            dprintf("\nARGUMENTS: \n");
            dprintf("\tCOMMAND - command name.\n");

            return S_OK;
        }
        else {
            dprintf ("\nERROR: INVALID COMMAND\n");

            return S_OK;
        }
    }
    else {
        dprintf("\n!adapter               - list all adapters with summary information\n");
        dprintf("!adapter <address>     - provide detailed information about the adapter\n");
        dprintf("                         identified by its device object or device extension\n");
        dprintf("                         address\n");
        dprintf("!unit                  - list all logical units with summary information\n");
        dprintf("!unit <address>        - provide detailed information about the logical unit\n");
        dprintf("                         identified by its device object or device extension\n");
        dprintf("                         address\n");
        dprintf("!help                  - list commands with description\n");
        dprintf("\n");
    
        return S_OK;
    }
}


DECLARE_API (adapter)

{
    ULONG64 address;

    if (GetExpressionEx(args, &address, &args)) {
        DumpAdapter(address, 1, 0);
    }
    else {
        ListGeneral(0, 0, 'A');
    }
    return S_OK;
}


DECLARE_API (unit)

{
    ULONG64 address;

    if (GetExpressionEx(args, &address, &args)) {
        DumpUnit(address, 1, 0);
    }
    else {
        ListGeneral(0, 0, 'U');

    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\kdext\scsikd\scsikd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       scsikd.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\class\mchgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    mchgr.h

Abstract:

    SCSI Medium Changer class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#ifndef _MCHGR_H_
#define _MCHGR_H_

#include "stdarg.h"
#include "ntddk.h"
#include "mcd.h"

#include "initguid.h"
#include "ntddstor.h"

#include <wmidata.h>
#include <wmistr.h>
#include <stdarg.h>

//
// WMI guid list for changer.
//
extern GUIDREGINFO ChangerWmiFdoGuidList[];

//
// Changer class device extension
//
typedef struct _MCD_CLASS_DATA {
    LONG          DeviceOpen;

    UNICODE_STRING MediumChangerInterfaceString;

    BOOLEAN       DosNameCreated;

} MCD_CLASS_DATA, *PMCD_CLASS_DATA;


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  );

NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
ChangerReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// WMI routines
//
NTSTATUS
ChangerFdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
ChangerFdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
ChangerFdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ChangerFdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ChangerFdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ChangerWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );

#endif // _MCHGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\class\mcdw2k.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    mcd.h

Abstract:

    These are the structures and defines that are used in the
    changer class drivers. The changer class driver is separated
    into two modules. Mcd.c contains code common to all medium
    changer drivers including the driver's major entry points.

Author:

    chuckp (Chuck Park)

Environment:

    Kernel mode

Revision History :

--*/


#include "scsi.h"
#include "ntddchgr.h"
#include <classpnp.h>

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) MCDebugPrint x
#else
#define DebugPrint(x)
#endif


VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define MAXIMUM_CHANGER_INQUIRY_DATA 252

typedef struct _MODE_ELEMENT_ADDRESS_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransportElementAddress[2];
    UCHAR NumberTransportElements[2];
    UCHAR FirstStorageElementAddress[2];
    UCHAR NumberStorageElements[2];
    UCHAR FirstIEPortElementAddress[2];
    UCHAR NumberIEPortElements[2];
    UCHAR FirstDataXFerElementAddress[2];
    UCHAR NumberDataXFerElements[2];
    UCHAR Reserved2[2];

} MODE_ELEMENT_ADDRESS_PAGE, *PMODE_ELEMENT_ADDRESS_PAGE;

typedef struct _MODE_TRANSPORT_GEOMETRY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR Flip : 1;
    UCHAR Reserved2: 7;
    UCHAR TransportElementNumber;

} MODE_TRANSPORT_GEOMETRY_PAGE, *PMODE_TRANSPORT_GEOMETRY_PAGE;

//
// Capabilities page decribes the various functions that the device
// supports. Used in GetParameters.
//

typedef struct _MODE_DEVICE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransport : 1;
    UCHAR StorageLocation : 1;
    UCHAR IEPort : 1;
    UCHAR DataXFer : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR MTtoMT : 1;
    UCHAR MTtoST : 1;
    UCHAR MTtoIE : 1;
    UCHAR MTtoDT : 1;
    UCHAR Reserved4 : 4;
    UCHAR STtoMT : 1;
    UCHAR STtoST : 1;
    UCHAR STtoIE : 1;
    UCHAR STtoDT : 1;
    UCHAR Reserved5 : 4;
    UCHAR IEtoMT : 1;
    UCHAR IEtoST : 1;
    UCHAR IEtoIE : 1;
    UCHAR IEtoDT : 1;
    UCHAR Reserved6 : 4;
    UCHAR DTtoMT : 1;
    UCHAR DTtoST : 1;
    UCHAR DTtoIE : 1;
    UCHAR DTtoDT : 1;
    UCHAR Reserved7 : 4;
    UCHAR Reserved8[4];
    UCHAR XMTtoMT : 1;
    UCHAR XMTtoST : 1;
    UCHAR XMTtoIE : 1;
    UCHAR XMTtoDT : 1;
    UCHAR Reserved9 : 4;
    UCHAR XSTtoMT : 1;
    UCHAR XSTtoST : 1;
    UCHAR XSTtoIE : 1;
    UCHAR XSTtoDT : 1;
    UCHAR Reserved10 : 4;
    UCHAR XIEtoMT : 1;
    UCHAR XIEtoST : 1;
    UCHAR XIEtoIE : 1;
    UCHAR XIEtoDT : 1;
    UCHAR Reserved11 : 4;
    UCHAR XDTtoMT : 1;
    UCHAR XDTtoST : 1;
    UCHAR XDTtoIE : 1;
    UCHAR XDTtoDT : 1;
    UCHAR Reserved12 : 4;

} MODE_DEVICE_CAPABILITIES_PAGE, *PMODE_DEVICE_CAPABILITIES_PAGE;

#define MODE_PAGE_DISPLAY 0x22

//
// Structures describing return data from READ_ELEMENT_STATUS
//

typedef struct _ELEMENT_STATUS_HEADER {
    UCHAR FirstElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} ELEMENT_STATUS_HEADER, *PELEMENT_STATUS_HEADER;

typedef struct _ELEMENT_STATUS_PAGE {
    UCHAR ElementType;
    UCHAR Reserved1 : 6;
    UCHAR AVolTag : 1;
    UCHAR PVolTag : 1;
    UCHAR ElementDescriptorLength[2];
    UCHAR Reserved2;
    UCHAR DescriptorByteCount[3];
} ELEMENT_STATUS_PAGE, *PELEMENT_STATUS_PAGE;


typedef struct _ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} ELEMENT_DESCRIPTOR, *PELEMENT_DESCRIPTOR;


//
// The following routines are the exported entry points for
// all changer class drivers.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ChangerClassCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    );

NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    );


//
// The following routines are provided by the changer
// device-specific module. Each routine name is
// prefixed with 'Changer.'


ULONG
ChangerAdditionalExtensionSize(
    VOID
    );

BOOLEAN
ChangerVerifyInquiry(
    PINQUIRYDATA InquiryData
    );

NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\class\mcdw2k.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mcd.c

Abstract:

Environment:

    Kernel mode

Revision History :

--*/

#include "stdarg.h"
#include "ntddk.h"
#include "mcd.h"

#include "initguid.h"
#include "ntddstor.h"

typedef struct _MCD_CLASS_DATA {
    LONG          DeviceOpen;
    UNICODE_STRING MediumChangerInterfaceString;
    BOOLEAN       DosNameCreated;
} MCD_CLASS_DATA, *PMCD_CLASS_DATA;


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  );

NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
ClasspSendSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerUnload)
#pragma alloc_text(PAGE, CreateChangerDeviceObject)
#pragma alloc_text(PAGE, ChangerClassCreateClose)
#pragma alloc_text(PAGE, ChangerClassDeviceControl)
#pragma alloc_text(PAGE, ChangerAddDevice)
#pragma alloc_text(PAGE, ChangerStartDevice)
#pragma alloc_text(PAGE, ChangerInitDevice)
#pragma alloc_text(PAGE, ChangerRemoveDevice)
#pragma alloc_text(PAGE, ChangerStopDevice)
#pragma alloc_text(PAGE, ChangerReadWriteVerification)
#endif


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  )

/*++

Routine Description:

    This routine handles CREATE/CLOSE requests.
    As these are exclusive devices, don't allow multiple opens.

Arguments:

    DeviceObject
    Irp

Return Value:

    NT Status

--*/

{
     PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
     PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
     PMCD_CLASS_DATA    mcdClassData;
     ULONG              miniclassExtSize;
     NTSTATUS           status = STATUS_SUCCESS;

     PAGED_CODE();

     mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
     miniclassExtSize = ChangerAdditionalExtensionSize();

     //
     // The class library's private data is after the miniclass's.
     //

     (ULONG_PTR)mcdClassData += miniclassExtSize;

     if (irpStack->MajorFunction == IRP_MJ_CLOSE) {
         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CLOSE\n"));

         //
         // Indicate that the device is available for others.
         //

         mcdClassData->DeviceOpen = 0;
         status = STATUS_SUCCESS;

     } else if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CREATE\n"));

         //
         // If already opened, return busy.
         //

         if (mcdClassData->DeviceOpen) {

             DebugPrint((1,
                        "ChangerClassCreateClose - returning DEVICE_BUSY. DeviceOpen - %x\n",
                        mcdClassData->DeviceOpen));

             status = STATUS_DEVICE_BUSY;
         } else {

             //
             // Indicate that the device is busy.
             //

             InterlockedIncrement(&mcdClassData->DeviceOpen);
             status = STATUS_SUCCESS;
         }


     }

     Irp->IoStatus.Status = status;
     ClassReleaseRemoveLock(DeviceObject, Irp);
     ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

     return status;

} // end ChangerCreate()


NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS               status;

    PAGED_CODE();

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CHANGER_GET_PARAMETERS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PARAMETERS\n"));

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(GET_CHANGER_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerGetParameters(DeviceObject, Irp);

            }

            break;

        case IOCTL_CHANGER_GET_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_STATUS\n"));

            status = ChangerGetStatus(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_GET_PRODUCT_DATA:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PRODUCT_DATA\n"));

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(CHANGER_PRODUCT_DATA)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = ChangerGetProductData(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_ACCESS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_ACCESS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_ACCESS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerSetAccess(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_GET_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_ELEMENT_STATUS\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_READ_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
                ULONG length = readElementStatus->ElementList.NumberOfElements * sizeof(CHANGER_ELEMENT_STATUS);

                //
                // Further validate parameters.
                //

                if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else if (length == 0) {

                    status = STATUS_INVALID_PARAMETER;

                } else {

                    status = ChangerGetElementStatus(DeviceObject, Irp);
                }

            }

            break;

        case IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerInitializeElementStatus(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_POSITION:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_POSITION\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_POSITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = ChangerSetPosition(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_EXCHANGE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_EXCHANGE_MEDIUM\n"));

            status = ChangerExchangeMedium(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_MOVE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_MOVE_MEDIUM\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_MOVE_MEDIUM)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = ChangerMoveMedium(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_REINITIALIZE_TRANSPORT:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_REINITIALIZE_TRANSPORT\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_ELEMENT)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = ChangerReinitializeUnit(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_QUERY_VOLUME_TAGS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_QUERY_VOLUME_TAGS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(READ_ELEMENT_ADDRESS_INFO)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {
                status = ChangerQueryVolumeTags(DeviceObject, Irp);
            }

            break;

        default:
            DebugPrint((1,
                       "Mcd.ChangerDeviceControl: Unhandled IOCTL\n"));


            //
            // Pass the request to the common device control routine.
            //

            return ClassDeviceControl(DeviceObject, Irp);
            break;
    }

    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        DebugPrint((1,
                   "Mcd.ChangerDeviceControl: IOCTL %x, status %x\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode,
                    status));

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);
    return status;
}


VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    Final Nt status indicating the results of the operation.

Notes:


--*/

{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;

    PAGED_CODE();

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {


        case SCSI_SENSE_ILLEGAL_REQUEST:
        switch (senseBuffer->AdditionalSenseCode) {
            case SCSI_ADSENSE_ILLEGAL_BLOCK:
                if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR ) {

                    DebugPrint((1,
                                "MediumChanger: An operation was attempted on an invalid element\n"));

                    //
                    // Attemped operation to an invalid element.
                    //

                    *Retry = FALSE;
                    *Status = STATUS_ILLEGAL_ELEMENT_ADDRESS;
                }
                break;

            case SCSI_ADSENSE_POSITION_ERROR:

                if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                    DebugPrint((1,
                                "MediumChanger: The specified source element has no media\n"));

                    //
                    // The indicated source address has no media.
                    //

                    *Retry = FALSE;
                    *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                    DebugPrint((1,
                                "MediumChanger: The specified destination element already has media.\n"));
                    //
                    // The indicated destination already contains media.
                    //

                    *Retry = FALSE;
                    *Status = STATUS_DESTINATION_ELEMENT_FULL;
                }
                break;

            default:
                break;
        }

        default:
            break;

        } // end switch
    }

    //
    // Allow device-specific module to update this.
    //

    ChangerError(DeviceObject, Srb, Status, Retry);
    return;
}



NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - MC class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    PULONG devicesFound = NULL;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of tape devices already initialized.
    //

    devicesFound = &IoGetConfigurationInformation()->MediumChangerCount;

    status = CreateChangerDeviceObject(DriverObject,
                                       PhysicalDeviceObject);


    if(NT_SUCCESS(status)) {

        (*devicesFound)++;
    }

    return status;
}



NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called after InitDevice, and creates the symbolic link,
    and sets up information in the registry.
    The routine could be called multiple times, in the event of a StopDevice.


Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PINQUIRYDATA            inquiryData = NULL;
    ULONG                   pageLength;
    ULONG                   inquiryLength;
    SCSI_REQUEST_BLOCK      srb;
    PCDB                    cdb;
    NTSTATUS                status;
    PMCD_CLASS_DATA              mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    ULONG                        miniClassExtSize = ChangerAdditionalExtensionSize();

    PAGED_CODE();

    //
    // Build and send request to get inquiry data.
    //

    inquiryData = ExAllocatePool(NonPagedPoolCacheAligned, MAXIMUM_CHANGER_INQUIRY_DATA);
    if (!inquiryData) {
        //
        // The buffer cannot be allocated.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 2;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = MAXIMUM_CHANGER_INQUIRY_DATA;

    status = ClassSendSrbSynchronous(Fdo,
                                     &srb,
                                     inquiryData,
                                     MAXIMUM_CHANGER_INQUIRY_DATA,
                                     FALSE);


    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        srb.SrbStatus = SRB_STATUS_SUCCESS;
    }

    if (srb.SrbStatus == SRB_STATUS_SUCCESS) {
        inquiryLength = inquiryData->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (inquiryLength > srb.DataTransferLength) {
            inquiryLength = srb.DataTransferLength;
        }
    } else {

        //
        // The class function will only write inquiryLength of inquiryData
        // to the reg. key.
        //

        inquiryLength = 0;
    }

    //
    // Add changer device info to registry
    //

    ClassUpdateInformationInRegistry(Fdo,
                                     "Changer",
                                     fdoExtension->DeviceNumber,
                                     inquiryData,
                                     inquiryLength);

    ExFreePool(inquiryData);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}




#define CHANGER_SRB_LIST_SIZE 2



NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the changer initialization.  This includes
    allocating sense info buffers and srb s-lists. Additionally, the miniclass
    driver's init entry points are called.

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PVOID                   senseData = NULL;
    NTSTATUS                status;
    PVOID                   minitapeExtension;
    STORAGE_PROPERTY_ID     propertyId;
    UNICODE_STRING          interfaceName;
    PMCD_CLASS_DATA         mcdClassData;

    PAGED_CODE();

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePool(NonPagedPoolCacheAligned,
                               SENSE_BUFFER_SIZE);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ChangerInitDeviceExit;
    }

    //
    // Build the lookaside list for srb's for the device. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension), CHANGER_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    fdoExtension->TimeOutValue = 600;

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "ChangerStartDevice: Unable to get adapter descriptor. Status %x\n",
                    status));
        goto ChangerInitDeviceExit;
    }

    //
    // Invoke the device-specific initialization function.
    //

    status = ChangerInitialize(Fdo);

    //
    // Register interfaces for this device.
    //

    RtlInitUnicodeString(&interfaceName, NULL);

    status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                       (LPGUID) &MediumChangerClassGuid,
                                       NULL,
                                       &interfaceName);

    if(NT_SUCCESS(status)) {
        ULONG miniclassExtSize;

        mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
        miniclassExtSize = ChangerAdditionalExtensionSize();

        //
        // The class library's private data is after the miniclass's.
        //

        (ULONG_PTR)mcdClassData += miniclassExtSize;

        mcdClassData->MediumChangerInterfaceString = interfaceName;

        status = IoSetDeviceInterfaceState(
                    &interfaceName,
                    TRUE);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1,
                        "ChangerInitDevice: Unable to register Changer%x interface name - %x.\n",
                        fdoExtension->DeviceNumber,
                        status));
            status = STATUS_SUCCESS;
        }
    }

    return status;

    //
    // Fall through and return whatever status the miniclass driver returned.
    //

ChangerInitDeviceExit:

    if (senseData) {
        ExFreePool(senseData);
    }

    return status;

} // End ChangerStartDevice



NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    tape driver.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PMCD_CLASS_DATA              mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    ULONG                        miniClassExtSize = ChangerAdditionalExtensionSize();
    WCHAR                        dosNameBuffer[64];
    UNICODE_STRING               dosUnicodeString;
    NTSTATUS                     status;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    //
    // Free all allocated memory.
    //

    if (fdoExtension->DeviceDescriptor) {
        ExFreePool(fdoExtension->DeviceDescriptor);
        fdoExtension->DeviceDescriptor = NULL;
    }
    if (fdoExtension->AdapterDescriptor) {
        ExFreePool(fdoExtension->AdapterDescriptor);
        fdoExtension->AdapterDescriptor = NULL;
    }
    if (fdoExtension->SenseData) {
        ExFreePool(fdoExtension->SenseData);
        fdoExtension->SenseData = NULL;
    }

    //
    // Remove the lookaside list.
    //

    ClassDeleteSrbLookasideList(&fdoExtension->CommonExtension);

    (ULONG_PTR)mcdClassData += miniClassExtSize;

    if(mcdClassData->MediumChangerInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(&(mcdClassData->MediumChangerInterfaceString),
                                  FALSE);

        RtlFreeUnicodeString(&(mcdClassData->MediumChangerInterfaceString));

        //
        // Clear it.
        //

        RtlInitUnicodeString(&(mcdClassData->MediumChangerInterfaceString), NULL);
    }

    //
    // Delete the symbolic link "changerN".
    //

    if(mcdClassData->DosNameCreated) {

        swprintf(dosNameBuffer,
                L"\\DosDevices\\Changer%d",
                fdoExtension->DeviceNumber);
        RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);
        IoDeleteSymbolicLink(&dosUnicodeString);
        mcdClassData->DosNameCreated = FALSE;
    }

    //
    // Remove registry bits.
    //

    if(Type == IRP_MN_REMOVE_DEVICE) {
        IoGetConfigurationInformation()->MediumChangerCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a stub that returns invalid device request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - Supplies the I/O request packet.

Return Value:

    STATUS_INVALID_DEVICE_REQUEST


--*/

{
    return  STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/

{



    CLASS_INIT_DATA InitializationData;

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    InitializationData.FdoData.DeviceExtensionSize = sizeof(FUNCTIONAL_DEVICE_EXTENSION) + ChangerAdditionalExtensionSize() + sizeof(MCD_CLASS_DATA);
    InitializationData.FdoData.DeviceType = FILE_DEVICE_CHANGER;
    InitializationData.FdoData.DeviceCharacteristics = 0;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassStartDevice = ChangerStartDevice;
    InitializationData.FdoData.ClassInitDevice = ChangerInitDevice;
    InitializationData.FdoData.ClassStopDevice = ChangerStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = ChangerRemoveDevice;
    InitializationData.ClassAddDevice = ChangerAddDevice;

    InitializationData.FdoData.ClassReadWriteVerification = NULL;
    InitializationData.FdoData.ClassDeviceControl = ChangerClassDeviceControl;
    InitializationData.FdoData.ClassError = ChangerClassError;
    InitializationData.FdoData.ClassShutdownFlush = NULL;

    InitializationData.FdoData.ClassCreateClose = ChangerClassCreateClose;

    //
    // Stub routine to make the class driver happy.
    //

    InitializationData.FdoData.ClassReadWriteVerification = ChangerReadWriteVerification;

    InitializationData.ClassUnload = ChangerUnload;


    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

}

VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates an object for the device and then searches
    the device for partitions and creates an object for each partition.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PhysicalDeviceObject - DeviceObject of the attached to device.

Return Value:

    NTSTATUS

--*/

{

    PDEVICE_OBJECT lowerDevice;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    CCHAR          deviceNameBuffer[64];
    NTSTATUS       status;
    PDEVICE_OBJECT deviceObject;
    ULONG          requiredStackSize;
    PVOID          senseData;
    WCHAR          dosNameBuffer[64];
    WCHAR          wideNameBuffer[64]; 
    UNICODE_STRING dosUnicodeString;
    UNICODE_STRING deviceUnicodeString;
    PMCD_CLASS_DATA mcdClassData;
    ULONG          mcdCount;

    PAGED_CODE();

    DebugPrint((3,"CreateChangerDeviceObject: Enter routine\n"));

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device.
        //

        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create device object for this device.
    //
    mcdCount = 0;
    do {
       sprintf(deviceNameBuffer,
               "\\Device\\Changer%d",
               mcdCount);
   
       status = ClassCreateDeviceObject(DriverObject,
                                        deviceNameBuffer,
                                        PhysicalDeviceObject,
                                        TRUE,
                                        &deviceObject);
       mcdCount++;
    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"CreateChangerDeviceObjects: Can not create device %s\n",
                    deviceNameBuffer));

        goto CreateChangerDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system tape number
    //

    fdoExtension->DeviceNumber = mcdCount - 1;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // The attach failed. Cleanup and return.
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateChangerDeviceObjectExit;
    }


    //
    // Create the dos port driver name.
    //

    swprintf(dosNameBuffer,
             L"\\DosDevices\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);

    //
    // Recreate the deviceName
    //

    swprintf(wideNameBuffer,
             L"\\Device\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&deviceUnicodeString,
                         wideNameBuffer);


    mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
    (ULONG_PTR)mcdClassData += ChangerAdditionalExtensionSize();
    if (NT_SUCCESS(IoAssignArcName(&dosUnicodeString, &deviceUnicodeString))) {
          mcdClassData->DosNameCreated = TRUE;
    } else {
          mcdClassData->DosNameCreated = FALSE;
    }

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ObDereferenceObject(lowerDevice);

    return(STATUS_SUCCESS);

CreateChangerDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;


} // end CreateChangerDeviceObject()


NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT Fdo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID BufferAddress,
    IN ULONG BufferLength,
    IN BOOLEAN WriteToDevice
    )
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    IO_STATUS_BLOCK ioStatus;
    ULONG controlType;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT event;
    PUCHAR senseInfoBuffer;
    ULONG retryCount = MAXIMUM_RETRIES;
    NTSTATUS status;
    BOOLEAN retry;

    //
    // NOTE: While this code may look as though it could be pagable,
    //       making it pagable creates the possibility of a page
    //       boundary between IoCallDriver() and ClassReleaseQueue(),
    //       which could leave the queue frozen as we try to page in
    //       this code, which is required to unfreeze the queue.
    //       The result would be a nice case of deadlock.
    //

    ASSERT(fdoExtension->CommonExtension.IsFdo);

    //
    // Write length to SRB.
    //

    Srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set SCSI bus address.
    //

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // NOTICE:  The SCSI-II specification indicates that this field should be
    // zero; however, some target controllers ignore the logical unit number
    // in the INDENTIFY message and only look at the logical unit number field
    // in the CDB.
    //

    // Srb->Cdb[1] |= deviceExtension->Lun << 5;

    //
    // Enable auto request sense.
    //

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Sense buffer is in aligned nonpaged pool.
    //

    senseInfoBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     SENSE_BUFFER_SIZE,
                                     '7CcS');

    if (senseInfoBuffer == NULL) {

        DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate request sense "
                       "buffer\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Srb->SenseInfoBuffer = senseInfoBuffer;
    Srb->DataBuffer = BufferAddress;

    if(BufferAddress != NULL) {
        if(WriteToDevice) {
            Srb->SrbFlags = SRB_FLAGS_DATA_OUT;
        } else {
            Srb->SrbFlags = SRB_FLAGS_DATA_IN;
        }
    } else {
        Srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    }

    //
    // Start retries here.
    //

retry:

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build device I/O control request with METHOD_NEITHER data transfer.
    // We'll queue a completion routine to cleanup the MDL's and such ourself.
    //

    irp = IoAllocateIrp(
            (CCHAR) (fdoExtension->CommonExtension.LowerDeviceObject->StackSize + 1),
            FALSE);

    if(irp == NULL) {
        ExFreePool(senseInfoBuffer);
        DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate Irp\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Get next stack location.
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set up SRB for execute scsi request. Save SRB address in next stack
    // for the port driver.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->Parameters.Scsi.Srb = Srb;

    IoSetCompletionRoutine(irp,
                           ClasspSendSynchronousCompletion,
                           Srb,
                           TRUE,
                           TRUE,
                           TRUE);

    irp->UserIosb = &ioStatus;
    irp->UserEvent = &event;

    if(BufferAddress) {
        //
        // Build an MDL for the data buffer and stick it into the irp.  The
        // completion routine will unlock the pages and free the MDL.
        //

        irp->MdlAddress = IoAllocateMdl( BufferAddress,
                                         BufferLength,
                                         FALSE,
                                         FALSE,
                                         irp );
        if (irp->MdlAddress == NULL) {
            ExFreePool(senseInfoBuffer);
            Srb->SenseInfoBuffer = NULL;
            IoFreeIrp( irp );
            DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate MDL\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        try {
            MmProbeAndLockPages( irp->MdlAddress,
                                 KernelMode,
                                 (WriteToDevice ? IoReadAccess :
                                                  IoWriteAccess));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();

            ExFreePool(senseInfoBuffer);
            Srb->SenseInfoBuffer = NULL;
            IoFreeMdl(irp->MdlAddress);
            IoFreeIrp(irp);

            DebugPrint((1, "ClassSendSrbSynchronous: Exception %lx "
                           "locking buffer\n", status));
            return status;
        }
    }

    //
    // Disable synchronous transfer for these requests.
    //

    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = BufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;
    Srb->NextSrb = 0;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = irp;

    //
    // Call the port driver with the request and wait for it to complete.
    //

    status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // Check that request completed without error.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        //
        // Release the queue if it is frozen.
        //

        if (Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(Fdo);
        }

        //
        // Update status and determine if request should be retried.
        //

        retry = ClassInterpretSenseInfo(Fdo,
                                        Srb,
                                        IRP_MJ_SCSI,
                                        0,
                                        MAXIMUM_RETRIES  - retryCount,
                                        &status,
                                        &retryInterval);

        if (retry) {

            if ((status == STATUS_DEVICE_NOT_READY &&
                 ((PSENSE_DATA) senseInfoBuffer)->AdditionalSenseCode ==
                                SCSI_ADSENSE_LUN_NOT_READY) ||
                (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT)) {

                LARGE_INTEGER delay;

                //
                // Delay for at least 2 seconds.
                //

                if(retryInterval < 2) {
                    retryInterval = 2;
                }

                delay.QuadPart = (LONGLONG)( - 10 * 1000 * (LONGLONG)1000 * retryInterval);

                //
                // Stall for a while to let the controller spinup.
                //

                KeDelayExecutionThread(KernelMode, FALSE, &delay);

            }

            //
            // If retries are not exhausted then retry this operation.
            //

            if (retryCount--) {
                goto retry;
            }
        }

    } else {

        status = STATUS_SUCCESS;
    }

    Srb->SenseInfoBuffer = NULL;
    ExFreePool(senseInfoBuffer);
    return status;

}


NTSTATUS
ClasspSendSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This completion routine will set the user event in the irp after
    freeing the irp and the associated MDL (if any).

Arguments:

    DeviceObject - the device object which requested the completion routine

    Irp - the irp being completed

    Context - unused

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    DebugPrint((3, "ClasspSendSynchronousCompletion: %p %p %p\n",
                   DeviceObject, Irp, Context));
    //
    // First set the status and information fields in the io status block
    // provided by the caller.
    //

    *(Irp->UserIosb) = Irp->IoStatus;

    //
    // Unlock the pages for the data buffer.
    //

    if(Irp->MdlAddress) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);
    }

    //
    // Signal the caller's event.
    //

    KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);

    //
    // Free the MDL and the IRP.
    //

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )

{
    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, 'CMcS');
}


VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    )
{
    ExFreePool(PoolToFree);
}

#if DBG
ULONG MCDebug = 0;
UCHAR DebugBuffer[128];
#endif


#if DBG

VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all medium changer drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= MCDebug) {

        vsprintf(DebugBuffer, DebugMessage, ap);

        DbgPrint(DebugBuffer);
    }

    va_end(ap);

} // end MCDebugPrint()

#else

//
// DebugPrint stub
//

VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\class\mcd.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mcd.c

Abstract:

Environment:

    Kernel mode

Revision History :

--*/
#include "mchgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerUnload)
#pragma alloc_text(PAGE, CreateChangerDeviceObject)
#pragma alloc_text(PAGE, ChangerClassCreateClose)
#pragma alloc_text(PAGE, ChangerClassDeviceControl)
#pragma alloc_text(PAGE, ChangerAddDevice)
#pragma alloc_text(PAGE, ChangerStartDevice)
#pragma alloc_text(PAGE, ChangerInitDevice)
#pragma alloc_text(PAGE, ChangerRemoveDevice)
#pragma alloc_text(PAGE, ChangerStopDevice)
#pragma alloc_text(PAGE, ChangerReadWriteVerification)
#endif


NTSTATUS
ChangerClassCreateClose (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp
  )

/*++

Routine Description:

    This routine handles CREATE/CLOSE requests.
    As these are exclusive devices, don't allow multiple opens.

Arguments:

    DeviceObject
    Irp

Return Value:

    NT Status

--*/

{
     PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
     PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
     PMCD_CLASS_DATA    mcdClassData;
     PMCD_INIT_DATA     mcdInitData;
     ULONG              miniclassExtSize;
     NTSTATUS           status = STATUS_SUCCESS;

     PAGED_CODE();

     mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);

     mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                              ChangerClassInitialize);

     if (mcdInitData == NULL) {

         Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
         ClassReleaseRemoveLock(DeviceObject, Irp);
         ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

         return STATUS_NO_SUCH_DEVICE;
     }

     miniclassExtSize = mcdInitData->ChangerAdditionalExtensionSize();

     //
     // The class library's private data is after the miniclass's.
     //

     (ULONG_PTR)mcdClassData += miniclassExtSize;

     if (irpStack->MajorFunction == IRP_MJ_CLOSE) {
         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CLOSE\n"));

         //
         // Indicate that the device is available for others.
         //

         mcdClassData->DeviceOpen = 0;
         status = STATUS_SUCCESS;

     } else if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         DebugPrint((3,
                    "ChangerClassCreateClose - IRP_MJ_CREATE\n"));

         //
         // If already opened, return busy.
         //

         if (mcdClassData->DeviceOpen) {

             DebugPrint((1,
                        "ChangerClassCreateClose - returning DEVICE_BUSY. DeviceOpen - %x\n",
                        mcdClassData->DeviceOpen));

             status = STATUS_DEVICE_BUSY;
         } else {

             //
             // Indicate that the device is busy.
             //

             InterlockedIncrement(&mcdClassData->DeviceOpen);
             status = STATUS_SUCCESS;
         }


     }

     Irp->IoStatus.Status = status;
     ClassReleaseRemoveLock(DeviceObject, Irp);
     ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

     return status;

} // end ChangerCreate()


NTSTATUS
ChangerClassDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    PMCD_INIT_DATA    mcdInitData;
    NTSTATUS               status;

    PAGED_CODE();


    mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);

        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Disable media change detection before processing current IOCTL
    //
    ClassDisableMediaChangeDetection(fdoExtension);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CHANGER_GET_PARAMETERS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PARAMETERS\n"));

            //
            // Validate buffer length.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(GET_CHANGER_PARAMETERS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerGetParameters(DeviceObject, Irp);

            }

            break;

        case IOCTL_CHANGER_GET_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_STATUS\n"));

            status = mcdInitData->ChangerGetStatus(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_GET_PRODUCT_DATA:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_PRODUCT_DATA\n"));

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(CHANGER_PRODUCT_DATA)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = mcdInitData->ChangerGetProductData(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_ACCESS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_ACCESS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_ACCESS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerSetAccess(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_GET_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_GET_ELEMENT_STATUS\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_READ_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
                ULONG length = readElementStatus->ElementList.NumberOfElements * sizeof(CHANGER_ELEMENT_STATUS);
                ULONG lengthEx = readElementStatus->ElementList.NumberOfElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
                ULONG outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // Further validate parameters.
                //
                status = STATUS_SUCCESS;
                if ((outputBuffLen < lengthEx) &&
                    (outputBuffLen < length)) {

                        status = STATUS_BUFFER_TOO_SMALL;

                } else if ((length == 0) || 
                           (lengthEx == 0)) {

                    status = STATUS_INVALID_PARAMETER;
                } 
                
                if (NT_SUCCESS(status)) {
                    status = mcdInitData->ChangerGetElementStatus(DeviceObject, Irp);
                }

            }

            break;

        case IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerInitializeElementStatus(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_SET_POSITION:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_SET_POSITION\n"));


            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SET_POSITION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {

                status = mcdInitData->ChangerSetPosition(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_EXCHANGE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_EXCHANGE_MEDIUM\n"));

            status = mcdInitData->ChangerExchangeMedium(DeviceObject, Irp);

            break;

        case IOCTL_CHANGER_MOVE_MEDIUM:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_MOVE_MEDIUM\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_MOVE_MEDIUM)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = mcdInitData->ChangerMoveMedium(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_REINITIALIZE_TRANSPORT:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_REINITIALIZE_TRANSPORT\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_ELEMENT)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = mcdInitData->ChangerReinitializeUnit(DeviceObject, Irp);
            }

            break;

        case IOCTL_CHANGER_QUERY_VOLUME_TAGS:

            DebugPrint((3,
                       "Mcd.ChangerDeviceControl: IOCTL_CHANGER_QUERY_VOLUME_TAGS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(READ_ELEMENT_ADDRESS_INFO)) {

                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {
                status = mcdInitData->ChangerQueryVolumeTags(DeviceObject, Irp);
            }

            break;

        default:
            DebugPrint((1,
                       "Mcd.ChangerDeviceControl: Unhandled IOCTL\n"));


            //
            // Pass the request to the common device control routine.
            //

            status = ClassDeviceControl(DeviceObject, Irp);

            //
            // Re-enable media change detection 
            //
            ClassEnableMediaChangeDetection(fdoExtension);

            return status;
    }

    Irp->IoStatus.Status = status;

    //
    // Re-enable media change detection 
    //
    ClassEnableMediaChangeDetection(fdoExtension);

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        DebugPrint((1,
                   "Mcd.ChangerDeviceControl: IOCTL %x, status %x\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode,
                    status));

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject,Irp, IO_NO_INCREMENT);
    return status;
}


VOID
ChangerClassError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    Final Nt status indicating the results of the operation.

Notes:


--*/

{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION    fdoExtension = DeviceObject->DeviceExtension;
    PMCD_INIT_DATA mcdInitData;

    mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return;
    }

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey & 0xf) {
        
          case SCSI_SENSE_MEDIUM_ERROR: {
              *Retry = FALSE;

              if (((senseBuffer->AdditionalSenseCode) ==  SCSI_ADSENSE_INVALID_MEDIA) &&
                  ((senseBuffer->AdditionalSenseCodeQualifier) == SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)) {

                  //
                  // This indicates a cleaner cartridge is present in the changer
                  //
                  *Status = STATUS_CLEANER_CARTRIDGE_INSTALLED;
              }
              break;
          }

          case SCSI_SENSE_ILLEGAL_REQUEST: {
              switch (senseBuffer->AdditionalSenseCode) {
                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR ) {

                        DebugPrint((1,
                                    "MediumChanger: An operation was attempted on an invalid element\n"));

                        //
                        // Attemped operation to an invalid element.
                        //

                        *Retry = FALSE;
                        *Status = STATUS_ILLEGAL_ELEMENT_ADDRESS;
                    }
                    break;

                case SCSI_ADSENSE_POSITION_ERROR:

                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                        DebugPrint((1,
                                "MediumChanger: The specified source element has no media\n"));

                        //
                        // The indicated source address has no media.
                        //

                        *Retry = FALSE;
                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                    } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                        DebugPrint((1,
                                    "MediumChanger: The specified destination element already has media.\n"));
                        //
                        // The indicated destination already contains media.
                        //

                        *Retry = FALSE;
                        *Status = STATUS_DESTINATION_ELEMENT_FULL;
                    }
                    break;



                default:
                    break;
              } // switch (senseBuffer->AdditionalSenseCode)

              break;
          }

          case SCSI_SENSE_UNIT_ATTENTION: {
              if ((senseBuffer->AdditionalSenseCode) == 
                  SCSI_ADSENSE_MEDIUM_CHANGED) {
                  //
                  // Need to notify applications of possible media change in
                  // the library. First, set the current media state to 
                  // NotPresent and then set the state to present. We need to
                  // do this because, changer devices do not report MediaNotPresent
                  // state. They only convey MediumChanged condition. In order for
                  // classpnp to notify applications of media change, we need to
                  // simulate media notpresent to present state transition
                  //
                  ClassSetMediaChangeState(fdoExtension, MediaNotPresent, FALSE);
                  ClassSetMediaChangeState(fdoExtension, MediaPresent, FALSE);
              }

              break;
          }

          default:
              break;

        } // end switch (senseBuffer->SenseKey & 0xf) 
    } // if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)

    //
    // Call Changer MiniDriver error routine only if we
    // are running at or below APC_LEVEL
    //
    if (KeGetCurrentIrql() > APC_LEVEL) {
        return;
    }

    if (mcdInitData->ChangerError) {
        //
        // Allow device-specific module to update this.
        //
        mcdInitData->ChangerError(DeviceObject, Srb, Status, Retry);
    }

    return;
}



NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - MC class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    PULONG devicesFound = NULL;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of tape devices already initialized.
    //

    devicesFound = &IoGetConfigurationInformation()->MediumChangerCount;

    status = CreateChangerDeviceObject(DriverObject,
                                       PhysicalDeviceObject);


    if(NT_SUCCESS(status)) {

        (*devicesFound)++;
    }

    return status;
}



NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called after InitDevice, and creates the symbolic link,
    and sets up information in the registry.
    The routine could be called multiple times, in the event of a StopDevice.


Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PINQUIRYDATA            inquiryData = NULL;
    ULONG                   pageLength;
    ULONG                   inquiryLength;
    SCSI_REQUEST_BLOCK      srb;
    PCDB                    cdb;
    NTSTATUS                status;
    PMCD_CLASS_DATA         mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    PMCD_INIT_DATA          mcdInitData;
    ULONG                   miniClassExtSize;
    
    PAGED_CODE();

    mcdInitData = IoGetDriverObjectExtension(Fdo->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    miniClassExtSize = mcdInitData->ChangerAdditionalExtensionSize();

    //
    // Build and send request to get inquiry data.
    //

    inquiryData = ExAllocatePool(NonPagedPoolCacheAligned, MAXIMUM_CHANGER_INQUIRY_DATA);
    if (!inquiryData) {
        //
        // The buffer cannot be allocated.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 2;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = MAXIMUM_CHANGER_INQUIRY_DATA;

    status = ClassSendSrbSynchronous(Fdo,
                                     &srb,
                                     inquiryData,
                                     MAXIMUM_CHANGER_INQUIRY_DATA,
                                     FALSE);


    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        srb.SrbStatus = SRB_STATUS_SUCCESS;
    }

    if (srb.SrbStatus == SRB_STATUS_SUCCESS) {
        inquiryLength = inquiryData->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (inquiryLength > srb.DataTransferLength) {
            inquiryLength = srb.DataTransferLength;
        }
    } else {

        //
        // The class function will only write inquiryLength of inquiryData
        // to the reg. key.
        //

        inquiryLength = 0;
    }

    //
    // Add changer device info to registry
    //

    ClassUpdateInformationInRegistry(Fdo,
                                     "Changer",
                                     fdoExtension->DeviceNumber,
                                     inquiryData,
                                     inquiryLength);

    ExFreePool(inquiryData);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}




#define CHANGER_SRB_LIST_SIZE 2



NTSTATUS
ChangerInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the changer initialization.  This includes
    allocating sense info buffers and srb s-lists. Additionally, the miniclass
    driver's init entry points are called.

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PVOID                   senseData = NULL;
    NTSTATUS                status;
    PVOID                   minitapeExtension;
    PMCD_INIT_DATA          mcdInitData;
    STORAGE_PROPERTY_ID     propertyId;
    UNICODE_STRING          interfaceName;
    PMCD_CLASS_DATA         mcdClassData;

    PAGED_CODE();

    mcdInitData = IoGetDriverObjectExtension(Fdo->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePool(NonPagedPoolCacheAligned,
                               SENSE_BUFFER_SIZE);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ChangerInitDeviceExit;
    }

    //
    // Build the lookaside list for srb's for the device. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension), CHANGER_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    fdoExtension->TimeOutValue = 600;

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "ChangerStartDevice: Unable to get adapter descriptor. Status %x\n",
                    status));
        goto ChangerInitDeviceExit;
    }

    //
    // Invoke the device-specific initialization function.
    //

    status = mcdInitData->ChangerInitialize(Fdo);

    //
    // Register for media change notification
    //
    ClassInitializeMediaChangeDetection(fdoExtension,
                                        "Changer");

    //
    // Register interfaces for this device.
    //

    RtlInitUnicodeString(&interfaceName, NULL);

    status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                       (LPGUID) &MediumChangerClassGuid,
                                       NULL,
                                       &interfaceName);

    if(NT_SUCCESS(status)) {

        mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);

        //
        // The class library's private data is after the miniclass's.
        //

        (ULONG_PTR)mcdClassData += mcdInitData->ChangerAdditionalExtensionSize();

        mcdClassData->MediumChangerInterfaceString = interfaceName;

        status = IoSetDeviceInterfaceState(
                    &interfaceName,
                    TRUE);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1,
                        "ChangerInitDevice: Unable to register Changer%x interface name - %x.\n",
                        fdoExtension->DeviceNumber,
                        status));
            status = STATUS_SUCCESS;
        }
    }

    return status;

    //
    // Fall through and return whatever status the miniclass driver returned.
    //

ChangerInitDeviceExit:

    if (senseData) {
        ExFreePool(senseData);
    }

    return status;

} // End ChangerStartDevice



NTSTATUS
ChangerRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    tape driver.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PMCD_CLASS_DATA              mcdClassData = (PMCD_CLASS_DATA)fdoExtension->CommonExtension.DriverData;
    PMCD_INIT_DATA               mcdInitData;
    ULONG                        miniClassExtSize;
    WCHAR                        dosNameBuffer[64];
    UNICODE_STRING               dosUnicodeString;
    NTSTATUS                     status;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }


    mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    miniClassExtSize = mcdInitData->ChangerAdditionalExtensionSize();

    //
    // Free all allocated memory.
    //

    if (fdoExtension->DeviceDescriptor) {
        ExFreePool(fdoExtension->DeviceDescriptor);
        fdoExtension->DeviceDescriptor = NULL;
    }
    if (fdoExtension->AdapterDescriptor) {
        ExFreePool(fdoExtension->AdapterDescriptor);
        fdoExtension->AdapterDescriptor = NULL;
    }
    if (fdoExtension->SenseData) {
        ExFreePool(fdoExtension->SenseData);
        fdoExtension->SenseData = NULL;
    }

    //
    // Remove the lookaside list.
    //

    ClassDeleteSrbLookasideList(&fdoExtension->CommonExtension);

    (ULONG_PTR)mcdClassData += miniClassExtSize;

    if(mcdClassData->MediumChangerInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(&(mcdClassData->MediumChangerInterfaceString),
                                  FALSE);

        RtlFreeUnicodeString(&(mcdClassData->MediumChangerInterfaceString));

        //
        // Clear it.
        //

        RtlInitUnicodeString(&(mcdClassData->MediumChangerInterfaceString), NULL);
    }

    //
    // Delete the symbolic link "changerN".
    //

    if(mcdClassData->DosNameCreated) {

        swprintf(dosNameBuffer,
                L"\\DosDevices\\Changer%d",
                fdoExtension->DeviceNumber);
        RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);
        IoDeleteSymbolicLink(&dosUnicodeString);
        mcdClassData->DosNameCreated = FALSE;
    }

    //
    // Remove registry bits.
    //

    if(Type == IRP_MN_REMOVE_DEVICE) {
        IoGetConfigurationInformation()->MediumChangerCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a stub that returns invalid device request.

Arguments:

    DeviceObject - Supplies the device object.

    Irp - Supplies the I/O request packet.

Return Value:

    STATUS_INVALID_DEVICE_REQUEST


--*/

{
    return  STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DriverEntry(
  IN PDRIVER_OBJECT DriverObject,
  IN PUNICODE_STRING RegistryPath
  )

/*++

Routine Description:

    This is the entry point for this EXPORT DRIVER.  It does nothing.

--*/

{
    return STATUS_SUCCESS;
}


NTSTATUS
ChangerClassInitialize(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  PMCD_INIT_DATA  MCDInitData
    )

/*++

Routine Description:

    This routine is called by a changer mini-class driver during its
    DriverEntry routine to initialize the driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.
    
    MCDInitData     - Changer Minidriver Init Data

Return Value:

    Status value returned by ClassInitialize
--*/

{
    PMCD_INIT_DATA driverExtension;
    CLASS_INIT_DATA InitializationData;
    NTSTATUS status;

    //
    // Get the driver extension
    //
    status = IoAllocateDriverObjectExtension(
                      DriverObject,
                      ChangerClassInitialize,
                      sizeof(MCD_INIT_DATA),
                      &driverExtension);
    if (!NT_SUCCESS(status)) {
        if(status == STATUS_OBJECT_NAME_COLLISION) {
        
            //
            // An extension already exists for this key.  Get a pointer to it
            //
        
            driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                         ChangerClassInitialize);
            if (driverExtension == NULL) {
                DebugPrint((1, 
                            "ChangerClassInitialize : driverExtension NULL\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
        
            //
            // As this failed, the changer init data won't be able to be stored.
            //
        
            DebugPrint((1, 
                        "ChangerClassInitialize: Error %x allocating driver extension\n",
                        status));
        
            return status;
        }
    }

    RtlCopyMemory(driverExtension, MCDInitData, sizeof(MCD_INIT_DATA));

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    InitializationData.FdoData.DeviceExtensionSize = 
        sizeof(FUNCTIONAL_DEVICE_EXTENSION) + 
        MCDInitData->ChangerAdditionalExtensionSize() + 
        sizeof(MCD_CLASS_DATA);

    InitializationData.FdoData.DeviceType = FILE_DEVICE_CHANGER;
    InitializationData.FdoData.DeviceCharacteristics = 0;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassStartDevice = ChangerStartDevice;
    InitializationData.FdoData.ClassInitDevice = ChangerInitDevice;
    InitializationData.FdoData.ClassStopDevice = ChangerStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = ChangerRemoveDevice;
    InitializationData.ClassAddDevice = ChangerAddDevice;

    InitializationData.FdoData.ClassReadWriteVerification = NULL;
    InitializationData.FdoData.ClassDeviceControl = ChangerClassDeviceControl;
    InitializationData.FdoData.ClassError = ChangerClassError;
    InitializationData.FdoData.ClassShutdownFlush = NULL;

    InitializationData.FdoData.ClassCreateClose = ChangerClassCreateClose;

    //
    // Stub routine to make the class driver happy.
    //

    InitializationData.FdoData.ClassReadWriteVerification = ChangerReadWriteVerification;

    InitializationData.ClassUnload = ChangerUnload;


    //
    // Routines for WMI support
    //
    InitializationData.FdoData.ClassWmiInfo.GuidCount = 3;
    InitializationData.FdoData.ClassWmiInfo.GuidRegInfo = ChangerWmiFdoGuidList;
    InitializationData.FdoData.ClassWmiInfo.ClassQueryWmiRegInfo = ChangerFdoQueryWmiRegInfo;
    InitializationData.FdoData.ClassWmiInfo.ClassQueryWmiDataBlock = ChangerFdoQueryWmiDataBlock;
    InitializationData.FdoData.ClassWmiInfo.ClassSetWmiDataBlock = ChangerFdoSetWmiDataBlock;
    InitializationData.FdoData.ClassWmiInfo.ClassSetWmiDataItem = ChangerFdoSetWmiDataItem;
    InitializationData.FdoData.ClassWmiInfo.ClassExecuteWmiMethod = ChangerFdoExecuteWmiMethod;
    InitializationData.FdoData.ClassWmiInfo.ClassWmiFunctionControl = ChangerWmiFunctionControl;

    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

}


VOID
ChangerUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}

NTSTATUS
CreateChangerDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates an object for the device and then searches
    the device for partitions and creates an object for each partition.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PhysicalDeviceObject - DeviceObject of the attached to device.

Return Value:

    NTSTATUS

--*/

{

    PDEVICE_OBJECT lowerDevice;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    CCHAR          deviceNameBuffer[64];
    NTSTATUS       status;
    PDEVICE_OBJECT deviceObject;
    ULONG          requiredStackSize;
    PVOID          senseData;
    WCHAR          dosNameBuffer[64];
    WCHAR          wideNameBuffer[64]; 
    UNICODE_STRING dosUnicodeString;
    UNICODE_STRING deviceUnicodeString;
    PMCD_CLASS_DATA mcdClassData;
    PMCD_INIT_DATA mcdInitData;
    ULONG          mcdCount;

    PAGED_CODE();

    DebugPrint((3,"CreateChangerDeviceObject: Enter routine\n"));

    //
    // Get the saved MCD Init Data
    //
    mcdInitData = IoGetDriverObjectExtension(DriverObject,
                                             ChangerClassInitialize);

    if (mcdInitData == NULL) {

        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(mcdInitData);

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device.
        //

        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create device object for this device.
    //
    mcdCount = 0;
    do {
       sprintf(deviceNameBuffer,
               "\\Device\\Changer%d",
               mcdCount);
   
       status = ClassCreateDeviceObject(DriverObject,
                                        deviceNameBuffer,
                                        PhysicalDeviceObject,
                                        TRUE,
                                        &deviceObject);
       mcdCount++;
    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,"CreateChangerDeviceObjects: Can not create device %s\n",
                    deviceNameBuffer));

        goto CreateChangerDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system tape number
    //

    fdoExtension->DeviceNumber = mcdCount - 1;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // The attach failed. Cleanup and return.
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateChangerDeviceObjectExit;
    }


    //
    // Create the dos port driver name.
    //

    swprintf(dosNameBuffer,
             L"\\DosDevices\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&dosUnicodeString, dosNameBuffer);

    //
    // Recreate the deviceName
    //

    swprintf(wideNameBuffer,
             L"\\Device\\Changer%d",
             fdoExtension->DeviceNumber);

    RtlInitUnicodeString(&deviceUnicodeString,
                         wideNameBuffer);


    mcdClassData = (PMCD_CLASS_DATA)(fdoExtension->CommonExtension.DriverData);
    (ULONG_PTR)mcdClassData += mcdInitData->ChangerAdditionalExtensionSize();
    if (NT_SUCCESS(IoAssignArcName(&dosUnicodeString, &deviceUnicodeString))) {
          mcdClassData->DosNameCreated = TRUE;
    } else {
          mcdClassData->DosNameCreated = FALSE;
    }

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    ObDereferenceObject(lowerDevice);

    return(STATUS_SUCCESS);

CreateChangerDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;


} // end CreateChangerDeviceObject()


NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    )
{
    return ClassSendSrbSynchronous(DeviceObject, Srb,
                                   Buffer, BufferSize,
                                   WriteToDevice);
}


PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )

{
    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, 'CMcS');
}


VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    )
{
    ExFreePool(PoolToFree);
}

#if DBG
#define MCHGR_DEBUG_PRINT_BUFF_LEN 128
ULONG MCDebug = 0;
UCHAR DebugBuffer[MCHGR_DEBUG_PRINT_BUFF_LEN];
#endif


#if DBG

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all medium changer drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= MCDebug) {

        _vsnprintf(DebugBuffer, MCHGR_DEBUG_PRINT_BUFF_LEN,
                  DebugMessage, ap);

        DbgPrintEx(DPFLTR_MCHGR_ID, DPFLTR_INFO_LEVEL, DebugBuffer);
    }

    va_end(ap);

} // end MCDebugPrint()

#else

//
// DebugPrint stub
//

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\class\mcdwmi.c ===
/*++ 
Copyright (C) Microsoft Corporation, 1999

Module Name:

    mcdwmi.c

Abstract:

    This is the changer class driver - WMI support routines.

Environment:

    kernel mode only

Revision History:

--*/
#include "mchgr.h"

//
// Internal routines
//
NTSTATUS
ChangerWMIGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PGET_CHANGER_PARAMETERS changerParameters
    );

//
// List of WMI GUIDs 
//
GUIDREGINFO ChangerWmiFdoGuidList[] =
{
   {
      WMI_CHANGER_PARAMETERS_GUID,
      1,
      0
   },

   {
      WMI_CHANGER_PROBLEM_WARNING_GUID,
      1,
      WMIREG_FLAG_EVENT_ONLY_GUID
   },

   {
      WMI_CHANGER_PROBLEM_DEVICE_ERROR_GUID,
      1,
      WMIREG_FLAG_EXPENSIVE
   },
};

GUID ChangerDriveProblemEventGuid = WMI_CHANGER_PROBLEM_WARNING_GUID;

//
// GUID index. It should match the list defined above
//
#define ChangerParametersGuid           0
#define ChangerProblemWarningGuid       1
#define ChangerProblemDevErrorGuid      2

//
// ISSUE: 02/29/2000 - nramas : Should make wmi routines pagable
//
/*
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, 

#endif
*/

NTSTATUS
ChangerFdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
{
   //
   // Use devnode for FDOs
   //
   *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
   return STATUS_SUCCESS;
}

NTSTATUS
ChangerFdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   PMCD_INIT_DATA mcdInitData;
   ULONG sizeNeeded = 0;
   
   switch (GuidIndex) {
      case ChangerParametersGuid: {
         GET_CHANGER_PARAMETERS changerParameters;
         PWMI_CHANGER_PARAMETERS outBuffer;

         sizeNeeded = sizeof(WMI_CHANGER_PARAMETERS);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }
         
         status = ChangerWMIGetParameters(DeviceObject,
                                          &changerParameters);
         if (NT_SUCCESS(status)) {
            outBuffer = (PWMI_CHANGER_PARAMETERS)Buffer;
            outBuffer->NumberOfSlots = changerParameters.NumberStorageElements;
            outBuffer->NumberOfDrives = changerParameters.NumberDataTransferElements;
            outBuffer->NumberOfIEPorts = changerParameters.NumberIEElements;
            outBuffer->NumberOfTransports = changerParameters.NumberTransportElements;
            outBuffer->NumberOfDoors = changerParameters.NumberOfDoors;
            outBuffer->MagazineSize = changerParameters.MagazineSize;
            outBuffer->NumberOfCleanerSlots = changerParameters.NumberCleanerSlots;
         }

         break;
      }

      case ChangerProblemDevErrorGuid: {
         PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError;

         mcdInitData = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                  ChangerClassInitialize);

         if (mcdInitData == NULL) {
             status = STATUS_NO_SUCH_DEVICE;
             break;
         }

         if (!(mcdInitData->ChangerPerformDiagnostics)) {
             status = STATUS_NOT_IMPLEMENTED;
             break;
         }

         sizeNeeded = sizeof(WMI_CHANGER_PROBLEM_DEVICE_ERROR);
         if (BufferAvail < sizeNeeded) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         changerDeviceError = (PWMI_CHANGER_PROBLEM_DEVICE_ERROR)Buffer;
         RtlZeroMemory(changerDeviceError, 
                       sizeof(WMI_CHANGER_PROBLEM_DEVICE_ERROR));
         status = mcdInitData->ChangerPerformDiagnostics(DeviceObject,
                                                         changerDeviceError);
         break;
      }

      default: {
         sizeNeeded = 0;
         status = STATUS_WMI_GUID_NOT_FOUND;
         break;
      }
   } // switch (GuidIndex)

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    sizeNeeded,
                                    IO_NO_INCREMENT);

   return status;
}


NTSTATUS
ChangerWMIGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PGET_CHANGER_PARAMETERS changerParameters
    )
/*+++

Routine Description: 
   Sends the IOCTL to get the changer parameters
   
Arguments :

   DeviceObject The changer device objcet
   ChangerParameters buffer in which the changer parameters is returned.
   
Return value:

   NT Status.
--*/
{
   KEVENT event;
   PDEVICE_OBJECT topOfStack;
   PIRP irp = NULL;
   IO_STATUS_BLOCK ioStatus;
   NTSTATUS status;

   KeInitializeEvent(&event, SynchronizationEvent, FALSE);

   topOfStack = IoGetAttachedDeviceReference(DeviceObject);

   //
   // Send down irp to get the changer parameters
   //
   irp = IoBuildDeviceIoControlRequest(
                   IOCTL_CHANGER_GET_PARAMETERS,
                   topOfStack,
                   NULL,
                   0,
                   changerParameters,
                   sizeof(GET_CHANGER_PARAMETERS),
                   FALSE,
                   &event,
                   &ioStatus);
   if (irp != NULL) { 
       status = IoCallDriver(topOfStack, irp);
       if (status == STATUS_PENDING) {
           KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
           status = ioStatus.Status;
       }
   } else {
       status = STATUS_INSUFFICIENT_RESOURCES;
   }

   ObDereferenceObject(topOfStack);
   return status;
}

NTSTATUS
ChangerWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

    This function can be used to enable\disable datablock collection. 

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
   NTSTATUS status;

   if (Function == DataBlockCollection) {
      DebugPrint((3,
                  "ChangerWmiFunctionControl : Irp %p - %s DataBlockCollection",
                  " for Device %p.\n",
                  Irp, Enable ? "Enable " : "Disable ", DeviceObject));
      status = STATUS_SUCCESS;
   } else {
       //
       // ISSUE: 03/01/2000 - nramas
       // Need to handle EventGeneration. But now we don't do polling
       // of the changers to detect failure. So, for now disallow
       // EventGeneration
       //
      DebugPrint((1,
                  "ChangerWmiFunctionControl : Unknown function %d for ",
                  "Device %p, Irp %p\n",
                  Function, DeviceObject, Irp));

      status = STATUS_INVALID_DEVICE_REQUEST;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);
   return status;
}

NTSTATUS
ChangerFdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{   
   NTSTATUS status = STATUS_SUCCESS;


   DebugPrint((3,
               "ChangerFdoExecuteMethod : Device %p, Irp %p, ",
               "GuidIndex %d\n",
               DeviceObject, Irp, GuidIndex));

   if (GuidIndex > ChangerProblemDevErrorGuid) {
      status = STATUS_WMI_GUID_NOT_FOUND;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);

   return status;
}

NTSTATUS
ChangerFdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*+

Routine Description :

   This routine is called to set the contents of a datablock.
   When the driver is finished setting the buffer, it must call
   ClassWmiCompleteRequest to complete the irp. The driver can
   return STATUS_PENDING if the irp cannot be completed immediately.

Arguments :

   Device object of the device being referred.

   Irp is the WMI Irp

   GuidIndex is the index of the guid for which the data is being set

   BufferSize is the size of the data block

   Buffer is the pointer to the data block

Return valus :

   NTSTATUS returned by ClassWmiCompleteRequest
   STATUS_WMI_READ_ONLY if the datablock cannot be modified.
   STATUS_WMI_GUID_NOT_FOUND if an invalid guid index is passed
-*/
{
   NTSTATUS status = STATUS_WMI_READ_ONLY;

   DebugPrint((3,
               "ChangerWmiSetBlock : Device %p, Irp %p, ",
               "GuidIndex %d\n",
               DeviceObject, Irp, GuidIndex));

   if (GuidIndex > ChangerProblemDevErrorGuid) {
      status = STATUS_WMI_GUID_NOT_FOUND;
   }

   status = ClassWmiCompleteRequest(DeviceObject,
                                    Irp,
                                    status,
                                    0,
                                    IO_NO_INCREMENT);

   DebugPrint((3, "ChangerSetWmiDataBlock : Device %p, Irp %p, returns %x\n",
               DeviceObject, Irp, status));
   return status;
}

NTSTATUS
ChangerFdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

   NTSTATUS returned by ClassWmiCompleteRequest
   STATUS_WMI_READ_ONLY if the datablock cannot be modified.
   STATUS_WMI_GUID_NOT_FOUND if an invalid guid index is passed

-*/
{
    NTSTATUS status = STATUS_WMI_READ_ONLY;

    DebugPrint((3,
                "TapeSetWmiDataItem, Device %p, Irp %p, GuiIndex %d",
                "  BufferSize %#x Buffer %p\n",
                DeviceObject, Irp,
                GuidIndex, DataItemId,
                BufferSize, Buffer));

    if (GuidIndex > ChangerProblemDevErrorGuid) {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    DebugPrint((3, "TapeSetWmiDataItem Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\adicsc\adicsc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    adicsc.c

Abstract:

    This module contains device-specific routines for the ADIC Scalar medium changers:
    ADIC Scalar 218,224,448, 458.

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "adicsc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, AdicBuildAddressMapping)
#endif


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the ADIC Scalar changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = AdicBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));

        //
        // Indicate that the device needs to re-init.
        //

        changerData->AddressMapping.Initialized = FALSE;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "Adicsc.ChangerInitialize: Error allocating dataBuffer. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"Scalar DLT", 10) == 10) {
            changerData->DriveID = ADIC_SCALAR;
        }
        if (RtlCompareMemory(dataBuffer->ProductId,"Scalar 100", 10) == 10) {
            changerData->DriveID = ADIC_SCALAR;
        }
        if ((RtlCompareMemory(dataBuffer->ProductId,"FastStor DLT", 12) == 12) ||
            (RtlCompareMemory(dataBuffer->ProductId,"PV 120T DLT", 11) == 11)) {
            changerData->DriveID = ADIC_FASTSTOR;
        }
    }

    ChangerClassFreePool(dataBuffer);

    //
    // We'll try to get device identifier info. If it fails
    // this flag will be set to FALSE so that subsequently
    // we won't try to get device identifier info
    //
    changerData->ObtainDeviceIdentifier = TRUE;

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x82:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            //
            // The ADIC returns 4/40/01 for some illegal commands.
            //

            if (senseBuffer->AdditionalSenseCode == 0x40) {
                if (senseBuffer->AdditionalSenseCodeQualifier == 0x01) {
                    *Retry = FALSE;
                    *Status = STATUS_INVALID_DEVICE_REQUEST;
                }
            } else {
                changerData->DeviceStatus = ADICSC_HW_ERROR;
            }
            break;

        default:
            break;
        }
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    ADIC Scalar changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 1;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 0;
    changerParameters->DriveCleanTimeout = 300;

    if (!addressMapping->Initialized) {
        ULONG i;

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;

        //
        // Determine the lowest element address for use with AllElements.
        //

        for (i = 0; i < ChangerDrive; i++) {
            if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {
                addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
            }
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //
    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Set IEPort flags if the changer has at least one IEPort
    //
    if (changerParameters->NumberIEElements != 0) {
       changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                      CHANGER_IEPORT_USER_CONTROL_CLOSE;
    } 

    //
    // The ADICs indicates whether a bar-code scanner is
    // attached by setting bit-0 in this byte.
    //

    changerParameters->Features0 |= ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
                                         CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;
    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
                                    CHANGER_POSITION_TO_ELEMENT           |
                                    CHANGER_PREDISMOUNT_EJECT_REQUIRED    |
                                    CHANGER_DRIVE_CLEANING_REQUIRED       |
                                    CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS    |
                                    CHANGER_CLEANER_ACCESS_NOT_VALID;

    if (changerParameters->NumberIEElements == 0) {

        //
        // No real IE Elements - nothing can be programatically locked.
        //

        changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_DRIVE);

    } else {
        changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_DRIVE | CHANGER_TO_IEPORT);
    }

    changerParameters->LockUnlockCapabilities = 0;

    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstSlotNumber = 1;

    if (changerParameters->Features0 & CHANGER_BAR_CODE_SCANNER_INSTALLED) {

        if ((changerParameters->NumberStorageElements == 17) ||
            (changerParameters->NumberStorageElements == 6)) {

            //
            // This is the 218 or FastStor
            // Barcode scanner steals the lowest slot.
            //

            changerParameters->FirstSlotNumber = 2;

        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Fix up the 218's storage capabilities.
    //

    if (changerParameters->NumberIEElements == 0) {
        changerParameters->Features0 &= ~CHANGER_STORAGE_IEPORT;
    }

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // The FastStor's door really isn't a door in 
    // the same sense as other changers, neither is its ieport 
    //
    if(changerData->DriveID == ADIC_FASTSTOR) {
          changerParameters->NumberIEElements = 0;
          changerParameters->Features0 &= ~(CHANGER_STORAGE_IEPORT |
                                            CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS);
          changerParameters->Features1 &= ~(CHANGER_IEPORT_USER_CONTROL_OPEN |
                                      CHANGER_IEPORT_USER_CONTROL_CLOSE);
    } 

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->InquiryData.VendorSpecific, SERIAL_NUMBER_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

   // doors cannot be locked, 
   // ieport has no extend/retract feature on 448 unit
   // ieport solenoid burns out if left activated constandly, 
   //   so ieport locking is only done around MoveMedium calls that
   //   involve the IEPORT. 
   // therefore all calls to this function are invalid. 

   return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    PCHANGER_ELEMENT_STATUS_EX elementStatusEx;
    ULONG    totalElements = readElementStatus->ElementList.NumberOfElements;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    
    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // length will be based on whether vol. tags are returned and element type(s).
    //

    if (elementType == AllElements) {

        //
        // There should be 4 status pages in the returned buffer.
        //

        statusPages = 4;
    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }


        statusPages = 1;
    }

    //
    // Account for length of all status pages and the header.
    //

    length = sizeof(ELEMENT_STATUS_HEADER) + (statusPages * sizeof(ELEMENT_STATUS_PAGE));

    if ((readElementStatus->VolumeTagInfo) ||
        (elementType == ChangerDrive)) {

        //
        // Each descriptor will have an embedded volume tag buffer.
        //
        // Changer returns serialnumbers of the drives
        //

        length += sizeof(ADICS_ELEMENT_DESCRIPTOR_PLUS) *  readElementStatus->ElementList.NumberOfElements;

    } else {

        length += sizeof(ADICS_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements;
    }


    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
 
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

RetryRequest:

    RtlZeroMemory(statusBuffer, length);

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // ISSUE - 2001/04/11 - nramas : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) &&
        (changerData->ObtainDeviceIdentifier == TRUE)) {

        //
        // Set this bit to retrieve device identifier information
        //
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

        //
        // Since serial number info follows volume tag field,
        // we need to set VolTag bit also in the CDB
        //
        cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    } else {
        cdb->READ_ELEMENT_STATUS.Reserved1 = 0x00;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PADICS_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;


        //
        // Check if the error was STATUS_DATA_OVERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           //
           // Check if there was a DATA_OVERRUN, or was it just 
           // DATA_UNDERRUN reported as DATA_OVERRRUN.
           //
           if (srb->DataTransferLength < length) {
              DebugPrint((1, 
                          "DATA_UNDERRUN reported as DATA_OVERRUN."));
              DebugPrint((1,
                          "Expected: %d, Transferred: %d.\n",
                          length, srb->DataTransferLength));
              status = STATUS_SUCCESS;
           } else {
              //
              // It was really DATA_OVERRUN error. Report accordingly.
              //
              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                    elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                    (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Ensure that media is actually present. If so, get the tag info.
                //

                if (elementDescriptor->Full) {
                    if (tagInfo) {
                        if (statusPage->PVolTag) {
                            ULONG tagIndex;

                            //
                            // Verify validity of volume tag information.
                            //

                            for (tagIndex = 0; tagIndex < 14; tagIndex++) {
                                if (((PADICS_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->VolumeTagDeviceID.VolumeTagInformation[tagIndex] != 0) {
                                    break;
                                }
                            }
                            if (tagIndex == 14) {

                                elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                                elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;

                            } else {
                                RtlMoveMemory(elementStatus->PrimaryVolumeID,
                                              ((PADICS_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor)->VolumeTagDeviceID.VolumeTagInformation,
                                              MAX_VOLUME_ID_SIZE);

                                elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                            }

                        } else {
                            DebugPrint((1,
                                       "ChangerGetElementStatus: tagInfo requested but PVoltag not set\n"));
                        }
                    }
                }
                
                if (elementType == ChangerDrive) {
                    if (outputBuffLen >= 
                        (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {

                        PADICS_ELEMENT_DESCRIPTOR_PLUS elementDescPlus = 
                            (PADICS_ELEMENT_DESCRIPTOR_PLUS) elementDescriptor;
                        PUCHAR idField = NULL;
                        ULONG idLength = 0;

                        elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus;

                        if (statusPage->PVolTag) {
                            idField =  elementDescPlus->VolumeTagDeviceID.Identifier;
                            idLength = elementDescPlus->VolumeTagDeviceID.IdLength;
                        } else {
                            idField = elementDescPlus->DeviceID.Identifier;
                            idLength = elementDescPlus->DeviceID.IdLength;
                        }

                        if (idLength != 0) {

                            if (idLength > SERIAL_NUMBER_LENGTH) {
                                idLength = SERIAL_NUMBER_LENGTH;
                            }

                            RtlMoveMemory(elementStatusEx->SerialNumber,
                                          idField,
                                          idLength);

                            DebugPrint((3, "Serial number : %s\n",
                                        elementStatusEx->SerialNumber));

                            elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                        }
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //
                if (outputBuffLen >=
                    (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    DebugPrint((3,
                                "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {
                    elementStatus += 1;
                }

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        if (outputBuffLen >= 
            (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        } else {
            Irp->IoStatus.Information = numberElements * sizeof(CHANGER_ELEMENT_STATUS);
        }

    } else if (status == STATUS_INVALID_DEVICE_REQUEST) {
        //
        // Probably the device doesn't support DVCID bit
        // which retrieves Device Identifier info such as 
        // serial number for drives. Try RES once more with
        // DVCID bit turned off.
        // 
        if (changerData->ObtainDeviceIdentifier == TRUE) {
            changerData->ObtainDeviceIdentifier = FALSE;
            goto RetryRequest;
        }
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        //
        // Use the ADIC vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // The Scalars don't support 2-sided media.
    //

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the Scalars units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status, moveStatus;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // ADICs don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    // Pre-MoveMedium Locking ? =========================================

    // if source or destination involved IEPORT, lock the IEPORT first
    if ((moveMedium->Source.ElementType == ChangerIEPort) || 
        (moveMedium->Destination.ElementType == ChangerIEPort)) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        // lock the IEPORT !
        cdb->MEDIA_REMOVAL.Prevent = 1;
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
        if (!NT_SUCCESS(status)) {
           DebugPrint((1,
                       "Pre-MoveMedium Locking failed : ",
                       status));
        }
    }



    // MoveMedium  =========================================

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;
    srb->DataTransferLength = 0;
    moveStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(moveStatus)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } 

    // Post-MoveMedium UnLocking ? =========================================

    // if source or destination involved IEPORT, unlock the IEPORT
    if ((moveMedium->Source.ElementType == ChangerIEPort) || 
        (moveMedium->Destination.ElementType == ChangerIEPort)) {

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        // unlock the IEPORT !
        cdb->MEDIA_REMOVAL.Prevent = 0;
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
        if (!NT_SUCCESS(status)) {
           DebugPrint((1,
                       "Post-MoveMedium UnLocking failed : ",
                       status));
        }
    }

    ChangerClassFreePool(srb);
    return moveStatus;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
AdicBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ADIC_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);


    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;

        //
        // Determine the lowest element address for use with AllElements.
        //

        for (i = 0; i < ChangerDrive; i++) {
            if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

                DebugPrint((1,
                           "BuildAddressMapping: New lowest address %x\n",
                           addressMapping->FirstElement[i]));
                addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
            }
        }
    }



    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PADICS_ELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asq = ElementDescriptor->AddSenseCodeQualifier;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x83:
            if (asq == 0x03) {
                exceptionCode = ERROR_LABEL_QUESTIONABLE;
            }
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "adicsmc: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               asq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ADIC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // ADICSC_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = ADICSC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ADICSC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ADICSC_DEVICE_PROBLEM_NONE) {
       changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\adicsc\adicsc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    adicsc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _ADIC_MC_
#define _ADIC_MC_

typedef struct _ADICS_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;                      // true for drives only
    UCHAR Reserved6 : 1;                // true for drives only
    UCHAR LunValid : 1;                 // true for drives only
    UCHAR IdValid : 1;                  // true for drives only
    UCHAR Reserved7 : 1;                // true for drives only
    UCHAR NotThisBus : 1;               // true for drives only
    UCHAR BusAddress;                   // true for drives only
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} ADICS_ELEMENT_DESCRIPTOR, *PADICS_ELEMENT_DESCRIPTOR;

typedef struct _ADICS_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];

    union {

        struct {
            UCHAR VolumeTagInformation[36];
            UCHAR CodeSet : 4;
            UCHAR Reserved10 : 4;
            UCHAR IdType : 4;
            UCHAR Reserved11: 4;
            UCHAR Reserved12;
            UCHAR IdLength;
            UCHAR Identifier[40];
        } VolumeTagDeviceID;

        struct {
            UCHAR CodeSet : 4;
            UCHAR Reserved10 : 4;
            UCHAR IdType : 4;
            UCHAR Reserved11: 4;
            UCHAR Reserved12;
            UCHAR IdLength;
            UCHAR Identifier[40];
        } DeviceID;

    };

} ADICS_ELEMENT_DESCRIPTOR_PLUS, *PADICS_ELEMENT_DESCRIPTOR_PLUS;


#define ADIC_NO_ELEMENT 0xFFFF

#define ADIC_SCALAR  1
#define ADIC_FASTSTOR 2

//
// Diagnostic related defines
//
// Device Status codes
//
#define ADICSC_DEVICE_PROBLEM_NONE     0x00
#define ADICSC_HW_ERROR                0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device status after Send Diagnostic
    //
    ULONG DeviceStatus;

    //
    // Flag to indicate whether or not the driver
    // should attempt to retrieve Device Identifier
    // info (serialnumber, etc). Not all devices
    // support this
    //
    BOOLEAN ObtainDeviceIdentifier;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;

//
// Internal routines to adicsc
//
NTSTATUS
AdicBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PADICS_ELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\adicvls\adicvls.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    adicvls.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _ADICVLS_MC_
#define _ADICVLS_MC_

typedef struct _ADICVLS_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} ADICVLS_ELEMENT_DESCRIPTOR, *PADICVLS_ELEMENT_DESCRIPTOR;

#define ADIC_NO_ELEMENT 0xFFFF


typedef struct _ADIC_SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
    UCHAR VendorStatus[3];
    UCHAR MagazinePosition;
} ADIC_SENSE_DATA, *PADIC_SENSE_DATA;

//
// Bit defs for Vendor status
//

#define SENSOR_BEAM_BLOCKED 0x4

#define ADIC_SENSE_LENGTH 22

//
// Diagnostic related defines
//
// ASC
//
#define ADICVLS_ASC_CHM_ERROR          0x15
#define ADICVLS_ASC_DIAGNOSTIC_ERROR   0x40

//
// ASCQ
//
#define ADICVLS_ASCQ_DOOR_OPEN                0x88
#define ADICVLS_ASCQ_GRIPPER_ERROR            0x91
#define ADICVLS_ASCQ_GRIPPER_MOVE_ERROR       0x92
#define ADICVLS_ASCQ_CHM_MOVE_SHORT_AXIS      0xA0
#define ADICVLS_ASCQ_CHM_SHORT_HOME_POSITION  0xA1
#define ADICVLS_ASCQ_CHM_DEST_SHORT_AXIS      0xA5
#define ADICVLS_ASCQ_CHM_MOVE_LONG_AXIS       0xB0
#define ADICVLS_ASCQ_CHM_LONG_HOME_POSITION   0xB1
#define ADICVLS_ASCQ_CHM_DEST_LONG_AXIS       0xB5
#define ADICVLS_ASCQ_DRUM_MOVE_ERROR          0xC0
#define ADICVLS_ASCQ_DRUM_HOME_ERROR          0xC1
#define ADICVLS_ASCQ_CHM_DEST_LONG            0xE5
#define ADICVLS_ASCQ_CHM_SHORT_AXIS_MOVE      0xF1

//
// DeviceStatus
//
#define ADICVLS_DEVICE_PROBLEM_NONE      0x00
#define ADICVLS_HW_ERROR                 0x01
#define ADICVLS_CHM_ERROR                0x02
#define ADICVLS_CHM_MOVE_ERROR           0x03
#define ADICVLS_GRIPPER_ERROR            0x04
#define ADICVLS_DOOR_OPEN                0x05


#define ADIC_1200       1               // 1-drive model
#define ADIC_VLS    2           // 2-drive model (except for DLT)

#define ADIC_4mm            1
#define ADIC_8mm_EXB    2
#define ADIC_8mm_SONY   3
#define ADIC_DLT            4

#define SCSIOP_ADIC_ALIGN_ELEMENTS 0xE5

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostic send completes
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    PVOID Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
AdicvlsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

PADIC_SENSE_DATA
InternalSendRequestSense(
    IN PDEVICE_OBJECT DeviceObject
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\adicvls\adicvls.c ===
/*++

Copyright (C) 1996-97  Microsoft Corporation

Module Name:

    adicvls.c

Abstract:

    This module contains device-specific routines for ADIC's VLS
    and 1200x series of Changers. These changers support the
    following drives:
      - HP and Sony 4mm DDS
      - Exabyte 8mm
      - Sony SDX 8mm
      - Quantum DLT

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "adicvls.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, AdicvlsBuildAddressMapping)
#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, InternalSendRequestSense)
#pragma alloc_text(PAGE, MapExceptionCodes)
#endif



ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the various VLS/1200 changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = AdicvlsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }

        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"DAT AutoChanger",15) == 15) {
        changerData->DriveType = ADIC_1200;
        changerData->DriveID   = ADIC_4mm;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS 4mm",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_4mm;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS 8mm",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_8mm_EXB;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS SDX",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_8mm_SONY;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"VLS DLT",7) == 7) {
        changerData->DriveType = ADIC_VLS;
        changerData->DriveID   = ADIC_DLT;
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    ULONG deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey) {
            case SCSI_SENSE_NOT_READY:
                break;

            case SCSI_SENSE_UNIT_ATTENTION:
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
                UCHAR adicvlsASC;
                UCHAR adicvlsASCQ;

                adicvlsASC = senseBuffer->AdditionalSenseCode;
                adicvlsASCQ = senseBuffer->AdditionalSenseCodeQualifier;

                deviceStatus = ADICVLS_HW_ERROR;
                switch (adicvlsASC) {
                  case ADICVLS_ASC_CHM_ERROR: {
                      deviceStatus = ADICVLS_CHM_ERROR;
                      break;
                  }

                  case ADICVLS_ASC_DIAGNOSTIC_ERROR: {
                      switch (adicvlsASCQ) {
                        case ADICVLS_ASCQ_DOOR_OPEN: {
                            deviceStatus = ADICVLS_DOOR_OPEN;
                            break;
                        }

                        case ADICVLS_ASCQ_GRIPPER_ERROR:
                        case ADICVLS_ASCQ_GRIPPER_MOVE_ERROR: {
                            deviceStatus = ADICVLS_GRIPPER_ERROR;
                           break;
                        }

                        case ADICVLS_ASCQ_CHM_MOVE_SHORT_AXIS:
                        case ADICVLS_ASCQ_CHM_SHORT_HOME_POSITION:
                        case ADICVLS_ASCQ_CHM_DEST_SHORT_AXIS:
                        case ADICVLS_ASCQ_CHM_MOVE_LONG_AXIS:
                        case ADICVLS_ASCQ_CHM_LONG_HOME_POSITION:
                        case ADICVLS_ASCQ_CHM_DEST_LONG_AXIS:
                        case ADICVLS_ASCQ_DRUM_MOVE_ERROR:
                        case ADICVLS_ASCQ_DRUM_HOME_ERROR:
                        case ADICVLS_ASCQ_CHM_DEST_LONG:
                        case ADICVLS_ASCQ_CHM_SHORT_AXIS_MOVE: {
                            deviceStatus = ADICVLS_CHM_MOVE_ERROR;
                            break;
                        }

                        default: {
                            deviceStatus = ADICVLS_HW_ERROR;
                            break;
                        }
                      } // switch (adicvlsASCQ)

                      break;
                  }

                  default: {
                      deviceStatus = ADICVLS_HW_ERROR;
                      break;
                  }
                } // switch (adicvlsASC)

                changerData->DeviceStatus = deviceStatus;
                break;
            }
        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. Srb status %x\n",
                   Srb->SrbStatus));
    }

    return;

}


NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    ADIC VLS/1200 changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK          srb;
    PGET_CHANGER_PARAMETERS      changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE  transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    //
    // These units say they have an IEPORT, but they don't.
    //

    changerParameters->NumberIEElements = 0;

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                     elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                      elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                    elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = (elementAddressPage->NumberTransportElements[0] << 8) |
                                                             elementAddressPage->NumberTransportElements[1];

        addressMapping->NumberOfElements[ChangerDrive] = (elementAddressPage->NumberDataXFerElements[0] << 8) |
                                                         elementAddressPage->NumberDataXFerElements[1];

        addressMapping->NumberOfElements[ChangerIEPort] = 0;

        addressMapping->NumberOfElements[ChangerSlot] = (elementAddressPage->NumberStorageElements[0] << 8) |
                                                        elementAddressPage->NumberStorageElements[1];

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];

        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;
    changerParameters->DriveCleanTimeout = 200;
    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    if (changerData->DriveID == ADIC_DLT) {
       changerParameters->DriveCleanTimeout = 300;
    }

    //
    // Set MagazineSize to number of slots, as
    // all of the slots are in one magazine.
    //

    changerParameters->MagazineSize = (elementAddressPage->NumberStorageElements[0] << 8) |
                                      elementAddressPage->NumberStorageElements[1];

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                     |
                                   CHANGER_CARTRIDGE_MAGAZINE              |
                                   CHANGER_POSITION_TO_ELEMENT             |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE     |
                                   CHANGER_DRIVE_CLEANING_REQUIRED         |
                                   CHANGER_PREDISMOUNT_EJECT_REQUIRED      |
                                   CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS      |
                                   CHANGER_CLEANER_ACCESS_NOT_VALID;

    changerParameters->Features1 = CHANGER_PREDISMOUNT_ALIGN_TO_SLOT       |
                                   CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE;

    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_DRIVE);

    if (changerData->DriveType == ADIC_1200) {

        changerParameters->Features0 &= ~CHANGER_CLEANER_ACCESS_NOT_VALID;
        changerParameters->Features1 &= ~CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE;
        changerParameters->Features1 |= CHANGER_CLEANER_OPS_NOT_SUPPORTED;
        changerParameters->PositionCapabilities &= ~CHANGER_TO_DRIVE;
    }

    //
    // build device capabilities mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;

    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    // The device reports that MT->IE is possible. As the Ieport is more conceptual than
    // a real element on these, claim no support.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // See above note concerning IePorts and these devices.
    //

    changerParameters->MoveFromIePort = 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 0;
    changerParameters->ExchangeFromSlot = 0;
    changerParameters->ExchangeFromIePort = 0;
    changerParameters->ExchangeFromDrive = 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;

}



NTSTATUS
ChangerGetStatus(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->InquiryData.VendorSpecific, SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door, Keypad and IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping =
    &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (controlOperation == LOCK_ELEMENT) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1,
                       "Adicvls.SetAccess: Prevent failed - %x\n",
                       status));
            ChangerClassFreePool(srb);
            return status;
        }

        //
        // By sending a move medium from IEPort to transport,
        // the unit will 'load' the magazine.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

        cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] >> 8);
        cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] & 0xFF);

        cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.Flip = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    } else if (controlOperation == UNLOCK_ELEMENT) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

        if (!NT_SUCCESS(status)) {
            DebugPrint((1,
                       "Adicvls.SetAccess: Prevent failed - %x\n",
                       status));
            ChangerClassFreePool(srb);
            return status;
        }

        //
        // By sending a move medium from IEPort to transport,
        // the unit will 'load' the magazine.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

        cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
        cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

        cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] >> 8);
        cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] & 0xFF);

        cdb->MOVE_MEDIUM.Flip = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    }

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    ChangerClassFreePool(srb);
    return status;

}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {
        ULONG i;

        statusPages = 4;

        //
        // Verify that the NumberOfElements for the AllElements request is valid.
        //


        for (i = 0; i <= ChangerDrive; i++) {
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // As the 'ieport' element is stripped off later (and never reported as being present)
        // need to add enough buffer to handle getting this info from the device.
        //

        totalElements += 1;

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }
        statusPages = 1;
    }

    length = sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    if (readElementStatus->VolumeTagInfo) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    length += (sizeof(ADICVLS_ELEMENT_DESCRIPTOR) * totalElements);
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = 0;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] = (UCHAR)((element->ElementAddress +
                                                         addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] = (UCHAR)((element->ElementAddress +
                                                          addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, a status page,
        // and one or more element descriptors.
        // Point each element to its respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // These units will return element status for the 'ieport'. As it's
                // claimed that none exist, bypass this info.
                //

                if (elementType != ChangerIEPort) {
                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;


                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    }

                    //
                    // Build Flags field.
                    //

                    if (elementType != ChangerTransport) {

                        //
                        // The VLS and 1200 devices use a different meaning of transport
                        // full than that which is expected. As moves from transport aren't
                        // possible anyway, claim it's always empty.
                        //

                        elementStatus->Flags = elementDescriptor->Full;
                    }

                    elementStatus->Flags |= (elementDescriptor->Exception << 2);

                    //
                    // The Access bit also has a different meaning on the VLS devices, so report
                    // the FULL state instead of the real Access state.
                    //

                    if (changerData->DriveType != ADIC_1200) {
                         elementStatus->Flags |= (elementDescriptor->Full << 3);
                    } else {
                        elementStatus->Flags |= (elementDescriptor->Accessible << 3);
                    }

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);


                    if (elementDescriptor->Exception) {
                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                        if (elementStatus->ExceptionCode == 0) {

                            //
                            // Turn off the exception bit.
                            //

                            elementStatus->Flags &= ~ELEMENT_STATUS_EXCEPT;
                        }
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                        //
                        // The vls doesn't set LunValid, but it is.
                        //

                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    //
                    // If the element type is a drive, send a request sense to the changer.
                    // This might update the full status, if the media was a cleaner cartridge,
                    // or bad media.
                    //

                    if (elementStatus->Element.ElementType == ChangerDrive) {
                        PADIC_SENSE_DATA requestSenseBuffer;

                        if (changerData->DriveType != ADIC_1200) {
                            requestSenseBuffer = InternalSendRequestSense(DeviceObject);

                            if (requestSenseBuffer) {

                                //
                                // Indicates that the media has been ejected by the drive - either bad media
                                // or a cleaner cartridge.
                                //

                                if (requestSenseBuffer->VendorStatus[0] & SENSOR_BEAM_BLOCKED) {

                                    //
                                    // Indicate that media is actually NOT in the drive.
                                    //

                                    if (elementStatus->Flags & ELEMENT_STATUS_FULL) {

                                        DebugPrint((1,
                                                   "Adicvls: Updating elementStatus to NOT full\n"));

                                        elementStatus->Flags &= ~ELEMENT_STATUS_FULL;
                                    }
                                }

                                ChangerClassFreePool(requestSenseBuffer);
                            }
                        }
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // By sending a move medium from IEPort to transport,
    // the unit will 'load' the magazine.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerIEPort] & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(addressMapping->FirstElement[ChangerTransport] & 0xFF);

    cdb->MOVE_MEDIUM.Flip = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    //
    // If the load fails, throw away the error, and continue.
    //

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                   "InitializeElementStatus: Load magazine failed - %x\n",
                   status));
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
    PADIC_SENSE_DATA requestSenseBuffer;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress + addressMapping->FirstElement[ChangerTransport]);
    maxTransport = (USHORT)(addressMapping->FirstElement[ChangerTransport] +
                            addressMapping->NumberOfElements[ChangerTransport]);

    destination = (USHORT)(setPosition->Destination.ElementAddress +
                           addressMapping->FirstElement[setPosition->Destination.ElementType]);
    maxDest = (USHORT)(addressMapping->FirstElement[setPosition->Destination.ElementType] +
                       addressMapping->NumberOfElements[setPosition->Destination.ElementType]);

    if ((transport > maxTransport) || (destination > maxDest)) {

        //
        // One of the elements specified in the user buffer was out of range.
        //

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send unsolicited request sense to get the current magazine position.
    // If the requested pos. is where the unit is currently, just return success.
    // Could be an optimization, but mainly is used as the vls units will auto-move
    // some media on the position command - hence, the move medium issued afterwards
    // will fail.
    //

    if (setPosition->Destination.ElementType == ChangerSlot) {
        if (changerData->DriveType != ADIC_1200) {
            requestSenseBuffer = InternalSendRequestSense(DeviceObject);

            if (requestSenseBuffer) {
                ULONG currentPosition = requestSenseBuffer->MagazinePosition;

                //
                // Free the buffer allocated by the requestsense call.
                //

                ChangerClassFreePool(requestSenseBuffer);

                if (currentPosition == setPosition->Destination.ElementAddress) {

                    Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
                    return STATUS_SUCCESS;
                }
            }
        }
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DebugPrint((1,
               "SetPosition: Positioning type %x address %x\n",
               setPosition->Destination.ElementType,
               setPosition->Destination.ElementAddress));


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = 0;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
    LONG                lockValue = 0;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //


    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // ADICs don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
AdicvlsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK          srb;
    PCDB                         cdb;
    NTSTATUS                     status;
    ULONG                        bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PVOID                        modeBuffer;
    ULONG                        i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ADIC_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                         elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                     elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                      elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                    elementAddressPage->FirstStorageElementAddress[1];
        //
        // Determine lowest address of all elements.
        //

        //
        // Determine the lowest element address for use with AllElements.
        //

        for (i = 0; i < ChangerDrive; i++) {
            if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

                DebugPrint((1,
                           "BuildAddressMapping: New lowest address %x\n",
                           addressMapping->FirstElement[i]));
                addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 0;
        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    ULONG exceptionCode = 0;
    UCHAR asq = ElementDescriptor->AddSenseCodeQualifier;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;


    DebugPrint((1,
               "MapExceptionCodes: ASC %x, ASCQ %x, ExceptionCode %x\n",
               asc,
               asq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ADIC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


PADIC_SENSE_DATA
InternalSendRequestSense(
    IN PDEVICE_OBJECT DeviceObject
    )

{
    PADIC_SENSE_DATA    requestSenseBuffer;
    PSCSI_REQUEST_BLOCK srb;
    ULONG       length = ADIC_SENSE_LENGTH;
    NTSTATUS    status;
    PCDB        cdb;

    requestSenseBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!requestSenseBuffer) {
        return NULL;
    }

    RtlZeroMemory(requestSenseBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(requestSenseBuffer);
        return NULL;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = 6;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength = (UCHAR)length;
    cdb->CDB6INQUIRY.Control = 0;

    srb->DataBuffer = requestSenseBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 10;

    //
    // Send unsolicited request sense.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (status == STATUS_DATA_OVERRUN) {
        if (srb->DataTransferLength >= ADIC_SENSE_LENGTH) {
            status = STATUS_SUCCESS;
        }
    }

    DebugPrint((1,
               "Adicvls: additional sense length %x\n",
               requestSenseBuffer->AdditionalSenseLength));

    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                   "Adicvls: request sense failed - %x\n",
                   status));

        ChangerClassFreePool(requestSenseBuffer);
        requestSenseBuffer = NULL;
    }

    ChangerClassFreePool(srb);

    return requestSenseBuffer;

}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // ADICVLS_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = ADICVLS_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ADICVLS\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ADICVLS_DEVICE_PROBLEM_NONE) {
       switch (changerData->DeviceStatus) {
         case ADICVLS_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case ADICVLS_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case ADICVLS_DOOR_OPEN: {
            changerDeviceError->ChangerProblemType = DeviceProblemDoorOpen;
            break;
         }

         case ADICVLS_CHM_MOVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
            break;
         }

         case ADICVLS_GRIPPER_ERROR: {
             changerDeviceError->ChangerProblemType = DeviceProblemGripperError;
             break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }      
      } // switch (changerData->DeviceStatus)
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\atl\atlmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    atlmc.c

Abstract:

    This module contains device-specific routines for the following
    ATL medium changers: 
            - ATL 520 and 7100 Series Libraries

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "atlmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                                sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Now get the full inquiry information for the device.

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.TimeOutValue = 10;
    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength +
                             FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        if (RtlCompareMemory(dataBuffer->ProductId,"ACL4/52",7) == 7) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TL810",5) == 5) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TL812",5) == 5) {
            changerData->DriveID = ATL_520;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TL894",5) == 5) {
            changerData->DriveID = ATL_520;

        } else if (RtlCompareMemory(dataBuffer->ProductId,"ATL7100",7) == 7) {
            changerData->DriveID = ATL_7100;
        }
    }

    ChangerClassFreePool(dataBuffer);

    // in case the unit is not set to AutoInventory, do one here !
/*
    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb.Cdb;

    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = fdoExtension->TimeOutValue;
    srb.DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                        SCSIOP_INIT_ELEMENT_STATUS;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);
*/
    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    ULONG deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:
           if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x3:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                    default:
                        break;
                }
           }
           if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x0:
                    case 0x7:
                    case 0x9:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                    default:
                        break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           UCHAR atlASC = senseBuffer->AdditionalSenseCode;
           UCHAR atlASCQ = senseBuffer->AdditionalSenseCodeQualifier;

           deviceStatus = ATL_HW_ERROR;
           
           switch (atlASC) {
            case ATL_ASC_HW_ERROR: {
               deviceStatus = ATL_HW_ERROR;
               break;
            }

            case ATL_ASC_GRIPPER_ERROR: {
               if ((atlASCQ == ATL_ASCQ_GRIPPER_BLOCKED) ||
                   (atlASCQ == ATL_ASCQ_PICK_ERROR)) {
                  deviceStatus = ATL_CHM_ERROR;
               } else {
                  deviceStatus = ATL_HW_ERROR;
               }
               break;
            }

            case ATL_ASC_VERTICAL_ERROR: 
            case ATL_ASC_HORIZONTAL_ERROR: {
               switch (atlASCQ) {
                  case ATL_ASCQ_POSITION_ERROR:
                  case ATL_ASCQ_HOME_NOT_FOUND: {
                     deviceStatus = ATL_CHM_ERROR;
                     break;
                  }

                  default: {
                     deviceStatus = ATL_HW_ERROR;
                     break;
                  }
               } // switch (atlASCQ)
               break;
            }

            case ATL_ASC_LOAD_PORT: {
               if (atlASCQ == ATL_ASCQ_LOAD_PORT_DOOR_OPEN) {
                  *Retry = FALSE;
                  *Status = STATUS_DEVICE_DOOR_OPEN;
                  deviceStatus = ATL_DOOR_OPEN;
               }
               break;
            }

            case ATL_ASC_DLT_DRIVE: {
               if (atlASCQ == ATL_ASCQ_DLT_DRIVE_TIMEOUT) {
                  *Retry = FALSE;
                  *Status = STATUS_DEVICE_NOT_CONNECTED;
                  deviceStatus = ATL_HW_ERROR;
               }
            }

            default: {
               deviceStatus = ATL_HW_ERROR;
               break;
            }
           } // switch (atlASC)

           changerData->DeviceStatus = deviceStatus;
           break;
        } // case SCSI_SENSE_HARDWARE_ERROR

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1D - Element address assignment page.

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    // Fill in values.

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = 
                 elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
                 (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
                 elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
                 (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = 
                 elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= 
                 (elementAddressPage->NumberIEPortElements[0] << 8);
    
    changerParameters->NumberDataTransferElements = 
                 elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
                 (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 1;

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 0; 
    // clean timeout changed from 600 to 300 seconds to 
    // reduce overall clean time from 16 minutes to 11 minutes. 
    changerParameters->DriveCleanTimeout = 300;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1E - transport geometry mode sense.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                             sizeof(MODE_PARAMETER_HEADER) +
                             sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    // initialize Features1  
        changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                                                   CHANGER_IEPORT_USER_CONTROL_CLOSE ;

        // initialize Features0 and then set flip bit...
    changerParameters->Features0 = 
             transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;
 

    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
               CHANGER_BAR_CODE_SCANNER_INSTALLED    |

    // even though this device supports this capability
    // it makes Import/export operations very sloooow
    //           CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
               CHANGER_STATUS_NON_VOLATILE           | 
               CHANGER_LOCK_UNLOCK                   | 
    // Position to Element IS supported by the device but
    // the command currently hangs. Since this is not a
    // feature used by NTMS, it is deemed to be non-critical
    // until the vendor can remedy the problem.                                   
    //         CHANGER_POSITION_TO_ELEMENT           |
               CHANGER_REPORT_IEPORT_STATE           |
               CHANGER_PREDISMOUNT_EJECT_REQUIRED    | 
               CHANGER_CLEANER_ACCESS_NOT_VALID        |
               CHANGER_DRIVE_CLEANING_REQUIRED;

        // door and keypad cannot be locked, only the IEPORT
    changerParameters->LockUnlockCapabilities = 
                LOCK_UNLOCK_IEPORT;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1F - Device Capabilities Page

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // ATL uses an addition 4 bytes past the scsi-defined structure.
    //

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE) + 
              ATL_DEVICE_CAP_EXTENSION;


    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    // Fill in values in Features that are contained in this page.

    changerParameters->Features0 |= 
     capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    // Determine all the move from and exchange from 
    // capabilities of this device.

    changerParameters->MoveFromTransport = 
     capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
     capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 
     capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    // changerParameters->MoveFromIePort |= 
    //  capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = 
     capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    // changerParameters->MoveFromDrive |= 0;
    //  capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
     capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
     capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 
     capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = 
     capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 0;
        //              CHANGER_TO_SLOT | 
        //              CHANGER_TO_IEPORT | 
        //              CHANGER_TO_DRIVE;
                

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
          changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
          changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
          changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, "", 1);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door or IEPort. 

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;

    if ((setAccess->Element.ElementType == ChangerKeypad) || 
                (setAccess->Element.ElementType == ChangerDoor)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (setAccess->Element.ElementType == ChangerIEPort) {

        // Do Prevent/Allow Medium  Removal... 
        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        if (controlOperation == LOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if (controlOperation == UNLOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command 
    for either all elements or the
    specified element type. The buffer returned is used to build 
    the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    // Get the element type.
    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {
        statusPages = 4;
    } else {
        statusPages = 1;
    } 

    if (readElementStatus->VolumeTagInfo) {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (ATL_FULL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    } else {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (ATL_PARTIAL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] =         
        (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =         (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] =
                                      (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] =
                                      (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] =
                                      (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PATL_ED elementDescriptor;
        ULONG numberElements = 
             readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        // Determine total number elements returned.
        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        // The buffer is composed of a header, status page, 
        // and element descriptors.
        // Point each element to it's respective place in the buffer.

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = 
           statusPage->ElementDescriptorLength[1];
        descriptorLength |= 
           (statusPage->ElementDescriptorLength[0] << 8);

        // Determine the number of elements of this type reported.
        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        // Fill in user buffer.
        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                // Get the address for this element.

                elementStatus->Element.ElementAddress =
                 elementDescriptor->ATL_FED.ElementAddress[1];

                elementStatus->Element.ElementAddress |=
                  (elementDescriptor->ATL_FED.ElementAddress[0] << 8);

                // Account for address mapping.
                elementStatus->Element.ElementAddress -= 
                   addressMapping->FirstElement[elementType];

                // Set the element type.
                elementStatus->Element.ElementType = elementType;

                if (elementDescriptor->ATL_FED.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    // Source address is valid. 
                    // Determine the device specific address.
                    tmpAddress = elementDescriptor->ATL_FED.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->ATL_FED.SourceStorageElementAddress[0] << 8);

                    // Now convert to 0-based values.
                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress =
                         tmpAddress - addressMapping->FirstElement[j];

                }

                // Build Flags field.

                elementStatus->Flags = 
                 elementDescriptor->ATL_FED.Full;
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.Exception << 2);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.Accessible << 3);

                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.LunValid << 12);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.IdValid << 13);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.NotThisBus << 15);

                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.Invert << 22);
                elementStatus->Flags |= 
                 (elementDescriptor->ATL_FED.SValid << 23);


                elementStatus->ExceptionCode = 
                 MapExceptionCodes(elementDescriptor);

                if (elementDescriptor->ATL_FED.IdValid) {
                    elementStatus->TargetId = 
                     elementDescriptor->ATL_FED.BusAddress;
                }
                if (elementDescriptor->ATL_FED.LunValid) {
                    elementStatus->Lun = elementDescriptor->ATL_FED.Lun;
                }

                //if (tagInfo) {
                //   RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                //        elementDescriptor->ATL_FED.PrimaryVolumeTag, 
                //        MAX_VOLUME_ID_SIZE);
                //    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                //}


                if (tagInfo) {
                    if (statusPage->PVolTag) {

                        ULONG tagIndex;

                        //
                        // ATL returns 32 " " + 4 NULL characters if missing label
                        //

                        for (tagIndex = 0; tagIndex < 36; tagIndex++) {
                            if (elementDescriptor->ATL_FED.PrimaryVolumeTag[tagIndex] != ' ') { 
                                break;
                            }
                        }
                        if (tagIndex == 32) {

                            elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                            elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;

                        } else {
                            RtlMoveMemory(elementStatus->PrimaryVolumeID,elementDescriptor->ATL_FED.PrimaryVolumeTag,
                                          MAX_VOLUME_ID_SIZE);

                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }

                    } 
                }

                // Get next descriptor.
                (ULONG_PTR)elementDescriptor += descriptorLength;

                // Advance to the next entry in the user 
                // buffer and element descriptor array.
                elementStatus += 1;
            }

            if (remainingElements > 0) {
                // Get next status page.
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                // Point to decriptors.
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                   statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                   (statusPage->ElementDescriptorLength[0] << 8);

                // Determine the number of this element type reported.
                typeCount = statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);
                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either 
    initialize all elements or the specified range of elements 
    using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if (initElementStatus->ElementList.Element.ElementType != 
                                                          AllElements) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                        SCSIOP_INIT_ELEMENT_STATUS;

    cdb->INIT_ELEMENT_STATUS.NoBarCode = 
                        initElementStatus->BarCodeScan ? 0 : 1;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 
                          sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the 
    robotic mechanism to the specified
    element address. Normally used to optimize moves or 
    exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    return STATUS_INVALID_DEVICE_REQUEST;

/*
    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerDoor)) {
        return STATUS_INVALID_PARAMETER;
    }


         

    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    // Convert to device addresses.

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += 
     addressMapping->FirstElement[setPosition->Destination.ElementType];

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    // Build srb and cdb.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    // Build device-specific addressing.

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] =
                    (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = 
                    (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = 
                    (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = 
                    (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;

*/
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 
      (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 
      (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = 
      (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = 
      (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 
      (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 
      (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension =DeviceObject->DeviceExtension;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    // Do Rezero Unit ... 
    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_REZERO_UNIT;

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }
    return status;
}




NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ATL_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = 
         (elementAddressPage->MediumTransportElementAddress[0] << 8) |
         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = 
         (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
         elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = 
         (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
         elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = 
         (elementAddressPage->FirstStorageElementAddress[0] << 8) |
         elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 
         elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= 
         (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = 
         elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= 
         (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 
         elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= 
         (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = 
         elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= 
         (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;
    }


    // Determine the lowest element address for use with AllElements.
    //
    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < 
                         addressMapping->FirstElement[AllElements]) {
            addressMapping->FirstElement[AllElements] = 
                                     addressMapping->FirstElement[i];
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PATL_ED ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor 
    and creates the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->ATL_FED.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->ATL_FED.AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {

        case 0x80:
            switch (asq) {
                case 0x22:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;

            }
                break; // 0x85

        case 0x8D:
            switch (asq) {
                case 0x22:

                case 0xF3:
                    exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
                    break;
            }

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ATL_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.
Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // ATL_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = ATL_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ATLMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set PF & SelfTest bits
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0xA;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ATL_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case ATL_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case ATL_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case ATL_DOOR_OPEN: {
            changerDeviceError->ChangerProblemType = DeviceProblemDoorOpen;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch (changerData->DeviceStatus) 
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\breece\breecemc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    breecemc.h

Abstract:

Authors:

    davet (Dave Therrien)

Revision History:

--*/
#ifndef _BREECE_MC_
#define _BREECE_MC_

//
// Breece Hill uses an addition 4 bytes on their device capabilities page...
//

#define BREECE_DEVICE_CAP_EXTENSION 4

typedef union _BHT_ED {

    struct _BHT_FED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } BHT_FED, *PBHT_FED;

    struct _BHT_PED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } BHT_PED, *PBHT_PED;

} BHT_ED, *PBHT_ED;

#define BHT_PARTIAL_SIZE sizeof(struct _BHT_PED)
#define BHT_FULL_SIZE sizeof(struct _BHT_FED)

#define BHT_DISPLAY_LINES        2
#define BHT_DISPLAY_LINE_LENGTH 16

typedef struct _LCD_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR WriteLine : 4;
    UCHAR Reserved2 : 2;
    UCHAR LCDSecurity : 1;
    UCHAR SecurityValid : 1;
    UCHAR Reserved4;
    UCHAR DisplayLine[BHT_DISPLAY_LINES][BHT_DISPLAY_LINE_LENGTH];
    UCHAR Reserved5[28];        // not used
} LCD_MODE_PAGE, *PLCD_MODE_PAGE;

#define BHT_NO_ELEMENT 0xFFFF

//
// Diagnostic sense codes
//
// ASC
// 
#define BREECE_ASC_HW_NOT_RESPONDING        0x08
#define BREECE_ASC_PICK_PUT_ERROR           0x15
#define BREECE_ASC_DRIVE_ERROR              0x3B
#define BREECE_ASC_DIAGNOSTIC_ERROR         0x40
#define BREECE_ASC_INTERNAL_HW_ERROR        0x44
#define BREECE_ASC_BARCODE_READ_ERROR       0x80
#define BREECE_ASC_INTERNAl_SW_ERROR        0x84

//
// ASCQ
//
#define BREECE_ASCQ_UNABLE_TO_OPEN_PICKER_JAW       0x90
#define BREECE_ASCQ_UNABLE_TO_CLOSE_PICKER_JAW      0x91
#define BREECE_ASCQ_THETA_AXIS_STUCK                0xA1
#define BREECE_ASCQ_Y_AXIS_STUCK                    0xB1
#define BREECE_ASCQ_Z_AXIS_STUCK                    0xC1

//
// DeviceStatus codes set in the extension
//
#define BREECE_DEVICE_PROBLEM_NONE      0x00 
#define BREECE_HW_ERROR                 0x01
#define BREECE_CHM_ERROR                0x02
#define BREECE_DRIVE_ERROR              0x03
#define BREECE_CHM_MOVE_ERROR           0x04


#define Q7            1
#define Q47           2


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device status returned by Diagnostic command
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PBHT_ED ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _BREECE_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\ddsmc\ddsmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ddsmc.c

Abstract:

    This module contains device-specific routines for DDS-2 DDS-3 medium changers:
    HP C1553A, HP C1557A, Sony TSL-7000

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "ddsmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, DdsBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}



ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the hp changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = DdsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(changerData->InquiryData.VendorId,"HP      ",8) == 8) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"C1553A",6) == 6) {
                changerData->DriveID = HP_DDS2;

            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"C1557A",6) == 6) {
                changerData->DriveID = HP_DDS3;

            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"C5713A",6) == 6) {
                changerData->DriveID = HP_DDS4;
            } 
        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"DEC     ",8) == 8) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"TLZ9",4) == 4) {
                changerData->DriveID = DEC_TLZ;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TLZ1",4) == 4) {
                changerData->DriveID = DEC_TLZ;
            }

        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"SONY",4) == 4) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-7000",8) == 8) {
                changerData->DriveID = SONY_TSL;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-9000",8) == 8) {
                changerData->DriveID = SONY_TSL;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-10000",9) == 9) {
                changerData->DriveID = SONY_TSL;
            } else if (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-11000",9) == 9) {
                changerData->DriveID = SONY_TSL11000;
            }
        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"ADIC    ",8) == 8) {

            //
            // ADIC 800E is OEMd from Sony
            //

            if (RtlCompareMemory(changerData->InquiryData.ProductId,"800E",4) == 4) {
                changerData->DriveID = SONY_TSL;
            }
        } else if (RtlCompareMemory(changerData->InquiryData.VendorId,"COMPAQ", 6) == 6) {  
           if ((RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-9000",8) == 8) ||
               (RtlCompareMemory(changerData->InquiryData.ProductId,"TSL-10000", 9))) {
                changerData->DriveID = COMPAQ_TSL;
           }
        }
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/
{



    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA   senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_MEDIUM_ERROR: {
            if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_INVALID_MEDIA) {
                if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED) {

                    //
                    // Indicates a cleaner cartridge.
                    //
                    *Status = STATUS_CLEANER_CARTRIDGE_INSTALLED;
                }

            }
            break;
        }

        case SCSI_SENSE_NOT_READY: {
            if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0x00)) {

                //
                // Indicates there's no magazine in the changer
                //
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
            }

            break;
        }

        default:
            break;
        }
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    hp changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    if ((changerData->DriveID == SONY_TSL) ||
         (changerData->DriveID == DEC_TLZ) ||
         (changerData->DriveID == COMPAQ_TSL) ||
         (changerData->DriveID == SONY_TSL11000)) {

        //
        // Indicate that a dedicated slot exists.
        //

        changerParameters->NumberCleanerSlots = 1;
        changerParameters->FirstCleanerSlotAddress = 7;
        changerParameters->MagazineSize = 8;
    } else {
        changerParameters->NumberCleanerSlots = 0;
        changerParameters->FirstCleanerSlotAddress = 0;
        changerParameters->MagazineSize = 6;
    }

    if (!addressMapping->Initialized) {

        ULONG i;

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    addressMapping->NumberOfElements[ChangerTransport] = changerParameters->NumberTransportElements;
    addressMapping->NumberOfElements[ChangerDrive] = changerParameters->NumberDataTransferElements;
    addressMapping->NumberOfElements[ChangerIEPort] = changerParameters->NumberIEElements;
    addressMapping->NumberOfElements[ChangerSlot] = changerParameters->NumberStorageElements;
    addressMapping->NumberOfElements[ChangerDoor] = changerParameters->NumberOfDoors;
    addressMapping->NumberOfElements[ChangerKeypad] = 0;


    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                   |
                                   CHANGER_CARTRIDGE_MAGAZINE            |
                                   CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS    |
                                   CHANGER_DRIVE_CLEANING_REQUIRED;

    changerParameters->Features1 = CHANGER_CLEANER_AUTODISMOUNT;

    if ((changerData->DriveID == SONY_TSL) ||
        (changerData->DriveID == DEC_TLZ) ||
        (changerData->DriveID == COMPAQ_TSL) ||
        (changerData->DriveID == SONY_TSL11000)) {

        changerParameters->Features0 |= CHANGER_CLEANER_SLOT;
    }

    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->InquiryData.VendorSpecific, SERIAL_NUMBER_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the loader mechanism.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {

        //
        // No IEPORTs on these devices.
        //

        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (controlOperation == LOCK_ELEMENT) {

        //
        // Issue prevent media removal command to lock the magazine.
        //

        cdb->MEDIA_REMOVAL.Prevent = 1;

    } else if (controlOperation == UNLOCK_ELEMENT) {

        //
        // Issue allow media removal.
        //

        cdb->MEDIA_REMOVAL.Prevent = 0;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {
        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    }


    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION           irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    ELEMENT_TYPE        originalElementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    realElements;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // Save this value for later. The HP's have no transport element and special casing
    // is done while filling in the user buffer.
    //

    originalElementType = elementType;

    DebugPrint((2,
               "GetElementStatus: ElementType: %x\n",
                elementType));

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;
        realElements = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            realElements += addressMapping->NumberOfElements[i];
        }
    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        statusPages = 1;
        realElements = readElementStatus->ElementList.NumberOfElements;
    }

    DebugPrint((2,
               "StatusPages %x, readElements %x\n",
               statusPages,
               realElements));

    if (readElementStatus->VolumeTagInfo) {

        //
        // These units have no Volume tag capability.
        //

        return STATUS_INVALID_PARAMETER;
    } else {

        if ((changerData->DriveID == SONY_TSL) ||
             (changerData->DriveID == DEC_TLZ) ||
             (changerData->DriveID == COMPAQ_TSL) ||
             (changerData->DriveID == SONY_TSL11000)) {

            //
            // length will be based on number of element type(s).
            //

            length = sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages) +
                     (sizeof(SONY_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        } else {

            //
            // length will be based on number of element type(s).
            //

            length = sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages) +
                     (sizeof(HP_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        }
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The HP's may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(realElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(realElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if ((NT_SUCCESS(status)) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // Check if data overrun is actually an underrun
        // reported as overrun.
        //
        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        RtlZeroMemory(elementStatus, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->Full;

        // Since none of these devices support exception reporting
                // don't se the exception bit
                //elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // The HP units don't have the capability of reporting exceptions
                // in this manner.
                //

                elementStatus->ExceptionCode = 0;

                if (elementDescriptor->IdValid) {
                    if (changerData->DriveID == SONY_TSL) {
                        UCHAR shiftValue;
                        UCHAR sonyAddress;

                        //
                        // Sony uses a bitmask for representing the target id
                        //

                        sonyAddress = elementDescriptor->BusAddress;
                        for (shiftValue = 1; shiftValue < 8; shiftValue++) {
                            if ((sonyAddress >> shiftValue) == 0) {
                                break;
                            }
                        }
                        elementStatus->TargetId = shiftValue - 1;
                    } else {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);


        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

        //
        // Send SCSI command (CDB) to device
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

        if (NT_SUCCESS(status)) {
            Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
        }

    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;

    }


    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. None of the support devices currently have this functionality.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the hp units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (!((changerData->DriveID == HP_DDS2) || 
          (changerData->DriveID == HP_DDS3) ||
          (changerData->DriveID == HP_DDS4))) {

        //
        // The HP's don't really have a transport, so don't bother.
        //

        if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

            DebugPrint((1,
                       "ChangerMoveMedium: Transport element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }
    }


    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // DDS changers don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID                  modeBuffer;
    ULONG                  i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = DDS_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == DDS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\breece\breecemc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    breecemc.c

Abstract:

    This module contains device-specific routines for the following
    Breece Hill medium changers: 
            - Q7
            - Q47

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "breecemc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}

ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"Quad 7",6) == 6) {
            changerData->DriveID = Q7;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"Quad 47",7) == 7) {
            changerData->DriveID = Q47;
        } 
    }

    ChangerClassFreePool(dataBuffer);


    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    ULONG deviceStatus;
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;


    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

           if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x81:
                    case 0x82:
                    case 0x83:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x03:
                    case 0x04:

                        *Retry = FALSE;
                        *Status = STATUS_MAGAZINE_NOT_PRESENT;
                         break;
                    case 0x05:
                    case 0x06:
                        *Retry = TRUE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                default:
                    break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           deviceStatus = BREECE_HW_ERROR;

           switch (senseBuffer->AdditionalSenseCode) {
            case BREECE_ASC_HW_NOT_RESPONDING: {
               deviceStatus = BREECE_HW_ERROR;
               break;
            }

            case BREECE_ASC_PICK_PUT_ERROR: {
               deviceStatus = BREECE_CHM_ERROR;
              break;
            }

            case BREECE_ASC_DRIVE_ERROR: {
               deviceStatus = BREECE_DRIVE_ERROR;
               break;
            }

            case BREECE_ASC_DIAGNOSTIC_ERROR: {
               switch (senseBuffer->AdditionalSenseCodeQualifier) {
                  case BREECE_ASCQ_UNABLE_TO_OPEN_PICKER_JAW:
                  case BREECE_ASCQ_UNABLE_TO_CLOSE_PICKER_JAW: {
                     deviceStatus = BREECE_CHM_ERROR;
                     break;
                  }

                  case BREECE_ASCQ_THETA_AXIS_STUCK:
                  case BREECE_ASCQ_Y_AXIS_STUCK:
                  case BREECE_ASCQ_Z_AXIS_STUCK: {
                     deviceStatus = BREECE_CHM_MOVE_ERROR;
                  }

                  default: {
                     deviceStatus = BREECE_HW_ERROR;
                     break;
                  }
               } // switch (senseBuffer->AdditionalSenseCodeQualifier)

               break;
            }

            case BREECE_ASC_INTERNAL_HW_ERROR: 
            case BREECE_ASC_BARCODE_READ_ERROR: 
            case BREECE_ASC_INTERNAl_SW_ERROR: {
               deviceStatus = BREECE_HW_ERROR;
               break;
            }

            default: {
               deviceStatus = BREECE_HW_ERROR;
               break;
            }
           } // switch (senseBuffer->AdditionalSenseCode)

           changerData->DeviceStatus = deviceStatus;
           break;
        }

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1D - Element address assignment page.

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    // Fill in values.

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = 
                 elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
                 (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
                 elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
                 (elementAddressPage->NumberStorageElements[0] << 8);

    // Breece Hill reports an IEPORT for both the Q7 and 47 
    // to represent an access to a 7 cartridge magazine. These
    // are really slots, not IEPORTs. 
    // The Q47 has an option called SCI/E which is a real IEPORT,
    // BUT IT IS NOT SUPPORTED BY NTMS PER AGREEMENT BY BREECE HILL
    // AND HIGHGROUND (3/31/98 - Ray Heineman, Brian Conrey of BH). 
    // BH DID NOT WANT TO FIX A BUG WITH THE 
    // INABILITY TO SCAN A MEDIUM THAT WAS INJECTED OR THE 
    // INNEFICIENCY OF DOING A SINGLE SLOT IES (which did them
    // all, not a single slot).  
    
    //if ((changerData->DriveID == Q47) && 
    //    ((changerData->InquiryData.VendorSpecific[19] & 0x2) == 0x2)) {
    //   changerParameters->NumberIEElements = 1;
    //} else { 
        changerParameters->NumberIEElements = 0;
    //} 

    changerParameters->NumberDataTransferElements = 
                 elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
                 (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 1;

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 7;

    changerParameters->DriveCleanTimeout = 600;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1E - transport geometry mode sense.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                             sizeof(MODE_PARAMETER_HEADER) +
                             sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);


    // initialize Features1  
        changerParameters->Features1 = 0;

    // initialize Features 0 and then set flip bit... 
    changerParameters->Features0 = 
             transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    // Breece Hill Q7 and Q47 units do not set the Inquiry BC bit
    // but they always hav a barcode reader installed. 

    changerParameters->Features0 |=
                             CHANGER_BAR_CODE_SCANNER_INSTALLED; 


    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
               CHANGER_STATUS_NON_VOLATILE           | 
               CHANGER_LOCK_UNLOCK                   |                                   
               CHANGER_CARTRIDGE_MAGAZINE            |
               CHANGER_DRIVE_CLEANING_REQUIRED       |
               CHANGER_PREDISMOUNT_EJECT_REQUIRED;

    // FIRMWARE BUG!
    // the spec says IES w/RANGE is supported, but
    // IES to one slot does them all and IES to IEPORT
    // doesn't do anything !
    //          CHANGER_INIT_ELEM_STAT_WITH_RANGE     |


    // Only the Door can be locked and unlocked
    // Door on Q7/Q47 is top access mechanism, not the big front door !
    // Big front door cannot be locked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;


    // legal Position capabilities... 
    changerParameters->PositionCapabilities = 0;


    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1F - Device Capabilities Page

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // BreeceHill uses an addition 4 bytes past the 
    // scsi-defined structure.

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE) + 
              BREECE_DEVICE_CAP_EXTENSION;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    // Fill in values in Features that are contained in this page.

    changerParameters->Features0 |= 
     capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    // Determine all the move from and exchange from 
    // capabilities of this device.

    changerParameters->MoveFromTransport = 
     capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
     capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 0;

    changerParameters->MoveFromDrive = 
     capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
     capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
     capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 0;

    changerParameters->ExchangeFromDrive = 
     capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
         changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
         changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
         changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, "", 1);    

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door or IEPort. 

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;

    if ((setAccess->Element.ElementType == ChangerKeypad) || 
        (setAccess->Element.ElementType == ChangerIEPort)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((controlOperation == EXTEND_IEPORT) ||
        (controlOperation == RETRACT_IEPORT)) { 
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    if ((controlOperation == LOCK_ELEMENT) || 
        (controlOperation == UNLOCK_ELEMENT)) {

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        if (controlOperation == LOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if (controlOperation == UNLOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 0;
        }
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command 
    for either all elements or the
    specified element type. The buffer returned is used to build 
    the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    numberElements;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    BOOLEAN  tagInfo;

    // Get the element type.
    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;
    numberElements = readElementStatus->ElementList.NumberOfElements;
    tagInfo = readElementStatus->VolumeTagInfo;

    if (elementType == AllElements) {
        statusPages = 4;
        if ((changerData->DriveID == Q47) && 
            ((changerData->InquiryData.VendorSpecific[19] & 0x2) == 0x2)) {
    
            numberElements++;   // if ALL requested, and the app thinks there
                                // are no IEPORTs, we must set aside a buffer
                                // for the IEPORT element and hide that 
                                // information when it gets passed back to 
                                // the application
        }
    } else {
        statusPages = 1;
    } 

    length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE));

    if (tagInfo) {
        length += (BHT_FULL_SIZE * numberElements);
    } else {
        length += (BHT_PARTIAL_SIZE * numberElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = tagInfo;

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] =         
        (UCHAR)(numberElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =      
        (UCHAR)(numberElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] =
                                      (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] =
                                      (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] =
                                      (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PBHT_ED elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        if (elementType == AllElements) {
            if ((changerData->DriveID == Q47) && 
                ((changerData->InquiryData.VendorSpecific[19] & 0x2) == 0x2)) {
    
                numberElements--;       
                                // Since this was incremented before to 
                                // create a RdElemStatus call that includes
                                // the IEPORT, it must be take out at this point
            }
        }


        // Determine total number elements returned.
        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        // The buffer is composed of a header, status page, 
        // and element descriptors.
        // Point each element to it's respective place in the buffer.

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);
            
        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = 
           statusPage->ElementDescriptorLength[1];
        descriptorLength |= 
           (statusPage->ElementDescriptorLength[0] << 8);

        // Determine the number of elements of this type reported.
        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        // Fill in user buffer.
        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {
            // hide the IEPORT from the application
            for (i = 0; i < typeCount; i++, remainingElements--) {

               // don't return IEPORT info to host
               if (elementType != ChangerIEPort) {

                    // Get the address for this element.
                    elementStatus->Element.ElementAddress =
                     elementDescriptor->BHT_FED.ElementAddress[1];
                    elementStatus->Element.ElementAddress |=
                     (elementDescriptor->BHT_FED.ElementAddress[0] << 8);

                    // Account for address mapping.
                    elementStatus->Element.ElementAddress -= 
                    addressMapping->FirstElement[elementType];

                    // Set the element type.
                    elementStatus->Element.ElementType = elementType;

                    if (elementDescriptor->BHT_FED.SValid) {

                        ULONG  j;
                        USHORT tmpAddress;

                        // Source address is valid. 
                        // Determine the device specific address.
                        tmpAddress = elementDescriptor->BHT_FED.SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->BHT_FED.SourceStorageElementAddress[0] << 8);

                        // Now convert to 0-based values.
                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                       elementStatus->SrcElementAddress.ElementAddress =
                             tmpAddress - addressMapping->FirstElement[j];

                    }

                    // Build Flags field.

                    elementStatus->Flags = 
                     elementDescriptor->BHT_FED.Full;
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.Exception << 2);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.Accessible << 3);

                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.LunValid << 12);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.IdValid << 13);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.NotThisBus << 15);

                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.Invert << 22);
                    elementStatus->Flags |= 
                     (elementDescriptor->BHT_FED.SValid << 23);


                    elementStatus->ExceptionCode = 
                     MapExceptionCodes(elementDescriptor);

                    if (elementDescriptor->BHT_FED.IdValid) {
                        elementStatus->TargetId = 
                         elementDescriptor->BHT_FED.BusAddress;
                    }
                    if (elementDescriptor->BHT_FED.LunValid) {
                        elementStatus->Lun = elementDescriptor->BHT_FED.Lun;
                    }

                    if (tagInfo) {
                       RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                            elementDescriptor->BHT_FED.PrimaryVolumeTag, 
                            MAX_VOLUME_ID_SIZE);
                       elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }

                    // Advance to the next entry in the user 
                    // buffer and element descriptor array.
                    elementStatus += 1;
               }
                 
               // even for IEPORT, walk across its data
               // Get next descriptor of this same element type.
               (ULONG_PTR)elementDescriptor += descriptorLength;

            } // end of loop for this element type

            if (remainingElements > 0) {
                // Get next status page.
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                // Point to decriptors.
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                       statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                       (statusPage->ElementDescriptorLength[0] << 8);

                // Determine the number of this element type reported.
                typeCount = statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                sizeof(CHANGER_ELEMENT_STATUS) * numberElements;
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either 
    initialize all elements or the specified range of elements 
    using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    if (initElementStatus->ElementList.Element.ElementType != AllElements) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                      SCSIOP_INIT_ELEMENT_STATUS;
    cdb->INIT_ELEMENT_STATUS.NoBarCode = 
            initElementStatus->BarCodeScan ? 0 : 1;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 
                     sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}




NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the 
    robotic mechanism to the specified
    element address. Normally used to optimize moves or 
    exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
         (setPosition->Destination.ElementType == ChangerDoor)) {
        return STATUS_INVALID_PARAMETER;
    }


    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    // Convert to device addresses.

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += 
     addressMapping->FirstElement[setPosition->Destination.ElementType];

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    // Build srb and cdb.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    // Build device-specific addressing.

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] =
                    (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = 
                    (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = 
                    (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = 
                    (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the exabyte units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 
      (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 
      (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = 
      (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = 
      (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 
      (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 
      (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // there is no command on these libraries to home or reinit the 
    // changer mechanism

    return STATUS_INVALID_DEVICE_REQUEST;
}




NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;


}



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = BHT_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = 
         (elementAddressPage->MediumTransportElementAddress[0] << 8) |
         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = 
         (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
         elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = 
         (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
         elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = 
         (elementAddressPage->FirstStorageElementAddress[0] << 8) |
         elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 
         elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= 
         (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = 
         elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= 
         (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 0;

        addressMapping->NumberOfElements[ChangerSlot] = 
         elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= 
         (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;
    }


    // Determine the lowest element address for use with AllElements.
    //
    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < 
                         addressMapping->FirstElement[AllElements]) {
            addressMapping->FirstElement[AllElements] = 
                                     addressMapping->FirstElement[i];
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PBHT_ED ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor 
    and creates the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->BHT_FED.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->BHT_FED.AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {

        case 0x83:
            switch (asq) {
                case 0x0:
                    exceptionCode = ERROR_LABEL_QUESTIONABLE;
                    break;

                case 0x1:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                case 0x2:
                    exceptionCode = ERROR_SLOT_NOT_PRESENT;
                    break;

                case 0x3:
                    exceptionCode = ERROR_LABEL_QUESTIONABLE;
                    break;


                case 0x4:
                    exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;

            }
                        break; // 0x83

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == BHT_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}
                                                                                                                                                             

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to 
   // BREECE_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate 
   // devicestatus.
   //
   changerData->DeviceStatus = BREECE_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "BREECEMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != BREECE_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case BREECE_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case BREECE_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case BREECE_DRIVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemDriveError;
            break;
         }

         case BREECE_CHM_MOVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch (changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\atl\atlmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    atlmc.h

Abstract:

Authors:

    davet (Dave Therrien)

Revision History:

--*/
#ifndef _ATL_MC_
#define _ATL_MC_

#define ATL_DEVICE_CAP_EXTENSION                4

typedef union _ATL_ED {

    struct _ATL_FED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[6];
    } ATL_FED, *PATL_FED;

    struct _ATL_PED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[6];
    } ATL_PED, *PATL_PED;

} ATL_ED, *PATL_ED;

#define ATL_PARTIAL_SIZE sizeof(struct _ATL_PED)
#define ATL_FULL_SIZE sizeof(struct _ATL_FED)

#define ATL_DISPLAY_LINES        4
#define ATL_DISPLAY_LINE_LENGTH  20

// Vendor Unique Mode Page 0

typedef struct _PAGE0_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR Reserved2 : 4;
    UCHAR NBL : 1;
    UCHAR Reserved3 : 2;
    UCHAR AInit : 1;
    UCHAR MaxParityRetries;
    UCHAR DisplayLine[ATL_DISPLAY_LINES][ATL_DISPLAY_LINE_LENGTH];
} PAGE0_MODE_PAGE, *PPAGE0_MODE_PAGE;


// Vendor Unique Mode Page 20 

typedef struct _PAGE20_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR Reserved2 : 1;
    UCHAR AC : 1;
    UCHAR Reserved3 : 6;
    UCHAR EXB : 1;
    UCHAR Reserved4 : 7;
} PAGE20_MODE_PAGE, *PPAGE20_MODE_PAGE;


#define ATL_NO_ELEMENT 0xFFFF

//
// Diagnostic test related defines
//
// ASC
#define ATL_ASC_HW_ERROR            0x80
#define ATL_ASC_GRIPPER_ERROR       0x81
#define ATL_ASC_VERTICAL_ERROR      0x84
#define ATL_ASC_HORIZONTAL_ERROR    0x85
#define ATL_ASC_LOAD_PORT           0x8C
#define ATL_ASC_DLT_DRIVE           0xF3

//
// ASCQ
//
#define ATL_ASCQ_GRIPPER_BLOCKED        0x50
#define ATL_ASCQ_PICK_ERROR             0x51 
#define ATL_ASCQ_POSITION_ERROR         0x03
#define ATL_ASCQ_HOME_NOT_FOUND         0x08
#define ATL_ASCQ_LOAD_PORT_DOOR_OPEN    0x06
#define ATL_ASCQ_DLT_DRIVE_TIMEOUT      0x02

//
// DeviceStatus codes
//
#define ATL_DEVICE_PROBLEM_NONE         0x00
#define ATL_HW_ERROR                    0x01
#define ATL_CHM_ERROR                   0x02
#define ATL_DOOR_OPEN                   0x03


#define ATL_520        1
#define ATL_7100       2

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostic test is performed
    //
    ULONG DeviceStatus; 

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PATL_ED ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _ATL_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\exabyte\exabyte.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    exabyte.c

Abstract:

    This module contains device-specific routines for exabyte medium changers:
    EXABYTE 210/220, EXABYTE 480.

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "exabyte.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}

typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[10];
} SERIALNUMBER, *PSERIALNUMBER;


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "Examc.ChangerInitialize: Error allocating dataBuffer. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"EXB-440",7) == 7) {
            changerData->DriveID = EXABYTE_440;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-480",7) == 7) {
            changerData->DriveID = EXABYTE_480;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-210",7) == 7) {
            changerData->DriveID = EXABYTE_210;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-220",7) == 7) {
            changerData->DriveID = EXABYTE_220;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"EXB-10e",7) == 7) {
            changerData->DriveID = EXABYTE_10;
        }
    }

    if ((changerData->DriveID != EXABYTE_10)) {
        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 14);
        if (!serialBuffer) {

            ChangerClassFreePool(dataBuffer);

            DebugPrint((1,
                        "Examc.ChangerInitialize: Error allocating serial number buffer. %x\n",
                        status));

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialBuffer, 14);

        //
        // Get serial number page.
        //

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = 10;

        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set EVPD
        //

        cdb->CDB6INQUIRY.Reserved1 = 1;

        //
        // Unit serial number page.
        //

        cdb->CDB6INQUIRY.PageCode = 0x80;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = 14;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             serialBuffer,
                                             14,
                                             FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            ULONG i;

            RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber, EXABYTE_SERIAL_NUMBER_LENGTH);

            DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
            DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
            DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

            DebugPrint((1,"Serial number "));

            for (i = 0; i < 10; i++) {
                DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
            }

            DebugPrint((1,"\n"));

        }

        ChangerClassFreePool(serialBuffer);
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;
    PCHANGER_DATA changerData;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
     
    fdoExtension = DeviceObject->DeviceExtension;
    changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x83:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;

                    case 0x85:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x03:
                    case 0x04:

                        *Retry = FALSE;
                        *Status = STATUS_MAGAZINE_NOT_PRESENT;
                         break;
                    case 0x05:
                    case 0x06:
                        *Retry = TRUE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                default:
                    break;
                }
            } else if ((senseBuffer->AdditionalSenseCode == 0x91) && (senseBuffer->AdditionalSenseCodeQualifier == 0x00)) {
                *Status = STATUS_TRANSPORT_FULL;

            }
            break;

        case SCSI_SENSE_UNIT_ATTENTION: {
            if ((senseBuffer->AdditionalSenseCode == 0x28) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0x0)) {

                //
                // Indicate that the door was opened and reclosed.
                //

                *Status = STATUS_MEDIA_CHANGED;
                *Retry = FALSE;
            }

            break;
        }

        case SCSI_SENSE_HARDWARE_ERROR: {
           UCHAR addSenseCode;
           UCHAR addSenseCodeQual;
           UCHAR statusCode;

           //
           // ISSUE - 2000/02/10 - nramas 
           // Should define more appropriate NTStatus codes
           // for these types of device  errors. For now
           // we handle it internally.
           //
           *Status = STATUS_IO_DEVICE_ERROR;
           statusCode = EXB_HARDWARE_ERROR;

           addSenseCode = senseBuffer->AdditionalSenseCode;
           addSenseCodeQual = senseBuffer->AdditionalSenseCodeQualifier;

           switch (addSenseCode) {
            case SCSI_ADSENSE_SEEK_ERROR: {
               switch (addSenseCodeQual) {
                  case EXB_ADSENSEQUAL_CARTRIDGE_DROPPED:
                  case EXB_ADSENSEQUAL_MECH_PICK_ERROR: 
                  case EXB_ADSENSEQUAL_PLACE_ERROR:
                  case EXB_ADSENSEQUAL_STALLED: 
                  case EXB_ADSENSEQUAL_GRIPPER_OPEN_ERROR:
                  case EXB_ADSENSEQUAL_PICK_FAILURE:{
                     statusCode = EXB_CARTRIDGE_HANDLING_ERROR;
                     break;
                  }   
               } // switch (addSenseCodeQual)

               break;
            }

            case EXB_ADSENSE_DIAGNOSTIC_FAILURE: {

               switch (addSenseCodeQual) {
                  case EXB_ADSENSEQUAL_CHM_ERROR: {
                     statusCode = EXB_CARTRIDGE_HANDLING_ERROR;
                     break;
                  }

                  case EXB_ADSENSEQUAL_DOOR_ERROR: {   
                     statusCode = EXB_DOOR_ERROR;
                     break;
                  }

                  case EXB_ADSENSEQUAL_GRIPPER_ERROR: 
                  case EXB_ADSENSEQUAL_GRIPPER_MOTION_ERROR:{
                     statusCode = EXB_GRIPPER_ERROR;
                     break;
                  }

                  case EXB_ADSENSEQUAL_SHORT_AXIS_MOVE:
                  case EXB_ADSENSEQUAL_SHORT_HOMING_ERROR: 
                  case EXB_ADSENSEQUAL_SERVO_SHORT:
                  case EXB_ADSENSEQUAL_DESTINATION_SHORT:
                  case EXB_ADSENSEQUAL_LONG_AXIS_MOVE:
                  case EXB_ADSENSEQUAL_SERVO_LONG:
                  case EXB_ADSENSEQUAL_DESTINATION_LONG:
                  case EXB_ADSENSEQUAL_LONG_HOMING_ERROR:
                  case EXB_ADSENSEQUAL_DRUM_MOTION:
                  case EXB_ADSENSEQUAL_DRUM_HOME:
                  case EXB_ADSENSEQUAL_CONTROLLER_CARD:
                  case EXB_ADSENSEQUAL_DESTINATION_SHORT2:
                  case EXB_ADSENSEQUAL_DESTINATION_LONG2:{
                     statusCode = EXB_CALIBRATION_ERROR;
                     break;
                  }

               } // switch (addSenseCodeQual)
               
               break;
            }

            case EXB_ADSENSE_TARGET_FAILURE: {
               statusCode = EXB_TARGET_FAILURE;
               break;
            }

            case EXB_ADSENSE_CARTRIDGE_ERROR: {
               statusCode = EXB_CARTRIDGE_HANDLING_ERROR;
               break;
            }

            case EXB_ADSENSE_CHM_MOVE_ERROR: {
               statusCode = EXB_CHM_MOVE_ERROR;
               break;
            }

            case EXB_ADSENSE_CHM_ZERO_ERROR: {
               statusCode = EXB_CHM_ZERO_ERROR;
               break;
            }

            case EXB_ADSENSE_CARTRIDGE_INSERT_ERROR: {
               if (addSenseCodeQual == EXB_ADSENSEQUAL_FIRMWARE) {
                  statusCode = EXB_HARDWARE_ERROR;
               } else {
                  statusCode = EXB_CARTRIDGE_INSERT_ERROR;
               }
               break;
            }

           case EXB_ADSENSE_CHM_POSITION_ERROR: {
              statusCode = EXB_CHM_POSITION_ERROR;
              break;
           }

           case EXB_ADSENSE_HARDWARE_ERROR: {
              statusCode = EXB_HARDWARE_ERROR;;
              break;
           }

           case EXB_ADSENSE_CALIBRATION_ERROR: {
              statusCode = EXB_CALIBRATION_ERROR;
              break;
           }

           case EXB_ADSENSE_SENSOR_ERROR: {
              statusCode = EXB_SENSOR_ERROR;
              break;
           }

           case EXB_ADSENSE_UNRECOVERABLE_ERROR: {
              statusCode = EXB_UNRECOVERABLE_ERROR;
              break;
           }

           case EXB_ADSENSE_EJECT_ERROR: {
              statusCode = EXB_EJECT_ERROR;
              break;
           }

           } // switch (addSenseCode)

           //
           // Update DeviceStatus in the device extension
           // with appropriate status code.
           //
           changerData->DeviceStatus = statusCode;
        } // case SCSI_SENSE_HARDWARE_ERROR

        default:
            break;
        }
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 1;

    changerParameters->FirstSlotNumber = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 10;
    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Exabyte indicates whether a bar-code scanner is
    // attached by setting bit-0 in this byte.
    //

    changerParameters->Features0 |= ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
                                         CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;

    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_DOOR    |
                                                 LOCK_UNLOCK_KEYPAD);
    changerParameters->PositionCapabilities =  (CHANGER_TO_SLOT      |
                                                CHANGER_TO_DRIVE);


    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_STATUS_NON_VOLATILE           |
                                    CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
                                    CHANGER_CLEANER_SLOT                  |
                                    CHANGER_LOCK_UNLOCK                   |
                                    CHANGER_CARTRIDGE_MAGAZINE            |
                                    CHANGER_POSITION_TO_ELEMENT           |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE   |
                                    CHANGER_PREDISMOUNT_EJECT_REQUIRED    |
                                    CHANGER_DRIVE_CLEANING_REQUIRED       |
                                    CHANGER_VOLUME_IDENTIFICATION         |
                                    CHANGER_VOLUME_SEARCH                 |
                                    CHANGER_SERIAL_NUMBER_VALID           |
                                    CHANGER_KEYPAD_ENABLE_DISABLE;

    if ((changerData->DriveID == EXABYTE_440) ||(changerData->DriveID == EXABYTE_480)) {
        changerParameters->Features0 |= CHANGER_CLOSE_IEPORT |
                                        CHANGER_OPEN_IEPORT;

        changerParameters->PositionCapabilities |= CHANGER_TO_IEPORT;
        changerParameters->LockUnlockCapabilities |= LOCK_UNLOCK_IEPORT;

    } else if (changerData->DriveID == EXABYTE_10) {
        changerParameters->Features0 &= ~(CHANGER_SERIAL_NUMBER_VALID       |
                                          CHANGER_STATUS_NON_VOLATILE       |
                                          CHANGER_INIT_ELEM_STAT_WITH_RANGE |
                                          CHANGER_CLEANER_SLOT              |
                                          CHANGER_VOLUME_IDENTIFICATION     |
                                          CHANGER_VOLUME_SEARCH             |
                                          CHANGER_LOCK_UNLOCK               |
                                          CHANGER_KEYPAD_ENABLE_DISABLE);

        changerParameters->LockUnlockCapabilities = 0;
        changerParameters->NumberCleanerSlots = 0;
    }

    if (!(changerParameters->Features0 & CHANGER_BAR_CODE_SCANNER_INSTALLED)) {

        //
        // No scanner, no search/ident possible.
        //

        changerParameters->Features0 &= ~(CHANGER_VOLUME_IDENTIFICATION | CHANGER_VOLUME_SEARCH);
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Exabyte uses an addition 4 bytes past the scsi-defined structure.
    //

    length =  sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE) + EXABYTE_DEVICE_CAP_EXTENSION;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;


    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, EXABYTE_SERIAL_NUMBER_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType, FALSE)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    switch (setAccess->Element.ElementType) {
        case ChangerDoor:

            if (controlOperation == LOCK_ELEMENT) {

                //
                // Issue prevent media removal command to lock the door.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            if ((changerData->DriveID == EXABYTE_440) || (changerData->DriveID == EXABYTE_480)) {

                //
                // Set the P/A bits to indicate that this operation is for the front door.
                //

                cdb->MEDIA_REMOVAL.Control = 0xC0;
            }

            break;

        case ChangerIEPort:

            if ((changerData->DriveID == EXABYTE_210) ||
                (changerData->DriveID == EXABYTE_220) ||
                (changerData->DriveID == EXABYTE_10)) {

                //
                // No IEPorts on these devices.
                //

                status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set vendor-unique flag indicating that this operation is for the
                // ieport only.
                //

                cdb->MEDIA_REMOVAL.Control = 0x80;

                if (controlOperation == LOCK_ELEMENT) {

                    //
                    // Issue prevent media removal command to lock the ie port.
                    //

                    cdb->MEDIA_REMOVAL.Prevent = 1;

                } else if (controlOperation == UNLOCK_ELEMENT) {

                    //
                    // Issue allow media removal.
                    //

                    cdb->MEDIA_REMOVAL.Prevent = 0;

                } else if (controlOperation == EXTEND_IEPORT) {

                    srb->CdbLength = CDB12GENERIC_LENGTH;
                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Exabyte overloads the move medium command by a bit-mask in the control byte.
                    //

                    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

                    //
                    // Build addressing values based on address map.
                    //

                    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
                    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

                    cdb->MOVE_MEDIUM.SourceElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.SourceElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.Flip = 0;

                    //
                    // Indicate that the IEPORT should be extended.
                    //

                    cdb->MOVE_MEDIUM.Control = 0x40;

                    srb->DataTransferLength = 0;

                } else if (controlOperation == RETRACT_IEPORT) {
                    srb->CdbLength = CDB12GENERIC_LENGTH;
                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Exabyte overloads the move medium command by a bit-mask in the control byte.
                    //

                    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

                    //
                    // Build addressing values based on address map.
                    //

                    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
                    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

                    cdb->MOVE_MEDIUM.SourceElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.SourceElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[0] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) >> 8);

                    cdb->MOVE_MEDIUM.DestinationElementAddress[1] =
                        (UCHAR)((setAccess->Element.ElementAddress +
                                 addressMapping->FirstElement[setAccess->Element.ElementType]) & 0xFF);

                    cdb->MOVE_MEDIUM.Flip = 0;

                    //
                    // Indicate that the IEPORT should be retracted.
                    //

                    cdb->MOVE_MEDIUM.Control = 0x80;

                    srb->DataTransferLength = 0;

                } else {
                    status = STATUS_INVALID_PARAMETER;
                }
            }

            break;

        case ChangerKeypad: {
            PVOID                modeBuffer;
            PLCD_MODE_PAGE       lcdModePage;

            //
            // Build the exabyte-unique lcd mode page.
            //

            modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER) + sizeof(LCD_MODE_PAGE));
            if (!modeBuffer) {
                ChangerClassFreePool(srb);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(LCD_MODE_PAGE));
            lcdModePage = (PLCD_MODE_PAGE)modeBuffer;
            (PCHAR)lcdModePage += sizeof(MODE_PARAMETER_HEADER);

            lcdModePage->PageCode = 0x22;
            lcdModePage->PageLength = 0x52;
            lcdModePage->SecurityValid = 1;

            //
            // Determine if the panel should be enabled or disabled.
            //

            if (controlOperation == LOCK_ELEMENT) {

                DebugPrint((2,
                           "ChangerSetAccess: Locking keypad\n"));

                lcdModePage->LCDSecurity = 1;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                DebugPrint((2,
                           "ChangerSetAccess: UnLocking keypad\n"));
                lcdModePage->LCDSecurity = 0;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            //
            // The display line fields will be left as zero and the WriteLine field left off, so that
            // the default text on the display is not changed.
            //

            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->TimeOutValue = 20;
            srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(LCD_MODE_PAGE);
            srb->DataBuffer = modeBuffer;

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.PFBit = 1;
            cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb->DataTransferLength;

            writeToDevice = TRUE;
        }
        break;

        default:

            status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // length will be based on whether vol. tags are returned and element type(s).
    //

    if (elementType == AllElements) {


        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }
    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType, TRUE)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        statusPages = 1;
    }

    if (readElementStatus->VolumeTagInfo) {

        //
        // Each descriptor will have an embedded volume tag buffer.
        //

        length = sizeof(ELEMENT_STATUS_HEADER) + (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
                 (EXA_FULL_SIZE * totalElements);
    } else {

        length = sizeof(ELEMENT_STATUS_HEADER) + (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
                 (EXA_PARTIAL_SIZE * totalElements);

    }


    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
       ChangerClassFreePool(statusBuffer);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if ((NT_SUCCESS(status)) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PEXA_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = totalElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
  
              return status;
           }
        }
        

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PVOID)statusPage = (PVOID)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);
                                         
        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                    ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                    (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                    tmpAddress |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Full;
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                elementStatus->Flags |= (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    if (changerData->DriveID == EXABYTE_10) {

                        //
                        // If the door was opened and closed, or a reset occurred,
                        // ERROR_LABEL_QUESTIONABLE is returned. This needs to be remapped.
                        //

                        elementStatus->ExceptionCode = ERROR_INIT_STATUS_NEEDED;

                    }
                }

                if (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                    elementStatus->TargetId = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                }
                if (((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                    elementStatus->Lun = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.Lun;
                }

                if (tagInfo) {
                    RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                  ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)elementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        if (changerData->DriveID == EXABYTE_10) {
            cdb->INIT_ELEMENT_STATUS.NoBarCode = 0;
        }

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        if (changerData->DriveID == EXABYTE_10) {

            //
            // Only supports normal SCSI Init element status command.
            //

            ChangerClassFreePool(srb);
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Use the exabyte vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport, TRUE)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType, TRUE)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Exabyte doesn't support 2-sided media.
    //

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the exabyte units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport, TRUE)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType, TRUE)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType, TRUE)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Exabyte doesn't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT transportToHome = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport is within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(transportToHome->ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport, TRUE)) {

        DebugPrint((1,
                   "ChangerReinitialize: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Setting destination equal to the transport, positions the arm out of the way
    // on the Exabyte units.
    //

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(transport & 0xFF);
    cdb->POSITION_TO_ELEMENT.Flip = 0;

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
    PSCSI_REQUEST_BLOCK srb;
    PVOID    tagBuffer;
    PVOID    statusBuffer;
    PCDB     cdb;
    NTSTATUS status;

    //
    // Do some validation.
    //

    if (volTagInfo->ActionCode != SEARCH_PRI_NO_SEQ) {
        DebugPrint((1,
                   "QueryVolumeTags: Invalid Action Code %x\n",
                   volTagInfo->ActionCode));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    //
    // Load buffer with template.
    //

    RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;
    cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

    cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;


    cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
    cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;


    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         tagBuffer,
                                         MAX_VOLUME_TEMPLATE_SIZE,
                                         TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;
        PVOID statusBuffer;

        //
        // Size of buffer returned is based on the size of the user buffer. If it's incorrectly
        // sized, the IoStatus.Information will be updated to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (EXA_FULL_SIZE * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 16);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[2] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PEXA_ELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Zero the portion of user buffer that is always there.
            //

            RtlZeroMemory(readElementAddressInfo,
                          sizeof(READ_ELEMENT_ADDRESS_INFO));

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            numberElements = (statusHeader->NumberOfElements[0] << 8);
            numberElements |= (statusHeader->NumberOfElements[1] & 0xFF);

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //

                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    elementStatus->Element.ElementAddress = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -=
                        addressMapping->FirstElement[statusPage->ElementType];

                    elementStatus->Element.ElementType = statusPage->ElementType;

                    if (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SValid) {

                        ULONG j;
                        USHORT tmpAddress;

                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    }

                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Full;
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                        if (changerData->DriveID == EXABYTE_10) {

                            //
                            // If the door was opened and closed, or a reset occurred,
                            // ERROR_LABEL_QUESTIONABLE is returned. This needs to be remapped.
                            //

                            elementStatus->ExceptionCode = ERROR_INIT_STATUS_NEEDED;

                        }
                    }

                    if (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                        elementStatus->TargetId = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                    }
                    if (elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                        elementStatus->Lun = elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.Lun;
                    }

                    RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->EXA_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = EXA_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);


    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;
    }


    //
    // Determine the lowest element address for use with AllElements.
    //

    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

            DebugPrint((1,
                       "BuildAddressMapping: New lowest address %x\n",
                       addressMapping->FirstElement[i]));
            addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PEXA_ELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asq = ((EXA_ELEMENT_DESCRIPTOR UNALIGNED *)ElementDescriptor)->EXA_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
    ULONG exceptionCode;

    //
    // On the exabytes, the additional sense code is always 0x83.
    //

    switch (asq) {
        case 0x0:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;

        case 0x1:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        case 0x2:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        case 0x3:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;


        case 0x4:
            exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
            break;

        case 0x8:
        case 0x9:
        case 0xA:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType,
    IN BOOLEAN IntrisicElement
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The exabyte's address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == EXA_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    if (IntrisicElement) {
        if (ElementType >= ChangerDoor) {
            DebugPrint((1,
                       "ElementOutOfRange: Specified type not intrinsic. Type %x\n",
                       ElementType));
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\ddsmc\ddsmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    ddsmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _DDS_MC_
#define _DDS_MC_

typedef struct _HP_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved[4];
} HP_ELEMENT_DESCRIPTOR, *PHP_ELEMENT_DESCRIPTOR;

typedef struct _SONY_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} SONY_ELEMENT_DESCRIPTOR, *PSONY_ELEMENT_DESCRIPTOR;

#define DDS_NO_ELEMENT 0xFFFF

//
// Drive ID's
//

#define HP_DDS2          0x00000001
#define HP_DDS3          0x00000002
#define SONY_TSL         0x00000003
#define DEC_TLZ          0x00000004
#define HP_DDS4          0x00000005
#define COMPAQ_TSL       0x00000006
#define SONY_TSL11000    0x00000007

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the Lowest element address of the unit.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

    UCHAR Reserved[3];

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates which device is currently supported.
    // See above.
    //

    ULONG DriveID;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;

//
// Device diagnostic related definitions
//
#define TSL_NO_ERROR                            0x00
#define MAGAZINE_LOADUNLOAD_ERROR               0xD0
#define ELEVATOR_JAMMED                         0xD1
#define LOADER_JAMMED                           0xD2
#define LU_COMMUNICATION_FAILURE                0xD3
#define LU_COMMUNICATION_TIMEOUT                0xD4
#define MOTOR_MONITOR_TIMEOUT                   0xD5
#define AUTOLOADER_DIAGNOSTIC_FAILURE           0xD6

typedef struct _SONY_TSL_RECV_DIAG {
   UCHAR ErrorSet : 4;
   UCHAR Reserved1 : 2;
   UCHAR TimeReSync : 1;
   UCHAR ResetError : 1;
   UCHAR ErrorCode;
   UCHAR ResultA;
   UCHAR ResultB;
   UCHAR TestNumber;
} SONY_TSL_RECV_DIAG, *PSONY_TSL_RECV_DIAG;

typedef struct _HP_RECV_DIAG {
   UCHAR TestNumber;
   UCHAR ErrorCode;
   UCHAR SuspectPart;
   UCHAR LoopCount;
   UCHAR TestSpecInfo[60];
}HP_RECV_DIAG, *PHP_RECV_DIAG;


NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

//
// Internal functions for wmi
//
VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    );

#endif // _DDS_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\discmc\discmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    discmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _DISC_MC_
#define _DISC_MC_

typedef struct _DISC_TRANSPORT_GEOMETRY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR Flip0 : 1;
    UCHAR Reserved2: 7;
    UCHAR TransportElementNumber0;
    UCHAR Flip1 : 1;
    UCHAR Reserved3: 7;
    UCHAR TransportElementNumber1;

} DISC_TRANSPORT_GEOMETRY_PAGE, *PDISC_TRANSPORT_GEOMETRY_PAGE;

typedef struct _DISC_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Reserved6[3];
    UCHAR Reserved7 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} DISC_ELEMENT_DESCRIPTOR, *PDISC_ELEMENT_DESCRIPTOR;

typedef struct _DISC_DATA_TRANSFER_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR Reserved1 : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved4 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved5 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved6;
    UCHAR Reserved7 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved8[4];
    UCHAR BusNumber[2];
} DISC_DATA_TRANSFER_ELEMENT_DESCRIPTOR, *PDISC_DATA_TRANSFER_ELEMENT_DESCRIPTOR;

typedef struct _DISC_INIT_ELEMENT_RANGE {
    UCHAR OperationCode;
    UCHAR ElementType : 4;
    UCHAR Reserved1 : 1;
    UCHAR LogicalUnitNubmer : 3;
    UCHAR FirstElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved2[4];
} DISC_INIT_ELEMENT_RANGE, *PDISC_INIT_ELEMENT_RANGE;

#define DISC_NO_ELEMENT          0xFFFF
#define DISC_INIT_ELEMENT_RANGE  0x20

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\discmc\discmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    discmc.c

Abstract:

    This module contains device-specific routines for Disc MO medium changers:

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "discmc.h"

#define DISC_MO 0x01
#define DISC_CD 0x02

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the Sony units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Flag to indicate if SendDiagnostic command
    // detected any hardware problem
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
DiscBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );



ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Disc changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"D525-1",6) == 6) {
        changerData->DriveType = DISC_MO;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"D630-1",6) == 6) {
        changerData->DriveType = DISC_CD;
    }

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = DiscBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                   "Disc.ChangerInitialize: Build address mapping failed. %x\n",
                   status));
    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 100;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    return STATUS_SUCCESS;
}


BOOLEAN
ChangerVerifyInquiry(
    PINQUIRYDATA InquiryData
    )
/*++

Routine Description:

    This routine determines whether the device specified in InquiryData
    should be supported by this module.

Arguments:

    InquiryData - Pointer to inquiry data.

Return Value:

    TRUE - If this is a supported device.

--*/

{


    if (RtlCompareMemory(InquiryData->VendorId,"DISC    ",8) == 8) {
        if (RtlCompareMemory(InquiryData->ProductId,"D525-1",6) == 6) {

            return TRUE;
        } else if (RtlCompareMemory(InquiryData->ProductId,"D630-1",6) == 6) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA   senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_UNIT_ATTENTION:


            if (senseBuffer->AdditionalSenseCode != SCSI_ADSENSE_MEDIUM_CHANGED) {

                //
                // Reset/power-on clears any prevents.
                //

                InterlockedExchange(&changerData->LockCount, 0);
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           changerData->HardwareError = TRUE;
           break;
        }

        default:
            break;
        }


        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    Disc changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PDISC_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 100;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = DISC_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(DISC_TRANSPORT_GEOMETRY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 100;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip0 ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= //CHANGER_INIT_ELEM_STAT_WITH_RANGE       |
                                    CHANGER_STATUS_NON_VOLATILE             |
                                    CHANGER_EXCHANGE_MEDIA                  |
                                    CHANGER_LOCK_UNLOCK                     |
                                    CHANGER_REPORT_IEPORT_STATE             |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE;

    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT);

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build dev caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 100;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 100;

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 100;

    if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {

            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

            //
            // Issue prevent media removal command to lock the ie port.
            //

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            InterlockedExchange(&changerData->LockCount, 0);

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;


        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {

        //
        // No door/keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    if (!addressMapping->Initialized) {
        
#if DBG
        DebugPrint((1,
                   "GetElementStatus: AddressMapping NOT Initialized!\n"));
        DbgBreakPoint();
#endif
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            return STATUS_INVALID_PARAMETER;

        } else {

            USHORT numberDrives = addressMapping->NumberOfElements[ChangerDrive];

            //
            // Determine length needed for drive data.
            //

            length = sizeof(DISC_DATA_TRANSFER_ELEMENT_DESCRIPTOR) * numberDrives;

            //
            // Add in size for remaining elements.
            //

            length += sizeof(DISC_ELEMENT_DESCRIPTOR) * (totalElements - numberDrives);

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if ((totalElements > addressMapping->NumberOfElements[elementType]) || (totalElements == 0)) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        if (readElementStatus->VolumeTagInfo) {

            return STATUS_INVALID_PARAMETER;

        } else {

            if (elementType == ChangerDrive) {
                length = (sizeof(DISC_DATA_TRANSFER_ELEMENT_DESCRIPTOR) * totalElements);

            } else {
                length = (sizeof(DISC_ELEMENT_DESCRIPTOR) * totalElements);
            }
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x address %x\n",
               length,
               totalElements,
               elementType,
               element->ElementAddress));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 2000;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements <= 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than/equal zero - %x\n",
                       remainingElements));

            DebugPrint((1,
                       "Srb %p, statusBuffer %p, input buffer %p\n",
                       srb,
                       statusBuffer,
                       readElementStatus));

            DbgBreakPoint();

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;


                //
                // Source address
                //

                if (elementDescriptor->SValid) {
                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                }

                if (elementDescriptor->IdValid) {
                    DebugPrint((1,
                               "BusAddress for Element %x -> %x\n",
                               elementStatus->Element.ElementAddress,
                               elementDescriptor->BusAddress));

                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        DebugPrint((1,
                   "Disc: Init element status - AllElements\n"));

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 20;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;
        PDISC_INIT_ELEMENT_RANGE initCdb = (PDISC_INIT_ELEMENT_RANGE)cdb;

        //
        // Use the disc vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        initCdb->OperationCode = DISC_INIT_ELEMENT_RANGE;
        initCdb->ElementType = (UCHAR)element->ElementType;

        DebugPrint((1,
                   "Disc: Init element status - elementType %x, numberOfElements %x\n",
                   element->ElementType,
                   elementList->NumberOfElements));

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        initCdb->FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        initCdb->FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        initCdb->NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        initCdb->NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        srb->TimeOutValue = fdoExtension->TimeOutValue * 20;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    DebugPrint((1,
               "InitStatus: Status %x\n",
               status));

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "ExchangeMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 200;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "ExchangeMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    if (lockValue) {

        NTSTATUS preventStatus;

        //
        // Send the prevent to re-lock down the unit.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 200;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        //
        // Ignore any errors at this point. The calling layer will need to fixup any problems with
        // prevent/allow.
        //

        preventStatus = ClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                NULL,
                                                0,
                                                FALSE);

        DebugPrint((1,
                   "ExchangeMedium: Prevent sent. Status %x\n",
                   preventStatus));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 100;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    if (lockValue) {

        NTSTATUS preventStatus;

        //
        // Send the prevent to re-lock down the unit.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 100;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        //
        // Ignore any errors at this point. The LM will fixup any problems with
        // prevent/allow
        //

        preventStatus = ClassSendSrbSynchronous(DeviceObject,
                                srb,
                                NULL,
                                0,
                                FALSE);
        DebugPrint((1,
                   "MoveMedium: Prevent sent. Status %x\n",
                   preventStatus));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue*20;


    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DiscBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = DISC_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 100;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = DISC_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "discmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == DISC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}



NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "DISCMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\exabyte\exabyte.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    exabyte.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _EXABYTE_MC_
#define _EXABYTE_MC_

#define EXABYTE_210   1
#define EXABYTE_220   2
#define EXABYTE_440   3
#define EXABYTE_480   4
#define EXABYTE_10    5

#define EXABYTE_SERIAL_NUMBER_LENGTH 10

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device status returned by Send Diagnostic command
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[EXABYTE_SERIAL_NUMBER_LENGTH];

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;


#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;

//
// defines for Exabyte Additional Sense codes
// and Additional Sense code qualifiers
//
#define EXB_ADSENSE_DIAGNOSTIC_FAILURE              0x40
#define EXB_ADSENSE_TARGET_FAILURE                  0x44
#define EXB_ADSENSE_CARTRIDGE_ERROR                 0x81
#define EXB_ADSENSE_CHM_MOVE_ERROR                  0x82
#define EXB_ADSENSE_CHM_ZERO_ERROR                  0x83
#define EXB_ADSENSE_CARTRIDGE_INSERT_ERROR          0x84
#define EXB_ADSENSE_CHM_POSITION_ERROR              0x85
#define EXB_ADSENSE_HARDWARE_ERROR                  0x86
#define EXB_ADSENSE_CALIBRATION_ERROR               0x88
#define EXB_ADSENSE_SENSOR_ERROR                    0x89
#define EXB_ADSENSE_UNRECOVERABLE_ERROR             0x8A
#define EXB_ADSENSE_EJECT_ERROR                     0x8B

#define EXB_ADSENSEQUAL_FIRMWARE                    0x00
#define EXB_ADSENSEQUAL_CARTRIDGE_DROPPED           0x80
#define EXB_ADSENSEQUAL_MECH_PICK_ERROR             0x81
#define EXB_ADSENSEQUAL_PLACE_ERROR                 0x83
#define EXB_ADSENSEQUAL_STALLED                     0x84
#define EXB_ADSENSEQUAL_GRIPPER_OPEN_ERROR          0x85
#define EXB_ADSENSEQUAL_PICK_FAILURE                0x86

#define EXB_ADSENSEQUAL_CHM_ERROR                   0x80
#define EXB_ADSENSEQUAL_DOOR_ERROR                  0x88
#define EXB_ADSENSEQUAL_GRIPPER_ERROR               0x91
#define EXB_ADSENSEQUAL_GRIPPER_MOTION_ERROR        0x92
#define EXB_ADSENSEQUAL_SHORT_AXIS_MOVE             0xA0
#define EXB_ADSENSEQUAL_SHORT_HOMING_ERROR          0xA1
#define EXB_ADSENSEQUAL_SERVO_SHORT                 0xA3
#define EXB_ADSENSEQUAL_DESTINATION_SHORT           0xA5
#define EXB_ADSENSEQUAL_LONG_AXIS_MOVE              0xB0
#define EXB_ADSENSEQUAL_LONG_HOMING_ERROR           0xB1
#define EXB_ADSENSEQUAL_SERVO_LONG                  0xB3
#define EXB_ADSENSEQUAL_DESTINATION_LONG            0xB5
#define EXB_ADSENSEQUAL_DRUM_MOTION                 0xC0
#define EXB_ADSENSEQUAL_DRUM_HOME                   0xC1
#define EXB_ADSENSEQUAL_CONTROLLER_CARD             0xE0
#define EXB_ADSENSEQUAL_DESTINATION_SHORT2          0xE5
#define EXB_ADSENSEQUAL_DESTINATION_LONG2           0xF1

//
// Device Status codes on doing Send Diagnostic command
//
#define EXB_DEVICE_PROBLEM_NONE                     0x00
#define EXB_HARDWARE_ERROR                          0x01
#define EXB_CARTRIDGE_HANDLING_ERROR                0x02
#define EXB_DOOR_ERROR                              0x03
#define EXB_CALIBRATION_ERROR                       0x04
#define EXB_TARGET_FAILURE                          0x05
#define EXB_CHM_MOVE_ERROR                          0x06
#define EXB_CHM_ZERO_ERROR                          0x07
#define EXB_CARTRIDGE_INSERT_ERROR                  0x08
#define EXB_CHM_POSITION_ERROR                      0x09
#define EXB_SENSOR_ERROR                            0x0A
#define EXB_UNRECOVERABLE_ERROR                     0x0B
#define EXB_EJECT_ERROR                             0x0C
#define EXB_GRIPPER_ERROR                           0x0D

//
// Exabyte uses an addition 4 bytes on their device capabilities page...
//

#define EXABYTE_DEVICE_CAP_EXTENSION 4

typedef union _EXA_ELEMENT_DESCRIPTOR {

    struct _EXA_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } EXA_FULL_ELEMENT_DESCRIPTOR, *PEXA_FULL_ELEMENT_DESCRIPTOR;

    struct _EXA_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } EXA_PARTIAL_ELEMENT_DESCRIPTOR, *PEXA_PARTIAL_ELEMENT_DESCRIPTOR;

} EXA_ELEMENT_DESCRIPTOR, *PEXA_ELEMENT_DESCRIPTOR;

#define EXA_PARTIAL_SIZE sizeof(struct _EXA_PARTIAL_ELEMENT_DESCRIPTOR)
#define EXA_FULL_SIZE sizeof(struct _EXA_FULL_ELEMENT_DESCRIPTOR)

#define EXA_DISPLAY_LINES        4
#define EXA_DISPLAY_LINE_LENGTH 20

typedef struct _LCD_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR WriteLine : 4;
    UCHAR Reserved2 : 2;
    UCHAR LCDSecurity : 1;
    UCHAR SecurityValid : 1;
    UCHAR Reserved4;
    UCHAR DisplayLine[4][EXA_DISPLAY_LINE_LENGTH];
} LCD_MODE_PAGE, *PLCD_MODE_PAGE;

#define EXA_NO_ELEMENT 0xFFFF



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PEXA_ELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType,
    IN BOOLEAN IntrisicElement
    );

#endif // _EXABYTE_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\ddsmc\wmi.c ===
/*++ 

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for DDS changers.

Environment:

    kernel mode only

Revision History:

--*/ 
#include "ntddk.h"
#include "mcd.h"
#include "ddsmc.h"


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.


Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   changerId = changerData->DriveID;

   //
   // ISSUE: 02/29/2000 - nramas :
   // Need to handle DEC_TLZ changer. For now, 
   // do not handle DEC TLZ changers
   //
   if (changerId == DEC_TLZ) {
      return STATUS_NOT_IMPLEMENTED;
   }

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "DDSMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set only SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if ((NT_SUCCESS(status)) ||
       (status != STATUS_IO_DEVICE_ERROR)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if (status == STATUS_IO_DEVICE_ERROR) {
        //
        // Diagnostic test failed. Do ReceiveDiagnostic to receive
        // the results of the diagnostic test
        //  
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;
        if ((changerId == SONY_TSL) ||
            (changerId == COMPAQ_TSL)) {
           length = sizeof(SONY_TSL_RECV_DIAG);
           cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(SONY_TSL_RECV_DIAG);
        } else if ((changerId == HP_DDS2) ||
                   (changerId == HP_DDS3) ||
                   (changerId == HP_DDS4)) {
           length = sizeof(HP_RECV_DIAG);
           cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(HP_RECV_DIAG);
        } else {
            DebugPrint((1, "DDSMC:Unknown changer id %x\n",
                        changerId));
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            ChangerClassFreePool(srb);
            return STATUS_SUCCESS;
        }

        resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                                length);
        if (resultBuffer == NULL) {
            //
            // Not enough memory. Just set the generic 
            // ChangerProblemType (DeviceProblemHardware)
            // and return STATUS_SUCCESS
            //
           changerDeviceError->ChangerProblemType = DeviceProblemHardware;
           DebugPrint((1, "DDSMC:PerformDiagnostics - Not enough memory to ",
                       "receive diagnostic results\n"));

           ChangerClassFreePool(srb);
           return STATUS_SUCCESS;
        }

        srb->DataTransferLength = length;
        srb->DataBuffer = resultBuffer;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = 120;
        
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                FALSE);
        if (NT_SUCCESS(status)) {
            ProcessDiagnosticResult(changerDeviceError,
                                    resultBuffer, 
                                    changerId);
        }
                               
        ChangerClassFreePool(resultBuffer);
        status = STATUS_SUCCESS;
   } 

   ChangerClassFreePool(srb);
   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.
   
Arguements :

   changerDeviceError - Output buffer with diagnostic info
   
   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.
                  
   changerId    - Type of DDS changer (COMPAQ_TSL, SONY_TSL, etc)
   
Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.   
--*/
{
   UCHAR errorCode;
   UCHAR errorSet;
   CHANGER_DEVICE_PROBLEM_TYPE changerErrorType;

   changerErrorType = DeviceProblemNone;
   if (changerId == SONY_TSL) {
      PSONY_TSL_RECV_DIAG diagBuffer;

      diagBuffer = (PSONY_TSL_RECV_DIAG)resultBuffer;
      errorCode = diagBuffer->ErrorCode;
      errorSet = diagBuffer->ErrorSet;

      if (errorSet == 0) {
         switch (errorCode) {
            case TSL_NO_ERROR: {
               changerErrorType = DeviceProblemNone;
               break;
            }
            case MAGAZINE_LOADUNLOAD_ERROR:
            case ELEVATOR_JAMMED:
            case LOADER_JAMMED: {
               changerErrorType = DeviceProblemCHMError;
               break;  
            }

            case LU_COMMUNICATION_FAILURE:
            case LU_COMMUNICATION_TIMEOUT:
            case MOTOR_MONITOR_TIMEOUT:
            case AUTOLOADER_DIAGNOSTIC_FAILURE: {
               changerErrorType = DeviceProblemHardware;
               break;
            }

            default: {
               changerErrorType = DeviceProblemDriveError;
               break;
            }
         }
      } else {
         changerErrorType = DeviceProblemHardware;
      }

   } else if ((changerId == HP_DDS2) ||
              (changerId == HP_DDS3) ||
              (changerId == HP_DDS4)) {
      PHP_RECV_DIAG diagBuffer = (PHP_RECV_DIAG)resultBuffer;

      errorCode = diagBuffer->ErrorCode;

      if (errorCode <= 0x2B) {
         changerErrorType = DeviceProblemDriveError;
      } else if (((errorCode >= 0x42) && 
                 (errorCode <= 0x4F)) ||
                 ((errorCode >= 0x61) &&
                  (errorCode <= 0x7F))) {
         if (errorCode == 0x6F) {
            changerErrorType = DeviceProblemCartridgeInsertError;
         } else if (errorCode == 0x7E) {
            changerErrorType = DeviceProblemNone;
         } else {
            changerErrorType = DeviceProblemHardware;
         }
         //
         // Issue - 02/14/2000 - nramas
         // More error codes for HP DDS drives need to be
         // handled
         //
      } 
   }

   changerDeviceError->ChangerProblemType = changerErrorType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\elmsmc\elmsmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    elmsmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _ELMS_MC_
#define _ELMS_MC_

typedef struct _ELMS_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
} ELMS_STORAGE_ELEMENT_DESCRIPTOR, *PELMS_STORAGE_ELEMENT_DESCRIPTOR;

typedef struct _ELMS_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} ELMS_ELEMENT_DESCRIPTOR, *PELMS_ELEMENT_DESCRIPTOR;

#define ELMS_NO_ELEMENT 0xFFFF


typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[23];
    UCHAR Reserved1[6];
} SERIALNUMBER, *PSERIALNUMBER;


//
// Diagnostic sense codes
//
// ASC
//
#define ELMS_ASC_CHM_MOVE_ERROR                 0x02
#define ELMS_ASC_CARRIAGE_OR_BARCODE_FAILURE    0x06
#define ELMS_ASC_MECHANICAL_ERROR               0x15
#define ELMS_ASC_DIAGNOSTIC_FAILURE             0x40

//
// ASCQ
//
#define ELMS_ASCQ_CARRIAGE_FAILURE              0x00
#define ELMS_ASCQ_BARCODE_READER_FAILURE        0x80
#define ELMS_ASCQ_DOOR_OPEN                     0x81
#define ELMS_ASCQ_ELEVATOR_BLOCKED              0x82
#define ELMS_ASCQ_DRIVE_TRAY_OPEN               0x83
#define ELMS_ASCQ_ELEVATOR_FAILURE              0x84

//
// DeviceStatus
//
#define ELMS_DEVICE_PROBLEM_NONE    0x00
#define ELMS_HW_ERROR               0x01
#define ELMS_CHM_MOVE_ERROR         0x02
#define ELMS_DOOR_OPEN              0x03
#define ELMS_DRIVE_ERROR            0x04
#define ELMS_CHM_ERROR              0x05


#define ELMS_CD 0x01
#define ELMS_SERIAL_NUMBER_LENGTH       23

//
// unique asc and ascq for the DVL
//

#define SCSI_ADSENSE_DIAGNOSTIC_FAILURE 0x40
#define SCSI_SENSEQ_ELMS_UNIQUE         0x81

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either CD-ROM or CD-R.
    //

    ULONG DriveType;

    //
    // Device status after diagnostic test.
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[ELMS_SERIAL_NUMBER_LENGTH];

    //
    // Pad out to ULONG.
    //

    UCHAR Reserved;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved1;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
ElmsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _ELMS_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\elmsmc\elmsmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    elmsmc.c

Abstract:

    This module contains device-specific routines for ELMS Cd library devices

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "elmsmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ElmsBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the DVL changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = ElmsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->VendorId,"Elms", 4) == 4) {
        if (RtlCompareMemory(dataBuffer->ProductId,"DVL",3) == 3) {
            changerData->DriveType = ELMS_CD;
        }
    } else if (RtlCompareMemory(dataBuffer->VendorId,"CYGNET",6) == 6) {

        if (RtlCompareMemory(dataBuffer->ProductId,"ID100",5) == 5) {
            changerData->DriveType = ELMS_CD;
        }
    }


    //
    // Get the Vital Product Data page.
    //

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 33);
    if (!serialBuffer) {
        DebugPrint((1, "BuildAddressMapping failed. %x\n", status));

        ChangerClassFreePool(dataBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(serialBuffer, 33);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set EVPD
    //

    cdb->CDB6INQUIRY.Reserved1 = 1;

    //
    // Unit serial number page.
    //

    cdb->CDB6INQUIRY.PageCode = 0x80;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = 33;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     serialBuffer,
                                     33,
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ULONG i;

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber, 23);

        DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
        DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
        DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

        DebugPrint((1,"Serial number "));

        for (i = 0; i < 23; i++) {
            DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
        }

        DebugPrint((1,"\n"));

    }


    ChangerClassFreePool(serialBuffer);
    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    ULONG deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       switch (senseBuffer->SenseKey) {
           case SCSI_SENSE_NOT_READY:
               if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
                   (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)) {
   
                   //
                   // Indicate that the door is open.
                   //
   
                   *Status = STATUS_DEVICE_DOOR_OPEN;
               }
               break;
   
       case SCSI_SENSE_HARDWARE_ERROR:
               deviceStatus = ELMS_HW_ERROR;

               switch (senseBuffer->AdditionalSenseCode) {
                  case ELMS_ASC_CHM_MOVE_ERROR: {
                     deviceStatus = ELMS_CHM_MOVE_ERROR;
                     break;
                  }

                  case ELMS_ASC_CARRIAGE_OR_BARCODE_FAILURE:  {
                     if ((senseBuffer->AdditionalSenseCodeQualifier) == 
                         ELMS_ASCQ_CARRIAGE_FAILURE) {
                        deviceStatus = ELMS_CHM_ERROR;
                     } else if ((senseBuffer->AdditionalSenseCodeQualifier) == 
                                ELMS_ASCQ_BARCODE_READER_FAILURE) {
                                deviceStatus = ELMS_HW_ERROR;
                     }
                  }

                  case ELMS_ASC_MECHANICAL_ERROR: {
                     deviceStatus = ELMS_HW_ERROR;
                     break;
                  }

                  case ELMS_ASC_DIAGNOSTIC_FAILURE: {
                     switch (senseBuffer->AdditionalSenseCodeQualifier) {
                        case ELMS_ASCQ_DOOR_OPEN: {
                           *Status = STATUS_DEVICE_DOOR_OPEN;
                           deviceStatus = ELMS_DOOR_OPEN;
                           break;
                        }

                        case ELMS_ASCQ_ELEVATOR_BLOCKED: {
                           deviceStatus = ELMS_CHM_MOVE_ERROR;
                           break;
                        }

                        case ELMS_ASCQ_DRIVE_TRAY_OPEN: {
                           deviceStatus = ELMS_DRIVE_ERROR;
                           break;
                        }

                        case ELMS_ASCQ_ELEVATOR_FAILURE: {
                           deviceStatus = ELMS_CHM_ERROR;
                           break;
                        }
                        
                        default:    {
                           deviceStatus = ELMS_HW_ERROR;
                           break;
                        }
                     } // switch (senseBuffer->AdditionalSenseCodeQualifier)

                     break;
                  }

                  default: {
                     deviceStatus = ELMS_HW_ERROR;
                     break;
                  }
               } // switch (senseBuffer->AdditionalSenseCode)   

               changerData->DeviceStatus = deviceStatus;
               DebugPrint((1, "HardwareError - SenseKey %x, ASC %x, ASCQ %x\n",
                           senseBuffer->SenseKey,
                           senseBuffer->AdditionalSenseCode,
                           senseBuffer->AdditionalSenseCodeQualifier));
               break;
   
           case SCSI_SENSE_UNIT_ATTENTION:
   
               if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_POSITION_ERROR) {
                   if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {
   
                       DebugPrint((1,
                                   "Elmsmc: The specified source element has no media\n"));
   
                       //
                       // The indicated source address has no media.
                       //
   
                       *Status = STATUS_SOURCE_ELEMENT_EMPTY;
   
                   } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {
   
                       DebugPrint((1,
                                   "Elmsmc: The specified destination element already has media.\n"));
                       //
                       // The indicated destination already contains media.
                       //
   
                       *Status = STATUS_DESTINATION_ELEMENT_FULL;
                   } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_ELMS_UNIQUE) {
   
                       DebugPrint((1,
                                   "Elmsmc: The specified element is contained in a magazine no longer present.\n"));
   
                       *Status = STATUS_MAGAZINE_NOT_PRESENT;
                   }
   
               } else if (senseBuffer->AdditionalSenseCode == 0x5A) {
                   if (senseBuffer->AdditionalSenseCodeQualifier == 0x80) {
                       *Status = STATUS_DEVICE_DOOR_OPEN;
   
                   }
               }
   
           break;
   
       }
    }
    
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    //
    // The actual value should be that of above, but the magazines are considered IEPORTs.
    // For above layers to function properly, make this zero.
    //

    changerParameters->NumberIEElements = 0;

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        //
        // See note concerning IEPorts, above.
        //

        addressMapping->FirstElement[ChangerIEPort] = 0;

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = ELMS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 20;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_POSITION_TO_ELEMENT         |
                                   CHANGER_PREDISMOUNT_EJECT_REQUIRED  |
                                   CHANGER_PREMOUNT_EJECT_REQUIRED     |
                                   CHANGER_CARTRIDGE_MAGAZINE          |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                   CHANGER_SERIAL_NUMBER_VALID;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT);

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, ELMS_SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{


    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // Another verification of parameters.
    //

    if (readElementStatus->ElementList.NumberOfElements < 1) {
        return STATUS_INVALID_PARAMETER;
    }

    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;
        ULONG totalElements = 0;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];
        }

        //
        // Account for length of the descriptors expected for the slots.
        //

        length = (sizeof(ELMS_STORAGE_ELEMENT_DESCRIPTOR))*
                        addressMapping->NumberOfElements[ChangerSlot];

        //
        // Add in length of descriptors for the other element types.
        //

        length += (sizeof(ELMS_ELEMENT_DESCRIPTOR)) *
                      (totalElements - addressMapping->NumberOfElements[ChangerSlot]);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {

        if (elementType == ChangerSlot) {
            length = (sizeof(ELMS_STORAGE_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);
        } else {
            length = (sizeof(ELMS_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The DVL's may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (typeCount > ((LONG)descriptorLength * remainingElements)) {

            //
            // Handle a problem with earlier FW revs.
            //

            DebugPrint((1,
                        "ChangerGetElementStatus: DescriptorByteCount is hosed. Claimed: %x",
                        typeCount));

            typeCount = descriptorLength * remainingElements;

            DebugPrint((1," Actual: %x\n", typeCount));
        }

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // The device claims it has IEPorts, but the driver claims otherwise.
                // Throw away any of these.
                //

                if (elementType != ChangerIEPort) {

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Zero these first.
                    //

                    elementStatus->SrcElementAddress.ElementAddress = 0;
                    elementStatus->SrcElementAddress.ElementType = 0;

                    if (elementType == ChangerDrive) {

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                        }

                        if (elementDescriptor->IdValid) {
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }
                        if (elementDescriptor->LunValid) {
                            elementStatus->Lun = elementDescriptor->Lun;
                        }
                    }

                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    if (elementType == ChangerDrive) {

                        elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                        elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                        elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                        elementStatus->Flags |= (elementDescriptor->Invert << 22);
                        elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    }

                    //
                    // Map the exceptions.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                    //
                    // Work around for FW.
                    //

                    if ((elementDescriptor->AddSenseCodeQualifier == 0x0E) && (elementDescriptor->AdditionalSenseCode == 0x3B)) {

                        DebugPrint((1,
                                   "Elmsmc: elementStatus reports no media as exception\n"));

                        //
                        // This indicates no media in tray. Turn off the exception and ensure the Full flag is 0.
                        //

                        elementStatus->Flags &= ~ELEMENT_STATUS_EXCEPT;
                        elementStatus->Flags &= ~ELEMENT_STATUS_FULL;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                if (elementType != ChangerIEPort) {

                    //
                    // Don't advance user buffer for IEPorts
                    //

                    elementStatus += 1;
                }
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Verify transport and dest. are within range.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    if ((setPosition->Destination.ElementType > ChangerDrive) ||
        (setPosition->Destination.ElementType == ChangerIEPort) ||
        (setPosition->Destination.ElementType == ChangerTransport)) {

        //
        // Though positioning to IEPorts is valid from the mechanism point of view
        // we claim there are none on these devices, so don't allow this.
        //

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the elms units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ElmsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = ELMS_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = ELMS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x3B:
            if (ascq == 0x0E) {

                //
                // This should only be 'til the FW is fixed, though may keep it around
                // for legacy cases.
                //

                DebugPrint((1,
                           "Elmsmc: FW reports no media as exception\n"));
                exceptionCode = 0;

            } else if (ascq == 0x82) {
                exceptionCode = ERROR_SLOT_NOT_PRESENT;

            } else if (ascq == 0x84) {
                exceptionCode = ERROR_TRAY_MALFUNCTION;

            }
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "Elmsmc: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == ELMS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to ELMS_DEVICE_PROBLEM_NONE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set an appropriate devicestatus.
   //
   changerData->DeviceStatus = ELMS_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "ELMSMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set the SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != ELMS_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
               case ELMS_HW_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemHardware;
                  break;
               }

               case ELMS_CHM_MOVE_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
                  break;
               }

               case ELMS_DOOR_OPEN: {
                  changerDeviceError->ChangerProblemType = DeviceProblemDoorOpen;
                  break;
               }

               case ELMS_DRIVE_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemDriveError;
                  break;
               }

               case ELMS_CHM_ERROR: {
                  changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
                  break;
               }

               default: {
                  changerDeviceError->ChangerProblemType = DeviceProblemHardware;
                  break;
               }
      } // switch (changerData->DeviceStatus) 
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\libxprmc\libxprmc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    libxprmc.h

Abstract:

Authors:

Revision History:
    April 2000, Added support for Library Mode Page 23h
    August 25, 1999, Valerie Barr, Overland Data
        Added support for Alternate Volume Tag Information
    July 14, 1999, Valerie Barr, Overland Data
        Changed file name

--*/
#ifndef _LIBXPR_MC
#define _LIBXPR_MC_

#define OVR_ALT_VOLUME_ID_SIZE 20

#define LXB_OR_LXG    1
#define LXS           2

#define VPD_SERIAL_NUMBER_LENGTH 10

#define MODE_PAGE_LIBRARY_MODE 0x23     // Page Code for Library Mode Page

#define LIB_MODE_RANDOM 0x0
#define LIB_UNLOAD_MODE 0x8
#define LIB_RECIRC 0x10
#define LIB_DOOR_AUTO_CLOSE 0x20
#define LIB_DOOR_OPEN_RESPONSE 0x40

#define OVR_NO_ELEMENT 0xFFFF

typedef union _OVR_ELEMENT_DESCRIPTOR {

    struct _OVR_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
        UCHAR AlternateVolumeTag[OVR_ALT_VOLUME_ID_SIZE];
        UCHAR Reserved9[12];
    } OVR_FULL_ELEMENT_DESCRIPTOR, *POVR_FULL_ELEMENT_DESCRIPTOR;

    struct _OVR_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } OVR_PARTIAL_ELEMENT_DESCRIPTOR, *POVR_PARTIAL_ELEMENT_DESCRIPTOR;


    struct _OVR_DRIVE_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
        UCHAR DriveSerialNumber[36];
    } OVR_DRIVE_FULL_ELEMENT_DESCRIPTOR, *POVR_DRIVE_FULL_ELEMENT_DESCRIPTOR;

    struct _OVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
        UCHAR DriveSerialNumber[36];
    } OVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR, *POVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR;


} OVR_ELEMENT_DESCRIPTOR, *POVR_ELEMENT_DESCRIPTOR;

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];



    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

} CHANGER_DATA, *PCHANGER_DATA;

#define OVR_PARTIAL_SIZE sizeof(struct _OVR_PARTIAL_ELEMENT_DESCRIPTOR)
#define OVR_FULL_SIZE sizeof(struct _OVR_FULL_ELEMENT_DESCRIPTOR)

#define OVR_DRIVE_PARTIAL_SIZE sizeof(struct _OVR_DRIVE_PARTIAL_ELEMENT_DESCRIPTOR)
#define OVR_DRIVE_FULL_SIZE sizeof(struct _OVR_DRIVE_FULL_ELEMENT_DESCRIPTOR)

#define OVR_DISPLAY_LINES        4
#define OVR_DISPLAY_LINE_LENGTH 20

typedef struct _MODE_LIBRARY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR LibraryMode : 3;
    UCHAR UnldMd : 1;
    UCHAR Recirc : 1;
    UCHAR DoorAutoClose : 1;
    UCHAR DoorOpenResponse : 1;
    UCHAR Reserved2 : 1;
    UCHAR Reserved4;
} MODE_LIBRARY_PAGE, *PMODE_LIBRARY_PAGE;

typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;


NTSTATUS
OvrBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN POVR_ELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\libxprmc\libxprmc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    libxprmc.c

Abstract:

    This module contains device-specific routines for Overland Data
    medium changers:
         LXB, LXG, LXS, LXL, LXM, LIBRARYPRO, TL8xx, SSL2000 Series

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


    April xx, 2000 - Valerie Barr, Overland Data
        Added support for Overland LIBRARYPRO and COMPAQ SSL2000 Series
            Modified Features0 and Features1 values
        Support SCSI cmd Position To Element (implemented as a no-op)
    August 25, 1999 - Valerie Barr, Overland Data
        Fixed a blue-screen problem in which invalid primary volume tag info 
          was being written to a non-allocated buffer.
        Added support for slot and drive address differences between
          Overland and Compaq
        Modified the magazine size calculation
        Added support for alternate volume tag info for Overland and Compaq
    August 3, 1999 - Valerie Barr, Overland Data
        Corrected out of order memory deallocation instances
        Corrected not deallocating memory in error conditions
    July 14, 1999 - Valerie Barr, Overland Data
        Changed file names
        Fixed 2 warnings of conversions from int to char

--*/

#include "ntddk.h"
#include "mcd.h"
#include "libxprmc.h"

#ifdef  ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, OvrBuildAddressMapping)

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = NULL;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath,
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
                              VOID
                              )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by these changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}

NTSTATUS
ChangerInitialize(
                 IN PDEVICE_OBJECT DeviceObject
                 )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = OvrBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "Examc.ChangerInitialize: Error allocating dataBuffer. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            &srb,
                                            dataBuffer,
                                            sizeof(INQUIRYDATA),
                                            FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"LXB",3) == 3) {
            changerData->DriveID = LXB_OR_LXG;

        } else if (RtlCompareMemory(dataBuffer->ProductId,"LXS",3)==3) {
            changerData->DriveID = LXS;
        }
    }

    //
    // Get serial number page

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 14);
    if (!serialBuffer) {
        ChangerClassFreePool(dataBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.TimeOutValue = 10;
    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    // Set EVPD
    cdb->CDB6INQUIRY.Reserved1 = 1;

    // Unit serial number page.
    cdb->CDB6INQUIRY.PageCode = 0x80;

    // Set allocation length to inquiry data buffer size.
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            &srb,
                                            serialBuffer,
                                            sizeof(SERIALNUMBER),
                                            FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        RtlMoveMemory(changerData->SerialNumber, 
                      serialBuffer->SerialNumber, VPD_SERIAL_NUMBER_LENGTH);

    }

    if (serialBuffer)
        ChangerClassFreePool(serialBuffer);
    ChangerClassFreePool(dataBuffer);
    return STATUS_SUCCESS;
}

VOID
ChangerError(
            PDEVICE_OBJECT DeviceObject,
            PSCSI_REQUEST_BLOCK Srb,
            NTSTATUS *Status,
            BOOLEAN *Retry
            )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        if (senseBuffer->AdditionalSenseCode == 0x04) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x83:
                //               case 0x8D:
                //               case 0x8E:
                //               case 0x03:
                *Retry = FALSE;
                *Status = STATUS_DEVICE_DOOR_OPEN;
                break;
            default:
                break;
            }
        }

        if (senseBuffer->AdditionalSenseCode == 0x3B) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x90:
            case 0x91:
                *Retry = FALSE;
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
                break;
            default:
                break;
            }
        }

        if (senseBuffer->AdditionalSenseCode == 0x80) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x03:
            case 0x04:
                *Retry = FALSE;
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
                break;
            default:
                break;
            }
        }

        if (senseBuffer->AdditionalSenseCode == 0x83) {
            switch (senseBuffer->AdditionalSenseCodeQualifier) {
            case 0x02:
                *Retry = FALSE;
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
                break;
            case 0x04:
                *Retry = TRUE;
                *Status = STATUS_DEVICE_NOT_CONNECTED;
                break;
            default:
                break;
            }
        }
    }
    return;
}

NTSTATUS
ChangerGetParameters(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    these changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    PMODE_LIBRARY_PAGE librarymodePage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;
    struct _MODE_SENSE_VALUES {

        UCHAR    UnldMd : 1;        // To store Mode Sense value
        UCHAR    Recirc : 1;        // To store Mode Sense value
    } MODE_SENSE_VALUES;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // Mode Sense - Page 1D - Element Address Assignment

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                          sizeof(MODE_PARAMETER_HEADER) +
                                          sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                  sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);

    changerParameters->NumberTransportElements = 
    elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
    (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
    elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
    (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = 
    elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= 
    (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = 
    elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
    (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    // the front panel offset is determined by the vendor mode defaults 
    if ((RtlCompareMemory(changerData->InquiryData.VendorId,"DEC",3) == 3)  ||
        (RtlCompareMemory(changerData->InquiryData.VendorId,"COMPAQ",6) == 6)) {
        // Compaq mode
        changerParameters->FirstSlotNumber = 0;
        changerParameters->FirstDriveNumber =  0;
        changerParameters->FirstIEPortNumber = 0;
    } else {
        // Overland mode
        changerParameters->FirstSlotNumber = 1;
        changerParameters->FirstDriveNumber =  1;
        changerParameters->FirstIEPortNumber = 1;
    }

    changerParameters->FirstTransportNumber = 1;
    changerParameters->FirstCleanerSlotAddress = 0;

    // Magazine size
    // Make the magazine size the number of storage elements.  This works
    // for single module systems but is not quite true for multi-module 
    // systems which contain multiple magazines of different sizes.  However, 
    // there is not a way to communicate this to the next level since there 
    // is only one magazine size stored.  So, this value contains the total
    // number of storage elements available in the system.

    changerParameters->MagazineSize = changerParameters->NumberStorageElements;

    changerParameters->DriveCleanTimeout = 600;

    ChangerClassFreePool(modeBuffer);


    // Mode Sense - Page 1E - Transport Geometry Parameters

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                          sizeof(MODE_PARAMETER_HEADER) +
                                          sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                  sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);


    // initialize Features1  
    changerParameters->Features1 = 0;

    // check for AIT Library and set ieport features
    if ((RtlCompareMemory(changerData->InquiryData.ProductId,"LIBRARYPRO",10) == 10)  ||
        (RtlCompareMemory(changerData->InquiryData.ProductId,"SSL2000 Series",14) == 14)) {
        changerParameters->Features1 |=
        CHANGER_REPORT_IEPORT_STATE          |
        CHANGER_IEPORT_USER_CONTROL_OPEN     |
        CHANGER_IEPORT_USER_CONTROL_CLOSE;
    }


    changerParameters->Features0 = 
    transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
    CHANGER_STATUS_NON_VOLATILE           | 
    CHANGER_LOCK_UNLOCK                   |
    CHANGER_CARTRIDGE_MAGAZINE            |
    CHANGER_POSITION_TO_ELEMENT           |
    CHANGER_DRIVE_CLEANING_REQUIRED       |
    CHANGER_SERIAL_NUMBER_VALID; 


    // Only the DOOR can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;

    // Barcode scanner installed?
    changerParameters->Features0 |= 
    ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
    CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;

    ChangerClassFreePool(modeBuffer);

    // Mode Sense - Page 1F - Device Capabilities Parameters

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Features0 |= 
    capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
    capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
    capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= 
    capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    changerParameters->MoveFromTransport = 
    capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
    capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
    capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= 
    capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
    capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
    capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
    capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= 
    capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 
    capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= 
    capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= 
    capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= 
    capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = 
    capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
    capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
    capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= 
    capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
    capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
    capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
    capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= 
    capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
    capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
    capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
    capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= 
    capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 
    capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= 
    capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= 
    capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= 
    capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = 
    capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
    capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
    capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= 
    capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->PositionCapabilities = 0;

    ChangerClassFreePool(modeBuffer);


    // Mode Sense - Page 23 - Library Mode Parameters

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_LIBRARY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_LIBRARY_MODE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(modeBuffer);
        ChangerClassFreePool(srb);
        return status;
    }

    // Check to see if the Door Open and Door Auto Close are already set.

    librarymodePage = modeBuffer;
    (ULONG_PTR)librarymodePage += sizeof(MODE_PARAMETER_HEADER);

    if (!(librarymodePage->DoorAutoClose && librarymodePage->DoorOpenResponse)) {
        // Both are not set, issue Mode Select to set them

        // Save some parameters from the Mode Sense
        MODE_SENSE_VALUES.UnldMd = librarymodePage->UnldMd;
        MODE_SENSE_VALUES.Recirc = librarymodePage->Recirc;

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        length =  sizeof(MODE_PARAMETER_HEADER) + 
                  sizeof(MODE_LIBRARY_PAGE);

        RtlZeroMemory(modeBuffer, length);
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = 20;
        srb->DataTransferLength = length;
        srb->DataBuffer = modeBuffer;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.SPBit = SETBITON;      // Save Parameters
        cdb->MODE_SELECT.PFBit = SETBITON;      // Page format is SCSI-2
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)length;

        // Library Mode is 0 == RANDOM;
        librarymodePage->PageCode = MODE_PAGE_LIBRARY_MODE;
        librarymodePage->PageLength = 0x02;
        librarymodePage->UnldMd = MODE_SENSE_VALUES.UnldMd;     // From Mode Sense
        librarymodePage->Recirc = MODE_SENSE_VALUES.Recirc;     // From Mode Sense
        librarymodePage->DoorAutoClose = 0x01;
        librarymodePage->DoorOpenResponse = 0x01;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                TRUE);

        if (!NT_SUCCESS(status)) {
            ChangerClassFreePool(modeBuffer);
            ChangerClassFreePool(srb);
            return status;
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
                  changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
                  changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
                  changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, 
                  changerData->SerialNumber, VPD_SERIAL_NUMBER_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    // All units have a DOOR. Even though the LXG can be configured to have an 
    // IEPORT, this is not a configuration option.  
    if ((setAccess->Element.ElementType == ChangerKeypad) || 
        (setAccess->Element.ElementType == ChangerIEPort)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }


    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    if (controlOperation == LOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 1;
    } else if (controlOperation == UNLOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 0;
    } else {
        status = STATUS_INVALID_PARAMETER;            
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                writeToDevice);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    // Compaq and Overland return different sized data structures for 
    // the driveElementDescriptor. To determine the length of the real
    // data to be returned, we'll send out a request for just the first 
    // 8 bytes of data. From bytes 5-7 of the header, we can add 8 more 
    // bytes to it to get the length that this device will return for 
    // the requested elements. 

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    length = 8;  // header only ! ! !
    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;

    // VOltag must be cleared for Transport Elements
    if ((readElementStatus->VolumeTagInfo) && 
        (elementType != ChangerTransport)) {
        cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;
    }
    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;

        // Get the length that would be returned if we'd have allocated
        // more space via the CDB.

        length =  (statusHeader->ReportByteCount[2]);
        length |= (statusHeader->ReportByteCount[1] << 8);
        length |= (statusHeader->ReportByteCount[0] << 16);

        // need to add 8 bytes to account for the header
        length = length + 8;

        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
    } else {
        ChangerClassFreePool(statusBuffer);
        ChangerClassFreePool(srb);
        return status;
    } 


    // now do the real ReadElementStatus command with the length acquired 
    // from the last ReadElementStatus command

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;

    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;

    // VOltag must be cleared for Transport Elements
    if ((readElementStatus->VolumeTagInfo) && 
        (elementType != ChangerTransport)) {
        cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;
    }
    //
    // Fill in element addressing info based on the mapping values.
    //

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        POVR_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        ULONG remainingElements;
        ULONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        ULONG i;
        ULONG descriptorLength;

        // Determine total number elements returned.

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to its respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        typeCount /= descriptorLength;

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Full;
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                    elementStatus->TargetId = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                }
                if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                    elementStatus->Lun = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Lun;
                }

                if (tagInfo) {  // Upper level requested volume tags
                    // Let's see if the library returned data
                    if (statusPage->PVolTag) {
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlMoveMemory(elementStatus->AlternateVolumeID, elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AlternateVolumeTag, OVR_ALT_VOLUME_ID_SIZE);
                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //

                elementStatus += 1;

            }

            if (remainingElements) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                typeCount /= descriptorLength;
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP Irp
                              )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //
    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType ==
        AllElements) {

        // Build the normal SCSI-2 command for all elements.

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = 
        SCSIOP_INIT_ELEMENT_STATUS;

        // must set last byte to 0xC0, Do an init of barcodes and elements 
        // since there is no option to do a non-barcoded InitElemStatus
        cdb->INIT_ELEMENT_STATUS.Reserved3 = 0x40;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {
        PCHANGER_ELEMENT_LIST elementList = 
        &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = 
        SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        // Addresses of elements need to be mapped from 0-based to device-specific.

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        // Indicate whether to use bar code scanning.

        // must set last byte to 0xC0, not 80 on BC Scan
        cdb->INITIALIZE_ELEMENT_RANGE.Reserved4 = 0x40;
        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = 1;
        // cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

// The command is supported but it's a no-op... 

{
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerExchangeMedium(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )

/*++

Routine Description:

    None of the units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    // bug fix - cannot do transport to other element moves
    if ((moveMedium->Source.ElementType == ChangerTransport) || 
        (moveMedium->Destination.ElementType == ChangerTransport)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                    "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                    "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                    "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // there is no command on this library to home or reinit the 
    // changer mechanism

    return STATUS_INVALID_DEVICE_REQUEST;
}




NTSTATUS
ChangerQueryVolumeTags(
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp
                      )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
    PSCSI_REQUEST_BLOCK srb;
    PVOID    tagBuffer;
    PVOID    statusBuffer;
    PCDB     cdb;
    NTSTATUS status;

    //
    // Do some validation.
    //

    if (volTagInfo->ActionCode != SEARCH_PRI_NO_SEQ) {
        DebugPrint((1,
                    "QueryVolumeTags: Invalid Action Code %x\n",
                    volTagInfo->ActionCode));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        if (srb) {
            ChangerClassFreePool(srb);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    //
    // Load buffer with template.
    //

    RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;
    cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)(element->ElementType);

    cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
    (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;


    cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
    cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;


    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            tagBuffer,
                                            MAX_VOLUME_TEMPLATE_SIZE,
                                            TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;
        PVOID statusBuffer;

        //
        // Size of buffer returned is based on the size of the user buffer. If it's incorrectly
        // sized, the IoStatus.Information will be updated to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                        (OVR_FULL_SIZE * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)(element->ElementType);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                statusBuffer,
                                                requestLength,
                                                TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            POVR_ELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / OVR_FULL_SIZE;

            }

            DebugPrint((1,
                        "QueryVolumeTags: Matches found - %x\n",
                        numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for 'NumberOfElements' field + the array of elementStatus'.
            //

            Irp->IoStatus.Information = sizeof(ULONG_PTR) + (numberElements * sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {
                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
                (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    elementStatus->Element.ElementAddress = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -=
                    addressMapping->FirstElement[statusPage->ElementType];

                    elementStatus->Element.ElementType = statusPage->ElementType;

                    if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid) {

                        ULONG j;
                        USHORT tmpAddress;

                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    }

                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Full;
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                    if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                        elementStatus->TargetId = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                    }
                    if (elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                        elementStatus->Lun = elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.Lun;
                    }

                    RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (ULONG_PTR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                        "QueryVolumeTags: RequestElementAddress failed. %x\n",
                        status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                    "QueryVolumeTags: Send Volume Tag failed. %x\n",
                    status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}



NTSTATUS
OvrBuildAddressMapping(
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = OVR_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                          + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);


    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                         elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                     elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                      elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                    elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;
        addressMapping->Initialized = TRUE;
    }


    //
    // Determine the lowest element address for use with AllElements.
    //

    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < addressMapping->FirstElement[AllElements]) {

            DebugPrint((1,
                        "BuildAddressMapping: New lowest address %x\n",
                        addressMapping->FirstElement[i]));
            addressMapping->FirstElement[AllElements] = addressMapping->FirstElement[i];
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
                 IN POVR_ELEMENT_DESCRIPTOR ElementDescriptor
                 )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->OVR_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {
    case 0x3B: 
        switch (asq) {
        case 0x90:
        case 0x91:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
        }
        break; //0x3B

    case 0x80: 
        switch (asq) {
        case 0x01:
        case 0x02:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
        }
        break; //0x80

    case 0x83:
        switch (asq) {
        case 0x1:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        case 0x2:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        case 0x4:
            exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
            break;

        case 0x9:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;

        }
        break; // 0x83

    default:
        exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
                 IN PCHANGER_ADDRESS_MAPPING AddressMap,
                 IN USHORT ElementOrdinal,
                 IN ELEMENT_TYPE ElementType
                 )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((0,
                    "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                    ElementType,
                    ElementOrdinal,
                    AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == OVR_NO_ELEMENT) {

        DebugPrint((1,
                    "ElementOutOfRange: No Type %x present\n",
                    ElementType));

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\exabyte\wmi.c ===
/*++

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for exabyte changers.

Environment:

    kernel mode only

Revision History:

--*/


#include "ntddk.h"
#include <wmidata.h>
#include <wmistr.h>
#include "mcd.h"
#include "exabyte.h"

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer 
   are set appropriately.
   
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType; 

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "Exabyte\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;
   
   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;
   cdb->CDB6GENERIC.CommandUniqueBits = 0xA;

   //
   // Set DeviceStatus in the device extension to 
   // EXB_DEVICE_PROBLEM_NONE
   //
   changerData->DeviceStatus = EXB_DEVICE_PROBLEM_NONE;

   //
   // Send the request down
   //
   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else {
      //
      // First check if it a hardware error
      //
      if ((changerData->DeviceStatus) != EXB_DEVICE_PROBLEM_NONE) {
         DebugPrint((1, 
                     "Exabyte\\ChangerPerformDiagnostics ",
                     "Found hardware problem. DeviceStatus %x\n",
                     changerData->DeviceStatus));
         switch (changerData->DeviceStatus) {
            case EXB_HARDWARE_ERROR: {
               changerProblemType = DeviceProblemHardware;
               break;
            }

            case EXB_CARTRIDGE_HANDLING_ERROR: {
               changerProblemType = DeviceProblemCHMError;
               break;
            }

            case EXB_DOOR_ERROR: {
               changerProblemType = DeviceProblemDoorOpen;
               break;
            }

            case EXB_CALIBRATION_ERROR: {
               changerProblemType = DeviceProblemCalibrationError;
               break;
            }

            case EXB_TARGET_FAILURE: {
               changerProblemType = DeviceProblemTargetFailure;
               break;
            }

            case EXB_CHM_MOVE_ERROR: {
               changerProblemType = DeviceProblemCHMMoveError;
               break;
            }

            case EXB_CHM_ZERO_ERROR: {
               changerProblemType = DeviceProblemCHMZeroError;
               break;
            }

            case EXB_CARTRIDGE_INSERT_ERROR: {
               changerProblemType = DeviceProblemCartridgeInsertError;
               break;
            }

            case EXB_CHM_POSITION_ERROR: {
               changerProblemType = DeviceProblemPositionError;
               break;
            }

            case EXB_SENSOR_ERROR: {
               changerProblemType = DeviceProblemSensorError;
               break;
            }

            case EXB_UNRECOVERABLE_ERROR: {
               changerProblemType = DeviceProblemHardware;
               break;
            }

            case EXB_EJECT_ERROR: {
               changerProblemType = DeviceProblemCartridgeEjectError;
               break;
            }

            case EXB_GRIPPER_ERROR: {
               changerProblemType = DeviceProblemGripperError;
               break;
            }

            default : {
               changerProblemType = DeviceProblemHardware;
               break;
            }
         } // switch (changerData->DeviceStatus)
      } else {
         changerDeviceError->ChangerProblemType = DeviceProblemNone;
         DebugPrint((1, "Exabyte\\ChangerPerformDiagnostics : Status %x\n",
                     status));
      }
   } 

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\jvcmc\jvcmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    jvcmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _JVC_MC_
#define _JVC_MC_

typedef struct _JVC_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 7;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
    UCHAR Tray : 1;
    UCHAR IEPortOpen : 1;
    UCHAR Reserved11 : 6;
    UCHAR Reserved12;
} JVC_ELEMENT_DESCRIPTOR, *PJVC_ELEMENT_DESCRIPTOR;

typedef struct _JVC_INIT_ELEMENT_RANGE {
    UCHAR OperationCode;
    UCHAR Form : 2;
    UCHAR Reserved1 : 3;
    UCHAR LogicalUnitNumber : 3;
    UCHAR FirstElementAddress[2];
    UCHAR LastElementAddress[2];
    UCHAR Reserved2[4];
} JVC_INIT_ELEMENT_RANGE, *PJVC_INIT_ELEMENT_RANGE;

#define JVC_INIT_ELEMENT  0xE7
#define INIT_ALL_ELEMENTS 0x00
#define INIT_SPECIFIED_RANGE 0x02

#define JVC_NO_ELEMENT 0xFFFF


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the Sony units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Flag to indicate if the changer returned 
    // sense code SCSI_SENSE_HARDWARE_ERROR
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
JVCBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\hpmc\hpmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    hpmc.c

Abstract:

    This module contains device-specific routines for HP MO and DLT medium changers:
    HP 40FX, HP ..... TODO

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "hpmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, HpmoBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the HP DLT and MO changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    changerData->DeviceLocksPort = 1;

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"C1160A",6) == 6) {
        changerData->DriveType = HP_MO;
        changerData->DriveID   = HP1160;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C1160F",6) == 6) {
        changerData->DriveType = HP_MO;
        changerData->DriveID = HP1160;

    } else if ((RtlCompareMemory(dataBuffer->ProductId,"C1100F",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1107F",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1118J",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1118M",6) == 6) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C1100J",6) == 6)) {
        changerData->DriveType = HP_MO;
        changerData->DriveID = HP1100;
        changerData->DeviceLocksPort = 1;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5153F",6) == 6) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5153;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C1718T",6) == 6) {
        changerData->DriveType = HP_MO;
        changerData->DriveID = HP1718;
        changerData->DeviceLocksPort = 0;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C1194F",6) == 6) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP1194;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5151-4000", 10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;
        changerData->DeviceLocksPort = 0;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5151-2000", 10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;
        changerData->DeviceLocksPort = 0;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5177-4000",10) == 10) {

        //
        // Fast Wide versions of 1194 with DLT4000 and DLT7000 drives
        //

        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP1194;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5177-7000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP1194;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5173-4000",10) == 10) {

        //
        // Fast Wide versions of 5151 with DLT4000 and DLT7000 drives
        //

        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"C5173-7000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP5151;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C6280-4000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP418;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C6280-7000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP418;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"C6280-8000",10) == 10) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP418;
    } else if ((RtlCompareMemory(dataBuffer->ProductId,"C7200-8000",10) == 10) ||
               (RtlCompareMemory(dataBuffer->ProductId,"C7145-8000",10) == 10)) {
        changerData->DriveType = HP_DLT;
        changerData->DriveID = HP7000;
    } 

    //
    // Check for Plasmon and Pinnacle.
    //

    if (RtlCompareMemory(dataBuffer->VendorId,"PINNACLE", 8) == 8) {
        if (RtlCompareMemory(dataBuffer->ProductId,"ALTA", 4) == 4) {

            //
            // Acts like an 1100
            //

            changerData->DriveType = HP_MO;
            changerData->DriveID = PINNACLE;
            changerData->DeviceLocksPort = 1;
        }
    } else if (RtlCompareMemory(dataBuffer->VendorId,"IDE     ", 8) == 8) {

        if (RtlCompareMemory(dataBuffer->ProductId,"MULTI", 5) == 5) {
            changerData->DriveType = HP_MO;
            changerData->DriveID = PLASMON;
            changerData->DeviceLocksPort = 0;
        }
    }

    DebugPrint((1,
               "ChangerInitialize: DriveType %x, DriveID %x\n",
               changerData->DriveType,
               changerData->DriveID));

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = HpmoBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);
    return STATUS_SUCCESS;
}

VOID
ScanForSpecial(
     IN PDEVICE_OBJECT DeviceObject,
     IN PGET_CHANGER_PARAMETERS ChangerParameters
     )

/*
   Routine Description : 
      This routine reads from registry certain hardware features, 
      and overrides the features derived (incorrectly) from the device.
      
   Arguments:
      DeviceObject  Pointer to the functional device object
      changerParameters Pointer to GET_CHANGER_PARAMETERS struct
   
   Return Value:
      None
 */

{
   PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension;
   PCHANGER_DATA   changerData; 
   NTSTATUS status;
   HANDLE deviceHandle, keyHandle;
   ULONG DeviceHasDoor, IEPortUserClose;
   RTL_QUERY_REGISTRY_TABLE queryTable[3];
   PDEVICE_OBJECT physicalDeviceObject;
   OBJECT_ATTRIBUTES ObjAttributes;
   UNICODE_STRING DriverName;
   ULONG DeviceBit;

   DebugPrint((3, "Entered ScanForSpecial in HPMC.SYS.\n"));
   
   ASSERT(DeviceObject != NULL);
   fdoExtension = DeviceObject->DeviceExtension;
   
   ASSERT(fdoExtension != NULL);
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   
   physicalDeviceObject = fdoExtension->LowerPdo;

   //
   // Open a handle to the device node.
   //
   status = IoOpenDeviceRegistryKey(physicalDeviceObject, 
                                    PLUGPLAY_REGKEY_DEVICE, 
                                    KEY_QUERY_VALUE, 
                                    &deviceHandle);
   if (!NT_SUCCESS(status)) {
       DebugPrint((1, 
                   "IoOpenDeviceRegistryKey Failed in ScanForSpecial : %x.\n",
                   status));
       return;
   }

   DebugPrint((3, 
             "IoOpenDeviceRegistryKey success in HPMC.SYS!ScanForSpecial.\n"));
   
   RtlInitUnicodeString(&DriverName, HPMC_MEDIUM_CHANGER);
   
   RtlZeroMemory(queryTable, sizeof(queryTable));

   InitializeObjectAttributes(&ObjAttributes, &DriverName, 
                               (OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE),
                               deviceHandle, NULL);
   status = ZwOpenKey(&keyHandle, KEY_READ, &ObjAttributes);
   if (!NT_SUCCESS(status)) {
      DebugPrint((1, "ZwOpenKey failed in hpmc.sys : %x.\n",
                  status));
      ZwClose(deviceHandle);
      return;
   }
   
   //
   // Read values for device specific features from registry.
   // If the device has door, DeviceHasDoor flag should
   // be set to 1. Otherwise 0. Similarly, if IEPort
   // should be closed by the user, IEPortUserClose flag
   // should be set to 1. Otherwise 0.
   //
   queryTable[0].Flags = (RTL_QUERY_REGISTRY_REQUIRED | 
                             RTL_QUERY_REGISTRY_DIRECT);
   queryTable[0].Name = (PWSTR) DEVICE_DOOR;
   queryTable[0].EntryContext = &DeviceHasDoor;
   queryTable[0].DefaultType = REG_DWORD;
   queryTable[0].DefaultData = NULL;
   queryTable[0].DefaultLength = 0;
   
   queryTable[1].Flags = (RTL_QUERY_REGISTRY_REQUIRED | 
                          RTL_QUERY_REGISTRY_DIRECT);
   queryTable[1].Name = (PWSTR) DEVICE_IEPORT_USER_CLOSE;
   queryTable[1].EntryContext = &IEPortUserClose;
   queryTable[1].DefaultType = REG_DWORD;
   queryTable[1].DefaultData = NULL;
   queryTable[1].DefaultLength = 0;

   status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE, 
                                   (PWSTR)keyHandle, queryTable, 
                                   NULL, NULL);
   if (!NT_SUCCESS(status)) {
      DebugPrint((1, 
                  "QueryRegistry failed for DEVICE_DOOR : %d.\n",
                  status));
      ZwClose(keyHandle);
      ZwClose(deviceHandle);
      return;
   }
      
   //
   // Check the bit corresponding to this device to determine if
   // the device has door and if IEPort should be closed by the user.
   //
   DeviceBit = (1 << ((changerData->DriveID) - 1));

   if ((DeviceHasDoor & DeviceBit) == 0) {
      DebugPrint((3, "Modifying LockUnlockCapabilities flag.\n"));
      ChangerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_DOOR;
   }

   if ((IEPortUserClose & DeviceBit) != 0) {
      DebugPrint((3, "Modifying Features1 flag.\n"));
      ChangerParameters->Features1 |= CHANGER_IEPORT_USER_CONTROL_CLOSE;
   }

   // 
   // Close the handle to the registry subkey and devnode
   //
   ZwClose(keyHandle);
   ZwClose(deviceHandle);
   
   return;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

            case SCSI_SENSE_ILLEGAL_REQUEST:

                //if (senseBuffer->AdditionalSenseCode == ?? sense data for 'the unit is locked') {
                //}
                break;

            case SCSI_SENSE_UNIT_ATTENTION:

                changerData->LockCount = 0;
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
                changerData->DeviceStatus = HPMC_HW_ERROR;
                break;
            }

            default:
                break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    HP changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
        cdb->MODE_SENSE.Dbd = 1;
    }

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);
    }

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = HP_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }
    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    if (changerData->DriveType == HP_DLT) {
        changerParameters->NumberOfDoors = 1;
    } else {
        changerParameters->NumberOfDoors = 0;
    }

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    if (changerData->DriveID == HP5153 || changerData->DriveID == HP5151) {
        changerParameters->MagazineSize = 5;
    } else if (changerData->DriveID == HP7000) {
        changerParameters->MagazineSize = 6;
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
        cdb->MODE_SENSE.Dbd = 1;
    }
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)transportGeometryPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);
    }

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;
    changerParameters->Features1 = 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 300;
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT | LOCK_UNLOCK_DOOR);
    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT      |
                                               CHANGER_TO_IEPORT    |
                                               CHANGER_TO_DRIVE);

    if (changerData->DriveID == HP1194) {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED      |
                                        CHANGER_CLOSE_IEPORT                    |
                                        CHANGER_OPEN_IEPORT                     |
                                        CHANGER_EXCHANGE_MEDIA                  |
                                        CHANGER_LOCK_UNLOCK                     |
                                        CHANGER_POSITION_TO_ELEMENT             |
                                        CHANGER_REPORT_IEPORT_STATE             |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE     |
                                        CHANGER_DRIVE_CLEANING_REQUIRED         |
                                        CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;
    }

    if ((changerData->DriveID == HP5151) || 
        (changerData->DriveID == HP5153) ||
        (changerData->DriveID == HP7000)) {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED  |
                                        CHANGER_LOCK_UNLOCK                 |
                                        CHANGER_POSITION_TO_ELEMENT         |
                                        CHANGER_DRIVE_CLEANING_REQUIRED     |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                        CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

    } else if (changerData->DriveID == HP418) {
        changerParameters->Features0 |= CHANGER_LOCK_UNLOCK                 |
                                        CHANGER_POSITION_TO_ELEMENT         |
                                        CHANGER_DRIVE_CLEANING_REQUIRED     |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                        CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

       changerParameters->Features1 |= CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR;
    }

    if (changerData->DriveType == HP_MO) {

        //
        // MO units
        //

        changerParameters->Features0 |= CHANGER_CLOSE_IEPORT                  |
                                        CHANGER_OPEN_IEPORT                   |
                                        CHANGER_EXCHANGE_MEDIA                |
                                        CHANGER_LOCK_UNLOCK                   |
                                        CHANGER_POSITION_TO_ELEMENT           |
                                        CHANGER_DEVICE_REINITIALIZE_CAPABLE   |
                                        CHANGER_REPORT_IEPORT_STATE;

        changerParameters->DriveCleanTimeout = 0;

        if (changerData->DriveID == PLASMON) {

            //
            // IEport can't retract and can't tell when media is inserted when open.
            //

            changerParameters->Features0 &= ~CHANGER_CLOSE_IEPORT;
            changerParameters->Features0 &= ~CHANGER_REPORT_IEPORT_STATE;

            //
            // Transport needs to be positioned in front of drive on dismount.
            //

            changerParameters->Features1 |= CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE;
        }

        if (changerData->DriveID == PINNACLE) {

            changerParameters->Features0 &= ~(CHANGER_CLOSE_IEPORT | CHANGER_OPEN_IEPORT);
        }
    } else {

        //
        // DLT
        //

        changerParameters->Features0 |= CHANGER_CLEANER_ACCESS_NOT_VALID;
    }

    if ((changerData->DriveID == HP1100) || (changerData->DriveID == PINNACLE)) {
        changerParameters->Features0 &= ~CHANGER_EXCHANGE_MEDIA;
        changerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_DOOR;
    }

    if ((changerData->DriveID == HP5151) || 
        (changerData->DriveID == HP418)) {
        changerParameters->PositionCapabilities &= ~CHANGER_TO_IEPORT;
        changerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_IEPORT;

    }
    
    if (changerData->DriveID == HP1160) {
        changerParameters->LockUnlockCapabilities &= ~LOCK_UNLOCK_DOOR;
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
        cdb->MODE_SENSE.Dbd = 1;
    }
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)capabilitiesPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);
    }

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    if (changerData->DriveID == HP418) {

        //
        // As slot->slot moves are only available on a subset of slots, claim no support.
        //

        changerParameters->MoveFromSlot &= ~CHANGER_TO_SLOT;
    }
    if (changerData->DriveType == HP_DLT) {

        if ((changerData->DriveID == HP1194) ||
            (changerData->DriveID == HP7000)) {
            changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
            changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
            changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
            changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

        } else {
            changerParameters->MoveFromIePort = 0;
        }

    } else {
        changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
        changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
        changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
        changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;
    }

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    ScanForSpecial(DeviceObject, changerParameters);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->InquiryData.VendorSpecific, SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    LONG                lockValue = 0;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (changerData->DeviceLocksPort) {
        if (controlOperation == LOCK_ELEMENT) {

            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

        } else if (controlOperation == UNLOCK_ELEMENT) {

            //
            // Dec the lock count to indicate that an unlock has been sent.
            //

            changerData->LockCount = 0;
        } else {

            //
            // Either an extend or retract.
            // Need to ensure that the unit isn't locked down.
            //

            lockValue = changerData->LockCount;
            DebugPrint((1,
                       "SetAccess: LockCount is %x\n",
                       changerData->LockCount));


            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB6GENERIC_LENGTH;

            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        }
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerDoor) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;
        }

    } else if (setAccess->Element.ElementType == ChangerIEPort) {

        if (addressMapping->NumberOfElements[ChangerIEPort] == 0) {
            status = STATUS_INVALID_PARAMETER;
        } else {

            if (controlOperation == LOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue prevent media removal command to lock the ie port.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;

            } else if (controlOperation == EXTEND_IEPORT) {

                if (changerData->DriveID == PINNACLE) {

                    ChangerClassFreePool(srb);
                    return STATUS_INVALID_DEVICE_REQUEST;
                }

                srb->TimeOutValue = fdoExtension->TimeOutValue;

                //
                // Hp uses a vendor unique mailslot command.
                //

                cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = HP_MAILSLOT_OPEN;

            } else if (controlOperation == RETRACT_IEPORT) {

                if (changerData->DriveID == PINNACLE) {
                    ChangerClassFreePool(srb);
                    return STATUS_INVALID_DEVICE_REQUEST;
                }

                srb->TimeOutValue = fdoExtension->TimeOutValue;

                //
                // Hp uses a vendor unique mailslot command.
                //

                cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = HP_MAILSLOT_CLOSE;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    } else {

        //
        // No keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
        if (status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            // If EXTEND\RETRACT IEPort is not supported
            // by this changer, then just ignore the
            // error
            //
            if ((controlOperation == RETRACT_IEPORT) ||
                (controlOperation == EXTEND_IEPORT)) {

                DebugPrint((1, "Extend or Retract not supported\n"));
                status = STATUS_SUCCESS;
            }
        }

    }

    if (lockValue) {
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;

        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
        status = STATUS_SUCCESS;
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT_STATUS_EX   elementStatusEx;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;
    ULONG    outputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    BOOLEAN  IsSCSI3 = FALSE;

    if (((changerData->InquiryData.Versions) & 0x7) >= 3) {
        IsSCSI3 = TRUE;
    }

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        if (changerData->DriveType == HP_MO || changerData->DriveID == HP418) {

            //
            // These units have no Volume tag capability. DLT have this capability
            //

            return STATUS_INVALID_PARAMETER;

        }
    }

    if (((changerData->DriveID) == HP7000) &&
        (elementType == ChangerIEPort)) {
        LARGE_INTEGER waitTime;

        waitTime.LowPart = (ULONG)(- ( 10 * 1000 * 10000 ));
        waitTime.HighPart = -1;
        KeDelayExecutionThread(KernelMode, FALSE, &waitTime);
    }

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if ((readElementStatus->VolumeTagInfo) ||
            (IsSCSI3 == TRUE)) {

            length = sizeof(HPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS) *
                            addressMapping->NumberOfElements[ChangerDrive];

            //
            // Add in length of descriptors for transport and IEPort (if applicable).
            //

            length += sizeof(HPMO_ELEMENT_DESCRIPTOR) *
                          (totalElements - (addressMapping->NumberOfElements[ChangerDrive] +
                                            addressMapping->NumberOfElements[ChangerSlot]));
            //
            // Add in length for slots.
            //

            length += sizeof(HPMO_ELEMENT_DESCRIPTOR_PLUS) * addressMapping->NumberOfElements[ChangerSlot];

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        } else {

            if (changerData->DriveID == PLASMON) {

                length = sizeof(PLASMON_ELEMENT_DESCRIPTOR) * totalElements;

            } else {

                length = sizeof(HPMO_DATA_XFER_ELEMENT_DESCRIPTOR) * addressMapping->NumberOfElements[ChangerDrive];

                //
                // Add in length of descriptors for the other element types.
                //

                length += sizeof(HPMO_ELEMENT_DESCRIPTOR) *
                              (totalElements -
                               addressMapping->NumberOfElements[ChangerDrive]);

            }
            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        if ((readElementStatus->VolumeTagInfo) ||
            (IsSCSI3 == TRUE)) {

            if (elementType == ChangerSlot) {

                length = (sizeof(HPMO_ELEMENT_DESCRIPTOR_PLUS) * totalElements);

            } else if (elementType == ChangerDrive) {

                length = (sizeof(HPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS) * totalElements );

            } else {

                //
                // No vol tag info from the other types.
                //

                length = (sizeof(HPMO_ELEMENT_DESCRIPTOR) * totalElements);
            }

        } else {

            if (changerData->DriveID == PLASMON) {

                length = (sizeof(PLASMON_ELEMENT_DESCRIPTOR) * totalElements);

            } else {
                if (elementType == ChangerDrive) {
                    length = (sizeof(HPMO_DATA_XFER_ELEMENT_DESCRIPTOR) * totalElements);
                } else {
                    length = (sizeof(HPMO_ELEMENT_DESCRIPTOR) * totalElements);
                }
            }
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((1,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The HP's may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // If we are using SCSI-3 set Dvc Id bit (1st bit of the 7th byte in
    // the CDB) to retrieve "Device Identification Descriptor"
    //
    // ISSUE - 2000/02/11 - nramas : Should change Reserved1 field in CDB
    // to meaningful name.
    //
    if ((elementType == ChangerDrive) && (IsSCSI3 == TRUE)) {

       cdb->READ_ELEMENT_STATUS.Reserved1 = 0x01;

       //
       // In the descriptor returned for Drive, product info
       // follows volumetag info. So, we get both volume tag
       // and product info for drives
       //
       cdb->READ_ELEMENT_STATUS.VolTag = 0x01;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if ((NT_SUCCESS(status)) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if ((srb->DataTransferLength) <= length) {
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "HPMC:ReadElementStatus - Dataoverrun.\n"));
              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements < 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than zero - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if ((tagInfo) ||
                    (IsSCSI3 == TRUE)) {

                    //
                    // For drive and slot types, copy the additional fields (vol tag info).
                    //

                    if (elementType == ChangerDrive) {
                        PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS driveDescriptor =
                                                                (PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                        if (statusPage->PVolTag) {
                            RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                          driveDescriptor->VolumeTagInformation, 
                                          MAX_VOLUME_ID_SIZE);

                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }

                        //
                        // Copy Device indentification information if
                        // the device implemenets SCSI-3 or higher
                        //
                        if (IsSCSI3 == TRUE) {
                            if (outputBuffLen >= 
                                (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {

                                elementStatusEx = (PCHANGER_ELEMENT_STATUS_EX)elementStatus; 

                                RtlMoveMemory(elementStatusEx->VendorIdentification,
                                              driveDescriptor->VendorID,
                                              VENDOR_ID_LENGTH);

                                RtlMoveMemory(elementStatusEx->ProductIdentification,
                                              driveDescriptor->ProductID,
                                              PRODUCT_ID_LENGTH);

                                //
                                // Serial number is 10 bytes long
                                //
                                RtlMoveMemory(elementStatusEx->SerialNumber,
                                              driveDescriptor->SerialNumber,
                                              10);

                                DebugPrint((3, 
                                            "Serial number : %s\n",
                                            elementStatusEx->SerialNumber));
                                elementStatusEx->Flags |= ELEMENT_STATUS_PRODUCT_DATA;
                            }
                        }
                        
                        if (elementDescriptor->IdValid) {
                            elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }

                        if (elementDescriptor->LunValid) {
                            elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                            elementStatus->Lun = elementDescriptor->Lun;
                        }

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                        }

                    } else if (elementType == ChangerSlot) {
                        PHPMO_ELEMENT_DESCRIPTOR_PLUS slotDescriptor =
                                                         (PHPMO_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                        if (statusPage->PVolTag) {
                            RtlMoveMemory(elementStatus->PrimaryVolumeID, slotDescriptor->VolumeTagInformation, MAX_VOLUME_ID_SIZE);
                            elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }
                    }

                } else {

                    if (elementType == ChangerDrive) {

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {
                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }

                        if (elementDescriptor->IdValid) {
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }
                        if (elementDescriptor->LunValid) {
                            elementStatus->Lun = elementDescriptor->Lun;
                        }
                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                if (elementType == ChangerDrive) {
                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);
                }

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // The HP units don't have the capability of reporting exceptions
                    // in this manner except for - DataTransferElements on Optical
                    // DataXfer, Slot on DLT
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all spaces. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != ' ') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "Hpmc.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                if (outputBuffLen >= 
                    (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
                    DebugPrint((3, 
                                "Incrementing by sizeof(CHANGER_ELEMENT_STATUS_EX\n"));
                    (PUCHAR)elementStatus += sizeof(CHANGER_ELEMENT_STATUS_EX);
                } else {
                    elementStatus += 1;
                }

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }

                if (typeCount < 0) {
                    DebugPrint((1,
                               "ChangerGetElementStatus(2): Count of type %x less than zero - %x\n",
                               elementType,
                               typeCount));
                }
            }

        } while (remainingElements);


        DebugPrint((3, "IoStatus.Information set to %d\n",
                    outputBuffLen));
        if (outputBuffLen >= 
            (totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX))) {
            Irp->IoStatus.Information = totalElements * sizeof(CHANGER_ELEMENT_STATUS_EX);
        } else {
            Irp->IoStatus.Information = totalElements * sizeof(CHANGER_ELEMENT_STATUS);
        }
    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    switch (changerData->DriveID) {
        case HP5151:
        case HP5153:
        case HP418:
        case HP7000: {
            DebugPrint((1, "ChangerExchangeMedium not supported for device %d\n",
                        (changerData->DriveID)));
            return STATUS_INVALID_DEVICE_REQUEST;
        } 

        default:  {
            break;
        }
    } // switch (changerData->DriveID)

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // for HP 1194, if the source or destination is an IEPORT,
    // do an allow before the move and a prevent after the move.
    // This works around the behaviour of the device whereby a PreventMediumRemoval
    // inhibits a MoveMedium to/from the IEPORT.
    //

    if ((changerData->DeviceLocksPort) &&
       ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort))) {


        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "ExchangeMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "ExchangeMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    if ((changerData->DeviceLocksPort) &&
       ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort))) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The calling layer will need to fixup any problems with
            // prevent/allow.
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                                    srb,
                                                    NULL,
                                                    0,
                                                    FALSE);

            DebugPrint((1,
                       "ExchangeMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // for many HP units, if the source or destination is an IEPORT,
    // do an allow before the move and a prevent after the move.
    // This works around the behaviour of the device whereby a PreventMediumRemoval
    // inhibits a MoveMedium to/from the IEPORT.
    //

    if ((changerData->DeviceLocksPort) &&
        ((moveMedium->Destination.ElementType == ChangerIEPort) ||
         (moveMedium->Source.ElementType == ChangerIEPort))) {


        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    if ((changerData->DeviceLocksPort) &&
        ((moveMedium->Destination.ElementType == ChangerIEPort) ||
         (moveMedium->Source.ElementType == ChangerIEPort))) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The LM will fixup any problems with
            // prevent/allow
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    NULL,
                                    0,
                                    FALSE);
            DebugPrint((1,
                       "MoveMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);

    DebugPrint((1,
               "MoveMedium: Returning %x\n",
               status));
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    //
    // Clear locks.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);
    //
    // Set LockCount to zero.
    //

    changerData->LockCount = 0;

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
HpmoBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = HP_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    if (changerData->DriveID == HP1718) {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    } else {
        bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
        cdb->MODE_SENSE.Dbd = 1;
    }

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    if (changerData->DriveID == HP1718) {
        (PCHAR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK));
    } else {
        (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);
    }

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = HP_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);


        if (changerData->DriveType == HP_MO) {
            addressMapping->NumberOfElements[ChangerDoor] = 0;
        } else {
            addressMapping->NumberOfElements[ChangerDoor] = 1;
        }
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }




    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;

    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "Hpmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == HP_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   changerId = changerData->DriveID;

   //
   // Initialize the devicestatus in the device extension to
   // HPMC_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = HPMC_DEVICE_PROBLEM_NONE;
   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "HPMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set the selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
       changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == HPMC_HW_ERROR) {
       //
       // Diagnostic test failed. Do ReceiveDiagnostic to receive
       // the results of the diagnostic test
       //
       RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

       cdb = (PCDB)srb->Cdb;
       cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;
       cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(HPMC_RECV_DIAG);
       resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                               sizeof(HPMC_RECV_DIAG));
       if (resultBuffer == NULL) {
           //
           // No memory to receive diagnostic result. Set the
           // generic error code (DeviceProblemHardware), but return
           // STATUS_SUCCESS anyway.
           //
           changerDeviceError->ChangerProblemType = DeviceProblemHardware;
           DebugPrint((1, "HPMC:PerformDiagnostics - Not enough memory to ",
                       "receive diagnostic results\n"));

           ChangerClassFreePool(srb);
           return STATUS_SUCCESS;
       }

       srb->DataTransferLength = sizeof(HPMC_RECV_DIAG);
       srb->DataBuffer = resultBuffer;
       srb->CdbLength = CDB6GENERIC_LENGTH;
       srb->TimeOutValue = 120;

       status = ChangerClassSendSrbSynchronous(DeviceObject,
                                        srb,
                                        srb->DataBuffer,
                                        srb->DataTransferLength,
                                        FALSE);
       if (NT_SUCCESS(status)) {
           ProcessDiagnosticResult(changerDeviceError,
                                   resultBuffer,
                                   changerId);
       }

       ChangerClassFreePool(resultBuffer);
       status = STATUS_SUCCESS;
   }

   ChangerClassFreePool(srb);
   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.

Arguements :

   changerDeviceError - Output buffer with diagnostic info

   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.

   changerId    - Type of DDS changer (COMPAQ_TSL, SONY_TSL, etc)

Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.
--*/
{
   UCHAR errorCode;
   UCHAR FRU_One;
   UCHAR FRU_Two;
   UCHAR FRU_Three;
   CHANGER_DEVICE_PROBLEM_TYPE changerErrorType;
   PHPMC_RECV_DIAG  diagBuffer;

   changerErrorType = DeviceProblemNone;
   diagBuffer = (PHPMC_RECV_DIAG)resultBuffer;

   errorCode = diagBuffer->HWErrorCode;
   FRU_One = diagBuffer->FRU_1;
   FRU_Two = diagBuffer->FRU_2;
   FRU_Three = diagBuffer->FRU_3;

   //
   // ISSUE: 02/24/2000 - nramas
   // Not sure if the FRUs returned indicate a hardware error
   // or not. For now, do not return HW error for them.
   //
   DebugPrint((1, "HPMC\\RecvDiag : FRU_1 %x, FRU_2 %x, FRU_3 %x\n",
               FRU_One, FRU_Two, FRU_Three));
   if (errorCode) {
       changerErrorType = DeviceProblemHardware;
   }

   changerDeviceError->ChangerProblemType = changerErrorType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\hpmc\hpmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    hpmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _HP_MC_
#define _HP_MC_

typedef struct _HPMO_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
} HPMO_ELEMENT_DESCRIPTOR, *PHPMO_ELEMENT_DESCRIPTOR;

typedef struct _HPMO_DATA_XFER_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} HPMO_DATA_XFER_ELEMENT_DESCRIPTOR, *PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR;

typedef struct _HPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR VolumeTagInformation[36];
    UCHAR CodeSet : 4;
    UCHAR Reserved10 : 4;
    UCHAR IDType : 4;
    UCHAR Reserved11 : 4;
    UCHAR Reserved12;
    UCHAR IDLength;
    UCHAR VendorID[VENDOR_ID_LENGTH];
    UCHAR ProductID[PRODUCT_ID_LENGTH];
    UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];
} HPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS, *PHPMO_DATA_XFER_ELEMENT_DESCRIPTOR_PLUS;


typedef struct _HPMO_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Reserved6[3];
    UCHAR Reserved7 : 7;
    UCHAR SValid : 1;
    UCHAR SourceElementAddress[2];
    UCHAR VolumeTagInformation[36];
} HPMO_ELEMENT_DESCRIPTOR_PLUS, *PHPMO_ELEMENT_DESCRIPTOR_PLUS;

typedef struct _PLASMON_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} PLASMON_ELEMENT_DESCRIPTOR, *PPLASMON_ELEMENT_DESCRIPTOR;

#define SCSIOP_ROTATE_MAILSLOT 0x0C

#define HP_MAILSLOT_OPEN       0x01
#define HP_MAILSLOT_CLOSE      0x00

#define HP_NO_ELEMENT          0xFFFF

//
// Diagnostic related defines
//
#define HPMC_DEVICE_PROBLEM_NONE     0x00
#define HPMC_HW_ERROR                0x01

typedef struct _HPMC_RECV_DIAG {
    UCHAR Reserved;
    UCHAR HWErrorCode;
    UCHAR FRU_1;
    UCHAR FRU_2;
    UCHAR FRU_3;
    UCHAR TestNumber;
    UCHAR Parameters[8];
} HPMC_RECV_DIAG, *PHPMC_RECV_DIAG;


#define HP_MO  1
#define HP_DLT 2

#define HP1194   1
#define HP1100   2
#define HP1160   3
#define HP1718   4
#define HP5151   5
#define HP5153   6
#define HP418    7
#define PLASMON  8
#define PINNACLE 9
#define HP7000   10


// Device features
#define DEVICE_DOOR (L"DeviceHasDoor")
#define DEVICE_IEPORT_USER_CLOSE (L"IEPortUserClose")

// Device names
#define HPMC_MEDIUM_CHANGER (L"HPMC")


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Device Status after send diagnostic is completed
    //
    ULONG DeviceStatus;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the HP units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Indicate whether to worry about the IEPort getting locked
    // down when a Prevent is sent.
    //

    ULONG DeviceLocksPort;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
HpmoBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

VOID ScanForSpecial(
    IN PDEVICE_OBJECT DeviceObject,
    IN PGET_CHANGER_PARAMETERS ChangerParameters
    );

VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer,
    IN ULONG changerId
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\jvcmc\jvcmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    jvcmc.c

Abstract:

    This module contains device-specific routines for JVC 1200/1600.

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "jvcmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, JVCBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Pioneer changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = JVCBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    DebugPrint((1,
               "ChangerError: Error on opcode %x\n",
               Srb->Cdb[0]));

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey) {
            case SCSI_SENSE_ABORTED_COMMAND:
                if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_POSITION_ERROR) {
                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                        *Status = STATUS_DESTINATION_ELEMENT_FULL;

                    } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                    } else {

                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;
                    }

                }

                break;

            case SCSI_SENSE_NOT_READY:
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
               changerData->HardwareError = TRUE;
               break;
            }

            case SCSI_SENSE_UNIT_ATTENTION:

                if (senseBuffer->AdditionalSenseCode != SCSI_ADSENSE_MEDIUM_CHANGED) {

                    //
                    // Reset/power-on clears any prevents.
                    //

                    InterlockedExchange(&changerData->LockCount, 0);
                }

                break;

            break;

        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));

    }
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK          srb;
    PGET_CHANGER_PARAMETERS      changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE  transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = JVC_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    changerParameters->MagazineSize = 50;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                 |
                                   CHANGER_STATUS_NON_VOLATILE         |
                                   CHANGER_POSITION_TO_ELEMENT         |
                                   CHANGER_CARTRIDGE_MAGAZINE          |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE;

    changerParameters->Features1 = CHANGER_SLOTS_USE_TRAYS | CHANGER_IEPORT_USER_CONTROL_CLOSE;

    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;
    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT  | CHANGER_TO_IEPORT | CHANGER_TO_DRIVE);

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The IEPort can be locked/unlocked.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {

            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            InterlockedExchange(&changerData->LockCount, 0);

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    ChangerClassFreePool(srb);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;
    ULONG    totalElements = 0;


    if (addressMapping->Initialized != TRUE) {

        DebugPrint((1,
                   "GetElementStatus: Not initialized, building address mapping\n"));
        status = JVCBuildAddressMapping(DeviceObject);
        if (!NT_SUCCESS(status)) {
            DebugPrint((1, "GetElementStatus: Address mapping failed %x\n",
                        status));
            return status;
        }
    }

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {

            DebugPrint((2,
                       "Jvc: NumberOfElements[%d] -> %d\n",
                       i,
                       addressMapping->NumberOfElements[i]));

            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];

        }

        //
        // Firmware workaround. Even though there aren't 6 drives, ask for info on them.
        //

        totalElements += (6 - addressMapping->NumberOfElements[ChangerDrive]);

        DebugPrint((2,
                   "Jvc: TotalElements - %d\n",
                   totalElements));

        //
        // Determine length of the descriptors expected for the elements.
        //

        length = (sizeof(JVC_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {


        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        length = (sizeof(JVC_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // Ensure that starting address is valid.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);



    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(elementStatus, sizeof(CHANGER_ELEMENT_STATUS) * numberElements);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                if (elementType == ChangerDrive) {
                    if (!elementDescriptor->Accessible) {
                        DebugPrint((1,
                                   "JVC: Drive not accessible\n"));

                        (ULONG_PTR)elementDescriptor += descriptorLength;
                        continue;
                    }
                }

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                if (elementType != ChangerIEPort) {
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                }

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                //
                // Map the exceptions.
                //

                if (elementDescriptor->Exception) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    } else {


        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport and dest. are within range.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    if ((setPosition->Destination.ElementType == AllElements) ||
        (setPosition->Destination.ElementType == ChangerTransport) ||
        (setPosition->Destination.ElementType > ChangerDrive) ) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Source.ElementType == ChangerIEPort) {

        //
        // JVC has a stealth address for closing the IEPort.
        //

        DebugPrint((2,
                   "Incing ieport address %x -> ",
                   source));

        source += 1;

        DebugPrint((2,"%x\n", source));

    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    if (lockValue) {

        NTSTATUS preventStatus;

        //
        // Send the prevent to re-lock down the unit.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        //
        // Ignore any errors at this point. The LM will fixup any problems with
        // prevent/allow
        //

        preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                srb,
                                NULL,
                                0,
                                FALSE);
        DebugPrint((1,
                   "MoveMedium: Prevent sent. Status %x\n",
                   preventStatus));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
JVCBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = JVC_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = JVC_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    } else {
        DebugPrint((1,
                   "JVCMC: AddressMapping not initialized\n"));
    }

    //
    // If the mode sense failed, first open of the device will get the information.
    //

    status = STATUS_SUCCESS;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x04:
        case 0x3A:

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "JVCMC: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == JVC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "JVCMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\nsmmc\nsmmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nsmmc.c

Abstract:

    This module contains device-specific routines for NSM Mercury Cd library devices

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "nsmmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, NSMBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the NSM changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = NSMBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"Mercury-40S",11) == 11) {
        changerData->DeviceID = MERCURY_40;
    }

    //
    // Get the Vital Product Data page.
    //

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIALNUMBER));
    if (!serialBuffer) {
        DebugPrint((1, "BuildAddressMapping failed. %x\n", status));

        ChangerClassFreePool(dataBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set EVPD
    //

    cdb->CDB6INQUIRY.Reserved1 = 1;

    //
    // Unit serial number page.
    //

    cdb->CDB6INQUIRY.PageCode = 0x80;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     serialBuffer,
                                     sizeof(SERIALNUMBER),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ULONG i;

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->SerialNumber, NSM_SERIAL_NUMBER_LENGTH);

        DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
        DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
        DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

        DebugPrint((1,"Serial number "));

        for (i = 0; i < NSM_SERIAL_NUMBER_LENGTH; i++) {
            DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
        }

        DebugPrint((1,"\n"));

    }


    ChangerClassFreePool(serialBuffer);
    ChangerClassFreePool(dataBuffer);


    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;



    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        switch (senseBuffer->SenseKey) {
            case SCSI_SENSE_NOT_READY:
                if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
                    (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)) {

                    //
                    // Indicate that the door is open.
                    //

                    *Status = STATUS_DEVICE_DOOR_OPEN;
                }
                break;

            case SCSI_SENSE_UNIT_ATTENTION: {

                InterlockedExchange(&changerData->LockCount, 0);

                if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_POSITION_ERROR) {
                    if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_SOURCE_EMPTY) {

                        DebugPrint((1,
                                    "NSMMC: The specified source element has no media\n"));

                        //
                        // The indicated source address has no media.
                        //

                        *Status = STATUS_SOURCE_ELEMENT_EMPTY;

                    } else if (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_DESTINATION_FULL) {

                        DebugPrint((1,
                                    "NSMMC: The specified destination element already has media.\n"));
                        //
                        // The indicated destination already contains media.
                        //

                        *Status = STATUS_DESTINATION_ELEMENT_FULL;
                    }
                }

                break;
            }

            case SCSI_SENSE_HARDWARE_ERROR: {
               DebugPrint((1, "HardwareError - SenseCode %x, ASC %x, ASCQ %x\n",
                           senseBuffer->SenseKey,
                           senseBuffer->AdditionalSenseCode,
                           senseBuffer->AdditionalSenseCodeQualifier));
               changerData->HardwareError = TRUE;

               break;
            }
        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    }
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = NSM_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 50;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_EXCHANGE_MEDIA              |
                                   CHANGER_LOCK_UNLOCK                 |
                                   CHANGER_CARTRIDGE_MAGAZINE          |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE |
                                   CHANGER_SERIAL_NUMBER_VALID;

    changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_CLOSE | 
                                   CHANGER_MOVE_EXTENDS_IEPORT;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT | CHANGER_TO_IEPORT);
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT);

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, NSM_SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataBuffer = NULL;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    switch (setAccess->Element.ElementType) {
        case ChangerIEPort:

            if (controlOperation == LOCK_ELEMENT) {

                //
                // Issue prevent media removal command to lock the door.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;

                //
                // Inc the lock count to indicate that a prevent is on the device.
                //

                InterlockedIncrement(&changerData->LockCount);

            } else if (controlOperation == UNLOCK_ELEMENT) {

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;

                InterlockedExchange(&changerData->LockCount, 0);

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        default:

            status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;
        ULONG totalElements = 0;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];
        }

        //
        // Determine length of the descriptors expected for the elements.
        //

        length = (sizeof(NSM_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {

        length = (sizeof(NSM_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // Ensure that starting address is valid.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) || 
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (typeCount > ((LONG)descriptorLength * remainingElements)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: DescriptorByteCount is hosed. Claimed: %x",
                        typeCount));

            typeCount = descriptorLength * remainingElements;

            DebugPrint((1," Actual: %x\n", typeCount));
        }

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (elementType == ChangerDrive) {

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                } else {

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                //
                // Map the exceptions.
                //

                if (elementDescriptor->Exception) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    if (elementStatus->ExceptionCode == 0) {

                        //
                        // For some reason an exception was noted that is not relevant.
                        //

                        elementStatus->Flags &=~ELEMENT_STATUS_EXCEPT;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    //
    // The Mercury doesn't support this.
    //

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;
    LONG                lockValue = 0;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    if (lockValue) {

        NTSTATUS preventStatus;

        //
        // Send the prevent to re-lock down the unit.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        //
        // Ignore any errors at this point. The LM will fixup any problems with
        // prevent/allow
        //

        preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                srb,
                                NULL,
                                0,
                                FALSE);
        DebugPrint((1,
                   "MoveMedium: Prevent sent. Status %x\n",
                   preventStatus));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
NSMBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = NSM_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = NSM_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x53:
            if (ascq == 0x02) {

                //
                // Reporting that medium removal is prevented.
                //

                exceptionCode = 0;

            }
            break;
        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "NSMMC: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == NSM_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   
   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "NSMMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\pnrmc\pnrmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pnrmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _PNR_MC_
#define _PNR_MC_

typedef struct _PNR_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 2;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 7;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} PNR_ELEMENT_DESCRIPTOR, *PPNR_ELEMENT_DESCRIPTOR;

#define PNR_NO_ELEMENT 0xFFFF

#define DRM_1004 0x01


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates the unit being supported.
    //

    ULONG DeviceID;

    //
    // Flag to indicate if diagnostic command failed or not
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
PNRBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\nsmmc\nsmmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    nsmmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _NSM_MC_
#define _NSM_MC_

typedef struct _NSM_STORAGE_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR ExEnable : 1;
    UCHAR InEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} NSM_ELEMENT_DESCRIPTOR, *PNSM_ELEMENT_DESCRIPTOR;

#define NSM_NO_ELEMENT 0xFFFF


#define NSM_SERIAL_NUMBER_LENGTH        12

typedef struct _SERIALNUMBER {
    UCHAR DeviceType : 5;
    UCHAR PeripheralQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[NSM_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;


#define MERCURY_40 0x01


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates the unit being supported.
    //

    ULONG DeviceID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the HP units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[NSM_SERIAL_NUMBER_LENGTH];

    //
    // Pad out to ULONG.
    //

    BOOLEAN HardwareError;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
NSMBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\plasmc\plasmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    hpmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _PLAS_MC_
#define _PLAS_MC_

typedef struct _PLASMON_DSERIES_UNIT_INFO_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR MaximumMagazines;
    UCHAR MaximumDrives;
    UCHAR NumberColumns;
    UCHAR Reserved1;
    UCHAR FlFWPartNumber[10];
    UCHAR FlFWCheckSum[2];
    UCHAR FlFWRev;
    UCHAR FlFWBuildFlags;
    UCHAR EPFWPartNumber[10];
    UCHAR EPFWRev[4];
    UCHAR EPFWCheckSum[2];
    UCHAR Reserved2[2];
} PLASMON_DSERIES_UNIT_INFO_PAGE, *PPLASMON_DSERIES_UNIT_INFO_PAGE;

typedef struct _PLASMON_FTA_UNIT_INFO_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR FWLevel;
    UCHAR HWLevel;
    UCHAR Reserved1 : 1;
    UCHAR BarCodes  : 1;
    UCHAR RedundantMTA : 1;
    UCHAR NoOfPassThrough : 2;
    UCHAR MaximumMagazines : 2;
    UCHAR Reserved2 : 1;
    UCHAR NumberOfSlots[2];
    UCHAR MaximumNoOfDrives;
    UCHAR NoOfColumns;
    UCHAR SlotsInColumn[10];
    UCHAR Reserved3[4];
    UCHAR FWPartNumber[10];
    UCHAR Reserved4[10];
    UCHAR FWChecksum[2];
    UCHAR Reserved5[2];
    UCHAR ElectronicSignature[6];
    UCHAR Reserved6[2];
} PLASMON_FTA_UNIT_INFO_PAGE, *PPLASMON_FTA_UNIT_INFO_PAGE;

typedef union _PLASMON_ELEMENT_DESCRIPTOR {
    struct {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR ImpExp : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR ExEnable : 1;
        UCHAR InEnable : 1;
        UCHAR Reserved4 : 2;
        UCHAR Reserved5;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved6 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved7 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved8;
        UCHAR Reserved9 : 7;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR BarCode[32];
        UCHAR Reserved11[8];
        UCHAR DriveSerialNumber[10];
    } PLASMON_FTA_DESCRIPTOR;

    struct {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR ImpExp : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR ExEnable : 1;
        UCHAR InEnable : 1;
        UCHAR Reserved4 : 2;
        UCHAR Reserved5;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved6 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved7 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved8;
        UCHAR Reserved9 : 7;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved10[4];
        UCHAR Changed : 1;
        UCHAR Magazine : 1;
        UCHAR Reserved11 : 3;
        UCHAR Volatile : 1;
        UCHAR PD : 1;
        UCHAR Tray : 1;
        UCHAR Reserved12;
    } PLASMON_DSERIES_DESCRIPTOR;

} PLASMON_ELEMENT_DESCRIPTOR, *PPLASMON_ELEMENT_DESCRIPTOR;

typedef struct _LIBRARY_MODE_PARAMS_PAGE2 {
    UCHAR PageCode;
    UCHAR ParameterLength;
    UCHAR Reserved1 : 1;
    UCHAR IgnoreParity : 1;
    UCHAR WaitLoad : 1;
    UCHAR NoDelay : 1;
    UCHAR LvClosed : 1;
    UCHAR LimitRec : 1;
    UCHAR AlwPdExp : 1;
    UCHAR NoRepRec : 1;
    UCHAR UnUsed[7]; // Some interesting bits, but we aren't using them at present.
} LIBRARY_MODE_PARAMS_PAGE2, *PLIBRARY_MODE_PARAMS_PAGE2;


typedef struct _READ_MAGAZINE_STATUS {
    UCHAR OperationCode;
    UCHAR Reserved1 : 5;
    UCHAR LogicalUnitNubmer : 3;
    UCHAR FirstMagazineNumber[2];
    UCHAR NumberOfMagazines[2];
    UCHAR Reserved2;
    UCHAR AllocationLength[3];
    UCHAR Reserved3;
} READ_MAGAZINE_STATUS, *PREAD_MAGAZINE_STATUS;

typedef struct _MAGAZINE_STATUS_HEADER {
    UCHAR FirstMagazineReported[2];
    UCHAR NumberOfMagazines[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} MAGAZINE_STATUS_HEADER, *PMAGAZINE_STATUS_HEADER;

typedef struct _MAGAZINE_DESCRIPTOR {
    UCHAR MagazineNumber;
    UCHAR FirstElementAddress[2];
    UCHAR Description;
} MAGAZINE_DESCRIPTOR, *PMAGAZINE_DESCRIPTOR;

//
// Bit defs of the description field in the magazine descriptor
// Some left out as they are presently unused.
//

#define MAGAZINE_FULL    0x01
#define MAGAZINE_CHANGED 0x04

#define MODE_PARAMS_PAGE2  0x20

#define SCSIOP_OPEN_IEPORT_DSERIES     0x0D
#define SCSIOP_OPEN_IEPORT_FTA         0x0C

#define SCSIOP_READ_MAG_STATUS_DSERIES 0xF8
#define SCSIOP_READ_MAG_STATUS_FTA     0xB9

#define PLASMON_MAILSLOT_OPEN  0x01
#define PLASMON_MAILSLOT_CLOSE 0x00

#define PLASMON_DSERIES_IEPORT_LOCK  0x40
#define PLASMON_FTA_IEPORT_LOCK      0x00

#define PLAS_NO_ELEMENT          0xFFFF

//
// Diagnostic error codes
//
// ASC
//
#define PLASMC_ASC_DIAGNOSTIC_FAILURE       0x40
#define PLASMC_ASC_INTERNAL_TARGET_FAILURE  0x44
#define PLASMC_ASC_VENDOR_UNIQUE            0x80

//
// ASCQ
//
#define PLASMC_ASCQ_PICKER_HOME_FAILURE         0x50
#define PLASMC_ASCQ_LIFT_BLOCKED_BY_TRAY        0x64

//
// DeviceStatus codes
//
#define PLASMC_DEVICE_PROBLEM_NONE              0x00
#define PLASMC_HW_ERROR                         0x01
#define PLASMC_TARGET_FAILURE                   0x02
#define PLASMC_CHM_MOVE_ERROR                   0x03


#define PLSMN_CD     1
#define PLSMN_TAPE   2

#define PLASMON_DSERIES  1
#define PLASMON_FTA      2

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Indicates the number of magazine slots available.
    //

    ULONG MagazineSlots;

    //
    // Indicates the number of slots in each magazine.
    //

    ULONG SlotsPerMag;

    //
    // Bitmap of available magazine locations.
    //

    ULONG MagazinePresent;

    //
    // Device status after a diagnostic test
    //
    ULONG DeviceStatus;

    //
    // FLAG set if we are building magazine map
    //
    BOOLEAN BuildMagazineMapInProgress;

    //
    // Flag to indicate if barcode reader is installed
    // or not
    //
    BOOLEAN BarCodeReaderInstalled;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


NTSTATUS
PlasmonBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

NTSTATUS
BuildMagazineMap(
    IN PDEVICE_OBJECT DeviceObject
    );

#endif // _PLAS_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\powerfil\powerfil.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    starmatx.c

Abstract:

    This module contains device-specific routines for StarMatix Powerfile
    changer device.
 
Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "powerfil.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, StarMatxBuildAddressMapping)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the StarMatix changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{
    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    changerData->DriveID = 0;
    changerData->DriveType = POWERFILE_DVD;

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = StarMatxBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}



VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    StarMatix changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    
    //
    // ISSUE : nramas 02/19/2001
    //         StarMatix firmware reports that there is one transport, but
    //         the device has none.
    //
    changerParameters->NumberTransportElements = 0;

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 0;

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = STARMATX_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    //
    // PowerFile C200 does not have a door
    //
    changerParameters->NumberOfDoors = 0;

    changerParameters->MagazineSize = 200;

    changerParameters->NumberCleanerSlots = 0;
    
    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //
    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //
    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= CHANGER_STATUS_NON_VOLATILE             |
                                    CHANGER_POSITION_TO_ELEMENT             |
                                    CHANGER_VOLUME_IDENTIFICATION           |
                                    CHANGER_VOLUME_REPLACE                  |
                                    CHANGER_VOLUME_ASSERT                   |
                                    CHANGER_VOLUME_SEARCH;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | 
                                               CHANGER_TO_SLOT  | 
                                               CHANGER_TO_IEPORT);

    //
    // Free buffer.
    //
    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // ISSUE: 03/03/2000 - nramas
    // Powerfile C200 is reporting that it can move media from IEPort to Drive & IEPort.
    // It also says it cannot move from slot to IEPort or Drive. This is reveresed. Till
    // we get a firmware fix for this, let's hard code that :
    //  Capable of moving media from Slot to IEPort & Drive
    //  Capable of moving media from IEPort to Slot
    //
    changerParameters->MoveFromSlot = (CHANGER_TO_DRIVE |
                                       CHANGER_TO_IEPORT);
    changerParameters->MoveFromIePort = CHANGER_TO_SLOT;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    //
    // SetAccess not supported by this changer
    //
    Irp->IoStatus.Information = 0;
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            length = sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        } else {

            length = sizeof(STARMATX_ELEMENT_DESCRIPTOR) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        if (readElementStatus->VolumeTagInfo) {

            length = (sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * totalElements);

        } else {

            length = (sizeof(STARMATX_ELEMENT_DESCRIPTOR) * totalElements);
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG remainingElements;
        ULONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        ULONG i;
        ULONG descriptorLength;

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements > totalElements ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements incorrect - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        typeCount /= descriptorLength;

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (tagInfo) {

                    PSTARMATX_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->PrimaryVolumeTag), 
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {

                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->AlternateVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->AlternateVolumeTag), 
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }


                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }

                } else {

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {
                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all spaces. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != ' ') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "Starmatx.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                typeCount /= descriptorLength;

            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    } else {

        ChangerClassFreePool(srb);
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // For now do nothing
    //
    Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    return STATUS_SUCCESS;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
   //
   // Not supported by this changer.
   // 
   return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    //
    // Reinitialize not supported by this changer
    //
    Irp->IoStatus.Information = 0;
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
   PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
   PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
   PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
   PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
   PSCSI_REQUEST_BLOCK srb;
   PVOID    tagBuffer;
   PVOID    statusBuffer;
   PCDB     cdb;
   NTSTATUS status;

   switch (volTagInfo->ActionCode) {
        case SEARCH_ALL      :
        case SEARCH_PRIMARY  :
        case SEARCH_ALTERNATE:
        case SEARCH_ALL_NO_SEQ:
        case SEARCH_PRI_NO_SEQ:
        case SEARCH_ALT_NO_SEQ:
        case UNDEFINE_PRIMARY:
        case UNDEFINE_ALTERNATE:
        case ASSERT_PRIMARY:
        case ASSERT_ALTERNATE:
             break;

        case REPLACE_PRIMARY:
        case REPLACE_ALTERNATE:

            //
            // Ensure that only one element is being specified.
            //

            if (element->ElementType == AllElements) {

                DebugPrint((1,
                           "QueryVolumeTags: Attempting REPLACE on AllElements\n"));

                return STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        default:

            DebugPrint((1,
                       "QueryVolumeTags: Unsupported operation. ActionCode %x\n",
                       volTagInfo->ActionCode));

            return STATUS_INVALID_DEVICE_REQUEST;
   }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;


    if ((volTagInfo->ActionCode == SEARCH_ALL)        ||
        (volTagInfo->ActionCode == SEARCH_PRIMARY)    ||
        (volTagInfo->ActionCode == SEARCH_ALTERNATE)  ||
        (volTagInfo->ActionCode == SEARCH_ALL_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_PRI_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_ALT_NO_SEQ)) {

        //
        // This is reserved for all other action codes.
        //

        cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);


    } else if ((volTagInfo->ActionCode == UNDEFINE_PRIMARY)   ||
               (volTagInfo->ActionCode == UNDEFINE_ALTERNATE)) {

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = 0;

    } else if ((volTagInfo->ActionCode == REPLACE_PRIMARY)   ||
               (volTagInfo->ActionCode == REPLACE_ALTERNATE) ||
               (volTagInfo->ActionCode == ASSERT_PRIMARY)    ||
               (volTagInfo->ActionCode == ASSERT_ALTERNATE)) {


        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);
    }


    if (element->ElementType == AllElements) {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     tagBuffer,
                                     MAX_VOLUME_TEMPLATE_SIZE,
                                     TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;
        PVOID statusBuffer;

        //
        // Size of buffer returned is based on the size of the user buffer. 
        // If it's incorrectly sized, the IoStatus.Information will be updated
        // to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        if (element->ElementType == AllElements) {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

        } else {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
        }

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS);

            }

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                ELEMENT_TYPE        elementType;

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //


                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                elementType = statusPage->ElementType;

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    PSTARMATX_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }


                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    //
                    // Map any exceptions reported directly.
                    // If there is volume info returned ensure that it's not all spaces
                    // as this indicates that the label is missing or unreadable.
                    //

                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                        //
                        // Map the exception.
                        //

                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->PrimaryVolumeTag), 
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->AlternateVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->AlternateVolumeTag),
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
StarMatxBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds
    an array of element addresses. These are used to translate between the 
    device-specific addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = STARMATX_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = STARMATX_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "StarMatx.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == STARMATX_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
    changerDeviceError->ChangerProblemType = DeviceProblemNone;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\plasmc\plasmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    plasmc.c

Abstract:

    This module contains device-specific routines for Plasmon medium changers:

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "plasmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, PlasmonBuildAddressMapping)
#pragma alloc_text(PAGE, BuildMagazineMap)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the plasmon D-Series changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PPLASMON_DSERIES_UNIT_INFO_PAGE dseriesUnitInfo = NULL;
    PPLASMON_FTA_UNIT_INFO_PAGE     ftaUnitInfo = NULL;
    PVOID          unitInfo = NULL;
    PVOID          modeBuffer;
    PLIBRARY_MODE_PARAMS_PAGE2 modePage2;
    PCDB           cdb;
    ULONG          length;
    UCHAR          sizeNeeded;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCa